  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">erl_scan</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">The Erlang token scanner.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module contains functions for tokenizing (scanning) characters into Erlang tokens.</p> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-category" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-category">category()</a> = atom()</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-error_description" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-error_description">error_description()</a> = term()</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-error_info" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-error_info">error_info()</a> = 
 {<a href="erl_anno.html#type-location">erl_anno:location()</a>, module(), <a href="#type-error_description">error_description()</a>}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-option" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-option">option()</a> = 
 return | return_white_spaces | return_comments | text |
 {reserved_word_fun, <a href="#type-resword_fun">resword_fun()</a>} |
 {text_fun, <a href="#type-text_fun">text_fun()</a>} |
 {compiler_internal, [term()]}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-options" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-options">options()</a> = <a href="#type-option">option()</a> | [<a href="#type-option">option()</a>]</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-symbol" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-symbol">symbol()</a> = atom() | float() | integer() | string()</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-resword_fun" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-resword_fun">resword_fun()</a> = fun((atom()) -&gt; boolean())</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-token" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-token">token()</a> = 
 {<a href="#type-category">category()</a>, Anno :: <a href="erl_anno.html#type-anno">erl_anno:anno()</a>, <a href="#type-symbol">symbol()</a>} |
 {<a href="#type-category">category()</a>, Anno :: <a href="erl_anno.html#type-anno">erl_anno:anno()</a>}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-tokens" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-tokens">tokens()</a> = [<a href="#type-token">token()</a>]</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-tokens_result" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-tokens_result">tokens_result()</a> = 
 {ok, Tokens :: <a href="#type-tokens">tokens()</a>, EndLocation :: <a href="erl_anno.html#type-location">erl_anno:location()</a>} |
 {eof, EndLocation :: <a href="erl_anno.html#type-location">erl_anno:location()</a>} |
 {error,
 ErrorInfo :: <a href="#type-error_info">error_info()</a>,
 EndLocation :: <a href="erl_anno.html#type-location">erl_anno:location()</a>}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-text_fun" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-text_fun">text_fun()</a> = fun((atom(), string()) -&gt; boolean())</code><br> </div> </h3> </article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="category-1" class="bold_code title-link func-head">  <code>category(Token) -&gt; <code><a href="#type-category">category()</a></code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Token = <a href="#type-token">token()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the category of <code>Token</code>.</p> </div></div></article><article class="func"><h3 id="column-1" class="bold_code title-link func-head">  <code>column(Token) -&gt; <code><a href="erl_anno.html#type-column">erl_anno:column()</a></code> | undefined</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Token = <a href="#type-token">token()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the column of <code>Token</code>'s collection of annotations.</p> </div></div></article><article class="func"><h3 id="end_location-1" class="bold_code title-link func-head">  <code>end_location(Token) -&gt; <code><a href="erl_anno.html#type-location">erl_anno:location()</a></code> | undefined</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Token = <a href="#type-token">token()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the end location of the text of <code>Token</code>'s collection of annotations. If there is no text, <code>undefined</code> is returned.</p> </div></div></article><article class="func"><h3 id="format_error-1" class="bold_code title-link func-head">  <code>format_error(ErrorDescriptor) -&gt; <code>string()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ErrorDescriptor = <a href="#type-error_description">error_description()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uses an <code>ErrorDescriptor</code> and returns a string that describes the error or warning. This function is usually called implicitly when an <code>ErrorInfo</code> structure is processed (see section <code><a href="#errorinfo">Error Information</a></code>).</p> </div></div></article><article class="func"><h3 id="line-1" class="bold_code title-link func-head">  <code>line(Token) -&gt; <code><a href="erl_anno.html#type-line">erl_anno:line()</a></code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Token = <a href="#type-token">token()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the line of <code>Token</code>'s collection of annotations.</p> </div></div></article><article class="func"><h3 id="location-1" class="bold_code title-link func-head">  <code>location(Token) -&gt; <code><a href="erl_anno.html#type-location">erl_anno:location()</a></code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Token = <a href="#type-token">token()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the location of <code>Token</code>'s collection of annotations.</p> </div></div></article><article class="func"><h3 id="reserved_word-1" class="bold_code title-link func-head">  <code>reserved_word(Atom :: <code>atom()</code>) -&gt; <code>boolean()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Atom</code> is an Erlang reserved word, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="string-1" class="bold_code title-link func-head">  <code>string(String) -&gt; Return</code> </h3> <h3 id="string-2" class="bold_code title-link func-head">  <code>string(String, StartLocation) -&gt; Return</code> </h3> <h3 id="string-3" class="bold_code title-link func-head">  <code>string(String, StartLocation, Options) -&gt; Return</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>String = string()</code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-options">options()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Return = 
 {ok, Tokens :: <a href="#type-tokens">tokens()</a>, EndLocation} |
 {error, ErrorInfo :: <a href="#type-error_info">error_info()</a>, ErrorLocation}</code></pre></div> <div class="REFTYPES rt-1"><code>StartLocation = EndLocation = ErrorLocation = <a href="erl_anno.html#type-location">erl_anno:location()</a></code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Takes the list of characters <code>String</code> and tries to scan (tokenize) them. Returns one of the following:</p> <dl> <dt class="title-link"><strong><code>{ok, Tokens, EndLocation}</code></strong></dt> <dd> <p><code>Tokens</code> are the Erlang tokens from <code>String</code>. <code>EndLocation</code> is the first location after the last token.</p> </dd> <dt class="title-link"><strong><code>{error, ErrorInfo, ErrorLocation}</code></strong></dt> <dd> <p>An error occurred. <code>ErrorLocation</code> is the first location after the erroneous token.</p> </dd> </dl> <p><code>string(String)</code> is equivalent to <code>string(String, 1)</code>, and <code>string(String, StartLocation)</code> is equivalent to <code>string(String, StartLocation, [])</code>.</p> <p><code>StartLocation</code> indicates the initial location when scanning starts. If <code>StartLocation</code> is a line, <code>Anno</code>, <code>EndLocation</code>, and <code>ErrorLocation</code> are lines. If <code>StartLocation</code> is a pair of a line and a column, <code>Anno</code> takes the form of an opaque compound data type, and <code>EndLocation</code> and <code>ErrorLocation</code> are pairs of a line and a column. The <strong>token annotations</strong> contain information about the column and the line where the token begins, as well as the text of the token (if option <code>text</code> is specified), all of which can be accessed by calling <code><a href="#column-1">column/1</a></code>, <code><a href="#line-1">line/1</a></code>, <code><a href="#location-1">location/1</a></code>, and <code><a href="#text-1">text/1</a></code>.</p> <p>A <strong>token</strong> is a tuple containing information about syntactic category, the token annotations, and the terminal symbol. For punctuation characters (such as <code>;</code> and <code>|</code>) and reserved words, the category and the symbol coincide, and the token is represented by a two-tuple. Three-tuples have one of the following forms:</p> <ul> <li><code>{atom, Anno, atom()}</code></li> <li><code>{char, Anno, char()}</code></li> <li><code>{comment, Anno, string()}</code></li> <li><code>{float, Anno, float()}</code></li> <li><code>{integer, Anno, integer()}</code></li> <li><code>{var, Anno, atom()}</code></li> <li><code>{white_space, Anno, string()}</code></li> </ul> <p>Valid options:</p> <dl> <dt class="title-link"><strong><code>{reserved_word_fun, reserved_word_fun()}</code></strong></dt> <dd> <p>A callback function that is called when the scanner has found an unquoted atom. If the function returns <code>true</code>, the unquoted atom itself becomes the category of the token. If the function returns <code>false</code>, <code>atom</code> becomes the category of the unquoted atom.</p> </dd> <dt class="title-link"><strong><code>return_comments</code></strong></dt> <dd> <p>Return comment tokens.</p> </dd> <dt class="title-link"><strong><code>return_white_spaces</code></strong></dt> <dd> <p>Return white space tokens. By convention, a newline character, if present, is always the first character of the text (there cannot be more than one newline in a white space token).</p> </dd> <dt class="title-link"><strong><code>return</code></strong></dt> <dd> <p>Short for <code>[return_comments, return_white_spaces]</code>.</p> </dd> <dt class="title-link"><strong><code id="text">text</code></strong></dt> <dd> <p>Include the token text in the token annotation. The text is the part of the input corresponding to the token. See also <code><a href="#text_fun">text_fun</a></code>.</p> </dd> <dt class="title-link"><strong><code id="text_fun">{text_fun, text_fun()}</code></strong></dt> <dd> <p>A callback function used to determine whether the full text for the token shall be included in the token annotation. Arguments of the function are the category of the token and the full token string. This is only used when <code><a href="#text">text</a></code> is not present. If neither are present the text will not be saved in the token annotation.</p> </dd> <dt class="title-link"><strong> <code id="compiler_interal">{compiler_internal, term()}</code> </strong></dt> <dd> <p>Pass compiler-internal options to the scanner. The set of internal options understood by the scanner should be considered experimental and can thus be changed at any time without prior warning.</p> <p>The following options are currently understood:</p> <dl> <dt class="title-link"><strong><code>ssa_checks</code></strong></dt> <dd> <p>Tokenizes source code annotations used for encoding tests on the BEAM SSA code produced by the compiler.</p> </dd> </dl> </dd> </dl> </div></div></article><article class="func"><h3 id="symbol-1" class="bold_code title-link func-head">  <code>symbol(Token) -&gt; <code><a href="#type-symbol">symbol()</a></code></code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Token = <a href="#type-token">token()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the symbol of <code>Token</code>.</p> </div></div></article><article class="func"><h3 id="text-1" class="bold_code title-link func-head">  <code>text(Token) -&gt; <code><a href="erl_anno.html#type-text">erl_anno:text()</a></code> | undefined</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Token = <a href="#type-token">token()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the text of <code>Token</code>'s collection of annotations. If there is no text, <code>undefined</code> is returned.</p> </div></div></article><article class="func"><h3 id="tokens-3" class="bold_code title-link func-head">  <code>tokens(Continuation, CharSpec, StartLocation) -&gt; Return</code> </h3> <h3 id="tokens-4" class="bold_code title-link func-head">  <code>tokens(Continuation, CharSpec, StartLocation, Options) -&gt; Return</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Continuation = return_cont() | []</code></div> <div class="REFTYPES rt-1"><code>CharSpec = char_spec()</code></div> <div class="REFTYPES rt-1"><code>StartLocation = <a href="erl_anno.html#type-location">erl_anno:location()</a></code></div> <div class="REFTYPES rt-1"><code>Options = <a href="#type-options">options()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Return = 
 {done,
 Result :: <a href="#type-tokens_result">tokens_result()</a>,
 LeftOverChars :: char_spec()} |
 {more, Continuation1 :: return_cont()}</code></pre></div> <div class="REFTYPES rt-2"> <code>char_spec() = string() | eof</code><br> </div> <div class="REFTYPES rt-2"> <code>return_cont()</code><br> </div> <div class="REFBODY rb-1">An opaque continuation.</div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>This is the re-entrant scanner, which scans characters until either a <strong>dot</strong> ('.' followed by a white space) or <code>eof</code> is reached. It returns:</p> <dl> <dt class="title-link"><strong><code>{done, Result, LeftOverChars}</code> </strong></dt> <dd> <p>Indicates that there is sufficient input data to get a result. <code>Result</code> is:</p> <dl> <dt class="title-link"><strong><code>{ok, Tokens, EndLocation}</code></strong></dt> <dd> <p>The scanning was successful. <code>Tokens</code> is the list of tokens including <strong>dot</strong>.</p> </dd> <dt class="title-link"><strong><code>{eof, EndLocation}</code></strong></dt> <dd> <p>End of file was encountered before any more tokens.</p> </dd> <dt class="title-link"><strong><code>{error, ErrorInfo, EndLocation}</code></strong></dt> <dd> <p>An error occurred. <code>LeftOverChars</code> is the remaining characters of the input data, starting from <code>EndLocation</code>.</p> </dd> </dl> </dd> <dt class="title-link"><strong><code>{more, Continuation1}</code></strong></dt> <dd> <p>More data is required for building a term. <code>Continuation1</code> must be passed in a new call to <code>tokens/3,4</code> when more data is available.</p> </dd> </dl> <p>The <code>CharSpec</code> <code>eof</code> signals end of file. <code>LeftOverChars</code> then takes the value <code>eof</code> as well.</p> <p><code>tokens(Continuation, CharSpec, StartLocation)</code> is equivalent to <code>tokens(Continuation, CharSpec, StartLocation, [])</code>.</p> <p>For a description of the options, see <code><a href="#string-3">string/3</a></code>.</p> </div></div></article> </div> <section class="innertube"><h2 id="error-information" class="title-link"> <div class="title-name">Error Information</div>  </h2> <div class="REFBODY rb-3"> <p><code>ErrorInfo</code> is the standard <code>ErrorInfo</code> structure that is returned from all I/O modules. The format is as follows:</p> <pre data-language="erlang">{ErrorLocation, Module, ErrorDescriptor}</pre> <p>A string describing the error is obtained with the following call:</p> <pre data-language="erlang">Module:format_error(ErrorDescriptor)</pre> </div></section> <section class="innertube"><h2 id="notes" class="title-link"> <div class="title-name">Notes</div>  </h2> <div class="REFBODY rb-3"> <p>The continuation of the first call to the re-entrant input functions must be <code>[]</code>. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding and Williams: 'Concurrent Programming in Erlang', Chapter 13.</p> </div></section> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p><code><a href="erl_anno.html">erl_anno(3)</a></code>, <code><a href="erl_parse.html">erl_parse(3)</a></code>, <code><a href="io.html">io(3)</a></code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
