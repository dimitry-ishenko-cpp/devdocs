  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">proc_lib</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Functions for asynchronous and synchronous start of processes adhering to the OTP design principles.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module is used to start processes adhering to the <code> OTP Design Principles</code>. Specifically, the functions in this module are used by the OTP standard behaviors (for example, <code>gen_server</code> and <code>gen_statem</code>) when starting new processes. The functions can also be used to start <strong>special processes</strong>, user-defined processes that comply to the OTP design principles. For an example, see section <code> sys and proc_lib</code> in OTP Design Principles.</p> <p>Some useful information is initialized when a process starts. The registered names, or the process identifiers, of the parent process, and the parent ancestors, are stored together with information about the function initially called in the process.</p> <p>While in "plain Erlang", a process is said to terminate normally only for exit reason <code>normal</code>, a process started using <code>proc_lib</code> is also said to terminate normally if it exits with reason <code>shutdown</code> or <code>{shutdown,Term}</code>. <code>shutdown</code> is the reason used when an application (supervision tree) is stopped.</p> <p>When a process that is started using <code>proc_lib</code> terminates abnormally (that is, with another exit reason than <code>normal</code>, <code>shutdown</code>, or <code>{shutdown,Term}</code>), a <strong>crash report</strong> is generated, which is written to terminal by the default logger handler setup by Kernel. For more information about how crash reports were logged prior to Erlang/OTP 21.0, see <code>SASL Error Logging</code> in the SASL User's Guide.</p> <p>Unlike in "plain Erlang", <code>proc_lib</code> processes will not generate <strong>error reports</strong>, which are written to the terminal by the emulator. All exceptions are converted to <strong>exits</strong> which are ignored by the default <code>logger</code> handler.</p> <p>The crash report contains the previously stored information, such as ancestors and initial function, the termination reason, and information about other processes that terminate as a result of this process terminating.</p> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-spawn_option" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-spawn_option">spawn_option()</a> = erlang:spawn_opt_option()</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>See <code> erlang:spawn_opt/2,3,4,5</code>.</p> </div></div></article> <article class="data-types-body"><h3 id="type-start_spawn_option" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-start_spawn_option">start_spawn_option()</a> = 
 link |
 {priority, erlang:priority_level()} |
 {fullsweep_after, integer() &gt;= 0} |
 {min_heap_size, integer() &gt;= 0} |
 {min_bin_vheap_size, integer() &gt;= 0} |
 {max_heap_size, erlang:max_heap_size()} |
 {message_queue_data, erlang:message_queue_data()}</code></pre>
<br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>A restricted set of <code><a href="#type-spawn_option">spawn options</a></code>. Most notably <code>monitor</code> is <strong>not</strong> part of these options.</p> </div></div></article> <article class="data-types-body"><h3 id="type-dict_or_pid" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-dict_or_pid">dict_or_pid()</a> = 
 pid() |
 (ProcInfo :: [term()]) |
 {X :: integer(), Y :: integer(), Z :: integer()}</code></pre>
<br> </div> </h3> </article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="format-1" class="bold_code title-link func-head">  <code>format(CrashReport) -&gt; <code>string()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>CrashReport = [term()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Equivalent to <code><a href="#format-2"> format(CrashReport, latin1)</a></code>.</p> </div></div></article><article class="func"><h3 id="format-2" class="bold_code title-link func-head">  <code>format(CrashReport, Encoding) -&gt; <code>string()</code></code><div class="title-since"><span class="since">OTP R16B</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>CrashReport = [term()]</code></div> <div class="REFTYPES rt-1"><code>Encoding = latin1 | unicode | utf8</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function is deprecated in the sense that the <code>error_logger</code> is no longer the preferred interface for logging in Erlang/OTP. A new <code>logging API</code> was added in Erlang/OTP 21.0, but legacy <code>error_logger</code> handlers can still be used. New Logger handlers do not need to use this function, since the formatting callback (<code>report_cb</code>) is included as metadata in the log event.</p> </div> </div> <p>This function can be used by a user-defined legacy <code>error_logger</code> event handler to format a crash report. The crash report is sent using <code> logger(3)</code>, and the event to be handled is of the format <code>{error_report, GL, {Pid, crash_report, CrashReport}}</code>, where <code>GL</code> is the group leader pid of process <code>Pid</code> that sent the crash report.</p> </div></div></article><article class="func"><h3 id="format-3" class="bold_code title-link func-head">  <code>format(CrashReport, Encoding, Depth) -&gt; <code>string()</code></code><div class="title-since"><span class="since">OTP 18.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>CrashReport = [term()]</code></div> <div class="REFTYPES rt-1"><code>Encoding = latin1 | unicode | utf8</code></div> <div class="REFTYPES rt-1"><code>Depth = unlimited | integer() &gt;= 1</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function is deprecated in the sense that the <code>error_logger</code> is no longer the preferred interface for logging in Erlang/OTP. A new <code>logging API</code> was added in Erlang/OTP 21.0, but legacy <code>error_logger</code> handlers can still be used. New Logger handlers do not need to used this function, since the formatting callback (<code>report_cb</code>) is included as metadata in the log event.</p> </div> </div> <p>This function can be used by a user-defined legacy <code>error_logger</code> event handler to format a crash report. When Depth is specified as a positive integer, it is used in the format string to limit the output as follows: <code>io_lib:format("~P", [Term,Depth])</code>.</p> </div></div></article><article class="func"><h3 id="hibernate-3" class="bold_code title-link func-head">  <code>hibernate(Module, Function, Args) -&gt; <code>no_return()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Function = atom()</code></div> <div class="REFTYPES rt-1"><code>Args = [term()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>This function does the same as (and does call) the <code> hibernate/3</code> BIF, but ensures that exception handling and logging continues to work as expected when the process wakes up.</p> <p>Always use this function instead of the BIF for processes started using <code>proc_lib</code> functions.</p> </div></div></article><article class="func"><h3 id="init_ack-1" class="bold_code title-link func-head">  <code>init_ack(Ret) -&gt; ok</code> </h3> <h3 id="init_ack-2" class="bold_code title-link func-head">  <code>init_ack(Parent, Ret) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Parent = pid()</code></div> <div class="REFTYPES rt-1"><code>Ret = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> This function must only be used by a process that has been started by a <code><a href="#start-3">start[_link|_monitor]/3,4,5</a></code> function. It tells <code>Parent</code> that the process has initialized itself and started. </p> <p>Function <code>init_ack/1</code> uses the parent value previously stored by the start function used.</p> <p> If neither this function nor <code><a href="#init_fail-2">init_fail/2,3</a></code> is called by the started process, the start function returns an error tuple when the started process exits, or when the start function time-out (if used) has passed, see <code><a href="#start-3">start/3,4,5</a></code>. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> Do not use this function to return an error indicating that the process start failed. When doing so the start function can return before the failing process has exited, which may block VM resources required for a new start attempt to succeed. Use <code><a href="#init_fail-2">init_fail/2,3</a></code> for that purpose. </p> </div> </div> <p>The following example illustrates how this function and <code>proc_lib:start_link/3</code> are used:</p> <pre data-language="erlang">-module(my_proc).
-export([start_link/0]).
-export([init/1]).

start_link() -&gt;
    proc_lib:start_link(my_proc, init, [self()]).

init(Parent) -&gt;
    case do_initialization() of
        ok -&gt;
            proc_lib:init_ack(Parent, {ok, self()});
        {error, Reason} -&gt;
            exit(Reason)
    end,
    loop().

...</pre> </div></div></article><article class="func"><div class="bold_code func-head"><h3 id="init_fail-2" class="title-link">  <div class="title-name">init_fail(Ret, Exception) -&gt; no_return()</div> <div class="title-since"><span class="since">OTP 26.0</span></div> </h3></div> <div class="bold_code func-head"><h3 id="init_fail-3" class="title-link">  <div class="title-name">init_fail(Parent, Ret, Exception) -&gt; no_return()</div> <div class="title-since"><span class="since">OTP 26.0</span></div> </h3></div> <div class="exports-tube"> <div class="REFBODY rb-5"> <h2 id="types" class="func-types-title">Types</h2> <div class="REFTYPES rt-4"> <code>Parent = pid()</code><br> </div> <div class="REFTYPES rt-4"> <code>Ret = term()</code><br> </div> <div class="REFTYPES rt-4"> <code>Exception = {Class, Reason} | {Class, Reason, Stacktrace}</code><br> </div> </div> <div class="REFBODY rb-7"> <p> This function must only be used by a process that has been started by a <code><a href="#start-3">start[_link|_monitor]/3,4,5</a></code> function. It tells <code>Parent</code> that the process has failed to initialize, and immediately raises an exception according to <code>Exception</code>. The start function then returns <code>Ret</code>. </p> <p> See <code>erlang:raise/3</code> for a description of <code>Class</code>, <code>Reason</code> and <code>Stacktrace</code>. </p> <p> Function <code>init_fail/2</code> uses the parent value previously stored by the start function used. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> Do not consider catching the exception from this function. That would defeat its purpose. A process started by a <code><a href="#start-3">start[_link|_monitor]/3,4,5</a></code> function should end in a value (that will be ignored) or an exception that will be handled by this module. See <code><a href="#description">Description</a></code>. </p> </div> </div> <p> If neither this function nor <code><a href="#init_ack-1">init_ack/1,2</a></code> is called by the started process, the start function returns an error tuple when the started process exits, or when the start function time-out (if used) has passed, see <code><a href="#start-3">start/3,4,5</a></code>. </p> <p>The following example illustrates how this function and <code>proc_lib:start_link/3</code> can be used:</p> <pre data-language="erlang">-module(my_proc).
-export([start_link/0]).
-export([init/1]).

start_link() -&gt;
    proc_lib:start_link(my_proc, init, [self()]).

init(Parent) -&gt;
    case do_initialization() of
        ok -&gt;
            proc_lib:init_ack(Parent, {ok, self()});
        {error, Reason} = Error -&gt;
            proc_lib:init_fail(Parent, Error, {exit, normal})
    end,
    loop().

...</pre> </div> </div></article><article class="func"><h3 id="initial_call-1" class="bold_code title-link func-head">  <code>initial_call(Process) -&gt; {Module, Function, Args} | false</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Process = <a href="#type-dict_or_pid">dict_or_pid()</a></code></div> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Function = atom()</code></div> <div class="REFTYPES rt-1"><code>Args = [atom()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Extracts the initial call of a process that was started using one of the spawn or start functions in this module. <code>Process</code> can either be a pid, an integer tuple (from which a pid can be created), or the process information of a process <code>Pid</code> fetched through an <code>erlang:process_info(Pid)</code> function call.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The list <code>Args</code> no longer contains the arguments, but the same number of atoms as the number of arguments; the first atom is <code>'Argument__1'</code>, the second <code>'Argument__2'</code>, and so on. The reason is that the argument list could waste a significant amount of memory, and if the argument list contained funs, it could be impossible to upgrade the code for the module.</p> <p>If the process was spawned using a fun, <code>initial_call/1</code> no longer returns the fun, but the module, function for the local function implementing the fun, and the arity, for example, <code>{some_module,-work/3-fun-0-,0}</code> (meaning that the fun was created in function <code>some_module:work/3</code>). The reason is that keeping the fun would prevent code upgrade for the module, and that a significant amount of memory could be wasted.</p> </div> </div> </div></div></article><article class="func"><h3 id="spawn-1" class="bold_code title-link func-head">  <code>spawn(Fun) -&gt; <code>pid()</code></code> </h3> <h3 id="spawn-2" class="bold_code title-link func-head">  <code>spawn(Node, Fun) -&gt; <code>pid()</code></code> </h3> <h3 id="spawn-3" class="bold_code title-link func-head">  <code>spawn(Module, Function, Args) -&gt; <code>pid()</code></code> </h3> <h3 id="spawn-4" class="bold_code title-link func-head">  <code>spawn(Node, Module, Function, Args) -&gt; <code>pid()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Node = node()</code></div> <div class="REFTYPES rt-1"><code>Fun = function()</code></div> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Function = atom()</code></div> <div class="REFTYPES rt-1"><code>Args = [term()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Spawns a new process and initializes it as described in the beginning of this manual page. The process is spawned using the <code>spawn</code> BIFs.</p> </div></div></article><article class="func"><h3 id="spawn_link-1" class="bold_code title-link func-head">  <code>spawn_link(Fun) -&gt; <code>pid()</code></code> </h3> <h3 id="spawn_link-2" class="bold_code title-link func-head">  <code>spawn_link(Node, Fun) -&gt; <code>pid()</code></code> </h3> <h3 id="spawn_link-3" class="bold_code title-link func-head">  <code>spawn_link(Module, Function, Args) -&gt; <code>pid()</code></code> </h3> <h3 id="spawn_link-4" class="bold_code title-link func-head">  <code>spawn_link(Node, Module, Function, Args) -&gt; <code>pid()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Node = node()</code></div> <div class="REFTYPES rt-1"><code>Fun = function()</code></div> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Function = atom()</code></div> <div class="REFTYPES rt-1"><code>Args = [term()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Spawns a new process and initializes it as described in the beginning of this manual page. The process is spawned using the <code>spawn_link</code> BIFs.</p> </div></div></article><article class="func"><h3 id="spawn_opt-2" class="bold_code title-link func-head">  <code>spawn_opt(Fun, SpawnOpts) -&gt; <code>pid()</code> | {<code>pid()</code>, <code>reference()</code>}</code> </h3> <h3 id="spawn_opt-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>spawn_opt(Node, Function, SpawnOpts) -&gt;
 <code>pid()</code> | {<code>pid()</code>, <code>reference()</code>}</code></pre> </h3> <h3 id="spawn_opt-4" class="bold_code title-link func-head">  <pre data-language="erlang"><code>spawn_opt(Module, Function, Args, SpawnOpts) -&gt;
 <code>pid()</code> | {<code>pid()</code>, <code>reference()</code>}</code></pre> </h3> <h3 id="spawn_opt-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>spawn_opt(Node, Module, Function, Args, SpawnOpts) -&gt;
 <code>pid()</code> | {<code>pid()</code>, <code>reference()</code>}</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Node = node()</code></div> <div class="REFTYPES rt-1"><code>Fun = function()</code></div> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Function = atom()</code></div> <div class="REFTYPES rt-1"><code>Args = [term()]</code></div> <div class="REFTYPES rt-1"><code>SpawnOpts = [<a href="#type-spawn_option">spawn_option()</a>]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Spawns a new process and initializes it as described in the beginning of this manual page. The process is spawned using the <code>erlang:spawn_opt</code> BIFs.</p> </div></div></article><article class="func"><h3 id="start-3" class="bold_code title-link func-head">  <code>start(Module, Function, Args) -&gt; Ret</code> </h3> <h3 id="start-4" class="bold_code title-link func-head">  <code>start(Module, Function, Args, Time) -&gt; Ret</code> </h3> <h3 id="start-5" class="bold_code title-link func-head">  <code>start(Module, Function, Args, Time, SpawnOpts) -&gt; Ret</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Function = atom()</code></div> <div class="REFTYPES rt-1"><code>Args = [term()]</code></div> <div class="REFTYPES rt-1"><code>Time = timeout()</code></div> <div class="REFTYPES rt-1"><code>SpawnOpts = [<a href="#type-start_spawn_option">start_spawn_option()</a>]</code></div> <div class="REFTYPES rt-1"><code>Ret = term() | {error, Reason :: term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Starts a new process synchronously. Spawns the process and waits for it to start. </p> <p> To indicate a succesful start, the started process <strong>must</strong> call <code><a href="#init_ack-2">init_ack(Parent, Ret)</a></code> where <code>Parent</code> is the process that evaluates this function, or <code><a href="#init_ack-1">init_ack(Ret)</a></code>. <code>Ret</code> is then returned by this function. </p> <p> If the process fails to start, it <strong>must</strong> fail; preferably by calling <code><a href="#init_fail-3"> init_fail(Parent, Ret, Exception) </a></code> where <code>Parent</code> is the process that evaluates this function, or <code><a href="#init_fail-2">init_fail(Ret, Exception)</a></code>. <code>Ret</code> is then returned by this function, and the started process fails with <code>Exception</code>. </p> <p> If the process instead fails before calling <code>init_ack/1,2</code> or <code>init_fail/2,3</code>, this function returns <code>{error, Reason}</code> where <code>Reason</code> depends a bit on the exception just like for a process link <code>{'EXIT',Pid,Reason}</code> message. </p> <p>If <code>Time</code> is specified as an integer, this function waits for <code>Time</code> milliseconds for the new process to call <code>init_ack/1,2</code> or <code>init_fail/2,3</code>, otherwise the process gets killed and <code>Ret = {error, timeout}</code> is returned.</p> <p>Argument <code>SpawnOpts</code>, if specified, is passed as the last argument to the <code> spawn_opt/2,3,4,5</code> BIF.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Using spawn option <code>monitor</code> is not allowed. It causes the function to fail with reason <code>badarg</code>.</p> <p> Using spawn option <code>link</code> will set a link to the spawned process, just like <code><a href="#start_link-3">start_link/3,4,5</a></code>. </p> </div> </div> </div></div></article><article class="func"><h3 id="start_link-3" class="bold_code title-link func-head">  <code>start_link(Module, Function, Args) -&gt; Ret</code> </h3> <h3 id="start_link-4" class="bold_code title-link func-head">  <code>start_link(Module, Function, Args, Time) -&gt; Ret</code> </h3> <h3 id="start_link-5" class="bold_code title-link func-head">  <code>start_link(Module, Function, Args, Time, SpawnOpts) -&gt; Ret</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Function = atom()</code></div> <div class="REFTYPES rt-1"><code>Args = [term()]</code></div> <div class="REFTYPES rt-1"><code>Time = timeout()</code></div> <div class="REFTYPES rt-1"><code>SpawnOpts = [<a href="#type-start_spawn_option">start_spawn_option()</a>]</code></div> <div class="REFTYPES rt-1"><code>Ret = term() | {error, Reason :: term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Starts a new process synchronously. Spawns the process and waits for it to start. A link is atomically set on the newly spawned process. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> If the started process gets killed or crashes with a reason that is not `normal`, the process link will kill the calling process so this function does not return, unless the calling process traps exits. For example, if this function times out it will kill the spawned process, and then the link might kill the calling process. </p> </div> </div> <p> Besides setting a link on the spawned process this function behaves like <code><a href="#start-3">start/3,4,5</a></code>. </p> <p> When the calling process traps exits; if this function returns due to the spawned process exiting (any error return), this function receives (consumes) the <code>'EXIT'</code> message, also when this function times out and kills the spawned process. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Using spawn option <code>monitor</code> is not allowed. It causes the function to fail with reason <code>badarg</code>.</p> </div> </div> </div></div></article><article class="func"><h3 id="start_monitor-3" class="bold_code title-link func-head">  <code>start_monitor(Module, Function, Args) -&gt; {Ret, Mon}</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <h3 id="start_monitor-4" class="bold_code title-link func-head">  <code>start_monitor(Module, Function, Args, Time) -&gt; {Ret, Mon}</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <h3 id="start_monitor-5" class="bold_code title-link func-head">  <pre data-language="erlang"><code>start_monitor(Module, Function, Args, Time, SpawnOpts) -&gt;
 {Ret, Mon}</code></pre>
<div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Function = atom()</code></div> <div class="REFTYPES rt-1"><code>Args = [term()]</code></div> <div class="REFTYPES rt-1"><code>Time = timeout()</code></div> <div class="REFTYPES rt-1"><code>SpawnOpts = [<a href="#type-start_spawn_option">start_spawn_option()</a>]</code></div> <div class="REFTYPES rt-1"><code>Mon = reference()</code></div> <div class="REFTYPES rt-1"><code>Ret = term() | {error, Reason :: term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Starts a new process synchronously. Spawns the process and waits for it to start. A monitor is atomically set on the newly spawned process. </p> <p> Besides setting a monitor on the spawned process this function behaves like <code><a href="#start-3">start/3,4,5</a></code>. </p> <p> The return value is <code>{Ret, Mon}</code> where <code>Ret</code> corresponds to the <code>Ret</code> argument in the call to <code>init_ack/1,2</code> or <code>init_fail/2,3</code>, and <code>Mon</code> is the monitor reference of the monitor that has been set up. </p> <p> If this function returns due to the spawned process exiting, that is returns any error value, a <code>'DOWN'</code> message will be delivered to the calling process, also when this function times out and kills the spawned process. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Using spawn option <code>monitor</code> is not allowed. It causes the function to fail with reason <code>badarg</code>. </p> <p> Using spawn option <code>link</code> will set a link to the spawned process, just like <code><a href="#start_link-3">start_link/3,4,5</a></code>. </p> </div> </div> </div></div></article><article class="func"><h3 id="stop-1" class="bold_code title-link func-head">  <code>stop(Process) -&gt; ok</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Process = pid() | RegName | {RegName, node()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Equivalent to <code><a href="#stop-3"> stop(Process, normal, infinity)</a></code>.</p> </div></div></article><article class="func"><h3 id="stop-3" class="bold_code title-link func-head">  <code>stop(Process, Reason, Timeout) -&gt; ok</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Process = pid() | RegName | {RegName, node()}</code></div> <div class="REFTYPES rt-1"><code>Reason = term()</code></div> <div class="REFTYPES rt-1"><code>Timeout = timeout()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Orders the process to exit with the specified <code>Reason</code> and waits for it to terminate.</p> <p>Returns <code>ok</code> if the process exits with the specified <code>Reason</code> within <code>Timeout</code> milliseconds.</p> <p>If the call times out, a <code>timeout</code> exception is raised.</p> <p>If the process does not exist, a <code>noproc</code> exception is raised.</p> <p>The implementation of this function is based on the <code>terminate</code> system message, and requires that the process handles system messages correctly. For information about system messages, see <code><a href="sys.html">sys(3)</a></code> and section <code> sys and proc_lib</code> in OTP Design Principles.</p> </div></div></article><article class="func"><h3 id="translate_initial_call-1" class="bold_code title-link func-head">  <code>translate_initial_call(Process) -&gt; {Module, Function, Arity}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Process = <a href="#type-dict_or_pid">dict_or_pid()</a></code></div> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Function = atom()</code></div> <div class="REFTYPES rt-1"><code>Arity = byte()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>This function is used by functions <code><a href="c.html#i-0">c:i/0</a></code> and <code><a href="c.html#regs-0">c:regs/0</a></code> to present process information.</p> <p>This function extracts the initial call of a process that was started using one of the spawn or start functions in this module, and translates it to more useful information. <code>Process</code> can either be a pid, an integer tuple (from which a pid can be created), or the process information of a process <code>Pid</code> fetched through an <code>erlang:process_info(Pid)</code> function call.</p> <p>If the initial call is to one of the system-defined behaviors such as <code>gen_server</code> or <code>gen_event</code>, it is translated to more useful information. If a <code>gen_server</code> is spawned, the returned <code>Module</code> is the name of the callback module and <code>Function</code> is <code>init</code> (the function that initiates the new server).</p> <p>A <code>supervisor</code> and a <code>supervisor_bridge</code> are also <code>gen_server</code> processes. To return information that this process is a supervisor and the name of the callback module, <code>Module</code> is <code>supervisor</code> and <code>Function</code> is the name of the supervisor callback module. <code>Arity</code> is <code>1</code>, as the <code>init/1</code> function is called initially in the callback module.</p> <p>By default, <code>{proc_lib,init_p,5}</code> is returned if no information about the initial call can be found. It is assumed that the caller knows that the process has been spawned with the <code>proc_lib</code> module.</p> </div></div></article> </div> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p><code> error_logger(3)</code></p> <p><code> logger(3)</code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
