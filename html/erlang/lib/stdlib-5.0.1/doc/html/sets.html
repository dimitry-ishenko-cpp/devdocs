  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">sets</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Functions for set manipulation.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>Sets are collections of elements with no duplicate elements.</p> <p>The data representing a set as used by this module is to be regarded as opaque by other modules. In abstract terms, the representation is a composite type of existing Erlang terms. See note on <code>data types</code>. Any code assuming knowledge of the format is running on thin ice.</p> <p>This module provides the same interface as the <code><a href="ordsets.html">ordsets(3)</a></code> module but with an undefined representation. One difference is that while this module considers two elements as different if they do not match (<code>=:=</code>), <code>ordsets</code> considers two elements as different if and only if they do not compare equal (<code>==</code>).</p> <p>Erlang/OTP 24.0 introduced a new internal representation for sets which is more performant. Developers can use this new representation by passing the <code>{version, 2}</code> flag to <code><a href="#new-1">new/1</a></code> and <code><a href="#from_list-2">from_list/2</a></code>, such as <code>sets:new([{version, 2}])</code>. This new representation will become the default in future Erlang/OTP versions. Functions that work on two sets, such as <code><a href="#union-2">union/2</a></code> and similar, will work with sets of different versions. In such cases, there is no guarantee about the version of the returned set. Explicit conversion from the old version to the new one can be done with <code>sets:from_list(sets:to_list(Old), [{version,2}])</code>. </p> </div> </div></section> <section class="innertube"><h2 id="compatibility" class="title-link"> <div class="title-name">Compatibility</div>  </h2> <div class="REFBODY rb-3"> <p>The following functions in this module also exist and provide the same functionality in the <code><a href="gb_sets.html">gb_sets(3)</a></code> and <code><a href="ordsets.html">ordsets(3)</a></code> modules. That is, by only changing the module name for each call, you can try out different set representations.</p> <ul> <li> <code><a href="#add_element-2">add_element/2</a></code> </li> <li> <code><a href="#del_element-2">del_element/2</a></code> </li> <li> <code><a href="#filter-2">filter/2</a></code> </li> <li> <code><a href="#fold-3">fold/3</a></code> </li> <li> <code><a href="#from_list-1">from_list/1</a></code> </li> <li> <code><a href="#intersection-1">intersection/1</a></code> </li> <li> <code><a href="#intersection-2">intersection/2</a></code> </li> <li> <code><a href="#is_element-2">is_element/2</a></code> </li> <li> <code><a href="#is_empty-1">is_empty/1</a></code> </li> <li> <code><a href="#is_set-1">is_set/1</a></code> </li> <li> <code><a href="#is_subset-2">is_subset/2</a></code> </li> <li> <code><a href="#new-0">new/0</a></code> </li> <li> <code><a href="#size-1">size/1</a></code> </li> <li> <code><a href="#subtract-2">subtract/2</a></code> </li> <li> <code><a href="#to_list-1">to_list/1</a></code> </li> <li> <code><a href="#union-1">union/1</a></code> </li> <li> <code><a href="#union-2">union/2</a></code> </li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p> While the three set implementations offer the same <strong>functionality</strong> with respect to the aforementioned functions, their overall <strong>behavior</strong> may differ. As mentioned, this module considers elements as different if and only if they do not match (<code>=:=</code>), while both <code><a href="ordsets.html">ordsets</a></code> and <code><a href="gb_sets.html">gb_sets</a></code> consider elements as different if and only if they do not compare equal (<code>==</code>). </p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; <code>sets:is_element(1.0, sets:from_list([1])).</code>
false
2&gt; <code>ordsets:is_element(1.0, ordsets:from_list([1])).</code>
true
2&gt; <code>gb_sets:is_element(1.0, gb_sets:from_list([1])).</code>
true</pre> </div> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-set" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-set">set(Element)</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>As returned by <code><a href="#new-0">new/0</a></code>.</p></div></div></article> <article class="data-types-body"><h3 id="type-set" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-set">set()</a> = <a href="#type-set">set</a>(term())</code><br> </div> </h3> </article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="add_element-2" class="bold_code title-link func-head">  <code>add_element(Element, Set1) -&gt; Set2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new set formed from <code>Set1</code> with <code>Element</code> inserted.</p> </div></div></article><article class="func"><h3 id="del_element-2" class="bold_code title-link func-head">  <code>del_element(Element, Set1) -&gt; Set2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>Set1</code>, but with <code>Element</code> removed.</p> </div></div></article><article class="func"><h3 id="filter-2" class="bold_code title-link func-head">  <code>filter(Pred, Set1) -&gt; Set2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Element) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Filters elements in <code>Set1</code> with boolean function <code>Pred</code>.</p> </div></div></article><article class="func"><h3 id="fold-3" class="bold_code title-link func-head">  <code>fold(Function, Acc0, Set) -&gt; Acc1</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Function = fun((Element, AccIn) -&gt; AccOut)</code></div> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> <div class="REFTYPES rt-1"><code>Acc0 = Acc1 = AccIn = AccOut = Acc</code></div>    </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Folds <code>Function</code> over every element in <code>Set</code> and returns the final value of the accumulator. The evaluation order is undefined.</p> </div></div></article><article class="func"><h3 id="from_list-1" class="bold_code title-link func-head">  <code>from_list(List) -&gt; Set</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List = [Element]</code></div> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a set of the elements in <code>List</code>.</p> </div></div></article><article class="func"><h3 id="from_list-2" class="bold_code title-link func-head">  <code>from_list(List, Opts :: [{version, 1..2}]) -&gt; Set</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List = [Element]</code></div> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a set of the elements in <code>List</code> at the given version.</p> </div></div></article><article class="func"><h3 id="intersection-1" class="bold_code title-link func-head">  <code>intersection(SetList) -&gt; Set</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>SetList = [<a href="#type-set">set</a>(Element), ...]</code></div> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the intersection of the non-empty list of sets.</p> </div></div></article><article class="func"><h3 id="intersection-2" class="bold_code title-link func-head">  <code>intersection(Set1, Set2) -&gt; Set3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = Set3 = <a href="#type-set">set</a>(Element)</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the intersection of <code>Set1</code> and <code>Set2</code>.</p> </div></div></article><article class="func"><h3 id="is_disjoint-2" class="bold_code title-link func-head">  <code>is_disjoint(Set1, Set2) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Set1</code> and <code>Set2</code> are disjoint (have no elements in common), otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="is_element-2" class="bold_code title-link func-head">  <code>is_element(Element, Set) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Element</code> is an element of <code>Set</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="is_empty-1" class="bold_code title-link func-head">  <code>is_empty(Set) -&gt; <code>boolean()</code></code><div class="title-since"><span class="since">OTP 21.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Set</code> is an empty set, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="is_set-1" class="bold_code title-link func-head">  <code>is_set(Set) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Set</code> appears to be a set of elements, otherwise <code>false</code>. Note that the test is shallow and will return <code>true</code> for any term that coincides with the possible representations of a set. See also note on <code>data types</code>.</p> </div></div></article><article class="func"><h3 id="is_subset-2" class="bold_code title-link func-head">  <code>is_subset(Set1, Set2) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = <a href="#type-set">set</a>(Element)</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> when every element of <code>Set1</code> is also a member of <code>Set2</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="new-0" class="bold_code title-link func-head">  <code>new() -&gt; <code><a href="#type-set">set</a></code>(<code>none()</code>)</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new empty set.</p> </div></div></article><article class="func"><h3 id="new-1" class="bold_code title-link func-head">  <code>new(Opts :: [{version, 1..2}]) -&gt; <code><a href="#type-set">set</a></code>(<code>none()</code>)</code><div class="title-since"><span class="since">OTP 24.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new empty set at the given version.</p> </div></div></article><article class="func"><h3 id="size-1" class="bold_code title-link func-head">  <code>size(Set) -&gt; <code>integer() &gt;= 0</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the number of elements in <code>Set</code>.</p> </div></div></article><article class="func"><h3 id="subtract-2" class="bold_code title-link func-head">  <code>subtract(Set1, Set2) -&gt; Set3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = Set3 = <a href="#type-set">set</a>(Element)</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns only the elements of <code>Set1</code> that are not also elements of <code>Set2</code>.</p> </div></div></article><article class="func"><h3 id="to_list-1" class="bold_code title-link func-head">  <code>to_list(Set) -&gt; List</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> <div class="REFTYPES rt-1"><code>List = [Element]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the elements of <code>Set</code> as a list. The order of the returned elements is undefined.</p> </div></div></article><article class="func"><h3 id="union-1" class="bold_code title-link func-head">  <code>union(SetList) -&gt; Set</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>SetList = [<a href="#type-set">set</a>(Element)]</code></div> <div class="REFTYPES rt-1"><code>Set = <a href="#type-set">set</a>(Element)</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the merged (union) set of the list of sets.</p> </div></div></article><article class="func"><h3 id="union-2" class="bold_code title-link func-head">  <code>union(Set1, Set2) -&gt; Set3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Set1 = Set2 = Set3 = <a href="#type-set">set</a>(Element)</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the merged (union) set of <code>Set1</code> and <code>Set2</code>.</p> </div></div></article> </div> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p><code><a href="gb_sets.html">gb_sets(3)</a></code>, <code><a href="ordsets.html">ordsets(3)</a></code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
