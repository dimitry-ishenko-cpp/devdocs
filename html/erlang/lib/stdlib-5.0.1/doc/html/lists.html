  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">lists</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">List processing functions.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module contains functions for list processing.</p> <p>Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1.</p> <p>Two terms <code>T1</code> and <code>T2</code> compare equal if <code>T1 == T2</code> evaluates to <code>true</code>. They match if <code>T1 =:= T2</code> evaluates to <code>true</code>.</p> <h3 id="ordering_function">Whenever an <strong id="ordering_function">ordering function</strong> <code>F</code> is expected as argument, it is assumed that the following properties hold of <code>F</code> for all x, y, and z:</h3> <ul> <li> <p>If x <code>F</code> y and y <code>F</code> x, then x = y (<code>F</code> is antisymmetric).</p> </li> <li> <p>If x <code>F</code> y and y <code>F</code> z, then x <code>F</code> z (<code>F</code> is transitive).</p> </li> <li> <p>x <code>F</code> y or y <code>F</code> x (<code>F</code> is total).</p> </li> </ul> <p>An example of a typical ordering function is less than or equal to: <code>=&lt;/2</code>.</p> </div> </div></section> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="all-2" class="bold_code title-link func-head">  <code>all(Pred, List) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Elem :: T) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List = [T]</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Pred(Elem)</code> returns <code>true</code> for all elements <code>Elem</code> in <code>List</code>, otherwise <code>false</code>. The <code>Pred</code> function must return a boolean.</p> </div></div></article><article class="func"><h3 id="any-2" class="bold_code title-link func-head">  <code>any(Pred, List) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Elem :: T) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List = [T]</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Pred(Elem)</code> returns <code>true</code> for at least one element <code>Elem</code> in <code>List</code>. The <code>Pred</code> function must return a boolean.</p> </div></div></article><article class="func"><h3 id="append-1" class="bold_code title-link func-head">  <code>append(ListOfLists) -&gt; List1</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ListOfLists = [List]</code></div> <div class="REFTYPES rt-1"><code>List = List1 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list in which all the sublists of <code>ListOfLists</code> have been appended.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:append([[1, 2, 3], [a, b], [4, 5, 6]]).</code>
[1,2,3,a,b,4,5,6]</pre> </div></div></article><article class="func"><h3 id="append-2" class="bold_code title-link func-head">  <code>append(List1, List2) -&gt; List3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = List2 = List3 = [T]</code></div>   <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new list <code>List3</code>, which is made from the elements of <code>List1</code> followed by the elements of <code>List2</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:append("abc", "def").</code>
"abcdef"</pre> <p><code>lists:append(A, B)</code> is equivalent to <code>A ++ B</code>.</p> </div></div></article><article class="func"><h3 id="concat-1" class="bold_code title-link func-head">  <code>concat(Things) -&gt; <code>string()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Things = [Thing]</code></div> <div class="REFTYPES rt-1"><code>Thing = atom() | integer() | float() | string()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Concatenates the text representation of the elements of <code>Things</code>. The elements of <code>Things</code> can be atoms, integers, floats, or strings.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:concat([doc, '/', file, '.', 3]).</code>
"doc/file.3"</pre> </div></div></article><article class="func"><h3 id="delete-2" class="bold_code title-link func-head">  <code>delete(Elem, List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Elem = T</code></div> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a copy of <code>List1</code> where the first element matching <code>Elem</code> is deleted, if there is such an element.</p> </div></div></article><article class="func"><h3 id="droplast-1" class="bold_code title-link func-head">  <code>droplast(List) -&gt; InitList</code><div class="title-since"><span class="since">OTP 17.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List = [T, ...]</code></div> <div class="REFTYPES rt-1"><code>InitList = [T]</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Drops the last element of a <code>List</code>. The list is to be non-empty, otherwise the function crashes with a <code>function_clause</code>.</p> </div></div></article><article class="func"><h3 id="dropwhile-2" class="bold_code title-link func-head">  <code>dropwhile(Pred, List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Elem :: T) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Drops elements <code>Elem</code> from <code>List1</code> while <code>Pred(Elem)</code> returns <code>true</code> and returns the remaining list. The <code>Pred</code> function must return a boolean.</p> </div></div></article><article class="func"><h3 id="duplicate-2" class="bold_code title-link func-head">  <code>duplicate(N, Elem) -&gt; List</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>Elem = T</code></div> <div class="REFTYPES rt-1"><code>List = [T]</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list containing <code>N</code> copies of term <code>Elem</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:duplicate(5, xx).</code>
[xx,xx,xx,xx,xx]</pre> </div></div></article><article class="func"><h3 id="enumerate-1" class="bold_code title-link func-head">  <code>enumerate(List1) -&gt; List2</code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <h3 id="enumerate-2" class="bold_code title-link func-head">  <code>enumerate(Index, List1) -&gt; List2</code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <h3 id="enumerate-3" class="bold_code title-link func-head">  <code>enumerate(Index, Step, List1) -&gt; List2</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = [T]</code></div> <div class="REFTYPES rt-1"><code>List2 = [{Index, T}]</code></div> <div class="REFTYPES rt-1"><code>Index = Step = integer()</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>List1</code> with each element <code>H</code> replaced by a tuple of form <code>{I, H}</code> where <code>I</code> is the position of <code>H</code> in <code>List1</code>. The enumeration starts with <code>Index</code> and increases by <code>Step</code> in each step.</p> <p>That is, <code>enumerate/3</code> behaves as if it had been defined as follows:</p> <pre data-language="erlang">enumerate(I, S, List) -&gt;
  {List1, _ } = lists:mapfoldl(fun(T, Acc) -&gt; {{Acc, T}, Acc+S} end, I, List),
  List1.</pre> <p>The default values for <code>Index</code> and <code>Step</code> are both <code>1</code>.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>lists:enumerate([a,b,c]).</code>
[{1,a},{2,b},{3,c}]</pre> <pre data-language="erlang">
&gt; <code>lists:enumerate(10, [a,b,c]).</code>
[{10,a},{11,b},{12,c}]</pre> <pre data-language="erlang">
&gt; <code>lists:enumerate(0, -2, [a,b,c]).</code>
[{0,a},{-2,b},{-4,c}]</pre> </div></div></article><article class="func"><h3 id="filter-2" class="bold_code title-link func-head">  <code>filter(Pred, List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Elem :: T) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p><code>List2</code> is a list of all elements <code>Elem</code> in <code>List1</code> for which <code>Pred(Elem)</code> returns <code>true</code>. The <code>Pred</code> function must return a boolean.</p> </div></div></article><article class="func"><h3 id="filtermap-2" class="bold_code title-link func-head">  <code>filtermap(Fun, List1) -&gt; List2</code><div class="title-since"><span class="since">OTP R16B01</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Elem) -&gt; boolean() | {true, Value})</code></div> <div class="REFTYPES rt-1"><code>List1 = [Elem]</code></div> <div class="REFTYPES rt-1"><code>List2 = [Elem | Value]</code></div> <div class="REFTYPES rt-1"><code>Elem = Value = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Calls <code>Fun(Elem)</code> on successive elements <code>Elem</code> of <code>List1</code>. <code>Fun/1</code> must return either a Boolean or a tuple <code>{true, Value}</code>. The function returns the list of elements for which <code>Fun</code> returns a new value, where a value of <code>true</code> is synonymous with <code>{true, Elem}</code>.</p> <p>That is, <code>filtermap</code> behaves as if it had been defined as follows:</p> <pre data-language="erlang">filtermap(Fun, List1) -&gt;
    lists:foldr(fun(Elem, Acc) -&gt;
                       case Fun(Elem) of
                           false -&gt; Acc;
                           true -&gt; [Elem|Acc];
                           {true,Value} -&gt; [Value|Acc]
                       end
                end, [], List1).</pre> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:filtermap(fun(X) -&gt; case X rem 2 of 0 -&gt; {true, X div 2}; _ -&gt; false end end, [1,2,3,4,5]).</code>
[1,2]</pre> </div></div></article><article class="func"><h3 id="flatlength-1" class="bold_code title-link func-head">  <code>flatlength(DeepList) -&gt; <code>integer() &gt;= 0</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>DeepList = [term() | DeepList]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Equivalent to <code>length(flatten(DeepList))</code>, but more efficient.</p> </div></div></article><article class="func"><h3 id="flatmap-2" class="bold_code title-link func-head">  <code>flatmap(Fun, List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((A) -&gt; [B])</code></div> <div class="REFTYPES rt-1"><code>List1 = [A]</code></div> <div class="REFTYPES rt-1"><code>List2 = [B]</code></div> <div class="REFTYPES rt-1"><code>A = B = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Takes a function from <code>A</code>s to lists of <code>B</code>s, and a list of <code>A</code>s (<code>List1</code>) and produces a list of <code>B</code>s by applying the function to every element in <code>List1</code> and appending the resulting lists.</p> <p>That is, <code>flatmap</code> behaves as if it had been defined as follows:</p> <pre data-language="erlang">flatmap(Fun, List1) -&gt;
    append(map(Fun, List1)).</pre> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:flatmap(fun(X)-&gt;[X,X] end, [a,b,c]).</code>
[a,a,b,b,c,c]</pre> </div></div></article><article class="func"><h3 id="flatten-1" class="bold_code title-link func-head">  <code>flatten(DeepList) -&gt; List</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>DeepList = [term() | DeepList]</code></div> <div class="REFTYPES rt-1"><code>List = [term()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a flattened version of <code>DeepList</code>.</p> </div></div></article><article class="func"><h3 id="flatten-2" class="bold_code title-link func-head">  <code>flatten(DeepList, Tail) -&gt; List</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>DeepList = [term() | DeepList]</code></div> <div class="REFTYPES rt-1"><code>Tail = List = [term()]</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a flattened version of <code>DeepList</code> with tail <code>Tail</code> appended.</p> </div></div></article><article class="func"><h3 id="foldl-3" class="bold_code title-link func-head">  <code>foldl(Fun, Acc0, List) -&gt; Acc1</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Elem :: T, AccIn) -&gt; AccOut)</code></div> <div class="REFTYPES rt-1"><code>Acc0 = Acc1 = AccIn = AccOut = term()</code></div>    <div class="REFTYPES rt-1"><code>List = [T]</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Calls <code>Fun(Elem, AccIn)</code> on successive elements <code>A</code> of <code>List</code>, starting with <code>AccIn == Acc0</code>. <code>Fun/2</code> must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. <code>Acc0</code> is returned if the list is empty.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:foldl(fun(X, Sum) -&gt; X + Sum end, 0, [1,2,3,4,5]).</code>
15
&gt; <code>lists:foldl(fun(X, Prod) -&gt; X * Prod end, 1, [1,2,3,4,5]).</code>
120</pre> </div></div></article><article class="func"><h3 id="foldr-3" class="bold_code title-link func-head">  <code>foldr(Fun, Acc0, List) -&gt; Acc1</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Elem :: T, AccIn) -&gt; AccOut)</code></div> <div class="REFTYPES rt-1"><code>Acc0 = Acc1 = AccIn = AccOut = term()</code></div>    <div class="REFTYPES rt-1"><code>List = [T]</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Like <code><a href="#foldl-3">foldl/3</a></code>, but the list is traversed from right to left.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>P = fun(A, AccIn) -&gt; io:format("~p ", [A]), AccIn end.</code>
#Fun&lt;erl_eval.12.2225172&gt;
&gt; <code>lists:foldl(P, void, [1,2,3]).</code>
1 2 3 void
&gt; <code>lists:foldr(P, void, [1,2,3]).</code>
3 2 1 void</pre> <p><code>foldl/3</code> is tail recursive and is usually preferred to <code>foldr/3</code>.</p> </div></div></article><article class="func"><h3 id="join-2" class="bold_code title-link func-head">  <code>join(Sep, List1) -&gt; List2</code><div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Sep = T</code></div> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Inserts <code>Sep</code> between each element in <code>List1</code>. Has no effect on the empty list and on a singleton list. For example:</p> <pre data-language="erlang">
&gt; <code>lists:join(x, [a,b,c]).</code>
[a,x,b,x,c]
&gt; <code>lists:join(x, [a]).</code>
[a]
&gt; <code>lists:join(x, []).</code>
[]</pre> </div></div></article><article class="func"><h3 id="foreach-2" class="bold_code title-link func-head">  <code>foreach(Fun, List) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Elem :: T) -&gt; term())</code></div> <div class="REFTYPES rt-1"><code>List = [T]</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Calls <code>Fun(Elem)</code> for each element <code>Elem</code> in <code>List</code>. This function is used for its side effects and the evaluation order is defined to be the same as the order of the elements in the list.</p> </div></div></article><article class="func"><h3 id="keydelete-3" class="bold_code title-link func-head">  <code>keydelete(Key, N, TupleList1) -&gt; TupleList2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Key = term()</code></div> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList1 = TupleList2 = [Tuple]</code></div>  <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a copy of <code>TupleList1</code> where the first occurrence of a tuple whose <code>N</code>th element compares equal to <code>Key</code> is deleted, if there is such a tuple.</p> </div></div></article><article class="func"><h3 id="keyfind-3" class="bold_code title-link func-head">  <code>keyfind(Key, N, TupleList) -&gt; Tuple | false</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Key = term()</code></div> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList = [Tuple]</code></div> <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Searches the list of tuples <code>TupleList</code> for a tuple whose <code>N</code>th element compares equal to <code>Key</code>. Returns <code>Tuple</code> if such a tuple is found, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="keymap-3" class="bold_code title-link func-head">  <code>keymap(Fun, N, TupleList1) -&gt; TupleList2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((Term1 :: term()) -&gt; Term2 :: term())</code></div> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList1 = TupleList2 = [Tuple]</code></div>  <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list of tuples where, for each tuple in <code>TupleList1</code>, the <code>N</code>th element <code>Term1</code> of the tuple has been replaced with the result of calling <code>Fun(Term1)</code>.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>Fun = fun(Atom) -&gt; atom_to_list(Atom) end.</code>
#Fun&lt;erl_eval.6.10732646&gt;
2&gt; <code>lists:keymap(Fun, 2, [{name,jane,22},{name,lizzie,20},{name,lydia,15}]).</code>
[{name,"jane",22},{name,"lizzie",20},{name,"lydia",15}]</pre> </div></div></article><article class="func"><h3 id="keymember-3" class="bold_code title-link func-head">  <code>keymember(Key, N, TupleList) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Key = term()</code></div> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList = [Tuple]</code></div> <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if there is a tuple in <code>TupleList</code> whose <code>N</code>th element compares equal to <code>Key</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="keymerge-3" class="bold_code title-link func-head">  <code>keymerge(N, TupleList1, TupleList2) -&gt; TupleList3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList1 = [T1]</code></div> <div class="REFTYPES rt-1"><code>TupleList2 = [T2]</code></div> <div class="REFTYPES rt-1"><code>TupleList3 = [T1 | T2]</code></div> <div class="REFTYPES rt-1"><code>T1 = T2 = Tuple</code></div>  <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sorted list formed by merging <code>TupleList1</code> and <code>TupleList2</code>. The merge is performed on the <code>N</code>th element of each tuple. Both <code>TupleList1</code> and <code>TupleList2</code> must be key-sorted before evaluating this function. When two tuples compare equal, the tuple from <code>TupleList1</code> is picked before the tuple from <code>TupleList2</code>.</p> </div></div></article><article class="func"><h3 id="keyreplace-4" class="bold_code title-link func-head">  <code>keyreplace(Key, N, TupleList1, NewTuple) -&gt; TupleList2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Key = term()</code></div> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList1 = TupleList2 = [Tuple]</code></div>  <div class="REFTYPES rt-1"><code>NewTuple = Tuple</code></div> <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a copy of <code>TupleList1</code> where the first occurrence of a <code>T</code> tuple whose <code>N</code>th element compares equal to <code>Key</code> is replaced with <code>NewTuple</code>, if there is such a tuple <code>T</code>.</p> </div></div></article><article class="func"><h3 id="keysearch-3" class="bold_code title-link func-head">  <code>keysearch(Key, N, TupleList) -&gt; {value, Tuple} | false</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Key = term()</code></div> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList = [Tuple]</code></div> <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Searches the list of tuples <code>TupleList</code> for a tuple whose <code>N</code>th element compares equal to <code>Key</code>. Returns <code>{value, Tuple}</code> if such a tuple is found, otherwise <code>false</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function is retained for backward compatibility. Function <code><a href="#keyfind-3">keyfind/3</a></code> is usually more convenient.</p> </div> </div> </div></div></article><article class="func"><h3 id="keysort-2" class="bold_code title-link func-head">  <code>keysort(N, TupleList1) -&gt; TupleList2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList1 = TupleList2 = [Tuple]</code></div>  <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list containing the sorted elements of list <code>TupleList1</code>. Sorting is performed on the <code>N</code>th element of the tuples. The sort is stable.</p> </div></div></article><article class="func"><h3 id="keystore-4" class="bold_code title-link func-head">  <code>keystore(Key, N, TupleList1, NewTuple) -&gt; TupleList2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Key = term()</code></div> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList1 = [Tuple]</code></div> <div class="REFTYPES rt-1"><code>TupleList2 = [Tuple, ...]</code></div> <div class="REFTYPES rt-1"><code>NewTuple = Tuple</code></div> <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a copy of <code>TupleList1</code> where the first occurrence of a tuple <code>T</code> whose <code>N</code>th element compares equal to <code>Key</code> is replaced with <code>NewTuple</code>, if there is such a tuple <code>T</code>. If there is no such tuple <code>T</code>, a copy of <code>TupleList1</code> where [<code>NewTuple</code>] has been appended to the end is returned.</p> </div></div></article><article class="func"><h3 id="keytake-3" class="bold_code title-link func-head">  <code>keytake(Key, N, TupleList1) -&gt; {value, Tuple, TupleList2} | false</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Key = term()</code></div> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList1 = TupleList2 = [tuple()]</code></div>  <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Searches the list of tuples <code>TupleList1</code> for a tuple whose <code>N</code>th element compares equal to <code>Key</code>. Returns <code>{value, Tuple, TupleList2}</code> if such a tuple is found, otherwise <code>false</code>. <code>TupleList2</code> is a copy of <code>TupleList1</code> where the first occurrence of <code>Tuple</code> has been removed.</p> </div></div></article><article class="func"><h3 id="last-1" class="bold_code title-link func-head">  <code>last(List) -&gt; Last</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List = [T, ...]</code></div> <div class="REFTYPES rt-1"><code>Last = T</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the last element in <code>List</code>.</p> </div></div></article><article class="func"><h3 id="map-2" class="bold_code title-link func-head">  <code>map(Fun, List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((A) -&gt; B)</code></div> <div class="REFTYPES rt-1"><code>List1 = [A]</code></div> <div class="REFTYPES rt-1"><code>List2 = [B]</code></div> <div class="REFTYPES rt-1"><code>A = B = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Takes a function from <code>A</code>s to <code>B</code>s, and a list of <code>A</code>s and produces a list of <code>B</code>s by applying the function to every element in the list. This function is used to obtain the return values. The evaluation order depends on the implementation.</p> </div></div></article><article class="func"><h3 id="mapfoldl-3" class="bold_code title-link func-head">  <code>mapfoldl(Fun, Acc0, List1) -&gt; {List2, Acc1}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((A, AccIn) -&gt; {B, AccOut})</code></div> <div class="REFTYPES rt-1"><code>Acc0 = Acc1 = AccIn = AccOut = term()</code></div>    <div class="REFTYPES rt-1"><code>List1 = [A]</code></div> <div class="REFTYPES rt-1"><code>List2 = [B]</code></div> <div class="REFTYPES rt-1"><code>A = B = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Combines the operations of <code><a href="#map-2">map/2</a></code> and <code><a href="#foldl-3">foldl/3</a></code> into one pass.</p> <p><strong>Example:</strong></p> <p>Summing the elements in a list and double them at the same time:</p> <pre data-language="erlang">
&gt; <code>lists:mapfoldl(fun(X, Sum) -&gt; {2*X, X+Sum} end,</code>
<code>0, [1,2,3,4,5]).</code>
{[2,4,6,8,10],15}</pre> </div></div></article><article class="func"><h3 id="mapfoldr-3" class="bold_code title-link func-head">  <code>mapfoldr(Fun, Acc0, List1) -&gt; {List2, Acc1}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((A, AccIn) -&gt; {B, AccOut})</code></div> <div class="REFTYPES rt-1"><code>Acc0 = Acc1 = AccIn = AccOut = term()</code></div>    <div class="REFTYPES rt-1"><code>List1 = [A]</code></div> <div class="REFTYPES rt-1"><code>List2 = [B]</code></div> <div class="REFTYPES rt-1"><code>A = B = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Combines the operations of <code><a href="#map-2">map/2</a></code> and <code><a href="#foldr-3">foldr/3</a></code> into one pass.</p> </div></div></article><article class="func"><h3 id="max-1" class="bold_code title-link func-head">  <code>max(List) -&gt; Max</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List = [T, ...]</code></div> <div class="REFTYPES rt-1"><code>Max = T</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the first element of <code>List</code> that compares greater than or equal to all other elements of <code>List</code>.</p> </div></div></article><article class="func"><h3 id="member-2" class="bold_code title-link func-head">  <code>member(Elem, List) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Elem = T</code></div> <div class="REFTYPES rt-1"><code>List = [T]</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Elem</code> matches some element of <code>List</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="merge-1" class="bold_code title-link func-head">  <code>merge(ListOfLists) -&gt; List1</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ListOfLists = [List]</code></div> <div class="REFTYPES rt-1"><code>List = List1 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sorted list formed by merging all the sublists of <code>ListOfLists</code>. All sublists must be sorted before evaluating this function. When two elements compare equal, the element from the sublist with the lowest position in <code>ListOfLists</code> is picked before the other element.</p> </div></div></article><article class="func"><h3 id="merge-2" class="bold_code title-link func-head">  <code>merge(List1, List2) -&gt; List3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = [X]</code></div> <div class="REFTYPES rt-1"><code>List2 = [Y]</code></div> <div class="REFTYPES rt-1"><code>List3 = [X | Y]</code></div> <div class="REFTYPES rt-1"><code>X = Y = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sorted list formed by merging <code>List1</code> and <code>List2</code>. Both <code>List1</code> and <code>List2</code> must be sorted before evaluating this function. When two elements compare equal, the element from <code>List1</code> is picked before the element from <code>List2</code>.</p> </div></div></article><article class="func"><h3 id="merge-3" class="bold_code title-link func-head">  <code>merge(Fun, List1, List2) -&gt; List3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((A, B) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List1 = [A]</code></div> <div class="REFTYPES rt-1"><code>List2 = [B]</code></div> <div class="REFTYPES rt-1"><code>List3 = [A | B]</code></div> <div class="REFTYPES rt-1"><code>A = B = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sorted list formed by merging <code>List1</code> and <code>List2</code>. Both <code>List1</code> and <code>List2</code> must be sorted according to the <code><a href="#ordering_function">ordering function</a></code> <code>Fun</code> before evaluating this function. <code>Fun(A, B)</code> is to return <code>true</code> if <code>A</code> compares less than or equal to <code>B</code> in the ordering, otherwise <code>false</code>. When two elements compare equal, the element from <code>List1</code> is picked before the element from <code>List2</code>.</p> </div></div></article><article class="func"><h3 id="merge3-3" class="bold_code title-link func-head">  <code>merge3(List1, List2, List3) -&gt; List4</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = [X]</code></div> <div class="REFTYPES rt-1"><code>List2 = [Y]</code></div> <div class="REFTYPES rt-1"><code>List3 = [Z]</code></div> <div class="REFTYPES rt-1"><code>List4 = [X | Y | Z]</code></div> <div class="REFTYPES rt-1"><code>X = Y = Z = term()</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sorted list formed by merging <code>List1</code>, <code>List2</code>, and <code>List3</code>. All of <code>List1</code>, <code>List2</code>, and <code>List3</code> must be sorted before evaluating this function. When two elements compare equal, the element from <code>List1</code>, if there is such an element, is picked before the other element, otherwise the element from <code>List2</code> is picked before the element from <code>List3</code>.</p> </div></div></article><article class="func"><h3 id="min-1" class="bold_code title-link func-head">  <code>min(List) -&gt; Min</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List = [T, ...]</code></div> <div class="REFTYPES rt-1"><code>Min = T</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the first element of <code>List</code> that compares less than or equal to all other elements of <code>List</code>.</p> </div></div></article><article class="func"><h3 id="nth-2" class="bold_code title-link func-head">  <code>nth(N, List) -&gt; Elem</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..length(List)</div> <div class="REFTYPES rt-1"><code>List = [T, ...]</code></div> <div class="REFTYPES rt-1"><code>Elem = T</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the <code>N</code>th element of <code>List</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:nth(3, [a, b, c, d, e]).</code>
c</pre> </div></div></article><article class="func"><h3 id="nthtail-2" class="bold_code title-link func-head">  <code>nthtail(N, List) -&gt; Tail</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 0</code></div> <div class="REFBODY rb-1">0..length(List)</div> <div class="REFTYPES rt-1"><code>List = [T, ...]</code></div> <div class="REFTYPES rt-1"><code>Tail = [T]</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the <code>N</code>th tail of <code>List</code>, that is, the sublist of <code>List</code> starting at <code>N+1</code> and continuing up to the end of the list.</p> <p><strong>Example</strong></p> <pre data-language="erlang">
&gt; <code>lists:nthtail(3, [a, b, c, d, e]).</code>
[d,e]
&gt; <code>tl(tl(tl([a, b, c, d, e]))).</code>
[d,e]
&gt; <code>lists:nthtail(0, [a, b, c, d, e]).</code>
[a,b,c,d,e]
&gt; <code>lists:nthtail(5, [a, b, c, d, e]).</code>
[]</pre> </div></div></article><article class="func"><h3 id="partition-2" class="bold_code title-link func-head">  <code>partition(Pred, List) -&gt; {Satisfying, NotSatisfying}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Elem :: T) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List = Satisfying = NotSatisfying = [T]</code></div>   <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Partitions <code>List</code> into two lists, where the first list contains all elements for which <code>Pred(Elem)</code> returns <code>true</code>, and the second list contains all elements for which <code>Pred(Elem)</code> returns <code>false</code>.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>lists:partition(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).</code>
{[1,3,5,7],[2,4,6]}
&gt; <code>lists:partition(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).</code>
{[a,b,c,d,e],[1,2,3,4]}</pre> <p>For a different way to partition a list, see <code><a href="#splitwith-2">splitwith/2</a></code>.</p> </div></div></article><article class="func"><h3 id="prefix-2" class="bold_code title-link func-head">  <code>prefix(List1, List2) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>List1</code> is a prefix of <code>List2</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="reverse-1" class="bold_code title-link func-head">  <code>reverse(List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list with the elements in <code>List1</code> in reverse order.</p> </div></div></article><article class="func"><h3 id="reverse-2" class="bold_code title-link func-head">  <code>reverse(List1, Tail) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = [T]</code></div> <div class="REFTYPES rt-1"><code>Tail = term()</code></div> <div class="REFTYPES rt-1"><code>List2 = [T]</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list with the elements in <code>List1</code> in reverse order, with tail <code>Tail</code> appended.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:reverse([1, 2, 3, 4], [a, b, c]).</code>
[4,3,2,1,a,b,c]</pre> </div></div></article><article class="func"><h3 id="search-2" class="bold_code title-link func-head">  <code>search(Pred, List) -&gt; {value, Value} | false</code><div class="title-since"><span class="since">OTP 21.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((T) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List = [T]</code></div> <div class="REFTYPES rt-1"><code>Value = T</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>If there is a <code>Value</code> in <code>List</code> such that <code>Pred(Value)</code> returns <code>true</code>, returns <code>{value, Value}</code> for the first such <code>Value</code>, otherwise returns <code>false</code>. The <code>Pred</code> function must return a boolean.</p> </div></div></article><article class="func"><h3 id="seq-2" class="bold_code title-link func-head">  <code>seq(From, To) -&gt; Seq</code> </h3> <h3 id="seq-3" class="bold_code title-link func-head">  <code>seq(From, To, Incr) -&gt; Seq</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>From = To = Incr = integer()</code></div>   <div class="REFTYPES rt-1"><code>Seq = [integer()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a sequence of integers that starts with <code>From</code> and contains the successive results of adding <code>Incr</code> to the previous element, until <code>To</code> is reached or passed (in the latter case, <code>To</code> is not an element of the sequence). <code>Incr</code> defaults to 1.</p> <p>Failures:</p> <ul> <li> <p>If <code>To &lt; From - Incr</code> and <code>Incr &gt; 0</code>.</p> </li> <li> <p>If <code>To &gt; From - Incr</code> and <code>Incr &lt; 0</code>.</p> </li> <li> <p>If <code>Incr =:= 0</code> and <code>From =/= To</code>.</p> </li> </ul> <p>The following equalities hold for all sequences:</p> <pre data-language="erlang">length(lists:seq(From, To)) =:= To - From + 1
length(lists:seq(From, To, Incr)) =:= (To - From + Incr) div Incr</pre> <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>lists:seq(1, 10).</code>
[1,2,3,4,5,6,7,8,9,10]
&gt; <code>lists:seq(1, 20, 3).</code>
[1,4,7,10,13,16,19]
&gt; <code>lists:seq(1, 0, 1).</code>
[]
&gt; <code>lists:seq(10, 6, 4).</code>
[]
&gt; <code>lists:seq(1, 1, 0).</code>
[1]</pre> </div></div></article><article class="func"><h3 id="sort-1" class="bold_code title-link func-head">  <code>sort(List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list containing the sorted elements of <code>List1</code>.</p> </div></div></article><article class="func"><h3 id="sort-2" class="bold_code title-link func-head">  <code>sort(Fun, List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((A :: T, B :: T) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list containing the sorted elements of <code>List1</code>, according to the <code><a href="#ordering_function">ordering function</a></code> <code>Fun</code>. <code>Fun(A, B)</code> is to return <code>true</code> if <code>A</code> compares less than or equal to <code>B</code> in the ordering, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="split-2" class="bold_code title-link func-head">  <code>split(N, List1) -&gt; {List2, List3}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 0</code></div> <div class="REFBODY rb-1">0..length(List1)</div> <div class="REFTYPES rt-1"><code>List1 = List2 = List3 = [T]</code></div>   <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Splits <code>List1</code> into <code>List2</code> and <code>List3</code>. <code>List2</code> contains the first <code>N</code> elements and <code>List3</code> the remaining elements (the <code>N</code>th tail).</p> </div></div></article><article class="func"><h3 id="splitwith-2" class="bold_code title-link func-head">  <code>splitwith(Pred, List) -&gt; {List1, List2}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((T) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List = List1 = List2 = [T]</code></div>   <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Partitions <code>List</code> into two lists according to <code>Pred</code>. <code>splitwith/2</code> behaves as if it is defined as follows:</p> <pre data-language="erlang">splitwith(Pred, List) -&gt;
    {takewhile(Pred, List), dropwhile(Pred, List)}.</pre> <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>lists:splitwith(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).</code>
{[1],[2,3,4,5,6,7]}
&gt; <code>lists:splitwith(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).</code>
{[a,b],[1,c,d,2,3,4,e]}</pre> <p>The <code>Pred</code> function must return a boolean. For a different way to partition a list, see <code><a href="#partition-2">partition/2</a></code>.</p> </div></div></article><article class="func"><h3 id="sublist-2" class="bold_code title-link func-head">  <code>sublist(List1, Len) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>Len = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sublist of <code>List1</code> starting at position 1 and with (maximum) <code>Len</code> elements. It is not an error for <code>Len</code> to exceed the length of the list, in that case the whole list is returned.</p> </div></div></article><article class="func"><h3 id="sublist-3" class="bold_code title-link func-head">  <code>sublist(List1, Start, Len) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>Start = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..(length(List1)+1)</div> <div class="REFTYPES rt-1"><code>Len = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sublist of <code>List1</code> starting at <code>Start</code> and with (maximum) <code>Len</code> elements. It is not an error for <code>Start+Len</code> to exceed the length of the list.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>lists:sublist([1,2,3,4], 2, 2).</code>
[2,3]
&gt; <code>lists:sublist([1,2,3,4], 2, 5).</code>
[2,3,4]
&gt; <code>lists:sublist([1,2,3,4], 5, 2).</code>
[]</pre> </div></div></article><article class="func"><h3 id="subtract-2" class="bold_code title-link func-head">  <code>subtract(List1, List2) -&gt; List3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = List2 = List3 = [T]</code></div>   <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a new list <code>List3</code> that is a copy of <code>List1</code>, subjected to the following procedure: for each element in <code>List2</code>, its first occurrence in <code>List1</code> is deleted.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:subtract("123212", "212").</code>
"312".</pre> <p><code>lists:subtract(A, B)</code> is equivalent to <code>A -- B</code>.</p> </div></div></article><article class="func"><h3 id="suffix-2" class="bold_code title-link func-head">  <code>suffix(List1, List2) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>List1</code> is a suffix of <code>List2</code>, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="sum-1" class="bold_code title-link func-head">  <code>sum(List) -&gt; <code>number()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List = [number()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sum of the elements in <code>List</code>.</p> </div></div></article><article class="func"><h3 id="takewhile-2" class="bold_code title-link func-head">  <code>takewhile(Pred, List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Pred = fun((Elem :: T) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Takes elements <code>Elem</code> from <code>List1</code> while <code>Pred(Elem)</code> returns <code>true</code>, that is, the function returns the longest prefix of the list for which all elements satisfy the predicate. The <code>Pred</code> function must return a boolean.</p> </div></div></article><article class="func"><h3 id="ukeymerge-3" class="bold_code title-link func-head">  <code>ukeymerge(N, TupleList1, TupleList2) -&gt; TupleList3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList1 = [T1]</code></div> <div class="REFTYPES rt-1"><code>TupleList2 = [T2]</code></div> <div class="REFTYPES rt-1"><code>TupleList3 = [T1 | T2]</code></div> <div class="REFTYPES rt-1"><code>T1 = T2 = Tuple</code></div>  <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sorted list formed by merging <code>TupleList1</code> and <code>TupleList2</code>. The merge is performed on the <code>N</code>th element of each tuple. Both <code>TupleList1</code> and <code>TupleList2</code> must be key-sorted without duplicates before evaluating this function. When two tuples compare equal, the tuple from <code>TupleList1</code> is picked and the one from <code>TupleList2</code> is deleted.</p> </div></div></article><article class="func"><h3 id="ukeysort-2" class="bold_code title-link func-head">  <code>ukeysort(N, TupleList1) -&gt; TupleList2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>N = integer() &gt;= 1</code></div> <div class="REFBODY rb-1">1..tuple_size(Tuple)</div> <div class="REFTYPES rt-1"><code>TupleList1 = TupleList2 = [Tuple]</code></div>  <div class="REFTYPES rt-1"><code>Tuple = tuple()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list containing the sorted elements of list <code>TupleList1</code> where all except the first tuple of the tuples comparing equal have been deleted. Sorting is performed on the <code>N</code>th element of the tuples.</p> </div></div></article><article class="func"><h3 id="umerge-1" class="bold_code title-link func-head">  <code>umerge(ListOfLists) -&gt; List1</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>ListOfLists = [List]</code></div> <div class="REFTYPES rt-1"><code>List = List1 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sorted list formed by merging all the sublists of <code>ListOfLists</code>. All sublists must be sorted and contain no duplicates before evaluating this function. When two elements compare equal, the element from the sublist with the lowest position in <code>ListOfLists</code> is picked and the other is deleted.</p> </div></div></article><article class="func"><h3 id="umerge-2" class="bold_code title-link func-head">  <code>umerge(List1, List2) -&gt; List3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = [X]</code></div> <div class="REFTYPES rt-1"><code>List2 = [Y]</code></div> <div class="REFTYPES rt-1"><code>List3 = [X | Y]</code></div> <div class="REFTYPES rt-1"><code>X = Y = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sorted list formed by merging <code>List1</code> and <code>List2</code>. Both <code>List1</code> and <code>List2</code> must be sorted and contain no duplicates before evaluating this function. When two elements compare equal, the element from <code>List1</code> is picked and the one from <code>List2</code> is deleted.</p> </div></div></article><article class="func"><h3 id="umerge-3" class="bold_code title-link func-head">  <code>umerge(Fun, List1, List2) -&gt; List3</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((A, B) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List1 = [A]</code></div> <div class="REFTYPES rt-1"><code>List2 = [B]</code></div> <div class="REFTYPES rt-1"><code>List3 = [A | B]</code></div> <div class="REFTYPES rt-1"><code>A = B = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sorted list formed by merging <code>List1</code> and <code>List2</code>. Both <code>List1</code> and <code>List2</code> must be sorted according to the <code><a href="#ordering_function">ordering function</a></code> <code>Fun</code> and contain no duplicates before evaluating this function. <code>Fun(A, B)</code> is to return <code>true</code> if <code>A</code> compares less than or equal to <code>B</code> in the ordering, otherwise <code>false</code>. When two elements compare equal, the element from <code>List1</code> is picked and the one from <code>List2</code> is deleted.</p> </div></div></article><article class="func"><h3 id="umerge3-3" class="bold_code title-link func-head">  <code>umerge3(List1, List2, List3) -&gt; List4</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = [X]</code></div> <div class="REFTYPES rt-1"><code>List2 = [Y]</code></div> <div class="REFTYPES rt-1"><code>List3 = [Z]</code></div> <div class="REFTYPES rt-1"><code>List4 = [X | Y | Z]</code></div> <div class="REFTYPES rt-1"><code>X = Y = Z = term()</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the sorted list formed by merging <code>List1</code>, <code>List2</code>, and <code>List3</code>. All of <code>List1</code>, <code>List2</code>, and <code>List3</code> must be sorted and contain no duplicates before evaluating this function. When two elements compare equal, the element from <code>List1</code> is picked if there is such an element, otherwise the element from <code>List2</code> is picked, and the other is deleted.</p> </div></div></article><article class="func"><h3 id="unzip-1" class="bold_code title-link func-head">  <code>unzip(List1) -&gt; {List2, List3}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = [{A, B}]</code></div> <div class="REFTYPES rt-1"><code>List2 = [A]</code></div> <div class="REFTYPES rt-1"><code>List3 = [B]</code></div> <div class="REFTYPES rt-1"><code>A = B = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>"Unzips" a list of two-tuples into two lists, where the first list contains the first element of each tuple, and the second list contains the second element of each tuple.</p> </div></div></article><article class="func"><h3 id="unzip3-1" class="bold_code title-link func-head">  <code>unzip3(List1) -&gt; {List2, List3, List4}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = [{A, B, C}]</code></div> <div class="REFTYPES rt-1"><code>List2 = [A]</code></div> <div class="REFTYPES rt-1"><code>List3 = [B]</code></div> <div class="REFTYPES rt-1"><code>List4 = [C]</code></div> <div class="REFTYPES rt-1"><code>A = B = C = term()</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>"Unzips" a list of three-tuples into three lists, where the first list contains the first element of each tuple, the second list contains the second element of each tuple, and the third list contains the third element of each tuple.</p> </div></div></article><article class="func"><h3 id="usort-1" class="bold_code title-link func-head">  <code>usort(List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list containing the sorted elements of <code>List1</code> where all except the first element of the elements comparing equal have been deleted.</p> </div></div></article><article class="func"><h3 id="usort-2" class="bold_code title-link func-head">  <code>usort(Fun, List1) -&gt; List2</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((T, T) -&gt; boolean())</code></div> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list containing the sorted elements of <code>List1</code> where all except the first element of the elements comparing equal according to the <code><a href="#ordering_function">ordering function</a></code> <code>Fun</code> have been deleted. <code>Fun(A, B)</code> is to return <code>true</code> if <code>A</code> compares less than or equal to <code>B</code> in the ordering, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="zip-2" class="bold_code title-link func-head">  <code>zip(List1, List2) -&gt; List3</code> </h3> <h3 id="zip-3" class="bold_code title-link func-head">  <code>zip(List1, List2, How) -&gt; List3</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = [A]</code></div> <div class="REFTYPES rt-1"><code>List2 = [B]</code></div> <div class="REFTYPES rt-1"><code>List3 = [{A | DefaultA, B | DefaultB}]</code></div> <div class="REFTYPES rt-1"><code>A = B = term()</code></div>  <div class="REFTYPES rt-1"><code>How = fail | trim | {pad, {DefaultA, DefaultB}}</code></div> <div class="REFTYPES rt-1"><code>DefaultA = DefaultB = term()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>"Zips" two lists into one list of two-tuples, where the first element of each tuple is taken from the first list and the second element is taken from the corresponding element in the second list.</p> <p>The <code>How</code> parameter specifies the behavior if the given lists are of different lengths.</p> <dl> <dt class="title-link"><strong><code>fail</code></strong></dt> <dd>The call will fail if the given lists are not of equal length. This is the default.</dd> <dt class="title-link"><strong><code>trim</code></strong></dt> <dd>Surplus elements from the longer list will be ignored. <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>lists:zip([a, b], [1, 2, 3], trim).</code>
[{a,1},{b,2}]
&gt; <code>lists:zip([a, b, c], [1, 2], trim).</code>
[{a,1},{b,2}]</pre> </dd> <dt class="title-link"><strong><code>{pad, Defaults}</code></strong></dt> <dd>The shorter list will be padded to the length of the longer list, using the respective elements from the given <code>Defaults</code> tuple. <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>lists:zip([a, b], [1, 2, 3], {pad, {x, 0}}).</code>
[{a,1},{b,2},{x,3}]
&gt; <code>lists:zip([a, b, c], [1, 2], {pad, {x, 0}}).</code>
[{a,1},{b,2},{c,0}]</pre> </dd> </dl> </div></div></article><article class="func"><h3 id="zip3-3" class="bold_code title-link func-head">  <code>zip3(List1, List2, List3) -&gt; List4</code> </h3> <h3 id="zip3-4" class="bold_code title-link func-head">  <code>zip3(List1, List2, List3, How) -&gt; List4</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = [A]</code></div> <div class="REFTYPES rt-1"><code>List2 = [B]</code></div> <div class="REFTYPES rt-1"><code>List3 = [C]</code></div> <div class="REFTYPES rt-1"><code>List4 = [{A | DefaultA, B | DefaultB, C | DefaultC}]</code></div> <div class="REFTYPES rt-1"><code>A = B = C = term()</code></div>   <div class="REFTYPES rt-1"><code>How = fail | trim | {pad, {DefaultA, DefaultB, DefaultC}}</code></div> <div class="REFTYPES rt-1"><code>DefaultA = DefaultB = DefaultC = term()</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>"Zips" three lists into one list of three-tuples, where the first element of each tuple is taken from the first list, the second element is taken from the corresponding element in the second list, and the third element is taken from the corresponding element in the third list.</p> <p>For a description of the <code>How</code> parameter, see <code><a href="#zip-3">zip/3</a></code>.</p> </div></div></article><article class="func"><h3 id="zipwith-3" class="bold_code title-link func-head">  <code>zipwith(Combine, List1, List2) -&gt; List3</code> </h3> <h3 id="zipwith-4" class="bold_code title-link func-head">  <code>zipwith(Combine, List1, List2, How) -&gt; List3</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Combine = fun((X | DefaultX, Y | DefaultY) -&gt; T)</code></div> <div class="REFTYPES rt-1"><code>List1 = [X]</code></div> <div class="REFTYPES rt-1"><code>List2 = [Y]</code></div> <div class="REFTYPES rt-1"><code>List3 = [T]</code></div> <div class="REFTYPES rt-1"><code>X = Y = term()</code></div>  <div class="REFTYPES rt-1"><code>How = fail | trim | {pad, {DefaultX, DefaultY}}</code></div> <div class="REFTYPES rt-1"><code>DefaultX = DefaultY = T = term()</code></div>   </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Combines the elements of two lists into one list. For each pair <code>X, Y</code> of list elements from the two lists, the element in the result list is <code>Combine(X, Y)</code>.</p> <p>For a description of the <code>How</code> parameter, see <code><a href="#zip-3">zip/3</a></code>.</p> <p><code>zipwith(fun(X, Y) -&gt; {X,Y} end, List1, List2)</code> is equivalent to <code>zip(List1, List2)</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>lists:zipwith(fun(X, Y) -&gt; X+Y end, [1,2,3], [4,5,6]).</code>
[5,7,9]</pre> </div></div></article><article class="func"><h3 id="zipwith3-4" class="bold_code title-link func-head">  <code>zipwith3(Combine, List1, List2, List3) -&gt; List4</code> </h3> <h3 id="zipwith3-5" class="bold_code title-link func-head">  <code>zipwith3(Combine, List1, List2, List3, How) -&gt; List4</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Combine = fun((X | DefaultX, Y | DefaultY, Z | DefaultZ) -&gt; T)</code></div> <div class="REFTYPES rt-1"><code>List1 = [X]</code></div> <div class="REFTYPES rt-1"><code>List2 = [Y]</code></div> <div class="REFTYPES rt-1"><code>List3 = [Z]</code></div> <div class="REFTYPES rt-1"><code>List4 = [T]</code></div> <div class="REFTYPES rt-1"><code>X = Y = Z = term()</code></div>   <div class="REFTYPES rt-1"><code>How = fail | trim | {pad, {DefaultX, DefaultY, DefaultZ}}</code></div> <div class="REFTYPES rt-1"><code>DefaultX = DefaultY = DefaultZ = T = term()</code></div>    </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Combines the elements of three lists into one list. For each triple <code>X, Y, Z</code> of list elements from the three lists, the element in the result list is <code>Combine(X, Y, Z)</code>.</p> <p>For a description of the <code>How</code> parameter, see <code><a href="#zip-3">zip/3</a></code>.</p> <p><code>zipwith3(fun(X, Y, Z) -&gt; {X,Y,Z} end, List1, List2, List3)</code> is equivalent to <code>zip3(List1, List2, List3)</code>.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>lists:zipwith3(fun(X, Y, Z) -&gt; X+Y+Z end, [1,2,3], [4,5,6], [7,8,9]).</code>
[12,15,18]
&gt; <code>lists:zipwith3(fun(X, Y, Z) -&gt; [X,Y,Z] end, [a,b,c], [x,y,z], [1,2,3]).</code>
[[a,x,1],[b,y,2],[c,z,3]]</pre> </div></div></article><article class="func"><h3 id="uniq-1" class="bold_code title-link func-head">  <code>uniq(List1) -&gt; List2</code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list containing the elements of <code>List1</code> with duplicated elements removed (preserving the order of the elements). The first occurrence of each element is kept.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>lists:uniq([3,3,1,2,1,2,3]).</code>
[3,1,2]
&gt; <code>lists:uniq([a, a, 1, b, 2, a, 3]).</code>
[a, 1, b, 2, 3]</pre> </div></div></article><article class="func"><h3 id="uniq-2" class="bold_code title-link func-head">  <code>uniq(Fun, List1) -&gt; List2</code><div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Fun = fun((T) -&gt; any())</code></div> <div class="REFTYPES rt-1"><code>List1 = List2 = [T]</code></div>  <div class="REFTYPES rt-1"><code>T = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list containing the elements of <code>List1</code> without the elements for which <code>Fun</code> returned duplicate values (preserving the order of the elements). The first occurrence of each element is kept.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
&gt; <code>lists:uniq(fun({X, _}) -&gt; X end, [{b, 2}, {a, 1}, {c, 3}, {a, 2}]).</code>
[{b, 2}, {a, 1}, {c, 3}]</pre> </div></div></article> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
