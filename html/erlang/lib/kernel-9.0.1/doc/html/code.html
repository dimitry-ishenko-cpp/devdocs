  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">code</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Erlang code server.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module contains the interface to the Erlang <strong>code server</strong>, which deals with the loading of compiled code into a running Erlang runtime system.</p> <p>The runtime system can be started in <strong>interactive</strong> or <strong>embedded</strong> mode. Which one is decided by the command-line flag <code>-mode</code>:</p> <pre data-language="erlang">
% <code>erl -mode interactive</code></pre> <p>The modes are as follows:</p> <ul> <li> <p>In interactive mode, which is default, only some code is loaded during system startup, basically the modules needed by the runtime system. Other code is dynamically loaded when first referenced. When a call to a function in a certain module is made, and the module is not loaded, the code server searches for and tries to load the module.</p> </li> <li> <p>In embedded mode, modules are not auto loaded. Trying to use a module that has not been loaded results in an error. This mode is recommended when the boot script loads all modules, as it is typically done in OTP releases. (Code can still be loaded later by explicitly ordering the code server to do so).</p> </li> </ul> <p>To prevent accidentally reloading of modules affecting the Erlang runtime system, directories <code>kernel</code>, <code>stdlib</code>, and <code>compiler</code> are considered <strong>sticky</strong>. This means that the system issues a warning and rejects the request if a user tries to reload a module residing in any of them. The feature can be disabled by using command-line flag <code>-nostick</code>.</p> </div> </div></section> <section class="innertube"><h2 id="code-path" class="title-link"> <div class="title-name">Code Path</div>  </h2> <div class="REFBODY rb-3"> <p>In interactive mode, the code server maintains a search path, usually called the <strong>code path</strong>, consisting of a list of directories, which it searches sequentially when trying to load a module.</p> <p>Initially, the code path consists of the current working directory and all Erlang object code directories under library directory <code>$OTPROOT/lib</code>, where <code>$OTPROOT</code> is the installation directory of Erlang/OTP, <code>code:root_dir()</code>. Directories can be named <code>Name[-Vsn]</code> and the code server, by default, chooses the directory with the highest version number among those having the same <code>Name</code>. Suffix <code>-Vsn</code> is optional. If an <code>ebin</code> directory exists under <code>Name[-Vsn]</code>, this directory is added to the code path.</p> <p>Environment variable <code>ERL_LIBS</code> (defined in the operating system) can be used to define more library directories to be handled in the same way as the standard OTP library directory described above, except that directories without an <code>ebin</code> directory are ignored.</p> <p>All application directories found in the additional directories appear before the standard OTP applications, except for the Kernel and STDLIB applications, which are placed before any additional applications. In other words, modules found in any of the additional library directories override modules with the same name in OTP, except for modules in Kernel and STDLIB.</p> <p>Environment variable <code>ERL_LIBS</code> (if defined) is to contain a colon-separated (for Unix-like systems) or semicolon-separated (for Windows) list of additional libraries.</p> <p><strong>Example:</strong></p> <p>On a Unix-like system, <code>ERL_LIBS</code> can be set to the following</p> <pre data-language="erlang">/usr/local/jungerl:/home/some_user/my_erlang_lib</pre> <p>On Windows, use semi-colon as separator.</p> <p>The code paths specified by <code>$OTP_ROOT</code>, <code>ERL_LIBS</code>, and boot scripts have their listings cached by default (except for ".") since OTP 26.0. The code server will lookup the contents in their directories once and avoid future file system traversals. Therefore modules added to such directories after the Erlang VM boots won't be picked up. You can disable this behaviour by setting <code>-cache_boot_paths false</code> or by calling <code>code:set_path(code:get_path())</code>.</p> <p>The functions in this module and the command line options <code>-pa</code> and <code>-pz</code> are not cached by default. However, many of the functions that manipulate the code path accept the <code>cache</code> atom as an optional argument, which will enable caching on selected paths.</p> </div></section> <section class="innertube"><h2 id="loading-of-code-from-archive-files" class="title-link"> <div class="title-name">Loading of Code From Archive Files</div>  </h2> <div class="REFBODY rb-3"> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>The support for loading code from archive files is experimental. The purpose of releasing it before it is ready is to obtain early feedback. The file format, semantics, interfaces, and so on, can be changed in a future release. The function <code><a href="#lib_dir-2">lib_dir/2</a></code> and flag <code>-code_path_choice</code> are also experimental.</p>
</div> </div> <p>The Erlang archives are <code>ZIP</code> files with extension <code>.ez</code>. Erlang archives can also be enclosed in <code>escript</code> files whose file extension is arbitrary.</p> <p>Erlang archive files can contain entire Erlang applications or parts of applications. The structure in an archive file is the same as the directory structure for an application. If you, for example, create an archive of <code>mnesia-4.4.7</code>, the archive file must be named <code>mnesia-4.4.7.ez</code> and it must contain a top directory named <code>mnesia-4.4.7</code>. If the version part of the name is omitted, it must also be omitted in the archive. That is, a <code>mnesia.ez</code> archive must contain a <code>mnesia</code> top directory.</p> <p>An archive file for an application can, for example, be created like this:</p> <pre data-language="erlang">
zip:create("mnesia-4.4.7.ez",
	["mnesia-4.4.7"],
	[{cwd, code:lib_dir()},
	 {compress, all},
	 {uncompress,[".beam",".app"]}]).</pre> <p>Any file in the archive can be compressed, but to speed up the access of frequently read files, it can be a good idea to store <code>beam</code> and <code>app</code> files uncompressed in the archive.</p> <p>Normally the top directory of an application is located in library directory <code>$OTPROOT/lib</code> or in a directory referred to by environment variable <code>ERL_LIBS</code>. At startup, when the initial code path is computed, the code server also looks for archive files in these directories and possibly adds <code>ebin</code> directories in archives to the code path. The code path then contains paths to directories that look like <code>$OTPROOT/lib/mnesia.ez/mnesia/ebin</code> or <code>$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin</code>.</p> <p>The code server uses module <code>erl_prim_loader</code> in ERTS (possibly through <code>erl_boot_server</code>) to read code files from archives. However, the functions in <code>erl_prim_loader</code> can also be used by other applications to read files from archives. For example, the call <code>erl_prim_loader:list_dir( "/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)"</code> would list the contents of a directory inside an archive. See <code>erl_prim_loader(3)</code>.</p> <p>An application archive file and a regular application directory can coexist. This can be useful when it is needed to have parts of the application as regular files. A typical case is the <code>priv</code> directory, which must reside as a regular directory to link in drivers dynamically and start port programs. For other applications that do not need this, directory <code>priv</code> can reside in the archive and the files under the directory <code>priv</code> can be read through <code>erl_prim_loader</code>.</p> <p>When a directory is added to the code path and when the entire code path is (re)set, the code server decides which subdirectories in an application that are to be read from the archive and which that are to be read as regular files. If directories are added or removed afterwards, the file access can fail if the code path is not updated (possibly to the same path as before, to trigger the directory resolution update).</p> <p>For each directory on the second level in the application archive (<code>ebin</code>, <code>priv</code>, <code>src</code>, and so on), the code server first chooses the regular directory if it exists and second from the archive. Function <code>code:lib_dir/2</code> returns the path to the subdirectory. For example, <code>code:lib_dir(megaco,ebin)</code> can return <code>/otp/root/lib/megaco-3.9.1.1.ez/megaco-3.9.1.1/ebin</code> while <code>code:lib_dir(megaco,priv)</code> can return <code>/otp/root/lib/megaco-3.9.1.1/priv</code>.</p> <p>When an <code>escript</code> file contains an archive, there are no restrictions on the name of the <code>escript</code> and no restrictions on how many applications that can be stored in the embedded archive. Single Beam files can also reside on the top level in the archive. At startup, the top directory in the embedded archive and all (second level) <code>ebin</code> directories in the embedded archive are added to the code path. See <code>erts:escript(1)</code>.</p> <p>When the choice of directories in the code path is <code>strict</code>, the directory that ends up in the code path is exactly the stated one. This means that if, for example, the directory <code>$OTPROOT/lib/mnesia-4.4.7/ebin</code> is explicitly added to the code path, the code server does not load files from <code>$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin</code>.</p> <p>This behavior can be controlled through command-line flag <code>-code_path_choice Choice</code>. If the flag is set to <code>relaxed</code>, the code server instead chooses a suitable directory depending on the actual file structure. If a regular application <code>ebin</code> directory exists, it is chosen. Otherwise, the directory <code>ebin</code> in the archive is chosen if it exists. If neither of them exists, the original directory is chosen.</p> <p>Command-line flag <code>-code_path_choice Choice</code> also affects how module <code>init</code> interprets the <code>boot script</code>. The interpretation of the explicit code paths in the <code>boot script</code> can be <code>strict</code> or <code>relaxed</code>. It is particularly useful to set the flag to <code>relaxed</code> when elaborating with code loading from archives without editing the <code>boot script</code>. The default is <code>relaxed</code>. See <code>erts:init(3)</code>.</p> </div></section> <section class="innertube"><h2 id="current-and-old-code" class="title-link"> <div class="title-name">Current and Old Code</div>  </h2> <div class="REFBODY rb-3"> <p>The code for a module can exist in two variants in a system: <strong>current code</strong> and <strong>old code</strong>. When a module is loaded into the system for the first time, the module code becomes 'current' and the global <strong>export table</strong> is updated with references to all functions exported from the module.</p> <p>If then a new instance of the module is loaded (for example, because of error correction), the code of the previous instance becomes 'old', and all export entries referring to the previous instance are removed. After that, the new instance is loaded as for the first time, and becomes 'current'.</p> <p>Both old and current code for a module are valid, and can even be evaluated concurrently. The difference is that exported functions in old code are unavailable. Hence, a global call cannot be made to an exported function in old code, but old code can still be evaluated because of processes lingering in it.</p> <p>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it are terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</p> <p>For more information about old and current code, and how to make a process switch from old to current code, see section Compilation and Code Loading in the <code>Erlang Reference Manual</code>.</p> </div></section> <section class="innertube"><h2 id="argument-types-and-invalid-arguments" class="title-link"> <div class="title-name">Argument Types and Invalid Arguments</div>  </h2> <div class="REFBODY rb-3"> <p>Module and application names are atoms, while file and directory names are strings. For backward compatibility reasons, some functions accept both strings and atoms, but a future release will probably only allow the arguments that are documented.</p> <p>Functions in this module generally fail with an exception if they are passed an incorrect type (for example, an integer or a tuple where an atom is expected). An error tuple is returned if the argument type is correct, but there are some other errors (for example, a non-existing directory is specified to <code>set_path/1</code>).</p> </div></section> <section class="innertube"><h2 id="error-reasons-for-code-loading-functions" class="title-link"> <div class="title-name">Error Reasons for Code-Loading Functions</div>  </h2> <div class="REFBODY rb-3"> <p>Functions that load code (such as <code>load_file/1</code>) will return <code>{error,Reason}</code> if the load operation fails. Here follows a description of the common reasons.</p> <dl> <dt class="title-link"><strong><code>badfile</code></strong></dt> <dd> <p>The object code has an incorrect format or the module name in the object code is not the expected module name.</p> </dd> <dt class="title-link"><strong><code>nofile</code></strong></dt> <dd> <p>No file with object code was found.</p> </dd> <dt class="title-link"><strong><code>not_purged</code></strong></dt> <dd> <p>The object code could not be loaded because an old version of the code already existed.</p> </dd> <dt class="title-link"><strong><code>on_load_failure</code></strong></dt> <dd> <p>The module has an <code>-on_load function</code> that failed when it was called.</p> </dd> <dt class="title-link"><strong><code>sticky_directory</code></strong></dt> <dd> <p>The object code resides in a sticky directory.</p> </dd> </dl> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-add_path_ret" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-add_path_ret">add_path_ret()</a> = true | {error, bad_directory}</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-cache" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-cache">cache()</a> = cache | nocache</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-load_ret" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-load_ret">load_ret()</a> = 
 {error, What :: <a href="#type-load_error_rsn">load_error_rsn()</a>} |
 {module, Module :: module()}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-load_error_rsn" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-load_error_rsn">load_error_rsn()</a> = 
 badfile | nofile | not_purged | on_load_failure |
 sticky_directory</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-module_status" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-module_status">module_status()</a> = not_loaded | loaded | modified | removed</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-prepared_code" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-prepared_code">prepared_code()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"><p>An opaque term holding prepared code.</p></div></div></article> <article class="data-types-body"><h3 id="type-replace_path_ret" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-replace_path_ret">replace_path_ret()</a> = 
 true | {error, bad_directory | bad_name | {badarg, term()}}</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-set_path_ret" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-set_path_ret">set_path_ret()</a> = true | {error, bad_directory}</code><br> </div> </h3> </article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="set_path-1" class="bold_code title-link func-head">  <code>set_path(Path) -&gt; <code><a href="#type-set_path_ret">set_path_ret()</a></code></code> </h3> <h3 id="set_path-2" class="bold_code title-link func-head">  <code>set_path(Path, Cache :: <code><a href="#type-cache">cache()</a></code>) -&gt; <code><a href="#type-set_path_ret">set_path_ret()</a></code></code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Path = [Dir :: <a href="file.html#type-filename">file:filename()</a>]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Sets the code path to the list of directories <code>Path</code>.</p> <p>An optional second argument may be set to the atom <code>cache</code> to control if the contents of the directory must be cached on first traversal. Defaults to <code>nocache</code>.</p> <p>Returns:</p> <dl> <dt class="title-link"><strong><code>true</code></strong></dt> <dd><p>If successful</p></dd> <dt class="title-link"><strong><code>{error, bad_directory}</code></strong></dt> <dd><p>If any <code>Dir</code> is not a directory name</p></dd> </dl> </div></div></article><article class="func"><h3 id="get_path-0" class="bold_code title-link func-head">  <code>get_path() -&gt; Path</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Path = [Dir :: <a href="file.html#type-filename">file:filename()</a>]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the code path.</p> </div></div></article><article class="func"><h3 id="add_path-1" class="bold_code title-link func-head">  <code>add_path(Dir) -&gt; <code><a href="#type-add_path_ret">add_path_ret()</a></code></code> </h3> <h3 id="add_path-2" class="bold_code title-link func-head">  <code>add_path(Dir, Cache :: <code><a href="#type-cache">cache()</a></code>) -&gt; <code><a href="#type-add_path_ret">add_path_ret()</a></code></code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <h3 id="add_pathz-1" class="bold_code title-link func-head">  <code>add_pathz(Dir) -&gt; <code><a href="#type-add_path_ret">add_path_ret()</a></code></code> </h3> <h3 id="add_pathz-2" class="bold_code title-link func-head">  <code>add_pathz(Dir, Cache :: <code><a href="#type-cache">cache()</a></code>) -&gt; <code><a href="#type-add_path_ret">add_path_ret()</a></code></code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Dir = <a href="file.html#type-filename">file:filename()</a></code></div> <div class="REFTYPES rt-2"> <code>add_path_ret() = true | {error, bad_directory}</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Adds <code>Dir</code> to the code path. The directory is added as the last directory in the new path. If <code>Dir</code> already exists in the path, it is not added.</p> <p>An optional second argument may be set to the atom <code>cache</code> to control if the contents of the directory must be cached on first traversal. Defaults to <code>nocache</code>.</p> <p>Returns <code>true</code> if successful, or <code>{error, bad_directory}</code> if <code>Dir</code> is not the name of a directory.</p> </div></div></article><article class="func"><h3 id="add_patha-1" class="bold_code title-link func-head">  <code>add_patha(Dir) -&gt; <code><a href="#type-add_path_ret">add_path_ret()</a></code></code> </h3> <h3 id="add_patha-2" class="bold_code title-link func-head">  <code>add_patha(Dir, Cache :: <code><a href="#type-cache">cache()</a></code>) -&gt; <code><a href="#type-add_path_ret">add_path_ret()</a></code></code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Dir = <a href="file.html#type-filename">file:filename()</a></code></div> <div class="REFTYPES rt-2"> <code>add_path_ret() = true | {error, bad_directory}</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Adds <code>Dir</code> to the beginning of the code path. If <code>Dir</code> exists, it is removed from the old position in the code path.</p> <p>An optional second argument may be set to the atom <code>cache</code> to control if the contents of the directory must be cached on first traversal. Defaults to <code>nocache</code>.</p> <p>Returns <code>true</code> if successful, or <code>{error, bad_directory}</code> if <code>Dir</code> is not the name of a directory.</p> </div></div></article><article class="func"><h3 id="add_paths-1" class="bold_code title-link func-head">  <code>add_paths(Dirs) -&gt; ok</code> </h3> <h3 id="add_paths-2" class="bold_code title-link func-head">  <code>add_paths(Dirs, Cache :: <code><a href="#type-cache">cache()</a></code>) -&gt; ok</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <h3 id="add_pathsz-1" class="bold_code title-link func-head">  <code>add_pathsz(Dirs) -&gt; ok</code> </h3> <h3 id="add_pathsz-2" class="bold_code title-link func-head">  <code>add_pathsz(Dirs, Cache :: <code><a href="#type-cache">cache()</a></code>) -&gt; ok</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Dirs = [Dir :: <a href="file.html#type-filename">file:filename()</a>]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Adds the directories in <code>Dirs</code> to the end of the code path. If a <code>Dir</code> exists, it is not added.</p> <p>An optional second argument may be set to the atom <code>cache</code> to control if the contents of the directory must be cached on first traversal. Defaults to <code>nocache</code>.</p> <p>Always returns <code>ok</code>, regardless of the validity of each individual <code>Dir</code>.</p> </div></div></article><article class="func"><h3 id="add_pathsa-1" class="bold_code title-link func-head">  <code>add_pathsa(Dirs) -&gt; ok</code> </h3> <h3 id="add_pathsa-2" class="bold_code title-link func-head">  <code>add_pathsa(Dirs, Cache :: <code><a href="#type-cache">cache()</a></code>) -&gt; ok</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Dirs = [Dir :: <a href="file.html#type-filename">file:filename()</a>]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Traverses <code>Dirs</code> and adds each <code>Dir</code> to the beginning of the code path. This means that the order of <code>Dirs</code> is reversed in the resulting code path. For example, if you add <code>[Dir1,Dir2]</code>, the resulting path will be <code>[Dir2,Dir1|OldCodePath]</code>.</p> <p>If a <code>Dir</code> already exists in the code path, it is removed from the old position.</p> <p>An optional second argument may be set to the atom <code>cache</code> to control if the contents of the directory must be cached on first traversal. Defaults to <code>nocache</code>.</p> <p>Always returns <code>ok</code>, regardless of the validity of each individual <code>Dir</code>.</p> </div></div></article><article class="func"><h3 id="del_path-1" class="bold_code title-link func-head">  <code>del_path(NameOrDir) -&gt; <code>boolean()</code> | {error, What}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>NameOrDir = Name | Dir</code></div> <div class="REFTYPES rt-1"><code>Name = atom()</code></div> <div class="REFTYPES rt-1"><code>Dir = <a href="file.html#type-filename">file:filename()</a></code></div> <div class="REFTYPES rt-1"><code>What = bad_name</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Deletes a directory from the code path. The argument can be an atom <code>Name</code>, in which case the directory with the name <code>.../Name[-Vsn][/ebin]</code> is deleted from the code path. Also, the complete directory name <code>Dir</code> can be specified as argument.</p> <p>Returns:</p> <dl> <dt class="title-link"><strong><code>true</code></strong></dt> <dd><p>If successful</p></dd> <dt class="title-link"><strong><code>false</code></strong></dt> <dd><p>If the directory is not found</p></dd> <dt class="title-link"><strong><code>{error, bad_name}</code></strong></dt> <dd><p>If the argument is invalid</p></dd> </dl> </div></div></article><article class="func"><h3 id="del_paths-1" class="bold_code title-link func-head">  <code>del_paths(NamesOrDirs) -&gt; ok</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>NamesOrDirs = [Name | Dir]</code></div> <div class="REFTYPES rt-1"><code>Name = atom()</code></div> <div class="REFTYPES rt-1"><code>Dir = <a href="file.html#type-filename">file:filename()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Deletes directories from the code path. The argument is a list of either atoms or complete directory names. If an atom <code>Name</code>, the directory with the name <code>.../Name[-Vsn][/ebin]</code> is deleted from the code path.</p> <p>Always returns <code>ok</code>, regardless of the validity of each individual <code>NamesOrDirs</code>.</p> </div></div></article><article class="func"><h3 id="clear_cache-0" class="bold_code title-link func-head">  <code>clear_cache() -&gt; ok</code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Clear the code path cache. If a directory is cached, its cache is cleared once and then it will be recalculated and cached once more in a future traversal.</p> <p>If you want to clear the cache for a single path, you might re-add it to the code path (with <code>add_path/2</code>) or replace it (with <code>replace_path/3</code>). If you want to disable all cache, you can reset the code path with <code>code:set_path(code:get_path())</code>.</p> <p>Always returns <code>ok</code>.</p> </div></div></article><article class="func"><h3 id="replace_path-2" class="bold_code title-link func-head">  <code>replace_path(Name, Dir) -&gt; <code><a href="#type-replace_path_ret">replace_path_ret()</a></code></code> </h3> <h3 id="replace_path-3" class="bold_code title-link func-head">  <code>replace_path(Name, Dir, Cache :: <code><a href="#type-cache">cache()</a></code>) -&gt; <code><a href="#type-replace_path_ret">replace_path_ret()</a></code></code><div class="title-since"><span class="since">OTP 26.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = atom()</code></div> <div class="REFTYPES rt-1"><code>Dir = <a href="file.html#type-filename">file:filename()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Replaces an old occurrence of a directory named <code>.../Name[-Vsn][/ebin]</code> in the code path, with <code>Dir</code>. If <code>Name</code> does not exist, it adds the new directory <code>Dir</code> last in the code path. The new directory must also be named <code>.../Name[-Vsn][/ebin]</code>. This function is to be used if a new version of the directory (library) is added to a running system.</p> <p>An optional third argument may be set to the atom <code>cache</code> to control if the contents of the directory must be cached on first traversal. Defaults to <code>nocache</code>.</p> <p>Returns:</p> <dl> <dt class="title-link"><strong><code>true</code></strong></dt> <dd><p>If successful</p></dd> <dt class="title-link"><strong><code>{error, bad_name}</code></strong></dt> <dd><p>If <code>Name</code> is not found</p></dd> <dt class="title-link"><strong><code>{error, bad_directory}</code></strong></dt> <dd><p>If <code>Dir</code> does not exist</p></dd> <dt class="title-link"><strong><code>{error, {badarg, [Name, Dir]}}</code></strong></dt> <dd><p>If <code>Name</code> or <code>Dir</code> is invalid</p></dd> </dl> </div></div></article><article class="func"><h3 id="load_file-1" class="bold_code title-link func-head">  <code>load_file(Module) -&gt; <code><a href="#type-load_ret">load_ret()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-2"> <pre><code>load_ret() = 
 {error, What :: <a href="#type-load_error_rsn">load_error_rsn()</a>} |
 {module, Module :: module()}</code></pre>
<br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Tries to load the Erlang module <code>Module</code>, using the code path. It looks for the object code file with an extension corresponding to the Erlang machine used, for example, <code>Module.beam</code>. The loading fails if the module name found in the object code differs from the name <code>Module</code>. <code><a href="#load_binary-3">load_binary/3</a></code> must be used to load object code with a module name that is different from the file name.</p> <p>Returns <code>{module, Module}</code> if successful, or <code>{error, Reason}</code> if loading fails. See <code><a href="#error_reasons">Error Reasons for Code-Loading Functions</a></code> for a description of the possible error reasons.</p> </div></div></article><article class="func"><h3 id="load_abs-1" class="bold_code title-link func-head">  <code>load_abs(Filename) -&gt; <code><a href="#type-load_ret">load_ret()</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Filename = <a href="file.html#type-filename">file:filename()</a></code></div> <div class="REFTYPES rt-2"> <pre><code>load_ret() = 
 {error, What :: <a href="#type-load_error_rsn">load_error_rsn()</a>} |
 {module, Module :: module()}</code></pre>
<br> </div> <div class="REFTYPES rt-2"> <pre><code>loaded_filename() = 
 (Filename :: <a href="file.html#type-filename">file:filename()</a>) | loaded_ret_atoms()</code></pre>
<br> </div> <div class="REFTYPES rt-2"> <code>loaded_ret_atoms() = cover_compiled | preloaded</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Same as <code>load_file(Module)</code>, but <code>Filename</code> is an absolute or relative filename. The code path is not searched. It returns a value in the same way as <code><a href="#load_file-1">load_file/1</a></code>. Notice that <code>Filename</code> must not contain the extension (for example, <code>.beam</code>) because <code>load_abs/1</code> adds the correct extension.</p> </div></div></article><article class="func"><h3 id="ensure_loaded-1" class="bold_code title-link func-head">  <code>ensure_loaded(Module) -&gt; {module, Module} | {error, What}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>What = embedded | badfile | nofile | on_load_failure</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Tries to load a module in the same way as <code><a href="#load_file-1">load_file/1</a></code>, unless the module is already loaded. However, in embedded mode it does not load a module that is not already loaded, but returns <code>{error, embedded}</code> instead. See <code><a href="#error_reasons">Error Reasons for Code-Loading Functions</a></code> for a description of other possible error reasons.</p> </div></div></article><article class="func"><h3 id="load_binary-3" class="bold_code title-link func-head">  <pre data-language="erlang"><code>load_binary(Module, Filename, Binary) -&gt;
 {module, Module} | {error, What}</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Filename = loaded_filename()</code></div> <div class="REFTYPES rt-1"><code>Binary = binary()</code></div> <div class="REFTYPES rt-1"><code>What = badarg | <a href="#type-load_error_rsn">load_error_rsn()</a></code></div> <div class="REFTYPES rt-2"> <pre><code>loaded_filename() = 
 (Filename :: <a href="file.html#type-filename">file:filename()</a>) | loaded_ret_atoms()</code></pre>
<br> </div> <div class="REFTYPES rt-2"> <code>loaded_ret_atoms() = cover_compiled | preloaded</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>This function can be used to load object code on remote Erlang nodes. Argument <code>Binary</code> must contain object code for <code>Module</code>. <code>Filename</code> is only used by the code server to keep a record of from which file the object code for <code>Module</code> comes. Thus, <code>Filename</code> is not opened and read by the code server.</p> <p>Returns <code>{module, Module}</code> if successful, or <code>{error, Reason}</code> if loading fails. See <code><a href="#error_reasons">Error Reasons for Code-Loading Functions</a></code> for a description of the possible error reasons.</p> </div></div></article><article class="func"><h3 id="atomic_load-1" class="bold_code title-link func-head">  <code>atomic_load(Modules) -&gt; ok | {error, [{Module, What}]}</code><div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Modules = [Module | {Module, Filename, Binary}]</code></div> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Filename = <a href="file.html#type-filename">file:filename()</a></code></div> <div class="REFTYPES rt-1"><code>Binary = binary()</code></div> <div class="REFTYPES rt-1"><pre><code>What = 
 badfile | nofile | on_load_not_allowed | duplicated |
 not_purged | sticky_directory | pending_on_load</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Tries to load all of the modules in the list <code>Modules</code> atomically. That means that either all modules are loaded at the same time, or none of the modules are loaded if there is a problem with any of the modules.</p> <p>Loading can fail for one the following reasons:</p> <dl> <dt class="title-link"><strong><code>badfile</code></strong></dt> <dd> <p>The object code has an incorrect format or the module name in the object code is not the expected module name.</p> </dd> <dt class="title-link"><strong><code>nofile</code></strong></dt> <dd> <p>No file with object code exists.</p> </dd> <dt class="title-link"><strong><code>on_load_not_allowed</code></strong></dt> <dd> <p>A module contains an <code>-on_load function</code>.</p> </dd> <dt class="title-link"><strong><code>duplicated</code></strong></dt> <dd> <p>A module is included more than once in <code>Modules</code>.</p> </dd> <dt class="title-link"><strong><code>not_purged</code></strong></dt> <dd> <p>The object code cannot be loaded because an old version of the code already exists.</p> </dd> <dt class="title-link"><strong><code>sticky_directory</code></strong></dt> <dd> <p>The object code resides in a sticky directory.</p> </dd> <dt class="title-link"><strong><code>pending_on_load</code></strong></dt> <dd> <p>A previously loaded module contains an <code>-on_load</code> function that never finished.</p> </dd> </dl> <p>If it is important to minimize the time that an application is inactive while changing code, use <code><a href="#prepare_loading-1">prepare_loading/1</a></code> and <code><a href="#finish_loading-1">finish_loading/1</a></code> instead of <code>atomic_load/1</code>. Here is an example:</p> <pre data-language="erlang">
{ok,Prepared} = code:prepare_loading(Modules),
%% Put the application into an inactive state or do any
%% other preparation needed before changing the code.
ok = code:finish_loading(Prepared),
%% Resume the application.</pre> </div></div></article><article class="func"><h3 id="prepare_loading-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>prepare_loading(Modules) -&gt;
 {ok, Prepared} | {error, [{Module, What}]}</code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Modules = [Module | {Module, Filename, Binary}]</code></div> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Filename = <a href="file.html#type-filename">file:filename()</a></code></div> <div class="REFTYPES rt-1"><code>Binary = binary()</code></div> <div class="REFTYPES rt-1"><code>Prepared = <a href="#type-prepared_code">prepared_code()</a></code></div> <div class="REFTYPES rt-1"><code>What = badfile | nofile | on_load_not_allowed | duplicated</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Prepares to load the modules in the list <code>Modules</code>. Finish the loading by calling <code><a href="#finish_loading-1">finish_loading(Prepared)</a></code>.</p> <p>This function can fail with one of the following error reasons:</p> <dl> <dt class="title-link"><strong><code>badfile</code></strong></dt> <dd> <p>The object code has an incorrect format or the module name in the object code is not the expected module name.</p> </dd> <dt class="title-link"><strong><code>nofile</code></strong></dt> <dd> <p>No file with object code exists.</p> </dd> <dt class="title-link"><strong><code>on_load_not_allowed</code></strong></dt> <dd> <p>A module contains an <code>-on_load function</code>.</p> </dd> <dt class="title-link"><strong><code>duplicated</code></strong></dt> <dd> <p>A module is included more than once in <code>Modules</code>.</p> </dd> </dl> </div></div></article><article class="func"><h3 id="finish_loading-1" class="bold_code title-link func-head">  <code>finish_loading(Prepared) -&gt; ok | {error, [{Module, What}]}</code><div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Prepared = <a href="#type-prepared_code">prepared_code()</a></code></div> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>What = not_purged | sticky_directory | pending_on_load</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Tries to load code for all modules that have been previously prepared by <code><a href="#prepare_loading-1">prepare_loading/1</a></code>. The loading occurs atomically, meaning that either all modules are loaded at the same time, or none of the modules are loaded.</p> <p>This function can fail with one of the following error reasons:</p> <dl> <dt class="title-link"><strong><code>not_purged</code></strong></dt> <dd> <p>The object code cannot be loaded because an old version of the code already exists.</p> </dd> <dt class="title-link"><strong><code>sticky_directory</code></strong></dt> <dd> <p>The object code resides in a sticky directory.</p> </dd> <dt class="title-link"><strong><code>pending_on_load</code></strong></dt> <dd> <p>A previously loaded module contains an <code>-on_load</code> function that never finished.</p> </dd> </dl> </div></div></article><article class="func"><h3 id="ensure_modules_loaded-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>ensure_modules_loaded(Modules :: [Module]) -&gt;
 ok | {error, [{Module, What}]}</code></pre>
<div class="title-since"><span class="since">OTP 19.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>What = badfile | nofile | on_load_failure</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Tries to load any modules not already loaded in the list <code>Modules</code> in the same way as <code><a href="#load_file-1">load_file/1</a></code>.</p> <p>Returns <code>ok</code> if successful, or <code>{error,[{Module,Reason}]}</code> if loading of some modules fails. See <code><a href="#error_reasons">Error Reasons for Code-Loading Functions</a></code> for a description of other possible error reasons.</p> </div></div></article><article class="func"><h3 id="delete-1" class="bold_code title-link func-head">  <code>delete(Module) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Removes the current code for <code>Module</code>, that is, the current code for <code>Module</code> is made old. This means that processes can continue to execute the code in the module, but no external function calls can be made to it.</p> <p>Returns <code>true</code> if successful, or <code>false</code> if there is old code for <code>Module</code> that must be purged first, or if <code>Module</code> is not a (loaded) module.</p> </div></div></article><article class="func"><h3 id="purge-1" class="bold_code title-link func-head">  <code>purge(Module) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Purges the code for <code>Module</code>, that is, removes code marked as old. If some processes still linger in the old code, these processes are killed before the code is removed.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>As of ERTS version 9.0, a process is only considered to be lingering in the code if it has direct references to the code. For more information see documentation of <code>erlang:check_process_code/3</code>, which is used in order to determine this.</p>
</div> </div> <p>Returns <code>true</code> if successful and any process is needed to be killed, otherwise <code>false</code>.</p> </div></div></article><article class="func"><h3 id="soft_purge-1" class="bold_code title-link func-head">  <code>soft_purge(Module) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Purges the code for <code>Module</code>, that is, removes code marked as old, but only if no processes linger in it.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>As of ERTS version 9.0, a process is only considered to be lingering in the code if it has direct references to the code. For more information see documentation of <code>erlang:check_process_code/3</code>, which is used in order to determine this.</p>
</div> </div> <p>Returns <code>false</code> if the module cannot be purged because of processes lingering in old code, otherwise <code>true</code>.</p> </div></div></article><article class="func"><h3 id="is_loaded-1" class="bold_code title-link func-head">  <code>is_loaded(Module) -&gt; {file, Loaded} | false</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Loaded = loaded_filename()</code></div> <div class="REFTYPES rt-2"> <pre><code>loaded_filename() = 
 (Filename :: <a href="file.html#type-filename">file:filename()</a>) | loaded_ret_atoms()</code></pre>
<br> </div> <div class="REFBODY rb-1"> <code>Filename</code> is an absolute filename.</div> <div class="REFTYPES rt-2"> <code>loaded_ret_atoms() = cover_compiled | preloaded</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Checks if <code>Module</code> is loaded. If it is, <code>{file, Loaded}</code> is returned, otherwise <code>false</code>.</p> <p>Normally, <code>Loaded</code> is the absolute filename <code>Filename</code> from which the code is obtained. If the module is preloaded (see <code>script(4)</code>), <code>Loaded==preloaded</code>. If the module is Cover-compiled (see <code>cover(3)</code>), <code>Loaded==cover_compiled</code>.</p> </div></div></article><article class="func"><h3 id="all_available-0" class="bold_code title-link func-head">  <code>all_available() -&gt; [{Module, Filename, Loaded}]</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = string()</code></div> <div class="REFTYPES rt-1"><code>Filename = loaded_filename()</code></div> <div class="REFTYPES rt-1"><code>Loaded = boolean()</code></div> <div class="REFTYPES rt-2"> <pre><code>loaded_filename() = 
 (Filename :: <a href="file.html#type-filename">file:filename()</a>) | loaded_ret_atoms()</code></pre>
<br> </div> <div class="REFBODY rb-1"> <code>Filename</code> is an absolute filename.</div> <div class="REFTYPES rt-2"> <code>loaded_ret_atoms() = cover_compiled | preloaded</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list of tuples <code>{Module, Filename, Loaded}</code> for all available modules. A module is considered to be available if it either is loaded or would be loaded if called. <code>Filename</code> is normally the absolute filename, as described for <code><a href="#is_loaded-1">is_loaded/1</a></code>.</p> </div></div></article><article class="func"><h3 id="all_loaded-0" class="bold_code title-link func-head">  <code>all_loaded() -&gt; [{Module, Loaded}]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Loaded = loaded_filename()</code></div> <div class="REFTYPES rt-2"> <pre><code>loaded_filename() = 
 (Filename :: <a href="file.html#type-filename">file:filename()</a>) | loaded_ret_atoms()</code></pre>
<br> </div> <div class="REFBODY rb-1"> <code>Filename</code> is an absolute filename.</div> <div class="REFTYPES rt-2"> <code>loaded_ret_atoms() = cover_compiled | preloaded</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list of tuples <code>{Module, Loaded}</code> for all loaded modules. <code>Loaded</code> is normally the absolute filename, as described for <code><a href="#is_loaded-1">is_loaded/1</a></code>.</p> </div></div></article><article class="func"><h3 id="which-1" class="bold_code title-link func-head">  <code>which(Module) -&gt; Which</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Which = loaded_filename() | non_existing</code></div> <div class="REFTYPES rt-2"> <pre><code>loaded_filename() = 
 (Filename :: <a href="file.html#type-filename">file:filename()</a>) | loaded_ret_atoms()</code></pre>
<br> </div> <div class="REFTYPES rt-2"> <code>loaded_ret_atoms() = cover_compiled | preloaded</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>If the module is not loaded, this function searches the code path for the first file containing object code for <code>Module</code> and returns the absolute filename.</p> <p>If the module is loaded, it returns the name of the file containing the loaded object code.</p> <p>If the module is preloaded, <code>preloaded</code> is returned.</p> <p>If the module is Cover-compiled, <code>cover_compiled</code> is returned.</p> <p>If the module cannot be found, <code>non_existing</code> is returned.</p> </div></div></article><article class="func"><h3 id="get_object_code-1" class="bold_code title-link func-head">  <code>get_object_code(Module) -&gt; {Module, Binary, Filename} | error</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> <div class="REFTYPES rt-1"><code>Binary = binary()</code></div> <div class="REFTYPES rt-1"><code>Filename = <a href="file.html#type-filename">file:filename()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Searches the code path for the object code of module <code>Module</code>. Returns <code>{Module, Binary, Filename}</code> if successful, otherwise <code>error</code>. <code>Binary</code> is a binary data object, which contains the object code for the module. This can be useful if code is to be loaded on a remote node in a distributed system. For example, loading module <code>Module</code> on a node <code>Node</code> is done as follows:</p> <pre data-language="erlang">...
{_Module, Binary, Filename} = code:get_object_code(Module),
rpc:call(Node, code, load_binary, [Module, Filename, Binary]),
...</pre> </div></div></article><article class="func"><h3 id="get_doc-1" class="bold_code title-link func-head">  <code>get_doc(Mod) -&gt; {ok, Res} | {error, Reason}</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Mod = module()</code></div> <div class="REFTYPES rt-1"><code>Res = #docs_v1{}</code></div> <div class="REFTYPES rt-1"><code>Reason = non_existing | missing | <a href="file.html#type-posix">file:posix()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Searches the code path for EEP-48 style documentation and returns it if available. If no documentation can be found the function tries to generate documentation from the debug information in the module. If no debug information is available, this function will return <code>{error,missing}</code>. </p> <p>For more information about the documentation chunk see <code>Documentation Storage and Format</code> in Kernel's User's Guide.</p> </div></div></article><article class="func"><h3 id="root_dir-0" class="bold_code title-link func-head">  <code>root_dir() -&gt; <code><a href="file.html#type-filename">file:filename()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the root directory of Erlang/OTP, which is the directory where it is installed.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>code:root_dir().</code>
"/usr/local/otp"</pre> </div></div></article><article class="func"><h3 id="lib_dir-0" class="bold_code title-link func-head">  <code>lib_dir() -&gt; <code><a href="file.html#type-filename">file:filename()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the library directory, <code>$OTPROOT/lib</code>, where <code>$OTPROOT</code> is the root directory of Erlang/OTP.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>code:lib_dir().</code>
"/usr/local/otp/lib"</pre> </div></div></article><article class="func"><h3 id="lib_dir-1" class="bold_code title-link func-head">  <code>lib_dir(Name) -&gt; <code><a href="file.html#type-filename">file:filename()</a></code> | {error, bad_name}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = atom()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the path for the "library directory", the top directory, for an application <code>Name</code> located under <code>$OTPROOT/lib</code> or on a directory referred to with environment variable <code>ERL_LIBS</code>.</p> <p>If a regular directory called <code>Name</code> or <code>Name-Vsn</code> exists in the code path with an <code>ebin</code> subdirectory, the path to this directory is returned (not the <code>ebin</code> directory).</p> <p>If the directory refers to a directory in an archive, the archive name is stripped away before the path is returned. For example, if directory <code>/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin</code> is in the path, <code>/usr/local/otp/lib/mnesia-4.2.2/ebin</code> is returned. This means that the library directory for an application is the same, regardless if the application resides in an archive or not.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>code:lib_dir(mnesia).</code>
"/usr/local/otp/lib/mnesia-4.2.2"</pre> <p>Returns <code>{error, bad_name}</code> if <code>Name</code> is not the name of an application under <code>$OTPROOT/lib</code> or on a directory referred to through environment variable <code>ERL_LIBS</code>. Fails with an exception if <code>Name</code> has the wrong type.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>For backward compatibility, <code>Name</code> is also allowed to be a string. That will probably change in a future release.</p>
</div> </div> </div></div></article><article class="func"><h3 id="lib_dir-2" class="bold_code title-link func-head">  <code>lib_dir(Name, SubDir) -&gt; <code><a href="file.html#type-filename">file:filename()</a></code> | {error, bad_name}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = SubDir = atom()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the path to a subdirectory directly under the top directory of an application. Normally the subdirectories reside under the top directory for the application, but when applications at least partly reside in an archive, the situation is different. Some of the subdirectories can reside as regular directories while others reside in an archive file. It is not checked whether this directory exists.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
&gt; <code>code:lib_dir(megaco, priv).</code>
"/usr/local/otp/lib/megaco-3.9.1.1/priv"</pre> <p>Fails with an exception if <code>Name</code> or <code>SubDir</code> has the wrong type.</p> </div></div></article><article class="func"><h3 id="compiler_dir-0" class="bold_code title-link func-head">  <code>compiler_dir() -&gt; <code><a href="file.html#type-filename">file:filename()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the compiler library directory. Equivalent to <code>code:lib_dir(compiler)</code>.</p> </div></div></article><article class="func"><h3 id="priv_dir-1" class="bold_code title-link func-head">  <code>priv_dir(Name) -&gt; <code><a href="file.html#type-filename">file:filename()</a></code> | {error, bad_name}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = atom()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the path to the <code>priv</code> directory in an application. Equivalent to <code>code:lib_dir(Name, priv)</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>For backward compatibility, <code>Name</code> is also allowed to be a string. That will probably change in a future release.</p>
</div> </div> </div></div></article><article class="func"><h3 id="objfile_extension-0" class="bold_code title-link func-head">  <code>objfile_extension() -&gt; <code>nonempty_string()</code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the object code file extension corresponding to the Erlang machine used, namely <code>.beam</code>.</p> </div></div></article><article class="func"><h3 id="stick_dir-1" class="bold_code title-link func-head">  <code>stick_dir(Dir) -&gt; ok | error</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Dir = <a href="file.html#type-filename">file:filename()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Marks <code>Dir</code> as sticky.</p> <p>Returns <code>ok</code> if successful, otherwise <code>error</code>.</p> </div></div></article><article class="func"><h3 id="unstick_dir-1" class="bold_code title-link func-head">  <code>unstick_dir(Dir) -&gt; ok | error</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Dir = <a href="file.html#type-filename">file:filename()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Unsticks a directory that is marked as sticky.</p> <p>Returns <code>ok</code> if successful, otherwise <code>error</code>.</p> </div></div></article><article class="func"><h3 id="is_sticky-1" class="bold_code title-link func-head">  <code>is_sticky(Module) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Module = module()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns <code>true</code> if <code>Module</code> is the name of a module that has been loaded from a sticky directory (in other words: an attempt to reload the module will fail), or <code>false</code> if <code>Module</code> is not a loaded module or is not sticky.</p> </div></div></article><article class="func"><h3 id="where_is_file-1" class="bold_code title-link func-head">  <code>where_is_file(Filename) -&gt; non_existing | Absname</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Filename = Absname = <a href="file.html#type-filename">file:filename()</a></code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Searches the code path for <code>Filename</code>, a file of arbitrary type. If found, the full name is returned. <code>non_existing</code> is returned if the file cannot be found. The function can be useful, for example, to locate application resource files.</p> </div></div></article><article class="func"><h3 id="clash-0" class="bold_code title-link func-head">  <code>clash() -&gt; ok</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Searches all directories in the code path for module names with identical names and writes a report to <code>stdout</code>.</p> </div></div></article><article class="func"><h3 id="module_status-0" class="bold_code title-link func-head">  <code>module_status() -&gt; [{<code>module()</code>, <code><a href="#type-module_status">module_status()</a></code>}]</code><div class="title-since"><span class="since">OTP 23.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-2"> <code>module_status() = not_loaded | loaded | modified | removed</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>See <code><a href="#module_status-1">module_status/1</a></code> and <code><a href="#all_loaded-0">all_loaded/0</a></code> for details.</p> </div></div></article><article class="func"><h3 id="module_status-1" class="bold_code title-link func-head">  <pre data-language="erlang"><code>module_status(Module :: <code>module()</code> | [<code>module()</code>]) -&gt;
 <code><a href="#type-module_status">module_status()</a></code> | [{<code>module()</code>, <code><a href="#type-module_status">module_status()</a></code>}]</code></pre>
<div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-2"> <code>module_status() = not_loaded | loaded | modified | removed</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>The status of a module can be one of:</p> <dl> <dt class="title-link"><strong><code>not_loaded</code></strong></dt> <dd><p>If <code>Module</code> is not currently loaded.</p></dd> <dt class="title-link"><strong><code>loaded</code></strong></dt> <dd><p>If <code>Module</code> is loaded and the object file exists and contains the same code.</p></dd> <dt class="title-link"><strong><code>removed</code></strong></dt> <dd><p>If <code>Module</code> is loaded but no corresponding object file can be found in the code path.</p></dd> <dt class="title-link"><strong><code>modified</code></strong></dt> <dd><p>If <code>Module</code> is loaded but the object file contains code with a different MD5 checksum.</p></dd> </dl> <p>Preloaded modules are always reported as <code>loaded</code>, without inspecting the contents on disk. Cover compiled modules will always be reported as <code>modified</code> if an object file exists, or as <code>removed</code> otherwise. Modules whose load path is an empty string (which is the convention for auto-generated code) will only be reported as <code>loaded</code> or <code>not_loaded</code>.</p> <p>See also <code><a href="#modified_modules-0">modified_modules/0</a></code>.</p> </div></div></article><article class="func"><h3 id="modified_modules-0" class="bold_code title-link func-head">  <code>modified_modules() -&gt; [<code>module()</code>]</code><div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the list of all currently loaded modules for which <code><a href="#module_status-1">module_status/1</a></code> returns <code>modified</code>. See also <code><a href="#all_loaded-0">all_loaded/0</a></code>.</p> </div></div></article><article class="func"><h3 id="get_mode-0" class="bold_code title-link func-head">  <code>get_mode() -&gt; embedded | interactive</code><div class="title-since"><span class="since">OTP R16B</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns an atom describing the mode of the code server: <code>interactive</code> or <code>embedded</code>.</p> <p>This information is useful when an external entity (for example, an IDE) provides additional code for a running node. If the code server is in interactive mode, it only has to add the path to the code. If the code server is in embedded mode, the code must be loaded with <code><a href="#load_binary-3">load_binary/3</a></code>.</p> </div></div></article> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
