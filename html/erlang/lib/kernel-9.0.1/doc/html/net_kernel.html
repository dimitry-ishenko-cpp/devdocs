  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">net_kernel</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Erlang networking kernel.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>The net kernel is a system process, registered as <code>net_kernel</code>, which must be operational for distributed Erlang to work. The purpose of this process is to implement parts of the BIFs <code>spawn/4</code> and <code>spawn_link/4</code>, and to provide monitoring of the network.</p> <p>An Erlang node is started using command-line flag <code>-name</code> or <code>-sname</code>:</p> <pre data-language="erlang">
$ <code>erl -sname foobar</code></pre> <p>It is also possible to call <code><a href="#start-2">net_kernel:start(foobar, #{})</a></code> directly from the normal Erlang shell prompt:</p> <pre data-language="erlang">
1&gt; <code>net_kernel:start(foobar, #{name_domain =&gt; shortnames}).</code>
{ok,&lt;0.64.0&gt;}
(foobar@gringotts)2&gt;</pre> <p>If the node is started with command-line flag <code>-sname</code>, the node name is <code>foobar@Host</code>, where <code>Host</code> is the short name of the host (not the fully qualified domain name). If started with flag <code>-name</code>, the node name is <code>foobar@Host</code>, where <code>Host</code> is the fully qualified domain name. For more information, see <code>erl</code>.</p> <p>Normally, connections are established automatically when another node is referenced. This functionality can be disabled by setting Kernel configuration parameter <code>dist_auto_connect</code> to <code>never</code>, see <code><span>kernel(6)</span></code>. In this case, connections must be established explicitly by calling <code><a href="#connect_node-1">connect_node/1</a></code>.</p> <p>Which nodes that are allowed to communicate with each other is handled by the magic cookie system, see section <code>Distributed Erlang</code> in the Erlang Reference Manual.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> Starting a distributed node without also specifying <code>-proto_dist inet_tls</code> will expose the node to attacks that may give the attacker complete access to the node and in extension the cluster. When using un-secure distributed nodes, make sure that the network is configured to keep potential attackers out. See the <code> Using SSL for Erlang Distribution</code> User's Guide for details on how to setup a secure distributed node. </p> </div> </div> </div> </div></section> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="allow-1" class="bold_code title-link func-head">  <code>allow(Nodes) -&gt; ok | error</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Nodes = [node()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Permits access to the specified set of nodes.</p> <p>Before the first call to <code>allow/1</code>, any node with the correct cookie can be connected. When <code>allow/1</code> is called, a list of allowed nodes is established. Any access attempts made from (or to) nodes not in that list will be rejected.</p> <p>Subsequent calls to <code>allow/1</code> will add the specified nodes to the list of allowed nodes. It is not possible to remove nodes from the list.</p> <p>Returns <code>error</code> if any element in <code>Nodes</code> is not an atom.</p> </div></div></article><article class="func"><h3 id="connect_node-1" class="bold_code title-link func-head">  <code>connect_node(Node) -&gt; <code>boolean()</code> | ignored</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Node = node()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Establishes a connection to <code>Node</code>. Returns <code>true</code> if a connection was established or was already established or if <code>Node</code> is the local node itself. Returns <code>false</code> if the connection attempt failed, and <code>ignored</code> if the local node is not alive.</p> </div></div></article><article class="func"><h3 id="get_net_ticktime-0" class="bold_code title-link func-head">  <code>get_net_ticktime() -&gt; Res</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Res = NetTicktime | {ongoing_change_to, NetTicktime} | ignored</code></div> <div class="REFTYPES rt-1"><code>NetTicktime = integer() &gt;= 1</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns currently used net tick time in seconds. For more information see the <code><span>net_ticktime</span></code> <code>kernel(6)</code> parameter.</p> <p>Defined return values (<code>Res</code>):</p> <dl> <dt class="title-link"><strong><code>NetTicktime</code></strong></dt> <dd><p><code>net_ticktime</code> is <code>NetTicktime</code> seconds.</p></dd> <dt class="title-link"><strong><code>{ongoing_change_to, NetTicktime}</code></strong></dt> <dd><p><code>net_kernel</code> is currently changing <code>net_ticktime</code> to <code>NetTicktime</code> seconds.</p></dd> <dt class="title-link"><strong><code>ignored</code></strong></dt> <dd><p>The local node is not alive.</p></dd> </dl> </div></div></article><article class="func"><h3 id="getopts-2" class="bold_code title-link func-head">  <pre data-language="erlang"><code>getopts(Node, Options) -&gt;
 {ok, OptionValues} | {error, Reason} | ignored</code></pre>
<div class="title-since"><span class="since">OTP 19.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Node = node()</code></div> <div class="REFTYPES rt-1"><code>Options = [<a href="inet.html#type-socket_getopt">inet:socket_getopt()</a>]</code></div> <div class="REFTYPES rt-1"><code>OptionValues = [<a href="inet.html#type-socket_setopt">inet:socket_setopt()</a>]</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="inet.html#type-posix">inet:posix()</a> | noconnection</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Get one or more options for the distribution socket connected to <code>Node</code>.</p> <p>If <code>Node</code> is a connected node the return value is the same as from <code><a href="inet.html#getopts-2">inet:getopts(Sock, Options)</a></code> where <code>Sock</code> is the distribution socket for <code>Node</code>.</p> <p>Returns <code>ignored</code> if the local node is not alive or <code>{error, noconnection}</code> if <code>Node</code> is not connected.</p> </div></div></article><article class="func"><h3 id="get_state-0" class="bold_code title-link func-head">  <pre data-language="erlang"><code>get_state() -&gt;
 #{started =&gt; no | static | dynamic,
 name =&gt; <code>atom()</code>,
 name_type =&gt; static | dynamic,
 name_domain =&gt; shortnames | longnames}</code></pre>
<div class="title-since"><span class="since">OTP 25.0</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Get the current state of the distribution for the local node.</p> <p>Returns a map with (at least) the following key-value pairs:</p> <dl> <dt class="title-link"><strong><code>started =&gt; Started</code></strong></dt> <dd> <p>Valid values for <code>Started</code>:</p> <dl> <dt class="title-link"><strong><code>no</code></strong></dt> <dd> <p>The distribution is not started. In this state none of the other keys below are present in the map.</p> </dd> <dt class="title-link"><strong><code>static</code></strong></dt> <dd> <p>The distribution was started with command line arguments <code>-name</code> or <code>-sname</code>.</p> </dd> <dt class="title-link"><strong><code>dynamic</code></strong></dt> <dd> <p>The distribution was started with <code><a href="#start-1">net_kernel:start/1</a></code> and can be stopped with <code><a href="#start-1">net_kernel:stop/0</a></code>.</p> </dd> </dl> </dd> <dt class="title-link"><strong><code>name =&gt; Name</code></strong></dt> <dd> <p>The name of the node. Same as returned by <code>erlang:node/0</code> except when <code>name_type</code> is <code>dynamic</code> in which case <code>Name</code> may be <code>undefined</code> (instead of <code>nonode@nohost</code>). </p> </dd> <dt class="title-link"><strong><code>name_type =&gt; NameType</code></strong></dt> <dd> <p>Valid values for <code>NameType</code>:</p> <dl> <dt class="title-link"><strong><code>static</code></strong></dt> <dd> <p>The node has a static node name set by the node itself.</p> </dd> <dt class="title-link"><strong><code>dynamic</code></strong></dt> <dd> <p>The distribution was started in <code> dynamic node name</code> mode, and will get its node name assigned from the first node it connects to. If key <code>name</code> has value <code>undefined</code> that has not happened yet.</p> </dd> </dl> </dd> <dt class="title-link"><strong><code>name_domain =&gt; NameDomain</code></strong></dt> <dd> <p>Valid values for <code>NameDomain</code>:</p> <dl> <dt class="title-link"><strong><code>shortnames</code></strong></dt> <dd> <p>The distribution was started to use node names with a short host portion (not fully qualified).</p> </dd> <dt class="title-link"><strong><code>longnames</code></strong></dt> <dd> <p>The distribution was started to use node names with a long fully qualified host portion.</p> </dd> </dl> </dd> </dl> </div></div></article><article class="func"><h3 id="monitor_nodes-1" class="bold_code title-link func-head">  <code>monitor_nodes(Flag) -&gt; ok | Error</code> </h3> <h3 id="monitor_nodes-2" class="bold_code title-link func-head">  <code>monitor_nodes(Flag, Options) -&gt; ok | Error</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Flag = boolean()</code></div> <div class="REFTYPES rt-1"><code>Options = OptionsList | OptionsMap</code></div> <div class="REFTYPES rt-1"><code>OptionsList = [ListOption]</code></div> <div class="REFTYPES rt-1"><pre><code>ListOption = 
 connection_id | {node_type, NodeType} | nodedown_reason</code></pre></div> <div class="REFTYPES rt-1"><pre><code>OptionsMap = 
 #{connection_id =&gt; boolean(),
 node_type =&gt; NodeType,
 nodedown_reason =&gt; boolean()}</code></pre></div> <div class="REFTYPES rt-1"><code>NodeType = visible | hidden | all</code></div> <div class="REFTYPES rt-1"><code>Error = error | {error, term()}</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>The calling process subscribes or unsubscribes to node status change messages. A <code>nodeup</code> message is delivered to all subscribing processes when a new node is connected, and a <code>nodedown</code> message is delivered when a node is disconnected.</p> <p>If <code>Flag</code> is <code>true</code>, a new subscription is started. If <code>Flag</code> is <code>false</code>, all previous subscriptions started with the same <code>Options</code> are stopped. Two option lists are considered the same if they contain the same set of options.</p> <p>Delivery guarantees of <code>nodeup</code>/<code>nodedown</code> messages:</p> <ul> <li><p> <code>nodeup</code> messages are delivered before delivery of any signals from the remote node through the newly established connection. </p></li> <li> <p><code>nodedown</code> messages are delivered after all the signals from the remote node over the connection have been delivered. </p> </li> <li><p> <code>nodeup</code> messages are delivered after the corresponding node appears in results from <code>erlang:nodes()</code>. </p></li> <li> <p><code>nodedown</code> messages are delivered after the corresponding node has disappeared in results from <code>erlang:nodes()</code>. </p> </li> <li><p> As of OTP 23.0, a <code>nodedown</code> message for a connection being taken down will be delivered before a <code>nodeup</code> message due to a new connection to the same node. Prior to OTP 23.0, this was not guaranteed to be the case. </p></li> </ul> <p>The format of the node status change messages depends on <code>Options</code>. If <code>Options</code> is the empty list or if <code>net_kernel:monitor_nodes/1</code> is called, the format is as follows:</p> <pre data-language="erlang">{nodeup, Node} | {nodedown, Node}
  Node = node()</pre> <p> When <code>Options</code> is the empty map or empty list, the caller will only subscribe for status change messages for visible nodes. That is, only nodes that appear in the result of <code>erlang:nodes/0</code>. </p> <p> If <code>Options</code> equals anything other than the empty list, the format of the status change messages is as follows: </p> <pre data-language="erlang">{nodeup, Node, Info} | {nodedown, Node, Info}
  Node = node()
  Info = #{Tag =&gt; Val} | [{Tag, Val}]</pre> <p> <code>Info</code> is either a map or a list of 2-tuples. Its content depends on <code>Options</code>. If <code>Options</code> is a map, <code>Info</code> will also be a map. If <code>Options</code> is a list, <code>Info</code> will also be a list. </p> <p> When <code>Options</code> is a map, currently the following associations are allowed: </p> <dl> <dt class="title-link"><strong><code>connection_id =&gt; boolean()</code></strong></dt> <dd> <p> If the value of the association equals <code>true</code>, a <code>connection_id =&gt; ConnectionId</code> association will be included in the <code>Info</code> map where <code>ConnectionId</code> is the connection identifier of the connection coming up or going down. For more info about this connection identifier see the documentation of <code>erlang:nodes/2</code>. </p> </dd> <dt class="title-link"><strong><code>node_type =&gt; NodeType</code></strong></dt> <dd> <p>Valid values for <code>NodeType</code>:</p> <dl> <dt class="title-link"><strong><code>visible</code></strong></dt> <dd><p>Subscribe to node status change messages for visible nodes only. The association <code>node_type =&gt; visible</code> will be included in the <code>Info</code> map.</p></dd> <dt class="title-link"><strong><code>hidden</code></strong></dt> <dd><p>Subscribe to node status change messages for hidden nodes only. The association <code>node_type =&gt; hidden</code> will be included in the <code>Info</code> map.</p></dd> <dt class="title-link"><strong><code>all</code></strong></dt> <dd><p>Subscribe to node status change messages for both visible and hidden nodes. The association <code>node_type =&gt; visible | hidden</code> will be included in the <code>Info</code> map.</p></dd> </dl> <p> If no <code>node_type =&gt; NodeType</code> association is included in the <code>Options</code> map, the caller will subscribe for status change messages for visible nodes only, but <i>no</i> <code>node_type =&gt; visible</code> association will be included in the <code>Info</code> map. </p> </dd> <dt class="title-link"><strong><code>nodedown_reason =&gt; boolean()</code></strong></dt> <dd> <p> If the value of the association equals <code>true</code>, a <code>nodedown_reason =&gt; Reason</code> association will be included in the <code>Info</code> map for <code>nodedown</code> messages. </p>  <p id="nodedown_reasons"> <code>Reason</code> can, depending on which distribution module or process that is used, be any term, but for the standard TCP distribution module it is one of the following: </p> <dl> <dt class="title-link"><strong><code>connection_setup_failed</code></strong></dt> <dd><p>The connection setup failed (after <code>nodeup</code> messages were sent).</p></dd> <dt class="title-link"><strong><code>no_network</code></strong></dt> <dd><p>No network is available.</p></dd> <dt class="title-link"><strong><code>net_kernel_terminated</code></strong></dt> <dd><p>The <code>net_kernel</code> process terminated.</p></dd> <dt class="title-link"><strong><code>shutdown</code></strong></dt> <dd><p>Unspecified connection shutdown.</p></dd> <dt class="title-link"><strong><code>connection_closed</code></strong></dt> <dd><p>The connection was closed.</p></dd> <dt class="title-link"><strong><code>disconnect</code></strong></dt> <dd><p>The connection was disconnected (forced from the current node).</p></dd> <dt class="title-link"><strong><code>net_tick_timeout</code></strong></dt> <dd><p>Net tick time-out.</p></dd> <dt class="title-link"><strong><code>send_net_tick_failed</code></strong></dt> <dd><p>Failed to send net tick over the connection.</p></dd> <dt class="title-link"><strong><code>get_status_failed</code></strong></dt> <dd><p>Status information retrieval from the <code>Port</code> holding the connection failed.</p></dd> </dl> </dd> </dl> <p> When <code>Options</code> is a list, currently <code>ListOption</code> can be one of the following: </p> <dl> <dt class="title-link"><strong><code>connection_id</code></strong></dt> <dd> <p> A <code>{connection_id, ConnectionId}</code> tuple will be included in <code>Info</code> where <code>ConnectionId</code> is the connection identifier of the connection coming up or going down. For more info about this connection identifier see the documentation of <code>erlang:nodes/2</code>. </p> </dd> <dt class="title-link"><strong><code>{node_type, NodeType}</code></strong></dt> <dd> <p>Valid values for <code>NodeType</code>:</p> <dl> <dt class="title-link"><strong><code>visible</code></strong></dt> <dd><p>Subscribe to node status change messages for visible nodes only. The tuple <code>{node_type, visible}</code> will be included in the <code>Info</code> list.</p></dd> <dt class="title-link"><strong><code>hidden</code></strong></dt> <dd><p>Subscribe to node status change messages for hidden nodes only. The tuple <code>{node_type, hidden}</code> will be included in the <code>Info</code> list.</p></dd> <dt class="title-link"><strong><code>all</code></strong></dt> <dd><p>Subscribe to node status change messages for both visible and hidden nodes. The tuple <code>{node_type, visible | hidden}</code> will be included in the <code>Info</code> list.</p></dd> </dl> <p> If no <code>{node_type, NodeType}</code> option has been given. The caller will subscribe for status change messages for visible nodes only, but <i>no</i> <code>{node_type, visible}</code> tuple will be included in the <code>Info</code> list. </p> </dd> <dt class="title-link"><strong><code>nodedown_reason</code></strong></dt> <dd> <p> The tuple <code>{nodedown_reason, Reason}</code> will be included in the <code>Info</code> list for <code>nodedown</code> messages. </p> <p> See the documentation of the <code><a href="#nodedown_reasons">nodedown_reason =&gt; boolean()</a></code> association above for information about possible <code>Reason</code> values. </p> </dd> </dl> <p>Example:</p> <pre data-language="erlang">(a@localhost)1&gt; net_kernel:monitor_nodes(true, #{connection_id=&gt;true, node_type=&gt;all, nodedown_reason=&gt;true}).
ok
(a@localhost)2&gt; flush().
Shell got {nodeup,b@localhost,
                  #{connection_id =&gt; 3067552,node_type =&gt; visible}}
Shell got {nodeup,c@localhost,
                  #{connection_id =&gt; 13892107,node_type =&gt; hidden}}
Shell got {nodedown,b@localhost,
                    #{connection_id =&gt; 3067552,node_type =&gt; visible,
                      nodedown_reason =&gt; connection_closed}}
Shell got {nodedown,c@localhost,
                    #{connection_id =&gt; 13892107,node_type =&gt; hidden,
                      nodedown_reason =&gt; net_tick_timeout}}
Shell got {nodeup,b@localhost,
                  #{connection_id =&gt; 3067553,node_type =&gt; visible}}
ok
(a@localhost)3&gt; </pre> </div></div></article><article class="func"><h3 id="set_net_ticktime-1" class="bold_code title-link func-head">  <code>set_net_ticktime(NetTicktime) -&gt; Res</code> </h3> <h3 id="set_net_ticktime-2" class="bold_code title-link func-head">  <code>set_net_ticktime(NetTicktime, TransitionPeriod) -&gt; Res</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>NetTicktime = integer() &gt;= 1</code></div> <div class="REFTYPES rt-1"><code>TransitionPeriod = integer() &gt;= 0</code></div> <div class="REFTYPES rt-1"><pre><code>Res = 
 unchanged | change_initiated |
 {ongoing_change_to, NewNetTicktime}</code></pre></div> <div class="REFTYPES rt-1"><code>NewNetTicktime = integer() &gt;= 1</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Sets <code>net_ticktime</code> (see <code><span>kernel(6)</span></code>) to <code>NetTicktime</code> seconds. <code>TransitionPeriod</code> defaults to <code>60</code>.</p> <p>Some definitions:</p> <dl> <dt class="title-link"><strong>Minimum transition traffic interval (<code>MTTI</code>)</strong></dt> <dd><p><code>minimum(NetTicktime, PreviousNetTicktime)*1000 div 4</code> milliseconds.</p></dd> <dt class="title-link"><strong>Transition period</strong></dt> <dd><p>The time of the least number of consecutive <code>MTTI</code>s to cover <code>TransitionPeriod</code> seconds following the call to <code>set_net_ticktime/2</code> (that is, ((<code>TransitionPeriod*1000 - 1) div MTTI + 1)*MTTI</code> milliseconds).</p></dd> </dl> <p>If <code>NetTicktime &lt; PreviousNetTicktime</code>, the <code>net_ticktime</code> change is done at the end of the transition period; otherwise at the beginning. During the transition period, <code>net_kernel</code> ensures that there is outgoing traffic on all connections at least every <code>MTTI</code> millisecond.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The <code>net_ticktime</code> changes must be initiated on all nodes in the network (with the same <code>NetTicktime</code>) before the end of any transition period on any node; otherwise connections can erroneously be disconnected.</p> </div> </div> <p>Returns one of the following:</p> <dl> <dt class="title-link"><strong><code>unchanged</code></strong></dt> <dd> <p><code>net_ticktime</code> already has the value of <code>NetTicktime</code> and is left unchanged.</p> </dd> <dt class="title-link"><strong><code>change_initiated</code></strong></dt> <dd> <p><code>net_kernel</code> initiated the change of <code>net_ticktime</code> to <code>NetTicktime</code> seconds.</p> </dd> <dt class="title-link"><strong><code>{ongoing_change_to, NewNetTicktime}</code></strong></dt> <dd> <p>The request is <strong>ignored</strong> because <code>net_kernel</code> is busy changing <code>net_ticktime</code> to <code>NewNetTicktime</code> seconds.</p> </dd> </dl> </div></div></article><article class="func"><h3 id="setopts-2" class="bold_code title-link func-head">  <code>setopts(Node, Options) -&gt; ok | {error, Reason} | ignored</code><div class="title-since"><span class="since">OTP 19.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Node = node() | new</code></div> <div class="REFTYPES rt-1"><code>Options = [<a href="inet.html#type-socket_setopt">inet:socket_setopt()</a>]</code></div> <div class="REFTYPES rt-1"><code>Reason = <a href="inet.html#type-posix">inet:posix()</a> | noconnection</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Set one or more options for distribution sockets. Argument <code>Node</code> can be either one node name or the atom <code>new</code> to affect the distribution sockets of all future connected nodes.</p> <p>The return value is the same as from <code><a href="inet.html#setopts-2">inet:setopts/2</a></code> or <code>{error, noconnection}</code> if <code>Node</code> is not a connected node or <code>new</code>.</p> <p>If <code>Node</code> is <code>new</code> the <code>Options</code> will then also be added to kernel configuration parameters <code>inet_dist_listen_options</code> and <code>inet_dist_connect_options</code>.</p> <p>Returns <code>ignored</code> if the local node is not alive.</p> </div></div></article><article class="func"><h3 id="start-2" class="bold_code title-link func-head">  <code>start(Name, Options) -&gt; {ok, <code>pid()</code>} | {error, Reason}</code><div class="title-since"><span class="since">OTP 24.3</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><pre><code>Options = 
 #{name_domain =&gt; NameDomain,
 net_ticktime =&gt; NetTickTime,
 net_tickintensity =&gt; NetTickIntensity,
 dist_listen =&gt; boolean(),
 hidden =&gt; boolean()}</code></pre></div> <div class="REFTYPES rt-1"><code>Name = atom()</code></div> <div class="REFTYPES rt-1"><code>NameDomain = shortnames | longnames</code></div> <div class="REFTYPES rt-1"><code>NetTickTime = integer() &gt;= 1</code></div> <div class="REFTYPES rt-1"><code>NetTickIntensity = 4..1000</code></div> <div class="REFTYPES rt-1"><code>Reason = {already_started, pid()} | term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Turns a non-distributed node into a distributed node by starting <code>net_kernel</code> and other necessary processes. </p> <p> If <code>Name</code> is set to <strong><code>undefined</code></strong> the distribution will be started to request a dynamic node name from the first node it connects to. See <code> Dynamic Node Name</code>. Setting <code>Name</code> to <code>undefined</code> implies options <code>dist_listen =&gt; false</code> and <code>hidden =&gt; true</code>. </p> <p>Currently supported options:</p> <dl> <dt class="title-link"><strong><code>name_domain =&gt; NameDomain</code></strong></dt> <dd><p> Determines the host name part of the node name. If <code>NameDomain</code> equals <code>longnames</code>, fully qualified domain names will be used which also is the default. If <code>NameDomain</code> equals <code>shortnames</code>, only the short name of the host will be used. </p></dd> <dt class="title-link"><strong><code>net_ticktime =&gt; NetTickTime</code></strong></dt> <dd><p> <i>Net tick time</i> to use in seconds. Defaults to the value of the <code><span>net_ticktime</span></code> <code>kernel(6)</code> parameter. For more information about <i>net tick time</i>, see the <code>kernel</code> parameter. However, note that if the value of the <code>kernel</code> parameter is invalid, it will silently be replaced by a valid value, but if an invalid <code>NetTickTime</code> value is passed as option value to this function, the call will fail. </p></dd> <dt class="title-link"><strong><code>net_tickintensity =&gt; NetTickIntensity</code></strong></dt> <dd><p> <i>Net tick intensity</i> to use. Defaults to the value of the <code><span>net_tickintensity</span></code> <code>kernel(6)</code> parameter. For more information about <i>net tick intensity</i>, see the <code>kernel</code> parameter. However, note that if the value of the <code>kernel</code> parameter is invalid, it will silently be replaced by a valid value, but if an invalid <code>NetTickIntensity</code> value is passed as option value to this function, the call will fail. </p></dd> <dt class="title-link"><strong><code>dist_listen =&gt; boolean()</code></strong></dt> <dd> <p> Enable or disable listening for incoming connections. Defaults to the value of the <code>-dist_listen</code> <code>erl</code> command line argument. Note that <code>dist_listen =&gt; false</code> implies <code>hidden =&gt; true</code>. </p> <p> If <code>undefined</code> has been passed as <code>Name</code>, the <code>dist_listen</code> option will be overridden with <code>dist_listen =&gt; false</code>. </p> </dd> <dt class="title-link"><strong><code>hidden =&gt; boolean()</code></strong></dt> <dd> <p> Enable or disable hidden node. Defaults to <code>true</code> if the <code>-hidden</code> <code>erl</code> command line argument has been passed; otherwise <code>false</code>. </p> <p> If <code>undefined</code> has been passed as <code>Name</code>, or the option <code>dist_listen</code> equals <code>false</code>, the <code>hidden</code> option will be overridden with <code>hidden =&gt; true</code>. </p> </dd> </dl> </div></div></article><article class="func"><h3 id="start-1" class="bold_code title-link func-head">  <code>start(Options) -&gt; {ok, <code>pid()</code>} | {error, Reason}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Options = [Name | NameDomain | TickTime, ...]</code></div> <div class="REFTYPES rt-1"><code>Name = atom()</code></div> <div class="REFTYPES rt-1"><code>NameDomain = shortnames | longnames</code></div> <div class="REFTYPES rt-1"><code>TickTime = integer() &gt;= 1</code></div> <div class="REFTYPES rt-1"><code>Reason = {already_started, pid()} | term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> <code>start/1</code> is deprecated. Use <code><a href="#start-2">start/2</a></code> instead. </p>
</div> </div> <p> Turns a non-distributed node into a distributed node by starting <code>net_kernel</code> and other necessary processes. </p> <p> <code>Options</code> list can only be exactly one of the following lists (order is imporant): </p> <dl> <dt class="title-link"><strong><code>[Name]</code></strong></dt> <dd> <p> The same as <code>net_kernel:start([Name, longnames, 15000])</code>. </p> </dd> <dt class="title-link"><strong><code>[Name, NameDomain]</code></strong></dt> <dd> <p> The same as <code>net_kernel:start([Name, NameDomain, 15000])</code>. </p> </dd> <dt class="title-link"><strong><code>[Name, NameDomain, TickTime]</code></strong></dt> <dd> <p> The same as <code><a href="#start-2"> net_kernel:start(Name, #{name_domain =&gt; NameDomain, net_ticktime =&gt; ((TickTime*4-1) div 1000) + 1, net_tickintensity =&gt; 4})</a></code>. Note that <code>TickTime</code> is <i>not</i> the same as net tick time expressed in milliseconds. <code>TickTime</code> is the time between ticks when net tick intensity equals <code>4</code>. </p> </dd> </dl> </div></div></article><article class="func"><h3 id="stop-0" class="bold_code title-link func-head">  <code>stop() -&gt; ok | {error, Reason}</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Reason = not_allowed | not_found</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Turns a distributed node into a non-distributed node. For other nodes in the network, this is the same as the node going down. Only possible when the net kernel was started using <code><a href="#start-2">start/2</a></code>, otherwise <code>{error, not_allowed}</code> is returned. Returns <code>{error, not_found}</code> if the local node is not alive.</p> </div></div></article> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
