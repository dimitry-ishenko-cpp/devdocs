  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">global</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">A global name registration facility.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module consists of the following services:</p> <ul> <li>Registration of global names</li> <li>Global locks</li> <li>Maintenance of the fully connected network</li> </ul>  <p id="prevent_overlapping_partitions"> As of OTP 25, <code>global</code> will by default prevent overlapping partitions due to network issues by actively disconnecting from nodes that reports that they have lost connections to other nodes. This will cause fully connected partitions to form instead of leaving the network in a state with overlapping partitions. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> Prevention of overlapping partitions can be disabled using the <code><span> prevent_overlapping_partitions</span></code> <code>kernel(6)</code> parameter, making <code>global</code> behave like it used to do. This is, however, problematic for all applications expecting a fully connected network to be provided, such as for example <code>mnesia</code>, but also for <code>global</code> itself. A network of overlapping partitions might cause the internal state of <code>global</code> to become inconsistent. Such an inconsistency can remain even after such partitions have been brought together to form a fully connected network again. The effect on other applications that expects that a fully connected network is maintained may vary, but they might misbehave in very subtle hard to detect ways during such a partitioning. Since you might get hard to detect issues without this fix, you are <i>strongly</i> advised <i>not</i> to disable this fix. Also note that this fix <i>has</i> to be enabled on <i>all</i> nodes in the network in order to work properly. </p> </div> </div> <div class="note"> <div class="label">Note</div> <div class="content">

<p> None of the above services will be reliably delivered unless both of the kernel parameters <code><span>connect_all</span></code> and <code><span> prevent_overlapping_partitions</span></code> are enabled. Calls to the <code>global</code> API will, however, <i>not</i> fail even though one or both of them are disabled. You will just get unreliable results. </p> </div> </div> <p>These services are controlled through the process <code>global_name_server</code> that exists on every node. The global name server starts automatically when a node is started. With the term <strong>global</strong> is meant over a system consisting of many Erlang nodes.</p> <p>The ability to globally register names is a central concept in the programming of distributed Erlang systems. In this module, the equivalent of the <code>register/2</code> and <code>whereis/1</code> BIFs (for local name registration) are provided, but for a network of Erlang nodes. A registered name is an alias for a process identifier (pid). The global name server monitors globally registered pids. If a process terminates, the name is also globally unregistered.</p> <p>The registered names are stored in replica global name tables on every node. There is no central storage point. Thus, the translation of a name to a pid is fast, as it is always done locally. For any action resulting in a change to the global name table, all tables on other nodes are automatically updated.</p> <p>Global locks have lock identities and are set on a specific resource. For example, the specified resource can be a pid. When a global lock is set, access to the locked resource is denied for all resources other than the lock requester.</p> <p>Both the registration and lock services are atomic. All nodes involved in these actions have the same view of the information.</p> <p>The global name server also performs the critical task of continuously monitoring changes in node configuration. If a node that runs a globally registered process goes down, the name is globally unregistered. To this end, the global name server subscribes to <code>nodeup</code> and <code>nodedown</code> messages sent from module <code>net_kernel</code>. Relevant Kernel application variables in this context are <code>net_setuptime</code>, <code>net_ticktime</code>, and <code>dist_auto_connect</code>. See also <code><span>kernel(6)</span></code>.</p> <p>The name server also maintains a fully connected network. For example, if node <code>N1</code> connects to node <code>N2</code> (which is already connected to <code>N3</code>), the global name servers on the nodes <code>N1</code> and <code>N3</code> ensure that also <code>N1</code> and <code>N3</code> are connected. In this case, the name registration service cannot be used, but the lock mechanism still works.</p> <p>If the global name server fails to connect nodes (<code>N1</code> and <code>N3</code> in the example), a warning event is sent to the error logger. The presence of such an event does not exclude the nodes to connect later (you can, for example, try command <code>rpc:call(N1, net_adm, ping, [N2])</code> in the Erlang shell), but it indicates a network problem.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If the fully connected network is not set up properly, try first to increase the value of <code>net_setuptime</code>.</p> </div> </div> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-id" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-id">id()</a> = {ResourceId :: term(), LockRequesterId :: term()}</code><br> </div> </h3> </article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="del_lock-1" class="bold_code title-link func-head">  <code>del_lock(Id) -&gt; true</code> </h3> <h3 id="del_lock-2" class="bold_code title-link func-head">  <code>del_lock(Id, Nodes) -&gt; true</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Id = <a href="#type-id">id()</a></code></div> <div class="REFTYPES rt-1"><code>Nodes = [node()]</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Deletes the lock <code>Id</code> synchronously.</p> </div></div></article><article class="func"><h3 id="disconnect-0" class="bold_code title-link func-head">  <code>disconnect() -&gt; [<code>node()</code>]</code><div class="title-since"><span class="since">OTP 25.1</span></div> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p> Disconnect from all other nodes known to <code>global</code>. A list of node names (in an unspecified order) is returned which corresponds to the nodes that were disconnected. All disconnect operations performed have completed when <code>global:disconnect/0</code> returns. </p> <p> The disconnects will be made in such a way that only the current node will be removed from the cluster of <code>global</code> nodes. If <code><a href="#prevent_overlapping_partitions"> prevent_overlapping_partitions</a></code> is enabled and you disconnect, from other nodes in the cluster of <code>global</code> nodes, by other means, <code>global</code> on the other nodes may partition the remaining nodes in order to ensure that no overlapping partitions appear. Even if <code>prevent_overlapping_partitions</code> is disabled, you should preferably use <code>global:disconnect/0</code> in order to remove current node from a cluster of <code>global</code> nodes, since you otherwise likely <strong>will</strong> create overlapping partitions which might <code><a href="#prevent_overlapping_partitions">cause problems</a></code>. </p> <p> Note that if the node is going to be halted, there is <strong>no</strong> need to remove it from a cluster of <code>global</code> nodes explicitly by calling <code>global:disconnect/0</code> before halting it. The removal from the cluster is taken care of automatically when the node halts regardless of whether <code>prevent_overlapping_partitions</code> is enabled or not. </p> <p> If current node has been configured to be part of a <code><a href="global_group.html"><i>global group</i></a></code>, only connected and/or synchronized nodes in that group are known to <code>global</code>, so <code>global:disconnect/0</code> will <strong>only</strong> disconnect from those nodes. If current node is <strong>not</strong> part of a <i>global group</i>, all <code>connected visible nodes</code> will be known to <code>global</code>, so <code>global:disconnect/0</code> will disconnect from all those nodes. </p> <p> Note that information about connected nodes does not instantaneously reach <code>global</code>, so the caller might see a node part of the result returned by <code>nodes()</code> while it still is not known to <code>global</code>. The disconnect operation will, however, still not cause any overlapping partitions when <code>prevent_overlapping_partitions</code> is enabled. If <code>prevent_overlapping_partitions</code> is disabled, overlapping partitions might form in this case. </p> <p> Note that when <code>prevent_overlapping_partitions</code> is enabled, you may see warning reports on other nodes when they detect that current node has disconnected. These are in this case completely harmless and can be ignored. </p> </div></div></article><article class="func"><h3 id="notify_all_name-3" class="bold_code title-link func-head">  <code>notify_all_name(Name, Pid1, Pid2) -&gt; none</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = term()</code></div> <div class="REFTYPES rt-1"><code>Pid1 = Pid2 = pid()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Can be used as a name resolving function for <code><a href="#register_name-3">register_name/3</a></code> and <code><a href="#re_register_name-3">re_register_name/3</a></code>.</p> <p>The function unregisters both pids and sends the message <code>{global_name_conflict, Name, OtherPid}</code> to both processes.</p> </div></div></article><article class="func"><h3 id="random_exit_name-3" class="bold_code title-link func-head">  <code>random_exit_name(Name, Pid1, Pid2) -&gt; <code>pid()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = term()</code></div> <div class="REFTYPES rt-1"><code>Pid1 = Pid2 = pid()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Can be used as a name resolving function for <code><a href="#register_name-3">register_name/3</a></code> and <code><a href="#re_register_name-3">re_register_name/3</a></code>.</p> <p>The function randomly selects one of the pids for registration and kills the other one.</p> </div></div></article><article class="func"><h3 id="random_notify_name-3" class="bold_code title-link func-head">  <code>random_notify_name(Name, Pid1, Pid2) -&gt; <code>pid()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = term()</code></div> <div class="REFTYPES rt-1"><code>Pid1 = Pid2 = pid()</code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Can be used as a name resolving function for <code><a href="#register_name-3">register_name/3</a></code> and <code><a href="#re_register_name-3">re_register_name/3</a></code>.</p> <p>The function randomly selects one of the pids for registration, and sends the message <code>{global_name_conflict, Name}</code> to the other pid.</p> </div></div></article><article class="func"><h3 id="re_register_name-2" class="bold_code title-link func-head">  <code>re_register_name(Name, Pid) -&gt; yes</code> </h3> <h3 id="re_register_name-3" class="bold_code title-link func-head">  <code>re_register_name(Name, Pid, Resolve) -&gt; yes</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = term()</code></div> <div class="REFTYPES rt-1"><code>Pid = pid()</code></div> <div class="REFTYPES rt-1"><code>Resolve = method()</code></div> <div class="REFTYPES rt-2"> <pre><code>method() = 
 fun((Name :: term(), Pid :: pid(), Pid2 :: pid()) -&gt;
 pid() | none)</code></pre>
<br> </div> <div class="REFBODY rb-1">{<code>Module</code>, <code>Function</code>} is also allowed. </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Atomically changes the registered name <code>Name</code> on all nodes to refer to <code>Pid</code>.</p> <p>Function <code>Resolve</code> has the same behavior as in <code><a href="#register_name-2">register_name/2,3</a></code>. </p> </div></div></article><article class="func"><h3 id="register_name-2" class="bold_code title-link func-head">  <code>register_name(Name, Pid) -&gt; yes | no</code> </h3> <h3 id="register_name-3" class="bold_code title-link func-head">  <code>register_name(Name, Pid, Resolve) -&gt; yes | no</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = term()</code></div> <div class="REFTYPES rt-1"><code>Pid = pid()</code></div> <div class="REFTYPES rt-1"><code>Resolve = method()</code></div> <div class="REFTYPES rt-2"> <pre><code>method() = 
 fun((Name :: term(), Pid :: pid(), Pid2 :: pid()) -&gt;
 pid() | none)</code></pre>
<br> </div> <div class="REFBODY rb-1">{<code>Module</code>, <code>Function</code>} is also allowed for backward compatibility, but its use is deprecated. </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Globally associates name <code>Name</code> with a pid, that is, globally notifies all nodes of a new global name in a network of Erlang nodes.</p> <p>When new nodes are added to the network, they are informed of the globally registered names that already exist. The network is also informed of any global names in newly connected nodes. If any name clashes are discovered, function <code>Resolve</code> is called. Its purpose is to decide which pid is correct. If the function crashes, or returns anything other than one of the pids, the name is unregistered. This function is called once for each name clash.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>If you plan to change code without restarting your system, you must use an external fun (<code>fun Module:Function/Arity</code>) as function <code>Resolve</code>. If you use a local fun, you can never replace the code for the module that the fun belongs to.</p> </div> </div> <p>Three predefined resolve functions exist: <code>random_exit_name/3</code>, <code>random_notify_name/3</code>, and <code>notify_all_name/3</code>. If no <code>Resolve</code> function is defined, <code>random_exit_name</code> is used. This means that one of the two registered processes is selected as correct while the other is killed.</p> <p>This function is completely synchronous, that is, when this function returns, the name is either registered on all nodes or none.</p> <p>The function returns <code>yes</code> if successful, <code>no</code> if it fails. For example, <code>no</code> is returned if an attempt is made to register an already registered process or to register a process with a name that is already in use.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Releases up to and including Erlang/OTP R10 did not check if the process was already registered. The global name table could therefore become inconsistent. The old (buggy) behavior can be chosen by giving the Kernel application variable <code>global_multi_name_action</code> the value <code>allow</code>.</p> </div> </div> <p>If a process with a registered name dies, or the node goes down, the name is unregistered on all nodes.</p> </div></div></article><article class="func"><h3 id="registered_names-0" class="bold_code title-link func-head">  <code>registered_names() -&gt; [Name]</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns a list of all globally registered names.</p> </div></div></article><article class="func"><h3 id="send-2" class="bold_code title-link func-head">  <code>send(Name, Msg) -&gt; Pid</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = Msg = term()</code></div>  <div class="REFTYPES rt-1"><code>Pid = pid()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Sends message <code>Msg</code> to the pid globally registered as <code>Name</code>.</p> <p>If <code>Name</code> is not a globally registered name, the calling function exits with reason <code>{badarg, {Name, Msg}}</code>.</p> </div></div></article><article class="func"><h3 id="set_lock-1" class="bold_code title-link func-head">  <code>set_lock(Id) -&gt; <code>boolean()</code></code> </h3> <h3 id="set_lock-2" class="bold_code title-link func-head">  <code>set_lock(Id, Nodes) -&gt; <code>boolean()</code></code> </h3> <h3 id="set_lock-3" class="bold_code title-link func-head">  <code>set_lock(Id, Nodes, Retries) -&gt; <code>boolean()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Id = <a href="#type-id">id()</a></code></div> <div class="REFTYPES rt-1"><code>Nodes = [node()]</code></div> <div class="REFTYPES rt-1"><code>Retries = retries()</code></div> <div class="REFTYPES rt-2"> <code>id() = {ResourceId :: term(), LockRequesterId :: term()}</code><br> </div> <div class="REFTYPES rt-2"> <code>retries() = integer() &gt;= 0 | infinity</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Sets a lock on the specified nodes (or on all nodes if none are specified) on <code>ResourceId</code> for <code>LockRequesterId</code>. If a lock already exists on <code>ResourceId</code> for another requester than <code>LockRequesterId</code>, and <code>Retries</code> is not equal to <code>0</code>, the process sleeps for a while and tries to execute the action later. When <code>Retries</code> attempts have been made, <code>false</code> is returned, otherwise <code>true</code>. If <code>Retries</code> is <code>infinity</code>, <code>true</code> is eventually returned (unless the lock is never released).</p> <p>If no value for <code>Retries</code> is specified, <code>infinity</code> is used.</p> <p>This function is completely synchronous.</p> <p>If a process that holds a lock dies, or the node goes down, the locks held by the process are deleted.</p> <p>The global name server keeps track of all processes sharing the same lock, that is, if two processes set the same lock, both processes must delete the lock.</p> <p>This function does not address the problem of a deadlock. A deadlock can never occur as long as processes only lock one resource at a time. A deadlock can occur if some processes try to lock two or more resources. It is up to the application to detect and rectify a deadlock.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Avoid the following values of <code>ResourceId</code>, otherwise Erlang/OTP does not work properly:</p> <ul> <li><code>dist_ac</code></li> <li><code>global</code></li> <li><code>mnesia_adjust_log_writes</code></li> <li><code>mnesia_table_lock</code></li> </ul> </div> </div> </div></div></article><article class="func"><h3 id="sync-0" class="bold_code title-link func-head">  <code>sync() -&gt; ok | {error, Reason :: <code>term()</code>}</code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Synchronizes the global name server with all nodes known to this node. These are the nodes that are returned from <code>erlang:nodes()</code>. When this function returns, the global name server receives global information from all nodes. This function can be called when new nodes are added to the network.</p> <p>The only possible error reason <code>Reason</code> is <code>{"global_groups definition error", Error}</code>.</p> </div></div></article><article class="func"><h3 id="trans-2" class="bold_code title-link func-head">  <code>trans(Id, Fun) -&gt; Res | aborted</code> </h3> <h3 id="trans-3" class="bold_code title-link func-head">  <code>trans(Id, Fun, Nodes) -&gt; Res | aborted</code> </h3> <h3 id="trans-4" class="bold_code title-link func-head">  <code>trans(Id, Fun, Nodes, Retries) -&gt; Res | aborted</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Id = <a href="#type-id">id()</a></code></div> <div class="REFTYPES rt-1"><code>Fun = trans_fun()</code></div> <div class="REFTYPES rt-1"><code>Nodes = [node()]</code></div> <div class="REFTYPES rt-1"><code>Retries = retries()</code></div> <div class="REFTYPES rt-1"><code>Res = term()</code></div> <div class="REFTYPES rt-2"> <code>retries() = integer() &gt;= 0 | infinity</code><br> </div> <div class="REFTYPES rt-2"> <code>trans_fun() = function() | {module(), atom()}</code><br> </div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Sets a lock on <code>Id</code> (using <code><a href="#set_lock-3">set_lock/3</a></code>). If this succeeds, <code>Fun()</code> is evaluated and the result <code>Res</code> is returned. Returns <code>aborted</code> if the lock attempt fails. If <code>Retries</code> is set to <code>infinity</code>, the transaction does not abort.</p> <p><code>infinity</code> is the default setting and is used if no value is specified for <code>Retries</code>.</p> </div></div></article><article class="func"><h3 id="unregister_name-1" class="bold_code title-link func-head">  <code>unregister_name(Name) -&gt; <code>term()</code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Removes the globally registered name <code>Name</code> from the network of Erlang nodes.</p> </div></div></article><article class="func"><h3 id="whereis_name-1" class="bold_code title-link func-head">  <code>whereis_name(Name) -&gt; <code>pid()</code> | undefined</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Name = term()</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the pid with the globally registered name <code>Name</code>. Returns <code>undefined</code> if the name is not globally registered.</p> </div></div></article> </div> <section class="innertube"><h2 id="see-also" class="title-link"> <div class="title-name">See Also</div>  </h2> <div class="REFBODY rb-3"> <p><code><a href="global_group.html">global_group(3)</a></code>, <code><a href="net_kernel.html">net_kernel(3)</a></code></p> </div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
