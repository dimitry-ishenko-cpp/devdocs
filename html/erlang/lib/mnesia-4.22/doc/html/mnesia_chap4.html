<div class="innertube"> <h1 id="Transactions and Other Access Contexts">5 Transactions and Other Access Contexts</h1> <p>This section describes the <code>Mnesia</code> transaction system and the transaction properties that make <code>Mnesia</code> a fault-tolerant, distributed Database Management System (DBMS).</p> <p>This section also describes the locking functions, including table locks and sticky locks, as well as alternative functions that bypass the transaction system in favor of improved speed and reduced overhead. These functions are called "dirty operations". The use of nested transactions is also described. The following topics are included:</p> <ul> <li>Transaction properties, which include atomicity, consistency, isolation, and durability</li> <li>Locking</li> <li>Dirty operations</li> <li>Record names versus table names</li> <li>Activity concept and various access contexts</li> <li>Nested transactions</li> <li>Pattern matching</li> <li>Iteration</li> </ul> <h2 id="transaction-properties" class="title-link"> <div class="title-name">5.1 Transaction Properties</div>  </h2> <p>Transactions are important when designing fault-tolerant, distributed systems. A <code>Mnesia</code> transaction is a mechanism by which a series of database operations can be executed as one functional block. The functional block that is run as a transaction is called a Functional Object (Fun), and this code can read, write, and delete <code>Mnesia</code> records. The Fun is evaluated as a transaction that either commits or terminates. If a transaction succeeds in executing the Fun, it replicates the action on all nodes involved, or terminates if an error occurs.</p> <p>The following example shows a transaction that raises the salary of certain employee numbers:</p> <pre data-language="erlang">raise(Eno, Raise) -&gt;
    F = fun() -&gt;
                [E] = mnesia:read(employee, Eno, write),
                Salary = E#employee.salary + Raise,
                New = E#employee{salary = Salary},
                mnesia:write(New)
        end,
    mnesia:transaction(F).</pre> <p>The function <code>raise/2</code> contains a Fun made up of four code lines. This Fun is called by the statement <code>mnesia:transaction(F)</code> and returns a value.</p> <p>The <code>Mnesia</code> transaction system facilitates the construction of reliable, distributed systems by providing the following important properties:</p> <ul> <li>The transaction handler ensures that a Fun, which is placed inside a transaction, does not interfere with operations embedded in other transactions when it executes a series of operations on tables. </li> <li>The transaction handler ensures that either all operations in the transaction are performed successfully on all nodes atomically, or the transaction fails without permanent effect on any node. </li> <li>The <code>Mnesia</code> transactions have four important properties, called <strong>A</strong>tomicity, <strong>C</strong>onsistency, <strong>I</strong>solation, and <strong>D</strong>urability (ACID). These properties are described in the following sections.</li> </ul> <h3 id="atomicity" class="title-link"> <div class="title-name">Atomicity</div>  </h3> <p>Atomicity means that database changes that are executed by a transaction take effect on all nodes involved, or on none of the nodes. That is, the transaction either succeeds entirely, or it fails entirely.</p> <p>Atomicity is important when it is needed to write atomically more than one record in the same transaction. The function <code>raise/2</code>, shown in the previous example, writes one record only. The function <code>insert_emp/3</code>, shown in the program listing in <code><a href="mnesia_chap2.html#getting_started">Getting Started</a></code>, writes the record <code>employee</code> as well as employee relations, such as <code>at_dep</code> and <code>in_proj</code>, into the database. If this latter code is run inside a transaction, the transaction handler ensures that the transaction either succeeds completely, or not at all.</p> <p><code>Mnesia</code> is a distributed DBMS where data can be replicated on several nodes. In many applications, it is important that a series of write operations are performed atomically inside a transaction. The atomicity property ensures that a transaction takes effect on all nodes, or none.</p> <h3 id="consistency" class="title-link"> <div class="title-name">Consistency</div>  </h3> <p>The consistency property ensures that a transaction always leaves the DBMS in a consistent state. For example, <code>Mnesia</code> ensures that no inconsistencies occur if Erlang, <code>Mnesia</code>, or the computer crashes while a write operation is in progress.</p> <h3 id="isolation" class="title-link"> <div class="title-name">Isolation</div>  </h3> <p>The isolation property ensures that transactions that execute on different nodes in a network, and access and manipulate the same data records, do not interfere with each other. The isolation property makes it possible to execute the function <code>raise/2</code> concurrently. A classical problem in concurrency control theory is the "lost update problem".</p> <p>The isolation property is in particular useful if the following circumstances occur where an employee (with employee number 123) and two processes (P1 and P2) are concurrently trying to raise the salary for the employee:</p> <ul> <li> <strong>Step 1:</strong> The initial value of the employees salary is, for example, 5. Process P1 starts to execute, reads the employee record, and adds 2 to the salary.</li> <li> <strong>Step 2:</strong> Process P1 is for some reason pre-empted and process P2 has the opportunity to run.</li> <li> <strong>Step 3:</strong> Process P2 reads the record, adds 3 to the salary, and finally writes a new employee record with the salary set to 8.</li> <li> <strong>Step 4:</strong> Process P1 starts to run again and writes its employee record with salary set to 7, thus effectively overwriting and undoing the work performed by process P2. The update performed by P2 is lost.</li> </ul> <p>A transaction system makes it possible to execute two or more processes concurrently that manipulate the same record. The programmer does not need to check that the updates are synchronous; this is overseen by the transaction handler. All programs accessing the database through the transaction system can be written as if they had sole access to the data.</p> <h3 id="durability" class="title-link"> <div class="title-name">Durability</div>  </h3> <p>The durability property ensures that changes made to the DBMS by a transaction are permanent. Once a transaction is committed, all changes made to the database are durable, that is, they are written safely to disc and do not become corrupted and do not disappear.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The described durability feature does not entirely apply to situations where <code>Mnesia</code> is configured as a "pure" primary memory database.</p> </div> </div> <h2 id="locking" class="title-link"> <div class="title-name">5.2 Locking</div>  </h2> <p>Different transaction managers employ different strategies to satisfy the isolation property. <code>Mnesia</code> uses the standard technique of two phase locking. That is, locks are set on records before they are read or written. <code>Mnesia</code> uses the following lock types:</p> <ul> <li> <strong>Read locks</strong>. A read lock is set on one replica of a record before it can be read. </li> <li> <strong>Write locks</strong>. Whenever a transaction writes to a record, write locks are first set on all replicas of that particular record. </li> <li> <strong>Read table locks</strong>. If a transaction traverses an entire table in search for a record that satisfies some particular property, it is most inefficient to set read locks on the records one by one. It is also memory consuming, as the read locks themselves can take up considerable space if the table is large. Therefore, <code>Mnesia</code> can set a read lock on an entire table. </li> <li> <strong>Write table locks</strong>. If a transaction writes many records to one table, a write lock can be set on the entire table. </li> <li> <strong>Sticky locks</strong>. These are write locks that stay in place at a node after the transaction that initiated the lock has terminated.</li> </ul> <p><code>Mnesia</code> employs a strategy whereby functions, such as <code><a href="mnesia.html#read-1">mnesia:read/1</a></code> acquire the necessary locks dynamically as the transactions execute. <code>Mnesia</code> automatically sets and releases the locks and the programmer does not need to code these operations.</p> <p>Deadlocks can occur when concurrent processes set and release locks on the same records. <code>Mnesia</code> employs a "wait-die" strategy to resolve these situations. If <code>Mnesia</code> suspects that a deadlock can occur when a transaction tries to set a lock, the transaction is forced to release all its locks and sleep for a while. The Fun in the transaction is evaluated once more.</p> <p>It is therefore important that the code inside the Fun given to <code><a href="mnesia.html#transaction-1">mnesia:transaction/1</a></code> is pure. Some strange results can occur if, for example, messages are sent by the transaction Fun. The following example illustrates this situation:</p> <pre data-language="erlang">bad_raise(Eno, Raise) -&gt;
    F = fun() -&gt;
                [E] = mnesia:read({employee, Eno}),
                Salary = E#employee.salary + Raise,
                New = E#employee{salary = Salary},
                io:format("Trying to write ... ~n", []),
                mnesia:write(New)
        end,
    mnesia:transaction(F).</pre> <p>This transaction can write the text <code>"Trying to write ... "</code> 1000 times to the terminal. However, <code>Mnesia</code> guarantees that each transaction will eventually run. As a result, <code>Mnesia</code> is not only deadlock free, but also livelock free.</p> <p>The <code>Mnesia</code> programmer cannot prioritize one particular transaction to execute before other transactions that are waiting to execute. As a result, the <code>Mnesia</code> DBMS transaction system is not suitable for hard real-time applications. However, <code>Mnesia</code> contains other features that have real-time properties.</p> <p><code>Mnesia</code> dynamically sets and releases locks as transactions execute. It is therefore dangerous to execute code with transaction side-effects. In particular, a <code>receive</code> statement inside a transaction can lead to a situation where the transaction hangs and never returns, which in turn can cause locks not to release. This situation can bring the whole system to a standstill, as other transactions that execute in other processes, or on other nodes, are forced to wait for the defective transaction.</p> <p>If a transaction terminates abnormally, <code>Mnesia</code> automatically releases the locks held by the transaction.</p> <p>Up to now, examples of a number of functions that can be used inside a transaction have been shown. The following list shows the <strong>simplest</strong> <code>Mnesia</code> functions that work with transactions. Notice that these functions must be embedded in a transaction. If no enclosing transaction (or other enclosing <code>Mnesia</code> activity) exists, they all fail.</p> <ul> <li> <code><a href="mnesia.html#transaction-1">mnesia:transaction(Fun) -&gt; {aborted, Reason} |{atomic, Value}</a></code> executes one transaction with the functional object <code>Fun</code> as the single parameter. </li> <li> <code><a href="mnesia.html#read-1">mnesia:read({Tab, Key}) -&gt; transaction abort | RecordList</a></code> reads all records with <code>Key</code> as key from table <code>Tab</code>. This function has the same semantics regardless of the location of <code>Table</code>. If the table is of type <code>bag</code>, <code>read({Tab, Key})</code> can return an arbitrarily long list. If the table is of type <code>set</code>, the list is either of length one or <code>[]</code>. </li> <li> <code><a href="mnesia.html#wread-1">mnesia:wread({Tab, Key}) -&gt; transaction abort | RecordList</a></code> behaves the same way as the previously listed function <code>read/1</code>, except that it acquires a write lock instead of a read lock. To execute a transaction that reads a record, modifies the record, and then writes the record, it is slightly more efficient to set the write lock immediately. When a <code><a href="mnesia.html#read-1">mnesia:read/1</a></code> is issued, followed by a <code><a href="mnesia.html#write-1">mnesia:write/1</a></code> the first read lock must be upgraded to a write lock when the write operation is executed. </li> <li> <code><a href="mnesia.html#write-1">mnesia:write(Record) -&gt; transaction abort | ok</a></code> writes a record into the database. Argument <code>Record</code> is an instance of a record. The function returns <code>ok</code>, or terminates the transaction if an error occurs. </li> <li> <code><a href="mnesia.html#delete-1">mnesia:delete({Tab, Key}) -&gt; transaction abort | ok</a></code> deletes all records with the given key. </li> <li> <code><a href="mnesia.html#delete_object-1">mnesia:delete_object(Record) -&gt; transaction abort | ok</a></code> deletes records with the OID <code>Record</code>. Use this function to delete only some records in a table of type <code>bag</code>.</li> </ul> <h3 id="sticky-locks" class="title-link"> <div class="title-name">Sticky Locks</div>  </h3> <p>As previously stated, the locking strategy used by <code>Mnesia</code> is to lock one record when reading a record, and lock all replicas of a record when writing a record. However, some applications use <code>Mnesia</code> mainly for its fault-tolerant qualities. These applications can be configured with one node doing all the heavy work, and a standby node that is ready to take over if the main node fails. Such applications can benefit from using sticky locks instead of the normal locking scheme.</p> <p>A sticky lock is a lock that stays in place at a node, after the transaction that first acquired the lock has terminated. To illustrate this, assume that the following transaction is executed:</p> <pre data-language="erlang">F = fun() -&gt;
      mnesia:write(#foo{a = kalle})
    end,
mnesia:transaction(F).</pre> <p>The <code>foo</code> table is replicated on the two nodes <code>N1</code> and <code>N2</code>.</p> <p>Normal locking requires the following:</p> <ul> <li>One network RPC (two messages) to acquire the write lock </li> <li>Three network messages to execute the two-phase commit protocol </li> </ul> <p>If sticky locks are used, the code must first be changed as follows:</p> <pre data-language="erlang">F = fun() -&gt;
      mnesia:s_write(#foo{a = kalle})
    end,
mnesia:transaction(F).</pre> <p>This code uses the function <code><a href="mnesia.html#s_write-1">s_write/1</a></code> instead of the function <code><a href="mnesia.html#write-1">write/1</a></code> The function <code>s_write/1</code> sets a sticky lock instead of a normal lock. If the table is not replicated, sticky locks have no special effect. If the table is replicated, and a sticky lock is set on node <code>N1</code>, this lock then sticks to node <code>N1</code>. The next time you try to set a sticky lock on the same record at node <code>N1</code>, <code>Mnesia</code> detects that the lock is already set and do no network operation to acquire the lock.</p> <p>It is more efficient to set a local lock than it is to set a networked lock. Sticky locks can therefore benefit an application that uses a replicated table and perform most of the work on only one of the nodes.</p> <p>If a record is stuck at node <code>N1</code> and you try to set a sticky lock for the record on node <code>N2</code>, the record must be unstuck. This operation is expensive and reduces performance. The unsticking is done automatically if you issue <code>s_write/1</code> requests at <code>N2</code>.</p> <h3 id="table-locks" class="title-link"> <div class="title-name">Table Locks</div>  </h3> <p><code>Mnesia</code> supports read and write locks on whole tables as a complement to the normal locks on single records. As previously stated, <code>Mnesia</code> sets and releases locks automatically, and the programmer does not need to code these operations. However, transactions that read and write many records in a specific table execute more efficiently if the transaction is started by setting a table lock on this table. This blocks other concurrent transactions from the table. The following two functions are used to set explicit table locks for read and write operations:</p> <ul> <li> <code><a href="mnesia.html#read_lock_table-1">mnesia:read_lock_table(Tab)</a></code> sets a read lock on table <code>Tab</code>.</li> <li> <code><a href="mnesia.html#write_lock_table-1">mnesia:write_lock_table(Tab)</a></code> sets a write lock on table <code>Tab</code>.</li> </ul> <p>Alternative syntax for acquisition of table locks is as follows:</p> <pre data-language="erlang">mnesia:lock({table, Tab}, read)
mnesia:lock({table, Tab}, write)</pre> <p>The matching operations in <code>Mnesia</code> can either lock the entire table or only a single record (when the key is bound in the pattern).</p> <h3 id="global-locks" class="title-link"> <div class="title-name">Global Locks</div>  </h3> <p>Write locks are normally acquired on all nodes where a replica of the table resides (and is active). Read locks are acquired on one node (the local one if a local replica exists).</p> <p>The function <code><a href="mnesia.html#lock-2">mnesia:lock/2</a></code> is intended to support table locks (as mentioned previously) but also for situations when locks need to be acquired regardless of how tables have been replicated:</p> <pre data-language="erlang">mnesia:lock({global, GlobalKey, Nodes}, LockKind)

LockKind ::= read | write | ...</pre> <p>The lock is acquired on <code>LockItem</code> on all nodes in the node list.</p> <h2 id="dirty-operations" class="title-link"> <div class="title-name">5.3 Dirty Operations</div>  </h2> <p>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</p> <p>Dirty operation are often useful, for example, in a datagram routing application where <code>Mnesia</code> stores the routing table, and it is time consuming to start a whole transaction every time a packet is received. <code>Mnesia</code> has therefore functions that manipulate tables without using transactions. This alternative to processing is known as a dirty operation. However, notice the trade-off in avoiding the overhead of transaction processing:</p> <ul> <li>The atomicity and the isolation properties of <code>Mnesia</code> are lost. </li> <li>The isolation property is compromised, because other Erlang processes, which use transaction to manipulate the data, do not get the benefit of isolation if dirty operations simultaneously are used to read and write records from the same table. </li> </ul> <p>The major advantage of dirty operations is that they execute much faster than equivalent operations that are processed as functional objects within a transaction.</p> <p>Dirty operations are written to disc if they are performed on a table of type <code>disc_copies</code> or type <code>disc_only_copies</code>. <code>Mnesia</code> also ensures that all replicas of a table are updated if a dirty write operation is performed on a table.</p> <p>A dirty operation ensures a certain level of consistency. For example, dirty operations cannot return garbled records. Hence, each individual read or write operation is performed in an atomic manner.</p> <p>All dirty functions execute a call to <code>exit({aborted, Reason})</code> on failure. Even if the following functions are executed inside a transaction no locks are acquired. The following functions are available:</p> <ul> <li> <code><a href="mnesia.html#dirty_read-1">mnesia:dirty_read({Tab, Key})</a></code> reads one or more records from <code>Mnesia</code>. </li> <li> <code><a href="mnesia.html#dirty_write-1">mnesia:dirty_write(Record)</a></code> writes the record <code>Record</code>. </li> <li> <code><a href="mnesia.html#dirty_delete-1">mnesia:dirty_delete({Tab, Key})</a></code> deletes one or more records with key <code>Key</code>. </li> <li> <code><a href="mnesia.html#dirty_delete_object-1">mnesia:dirty_delete_object(Record)</a></code> is the dirty operation alternative to the function <code><a href="mnesia.html#delete_object-1">delete_object/1</a></code>. </li> <li> <p><code><a href="mnesia.html#dirty_first-1">mnesia:dirty_first(Tab)</a></code> returns the "first" key in table <code>Tab</code>.</p> <p>Records in <code>set</code> or <code>bag</code> tables are not sorted. However, there is a record order that is unknown to the user. This means that a table can be traversed by this function with the function <code><a href="mnesia.html#dirty_next-2">mnesia:dirty_next/2</a></code>.</p> <p>If there are no records in the table, this function returns the atom <code>'$end_of_table'</code>. It is not recommended to use this atom as the key for any user records.</p> </li> <li> <p><code><a href="mnesia.html#dirty_next-2">mnesia:dirty_next(Tab, Key)</a></code> returns the "next" key in table <code>Tab</code>. This function makes it possible to traverse a table and perform some operation on all records in the table. When the end of the table is reached, the special key <code>'$end_of_table'</code> is returned. Otherwise, the function returns a key that can be used to read the actual record.</p> <p>The behavior is undefined if any process performs a write operation on the table while traversing the table with the function <code><a href="mnesia.html#dirty_next-2">dirty_next/2</a></code> This is because <code>write</code> operations on a <code>Mnesia</code> table can lead to internal reorganizations of the table itself. This is an implementation detail, but remember that the dirty functions are low-level functions.</p> </li> <li> <code><a href="mnesia.html#dirty_last-1">mnesia:dirty_last(Tab)</a></code> works exactly like <code><a href="mnesia.html#dirty_first-1">mnesia:dirty_first/1</a></code> but returns the last object in Erlang term order for the table type <code>ordered_set</code>. For all other table types, <code>mnesia:dirty_first/1</code> and <code>mnesia:dirty_last/1</code> are synonyms. </li> <li> <code><a href="mnesia.html#dirty_prev-2">mnesia:dirty_prev(Tab, Key)</a></code> works exactly like <code>mnesia:dirty_next/2</code> but returns the previous object in Erlang term order for the table type <code>ordered_set</code>. For all other table types, <code>mnesia:dirty_next/2</code> and <code>mnesia:dirty_prev/2</code> are synonyms. </li> <li> <p>The behavior of this function is undefined if the table is written on while being traversed. The function <code><a href="mnesia.html#read_lock_table-1">mnesia:read_lock_table(Tab)</a></code> can be used to ensure that no transaction-protected writes are performed during the iteration.</p> </li> <li> <p><code><a href="mnesia.html#dirty_update_counter-2">mnesia:dirty_update_counter({Tab,Key}, Val)</a></code>. Counters are positive integers with a value greater than or equal to zero. Updating a counter adds <code>Val</code> and the counter where <code>Val</code> is a positive or negative integer.</p> <p><code>Mnesia</code> has no special counter records. However, records of the form <code>{TabName, Key, Integer}</code> can be used as counters, and can be persistent.</p> <p>Transaction-protected updates of counter records are not possible.</p> <p>There are two significant differences when using this function instead of reading the record, performing the arithmetic, and writing the record:</p> <ol> <li>It is much more efficient. </li> <li>The function <code><a href="mnesia.html#dirty_update_counter-2">dirty_update_counter/2</a></code> is performed as an atomic operation although it is not protected by a transaction. Therefore no table update is lost if two processes simultaneously execute the function <code>dirty_update_counter/2</code>. </li> </ol> </li> <li> <code><a href="mnesia.html#dirty_match_object-2">mnesia:dirty_match_object(Pat)</a></code> is the dirty equivalent of <code><a href="mnesia.html#match_object-1">mnesia:match_object/1</a></code>. </li> <li> <code><a href="mnesia.html#dirty_select-2">mnesia:dirty_select(Tab, Pat)</a></code> is the dirty equivalent of <code><a href="mnesia.html#select-2"> mnesia:select/2</a></code>. </li> <li> <code><a href="mnesia.html#dirty_index_match_object-2">mnesia:dirty_index_match_object(Pat, Pos)</a></code> is the dirty equivalent of <code><a href="mnesia.html#index_match_object-2">mnesia:index_match_object/2</a></code>. </li> <li> <code><a href="mnesia.html#dirty_index_read-3">mnesia:dirty_index_read(Tab, SecondaryKey, Pos)</a></code> is the dirty equivalent of <code><a href="mnesia.html#index_read-3">mnesia:index_read/3</a></code>. </li> <li> <code><a href="mnesia.html#dirty_all_keys-1">mnesia:dirty_all_keys(Tab)</a></code> is the dirty equivalent of <code><a href="mnesia.html#all_keys-1"> mnesia:all_keys/1</a></code>. </li> </ul> <h2 id="record-names-versus-table-names" class="title-link"> <div class="title-name">5.4 Record Names versus Table Names</div>  </h2> <p>In <code>Mnesia</code>, all records in a table must have the same name. All the records must be instances of the same record type. The record name, however, does not necessarily have to be the same as the table name, although this is the case in most of the examples in this User's Guide. If a table is created without property <code>record_name</code>, the following code ensures that all records in the tables have the same name as the table:</p> <pre data-language="erlang">mnesia:create_table(subscriber, [])</pre> <p>However, if the table is created with an explicit record name as argument, as shown in the following example, subscriber records can be stored in both of the tables regardless of the table names:</p> <pre data-language="erlang">TabDef = [{record_name, subscriber}],
mnesia:create_table(my_subscriber, TabDef),
mnesia:create_table(your_subscriber, TabDef).</pre> <p>To access such tables, simplified access functions (as described earlier) cannot be used. For example, writing a subscriber record into a table requires the function <code><a href="mnesia.html#write-3">mnesia:write/3</a></code> instead of the simplified functions <code><a href="mnesia.html#write-1">mnesia:write/1</a></code> and <code><a href="mnesia.html#s_write-1">mnesia:s_write/1</a></code>:</p> <pre data-language="erlang">mnesia:write(subscriber, #subscriber{}, write)
mnesia:write(my_subscriber, #subscriber{}, sticky_write)
mnesia:write(your_subscriber, #subscriber{}, write)</pre> <p>The following simple code illustrates the relationship between the simplified access functions used in most of the examples and their more flexible counterparts:</p> <pre data-language="erlang">mnesia:dirty_write(Record) -&gt;
  Tab = element(1, Record),
  mnesia:dirty_write(Tab, Record).

mnesia:dirty_delete({Tab, Key}) -&gt;
  mnesia:dirty_delete(Tab, Key).

mnesia:dirty_delete_object(Record) -&gt;
  Tab = element(1, Record),
  mnesia:dirty_delete_object(Tab, Record) 

mnesia:dirty_update_counter({Tab, Key}, Incr) -&gt;
  mnesia:dirty_update_counter(Tab, Key, Incr).

mnesia:dirty_read({Tab, Key}) -&gt;
  Tab = element(1, Record),
  mnesia:dirty_read(Tab, Key).

mnesia:dirty_match_object(Pattern) -&gt;
  Tab = element(1, Pattern),
  mnesia:dirty_match_object(Tab, Pattern).

mnesia:dirty_index_match_object(Pattern, Attr) 
  Tab = element(1, Pattern),
  mnesia:dirty_index_match_object(Tab, Pattern, Attr).

mnesia:write(Record) -&gt;
  Tab = element(1, Record),
  mnesia:write(Tab, Record, write).

mnesia:s_write(Record) -&gt;
  Tab = element(1, Record),
  mnesia:write(Tab, Record, sticky_write).

mnesia:delete({Tab, Key}) -&gt;
  mnesia:delete(Tab, Key, write).

mnesia:s_delete({Tab, Key}) -&gt;
  mnesia:delete(Tab, Key, sticky_write).

mnesia:delete_object(Record) -&gt;
  Tab = element(1, Record),
  mnesia:delete_object(Tab, Record, write).

mnesia:s_delete_object(Record) -&gt;
  Tab = element(1, Record),
  mnesia:delete_object(Tab, Record, sticky_write).

mnesia:read({Tab, Key}) -&gt;
  mnesia:read(Tab, Key, read).

mnesia:wread({Tab, Key}) -&gt;
  mnesia:read(Tab, Key, write).

mnesia:match_object(Pattern) -&gt;
  Tab = element(1, Pattern),
  mnesia:match_object(Tab, Pattern, read).

mnesia:index_match_object(Pattern, Attr) -&gt;
  Tab = element(1, Pattern),
  mnesia:index_match_object(Tab, Pattern, Attr, read).</pre> <h2 id="activity-concept-and-various-access-contexts" class="title-link"> <div class="title-name">5.5 Activity Concept and Various Access Contexts</div>  </h2> <p>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function <code><a href="mnesia.html#transaction-1">mnesia:transaction/1,2,3</a></code>: </p> <ul> <li> <code><a href="mnesia.html#write-3">mnesia:write/3 (write/1, s_write/1)</a></code> </li> <li> <code><a href="mnesia.html#delete-3">mnesia:delete/3</a></code> (<code><a href="mnesia.html#delete-1">mnesia:delete/1</a></code>, <code><a href="mnesia.html#s_delete-1">mnesia:s_delete/1</a></code>) </li> <li> <code><a href="mnesia.html#delete_object-3">mnesia:delete_object/3</a></code> (<code><a href="mnesia.html#delete_object-1">mnesia:delete_object/1</a></code>, <code><a href="mnesia.html#s_delete_object-1">mnesia:s_delete_object/1</a></code>) </li> <li> <code><a href="mnesia.html#read-3">mnesia:read/3</a></code> (<code><a href="mnesia.html#read-1">mnesia:read/1</a></code>, <code><a href="mnesia.html#wread-1">mnesia:wread/1</a></code>) </li> <li> <code><a href="mnesia.html#match_object-3">mnesia:match_object/2</a></code> (<code><a href="mnesia.html#match_object-1">mnesia:match_object/1</a></code>) </li> <li> <code><a href="mnesia.html#select-2">mnesia:select/3</a></code> (<code><a href="mnesia.html#select-2">mnesia:select/2</a></code>) </li> <li> <code><a href="mnesia.html#foldl-3">mnesia:foldl/3</a></code> (<code>mnesia:foldl/4</code>, <code><a href="mnesia.html#foldr-3">mnesia:foldr/3</a></code>, <code>mnesia:foldr/4</code>) </li> <li> <code><a href="mnesia.html#all_keys-1">mnesia:all_keys/1</a></code> </li> <li> <code><a href="mnesia.html#index_match_object-4">mnesia:index_match_object/4</a></code> (<code><a href="mnesia.html#index_match_object-2">mnesia:index_match_object/2</a></code>) </li> <li> <code><a href="mnesia.html#index_read-3">mnesia:index_read/3</a></code> </li> <li> <code><a href="mnesia.html#lock-2">mnesia:lock/2</a></code> (<code><a href="mnesia.html#read_lock_table-1">mnesia:read_lock_table/1</a></code>, <code><a href="mnesia.html#write_lock_table-1">mnesia:write_lock_table/1</a></code>) </li> <li> <code><a href="mnesia.html#table_info-2">mnesia:table_info/2</a></code> </li> </ul> <p>These functions are performed in a transaction context involving mechanisms, such as locking, logging, replication, checkpoints, subscriptions, and commit protocols. However, the same function can also be evaluated in other activity contexts.</p> <p>The following activity access contexts are currently supported:</p> <ul> <li><code>transaction</code></li> <li><code>sync_transaction</code></li> <li><code>async_dirty</code></li> <li><code>sync_dirty</code></li> <li><code>ets</code></li> </ul> <p>By passing the same "fun" as argument to the function <code><a href="mnesia.html#sync_transaction-1">mnesia:sync_transaction(Fun [, Args])</a></code> it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the <code>mnesia:sync_transaction</code> call. Using <code>sync_transaction</code> is useful in the following cases:</p> <ul> <li>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</li> <li>When a combining transaction writes with "dirty_reads", that is, the functions <code>dirty_match_object</code>, <code>dirty_read</code>, <code>dirty_index_read</code>, <code>dirty_select</code>, and so on.</li> <li>When an application performs frequent or voluminous updates that can overload <code>Mnesia</code> on other nodes.</li> </ul> <p>By passing the same "fun" as argument to the function <code><a href="mnesia.html#async_dirty-1">mnesia:async_dirty(Fun [, Args])</a></code>, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated "dirty". Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</p> <p>By passing the same "fun" as an argument to the function <code><a href="mnesia.html#sync_dirty-1">mnesia:sync_dirty(Fun [, Args])</a></code>, it is performed in almost the same context as the function <code><a href="mnesia.html#async_dirty-1">mnesia:async_dirty/1,2</a></code>. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using <code>mnesia:sync_dirty/1,2</code> is useful in the following cases:</p> <ul> <li>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</li> <li>When an application performs frequent or voluminous updates that can overload <code>Mnesia</code> on the nodes.</li> </ul> <p>To check if your code is executed within a transaction, use the function <code><a href="mnesia.html#is_transaction-0">mnesia:is_transaction/0</a></code>. It returns <code>true</code> when called inside a transaction context, otherwise <code>false</code>.</p> <p><code>Mnesia</code> tables with storage type <code>RAM_copies</code> and <code>disc_copies</code> are implemented internally as <code>ets</code> tables. Applications can access the these tables directly. This is only recommended if all options have been weighed and the possible outcomes are understood. By passing the earlier mentioned "fun" to the function <code><a href="mnesia.html#ets-1">mnesia:ets(Fun [, Args])</a></code>, it is performed but in a raw context. The operations are performed directly on the local <code>ets</code> tables, assuming that the local storage type is <code>RAM_copies</code> and that the table is not replicated on other nodes.</p> <p>Subscriptions are not triggered and no checkpoints are updated, but this operation is blindingly fast. Disc resident tables are not to be updated with the <code>ets</code> function, as the disc is not updated.</p> <p>The Fun can also be passed as an argument to the function <code><a href="mnesia.html#activity-2">mnesia:activity/2,3,4</a></code>, which enables use of customized activity access callback modules. It can either be obtained directly by stating the module name as argument, or implicitly by use of configuration parameter <code>access_module</code>. A customized callback module can be used for several purposes, such as providing triggers, integrity constraints, runtime statistics, or virtual tables.</p> <p>The callback module does not have to access real <code>Mnesia</code> tables, it is free to do whatever it wants as long as the callback interface is fulfilled.</p> <p><code><a href="mnesia_app_b.html">Appendix B, Activity Access Callback Interface</a></code> provides the source code, <code>mnesia_frag.erl</code>, for one alternative implementation. The context-sensitive function <code><a href="mnesia.html#table_info-2">mnesia:table_info/2</a></code> can be used to provide virtual information about a table. One use of this is to perform <code>QLC</code> queries within an activity context with a customized callback module. By providing table information about table indexes and other <code>QLC</code> requirements, <code>QLC</code> can be used as a generic query language to access virtual tables.</p> <p>QLC queries can be performed in all these activity contexts (<code>transaction</code>, <code>sync_transaction</code>, <code>async_dirty</code>, <code>sync_dirty</code>, and <code>ets</code>). The <code>ets</code> activity only works if the table has no indexes.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The function <code>mnesia:dirty_*</code> always executes with <code>async_dirty</code> semantics regardless of which activity access contexts that are started. It can even start contexts without any enclosing activity access context.</p> </div> </div> <h2 id="nested-transactions" class="title-link"> <div class="title-name">5.6 Nested Transactions</div>  </h2> <p>Transactions can be nested in an arbitrary fashion. A child transaction must run in the same process as its parent. When a child transaction terminates, the caller of the child transaction gets return value <code>{aborted, Reason}</code> and any work performed by the child is erased. If a child transaction commits, the records written by the child are propagated to the parent.</p> <p>No locks are released when child transactions terminate. Locks created by a sequence of nested transactions are kept until the topmost transaction terminates. Furthermore, any update performed by a nested transaction is only propagated in such a manner so that the parent of the nested transaction sees the updates. No final commitment is done until the top-level transaction terminates. So, although a nested transaction returns <code>{atomic, Val}</code>, if the enclosing parent transaction terminates, the entire nested operation terminates.</p> <p>The ability to have nested transaction with identical semantics as top-level transaction makes it easier to write library functions that manipulate <code>Mnesia</code> tables.</p> <p>Consider a function that adds a subscriber to a telephony system:</p> <pre data-language="erlang">
add_subscriber(S) -&gt;
    mnesia:transaction(fun() -&gt;
        case mnesia:read( ..........</pre> <p>This function needs to be called as a transaction. Assume that you wish to write a function that both calls the function <code>add_subscriber/1</code> and is in itself protected by the context of a transaction. By calling <code>add_subscriber/1</code> from within another transaction, a nested transaction is created.</p> <p>Also, different activity access contexts can be mixed while nesting. However, the dirty ones (<code>async_dirty</code>, <code>sync_dirty</code>, and <code>ets</code>) inherit the transaction semantics if they are called inside a transaction and thus grab locks and use two or three phase commit.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
add_subscriber(S) -&gt;
    mnesia:transaction(fun() -&gt;
       %% Transaction context 
       mnesia:read({some_tab, some_data}),
       mnesia:sync_dirty(fun() -&gt;
           %% Still in a transaction context.
           case mnesia:read( ..) ..end), end).
add_subscriber2(S) -&gt;
    mnesia:sync_dirty(fun() -&gt;
       %% In dirty context 
       mnesia:read({some_tab, some_data}),
       mnesia:transaction(fun() -&gt;
           %% In a transaction context.
           case mnesia:read( ..) ..end), end).</pre> <h2 id="pattern-matching" class="title-link"> <div class="title-name">5.7 Pattern Matching</div>  </h2>  <p id="matching">When the function <code><a href="mnesia.html#read-3">mnesia:read/3</a></code> cannot be used, <code>Mnesia</code> provides the programmer with several functions for matching records against a pattern. The most useful ones are the following:</p> <pre data-language="erlang">mnesia:select(Tab, MatchSpecification, LockKind) -&gt;
    transaction abort | [ObjectList]
mnesia:select(Tab, MatchSpecification, NObjects, Lock) -&gt;  
    transaction abort | {[Object],Continuation} | '$end_of_table'
mnesia:select(Cont) -&gt;
    transaction abort | {[Object],Continuation} | '$end_of_table'
mnesia:match_object(Tab, Pattern, LockKind) -&gt;
    transaction abort | RecordList</pre> <p>These functions match a <code>Pattern</code> against all records in table <code>Tab</code>. In a <code><a href="mnesia.html#select-2">mnesia:select</a></code> call, <code>Pattern</code> is a part of <code>MatchSpecification</code> described in the following. It is not necessarily performed as an exhaustive search of the entire table. By using indexes and bound values in the key of the pattern, the actual work done by the function can be condensed into a few hash lookups. Using <code>ordered_set</code> tables can reduce the search space if the keys are partially bound.</p> <p>The pattern provided to the functions must be a valid record, and the first element of the provided tuple must be the <code>record_name</code> of the table. The special element <code>'_'</code> matches any data structure in Erlang (also known as an Erlang term). The special elements <code>'$&lt;number&gt;'</code> behave as Erlang variables, that is, they match anything, bind the first occurrence, and match the coming occurrences of that variable against the bound value.</p> <p>Use function <code><a href="mnesia.html#table_info-2">mnesia:table_info(Tab, wild_pattern)</a></code> to obtain a basic pattern, which matches all records in a table, or use the default value in record creation. Do not make the pattern hard-coded, as this makes the code more vulnerable to future changes of the record definition.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">Wildpattern = mnesia:table_info(employee, wild_pattern), 
%% Or use
Wildpattern = #employee{_ = '_'},</pre> <p>For the employee table, the wild pattern looks as follows:</p> <pre data-language="erlang">{employee, '_', '_', '_', '_', '_',' _'}.</pre> <p>To constrain the match, it is needed to replace some of the <code>'_'</code> elements. The code for matching out all female employees looks as follows:</p> <pre data-language="erlang">Pat = #employee{sex = female, _ = '_'},
F = fun() -&gt; mnesia:match_object(Pat) end,
Females = mnesia:transaction(F).</pre> <p>The match function can also be used to check the equality of different attributes. For example, to find all employees with an employee number equal to their room number:</p> <pre data-language="erlang">Pat = #employee{emp_no = '$1', room_no = '$1', _ = '_'},
F = fun() -&gt; mnesia:match_object(Pat) end,
Odd = mnesia:transaction(F).</pre> <p>The function <code><a href="mnesia.html#match_object-3">mnesia:match_object/3</a></code> lacks some important features that <code><a href="mnesia.html#select-2">mnesia:select/3</a></code> have. For example, <code>mnesia:match_object/3</code> can only return the matching records, and it cannot express constraints other than equality. To find the names of the male employees on the second floor:</p> <pre data-language="erlang">MatchHead = #employee{name='$1', sex=male, room_no={'$2', '_'}, _='_'},
Guard = [{'&gt;=', '$2', 220},{'&lt;', '$2', 230}],
Result = '$1',
mnesia:select(employee,[{MatchHead, Guard, [Result]}])</pre> <p>The function <code>select</code> can be used to add more constraints and create output that cannot be done with <code>mnesia:match_object/3</code>.</p> <p>The second argument to <code>select</code> is a <code>MatchSpecification</code>. A <code>MatchSpecification</code> is a list of <code>MatchFunction</code>s, where each <code>MatchFunction</code> consists of a tuple containing <code>{MatchHead, MatchCondition, MatchBody}</code>:</p> <ul> <li> <code>MatchHead</code> is the same pattern as used in <code>mnesia:match_object/3</code> described earlier.</li> <li> <code>MatchCondition</code> is a list of extra constraints applied to each record.</li> <li> <code>MatchBody</code> constructs the return values.</li> </ul> <p>For details about the match specifications, see "Match Specifications in Erlang" in <code>ERTS</code> User's Guide. For more information, see the <code>ets</code> and <code>dets</code> manual pages in <code>STDLIB</code>.</p> <p>The functions <code><a href="mnesia.html#select-4">select/4</a></code> and <code><a href="mnesia.html#select-2">select/1</a></code> are used to get a limited number of results, where <code>Continuation</code> gets the next chunk of results. <code>Mnesia</code> uses <code>NObjects</code> as a recommendation only. Thus, more or less results than specified with <code>NObjects</code> can be returned in the result list, even the empty list can be returned even if there are more results to collect.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>There is a severe performance penalty in using <code>mnesia:select/[1|2|3|4]</code> after any modifying operation is done on that table in the same transaction. That is, avoid using <code><a href="mnesia.html#write-1">mnesia:write/1</a></code> or <code><a href="mnesia.html#delete-1">mnesia:delete/1</a></code> before <code>mnesia:select</code> in the same transaction.</p> </div> </div> <p>If the key attribute is bound in a pattern, the match operation is efficient. However, if the key attribute in a pattern is given as <code>'_'</code> or <code>'$1'</code>, the whole <code>employee</code> table must be searched for records that match. Hence if the table is large, this can become a time-consuming operation, but it can be remedied with indexes (see <code><a href="mnesia_chap5.html#indexing">Indexing</a></code>) if the function <code><a href="mnesia.html#match_object-1">mnesia:match_object</a></code> is used.</p> <p>QLC queries can also be used to search <code>Mnesia</code> tables. By using the function <code><a href="mnesia.html#table-1">mnesia:table/[1|2]</a></code> as the generator inside a QLC query, you let the query operate on a <code>Mnesia</code> table. <code>Mnesia</code>-specific options to <code>mnesia:table/2</code> are <code>{lock, Lock}</code>, <code>{n_objects,Integer}</code>, and <code>{traverse, SelMethod}</code>:</p> <ul> <li> <code>lock</code> specifies whether <code>Mnesia</code> is to acquire a read or write lock on the table.</li> <li> <code>n_objects</code> specifies how many results are to be returned in each chunk to QLC.</li> <li> <code>traverse</code> specifies which function <code>Mnesia</code> is to use to traverse the table. Default <code>select</code> is used, but by using <code>{traverse, {select, MatchSpecification}}</code> as an option to <code><a href="mnesia.html#table-1">mnesia:table/2</a></code> the user can specify its own view of the table.</li> </ul> <p>If no options are specified, a read lock is acquired, 100 results are returned in each chunk, and <code>select</code> is used to traverse the table, that is:</p> <pre data-language="erlang">mnesia:table(Tab) -&gt;
    mnesia:table(Tab, [{n_objects,100},{lock, read}, {traverse, select}]).</pre> <p>The function <code><a href="mnesia.html#all_keys-1">mnesia:all_keys(Tab)</a></code> returns all keys in a table.</p> <h2 id="iteration" class="title-link"> <div class="title-name">5.8 Iteration</div>  </h2>  <p id="iteration"><code>Mnesia</code> provides the following functions that iterate over all the records in a table:</p> <pre data-language="erlang">mnesia:foldl(Fun, Acc0, Tab) -&gt; NewAcc | transaction abort
mnesia:foldr(Fun, Acc0, Tab) -&gt; NewAcc | transaction abort
mnesia:foldl(Fun, Acc0, Tab, LockType) -&gt; NewAcc | transaction abort
mnesia:foldr(Fun, Acc0, Tab, LockType) -&gt; NewAcc | transaction abort</pre> <p>These functions iterate over the <code>Mnesia</code> table <code>Tab</code> and apply the function <code>Fun</code> to each record. <code>Fun</code> takes two arguments, the first is a record from the table, and the second is the accumulator. <code>Fun</code> returns a new accumulator.</p> <p>The first time <code>Fun</code> is applied, <code>Acc0</code> is the second argument. The next time <code>Fun</code> is called, the return value from the previous call is used as the second argument. The term the last call to <code>Fun</code> returns is the return value of the function <code><a href="mnesia.html#foldl-3">mnesia:foldl/3</a></code> or <code><a href="mnesia.html#foldr-3">mnesia:foldr/3</a></code>.</p> <p>The difference between these functions is the order the table is accessed for <code>ordered_set</code> tables. For other table types the functions are equivalent.</p> <p><code>LockType</code> specifies what type of lock that is to be acquired for the iteration, default is <code>read</code>. If records are written or deleted during the iteration, a write lock is to be acquired.</p> <p>These functions can be used to find records in a table when it is impossible to write constraints for the function <code><a href="mnesia.html#match_object-3">mnesia:match_object/3</a></code>, or when you want to perform some action on certain records.</p> <p>For example, finding all the employees who have a salary less than 10 can look as follows:</p> <pre data-language="erlang">find_low_salaries() -&gt;
  Constraint = 
       fun(Emp, Acc) when Emp#employee.salary &lt; 10 -&gt;
              [Emp | Acc];
          (_, Acc) -&gt;
              Acc
       end,
  Find = fun() -&gt; mnesia:foldl(Constraint, [], employee) end,
  mnesia:transaction(Find).</pre> <p>To raise the salary to 10 for everyone with a salary less than 10 and return the sum of all raises:</p> <pre data-language="erlang">increase_low_salaries() -&gt;
   Increase = 
       fun(Emp, Acc) when Emp#employee.salary &lt; 10 -&gt;
              OldS = Emp#employee.salary,
              ok = mnesia:write(Emp#employee{salary = 10}),
              Acc + 10 - OldS;
          (_, Acc) -&gt;
              Acc
       end,
  IncLow = fun() -&gt; mnesia:foldl(Increase, 0, employee, write) end,
  mnesia:transaction(IncLow).</pre> <p>Many nice things can be done with the iterator functions but take some caution about performance and memory use for large tables.</p> <p>Call these iteration functions on nodes that contain a replica of the table. Each call to the function <code>Fun</code> access the table and if the table resides on another node it generates much unnecessary network traffic.</p> <p><code>Mnesia</code> also provides some functions that make it possible for the user to iterate over the table. The order of the iteration is unspecified if the table is not of type <code>ordered_set</code>:</p> <pre data-language="erlang">mnesia:first(Tab) -&gt;  Key | transaction abort
mnesia:last(Tab)  -&gt;  Key | transaction abort
mnesia:next(Tab,Key)  -&gt;  Key | transaction abort
mnesia:prev(Tab,Key)  -&gt;  Key | transaction abort
mnesia:snmp_get_next_index(Tab,Index) -&gt; {ok, NextIndex} | endOfTable</pre> <p>The order of <code>first</code>/<code>last</code> and <code>next</code>/<code>prev</code> is only valid for <code>ordered_set</code> tables, they are synonyms for other tables. When the end of the table is reached, the special key <code>'$end_of_table'</code> is returned.</p> <p>If records are written and deleted during the traversal, use the function <code><a href="mnesia.html#foldl">mnesia:foldl/3</a></code> or <code><a href="mnesia.html#foldr">mnesia:foldr/3</a></code> with a <code>write</code> lock. Or the function <code><a href="mnesia.html#write_lock_table-1">mnesia:write_lock_table/1</a></code> when using <code>first</code> and <code>next</code>.</p> <p>Writing or deleting in transaction context creates a local copy of each modified record. Thus, modifying each record in a large table uses much memory. <code>Mnesia</code> compensates for every written or deleted record during the iteration in a transaction context, which can reduce the performance. If possible, avoid writing or deleting records in the same transaction before iterating over the table.</p> <p>In dirty context, that is, <code>sync_dirty</code> or <code>async_dirty</code>, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands <code><a href="mnesia.html#first-1">mnesia:first/1</a></code> and <code><a href="mnesia.html#next-2">mnesia:next/2</a></code>, the same drawbacks as described previously for <code><a href="mnesia.html#dirty_first-1">mnesia:dirty_first/1</a></code> and <code><a href="mnesia.html#dirty_next-2">mnesia:dirty_next/2</a></code> applies, that is, no writing to the table is to be done during iteration.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
