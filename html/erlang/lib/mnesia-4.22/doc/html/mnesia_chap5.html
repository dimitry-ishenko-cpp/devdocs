<div class="innertube"> <h1 id="Miscellaneous Mnesia Features">6 Miscellaneous Mnesia Features</h1> <p>The previous sections describe how to get started with <code>Mnesia</code> and how to build a <code>Mnesia</code> database. This section describes the more advanced features available when building a distributed, fault-tolerant <code>Mnesia</code> database. The following topics are included:</p> <ul> <li>Indexing</li> <li>Distribution and fault tolerance</li> <li>Table fragmentation</li> <li>Local content tables</li> <li>Disc-less nodes</li> <li>More about schema management</li> <li> <code>Mnesia</code> event handling</li> <li>Debugging <code>Mnesia</code> applications</li> <li>Concurrent processes in <code>Mnesia</code> </li> <li>Prototyping</li> <li>Object-based programming with <code>Mnesia</code> </li> </ul> <h2 id="indexing" class="title-link"> <div class="title-name">6.1 Indexing</div>  </h2> <p>Data retrieval and matching can be performed efficiently if the key for the record is known. Conversely, if the key is unknown, all records in a table must be searched. The larger the table, the more time consuming it becomes. To remedy this problem, <code>Mnesia</code> indexing capabilities are used to improve data retrieval and matching of records.</p> <p>The following two functions manipulate indexes on existing tables:</p> <ul> <li><code><a href="mnesia.html#add_table_index-2">mnesia:add_table_index(Tab, AttributeName) -&gt; {aborted, R} |{atomic, ok}</a></code></li> <li><code><a href="mnesia.html#del_table_index-2">mnesia:del_table_index(Tab, AttributeName) -&gt; {aborted, R} |{atomic, ok}</a></code></li> </ul> <p>These functions create or delete a table index on a field defined by <code>AttributeName</code>. To illustrate this, add an index to the table definition <code>(employee, {emp_no, name, salary, sex, phone, room_no})</code>, which is the example table from the <code>Company</code> database. The function that adds an index on element <code>salary</code> can be expressed as <code>mnesia:add_table_index(employee, salary)</code>.</p> <p>The indexing capabilities of <code>Mnesia</code> are used with the following three functions, which retrieve and match records based on index entries in the database:</p> <ul> <li> <code><a href="mnesia.html#index_read-3">mnesia:index_read(Tab, SecondaryKey, AttributeName) -&gt; transaction abort | RecordList</a></code> avoids an exhaustive search of the entire table, by looking up <code>SecondaryKey</code> in the index to find the primary keys. </li> <li> <code><a href="mnesia.html#index_match_object-2">mnesia:index_match_object(Pattern, AttributeName) -&gt; transaction abort | RecordList</a></code> avoids an exhaustive search of the entire table, by looking up the secondary key in the index to find the primary keys. The secondary key is found in field <code>AttributeName</code> of <code>Pattern</code>. The secondary key must be bound. </li> <li> <code><a href="mnesia.html#match_object-1">mnesia:match_object(Pattern) -&gt; transaction abort | RecordList</a></code> uses indexes to avoid exhaustive search of the entire table. Unlike the previous functions, this function can use any index as long as the secondary key is bound.</li> </ul> <p>These functions are further described and exemplified in <code><a href="mnesia_chap4.html#matching">Pattern Matching</a></code>. </p> <h2 id="distribution-and-fault-tolerance" class="title-link"> <div class="title-name">6.2 Distribution and Fault Tolerance</div>  </h2> <p><code>Mnesia</code> is a distributed, fault-tolerant DBMS. Tables can be replicated on different Erlang nodes in various ways. The <code>Mnesia</code> programmer does not need to state where the different tables reside, only the names of the different tables need to be specified in the program code. This is known as "location transparency" and is an important concept. In particular:</p> <ul> <li> <p>A program works regardless of the data location. It makes no difference whether the data resides on the local node or on a remote node.</p> <p>Notice that the program runs slower if the data is located on a remote node.</p> </li> <li>The database can be reconfigured, and tables can be moved between nodes. These operations do not affect the user programs. </li> </ul> <p>It has previously been shown that each table has a number of system attributes, such as <code>index</code> and <code>type</code>.</p> <p>Table attributes are specified when the table is created. For example, the following function creates a table with two RAM replicas:</p> <pre data-language="erlang">
mnesia:create_table(foo,
                    [{ram_copies, [N1, N2]},
                     {attributes, record_info(fields, foo)}]).</pre> <p>Tables can also have the following properties, where each attribute has a list of Erlang nodes as its value:</p> <ul> <li> <p><code>ram_copies</code>. The value of the node list is a list of Erlang nodes, and a RAM replica of the table resides on each node in the list.</p> <p>Notice that no disc operations are performed when a program executes write operations to these replicas. However, if permanent RAM replicas are required, the following alternatives are available:</p> <ol> <li>The function <code><a href="mnesia.html#dump_tables-1">mnesia:dump_tables/1</a></code> can be used to dump RAM table replicas to disc. </li> <li>The table replicas can be backed up, either from RAM, or from disc if dumped there with this function. </li> </ol> </li> <li> <code>disc_copies</code>. The value of the attribute is a list of Erlang nodes, and a replica of the table resides both in RAM and on disc on each node in the list. Write operations addressed to the table address both the RAM and the disc copy of the table. </li> <li> <code>disc_only_copies</code>. The value of the attribute is a list of Erlang nodes, and a replica of the table resides only as a disc copy on each node in the list. The major disadvantage of this type of table replica is the access speed. The major advantage is that the table does not occupy space in memory. </li> </ul> <p>In addition, table properties can be set and changed. For details, see <code><a href="mnesia_chap3.html#def_schema">Define a Schema</a></code>. </p> <p>There are basically two reasons for using more than one table replica: fault tolerance and speed. Notice that table replication provides a solution to both of these system requirements.</p> <p>If there are two active table replicas, all information is still available if one replica fails. This can be an important property in many applications. Furthermore, if a table replica exists at two specific nodes, applications that execute at either of these nodes can read data from the table without accessing the network. Network operations are considerably slower and consume more resources than local operations.</p> <p>It can be advantageous to create table replicas for a distributed application that reads data often, but writes data seldom, to achieve fast read operations on the local node. The major disadvantage with replication is the increased time to write data. If a table has two replicas, every write operation must access both table replicas. Since one of these write operations must be a network operation, it is considerably more expensive to perform a write operation to a replicated table than to a non-replicated table.</p> <h2 id="table-fragmentation" class="title-link"> <div class="title-name">6.3 Table Fragmentation</div>  </h2> <h3 id="concept" class="title-link"> <div class="title-name">Concept</div>  </h3> <p>A concept of table fragmentation has been introduced to cope with large tables. The idea is to split a table into several manageable fragments. Each fragment is implemented as a first class <code>Mnesia</code> table and can be replicated, have indexes, and so on, as any other table. But the tables cannot have <code>local_content</code> or have the <code>snmp</code> connection activated.</p> <p>To be able to access a record in a fragmented table, <code>Mnesia</code> must determine to which fragment the actual record belongs. This is done by module <code>mnesia_frag</code>, which implements the <code>mnesia_access</code> callback behavior. It is recommended to read the documentation about the function <code><a href="mnesia.html#activity-4">mnesia:activity/4</a></code> to see how <code>mnesia_frag</code> can be used as a <code>mnesia_access</code> callback module.</p> <p>At each record access, <code>mnesia_frag</code> first computes a hash value from the record key. Second, the name of the table fragment is determined from the hash value. Finally the actual table access is performed by the same functions as for non-fragmented tables. When the key is not known beforehand, all fragments are searched for matching records.</p> <p>Notice that in <code>ordered_set</code> tables, the records are ordered per fragment, and the order is undefined in results returned by <code>select</code> and <code>match_object</code>, as well as <code>first</code>, <code>next</code>, <code>prev</code> and <code>last</code>.</p> <p>The following code illustrates how a <code>Mnesia</code> table is converted to be a fragmented table and how more fragments are added later:</p> <pre data-language="erlang">Eshell V4.7.3.3  (abort with ^G)
(a@sam)1&gt; mnesia:start().
ok
(a@sam)2&gt; mnesia:system_info(running_db_nodes).
[b@sam,c@sam,a@sam]
(a@sam)3&gt; Tab = dictionary.
dictionary
(a@sam)4&gt; mnesia:create_table(Tab, [{ram_copies, [a@sam, b@sam]}]).
{atomic,ok}
(a@sam)5&gt; Write = fun(Keys) -&gt; [mnesia:write({Tab,K,-K}) || K &lt;- Keys], ok end.
#Fun&lt;erl_eval&gt;
(a@sam)6&gt; mnesia:activity(sync_dirty, Write, [lists:seq(1, 256)], mnesia_frag).
ok
(a@sam)7&gt; mnesia:change_table_frag(Tab, {activate, []}).
{atomic,ok}
(a@sam)8&gt; mnesia:table_info(Tab, frag_properties).
[{base_table,dictionary},
 {foreign_key,undefined},
 {n_doubles,0},
 {n_fragments,1},
 {next_n_to_split,1},
 {node_pool,[a@sam,b@sam,c@sam]}]
(a@sam)9&gt; Info = fun(Item) -&gt; mnesia:table_info(Tab, Item) end.
#Fun&lt;erl_eval&gt;
(a@sam)10&gt; Dist = mnesia:activity(sync_dirty, Info, [frag_dist], mnesia_frag).
[{c@sam,0},{a@sam,1},{b@sam,1}]
(a@sam)11&gt; mnesia:change_table_frag(Tab, {add_frag, Dist}).
{atomic,ok}
(a@sam)12&gt; Dist2 = mnesia:activity(sync_dirty, Info, [frag_dist], mnesia_frag).
[{b@sam,1},{c@sam,1},{a@sam,2}]
(a@sam)13&gt; mnesia:change_table_frag(Tab, {add_frag, Dist2}).
{atomic,ok}
(a@sam)14&gt; Dist3 = mnesia:activity(sync_dirty, Info, [frag_dist], mnesia_frag).
[{a@sam,2},{b@sam,2},{c@sam,2}]
(a@sam)15&gt; mnesia:change_table_frag(Tab, {add_frag, Dist3}).
{atomic,ok}
(a@sam)16&gt; Read = fun(Key) -&gt; mnesia:read({Tab, Key}) end.
#Fun&lt;erl_eval&gt;
(a@sam)17&gt; mnesia:activity(transaction, Read, [12], mnesia_frag).
[{dictionary,12,-12}]
(a@sam)18&gt; mnesia:activity(sync_dirty, Info, [frag_size], mnesia_frag).
[{dictionary,64},
 {dictionary_frag2,64},
 {dictionary_frag3,64},
 {dictionary_frag4,64}]
(a@sam)19&gt; </pre> <h3 id="fragmentation-properties" class="title-link"> <div class="title-name">Fragmentation Properties</div>  </h3> <p>The table property <code>frag_properties</code> can be read with the function <code><a href="mnesia.html#table_info-2">mnesia:table_info(Tab, frag_properties)</a></code>. The fragmentation properties are a list of tagged tuples with arity 2. By default the list is empty, but when it is non-empty it triggers <code>Mnesia</code> to regard the table as fragmented. The fragmentation properties are as follows:</p> <dl> <dt class="title-link"><strong><code>{n_fragments, Int}</code></strong></dt> <dd> <p><code>n_fragments</code> regulates how many fragments that the table currently has. This property can explicitly be set at table creation and later be changed with <code>{add_frag, NodesOrDist}</code> or <code>del_frag</code>. <code>n_fragments</code> defaults to <code>1</code>.</p> </dd> <dt class="title-link"><strong><code>{node_pool, List}</code></strong></dt> <dd> <p>The node pool contains a list of nodes and can explicitly be set at table creation and later be changed with <code>{add_node, Node}</code> or <code>{del_node, Node}</code>. At table creation <code>Mnesia</code> tries to distribute the replicas of each fragment evenly over all the nodes in the node pool. Hopefully all nodes end up with the same number of replicas. <code>node_pool</code> defaults to the return value from the function <code><a href="mnesia.html#system_info-1">mnesia:system_info(db_nodes)</a></code>.</p> </dd> <dt class="title-link"><strong><code>{n_ram_copies, Int}</code></strong></dt> <dd> <p>Regulates how many <code>ram_copies</code> replicas that each fragment is to have. This property can explicitly be set at table creation. Defaults is <code>0</code>, but if <code>n_disc_copies</code> and <code>n_disc_only_copies</code> also are <code>0</code>, <code>n_ram_copies</code> defaults to <code>1</code>.</p> </dd> <dt class="title-link"><strong><code>{n_disc_copies, Int}</code></strong></dt> <dd> <p>Regulates how many <code>disc_copies</code> replicas that each fragment is to have. This property can explicitly be set at table creation. Default is <code>0</code>.</p> </dd> <dt class="title-link"><strong><code>{n_disc_only_copies, Int}</code></strong></dt> <dd> <p>Regulates how many <code>disc_only_copies</code> replicas that each fragment is to have. This property can explicitly be set at table creation. Defaults is <code>0</code>.</p> </dd> <dt class="title-link"><strong><code>{foreign_key, ForeignKey}</code></strong></dt> <dd> <p><code>ForeignKey</code> can either be the atom <code>undefined</code> or the tuple <code>{ForeignTab, Attr}</code>, where <code>Attr</code> denotes an attribute that is to be interpreted as a key in another fragmented table named <code>ForeignTab</code>. <code>Mnesia</code> ensures that the number of fragments in this table and in the foreign table are always the same.</p> <p>When fragments are added or deleted, <code>Mnesia</code> automatically propagates the operation to all fragmented tables that have a foreign key referring to this table. Instead of using the record key to determine which fragment to access, the value of field <code>Attr</code> is used. This feature makes it possible to colocate records automatically in different tables to the same node. <code>foreign_key</code> defaults to <code>undefined</code>. However, if the foreign key is set to something else, it causes the default values of the other fragmentation properties to be the same values as the actual fragmentation properties of the foreign table.</p> </dd> <dt class="title-link"><strong><code>{hash_module, Atom}</code></strong></dt> <dd> <p>Enables definition of an alternative hashing scheme. The module must implement the <code><a href="mnesia_frag_hash.html">mnesia_frag_hash</a></code> callback behavior. This property can explicitly be set at table creation. Default is <code>mnesia_frag_hash</code>.</p> </dd> <dt class="title-link"><strong><code>{hash_state, Term}</code></strong></dt> <dd> <p>Enables a table-specific parameterization of a generic hash module. This property can explicitly be set at table creation. Default is <code>undefined</code>.</p> <pre data-language="erlang">Eshell V4.7.3.3  (abort with ^G)
(a@sam)1&gt; mnesia:start().
ok
(a@sam)2&gt; PrimProps = [{n_fragments, 7}, {node_pool, [node()]}].
[{n_fragments,7},{node_pool,[a@sam]}]
(a@sam)3&gt; mnesia:create_table(prim_dict, 
                              [{frag_properties, PrimProps},
                               {attributes,[prim_key,prim_val]}]).
{atomic,ok}
(a@sam)4&gt; SecProps = [{foreign_key, {prim_dict, sec_val}}].
[{foreign_key,{prim_dict,sec_val}}]
(a@sam)5&gt; mnesia:create_table(sec_dict, 
                              [{frag_properties, SecProps},
(a@sam)5&gt;                      {attributes, [sec_key, sec_val]}]).
{atomic,ok}
(a@sam)6&gt; Write = fun(Rec) -&gt; mnesia:write(Rec) end.
#Fun&lt;erl_eval&gt;
(a@sam)7&gt; PrimKey = 11.
11
(a@sam)8&gt; SecKey = 42.
42
(a@sam)9&gt; mnesia:activity(sync_dirty, Write,
                          [{prim_dict, PrimKey, -11}], mnesia_frag).
ok
(a@sam)10&gt; mnesia:activity(sync_dirty, Write,
                           [{sec_dict, SecKey, PrimKey}], mnesia_frag).
ok
(a@sam)11&gt; mnesia:change_table_frag(prim_dict, {add_frag, [node()]}).
{atomic,ok}
(a@sam)12&gt; SecRead = fun(PrimKey, SecKey) -&gt;
               mnesia:read({sec_dict, PrimKey}, SecKey, read) end.
#Fun&lt;erl_eval&gt;
(a@sam)13&gt; mnesia:activity(transaction, SecRead,
                           [PrimKey, SecKey], mnesia_frag).
[{sec_dict,42,11}]
(a@sam)14&gt; Info = fun(Tab, Item) -&gt; mnesia:table_info(Tab, Item) end.
#Fun&lt;erl_eval&gt;
(a@sam)15&gt; mnesia:activity(sync_dirty, Info,
                           [prim_dict, frag_size], mnesia_frag).
[{prim_dict,0},
 {prim_dict_frag2,0},
 {prim_dict_frag3,0},
 {prim_dict_frag4,1},
 {prim_dict_frag5,0},
 {prim_dict_frag6,0},
 {prim_dict_frag7,0},
 {prim_dict_frag8,0}]
(a@sam)16&gt; mnesia:activity(sync_dirty, Info,
                           [sec_dict, frag_size], mnesia_frag).
[{sec_dict,0},
 {sec_dict_frag2,0},
 {sec_dict_frag3,0},
 {sec_dict_frag4,1},
 {sec_dict_frag5,0},
 {sec_dict_frag6,0},
 {sec_dict_frag7,0},
 {sec_dict_frag8,0}]
(a@sam)17&gt;</pre> </dd> </dl> <h3 id="management-of-fragmented-tables" class="title-link"> <div class="title-name">Management of Fragmented Tables</div>  </h3> <p>The function <code>mnesia:change_table_frag(Tab, Change)</code> is intended to be used for reconfiguration of fragmented tables. Argument <code>Change</code> is to have one of the following values:</p> <dl> <dt class="title-link"><strong><code>{activate, FragProps}</code></strong></dt> <dd> <p>Activates the fragmentation properties of an existing table. <code>FragProps</code> is either to contain <code>{node_pool, Nodes}</code> or be empty.</p> </dd> <dt class="title-link"><strong><code>deactivate</code></strong></dt> <dd> <p>Deactivates the fragmentation properties of a table. The number of fragments must be <code>1</code>. No other table can refer to this table in its foreign key.</p> </dd> <dt class="title-link"><strong><code>{add_frag, NodesOrDist}</code></strong></dt> <dd> <p>Adds a fragment to a fragmented table. All records in one of the old fragments are rehashed and about half of them are moved to the new (last) fragment. All other fragmented tables, which refer to this table in their foreign key, automatically get a new fragment. Also, their records are dynamically rehashed in the same manner as for the main table.</p> <p>Argument <code>NodesOrDist</code> can either be a list of nodes or the result from the function <code><a href="mnesia.html#table_info-2">mnesia:table_info(Tab, frag_dist)</a></code>. Argument <code>NodesOrDist</code> is assumed to be a sorted list with the best nodes to host new replicas first in the list. The new fragment gets the same number of replicas as the first fragment (see <code>n_ram_copies</code>, <code>n_disc_copies</code>, and <code>n_disc_only_copies</code>). The <code>NodesOrDist</code> list must at least contain one element for each replica that needs to be allocated.</p> </dd> <dt class="title-link"><strong><code>del_frag</code></strong></dt> <dd> <p>Deletes a fragment from a fragmented table. All records in the last fragment are moved to one of the other fragments. All other fragmented tables, which refer to this table in their foreign key, automatically lose their last fragment. Also, their records are dynamically rehashed in the same manner as for the main table.</p> </dd> <dt class="title-link"><strong><code>{add_node, Node}</code></strong></dt> <dd> <p>Adds a node to <code>node_pool</code>. The new node pool affects the list returned from the function <code><a href="mnesia.html#table_info-2">mnesia:table_info(Tab, frag_dist)</a></code>. </p> </dd> <dt class="title-link"><strong><code>{del_node, Node}</code></strong></dt> <dd> <p>Deletes a node from <code>node_pool</code>. The new node pool affects the list returned from the function <code><a href="mnesia.html#table_info-2">mnesia:table_info(Tab, frag_dist)</a></code>. </p> </dd> </dl> <h3 id="extensions-of-existing-functions" class="title-link"> <div class="title-name">Extensions of Existing Functions</div>  </h3> <p>The function <code><a href="mnesia.html#create_table-2">mnesia:create_table/2</a></code> creates a brand new fragmented table, by setting table property <code>frag_properties</code> to some proper values.</p> <p>The function <code><a href="mnesia.html#delete_table-1">mnesia:delete_table/1</a></code> deletes a fragmented table including all its fragments. There must however not exist any other fragmented tables that refer to this table in their foreign key.</p> <p>The function <code><a href="mnesia.html#table_info-2">mnesia:table_info/2</a></code> now understands item <code>frag_properties</code>.</p> <p>If the function <code>mnesia:table_info/2</code> is started in the activity context of module <code>mnesia_frag</code>, information of several new items can be obtained:</p> <dl> <dt class="title-link"><strong><code>base_table</code></strong></dt> <dd>The name of the fragmented table</dd> <dt class="title-link"><strong><code>n_fragments</code></strong></dt> <dd>The actual number of fragments</dd> <dt class="title-link"><strong><code>node_pool</code></strong></dt> <dd>The pool of nodes</dd> <dt class="title-link"><strong><code>n_ram_copies</code></strong></dt>  <dt class="title-link"><strong><code>n_disc_copies</code></strong></dt>  <dt class="title-link"><strong><code>n_disc_only_copies</code></strong></dt> <dd> <p>The number of replicas with storage type <code>ram_copies</code>, <code>disc_copies</code>, and <code>disc_only_copies</code>, respectively. The actual values are dynamically derived from the first fragment. The first fragment serves as a protype. When the actual values need to be computed (for example, when adding new fragments) they are determined by counting the number of each replica for each storage type. This means that when the functions <code><a href="mnesia.html#add_table_copy-3">mnesia:add_table_copy/3</a></code>, <code><a href="mnesia.html#del_table_copy-2">mnesia:del_table_copy/2</a></code>, and <code><a href="mnesia.html#change_table_copy_type-3">mnesia:change_table_copy_type/2</a></code> are applied on the first fragment, it affects the settings on <code>n_ram_copies</code>, <code>n_disc_copies</code>, and <code>n_disc_only_copies</code>.</p> </dd> <dt class="title-link"><strong><code>foreign_key</code></strong></dt> <dd> <p>The foreign key</p> </dd> <dt class="title-link"><strong><code>foreigners</code></strong></dt> <dd> <p>All other tables that refer to this table in their foreign key</p> </dd> <dt class="title-link"><strong><code>frag_names</code></strong></dt> <dd> <p>The names of all fragments</p> </dd> <dt class="title-link"><strong><code>frag_dist</code></strong></dt> <dd> <p>A sorted list of <code>{Node, Count}</code> tuples that are sorted in increasing <code>Count</code> order. <code>Count</code> is the total number of replicas that this fragmented table hosts on each <code>Node</code>. The list always contains at least all nodes in <code>node_pool</code>. Nodes that do not belong to <code>node_pool</code> are put last in the list even if their <code>Count</code> is lower.</p> </dd> <dt class="title-link"><strong><code>frag_size</code></strong></dt> <dd> <p>A list of <code>{Name, Size}</code> tuples, where <code>Name</code> is a fragment <code>Name</code>, and <code>Size</code> is how many records it contains</p> </dd> <dt class="title-link"><strong><code>frag_memory</code></strong></dt> <dd> <p>A list of <code>{Name, Memory}</code> tuples, where <code>Name</code> is a fragment <code>Name</code>, and <code>Memory</code> is how much memory it occupies</p> </dd> <dt class="title-link"><strong><code>size</code></strong></dt> <dd> <p>Total size of all fragments</p> </dd> <dt class="title-link"><strong><code>memory</code></strong></dt> <dd> <p>Total memory of all fragments</p> </dd> </dl> <h3 id="load-balancing" class="title-link"> <div class="title-name">Load Balancing</div>  </h3> <p>There are several algorithms for distributing records in a fragmented table evenly over a pool of nodes. No one is best, it depends on the application needs. The following examples of situations need some attention:</p> <ul> <li> <code>permanent change of nodes</code>. When a new permanent <code>db_node</code> is introduced or dropped, it can be time to change the pool of nodes and redistribute the replicas evenly over the new pool of nodes. It can also be time to add or delete a fragment before the replicas are redistributed. </li> <li> <code>size/memory threshold</code>. When the total size or total memory of a fragmented table (or a single fragment) exceeds some application-specific threshold, it can be time to add a new fragment dynamically to obtain a better distribution of records. </li> <li> <code>temporary node down</code>. When a node temporarily goes down, it can be time to compensate some fragments with new replicas to keep the desired level of redundancy. When the node comes up again, it can be time to remove the superfluous replica. </li> <li> <code>overload threshold</code>. When the load on some node exceeds some application-specific threshold, it can be time to either add or move some fragment replicas to nodes with lower load. Take extra care if the table has a foreign key relation to some other table. To avoid severe performance penalties, the same redistribution must be performed for all the related tables. </li> </ul> <p>Use the function <code>mnesia:change_table_frag/2</code> to add new fragments and apply the usual schema manipulation functions (such as <code><a href="mnesia.html#add_table_copy-3">mnesia:add_table_copy/3</a></code>, <code><a href="mnesia.html#del_table_copy-2">mnesia:del_table_copy/2</a></code>, and <code><a href="mnesia.html#change_table_copy_type-3">mnesia:change_table_copy_type/2</a></code>) on each fragment to perform the actual redistribution.</p> <h2 id="local-content-tables" class="title-link"> <div class="title-name">6.4 Local Content Tables</div>  </h2> <p>Replicated tables have the same content on all nodes where they are replicated. However, it is sometimes advantageous to have tables, but different content on different nodes.</p> <p>If attribute <code>{local_content, true}</code> is specified when you create the table, the table resides on the nodes where you specify the table to exist, but the write operations on the table are only performed on the local copy.</p> <p>Furthermore, when the table is initialized at startup, the table is only initialized locally, and the table content is not copied from another node.</p> <h2 id="disc-less-nodes" class="title-link"> <div class="title-name">6.5 Disc-Less Nodes</div>  </h2> <p><code>Mnesia</code> can be run on nodes that do not have a disc. Replicas of <code>disc_copies</code> or <code>disc_only_copies</code> are not possible on such nodes. This is especially troublesome for the <code>schema</code> table, as <code>Mnesia</code> needs the schema to initialize itself.</p> <p>The schema table can, as other tables, reside on one or more nodes. The storage type of the schema table can either be <code>disc_copies</code> or <code>ram_copies</code> (but not <code>disc_only_copies</code>). At startup, <code>Mnesia</code> uses its schema to determine with which nodes it is to try to establish contact. If any other node is started already, the starting node merges its table definitions with the table definitions brought from the other nodes. This also applies to the definition of the schema table itself. Application parameter <code>extra_db_nodes</code> contains a list of nodes that <code>Mnesia</code> also is to establish contact with besides those found in the schema. Default is <code>[]</code> (empty list).</p> <p>Hence, when a disc-less node needs to find the schema definitions from a remote node on the network, this information must be supplied through application parameter <code>-mnesia extra_db_nodes NodeList</code>. Without this configuration parameter set, <code>Mnesia</code> starts as a single node system. Also, the function <code><a href="mnesia.html#change_config-2">mnesia:change_config/2</a></code> can be used to assign a value to <code>extra_db_nodes</code> and force a connection after <code>Mnesia</code> has been started, that is, <code>mnesia:change_config(extra_db_nodes, NodeList)</code>.</p> <p>Application parameter <code>schema_location</code> controls where <code>Mnesia</code> searches for its schema. The parameter can be one of the following atoms:</p> <dl> <dt class="title-link"><strong><code>disc</code></strong></dt> <dd> <p>Mandatory disc. The schema is assumed to be located in the <code>Mnesia</code> directory. If the schema cannot be found, <code>Mnesia</code> refuses to start.</p> </dd> <dt class="title-link"><strong><code>ram</code></strong></dt> <dd> <p>Mandatory RAM. The schema resides in RAM only. At startup, a tiny new schema is generated. This default schema contains only the definition of the schema table and resides on the local node only. Since no other nodes are found in the default schema, configuration parameter <code>extra_db_nodes</code> must be used to let the node share its table definitions with other nodes. (Parameter <code>extra_db_nodes</code> can also be used on disc-full nodes.)</p> </dd> <dt class="title-link"><strong><code>opt_disc</code></strong></dt> <dd> <p>Optional disc. The schema can reside on either disc or RAM. If the schema is found on disc, <code>Mnesia</code> starts as a disc-full node (the storage type of the schema table is disc_copies). If no schema is found on disc, <code>Mnesia</code> starts as a disc-less node (the storage type of the schema table is <code>ram_copies</code>). The default for the application parameter is <code>opt_disc</code>.</p> </dd> </dl> <p>When <code>schema_location</code> is set to <code>opt_disc</code>, the function <code><a href="mnesia.html#change_table_copy_type-3">mnesia:change_table_copy_type/3</a></code> can be used to change the storage type of the schema. This is illustrated as follows:</p> <pre data-language="erlang">
1&gt; mnesia:start().
ok
2&gt; mnesia:change_table_copy_type(schema, node(), disc_copies).
{atomic, ok}</pre> <p>Assuming that the call to <code><a href="mnesia.html#start-0">mnesia:start/0</a></code> does not find any schema to read on the disc, <code>Mnesia</code> starts as a disc-less node, and then change it to a node that use the disc to store the schema locally.</p> <h2 id="more-about-schema-management" class="title-link"> <div class="title-name">6.6 More about Schema Management</div>  </h2> <p>Nodes can be added to and removed from a <code>Mnesia</code> system. This can be done by adding a copy of the schema to those nodes.</p> <p>The functions <code><a href="mnesia.html#add_table_copy-3">mnesia:add_table_copy/3</a></code> and <code><a href="mnesia.html#del_table_copy-2">mnesia:del_table_copy/2</a></code> can be used to add and delete replicas of the schema table. Adding a node to the list of nodes where the schema is replicated affects the following:</p> <ul> <li>It allows other tables to be replicated to this node. </li> <li>It causes <code>Mnesia</code> to try to contact the node at startup of disc-full nodes. </li> </ul> <p>The function call <code>mnesia:del_table_copy(schema, mynode@host)</code> deletes node <code>mynode@host</code> from the <code>Mnesia</code> system. The call fails if <code>Mnesia</code> is running on <code>mynode@host</code>. The other <code>Mnesia</code> nodes never try to connect to that node again. Notice that if there is a disc resident schema on node <code>mynode@host</code>, the entire <code>Mnesia</code> directory is to be deleted. This is done with the function <code><a href="mnesia.html#delete_schema-1">mnesia:delete_schema/1</a></code>. If <code>Mnesia</code> is started again on node <code>mynode@host</code> and the directory has not been cleared, the behavior of <code>Mnesia</code> is undefined.</p> <p>If the storage type of the schema is <code>ram_copies</code>, that is, a disc-less node, <code>Mnesia</code> does not use the disc on that particular node. The disc use is enabled by changing the storage type of table <code>schema</code> to <code>disc_copies</code>.</p> <p>New schemas are created explicitly with the function <code><a href="mnesia.html#create_schema-1">mnesia:create_schema/1</a></code> or implicitly by starting <code>Mnesia</code> without a disc resident schema. Whenever a table (including the schema table) is created, it is assigned its own unique cookie. The schema table is not created with the function <code><a href="mnesia.html#create_table-2">mnesia:create_table/2</a></code> as normal tables.</p> <p>At startup, <code>Mnesia</code> connects different nodes to each other, then they exchange table definitions with each other, and the table definitions are merged. During the merge procedure, <code>Mnesia</code> performs a sanity test to ensure that the table definitions are compatible with each other. If a table exists on several nodes, the cookie must be the same, otherwise <code>Mnesia</code> shut down one of the nodes. This unfortunate situation occurs if a table has been created on two nodes independently of each other while they were disconnected. To solve this, one of the tables must be deleted (as the cookies differ, it is regarded to be two different tables even if they have the same name).</p> <p>Merging different versions of the schema table does not always require the cookies to be the same. If the storage type of the schema table is <code>disc_copies</code>, the cookie is immutable, and all other <code>db_nodes</code> must have the same cookie. When the schema is stored as type <code>ram_copies</code>, its cookie can be replaced with a cookie from another node (<code>ram_copies</code> or <code>disc_copies</code>). The cookie replacement (during merge of the schema table definition) is performed each time a RAM node connects to another node.</p> <p>Further, the following applies:</p> <ul> <li> <code><a href="mnesia.html#system_info-1">mnesia:system_info(schema_location)</a></code> and <code><a href="mnesia.html#system_info-1">mnesia:system_info(extra_db_nodes)</a></code> can be used to determine the actual values of <code>schema_location</code> and <code>extra_db_nodes</code>, respectively. </li> <li> <code><a href="mnesia.html#system_info-1">mnesia:system_info(use_dir)</a></code> can be used to determine whether <code>Mnesia</code> is actually using the <code>Mnesia</code> directory. </li> <li> <code>use_dir</code> can be determined even before <code>Mnesia</code> is started. </li> </ul> <p>The function <code><a href="mnesia.html#info-0">mnesia:info/0</a></code> can now be used to print some system information even before <code>Mnesia</code> is started. When <code>Mnesia</code> is started, the function prints more information.</p> <p>Transactions that update the definition of a table requires that <code>Mnesia</code> is started on all nodes where the storage type of the schema is <code>disc_copies</code>. All replicas of the table on these nodes must also be loaded. There are a few exceptions to these availability rules:</p> <ul> <li>Tables can be created and new replicas can be added without starting all the disc-full nodes. </li> <li>New replicas can be added before all other replicas of the table have been loaded, provided that at least one other replica is active. </li> </ul> <h2 id="mnesia-event-handling" class="title-link"> <div class="title-name">6.7 Mnesia Event Handling</div>  </h2> <p>System events and table events are the two event categories that <code>Mnesia</code> generates in various situations.</p> <p>A user process can subscribe on the events generated by <code>Mnesia</code>. The following two functions are provided:</p> <dl> <dt class="title-link"><strong><code><a href="mnesia.html#subscribe-1">mnesia:subscribe(Event-Category)</a></code> </strong></dt> <dd>Ensures that a copy of all events of type <code>Event-Category</code> are sent to the calling process</dd> <dt class="title-link"><strong><code><a href="mnesia.html#unsubscribe-1">mnesia:unsubscribe(Event-Category)</a></code> </strong></dt> <dd>Removes the subscription on events of type <code>Event-Category</code> </dd> </dl> <p><code>Event-Category</code> can be either of the following:</p> <ul> <li>The atom <code>system</code> </li> <li>The atom <code>activity</code> </li> <li>The tuple <code>{table, Tab, simple}</code> </li> <li>The tuple <code>{table, Tab, detailed}</code> </li> </ul> <p>The old event category <code>{table, Tab}</code> is the same event category as <code>{table, Tab, simple}</code>.</p> <p>The subscribe functions activate a subscription of events. The events are delivered as messages to the process evaluating the function <code><a href="mnesia.html#subscribe-1">mnesia:subscribe/1</a></code> The syntax is as follows:</p> <ul> <li> <code>{mnesia_system_event, Event}</code> for system events </li> <li> <code>{mnesia_activity_event, Event}</code> for activity events </li> <li> <code>{mnesia_table_event, Event}</code> for table events </li> </ul> <p>The event types are described in the next sections.</p> <p>All system events are subscribed by the <code>Mnesia</code> <code>gen_event</code> handler. The default <code>gen_event</code> handler is <code>mnesia_event</code>, but it can be changed by using application parameter <code>event_module</code>. The value of this parameter must be the name of a module implementing a complete handler, as specified by the <code>gen_event</code> module in <code>STDLIB</code>.</p> <p><code><a href="mnesia.html#system_info-1">mnesia:system_info(subscribers)</a></code> and <code><a href="mnesia.html#table_info-2">mnesia:table_info(Tab, subscribers)</a></code> can be used to determine which processes are subscribed to various events.</p> <h3 id="system-events" class="title-link"> <div class="title-name">System Events</div>  </h3> <p>The system events are as follows:</p> <dl> <dt class="title-link"><strong><code>{mnesia_up, Node}</code></strong></dt> <dd>Mnesia is started on a node. <code>Node</code> is the node name. By default this event is ignored. </dd> <dt class="title-link"><strong><code>{mnesia_down, Node}</code></strong></dt> <dd>Mnesia is stopped on a node. <code>Node</code> is the node name. By default this event is ignored. </dd> <dt class="title-link"><strong><code>{mnesia_checkpoint_activated, Checkpoint}</code></strong></dt> <dd>A checkpoint with the name <code>Checkpoint</code> is activated and the current node is involved in the checkpoint. Checkpoints can be activated explicitly with the function <code><a href="mnesia.html#activate_checkpoint-1">mnesia:activate_checkpoint/1</a></code> or implicitly at backup, when adding table replicas, at internal transfer of data between nodes, and so on. By default this event is ignored. </dd> <dt class="title-link"><strong><code>{mnesia_checkpoint_deactivated, Checkpoint}</code></strong></dt> <dd>A checkpoint with the name <code>Checkpoint</code> is deactivated and the current node is involved in the checkpoint. Checkpoints can be deactivated explicitly with the function <code><a href="mnesia.html#deactivate_checkpoint-1">mnesia:deactivate/1</a></code> or implicitly when the last replica of a table (involved in the checkpoint) becomes unavailable, for example, at node-down. By default this event is ignored. </dd> <dt class="title-link"><strong><code>{mnesia_overload, Details}</code></strong></dt> <dd> <p><code>Mnesia</code> on the current node is overloaded and the subscriber is to take action.</p> <p>A typical overload situation occurs when the applications perform more updates on disc resident tables than <code>Mnesia</code> can handle. Ignoring this kind of overload can lead to a situation where the disc space is exhausted (regardless of the size of the tables stored on disc).</p> <p>Each update is appended to the transaction log and occasionally (depending on how it is configured) dumped to the tables files. The table file storage is more compact than the transaction log storage, especially if the same record is updated repeatedly. If the thresholds for dumping the transaction log are reached before the previous dump is finished, an overload event is triggered.</p> <p>Another typical overload situation is when the transaction manager cannot commit transactions at the same pace as the applications perform updates of disc resident tables. When this occurs, the message queue of the transaction manager continues to grow until the memory is exhausted or the load decreases.</p> <p>The same problem can occur for dirty updates. The overload is detected locally on the current node, but its cause can be on another node. Application processes can cause high load if any table resides on another node (replicated or not). By default this event is reported to <code>error_logger.</code></p> </dd> <dt class="title-link"><strong><code>{inconsistent_database, Context, Node}</code></strong></dt> <dd> <code>Mnesia</code> regards the database as potential inconsistent and gives its applications a chance to recover from the inconsistency. For example, by installing a consistent backup as fallback and then restart the system. An alternative is to pick a <code>MasterNode</code> from <code><a href="mnesia.html#system_info-1">mnesia:system_info(db_nodes)</a></code> and invoke <code><a href="mnesia.html#set_master_nodes-1">mnesia:set_master_node([MasterNode])</a></code>. By default an error is reported to <code>error_logger</code>. </dd> <dt class="title-link"><strong><code>{mnesia_fatal, Format, Args, BinaryCore}</code></strong></dt> <dd> <p><code>Mnesia</code> detected a fatal error and terminates soon. The fault reason is explained in <code>Format</code> and <code>Args</code>, which can be given as input to <code>io:format/2</code> or sent to <code>error_logger</code>. By default it is sent to <code>error_logger</code>.</p> <p><code>BinaryCore</code> is a binary containing a summary of the <code>Mnesia</code> internal state at the time when the fatal error was detected. By default the binary is written to a unique filename on the current directory. On RAM nodes, the core is ignored.</p> </dd> <dt class="title-link"><strong><code>{mnesia_info, Format, Args}</code></strong></dt> <dd> <code>Mnesia</code> detected something that can be of interest when debugging the system. This is explained in <code>Format</code> and <code>Args</code>, which can appear as input to <code>io:format/2</code> or sent to <code>error_logger</code>. By default this event is printed with <code>io:format/2</code>. </dd> <dt class="title-link"><strong><code>{mnesia_error, Format, Args}</code></strong></dt> <dd> <code>Mnesia</code> has detected an error. The fault reason is explained in <code>Format</code> and <code>Args</code>, which can be given as input to <code>io:format/2</code> or sent to <code>error_logger</code>. By default this event is reported to <code>error_logger</code>. </dd> <dt class="title-link"><strong><code>{mnesia_user, Event}</code></strong></dt> <dd>An application started the function <code><a href="mnesia.html#report_event-1">mnesia:report_event(Event)</a></code>. <code>Event</code> can be any Erlang data structure. When tracing a system of <code>Mnesia</code> applications, it is useful to be able to interleave own events of <code>Mnesia</code> with application-related events that give information about the application context. Whenever the application starts with a new and demanding <code>Mnesia</code> activity, or enters a new and interesting phase in its execution, it can be a good idea to use <code>mnesia:report_event/1</code>. </dd> </dl> <h3 id="activity-events" class="title-link"> <div class="title-name">Activity Events</div>  </h3> <p>Currently, there is only one type of activity event:</p> <dl> <dt class="title-link"><strong><code>{complete, ActivityID}</code></strong></dt> <dd> <p>This event occurs when a transaction that caused a modification to the database is completed. It is useful for determining when a set of table events (see the next section), caused by a given activity, have been sent. Once this event is received, it is guaranteed that no further table events with the same <code>ActivityID</code> will be received. Notice that this event can still be received even if no table events with a corresponding <code>ActivityID</code> were received, depending on the tables to which the receiving process is subscribed.</p> <p>Dirty operations always contain only one update and thus no activity event is sent.</p> </dd> </dl> <h3 id="table-events" class="title-link"> <div class="title-name">Table Events</div>  </h3> <p>Table events are events related to table updates. There are two types of table events, simple and detailed.</p> <p>The <strong>simple table events</strong> are tuples like <code>{Oper, Record, ActivityId}</code>, where:</p> <ul> <li> <code>Oper</code> is the operation performed. </li> <li> <code>Record</code> is the record involved in the operation. </li> <li> <code>ActivityId</code> is the identity of the transaction performing the operation. </li> </ul> <p>Notice that the record name is the table name even when <code>record_name</code> has another setting.</p> <p>The table-related events that can occur are as follows:</p> <dl> <dt class="title-link"><strong><code>{write, NewRecord, ActivityId}</code></strong></dt> <dd>A new record has been written. <code>NewRecord</code> contains the new record value. </dd> <dt class="title-link"><strong><code>{delete_object, OldRecord, ActivityId}</code></strong></dt> <dd>A record has possibly been deleted with <code><a href="mnesia.html#delete_object-1">mnesia:delete_object/1</a></code>. <code>OldRecord</code> contains the value of the old record, as stated as argument by the application. Notice that other records with the same key can remain in the table if it is of type <code>bag</code>. </dd> <dt class="title-link"><strong><code>{delete, {Tab, Key}, ActivityId}</code></strong></dt> <dd>One or more records have possibly been deleted. All records with the key <code>Key</code> in the table <code>Tab</code> have been deleted. </dd> </dl> <p>The <strong>detailed table events</strong> are tuples like <code>{Oper, Table, Data, [OldRecs], ActivityId}</code>, where:</p> <ul> <li> <code>Oper</code> is the operation performed. </li> <li> <code>Table</code> is the table involved in the operation. </li> <li> <code>Data</code> is the record/OID written/deleted. </li> <li> <code>OldRecs</code> is the contents before the operation. </li> <li> <code>ActivityId</code> is the identity of the transaction performing the operation. </li> </ul> <p>The table-related events that can occur are as follows:</p> <dl> <dt class="title-link"><strong><code>{write, Table, NewRecord, [OldRecords], ActivityId}</code></strong></dt> <dd>A new record has been written. <code>NewRecord</code> contains the new record value and <code>OldRecords</code> contains the records before the operation is performed. Notice that the new content depends on the table type. </dd> <dt class="title-link"><strong><code>{delete, Table, What, [OldRecords], ActivityId}</code></strong></dt> <dd>Records have possibly been deleted. <code>What</code> is either <code>{Table, Key}</code> or a record <code>{RecordName, Key, ...}</code> that was deleted. Notice that the new content depends on the table type. </dd> </dl> <h2 id="debugging-mnesia-applications" class="title-link"> <div class="title-name">6.8 Debugging Mnesia Applications</div>  </h2> <p>Debugging a <code>Mnesia</code> application can be difficult for various reasons, primarily related to difficulties in understanding how the transaction and table load mechanisms work. Another source of confusion can be the semantics of nested transactions.</p> <p>The debug level of <code>Mnesia</code> is set by calling the function <code><a href="mnesia.html#set_debug_level-1">mnesia:set_debug_level(Level)</a></code>, where <code>Level</code>is one of the following:</p> <dl> <dt class="title-link"><strong><code>none</code></strong></dt> <dd>No trace outputs. This is the default. </dd> <dt class="title-link"><strong><code>verbose</code></strong></dt> <dd>Activates tracing of important debug events. These events generate <code>{mnesia_info, Format, Args}</code> system events. Processes can subscribe to these events with the function <code><a href="mnesia.html#subscribe-1">mnesia:subscribe/1</a></code>. The events are always sent to the <code>Mnesia</code> event handler. </dd> <dt class="title-link"><strong><code>debug</code></strong></dt> <dd>Activates all events at the verbose level plus traces of all debug events. These debug events generate <code>{mnesia_info, Format, Args}</code> system events. Processes can subscribe to these events with <code>mnesia:subscribe/1</code>. The events are always sent to the <code>Mnesia</code> event handler. On this debug level, the <code>Mnesia</code> event handler starts subscribing to updates in the schema table. </dd> <dt class="title-link"><strong><code>trace</code></strong></dt> <dd>Activates all events at the debug level. On this level, the <code>Mnesia</code> event handler starts subscribing to updates on all <code>Mnesia</code> tables. This level is intended only for debugging small toy systems, as many large events can be generated. </dd> <dt class="title-link"><strong><code>false</code></strong></dt> <dd>An alias for none. </dd> <dt class="title-link"><strong><code>true</code></strong></dt> <dd>An alias for debug. </dd> </dl> <p>The debug level of <code>Mnesia</code> itself is also an application parameter, making it possible to start an Erlang system to turn on <code>Mnesia</code> debug in the initial startup phase by using the following code:</p> <pre data-language="erlang">
% erl -mnesia debug verbose</pre> <h2 id="concurrent-processes-in-mnesia" class="title-link"> <div class="title-name">6.9 Concurrent Processes in Mnesia</div>  </h2> <p>Programming concurrent Erlang systems is the subject of a separate book. However, it is worthwhile to draw attention to the following features, which permit concurrent processes to exist in a <code>Mnesia</code> system:</p> <ul> <li> <p>A group of functions or processes can be called within a transaction. A transaction can include statements that read, write, or delete data from the DBMS. Many such transactions can run concurrently, and the programmer does not need to explicitly synchronize the processes that manipulate the data.</p> <p>All programs accessing the database through the transaction system can be written as if they had sole access to the data. This is a desirable property, as all synchronization is taken care of by the transaction handler. If a program reads or writes data, the system ensures that no other program tries to manipulate the same data at the same time.</p> </li> <li>Tables can be moved or deleted, and the layout of a table can be reconfigured in various ways. An important aspect of the implementation of these functions is that user programs can continue to use a table while it is being reconfigured. For example, it is possible to move a table and perform write operations to the table at the same time. This is important for many applications that require continuously available services. For more information, see <code><a href="mnesia_chap4.html#trans_prop">Transactions and Other Access Contexts</a></code>. </li> </ul> <h2 id="prototyping" class="title-link"> <div class="title-name">6.10 Prototyping</div>  </h2> <p>If and when you would like to start and manipulate <code>Mnesia</code>, it is often easier to write the definitions and data into an ordinary text file. Initially, no tables and no data exist, or which tables are required. At the initial stages of prototyping, it is prudent to write all data into one file, process that file, and have the data in the file inserted into the database. <code>Mnesia</code> can be initialized with data read from a text file. The following two functions can be used to work with text files.</p> <ul> <li> <code><a href="mnesia.html#load_textfile-1">mnesia:load_textfile(Filename)</a></code> loads a series of local table definitions and data found in the file into <code>Mnesia</code>. This function also starts <code>Mnesia</code> and possibly creates a new schema. The function operates on the local node only. </li> <li> <code><a href="mnesia.html#dump_to_textfile-1">mnesia:dump_to_textfile(Filename)</a></code> dumps all local tables of a <code>Mnesia</code> system into a text file, which can be edited (with a normal text editor) and later reloaded. </li> </ul> <p>These functions are much slower than the ordinary store and load functions of <code>Mnesia</code>. However, this is mainly intended for minor experiments and initial prototyping. The major advantage of these functions is that they are easy to use.</p> <p>The format of the text file is as follows:</p> <pre data-language="erlang">
{tables, [{Typename, [Options]},
{Typename2 ......}]}.

{Typename, Attribute1, Attribute2 ....}.
{Typename, Attribute1, Attribute2 ....}.</pre> <p><code>Options</code> is a list of <code>{Key,Value}</code> tuples conforming to the options that you can give to <code><a href="mnesia.html#create_table-2">mnesia:create_table/2</a></code>. </p> <p>For example, to start playing with a small database for healthy foods, enter the following data into file <code>FRUITS</code>:</p> <pre data-language="erlang">{tables,
 [{fruit, [{attributes, [name, color, taste]}]},
  {vegetable, [{attributes, [name, color, taste, price]}]}]}.


{fruit, orange, orange, sweet}.
{fruit, apple, green, sweet}.
{vegetable, carrot, orange, carrotish, 2.55}.
{vegetable, potato, yellow, none, 0.45}.</pre> <p>The following session with the Erlang shell shows how to load the <code>FRUITS</code> database:</p> <pre data-language="erlang">
% erl
Erlang (BEAM) emulator version 4.9
 
Eshell V4.9  (abort with ^G)
1&gt; mnesia:load_textfile("FRUITS").
New table fruit
New table vegetable
{atomic,ok}
2&gt; mnesia:info().
---&gt; Processes holding locks &lt;--- 
---&gt; Processes waiting for locks &lt;--- 
---&gt; Pending (remote) transactions &lt;--- 
---&gt; Active (local) transactions &lt;---
---&gt; Uncertain transactions &lt;--- 
---&gt; Active tables &lt;--- 
vegetable      : with 2 records occuping 299 words of mem 
fruit          : with 2 records occuping 291 words of mem 
schema         : with 3 records occuping 401 words of mem 
===&gt; System info in version "1.1", debug level = none &lt;===
opt_disc. Directory "/var/tmp/Mnesia.nonode@nohost" is used.
use fallback at restart = false
running db nodes = [nonode@nohost]
stopped db nodes = [] 
remote           = []
ram_copies       = [fruit,vegetable]
disc_copies      = [schema]
disc_only_copies = []
[{nonode@nohost,disc_copies}] = [schema]
[{nonode@nohost,ram_copies}] = [fruit,vegetable]
3 transactions committed, 0 aborted, 0 restarted, 2 logged to disc
0 held locks, 0 in queue; 0 local transactions, 0 remote
0 transactions waits for other nodes: []
ok
3&gt; 
    </pre> <p>It can be seen that the DBMS was initiated from a regular text file.</p> <h2 id="object-based-programming-with-mnesia" class="title-link"> <div class="title-name">6.11 Object-Based Programming with Mnesia</div>  </h2> <p>The <code>Company</code> database, introduced in <code><a href="mnesia_chap2.html#getting_started">Getting Started</a></code>, has three tables that store records (<code>employee</code>, <code>dept</code>, <code>project</code>), and three tables that store relationships (<code>manager</code>, <code>at_dep</code>, <code>in_proj</code>). This is a normalized data model, which has some advantages over a non-normalized data model.</p> <p>It is more efficient to do a generalized search in a normalized database. Some operations are also easier to perform on a normalized data model. For example, one project can easily be removed, as the following example illustrates:</p> <pre data-language="erlang">remove_proj(ProjName) -&gt;
    F = fun() -&gt;
                Ip = qlc:e(qlc:q([X || X &lt;- mnesia:table(in_proj),
				       X#in_proj.proj_name == ProjName]
				)),
                mnesia:delete({project, ProjName}),
                del_in_projs(Ip)
        end,
    mnesia:transaction(F).

del_in_projs([Ip|Tail]) -&gt;
    mnesia:delete_object(Ip),
    del_in_projs(Tail);
del_in_projs([]) -&gt;
    done.</pre> <p>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. <code>Mnesia</code> is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A <code>Mnesia</code> database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets <code>Mnesia</code> apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</p> <p>Many telecommunications applications have unique requirements on lookup times for certain types of records. If the <code>Company</code> database had been a part of a telecommunications system, it could be to minimize the lookup time of an employee <strong>together</strong> with a list of the projects the employee is working on. If this is the case, a drastically different data model without direct relationships can be chosen. You would then have only the records themselves, and different records could contain either direct references to other records, or contain other records that are not part of the <code>Mnesia</code> schema.</p> <p>The following record definitions can be created:</p> <pre data-language="erlang">-record(employee, {emp_no,
		   name,
		   salary,
		   sex,
		   phone,
		   room_no,
		   dept,
		   projects,
		   manager}).
		   

-record(dept, {id, 
               name}).

-record(project, {name,
                  number,
                  location}).</pre> <p>A record that describes an employee can look as follows:</p> <pre data-language="erlang">
Me = #employee{emp_no= 104732,
name = klacke,
salary = 7,
sex = male,
phone = 99586,
room_no = {221, 015},
dept = 'B/SFR',
projects = [erlang, mnesia, otp],
manager = 114872},</pre> <p>This model has only three different tables, and the employee records contain references to other records. The record has the following references:</p> <ul> <li> <code>'B/SFR'</code> refers to a <code>dept</code> record. </li> <li> <code>[erlang, mnesia, otp]</code> is a list of three direct references to three different <code>projects</code> records. </li> <li> <code>114872</code> refers to another employee record. </li> </ul> <p>The <code>Mnesia</code> record identifiers (<code>{Tab, Key}</code>) can also be used as references. In this case, attribute <code>dept</code> would be set to value <code>{dept, 'B/SFR'}</code> instead of <code>'B/SFR'</code>.</p> <p>With this data model, some operations execute considerably faster than they do with the normalized data model in the <code>Company</code> database. However, some other operations become much more complicated. In particular, it becomes more difficult to ensure that records do not contain dangling pointers to other non-existent, or deleted, records.</p> <p>The following code exemplifies a search with a non-normalized data model. To find all employees at department <code>Dep</code> with a salary higher than <code>Salary</code>, use the following code:</p> <pre data-language="erlang">get_emps(Salary, Dep) -&gt;
    Q = qlc:q( 
          [E || E &lt;- mnesia:table(employee),
                E#employee.salary &gt; Salary,
                E#employee.dept == Dep]
	 ),
    F = fun() -&gt; qlc:e(Q) end,
    transaction(F).</pre> <p>This code is easier to write and to understand, and it also executes much faster.</p> <p>It is easy to show examples of code that executes faster if a non-normalized data model is used, instead of a normalized model. The main reason is that fewer tables are required. Therefore, data from different tables can more easily be combined in join operations. In the previous example, the function <code>get_emps/2</code> is transformed from a join operation into a simple query, which consists of a selection and a projection on one single table.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
