<div class="innertube"> <h1 id="Build a Mnesia Database">4 Build a Mnesia Database</h1> <p>This section describes the basic steps when designing a <code>Mnesia</code> database and the programming constructs that make different solutions available to the programmer. The following topics are included:</p> <ul> <li>Define a schema</li> <li>Data model</li> <li>Start <code>Mnesia</code> </li> <li>Create tables</li> </ul> <h2 id="define-a-schema" class="title-link"> <div class="title-name">4.1 Define a Schema</div>  </h2> <p>The configuration of a <code>Mnesia</code> system is described in a schema. The schema is a special table that includes information such as the table names and the storage type of each table (that is, whether a table is to be stored in RAM, on disc, or on both, as well as its location).</p> <p>Unlike data tables, information in schema tables can only be accessed and modified by using the schema-related functions described in this section.</p> <p><code>Mnesia</code> has various functions for defining the database schema. Tables can be moved or deleted, and the table layout can be reconfigured.</p> <p>An important aspect of these functions is that the system can access a table while it is being reconfigured. For example, it is possible to move a table and simultaneously perform write operations to the same table. This feature is essential for applications that require continuous service.</p> <p>This section describes the functions available for schema management, all which return either of the following tuples:</p> <ul> <li> <code>{atomic, ok}</code> if successful</li> <li> <code>{aborted, Reason}</code> if unsuccessful</li> </ul> <h3 id="schema-functions" class="title-link"> <div class="title-name">Schema Functions</div>  </h3> <p>The schema functions are as follows:</p> <ul> <li> <code><a href="mnesia.html#create_schema-1">mnesia:create_schema(NodeList)</a></code> initializes a new, empty schema. This is a mandatory requirement before <code>Mnesia</code> can be started. <code>Mnesia</code> is a truly distributed DBMS and the schema is a system table that is replicated on all nodes in a <code>Mnesia</code> system. This function fails if a schema is already present on any of the nodes in <code>NodeList</code>. The function requires <code>Mnesia</code> to be stopped on the all <code>db_nodes</code> contained in parameter <code>NodeList</code>. Applications call this function only once, as it is usually a one-time activity to initialize a new database. </li> <li> <code><a href="mnesia.html#delete_schema-1">mnesia:delete_schema(DiscNodeList)</a></code> erases any old schemas on the nodes in <code>DiscNodeList</code>. It also removes all old tables together with all data. This function requires <code>Mnesia</code> to be stopped on all <code>db_nodes</code>. </li> <li> <code><a href="mnesia.html#delete_table-1">mnesia:delete_table(Tab)</a></code> permanently deletes all replicas of table <code>Tab</code>. </li> <li> <code><a href="mnesia.html#clear_table-1">mnesia:clear_table(Tab)</a></code> permanently deletes all entries in table <code>Tab</code>. </li> <li> <code><a href="mnesia.html#move_table_copy-3">mnesia:move_table_copy(Tab, From, To)</a></code> moves the copy of table <code>Tab</code> from node <code>From</code> to node <code>To</code>. The table storage type <code>{type}</code> is preserved, so if a RAM table is moved from one node to another, it remains a RAM table on the new node. Other transactions can still perform read and write operation to the table while it is being moved. </li> <li> <code><a href="mnesia.html#add_table_copy-3">mnesia:add_table_copy(Tab, Node, Type)</a></code> creates a replica of table <code>Tab</code> at node <code>Node</code>. Argument <code>Type</code> must be either of the atoms <code>ram_copies</code>, <code>disc_copies</code>, or <code>disc_only_copies</code>. If you add a copy of the system table <code>schema</code> to a node, you want the <code>Mnesia</code> schema to reside there as well. This action extends the set of nodes that comprise this particular <code>Mnesia</code> system. </li> <li> <code><a href="mnesia.html#del_table_copy-2">mnesia:del_table_copy(Tab, Node)</a></code> deletes the replica of table <code>Tab</code> at node <code>Node</code>. When the last replica of a table is removed, the table is deleted. </li> <li> <p><code><a href="mnesia.html#transform_table-4">mnesia:transform_table(Tab, Fun, NewAttributeList, NewRecordName)</a></code> changes the format on all records in table <code>Tab</code>. It applies argument <code>Fun</code> to all records in the table. <code>Fun</code> must be a function that takes a record of the old type, and returns the record of the new type. The table key must not be changed.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">-record(old, {key, val}).
-record(new, {key, val, extra}).

Transformer =
   fun(X) when record(X, old) -&gt;
      #new{key = X#old.key,
           val = X#old.val,
           extra = 42}
   end,
{atomic, ok} = mnesia:transform_table(foo, Transformer,
                                      record_info(fields, new),
                                      new),</pre> <p>Argument <code>Fun</code> can also be the atom <code>ignore</code>, which indicates that only the metadata about the table is updated. Use of <code>ignore</code> is not recommended (as it creates inconsistencies between the metadata and the actual data) but it is included as a possibility for the user do to an own (offline) transform.</p> </li> <li> <code>change_table_copy_type(Tab, Node, ToType)</code> changes the storage type of a table. For example, a RAM table is changed to a <code>disc_table</code> at the node specified as <code>Node</code>.</li> </ul> <h2 id="data-model" class="title-link"> <div class="title-name">4.2 Data Model</div>  </h2> <p>The data model employed by <code>Mnesia</code> is an extended relational data model. Data is organized as a set of tables and relations between different data records can be modeled as more tables describing the relationships. Each table contains instances of Erlang records. The records are represented as Erlang tuples.</p> <p>Each Object Identifier (OID) is made up of a table name and a key. For example, if an employee record is represented by the tuple <code>{employee, 104732, klacke, 7, male, 98108, {221, 015}}</code>, this record has an OID, which is the tuple <code>{employee, 104732}</code>.</p> <p>Thus, each table is made up of records, where the first element is a record name and the second element of the table is a key, which identifies the particular record in that table. The combination of the table name and a key is an arity two tuple <code>{Tab, Key}</code> called the OID. For more information about the relationship between the record name and the table name, see <code><a href="mnesia_chap4.html#recordnames_tablenames">Record Names versus Table Names</a></code>. </p> <p>What makes the <code>Mnesia</code> data model an extended relational model is the ability to store arbitrary Erlang terms in the attribute fields. One attribute value can, for example, be a whole tree of OIDs leading to other terms in other tables. This type of record is difficult to model in traditional relational DBMSs.</p> <h2 id="start-mnesia" class="title-link"> <div class="title-name">4.3 Start Mnesia</div>  </h2> <p>Before starting <code>Mnesia</code>, the following must be done: </p> <ul> <li>An empty schema must be initialized on all the participating nodes.</li> <li>The Erlang system must be started.</li> <li>Nodes with disc database schema must be defined and implemented with the function <code><a href="mnesia.html#create_schema-1">mnesia:create_schema(NodeList)</a></code>.</li> </ul> <p>When running a distributed system with two or more participating nodes, the function <code><a href="mnesia.html#start-0">mnesia:start()</a></code> must be executed on each participating node. This would typically be part of the boot script in an embedded environment. In a test environment or an interactive environment, <code>mnesia:start()</code> can also be used either from the Erlang shell or another program. </p> <h3 id="initialize-a-schema-and-start-mnesia" class="title-link"> <div class="title-name">Initialize a Schema and Start Mnesia</div>  </h3> <p>Let us use the example database <code>Company</code>, described in <code><a href="mnesia_chap2.html#getting_started">Getting Started</a></code> to illustrate how to run a database on two separate nodes, called <code>a@gin</code> and <code>b@skeppet</code>. Each of these nodes must have a <code>Mnesia</code> directory and an initialized schema before <code>Mnesia</code> can be started. There are two ways to specify the <code>Mnesia</code> directory to be used:</p> <ul> <li> <p>Specify the <code>Mnesia</code> directory by providing an application parameter either when starting the Erlang shell or in the application script. Previously, the following example was used to create the directory for the <code>Company</code> database:</p> <pre data-language="erlang">
%<code>erl -mnesia dir '"/ldisc/scratch/Mnesia.Company"'</code>
          </pre> </li> <li>If no command-line flag is entered, the <code>Mnesia</code> directory becomes the current working directory on the node where the Erlang shell is started.</li> </ul> <p>To start the <code>Company</code> database and get it running on the two specified nodes, enter the following commands:</p> <ol> <li> <p>On the node <code>a@gin</code>:</p> <pre data-language="erlang">
gin %<code>erl -sname a -mnesia dir '"/ldisc/scratch/Mnesia.company"'</code></pre> </li> <li> <p>On the node <code>b@skeppet</code>:</p> <pre data-language="erlang">
skeppet %<code>erl -sname b -mnesia dir '"/ldisc/scratch/Mnesia.company"'</code></pre> </li> <li> <p>On one of the two nodes:</p> <pre data-language="erlang">
(a@gin)1&gt;<code>mnesia:create_schema([a@gin, b@skeppet]).</code></pre> </li> <li>The function <code><a href="mnesia.html#start-0">mnesia:start()</a></code> is called on both nodes. </li> <li> <p>To initialize the database, execute the following code on one of the two nodes:</p> <pre data-language="erlang">dist_init() -&gt;
    mnesia:create_table(employee,
                         [{ram_copies, [a@gin, b@skeppet]},
                          {attributes, record_info(fields,
						   employee)}]),
    mnesia:create_table(dept,
                         [{ram_copies, [a@gin, b@skeppet]},
                          {attributes, record_info(fields, dept)}]),
    mnesia:create_table(project,
                         [{ram_copies, [a@gin, b@skeppet]},
                          {attributes, record_info(fields, project)}]),
    mnesia:create_table(manager, [{type, bag}, 
                                  {ram_copies, [a@gin, b@skeppet]},
                                  {attributes, record_info(fields,
							   manager)}]),
    mnesia:create_table(at_dep,
                         [{ram_copies, [a@gin, b@skeppet]},
                          {attributes, record_info(fields, at_dep)}]),
    mnesia:create_table(in_proj,
                        [{type, bag}, 
                         {ram_copies, [a@gin, b@skeppet]},
                         {attributes, record_info(fields, in_proj)}]).</pre> </li> </ol> <p>As illustrated, the two directories reside on different nodes, because <code>/ldisc/scratch</code> (the "local" disc) exists on the two different nodes.</p> <p>By executing these commands, two Erlang nodes are configured to run the <code>Company</code> database, and therefore, initialize the database. This is required only once when setting up. The next time the system is started, <code><a href="mnesia.html#start-0">mnesia:start()</a></code> is called on both nodes, to initialize the system from disc.</p> <p>In a system of <code>Mnesia</code> nodes, every node is aware of the current location of all tables. In this example, data is replicated on both nodes and functions that manipulate the data in the tables can be executed on either of the two nodes. Code that manipulate <code>Mnesia</code> data behaves identically regardless of where the data resides.</p> <p>The function <code><a href="mnesia.html#stop-0">mnesia:stop()</a></code> stops <code>Mnesia</code> on the node where the function is executed. The functions <code>mnesia:start/0</code> and <code>mnesia:stop/0</code> work on the "local" <code>Mnesia</code> system. No functions start or stop a set of nodes.</p> <h3 id="startup-procedure" class="title-link"> <div class="title-name">Startup Procedure</div>  </h3> <p>Start <code>Mnesia</code> by calling the following function:</p> <pre data-language="erlang">mnesia:start().</pre> <p>This function initiates the DBMS locally.</p> <p>The choice of configuration alters the location and load order of the tables. The alternatives are as follows:</p> <ol> <li>Tables that are only stored locally are initialized from the local <code>Mnesia</code> directory. </li> <li>Replicated tables that reside locally as well as somewhere else are either initiated from disc or by copying the entire table from the other node, depending on which of the different replicas are the most recent. <code>Mnesia</code> determines which of the tables are the most recent. </li> <li>Tables that reside on remote nodes are available to other nodes as soon as they are loaded.</li> </ol> <p>Table initialization is asynchronous. The function call <code><a href="mnesia.html#start-0">mnesia:start()</a></code> returns the atom <code>ok</code> and then starts to initialize the different tables. Depending on the size of the database, this can take some time, and the application programmer must wait for the tables that the application needs before they can be used. This is achieved by using the function <code><a href="mnesia.html#wait_for_tables-2">mnesia:wait_for_tables(TabList, Timeout)</a></code>, which suspends the caller until all tables specified in <code>TabList</code> are properly initiated.</p> <p>A problem can arise if a replicated table on one node is initiated, but <code>Mnesia</code> deduces that another (remote) replica is more recent than the replica existing on the local node, and the initialization procedure does not proceed. In this situation, a call to <code><a href="mnesia.html#wait_for_tables-2">mnesia:wait_for_tables/2</a></code>, suspends the caller until the remote node has initialized the table from its local disc and the node has copied the table over the network to the local node.</p> <p>However, this procedure can be time-consuming, the shortcut function <code><a href="mnesia.html#force_load_table-1">mnesia:force_load_table(Tab)</a></code> loads all the tables from disc at a faster rate. The function forces tables to be loaded from disc regardless of the network situation.</p> <p>Thus, it can be assumed that if an application wants to use tables <code>a</code> and <code>b</code>, the application must perform some action similar to following before it can use the tables:</p> <pre data-language="erlang">
case mnesia:wait_for_tables([a, b], 20000) of
  {timeout,   RemainingTabs} -&gt;
    panic(RemainingTabs);
  ok -&gt;
    synced
end.</pre> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>When tables are forcefully loaded from the local disc, all operations that were performed on the replicated table while the local node was down, and the remote replica was alive, are lost. This can cause the database to become inconsistent.</p> </div> </div> <p>If the startup procedure fails, the function <code><a href="mnesia.html#start-0">mnesia:start()</a></code> returns the cryptic tuple <code>{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}</code>. To get more information about the start failure, use command-line arguments <code>-boot start_sasl</code> as argument to the <code>erl</code> script.</p> <h2 id="create-tables" class="title-link"> <div class="title-name">4.4 Create Tables</div>  </h2> <p>The function <code><a href="mnesia.html#create_table-2">mnesia:create_table(Name, ArgList)</a></code> creates tables. When executing this function, it returns one of the following responses:</p> <ul> <li> <code>{atomic, ok}</code> if the function executes successfully </li> <li> <code>{aborted, Reason}</code> if the function fails </li> </ul> <p>The function arguments are as follows:</p> <ul> <li> <code>Name</code> is the name of the table. It is usually the same name as the name of the records that constitute the table. For details, see <code>record_name</code>. </li> <li> <p><code>ArgList</code> is a list of <code>{Key,Value}</code> tuples. The following arguments are valid:</p> <ul> <li> <p><code>{type, Type}</code>, where <code>Type</code> must be either of the atoms <code>set</code>, <code>ordered_set</code>, or <code>bag</code>. Default is <code>set</code>.</p> <p>Notice that currently <code>ordered_set</code> is not supported for <code>disc_only_copies</code> tables.</p> <p>A table of type <code>set</code> or <code>ordered_set</code> has either zero or one record per key, whereas a table of type <code>bag</code> can have an arbitrary number of records per key. The key for each record is always the first attribute of the record.</p> <p>The following example illustrates the difference between type <code>set</code> and <code>bag</code>:</p> <pre data-language="erlang">
f() -&gt;
   F = fun() -&gt;
         mnesia:write({foo, 1, 2}),
         mnesia:write({foo, 1, 3}),
         mnesia:read({foo, 1})
       end,
   mnesia:transaction(F).</pre> <p>This transaction returns the list <code>[{foo,1,3}]</code> if table <code>foo</code> is of type <code>set</code>. However, the list <code>[{foo,1,2}, {foo,1,3}]</code> is returned if the table is of type <code>bag</code>.</p> <p><code>Mnesia</code> tables can never contain duplicates of the same record in the same table. Duplicate records have attributes with the same contents and key.</p> </li> <li> <p><code>{disc_copies, NodeList}</code>, where <code>NodeList</code> is a list of the nodes where this table is to reside on disc.</p> <p>Write operations to a table replica of type <code>disc_copies</code> write data to the disc copy and to the RAM copy of the table.</p> <p>It is possible to have a replicated table of type <code>disc_copies</code> on one node, and the same table stored as a different type on another node. Default is <code>[]</code>. This arrangement is desirable if the following operational characteristics are required:</p> <ol> <li>Read operations must be fast and performed in RAM.</li> <li>All write operations must be written to persistent storage.</li> </ol> <p>A write operation on a <code>disc_copies</code> table replica is performed in two steps. First the write operation is appended to a log file, then the actual operation is performed in RAM.</p> </li> <li> <p><code>{ram_copies, NodeList}</code>, where <code>NodeList</code> is a list of the nodes where this table is stored in RAM. Default is <code>[node()]</code>. If the default value is used to create a table, it is located on the local node only.</p> <p>Table replicas of type <code>ram_copies</code> can be dumped to disc with the function <code><a href="mnesia.html#dump_tables-1">mnesia:dump_tables(TabList)</a></code>.</p> </li> <li> <code>{disc_only_copies, NodeList}</code>. These table replicas are stored on disc only and are therefore slower to access. However, a disc-only replica consumes less memory than a table replica of the other two storage types. </li> <li> <p><code>{index, AttributeNameList}</code>, where <code>AttributeNameList</code> is a list of atoms specifying the names of the attributes <code>Mnesia</code> is to build and maintain. An index table exists for every element in the list. The first field of a <code>Mnesia</code> record is the key and thus need no extra index.</p> <p>The first field of a record is the second element of the tuple, which is the representation of the record.</p> </li> <li> <p><code>{snmp, SnmpStruct}</code>. <code>SnmpStruct</code> is described in the <code>SNMP</code> User's Guide. Basically, if this attribute is present in <code>ArgList</code> of <code><a href="mnesia.html#create_table-2">mnesia:create_table/2</a></code>, the table is immediately accessible the SNMP.</p> <p>It is easy to design applications that use SNMP to manipulate and control the system. <code>Mnesia</code> provides a direct mapping between the logical tables that make up an SNMP control application and the physical data that makes up a <code>Mnesia</code> table. The default value is <code>[]</code>.</p> </li> <li> <code>{local_content, true}</code>. When an application needs a table whose contents is to be locally unique on each node, <code>local_content</code> tables can be used. The name of the table is known to all <code>Mnesia</code> nodes, but its contents is unique for each node. Access to this type of table must be done locally.</li> <li> <p><code>{attributes, AtomList}</code> is a list of the attribute names for the records that are supposed to populate the table. Default is the list <code>[key, val]</code>. The table must at least have one extra attribute besides the key. When accessing single attributes in a record, it is not recommended to hard code the attribute names as atoms. Use the construct <code>record_info(fields, record_name)</code> instead.</p> <p>The expression <code>record_info(fields, record_name)</code> is processed by the Erlang preprocessor and returns a list of the record field names. With the record definition <code>-record(foo, {x,y,z}).</code>, the expression <code>record_info(fields,foo)</code> is expanded to the list <code>[x,y,z]</code>. It is therefore possible for you to provide the attribute names or to use the <code>record_info/2</code> notation.</p> <p>It is recommended to use the <code>record_info/2</code> notation, as it becomes easier to maintain the program and the program becomes more robust with regards to future record changes.</p> </li> <li> <p><code>{record_name, Atom}</code> specifies the common name of all records stored in the table. All records stored in the table must have this name as their first element. <code>record_name</code> defaults to the name of the table. For more information, see <code><a href="mnesia_chap4.html#recordnames_tablenames">Record Names versus Table Names</a></code>.</p> </li> </ul> </li> </ul> <p>As an example, consider the following record definition:</p> <pre data-language="erlang">
-record(funky, {x, y}).</pre> <p>The following call would create a table that is replicated on two nodes, has an extra index on attribute <code>y</code>, and is of type <code>bag</code>.</p> <pre data-language="erlang">
mnesia:create_table(funky, [{disc_copies, [N1, N2]}, {index,
[y]}, {type, bag}, {attributes, record_info(fields, funky)}]).</pre> <p>Whereas a call to the following default code values would return a table with a RAM copy on the local node, no extra indexes, and the attributes defaulted to the list <code>[key,val]</code>.</p> <pre data-language="erlang">
mnesia:create_table(stuff, [])</pre> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
