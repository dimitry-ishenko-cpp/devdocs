<div class="innertube"> <h1 id="External Term Format">12 External Term Format</h1> <h2 id="introduction" class="title-link"> <div class="title-name">12.1 Introduction</div>  </h2> <p> The external term format is mainly used in the distribution mechanism of Erlang. </p> <p> As Erlang has a fixed number of types, there is no need for a programmer to define a specification for the external format used within some application. All Erlang terms have an external representation and the interpretation of the different terms is application-specific. </p> <p> In Erlang the BIF <code> erlang:term_to_binary/1,2</code> is used to convert a term into the external format. To convert binary data encoding to a term, the BIF <code> erlang:binary_to_term/1</code> is used. </p> <p> The distribution does this implicitly when sending messages across node boundaries. </p>  <p id="overall_format"> The overall format of the term format is as follows: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>N</td> </tr> <tr> <td><code>131</code></td> <td><code>Tag</code></td> <td><code>Data</code></td> </tr> </table> <p class="doc-table-caption">Table 12.1: Term Format</p> </div> <div class="note"> <div class="label">Note</div> <div class="content">

<p> When messages are <code><a href="erl_dist_protocol.html#connected_nodes">passed between connected nodes</a></code> and a <code><a href="#distribution_header">distribution header</a></code> is used, the first byte containing the version number (131) is omitted from the terms that follow the distribution header. This is because the version number is implied by the version number in the distribution header. </p> </div> </div> <p> The compressed term format is as follows: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>4</td> <td>N</td> </tr> <tr> <td><code>131</code></td> <td><code>80</code></td> <td><code>UncompressedSize</code></td> <td><code>Zlib-compressedData</code></td> </tr> </table> <p class="doc-table-caption">Table 12.2: Compressed Term Format</p> </div> <p> Uncompressed size (unsigned 32-bit integer in big-endian byte order) is the size of the data before it was compressed. The compressed data has the following format when it has been expanded: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>Uncompressed Size</td> </tr> <tr> <td><code>Tag</code></td> <td><code>Data</code></td> </tr> </table> <p class="doc-table-caption">Table 12.3: Compressed Data Format when Expanded</p> </div> <h2 id="encoding-atoms" class="title-link"> <div class="title-name">12.2 Encoding atoms</div>  </h2> <p> As from ERTS 9.0 (OTP 20), atoms may contain any Unicode characters. </p> <p> Atoms sent over node distribution are always encoded in UTF-8 using either <code><a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a></code>, <code><a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a></code> or <code><a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a></code>. </p> <p> Atoms encoded with <code> erlang:term_to_binary/1,2</code> or <code> erlang:term_to_iovec/1,2</code> are by default still using the old deprecated Latin-1 format <code><a href="#ATOM_EXT">ATOM_EXT</a></code> for atoms that only contain Latin-1 characters (Unicode code points 0-255). Atoms with higher code points will be encoded in UTF-8 using either <code><a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a></code> or <code><a href="#SMALL_ATOM_UTF8_EXT">SMALL_ATOM_UTF8_EXT</a></code>. </p> <p>The maximum number of allowed characters in an atom is 255. In the UTF-8 case, each character can need 4 bytes to be encoded.</p> <h2 id="distribution-header" class="title-link"> <div class="title-name">12.3 Distribution Header</div>  </h2> <p> The distribution header is sent by the erlang distribution to carry metadata about the coming <code><a href="erl_dist_protocol.html#control_message">control message</a></code> and potential payload. It is primarily used to handle the atom cache in the Erlang distribution. Since OTP-22 it is also used to fragment large distribution messages into multiple smaller fragments. For more information about how the distribution uses the distribution header, see the documentation of the <code><a href="erl_dist_protocol.html#connected_nodes">protocol between connected nodes</a></code> in the <code><a href="erl_dist_protocol.html">distribution protocol</a></code> documentation. </p> <p> Any <code><a href="#ATOM_CACHE_REF">ATOM_CACHE_REF</a></code> entries with corresponding <code>AtomCacheReferenceIndex</code> in terms encoded on the external format following a distribution header refer to the atom cache references made in the distribution header. The range is 0 &lt;= <code>AtomCacheReferenceIndex</code> &lt; 255, that is, at most 255 different atom cache references from the following terms can be made. </p> <h3 id="normal-distribution-header" class="title-link"> <div class="title-name">Normal Distribution Header</div>  </h3> <p> The non-fragmented distribution header format is as follows: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>1</td> <td>NumberOfAtomCacheRefs/2+1 | 0</td> <td>N | 0</td> </tr> <tr> <td><code>131</code></td> <td><code>68</code></td> <td><code>NumberOfAtomCacheRefs</code></td> <td><code>Flags</code></td> <td><code>AtomCacheRefs</code></td> </tr> </table> <p class="doc-table-caption">Table 12.4: Normal Distribution Header Format</p> </div> <p> <code>Flags</code> consist of <code>NumberOfAtomCacheRefs/2+1</code> bytes, unless <code>NumberOfAtomCacheRefs</code> is <code>0</code>. If <code>NumberOfAtomCacheRefs</code> is <code>0</code>, <code>Flags</code> and <code>AtomCacheRefs</code> are omitted. Each atom cache reference has a half byte flag field. Flags corresponding to a specific <code>AtomCacheReferenceIndex</code> are located in flag byte number <code>AtomCacheReferenceIndex/2</code>. Flag byte 0 is the first byte after the <code>NumberOfAtomCacheRefs</code> byte. Flags for an even <code>AtomCacheReferenceIndex</code> are located in the least significant half byte and flags for an odd <code>AtomCacheReferenceIndex</code> are located in the most significant half byte. </p> <p> The flag field of an atom cache reference has the following format: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1 bit</td> <td>3 bits</td> </tr> <tr> <td><code>NewCacheEntryFlag</code></td> <td><code>SegmentIndex</code></td> </tr> </table> <p class="doc-table-caption">Table 12.5: </p> </div> <p> The most significant bit is the <code>NewCacheEntryFlag</code>. If set, the corresponding cache reference is new. The three least significant bits are the <code>SegmentIndex</code> of the corresponding atom cache entry. An atom cache consists of 8 segments, each of size 256, that is, an atom cache can contain 2048 entries. </p> <p> Another half byte flag field is located along with flag fields for atom cache references. When <code>NumberOfAtomCacheRefs</code> is even, this half byte is the least significant half byte of the byte that follows the atom cache references. When <code>NumberOfAtomCacheRefs</code> is odd, this half byte is the most significant half byte of the last byte of the atom cache references (on the wire, it will appear before the last cache reference). It has the following format: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>3 bits</td> <td>1 bit</td> </tr> <tr> <td><code>CurrentlyUnused</code></td> <td><code>LongAtoms</code></td> </tr> </table> <p class="doc-table-caption">Table 12.6: </p> </div> <p> The least significant bit in that half byte is flag <code>LongAtoms</code>. If it is set, 2 bytes are used for atom lengths instead of 1 byte in the distribution header. </p> <p> After the <code>Flags</code> field follow the <code>AtomCacheRefs</code>. The first <code>AtomCacheRef</code> is the one corresponding to <code>AtomCacheReferenceIndex</code> 0. Higher indices follow in sequence up to index <code>NumberOfAtomCacheRefs - 1</code>. </p> <p> If the <code>NewCacheEntryFlag</code> for the next <code>AtomCacheRef</code> has been set, a <code>NewAtomCacheRef</code> on the following format follows: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1 | 2</td> <td>Length</td> </tr> <tr> <td><code>InternalSegmentIndex</code></td> <td><code>Length</code></td> <td><code>AtomText</code></td> </tr> </table> <p class="doc-table-caption">Table 12.7: </p> </div> <p> <code>InternalSegmentIndex</code> together with the <code>SegmentIndex</code> completely identify the location of an atom cache entry in the atom cache. <code>Length</code> is the number of bytes that <code>AtomText</code> consists of. Length is a 2 byte big-endian integer if flag <code>LongAtoms</code> has been set, otherwise a 1 byte integer. When distribution flag <code><a href="erl_dist_protocol.html#DFLAG_UTF8_ATOMS"> DFLAG_UTF8_ATOMS</a></code> has been exchanged between both nodes in the <code><a href="erl_dist_protocol.html#distribution_handshake"> distribution handshake</a></code>, characters in <code>AtomText</code> are encoded in UTF-8, otherwise in Latin-1. The following <code>CachedAtomRef</code>s with the same <code>SegmentIndex</code> and <code>InternalSegmentIndex</code> as this <code>NewAtomCacheRef</code> refer to this atom until a new <code>NewAtomCacheRef</code> with the same <code>SegmentIndex</code> and <code>InternalSegmentIndex</code> appear. </p> <p> For more information on encoding of atoms, see the <code><a href="#utf8_atoms">section on UTF-8 encoded atoms</a></code> above. </p> <p> If the <code>NewCacheEntryFlag</code> for the next <code>AtomCacheRef</code> has not been set, a <code>CachedAtomRef</code> on the following format follows: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> </tr> <tr> <td><code>InternalSegmentIndex</code></td> </tr> </table> <p class="doc-table-caption">Table 12.8: </p> </div> <p> <code>InternalSegmentIndex</code> together with the <code>SegmentIndex</code> identify the location of the atom cache entry in the atom cache. The atom corresponding to this <code>CachedAtomRef</code> is the latest <code>NewAtomCacheRef</code> preceding this <code>CachedAtomRef</code> in another previously passed distribution header. </p> <h3 id="distribution-header-for-fragmented-messages" class="title-link"> <div class="title-name">Distribution Header for fragmented messages</div>  </h3> <p>Messages sent between Erlang nodes can sometimes be quite large. Since OTP-22 it is possible to split large messages into smaller fragments in order to allow smaller messages to be interleaved between larges messages. It is only the <code>message</code> part of each <code><a href="erl_dist_protocol.html#connected_nodes">distributed message</a></code> that may be split using fragmentation. Therefore it is recommended to use the <code><a href="erl_dist_protocol.html#new-ctrlmessages-for-erlang-otp-22"> PAYLOAD control messages</a></code> introduced in OTP-22. </p> <p>Fragmented distribution messages are only used if the receiving node signals that it supports them via the <code><a href="erl_dist_protocol.html#DFLAG_FRAGMENTS">DFLAG_FRAGMENTS</a></code> distribution flag.</p> <p>A process must complete the sending of a fragmented message before it can start sending any other message on the same distribution channel.</p> <p>The start of a sequence of fragmented messages looks like this:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>8</td> <td>8</td> <td>1</td> <td>NumberOfAtomCacheRefs/2+1 | 0</td> <td>N | 0</td> </tr> <tr> <td><code>131</code></td> <td><code>69</code></td> <td><code>SequenceId</code></td> <td><code>FragmentId</code></td> <td><code>NumberOfAtomCacheRefs</code></td> <td><code>Flags</code></td> <td><code>AtomCacheRefs</code></td> </tr> </table> <p class="doc-table-caption">Table 12.9: Starting Fragmented Distribution Header Format</p> </div> <p>The continuation of a sequence of fragmented messages looks like this:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>8</td> <td>8</td> </tr> <tr> <td><code>131</code></td> <td><code>70</code></td> <td><code>SequenceId</code></td> <td><code>FragmentId</code></td> </tr> </table> <p class="doc-table-caption">Table 12.10: Continuing Fragmented Distribution Header Format</p> </div> <p> The starting distribution header is very similar to a non-fragmented distribution header. The atom cache works the same as for normal distribution header and is the same for the entire sequence. The additional fields added are the sequence id and fragment id. </p> <dl> <dt class="title-link"><strong>Sequence ID</strong></dt> <dd> <p> The sequence id is used to uniquely identify a fragmented message sent from one process to another on the same distributed connection. This is used to identify which sequence a fragment is a part of as the same process can be in the process of receiving multiple sequences at the same time. </p> <p> As one process can only be sending one fragmented message at once, it can be convenient to use the local PID as the sequence id. </p> </dd> <dt class="title-link"><strong>Fragments ID</strong></dt> <dd> <p> The Fragment ID is used to number the fragments in a sequence. The id starts at the total number of fragments and then decrements to 1 (which is the final fragment). So if a sequence consists of 3 fragments the fragment id in the starting header will be 3, and then fragments 2 and 1 are sent. </p> <p> The fragments must be delivered in the correct order, so if an unordered distribution carrier is used, they must be ordered before delivered to the Erlang run-time. </p> </dd> </dl> <h4>Example:</h4> <p> As an example, let say that we want to send <code>{call, &lt;0.245.2&gt;, {set_get_state, &lt;&lt;0:1024&gt;&gt;}}</code> to registered process <code>reg</code> using a fragment size of 128. To send this message we need a distribution header, atom cache updates, the control message (which would be <code>{6, &lt;0.245.2&gt;, [], reg}</code> in this case) and finally the actual message. This would all be encoded into: </p> <pre data-language="erlang">131,69,0,0,2,168,0,0,5,83,0,0,0,0,0,0,0,2,               %% Header with seq and frag id
5,4,137,9,10,5,236,3,114,101,103,9,4,99,97,108,108,      %% Atom cache updates
238,13,115,101,116,95,103,101,116,95,115,116,97,116,101,
104,4,97,6,103,82,0,0,0,0,85,0,0,0,0,2,82,1,82,2,        %% Control message
104,3,82,3,103,82,0,0,0,0,245,0,0,0,2,2,                 %% Actual message using cached atoms
104,2,82,4,109,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

131,70,0,0,2,168,0,0,5,83,0,0,0,0,0,0,0,1,               %% Cont Header with seq and frag id
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,               %% Rest of payload
0,0,0,0</pre> <p> Let us break that apart into its components. First we have the distribution header tags together with the sequence id and a fragment id of 2. </p> <pre data-language="erlang">131,69,                   %% Start fragment header
0,0,2,168,0,0,5,83,       %% The sequence ID
0,0,0,0,0,0,0,2,           %% The fragment ID</pre> <p>Then we have the updates to the atom cache:</p> <pre data-language="erlang">5,4,137,9,  %% 5 atoms and their flags
10,5,       %% The already cached atom ids
236,3,114,101,103,  %% The atom 'reg'
9,4,99,97,108,108,  %% The atom 'call'
238,13,115,101,116,95,103,101,116,95,115,116,97,116,101, %% The atom 'set_get_state'</pre> <p> The first byte says that we have 5 atoms that are part of the cache. Then follows three bytes that are the atom cache ref flags. Each of the flags uses 4 bits so they are a bit hard to read in decimal byte form. In binary half-byte form they look like this: </p> <pre data-language="erlang">0000, 0100, 1000, 1001, 1001</pre> <p> As the high bit of the first two atoms in the cache are not set we know that they are already in the cache, so they do not have to be sent again (this is the node name of the receiving and sending node). Then follows the atoms that have to be sent, together with their segment ids. </p> <p> Then the listing of the atoms comes, starting with 10 and 5 which are the atom refs of the already cached atoms. Then the new atoms are sent. </p> <p> When the atom cache is setup correctly the control message is sent. </p> <pre data-language="erlang">104,4,97,6,103,82,0,0,0,0,85,0,0,0,0,2,82,1,82,2,</pre> <p> Note that up until here it is not allowed to fragments the message. The entire atom cache and control message has to be part of the starting fragment. After the control message the payload of the message is sent using 128 bytes: </p> <pre data-language="erlang">104,3,82,3,103,82,0,0,0,0,245,0,0,0,2,2,
104,2,82,4,109,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</pre> <p> Since the payload is larger than 128-bytes it is split into two fragments. The second fragment does not have any atom cache update instructions so it is a lot simpler: </p> <pre data-language="erlang">131,70,0,0,2,168,0,0,5,83,0,0,0,0,0,0,0,1, %% Continuation dist header 70 with seq and frag id
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, %% remaining payload
0,0,0,0</pre> <div class="note"> <div class="label">Note</div> <div class="content">

<p> The fragment size of 128 is only used as an example. Any fragments size may be used when sending fragmented messages. </p> </div> </div> <h2 id="atom_cache_ref" class="title-link"> 12.4 atom_cache_ref  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> </tr> <tr> <td><code>82</code></td> <td><code>AtomCacheReferenceIndex</code></td> </tr> </table> <p class="doc-table-caption">Table 12.11: ATOM_CACHE_REF</p> </div> <p> Refers to the atom with <code>AtomCacheReferenceIndex</code> in the <code><a href="#distribution_header">distribution header</a></code>. </p> <h2 id="small_integer_ext" class="title-link"> 12.5 small_integer_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> </tr> <tr> <td><code>97</code></td> <td><code>Int</code></td> </tr> </table> <p class="doc-table-caption">Table 12.12: SMALL_INTEGER_EXT</p> </div> <p> Unsigned 8-bit integer. </p> <h2 id="integer_ext" class="title-link"> 12.6 integer_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> </tr> <tr> <td><code>98</code></td> <td><code>Int</code></td> </tr> </table> <p class="doc-table-caption">Table 12.13: INTEGER_EXT</p> </div> <p> Signed 32-bit integer in big-endian format. </p> <h2 id="float_ext" class="title-link"> 12.7 float_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>31</td> </tr> <tr> <td><code>99</code></td> <td><code>Float string</code></td> </tr> </table> <p class="doc-table-caption">Table 12.14: FLOAT_EXT</p> </div> <p> A finite float (i.e. not inf, -inf or NaN) is stored in string format. The format used in sprintf to format the float is "%.20e" (there are more bytes allocated than necessary). To unpack the float, use sscanf with format "%lf". </p> <p> This term is used in minor version 0 of the external format; it has been superseded by <code><a href="#NEW_FLOAT_EXT">NEW_FLOAT_EXT</a></code>. </p> <h2 id="port_ext" class="title-link"> 12.8 port_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>N</td> <td>4</td> <td>1</td> </tr> <tr> <td><code>102</code></td> <td><code>Node</code></td> <td><code>ID</code></td> <td><code>Creation</code></td> </tr> </table> <p class="doc-table-caption">Table 12.15: PORT_EXT</p> </div> <p> Same as <code><a href="#NEW_PORT_EXT">NEW_PORT_EXT</a></code> except the <code>Creation</code> field is only one byte and only two bits are significant, the rest are to be 0. </p> <h2 id="new_port_ext" class="title-link"> 12.9 new_port_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>N</td> <td>4</td> <td>4</td> </tr> <tr> <td><code>89</code></td> <td><code>Node</code></td> <td><code>ID</code></td> <td><code>Creation</code></td> </tr> </table> <p class="doc-table-caption">Table 12.16: NEW_PORT_EXT</p> </div> <p> Same as <code><a href="#V4_PORT_EXT">V4_PORT_EXT</a></code> except the <code>ID</code> field is only four bytes. Only 28 bits are significant; the rest are to be 0. </p> <p><code>NEW_PORT_EXT</code> was introduced in OTP 19, but only to be decoded and echoed back. Not encoded for local ports. </p> <p>In OTP 23 distribution flag <code><a href="erl_dist_protocol.html#DFLAG_BIG_CREATION">DFLAG_BIG_CREATION</a></code> became mandatory. All ports are now encoded using <code>NEW_PORT_EXT</code>, even external ports received as <code><a href="#PORT_EXT">PORT_EXT</a></code> from older nodes. </p> <h2 id="v4_port_ext" class="title-link"> 12.10 v4_port_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>N</td> <td>8</td> <td>4</td> </tr> <tr> <td><code>120</code></td> <td><code>Node</code></td> <td><code>ID</code></td> <td><code>Creation</code></td> </tr> </table> <p class="doc-table-caption">Table 12.17: V4_PORT_EXT</p> </div> <p> Encodes a port identifier (obtained from <code><a href="erlang.html#open_port-2">erlang:open_port/2</a></code>). <code>Node</code> is the originating node, <code><a href="#utf8_atoms">encoded as an atom</a></code>. <code>ID</code> is a 64-bit big endian unsigned integer. The <code>Creation</code> works just like in <code><a href="#NEW_PID_EXT">NEW_PID_EXT</a></code>. Port operations are not allowed across node boundaries. </p> <p>In OTP 26 distribution flag <code><a href="erl_dist_protocol.html#DFLAG_V4_NC">DFLAG_V4_NC</a></code> as well as <code>V4_PORT_EXT</code> became mandatory accepting full 64-bit ports to be decoded and echoed back. </p> <h2 id="pid_ext" class="title-link"> 12.11 pid_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>N</td> <td>4</td> <td>4</td> <td>1</td> </tr> <tr> <td><code>103</code></td> <td><code>Node</code></td> <td><code>ID</code></td> <td><code>Serial</code></td> <td><code>Creation</code></td> </tr> </table> <p class="doc-table-caption">Table 12.18: PID_EXT</p> </div> <p> Same as <code><a href="#NEW_PID_EXT">NEW_PID_EXT</a></code> except the <code>Creation</code> field is only one byte and only two bits are significant, the rest are to be 0. </p> <h2 id="new_pid_ext" class="title-link"> 12.12 new_pid_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>N</td> <td>4</td> <td>4</td> <td>4</td> </tr> <tr> <td><code>88</code></td> <td><code>Node</code></td> <td><code>ID</code></td> <td><code>Serial</code></td> <td><code>Creation</code></td> </tr> </table> <p class="doc-table-caption">Table 12.19: NEW_PID_EXT</p> </div> <p> Encodes an Erlang process identifier object. </p> <dl> <dt class="title-link"><strong><code>Node</code></strong></dt> <dd> <p>The name of the originating node, <code><a href="#utf8_atoms">encoded as an atom</a></code>.</p> </dd> <dt class="title-link"><strong><code>ID</code></strong></dt> <dd> <p>A 32-bit big endian unsigned integer.</p> </dd> <dt class="title-link"><strong><code>Serial</code></strong></dt> <dd> <p>A 32-bit big endian unsigned integer.</p> </dd> <dt class="title-link"><strong><code>Creation</code></strong></dt> <dd> <p>A 32-bit big endian unsigned integer. All identifiers originating from the same node incarnation must have identical <code>Creation</code> values. This makes it possible to separate identifiers from old (crashed) nodes from a new one. The value zero is reserved and must be avoided for normal operations.</p> </dd> </dl> <p><code>NEW_PID_EXT</code> was introduced in OTP 19, but only to be decoded and echoed back. Not encoded for local processes. </p> <p>In OTP 23 distribution flag <code><a href="erl_dist_protocol.html#DFLAG_BIG_CREATION">DFLAG_BIG_CREATION</a></code> became mandatory. All pids are now encoded using <code>NEW_PID_EXT</code>, even external pids received as <code><a href="#PID_EXT">PID_EXT</a></code> from older nodes. </p> <p>In OTP 26 distribution flag <code><a href="erl_dist_protocol.html#DFLAG_V4_NC">DFLAG_V4_NC</a></code> became mandatory accepting full 64-bit pids to be decoded and echoed back. </p> <h2 id="small_tuple_ext" class="title-link"> 12.13 small_tuple_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>N</td> </tr> <tr> <td><code>104</code></td> <td><code>Arity</code></td> <td><code>Elements</code></td> </tr> </table> <p class="doc-table-caption">Table 12.20: SMALL_TUPLE_EXT</p> </div> <p> Encodes a tuple. The <code>Arity</code> field is an unsigned byte that determines how many elements that follows in section <code>Elements</code>. </p> <h2 id="large_tuple_ext" class="title-link"> 12.14 large_tuple_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> <td>N</td> </tr> <tr> <td><code>105</code></td> <td><code>Arity</code></td> <td><code>Elements</code></td> </tr> </table> <p class="doc-table-caption">Table 12.21: LARGE_TUPLE_EXT</p> </div> <p> Same as <code><a href="#SMALL_TUPLE_EXT">SMALL_TUPLE_EXT</a></code> except that <code>Arity</code> is an unsigned 4 byte integer in big-endian format. </p> <h2 id="map_ext" class="title-link"> 12.15 map_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> <td>N</td> </tr> <tr> <td><code>116</code></td> <td><code>Arity</code></td> <td><code>Pairs</code></td> </tr> </table> <p class="doc-table-caption">Table 12.22: MAP_EXT</p> </div> <p> Encodes a map. The <code>Arity</code> field is an unsigned 4 byte integer in big-endian format that determines the number of key-value pairs in the map. Key and value pairs (<code>Ki =&gt; Vi</code>) are encoded in section <code>Pairs</code> in the following order: <code>K1, V1, K2, V2,..., Kn, Vn</code>. Duplicate keys are <strong>not allowed</strong> within the same map. </p> <p><strong>As from </strong>Erlang/OTP 17.0</p> <h2 id="nil_ext" class="title-link"> 12.16 nil_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> </tr> <tr> <td><code>106</code></td> </tr> </table> <p class="doc-table-caption">Table 12.23: NIL_EXT</p> </div> <p> The representation for an empty list, that is, the Erlang syntax <code>[]</code>. </p> <h2 id="string_ext" class="title-link"> 12.17 string_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>2</td> <td>Len</td> </tr> <tr> <td><code>107</code></td> <td><code>Length</code></td> <td><code>Characters</code></td> </tr> </table> <p class="doc-table-caption">Table 12.24: STRING_EXT</p> </div> <p> String does <strong>not</strong> have a corresponding Erlang representation, but is an optimization for sending lists of bytes (integer in the range 0-255) more efficiently over the distribution. As field <code>Length</code> is an unsigned 2 byte integer (big-endian), implementations must ensure that lists longer than 65535 elements are encoded as <code><a href="#LIST_EXT">LIST_EXT</a></code>. </p> <h2 id="list_ext" class="title-link"> 12.18 list_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> <td> </td> <td> </td> </tr> <tr> <td><code>108</code></td> <td><code>Length</code></td> <td><code>Elements</code></td> <td><code>Tail</code></td> </tr> </table> <p class="doc-table-caption">Table 12.25: LIST_EXT</p> </div> <p> <code>Length</code> is the number of elements that follows in section <code>Elements</code>. <code>Tail</code> is the final tail of the list; it is <code><a href="#NIL_EXT">NIL_EXT</a></code> for a proper list, but can be any type if the list is improper (for example, <code>[a|b]</code>). </p> <h2 id="binary_ext" class="title-link"> 12.19 binary_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> <td>Len</td> </tr> <tr> <td><code>109</code></td> <td><code>Len</code></td> <td><code>Data</code></td> </tr> </table> <p class="doc-table-caption">Table 12.26: BINARY_EXT</p> </div> <p> Binaries are generated with bit syntax expression or with <code> erlang:list_to_binary/1</code>, <code> erlang:term_to_binary/1</code>, or as input from binary ports. The <code>Len</code> length field is an unsigned 4 byte integer (big-endian). </p> <h2 id="small_big_ext" class="title-link"> 12.20 small_big_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>1</td> <td>n</td> </tr> <tr> <td><code>110</code></td> <td><code>n</code></td> <td><code>Sign</code></td> <td> <code>d(0)</code> ... <code>d(n-1)</code> </td> </tr> </table> <p class="doc-table-caption">Table 12.27: SMALL_BIG_EXT</p> </div> <p> Bignums are stored in unary form with a <code>Sign</code> byte, that is, 0 if the bignum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used: </p> <p><code>B</code> = 256<br> <code>(d0*B^0 + d1*B^1 + d2*B^2 + ... d(N-1)*B^(n-1))</code> </p> <h2 id="large_big_ext" class="title-link"> 12.21 large_big_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> <td>1</td> <td>n</td> </tr> <tr> <td><code>111</code></td> <td><code>n</code></td> <td><code>Sign</code></td> <td> <code>d(0)</code> ... <code>d(n-1)</code> </td> </tr> </table> <p class="doc-table-caption">Table 12.28: LARGE_BIG_EXT</p> </div> <p> Same as <code><a href="#SMALL_BIG_EXT"> SMALL_BIG_EXT</a></code> except that the length field is an unsigned 4 byte integer. </p> <h2 id="reference_ext--deprecated-" class="title-link"> <div class="title-name">12.22 REFERENCE_EXT (deprecated)</div>  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>N</td> <td>4</td> <td>1</td> </tr> <tr> <td><code>101</code></td> <td><code>Node</code></td> <td><code>ID</code></td> <td><code>Creation</code></td> </tr> </table> <p class="doc-table-caption">Table 12.29: REFERENCE_EXT</p> </div> <p> The same as <code><a href="#NEW_REFERENCE_EXT"> NEW_REFERENCE_EXT</a></code> except <code>ID</code> is only one word (<code>Len</code> = 1). </p> <h2 id="new_reference_ext" class="title-link"> 12.23 new_reference_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>2</td> <td>N</td> <td>1</td> <td>N'</td> </tr> <tr> <td><code>114</code></td> <td><code>Len</code></td> <td><code>Node</code></td> <td><code>Creation</code></td> <td><code>ID ...</code></td> </tr> </table> <p class="doc-table-caption">Table 12.30: NEW_REFERENCE_EXT</p> </div> <p> The same as <code><a href="#NEWER_REFERENCE_EXT"> NEWER_REFERENCE_EXT</a></code> <strong>except</strong>: </p> <dl> <dt class="title-link"><strong><code>ID</code></strong></dt> <dd> <p>In the first word (4 bytes) of <code>ID</code>, only 18 bits are significant, the rest must be 0.</p> </dd> <dt class="title-link"><strong><code>Creation</code></strong></dt> <dd> <p>Only one byte long and only two bits are significant, the rest must be 0.</p> </dd> </dl> <h2 id="newer_reference_ext" class="title-link"> 12.24 newer_reference_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>2</td> <td>N</td> <td>4</td> <td>N'</td> </tr> <tr> <td><code>90</code></td> <td><code>Len</code></td> <td><code>Node</code></td> <td><code>Creation</code></td> <td><code>ID ...</code></td> </tr> </table> <p class="doc-table-caption">Table 12.31: NEWER_REFERENCE_EXT</p> </div> <p> Encodes a reference term generated with <code>erlang:make_ref/0</code>. </p> <dl> <dt class="title-link"><strong><code>Node</code></strong></dt> <dd> <p>The name of the originating node, <code><a href="#utf8_atoms">encoded as an atom</a></code>.</p> </dd> <dt class="title-link"><strong><code>Len</code></strong></dt> <dd> <p>A 16-bit big endian unsigned integer not larger than 5.</p> </dd> <dt class="title-link"><strong><code>ID</code></strong></dt> <dd> <p>A sequence of <code>Len</code> big-endian unsigned integers (4 bytes each, so <code>N'</code> = 4 * <code>Len</code>), but is to be regarded as uninterpreted data.</p> </dd> <dt class="title-link"><strong><code>Creation</code></strong></dt> <dd> <p>Works just like in <code><a href="#NEW_PID_EXT">NEW_PID_EXT</a></code>.</p> </dd> </dl> <p><code>NEWER_REFERENCE_EXT</code> was introduced in OTP 19, but only to be decoded and echoed back. Not encoded for local references. </p> <p>In OTP 23 distribution flag <code><a href="erl_dist_protocol.html#DFLAG_BIG_CREATION">DFLAG_BIG_CREATION</a></code> became mandatory. All references are now encoded using <code>NEWER_REFERENCE_EXT</code>, even external references received as <code><a href="#NEW_REFERENCE_EXT">NEW_REFERENCE_EXT</a></code> from older nodes. </p> <p>In OTP 26 distribution flag <code><a href="erl_dist_protocol.html#DFLAG_V4_NC">DFLAG_V4_NC</a></code> became mandatory. References now can contain up to 5 <code>ID</code> words.</p> <h2 id="fun_ext--removed-" class="title-link"> <div class="title-name">12.25 FUN_EXT (removed)</div>  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> <td>N1</td> <td>N2</td> <td>N3</td> <td>N4</td> <td>N5</td> </tr> <tr> <td><code>117</code></td> <td><code>NumFree</code></td> <td><code>Pid</code></td> <td><code>Module</code></td> <td><code>Index</code></td> <td><code>Uniq</code></td> <td><code>Free vars ...</code></td> </tr> </table> <p class="doc-table-caption">Table 12.32: FUN_EXT</p> </div> <p>Not emitted since OTP R8, and not decoded since OTP 23.</p> <h2 id="new_fun_ext" class="title-link"> 12.26 new_fun_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> <td>1</td> <td>16</td> <td>4</td> <td>4</td> <td>N1</td> <td>N2</td> <td>N3</td> <td>N4</td> <td>N5</td> </tr> <tr> <td><code>112</code></td> <td><code>Size</code></td> <td><code>Arity</code></td> <td><code>Uniq</code></td> <td><code>Index</code></td> <td><code>NumFree</code></td> <td><code>Module</code></td> <td><code>OldIndex</code></td> <td><code>OldUniq</code></td> <td><code>Pid</code></td> <td><code>Free Vars</code></td> </tr> </table> <p class="doc-table-caption">Table 12.33: NEW_FUN_EXT</p> </div> <p> This is the encoding of internal funs: <code>fun F/A</code> and <code>fun(Arg1,..) -&gt; ... end</code>. </p> <dl> <dt class="title-link"><strong><code>Size</code></strong></dt> <dd> <p>The total number of bytes, including field <code>Size</code>.</p> </dd> <dt class="title-link"><strong><code>Arity</code></strong></dt> <dd> <p>The arity of the function implementing the fun.</p> </dd> <dt class="title-link"><strong><code>Uniq</code></strong></dt> <dd> <p>The 16 bytes MD5 of the significant parts of the Beam file.</p> </dd> <dt class="title-link"><strong><code>Index</code></strong></dt> <dd> <p>An index number. Each fun within a module has an unique index. <code>Index</code> is stored in big-endian byte order. </p> </dd> <dt class="title-link"><strong><code>NumFree</code></strong></dt> <dd> <p>The number of free variables.</p> </dd> <dt class="title-link"><strong><code>Module</code></strong></dt> <dd> <p> The module that the fun is implemented in, <code><a href="#utf8_atoms">encoded as an atom</a></code>. </p> </dd> <dt class="title-link"><strong><code>OldIndex</code></strong></dt> <dd> <p>An integer encoded using <code><a href="#SMALL_INTEGER_EXT"> SMALL_INTEGER_EXT</a></code> or <code><a href="#INTEGER_EXT">INTEGER_EXT</a></code>. Is typically a small index into the module's fun table. </p> </dd> <dt class="title-link"><strong><code>OldUniq</code></strong></dt> <dd> <p>An integer encoded using <code><a href="#SMALL_INTEGER_EXT"> SMALL_INTEGER_EXT</a></code> or <code><a href="#INTEGER_EXT">INTEGER_EXT</a></code>. <code>Uniq</code> is the hash value of the parse tree for the fun. </p> </dd> <dt class="title-link"><strong><code>Pid</code></strong></dt> <dd> <p>A process identifier as in <code><a href="#PID_EXT">PID_EXT</a></code>. Represents the process in which the fun was created. </p> </dd> <dt class="title-link"><strong><code>Free vars</code></strong></dt> <dd> <p><code>NumFree</code> number of terms, each one encoded according to its type. </p> </dd> </dl> <h2 id="export_ext" class="title-link"> 12.27 export_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>N1</td> <td>N2</td> <td>N3</td> </tr> <tr> <td><code>113</code></td> <td><code>Module</code></td> <td><code>Function</code></td> <td><code>Arity</code></td> </tr> </table> <p class="doc-table-caption">Table 12.34: EXPORT_EXT</p> </div> <p> This term is the encoding for external funs: <code>fun M:F/A</code>. </p> <p> <code>Module</code> and <code>Function</code> are <code><a href="#utf8_atoms">encoded as atoms</a></code>. </p> <p> <code>Arity</code> is an integer encoded using <code><a href="#SMALL_INTEGER_EXT"> SMALL_INTEGER_EXT</a></code>. </p> <h2 id="bit_binary_ext" class="title-link"> 12.28 bit_binary_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> <td>1</td> <td>Len</td> </tr> <tr> <td><code>77</code></td> <td><code>Len</code></td> <td><code>Bits</code></td> <td><code>Data</code></td> </tr> </table> <p class="doc-table-caption">Table 12.35: BIT_BINARY_EXT</p> </div> <p> This term represents a bitstring whose length in bits does not have to be a multiple of 8. The <code>Len</code> field is an unsigned 4 byte integer (big-endian). The <code>Bits</code> field is the number of bits (1-8) that are used in the last byte in the data field, counting from the most significant bit to the least significant. </p> <h2 id="new_float_ext" class="title-link"> 12.29 new_float_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>8</td> </tr> <tr> <td><code>70</code></td> <td><code>IEEE float</code></td> </tr> </table> <p class="doc-table-caption">Table 12.36: NEW_FLOAT_EXT</p> </div> <p> A finite float (i.e. not inf, -inf or NaN) is stored as 8 bytes in big-endian IEEE format. </p> <p> This term is used in minor version 1 of the external format. </p> <h2 id="atom_utf8_ext" class="title-link"> 12.30 atom_utf8_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>2</td> <td>Len</td> </tr> <tr> <td><code>118</code></td> <td><code>Len</code></td> <td><code>AtomName</code></td> </tr> </table> <p class="doc-table-caption">Table 12.37: ATOM_UTF8_EXT</p> </div> <p> An atom is stored with a 2 byte unsigned length in big-endian order, followed by <code>Len</code> bytes containing the <code>AtomName</code> encoded in UTF-8. </p> <p> For more information, see the <code><a href="#utf8_atoms">section on encoding atoms</a></code> in the beginning of this page. </p> <h2 id="small_atom_utf8_ext" class="title-link"> 12.31 small_atom_utf8_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>Len</td> </tr> <tr> <td><code>119</code></td> <td><code>Len</code></td> <td><code>AtomName</code></td> </tr> </table> <p class="doc-table-caption">Table 12.38: SMALL_ATOM_UTF8_EXT</p> </div> <p> An atom is stored with a 1 byte unsigned length, followed by <code>Len</code> bytes containing the <code>AtomName</code> encoded in UTF-8. Longer atoms encoded in UTF-8 can be represented using <code><a href="#ATOM_UTF8_EXT">ATOM_UTF8_EXT</a></code>. </p> <p> For more information, see the <code><a href="#utf8_atoms">section on encoding atoms</a></code> in the beginning of this page. </p> <h2 id="atom_ext--deprecated-" class="title-link"> <div class="title-name">12.32 ATOM_EXT (deprecated)</div>  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>2</td> <td>Len</td> </tr> <tr> <td><code>100</code></td> <td><code>Len</code></td> <td><code>AtomName</code></td> </tr> </table> <p class="doc-table-caption">Table 12.39: ATOM_EXT</p> </div> <p> An atom is stored with a 2 byte unsigned length in big-endian order, followed by <code>Len</code> numbers of 8-bit Latin-1 characters that forms the <code>AtomName</code>. The maximum allowed value for <code>Len</code> is 255. </p> <h2 id="small_atom_ext--deprecated-" class="title-link"> <div class="title-name">12.33 SMALL_ATOM_EXT (deprecated)</div>  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>Len</td> </tr> <tr> <td><code>115</code></td> <td><code>Len</code></td> <td><code>AtomName</code></td> </tr> </table> <p class="doc-table-caption">Table 12.40: SMALL_ATOM_EXT</p> </div> <p> An atom is stored with a 1 byte unsigned length, followed by <code>Len</code> numbers of 8-bit Latin-1 characters that forms the <code>AtomName</code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> <code>SMALL_ATOM_EXT</code> was introduced in ERTS 5.7.2 and require an exchange of distribution flag <code><a href="erl_dist_protocol.html#DFLAG_SMALL_ATOM_TAGS"> DFLAG_SMALL_ATOM_TAGS</a></code> in the <code><a href="erl_dist_protocol.html#distribution_handshake"> distribution handshake</a></code>. </p> </div> </div> <h2 id="local_ext" class="title-link"> 12.34 local_ext  </h2> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>...</td> </tr> <tr> <td><code>121</code></td> <td>...</td> </tr> </table> <p class="doc-table-caption">Table 12.41: LOCAL_EXT</p> </div> <p> Marks that this is encoded on an alternative local external term format intended to only be decoded by a specific local decoder. The bytes following from here on may contain any unspecified type of encoding of terms. It is the responsibility of the user to only attempt to decode terms on the local external term format which has been produced by a matching encoder. </p> <p> This tag is used by the Erlang runtime system upon encoding the local external term format when the <code>local</code> option is passed to <code>term_to_binary/2</code>, but can be used by other encoders as well providing similar functionality. The Erlang runtime system adds a hash immediately following the <code>LOCAL_EXT</code> tag which is verified on decoding in order to verify that encoder and decoder match which might be a good practice. This will very likely catch mistakes made by users, but is not guaranteed to, and is not intended to, prevent decoding of an intentionally forged encoding on the local external term format. </p> <p> <code>LOCAL_EXT</code> was introduced in OTP 26.0. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
