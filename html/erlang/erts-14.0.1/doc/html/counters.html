  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">counters</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">Counter Functions</div> <h2 id="since" class="title-link"> <div class="title-name">Since</div>  </h2> <div class="REFBODY module-since"> Module counters was introduced in OTP 21.2. </div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module provides a set of functions to do operations towards shared mutable counter variables. The implementation does not utilize any software level locking, which makes it very efficient for concurrent access. The counters are organized into arrays with the following semantics:</p> <ul> <li> <p>Counters are 64 bit signed integers.</p> </li> <li> <p>Counters wrap around at overflow and underflow operations.</p> </li> <li> <p>Counters are initialized to zero.</p> </li> <li> <p>Write operations guarantee atomicity. No intermediate results can be seen from a single write operation.</p> </li> <li> <p>Two types of counter arrays can be created with options <code>atomics</code> or <code>write_concurrency</code>. The <code>atomics</code> counters have good allround performance with nice consistent semantics while <code>write_concurrency</code> counters offers even better concurrent write performance at the expense of some potential read inconsistencies. See <code><a href="#new-2">new/2</a></code>.</p> </li> <li> <p>Indexes into counter arrays are one-based. A counter array of size N contains N counters with index from 1 to N.</p> </li> </ul> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-counters_ref" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-counters_ref">counters_ref()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Identifies a counter array returned from <code><a href="#new-2">new/2</a></code>.</p> </div></div></article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="new-2" class="bold_code title-link func-head">  <code>new(Size, Opts) -&gt; <code><a href="#type-counters_ref">counters_ref()</a></code></code><div class="title-since"><span class="since">OTP 21.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Size = <a href="erlang.html#type-pos_integer">integer() &gt;= 1</a></code></div> <div class="REFTYPES rt-1"><code>Opts = [Opt]</code></div> <div class="REFTYPES rt-1"><code>Opt = atomics | write_concurrency</code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Create a new counter array of <code>Size</code> counters. All counters in the array are initially set to zero.</p> <p>Argument <code>Opts</code> is a list of the following possible options:</p> <dl> <dt class="title-link"><strong><code>atomics</code> (Default)</strong></dt> <dd> <p>Counters will be sequentially consistent. If write operation A is done sequentially before write operation B, then a concurrent reader may see the result of none of them, only A, or both A and B. It cannot see the result of only B.</p> </dd> <dt class="title-link"><strong><code>write_concurrency</code></strong></dt> <dd> <p>This is an optimization to achieve very efficient concurrent <code><a href="#add-3">add</a></code> and <code><a href="#sub-3">sub</a></code> operations at the expense of potential read inconsistency and memory consumption per counter.</p> <p>Read operations may see sequentially inconsistent results with regard to concurrent write operations. Even if write operation A is done sequentially before write operation B, a concurrent reader may see any combination of A and B, including only B. A read operation is only guaranteed to see all writes done sequentially before the read. No writes are ever lost, but will eventually all be seen.</p> <p>The typical use case for <code>write_concurrency</code> is when concurrent calls to <code><a href="#add-3">add</a></code> and <code><a href="#sub-3">sub</a></code> toward the same counters are very frequent, while calls to <code><a href="#get-2">get </a></code> and <code><a href="#put-3">put</a></code> are much less frequent. The lack of absolute read consistency must also be acceptable.</p> </dd> </dl> <p>Counters are not tied to the current process and are automatically garbage collected when they are no longer referenced.</p> </div></div></article><article class="func"><h3 id="get-2" class="bold_code title-link func-head">  <code>get(Ref, Ix) -&gt; <code><a href="erlang.html#type-integer">integer()</a></code></code><div class="title-since"><span class="since">OTP 21.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Ref = <a href="#type-counters_ref">counters_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Ix = <a href="erlang.html#type-integer">integer()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Read counter value.</p> </div></div></article><article class="func"><h3 id="add-3" class="bold_code title-link func-head">  <code>add(Ref, Ix, Incr) -&gt; ok</code><div class="title-since"><span class="since">OTP 21.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Ref = <a href="#type-counters_ref">counters_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Ix = Incr = <a href="erlang.html#type-integer">integer()</a></code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Add <code>Incr</code> to counter at index <code>Ix</code>.</p> </div></div></article><article class="func"><h3 id="sub-3" class="bold_code title-link func-head">  <code>sub(Ref, Ix, Decr) -&gt; ok</code><div class="title-since"><span class="since">OTP 21.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Ref = <a href="#type-counters_ref">counters_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Ix = Decr = <a href="erlang.html#type-integer">integer()</a></code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Subtract <code>Decr</code> from counter at index <code>Ix</code>.</p> </div></div></article><article class="func"><h3 id="put-3" class="bold_code title-link func-head">  <code>put(Ref, Ix, Value) -&gt; ok</code><div class="title-since"><span class="since">OTP 21.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Ref = <a href="#type-counters_ref">counters_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Ix = Value = <a href="erlang.html#type-integer">integer()</a></code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Write <code>Value</code> to counter at index <code>Ix</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Despite its name, the <code>write_concurrency</code> optimization does not improve <code>put</code>. A call to <code>put</code> is a relatively heavy operation compared to the very lightweight and scalable <code><a href="#add-3">add</a></code> and <code><a href="#sub-3"> sub</a></code>. The cost for a <code>put</code> with <code>write_concurrency</code> is like a <code><a href="#get-2">get </a></code> plus a <code>put</code> without <code>write_concurrency</code>.</p> </div> </div> </div></div></article><article class="func"><h3 id="info-1" class="bold_code title-link func-head">  <code>info(Ref) -&gt; Info</code><div class="title-since"><span class="since">OTP 21.2</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Ref = <a href="#type-counters_ref">counters_ref()</a></code></div> <div class="REFTYPES rt-1"><code>Info = #{size := Size, memory := Memory}</code></div> <div class="REFTYPES rt-1"><code>Size = Memory = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div>  </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Return information about a counter array in a map. The map has the following keys (at least):</p> <dl> <dt class="title-link"><strong><code>size</code></strong></dt> <dd><p>The number of counters in the array.</p></dd> <dt class="title-link"><strong><code>memory</code></strong></dt> <dd><p>Approximate memory consumption for the array in bytes.</p></dd> </dl> </div></div></article> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
