  <div class="innertube"> <h2 id="module" class="title-link"> <div class="title-name">Module</div>  </h2> <div class="REFBODY module-body">zlib</div> </div> <div class="innertube"> <h2 id="module-summary" class="title-link"> <div class="title-name">Module Summary</div>  </h2> <div class="REFBODY module-summary-body">zlib compression interface.</div> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link"> <div class="title-name">Description</div>  </h2> <div class="REFBODY description-body">

<p>This module provides an API for the zlib library (<code><a href="http://www.zlib.net">www.zlib.net</a></code>). It is used to compress and decompress data. The data format is described by <code><a href="https://www.ietf.org/rfc/rfc1950.txt">RFC 1950</a></code>, <code><a href="https://www.ietf.org/rfc/rfc1951.txt">RFC 1951</a></code>, and <code><a href="https://www.ietf.org/rfc/rfc1952.txt">RFC 1952</a></code>.</p> <p>A typical (compress) usage is as follows:</p> <pre data-language="erlang">
Z = zlib:open(),
ok = zlib:deflateInit(Z,default),

Compress = fun(end_of_data, _Cont) -&gt; [];
              (Data, Cont) -&gt;
                 [zlib:deflate(Z, Data)|Cont(Read(),Cont)]
           end,
Compressed = Compress(Read(),Compress),
Last = zlib:deflate(Z, [], finish),
ok = zlib:deflateEnd(Z),
zlib:close(Z),
list_to_binary([Compressed|Last])</pre> <p>In all functions errors, <code>{'EXIT',{Reason,Backtrace}}</code>, can be thrown, where <code>Reason</code> describes the error.</p> <p>Typical <code>Reason</code>s:</p> <dl> <dt class="title-link"><strong><code>badarg</code></strong></dt> <dd>Bad argument. </dd> <dt class="title-link"><strong><code>not_initialized</code></strong></dt> <dd>The stream hasn't been initialized, eg. if <code><a href="#inflateInit-1">inflateInit/1</a></code> wasn't called prior to a call to <code><a href="#inflate-2">inflate/2</a></code>. </dd> <dt class="title-link"><strong><code>not_on_controlling_process</code></strong></dt> <dd>The stream was used by a process that doesn't control it. Use <code><a href="#set_controlling_process-2"> set_controlling_process/2</a></code> if you need to transfer a stream to a different process.</dd> <dt class="title-link"><strong><code>data_error</code></strong></dt> <dd>The data contains errors. </dd> <dt class="title-link"><strong><code>stream_error</code></strong></dt> <dd>Inconsistent stream state.</dd> <dt class="title-link"><strong><code>{need_dictionary,Adler32}</code></strong></dt> <dd>See <code><a href="#inflate-2">inflate/2</a></code>. </dd> </dl> </div> </div></section> <div class="innertube"> <h2 id="data-types" class="title-link"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h3 id="type-zstream" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-zstream">zstream()</a> = <a href="erlang.html#type-reference">reference()</a></code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>A zlib stream, see <code><a href="#open-0">open/0</a></code>. </p> </div></div></article> <article class="data-types-body"><h3 id="type-zlevel" class="title-link data-type-name">  <div class="title-name"> <pre data-language="erlang"><code><a name="type-zlevel">zlevel()</a> = 
 none | default | best_compression | best_speed | 0..9</code></pre>
<br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-zflush" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-zflush">zflush()</a> = none | sync | full | finish</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-zmemlevel" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-zmemlevel">zmemlevel()</a> = 1..9</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-zmethod" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-zmethod">zmethod()</a> = deflated</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-zstrategy" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-zstrategy">zstrategy()</a> = default | filtered | huffman_only | rle</code><br> </div> </h3> </article> <article class="data-types-body"><h3 id="type-zwindowbits" class="title-link data-type-name">  <div class="title-name"> <code><a name="type-zwindowbits">zwindowbits()</a> = -15..-8 | 8..47</code><br> </div> </h3> <div class="data-type-desc"><div class="REFBODY rb-7"> <p>Normally in the range <code>-15..-8 | 8..15</code>.</p> </div></div></article> </div> <div class="innertube"><h2 id="export" class="title-link"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h3 id="adler32-2" class="bold_code title-link func-head">  <code>adler32(Z, Data) -&gt; CheckSum</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>CheckSum = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Calculates the Adler-32 checksum for <code>Data</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release. Use <code> erlang:adler32/1</code> instead.</p> </div> </div> </div></div></article><article class="func"><h3 id="adler32-3" class="bold_code title-link func-head">  <code>adler32(Z, PrevAdler, Data) -&gt; CheckSum</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>PrevAdler = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>CheckSum = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Updates a running Adler-32 checksum for <code>Data</code>. If <code>Data</code> is the empty binary or the empty iolist, this function returns the required initial value for the checksum.</p> <p>Example:</p> <pre data-language="erlang">
Crc = lists:foldl(fun(Data,Crc0) -&gt;
                      zlib:adler32(Z, Crc0, Data),
                  end, zlib:adler32(Z,&lt;&lt; &gt;&gt;), Datas)</pre> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release. Use <code> erlang:adler32/2</code> instead.</p> </div> </div> </div></div></article><article class="func"><h3 id="adler32_combine-4" class="bold_code title-link func-head">  <code>adler32_combine(Z, Adler1, Adler2, Size2) -&gt; Adler</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Adler = Adler1 = Adler2 = Size2 = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div>    </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Combines two Adler-32 checksums into one. For two binaries or iolists, <code>Data1</code> and <code>Data2</code> with sizes of <code>Size1</code> and <code>Size2</code>, with Adler-32 checksums <code>Adler1</code> and <code>Adler2</code>.</p> <p>This function returns the <code>Adler</code> checksum of <code>[Data1,Data2]</code>, requiring only <code>Adler1</code>, <code>Adler2</code>, and <code>Size2</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release. Use <code> erlang:adler32_combine/3</code> instead.</p> </div> </div> </div></div></article><article class="func"><h3 id="close-1" class="bold_code title-link func-head">  <code>close(Z) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Closes the stream referenced by <code>Z</code>.</p> </div></div></article><article class="func"><h3 id="compress-1" class="bold_code title-link func-head">  <code>compress(Data) -&gt; Compressed</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Compressed = <a href="erlang.html#type-binary">binary()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Compresses data with zlib headers and checksum.</p> </div></div></article><article class="func"><h3 id="crc32-1" class="bold_code title-link func-head">  <code>crc32(Z) -&gt; CRC</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>CRC = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Gets the current calculated CRC checksum.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release. Use <code> erlang:crc32/1</code> on the uncompressed data instead.</p> </div> </div> </div></div></article><article class="func"><h3 id="crc32-2" class="bold_code title-link func-head">  <code>crc32(Z, Data) -&gt; CRC</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>CRC = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Calculates the CRC checksum for <code>Data</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release. Use <code> erlang:crc32/1</code> instead.</p> </div> </div> </div></div></article><article class="func"><h3 id="crc32-3" class="bold_code title-link func-head">  <code>crc32(Z, PrevCRC, Data) -&gt; CRC</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>PrevCRC = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>CRC = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Updates a running CRC checksum for <code>Data</code>. If <code>Data</code> is the empty binary or the empty iolist, this function returns the required initial value for the CRC.</p> <p>Example:</p> <pre data-language="erlang">
Crc = lists:foldl(fun(Data,Crc0) -&gt;
                      zlib:crc32(Z, Crc0, Data),
                  end, zlib:crc32(Z,&lt;&lt; &gt;&gt;), Datas)</pre> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release. Use <code> erlang:crc32/2</code> instead.</p> </div> </div> </div></div></article><article class="func"><h3 id="crc32_combine-4" class="bold_code title-link func-head">  <code>crc32_combine(Z, CRC1, CRC2, Size2) -&gt; CRC</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>CRC = CRC1 = CRC2 = Size2 = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div>    </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Combines two CRC checksums into one. For two binaries or iolists, <code>Data1</code> and <code>Data2</code> with sizes of <code>Size1</code> and <code>Size2</code>, with CRC checksums <code>CRC1</code> and <code>CRC2</code>.</p> <p>This function returns the <code>CRC</code> checksum of <code>[Data1,Data2]</code>, requiring only <code>CRC1</code>, <code>CRC2</code>, and <code>Size2</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release. Use <code> erlang:crc32_combine/3</code> instead.</p> </div> </div> </div></div></article><article class="func"><h3 id="deflate-2" class="bold_code title-link func-head">  <code>deflate(Z, Data) -&gt; Compressed</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Compressed = <a href="erlang.html#type-iolist">iolist()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Same as <code>deflate(Z, Data, none)</code>.</p> </div></div></article><article class="func"><h3 id="deflate-3" class="bold_code title-link func-head">  <code>deflate(Z, Data, Flush) -&gt; Compressed</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Flush = <a href="#type-zflush">zflush()</a></code></div> <div class="REFTYPES rt-1"><code>Compressed = <a href="erlang.html#type-iolist">iolist()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Compresses as much data as possible, and stops when the input buffer becomes empty. It can introduce some output latency (reading input without producing any output) except when forced to flush.</p> <p>If <code>Flush</code> is set to <code>sync</code>, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. Flushing can degrade compression for some compression algorithms; thus, use it only when necessary.</p> <p>If <code>Flush</code> is set to <code>full</code>, all output is flushed as with <code>sync</code>, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using <code>full</code> too often can seriously degrade the compression.</p> <p>If <code>Flush</code> is set to <code>finish</code>, pending input is processed, pending output is flushed, and <code>deflate/3</code> returns. Afterwards the only possible operations on the stream are <code><a href="#deflateReset-1">deflateReset/1</a></code> or <code><a href="#deflateEnd-1">deflateEnd/1</a></code>.</p> <p><code>Flush</code> can be set to <code>finish</code> immediately after <code><a href="#deflateInit-1">deflateInit</a></code> if all compression is to be done in one step.</p> <p>Example:</p> <pre data-language="erlang">
zlib:deflateInit(Z),
B1 = zlib:deflate(Z,Data),
B2 = zlib:deflate(Z,&lt;&lt; &gt;&gt;,finish),
zlib:deflateEnd(Z),
list_to_binary([B1,B2])</pre> </div></div></article><article class="func"><h3 id="deflateEnd-1" class="bold_code title-link func-head">  <code>deflateEnd(Z) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Ends the deflate session and cleans all data used. Notice that this function throws a <code>data_error</code> exception if the last call to <code><a href="#deflate-3">deflate/3</a></code> was not called with <code>Flush</code> set to <code>finish</code>.</p> </div></div></article><article class="func"><h3 id="deflateInit-1" class="bold_code title-link func-head">  <code>deflateInit(Z) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Same as <code>zlib:deflateInit(Z, default)</code>.</p> </div></div></article><article class="func"><h3 id="deflateInit-2" class="bold_code title-link func-head">  <code>deflateInit(Z, Level) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Level = <a href="#type-zlevel">zlevel()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Initializes a zlib stream for compression.</p> <p><code>Level</code> decides the compression level to be used:</p> <ul> <li> <code>default</code> gives default compromise between speed and compression</li> <li> <code>none</code> (0) gives no compression</li> <li> <code>best_speed</code> (1) gives best speed</li> <li> <code>best_compression</code> (9) gives best compression</li> </ul> </div></div></article><article class="func"><h3 id="deflateInit-6" class="bold_code title-link func-head">  <pre data-language="erlang"><code>deflateInit(Z, Level, Method, WindowBits, MemLevel, Strategy) -&gt;
 ok</code></pre> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Level = <a href="#type-zlevel">zlevel()</a></code></div> <div class="REFTYPES rt-1"><code>Method = <a href="#type-zmethod">zmethod()</a></code></div> <div class="REFTYPES rt-1"><code>WindowBits = <a href="#type-zwindowbits">zwindowbits()</a></code></div> <div class="REFTYPES rt-1"><code>MemLevel = <a href="#type-zmemlevel">zmemlevel()</a></code></div> <div class="REFTYPES rt-1"><code>Strategy = <a href="#type-zstrategy">zstrategy()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Initiates a zlib stream for compression.</p> <dl> <dt class="title-link"><strong><code>Level</code></strong></dt> <dd> <p>Compression level to use:</p> <ul> <li> <code>default</code> gives default compromise between speed and compression</li> <li> <code>none</code> (0) gives no compression</li> <li> <code>best_speed</code> (1) gives best speed</li> <li> <code>best_compression</code> (9) gives best compression</li> </ul> </dd> <dt class="title-link"><strong><code>Method</code></strong></dt> <dd> <p>Compression method to use, currently the only supported method is <code>deflated</code>.</p> </dd> <dt class="title-link"><strong><code>WindowBits</code></strong></dt> <dd> <p>The base two logarithm of the window size (the size of the history buffer). It is to be in the range 8 through 15. Larger values result in better compression at the expense of memory usage. Defaults to 15 if <code><a href="#deflateInit-2"> deflateInit/2</a></code> is used. A negative <code>WindowBits</code> value suppresses the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Due to a known bug in the underlying zlib library, <code>WindowBits</code> values 8 and -8 do not work as expected. In zlib versions before 1.2.9 values 8 and -8 are automatically changed to 9 and -9. <strong>From zlib version 1.2.9 value -8 is rejected</strong> causing <code>zlib:deflateInit/6</code> to fail (8 is still changed to 9). It also seem possible that future versions of zlib may fix this bug and start accepting 8 and -8 as is.</p> <p>Conclusion: Avoid values 8 and -8 unless you know your zlib version supports them.</p> </div> </div> </dd> <dt class="title-link"><strong><code>MemLevel</code></strong></dt> <dd> <p>Specifies how much memory is to be allocated for the internal compression state: <code>MemLevel</code>=1 uses minimum memory but is slow and reduces compression ratio; <code>MemLevel</code>=9 uses maximum memory for optimal speed. Defaults to 8.</p> </dd> <dt class="title-link"><strong><code>Strategy</code></strong></dt> <dd> <p>Tunes the compression algorithm. Use the following values:</p> <ul> <li> <code>default</code> for normal data</li> <li> <code>filtered</code> for data produced by a filter (or predictor)</li> <li> <code>huffman_only</code> to force Huffman encoding only (no string match)</li> <li> <code>rle</code> to limit match distances to one (run-length encoding)</li> </ul> <p>Filtered data consists mostly of small values with a somewhat random distribution. In this case, the compression algorithm is tuned to compress them better. The effect of <code>filtered</code> is to force more Huffman coding and less string matching; it is somewhat intermediate between <code>default</code> and <code>huffman_only</code>. <code>rle</code> is designed to be almost as fast as <code>huffman_only</code>, but gives better compression for PNG image data.</p> <p><code>Strategy</code> affects only the compression ratio, but not the correctness of the compressed output even if it is not set appropriately.</p> </dd> </dl> </div></div></article><article class="func"><h3 id="deflateParams-3" class="bold_code title-link func-head">  <code>deflateParams(Z, Level, Strategy) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Level = <a href="#type-zlevel">zlevel()</a></code></div> <div class="REFTYPES rt-1"><code>Strategy = <a href="#type-zstrategy">zstrategy()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Dynamically updates the compression level and compression strategy. The interpretation of <code>Level</code> and <code>Strategy</code> is as in <code><a href="#deflateInit-6">deflateInit/6</a></code>. This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data requiring a different strategy. If the compression level is changed, the input available so far is compressed with the old level (and can be flushed); the new level takes effect only at the next call of <code><a href="#deflate-3">deflate/3</a></code>.</p> <p>Before the call of <code>deflateParams</code>, the stream state must be set as for a call of <code>deflate/3</code>, as the currently available input may have to be compressed and flushed.</p> </div></div></article><article class="func"><h3 id="deflateReset-1" class="bold_code title-link func-head">  <code>deflateReset(Z) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Equivalent to <code><a href="#deflateEnd-1">deflateEnd/1</a></code> followed by <code><a href="#deflateInit-1">deflateInit/1,2,6</a></code>, but does not free and reallocate all the internal compression state. The stream keeps the same compression level and any other attributes.</p> </div></div></article><article class="func"><h3 id="deflateSetDictionary-2" class="bold_code title-link func-head">  <code>deflateSetDictionary(Z, Dictionary) -&gt; Adler32</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Dictionary = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Adler32 = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Initializes the compression dictionary from the specified byte sequence without producing any compressed output.</p> <p>This function must be called immediately after <code><a href="#deflateInit-1">deflateInit/1,2,6</a></code> or <code><a href="#deflateReset-1">deflateReset/1</a></code>, before any call of <code><a href="#deflate-3">deflate/3</a></code>.</p> <p>The compressor and decompressor must use the same dictionary (see <code><a href="#inflateSetDictionary-2"> inflateSetDictionary/2</a></code>).</p> <p>The Adler checksum of the dictionary is returned.</p> </div></div></article><article class="func"><h3 id="getBufSize-1" class="bold_code title-link func-head">  <code>getBufSize(Z) -&gt; <code><a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Gets the size of the intermediate buffer.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release.</p> </div> </div> </div></div></article><article class="func"><h3 id="gunzip-1" class="bold_code title-link func-head">  <code>gunzip(Data) -&gt; Decompressed</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Decompressed = <a href="erlang.html#type-binary">binary()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uncompresses data with gz headers and checksum.</p> </div></div></article><article class="func"><h3 id="gzip-1" class="bold_code title-link func-head">  <code>gzip(Data) -&gt; Compressed</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Compressed = <a href="erlang.html#type-binary">binary()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Compresses data with gz headers and checksum.</p> </div></div></article><article class="func"><h3 id="inflate-2" class="bold_code title-link func-head">  <code>inflate(Z, Data) -&gt; Decompressed</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Decompressed = <a href="erlang.html#type-iolist">iolist()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Equivalent to <code><a href="#inflate-3">inflate(Z, Data, [])</a></code> </p> </div></div></article><article class="func"><h3 id="inflate-3" class="bold_code title-link func-head">  <code>inflate(Z, Data, Options) -&gt; Decompressed</code><div class="title-since"><span class="since">OTP 20.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Options = [{exception_on_need_dict, <a href="erlang.html#type-boolean">boolean()</a>}]</code></div> <div class="REFTYPES rt-1"><pre><code>Decompressed = 
 <a href="erlang.html#type-iolist">iolist()</a> |
 {need_dictionary,
 Adler32 :: <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a>,
 Output :: <a href="erlang.html#type-iolist">iolist()</a>}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Decompresses as much data as possible. It can introduce some output latency (reading input without producing any output).</p> <p>Currently the only available option is <code>{exception_on_need_dict,boolean()}</code> which controls whether the function should throw an exception when a preset dictionary is required for decompression. When set to false, a <code>need_dictionary</code> tuple will be returned instead. See <code><a href="#inflateSetDictionary-2"> inflateSetDictionary/2</a></code> for details.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This option defaults to <code>true</code> for backwards compatibility but we intend to remove the exception behavior in a future release. New code that needs to handle dictionaries manually should always specify <code>{exception_on_need_dict,false}</code>.</p> </div> </div> </div></div></article><article class="func"><h3 id="inflateChunk-1" class="bold_code title-link func-head">  <code>inflateChunk(Z) -&gt; Decompressed | {more, Decompressed}</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Decompressed = <a href="erlang.html#type-iolist">iolist()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release. Use <code><a href="#safeInflate-2">safeInflate/2 </a></code> instead.</p> </div> </div> <p>Reads the next chunk of uncompressed data, initialized by <code><a href="#inflateChunk-2">inflateChunk/2</a></code>.</p> <p>This function is to be repeatedly called, while it returns <code>{more, Decompressed}</code>.</p> </div></div></article><article class="func"><h3 id="inflateChunk-2" class="bold_code title-link func-head">  <code>inflateChunk(Z, Data) -&gt; Decompressed | {more, Decompressed}</code><div class="title-since"><span class="since">OTP 18.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Decompressed = <a href="erlang.html#type-iolist">iolist()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release. Use <code><a href="#safeInflate-2">safeInflate/2 </a></code> instead.</p> </div> </div> <p>Like <code><a href="#inflate-2">inflate/2</a></code>, but decompresses no more data than will fit in the buffer configured through <code><a href="#setBufSize-2">setBufSize/2 </a></code>. Is is useful when decompressing a stream with a high compression ratio, such that a small amount of compressed input can expand up to 1000 times.</p> <p>This function returns <code>{more, Decompressed}</code>, when there is more output available, and <code><a href="#inflateChunk-1">inflateChunk/1</a></code> is to be used to read it.</p> <p>This function can introduce some output latency (reading input without producing any output).</p> <p>An exception will be thrown if a preset dictionary is required for further decompression. See <code><a href="#inflateSetDictionary-2"> inflateSetDictionary/2</a></code> for details.</p> <p>Example:</p> <pre data-language="erlang">
walk(Compressed, Handler) -&gt;
    Z = zlib:open(),
    zlib:inflateInit(Z),
    % Limit single uncompressed chunk size to 512kb
    zlib:setBufSize(Z, 512 * 1024),
    loop(Z, Handler, zlib:inflateChunk(Z, Compressed)),
    zlib:inflateEnd(Z),
    zlib:close(Z).

loop(Z, Handler, {more, Uncompressed}) -&gt;
    Handler(Uncompressed),
    loop(Z, Handler, zlib:inflateChunk(Z));
loop(Z, Handler, Uncompressed) -&gt;
    Handler(Uncompressed).</pre> </div></div></article><article class="func"><h3 id="inflateEnd-1" class="bold_code title-link func-head">  <code>inflateEnd(Z) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Ends the inflate session and cleans all data used. Notice that this function throws a <code>data_error</code> exception if no end of stream was found (meaning that not all data has been uncompressed).</p> </div></div></article><article class="func"><h3 id="inflateGetDictionary-1" class="bold_code title-link func-head">  <code>inflateGetDictionary(Z) -&gt; Dictionary</code><div class="title-since"><span class="since">OTP 20.0</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Dictionary = <a href="erlang.html#type-binary">binary()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Returns the decompression dictionary currently in use by the stream. This function must be called between <code><a href="#inflateInit-1">inflateInit/1,2</a></code> and <code><a href="#inflateEnd-1">inflateEnd</a></code>.</p> <p>Only supported if ERTS was compiled with zlib &gt;= 1.2.8.</p> </div></div></article><article class="func"><h3 id="inflateInit-1" class="bold_code title-link func-head">  <code>inflateInit(Z) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Initializes a zlib stream for decompression.</p> </div></div></article><article class="func"><h3 id="inflateInit-2" class="bold_code title-link func-head">  <code>inflateInit(Z, WindowBits) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>WindowBits = <a href="#type-zwindowbits">zwindowbits()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Initializes a decompression session on zlib stream.</p> <p><code>WindowBits</code> is the base two logarithm of the maximum window size (the size of the history buffer). It is to be in the range 8 through 15. Default to 15 if <code><a href="#inflateInit-1">inflateInit/1</a></code> is used.</p> <p>If a compressed stream with a larger window size is specified as input, <code><a href="#inflate-2">inflate/2</a></code> throws the <code>data_error</code> exception.</p> <p>A negative <code>WindowBits</code> value makes zlib ignore the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</p> </div></div></article><article class="func"><h3 id="inflateReset-1" class="bold_code title-link func-head">  <code>inflateReset(Z) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Equivalent to <code><a href="#inflateEnd-1">inflateEnd/1</a></code> followed by <code><a href="#inflateInit-1">inflateInit/1</a></code>, but does not free and reallocate all the internal decompression state. The stream will keep attributes that could have been set by <code>inflateInit/1,2</code>.</p> </div></div></article><article class="func"><h3 id="inflateSetDictionary-2" class="bold_code title-link func-head">  <code>inflateSetDictionary(Z, Dictionary) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Dictionary = <a href="erlang.html#type-iodata">iodata()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Initializes the decompression dictionary from the specified uncompressed byte sequence. This function must be called as a response to an inflate operation (eg. <code><a href="#safeInflate-2">safeInflate/2</a></code>) returning <code>{need_dictionary,Adler,Output}</code> or in the case of deprecated functions, throwing an <code>{'EXIT',{{need_dictionary,Adler},_StackTrace}}</code> exception.</p> <p>The dictionary chosen by the compressor can be determined from the Adler value returned or thrown by the call to the inflate function. The compressor and decompressor must use the same dictionary (See <code><a href="#deflateSetDictionary-2"> deflateSetDictionary/2</a></code>).</p> <p>After setting the dictionary the inflate operation should be retried without new input.</p> <p>Example:</p> <pre data-language="erlang">
deprecated_unpack(Z, Compressed, Dict) -&gt;
     case catch zlib:inflate(Z, Compressed) of
          {'EXIT',{{need_dictionary,_DictID},_}} -&gt;
                 ok = zlib:inflateSetDictionary(Z, Dict),
                 Uncompressed = zlib:inflate(Z, []);
          Uncompressed -&gt;
                 Uncompressed
     end.

new_unpack(Z, Compressed, Dict) -&gt;
    case zlib:inflate(Z, Compressed, [{exception_on_need_dict, false}]) of
        {need_dictionary, _DictId, Output} -&gt;
            ok = zlib:inflateSetDictionary(Z, Dict),
            [Output | zlib:inflate(Z, [])];
        Uncompressed -&gt;
            Uncompressed
    end.</pre> </div></div></article><article class="func"><h3 id="open-0" class="bold_code title-link func-head">  <code>open() -&gt; <code><a href="#type-zstream">zstream()</a></code></code> </h3> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Opens a zlib stream.</p> </div></div></article><article class="func"><h3 id="safeInflate-2" class="bold_code title-link func-head">  <code>safeInflate(Z, Data) -&gt; Result</code><div class="title-since"><span class="since">OTP 20.1</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><pre><code>Result = 
 {continue, Output :: <a href="erlang.html#type-iolist">iolist()</a>} |
 {finished, Output :: <a href="erlang.html#type-iolist">iolist()</a>} |
 {need_dictionary,
 Adler32 :: <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a>,
 Output :: <a href="erlang.html#type-iolist">iolist()</a>}</code></pre></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Like <code><a href="#inflate-2">inflate/2</a></code>, but returns once it has expanded beyond a small implementation-defined threshold. It's useful when decompressing untrusted input which could have been maliciously crafted to expand until the system runs out of memory.</p> <p>This function returns <code>{continue | finished, Output}</code>, where Output is the data that was decompressed in this call. New input can be queued up on each call if desired, and the function will return <code>{finished, Output}</code> once all queued data has been decompressed.</p> <p>This function can introduce some output latency (reading input without producing any output).</p> <p>If a preset dictionary is required for further decompression, this function returns a <code>need_dictionary</code> tuple. See <code><a href="#inflateSetDictionary-2"> inflateSetDictionary/2</a></code>) for details.</p> <p>Example:</p> <pre data-language="erlang">
walk(Compressed, Handler) -&gt;
    Z = zlib:open(),
    zlib:inflateInit(Z),
    loop(Z, Handler, zlib:safeInflate(Z, Compressed)),
    zlib:inflateEnd(Z),
    zlib:close(Z).

loop(Z, Handler, {continue, Output}) -&gt;
    Handler(Output),
    loop(Z, Handler, zlib:safeInflate(Z, []));
loop(Z, Handler, {finished, Output}) -&gt;
    Handler(Output).</pre> </div></div></article><article class="func"><h3 id="setBufSize-2" class="bold_code title-link func-head">  <code>setBufSize(Z, Size) -&gt; ok</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Size = <a href="erlang.html#type-non_neg_integer">integer() &gt;= 0</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Sets the intermediate buffer size.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release.</p> </div> </div> </div></div></article><article class="func"><h3 id="set_controlling_process-2" class="bold_code title-link func-head">  <code>set_controlling_process(Z, Pid) -&gt; ok</code><div class="title-since"><span class="since">OTP 20.1.3</span></div> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Z = <a href="#type-zstream">zstream()</a></code></div> <div class="REFTYPES rt-1"><code>Pid = <a href="erlang.html#type-pid">pid()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Changes the controlling process of <code>Z</code> to <code>Pid</code>, which must be a local process.</p> </div></div></article><article class="func"><h3 id="uncompress-1" class="bold_code title-link func-head">  <code>uncompress(Data) -&gt; Decompressed</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Decompressed = <a href="erlang.html#type-binary">binary()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uncompresses data with zlib headers and checksum.</p> </div></div></article><article class="func"><h3 id="unzip-1" class="bold_code title-link func-head">  <code>unzip(Data) -&gt; Decompressed</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Decompressed = <a href="erlang.html#type-binary">binary()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Uncompresses data without zlib headers and checksum.</p> </div></div></article><article class="func"><h3 id="zip-1" class="bold_code title-link func-head">  <code>zip(Data) -&gt; Compressed</code> </h3> <div class="REFBODY fun-types"> <h4 id="types" class="func-types-title">Types</h4> <div class="REFTYPES rt-1"><code>Data = <a href="erlang.html#type-iodata">iodata()</a></code></div> <div class="REFTYPES rt-1"><code>Compressed = <a href="erlang.html#type-binary">binary()</a></code></div> </div> <div class="exports-tube"><div class="REFBODY rb-7"> <p>Compresses data without zlib headers and checksum.</p> </div></div></article> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
