<h1 class="wp-block-wporg-code-reference-title">
<span class="keyword">class</span> WP_HTML_Processor {}</h1> <section><p>Core class used to safely parse and modify an HTML document.</p> </section> <section><h2 id="description">Description</h2> <p>The HTML Processor class properly parses and modifies HTML5 documents.</p> <p>It supports a subset of the HTML5 specification, and when it encounters unsupported markup, it aborts early to avoid unintentionally breaking the document. The HTML Processor should never break an HTML document.</p> <p>While the <code>WP_HTML_Tag_Processor</code> is a valuable tool for modifying attributes on individual HTML tags, the HTML Processor is more capable and useful for the following operations:</p> <ul> <li>Querying based on nested HTML structure.</li> </ul> <p>Eventually the HTML Processor will also support:</p> <ul> <li>Wrapping a tag in surrounding HTML.</li> <li>Unwrapping a tag by removing its parent.</li> <li>Inserting and removing nodes.</li> <li>Reading and changing inner content.</li> <li>Navigating up or around HTML structure.</li> </ul> <h2 id="usage">Usage</h2> <p>Use of this class requires three steps:</p> <ol> <li>Call a static creator method with your input HTML document.</li> <li>Find the location in the document you are looking for.</li> <li>Request changes to the document at that location.</li> </ol> <p>Example:</p> 
<pre class="wp-block-code" data-language="php"><code lang="php" class="language-php ">$processor = WP_HTML_Processor::create_fragment( $html );
if ( $processor-&gt;next_tag( array( 'breadcrumbs' =&gt; array( 'DIV', 'FIGURE', 'IMG' ) ) ) ) {
    $processor-&gt;add_class( 'responsive-image' );
}</code></pre> <h4>Breadcrumbs</h4> <p>Breadcrumbs represent the stack of open elements from the root of the document or fragment down to the currently-matched node, if one is currently selected. Call WP_HTML_Processor::get_breadcrumbs() to inspect the breadcrumbs for a matched tag.</p> <p>Breadcrumbs can specify nested HTML structure and are equivalent to a CSS selector comprising tag names separated by the child combinator, such as "DIV &gt; FIGURE &gt; IMG".</p> <p>Since all elements find themselves inside a full HTML document when parsed, the return value from <code>get_breadcrumbs()</code> will always contain any implicit outermost elements. For example, when parsing with <code>create_fragment()</code> in the <code>BODY</code> context (the default), any tag in the given HTML document will contain <code>array( 'HTML', 'BODY', … )</code> in its breadcrumbs.</p> <p>Despite containing the implied outermost elements in their breadcrumbs, tags may be found with the shortest-matching breadcrumb query. That is, <code>array( 'IMG' )</code> matches all IMG elements and <code>array( 'P', 'IMG' )</code> matches all IMG elements directly inside a P element. To ensure that no partial matches erroneously match it’s possible to specify in a query the full breadcrumb match all the way down from the root HTML element.</p> <p>Example:</p> 
<pre class="wp-block-code" data-language="php"><code lang="php" class="language-php line-numbers">$html = '&lt;figure&gt;&lt;img&gt;&lt;figcaption&gt;A &lt;em&gt;lovely&lt;/em&gt; day outside&lt;/figcaption&gt;&lt;/figure&gt;';
//               ----- Matches here.
$processor-&gt;next_tag( array( 'breadcrumbs' =&gt; array( 'FIGURE', 'IMG' ) ) );

$html = '&lt;figure&gt;&lt;img&gt;&lt;figcaption&gt;A &lt;em&gt;lovely&lt;/em&gt; day outside&lt;/figcaption&gt;&lt;/figure&gt;';
//                                  ---- Matches here.
$processor-&gt;next_tag( array( 'breadcrumbs' =&gt; array( 'FIGURE', 'FIGCAPTION', 'EM' ) ) );

$html = '&lt;div&gt;&lt;img&gt;&lt;/div&gt;&lt;img&gt;';
//                       ----- Matches here, because IMG must be a direct child of the implicit BODY.
$processor-&gt;next_tag( array( 'breadcrumbs' =&gt; array( 'BODY', 'IMG' ) ) );</code></pre> <h2 id="html-support">HTML Support</h2> <p>This class implements a small part of the HTML5 specification.<br>It’s designed to operate within its support and abort early whenever encountering circumstances it can’t properly handle. This is the principle way in which this class remains as simple as possible without cutting corners and breaking compliance.</p> <h3 id="supported-elements">Supported elements</h3> <p>If any unsupported element appears in the HTML input the HTML Processor will abort early and stop all processing. This draconian measure ensures that the HTML Processor won’t break any HTML it doesn’t fully understand.</p> <p>The following list specifies the HTML tags that <em>are</em> supported:</p> <ul> <li>Containers: ADDRESS, BLOCKQUOTE, DETAILS, DIALOG, DIV, FOOTER, HEADER, MAIN, MENU, SPAN, SUMMARY.</li> <li>Custom elements: All custom elements are supported. :)</li> <li>Form elements: BUTTON, DATALIST, FIELDSET, INPUT, LABEL, LEGEND, METER, PROGRESS, SEARCH.</li> <li>Formatting elements: B, BIG, CODE, EM, FONT, I, PRE, SMALL, STRIKE, STRONG, TT, U, WBR.</li> <li>Heading elements: H1, H2, H3, H4, H5, H6, HGROUP.</li> <li>Links: A.</li> <li>Lists: DD, DL, DT, LI, OL, UL.</li> <li>Media elements: AUDIO, CANVAS, EMBED, FIGCAPTION, FIGURE, IMG, MAP, PICTURE, SOURCE, TRACK, VIDEO.</li> <li>Paragraph: BR, P.</li> <li>Phrasing elements: ABBR, AREA, BDI, BDO, CITE, DATA, DEL, DFN, INS, MARK, OUTPUT, Q, SAMP, SUB, SUP, TIME, VAR.</li> <li>Sectioning elements: ARTICLE, ASIDE, HR, NAV, SECTION.</li> <li>Templating elements: SLOT.</li> <li>Text decoration: RUBY.</li> <li>Deprecated elements: ACRONYM, BLINK, CENTER, DIR, ISINDEX, KEYGEN, LISTING, MULTICOL, NEXTID, PARAM, SPACER.</li> </ul> <h3 id="supported-markup">Supported markup</h3> <p>Some kinds of non-normative HTML involve reconstruction of formatting elements and re-parenting of mis-nested elements. For example, a DIV tag found inside a TABLE may in fact belong <em>before</em> the table in the DOM. If the HTML Processor encounters such a case it will stop processing.</p> <p>The following list specifies HTML markup that <em>is</em> supported:</p> <ul> <li>Markup involving only those tags listed above.</li> <li>Fully-balanced and non-overlapping tags.</li> <li>HTML with unexpected tag closers.</li> <li>Some unbalanced or overlapping tags.</li> <li>P tags after unclosed P tags.</li> <li>BUTTON tags after unclosed BUTTON tags.</li> <li>A tags after unclosed A tags that don’t involve any active formatting elements.</li> </ul> <h3 id="see-also">See also</h3>
<ul>
<li><a href="wp_html_tag_processor.html">WP_HTML_Tag_Processor</a></li> <li><a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a></li> </ul></section> <section><h2 id="methods">Methods</h2> <section style="margin-top:var(--wp--preset--spacing--20);" id="uses"><figure class="wp-block-table "><table>
<thead><tr>
<th scope="col">Name</th>
<th scope="col">Description</th>
</tr></thead>
<tbody>
<tr class="">
<td><a href="wp_html_processor/__construct.html">WP_HTML_Processor::__construct</a></td>
<td>Constructor.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/add_class.html">WP_HTML_Processor::add_class</a></td>
<td>Adds a new class name to the currently matched tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/bookmark_tag.html">WP_HTML_Processor::bookmark_tag</a></td>
<td>Creates a new bookmark for the currently-matched tag and returns the generated name.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/bookmark_token.html">WP_HTML_Processor::bookmark_token</a></td>
<td>Creates a new bookmark for the currently-matched token and returns the generated name.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/class_list.html">WP_HTML_Processor::class_list</a></td>
<td>Generator for a foreach loop to step through each class name for the matched tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/close_a_p_element.html">WP_HTML_Processor::close_a_p_element</a></td>
<td>Closes a P element.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/create_fragment.html">WP_HTML_Processor::create_fragment</a></td>
<td>Creates an HTML processor in the fragment parsing mode.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/expects_closer.html">WP_HTML_Processor::expects_closer</a></td>
<td>Indicates if the currently-matched node expects a closing token, or if it will self-close on the next step.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/generate_implied_end_tags.html">WP_HTML_Processor::generate_implied_end_tags</a></td>
<td>Closes elements that have implied end tags.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/generate_implied_end_tags_thoroughly.html">WP_HTML_Processor::generate_implied_end_tags_thoroughly</a></td>
<td>Closes elements that have implied end tags, thoroughly.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/get_attribute.html">WP_HTML_Processor::get_attribute</a></td>
<td>Returns the value of a requested attribute from a matched tag opener if that attribute exists.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/get_attribute_names_with_prefix.html">WP_HTML_Processor::get_attribute_names_with_prefix</a></td>
<td>Gets lowercase names of all attributes matching a given prefix in the current tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/get_breadcrumbs.html">WP_HTML_Processor::get_breadcrumbs</a></td>
<td>Computes the HTML breadcrumbs for the currently-matched node, if matched.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/get_comment_type.html">WP_HTML_Processor::get_comment_type</a></td>
<td>Indicates what kind of comment produced the comment node.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/get_current_depth.html">WP_HTML_Processor::get_current_depth</a></td>
<td>Returns the nesting depth of the current location in the document.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/get_last_error.html">WP_HTML_Processor::get_last_error</a></td>
<td>Returns the last error, if any.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/get_modifiable_text.html">WP_HTML_Processor::get_modifiable_text</a></td>
<td>Returns the modifiable text for a matched token, or an empty string.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/get_tag.html">WP_HTML_Processor::get_tag</a></td>
<td>Returns the uppercase name of the matched tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/get_token_name.html">WP_HTML_Processor::get_token_name</a></td>
<td>Returns the node name represented by the token.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/get_token_type.html">WP_HTML_Processor::get_token_type</a></td>
<td>Indicates the kind of matched token, if any.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/has_bookmark.html">WP_HTML_Processor::has_bookmark</a></td>
<td>Checks whether a bookmark with the given name exists.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/has_class.html">WP_HTML_Processor::has_class</a></td>
<td>Returns if a matched tag contains the given ASCII case-insensitive class name.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/has_self_closing_flag.html">WP_HTML_Processor::has_self_closing_flag</a></td>
<td>Indicates if the currently matched tag contains the self-closing flag.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/insert_html_element.html">WP_HTML_Processor::insert_html_element</a></td>
<td>Inserts an HTML element on the stack of open elements.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/is_special.html">WP_HTML_Processor::is_special</a></td>
<td>Returns whether an element of a given name is in the HTML special category.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/is_tag_closer.html">WP_HTML_Processor::is_tag_closer</a></td>
<td>Indicates if the current tag token is a tag closer.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/is_virtual.html">WP_HTML_Processor::is_virtual</a></td>
<td>Indicates if the currently-matched token is virtual, created by a stack operation while processing HTML, rather than a token found in the HTML text itself.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/is_void.html">WP_HTML_Processor::is_void</a></td>
<td>Returns whether a given element is an HTML Void Element</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/matches_breadcrumbs.html">WP_HTML_Processor::matches_breadcrumbs</a></td>
<td>Indicates if the currently-matched tag matches the given breadcrumbs.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/next_tag.html">WP_HTML_Processor::next_tag</a></td>
<td>Finds the next tag matching the $query.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/next_token.html">WP_HTML_Processor::next_token</a></td>
<td>Ensures internal accounting is maintained for HTML semantic rules while the underlying Tag Processor class is seeking to a bookmark.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/reconstruct_active_formatting_elements.html">WP_HTML_Processor::reconstruct_active_formatting_elements</a></td>
<td>Reconstructs the active formatting elements.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/release_bookmark.html">WP_HTML_Processor::release_bookmark</a></td>
<td>Removes a bookmark that is no longer needed.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/remove_attribute.html">WP_HTML_Processor::remove_attribute</a></td>
<td>Remove an attribute from the currently-matched tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/remove_class.html">WP_HTML_Processor::remove_class</a></td>
<td>Removes a class name from the currently matched tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/run_adoption_agency_algorithm.html">WP_HTML_Processor::run_adoption_agency_algorithm</a></td>
<td>Runs the adoption agency algorithm.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/seek.html">WP_HTML_Processor::seek</a></td>
<td>Moves the internal cursor in the HTML Processor to a given bookmark’s location.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/set_attribute.html">WP_HTML_Processor::set_attribute</a></td>
<td>Updates or creates a new attribute on the currently matched tag with the passed value.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/set_bookmark.html">WP_HTML_Processor::set_bookmark</a></td>
<td>Sets a bookmark in the HTML document.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/step.html">WP_HTML_Processor::step</a></td>
<td>Steps through the HTML document and stop at the next tag, if any.</td>
</tr>
<tr class="">
<td><a href="wp_html_processor/step_in_body.html">WP_HTML_Processor::step_in_body</a></td>
<td>Parses next element in the ‘in body’ insertion mode.</td>
</tr>
</tbody>
</table></figure></section> </section> <section><h2 id="source">Source</h2> <pre class="wp-block-code" data-start="139" aria-label="Function source code" data-language="php"><code id="wporg-source-code" lang="php" class="language-php line-numbers"> *
 * @see WP_HTML_Tag_Processor
 * @see https://html.spec.whatwg.org/
 */
class WP_HTML_Processor extends WP_HTML_Tag_Processor {
	/**
	 * The maximum number of bookmarks allowed to exist at any given time.
	 *
	 * HTML processing requires more bookmarks than basic tag processing,
	 * so this class constant from the Tag Processor is overwritten.
	 *
	 * @since 6.4.0
	 *
	 * @var int
	 */
	const MAX_BOOKMARKS = 100;

	/**
	 * Holds the working state of the parser, including the stack of
	 * open elements and the stack of active formatting elements.
	 *
	 * Initialized in the constructor.
	 *
	 * @since 6.4.0
	 *
	 * @var WP_HTML_Processor_State
	 */
	private $state;

	/**
	 * Used to create unique bookmark names.
	 *
	 * This class sets a bookmark for every tag in the HTML document that it encounters.
	 * The bookmark name is auto-generated and increments, starting with `1`. These are
	 * internal bookmarks and are automatically released when the referring WP_HTML_Token
	 * goes out of scope and is garbage-collected.
	 *
	 * @since 6.4.0
	 *
	 * @see WP_HTML_Processor::$release_internal_bookmark_on_destruct
	 *
	 * @var int
	 */
	private $bookmark_counter = 0;

	/**
	 * Stores an explanation for why something failed, if it did.
	 *
	 * @see self::get_last_error
	 *
	 * @since 6.4.0
	 *
	 * @var string|null
	 */
	private $last_error = null;

	/**
	 * Stores context for why the parser bailed on unsupported HTML, if it did.
	 *
	 * @see self::get_unsupported_exception
	 *
	 * @since 6.7.0
	 *
	 * @var WP_HTML_Unsupported_Exception|null
	 */
	private $unsupported_exception = null;

	/**
	 * Releases a bookmark when PHP garbage-collects its wrapping WP_HTML_Token instance.
	 *
	 * This function is created inside the class constructor so that it can be passed to
	 * the stack of open elements and the stack of active formatting elements without
	 * exposing it as a public method on the class.
	 *
	 * @since 6.4.0
	 *
	 * @var Closure|null
	 */
	private $release_internal_bookmark_on_destruct = null;

	/**
	 * Stores stack events which arise during parsing of the
	 * HTML document, which will then supply the "match" events.
	 *
	 * @since 6.6.0
	 *
	 * @var WP_HTML_Stack_Event[]
	 */
	private $element_queue = array();

	/**
	 * Stores the current breadcrumbs.
	 *
	 * @since 6.7.0
	 *
	 * @var string[]
	 */
	private $breadcrumbs = array();

	/**
	 * Current stack event, if set, representing a matched token.
	 *
	 * Because the parser may internally point to a place further along in a document
	 * than the nodes which have already been processed (some "virtual" nodes may have
	 * appeared while scanning the HTML document), this will point at the "current" node
	 * being processed. It comes from the front of the element queue.
	 *
	 * @since 6.6.0
	 *
	 * @var WP_HTML_Stack_Event|null
	 */
	private $current_element = null;

	/**
	 * Context node if created as a fragment parser.
	 *
	 * @var WP_HTML_Token|null
	 */
	private $context_node = null;

	/*
	 * Public Interface Functions
	 */

	/**
	 * Creates an HTML processor in the fragment parsing mode.
	 *
	 * Use this for cases where you are processing chunks of HTML that
	 * will be found within a bigger HTML document, such as rendered
	 * block output that exists within a post, `the_content` inside a
	 * rendered site layout.
	 *
	 * Fragment parsing occurs within a context, which is an HTML element
	 * that the document will eventually be placed in. It becomes important
	 * when special elements have different rules than others, such as inside
	 * a TEXTAREA or a TITLE tag where things that look like tags are text,
	 * or inside a SCRIPT tag where things that look like HTML syntax are JS.
	 *
	 * The context value should be a representation of the tag into which the
	 * HTML is found. For most cases this will be the body element. The HTML
	 * form is provided because a context element may have attributes that
	 * impact the parse, such as with a SCRIPT tag and its `type` attribute.
	 *
	 * ## Current HTML Support
	 *
	 *  - The only supported context is `&lt;body&gt;`, which is the default value.
	 *  - The only supported document encoding is `UTF-8`, which is the default value.
	 *
	 * @since 6.4.0
	 * @since 6.6.0 Returns `static` instead of `self` so it can create subclass instances.
	 *
	 * @param string $html     Input HTML fragment to process.
	 * @param string $context  Context element for the fragment, must be default of `&lt;body&gt;`.
	 * @param string $encoding Text encoding of the document; must be default of 'UTF-8'.
	 * @return static|null The created processor if successful, otherwise null.
	 */
	public static function create_fragment( $html, $context = '&lt;body&gt;', $encoding = 'UTF-8' ) {
		if ( '&lt;body&gt;' !== $context || 'UTF-8' !== $encoding ) {
			return null;
		}

		$processor                             = new static( $html, self::CONSTRUCTOR_UNLOCK_CODE );
		$processor-&gt;state-&gt;context_node        = array( 'BODY', array() );
		$processor-&gt;state-&gt;insertion_mode      = WP_HTML_Processor_State::INSERTION_MODE_IN_BODY;
		$processor-&gt;state-&gt;encoding            = $encoding;
		$processor-&gt;state-&gt;encoding_confidence = 'certain';

		// @todo Create "fake" bookmarks for non-existent but implied nodes.
		$processor-&gt;bookmarks['root-node']    = new WP_HTML_Span( 0, 0 );
		$processor-&gt;bookmarks['context-node'] = new WP_HTML_Span( 0, 0 );

		$root_node = new WP_HTML_Token(
			'root-node',
			'HTML',
			false
		);

		$processor-&gt;state-&gt;stack_of_open_elements-&gt;push( $root_node );

		$context_node = new WP_HTML_Token(
			'context-node',
			$processor-&gt;state-&gt;context_node[0],
			false
		);

		$processor-&gt;context_node = $context_node;
		$processor-&gt;breadcrumbs  = array( 'HTML', $context_node-&gt;node_name );

		return $processor;
	}

	/**
	 * Creates an HTML processor in the full parsing mode.
	 *
	 * It's likely that a fragment parser is more appropriate, unless sending an
	 * entire HTML document from start to finish. Consider a fragment parser with
	 * a context node of `&lt;body&gt;`.
	 *
	 * Since UTF-8 is the only currently-accepted charset, if working with a
	 * document that isn't UTF-8, it's important to convert the document before
	 * creating the processor: pass in the converted HTML.
	 *
	 * @param string      $html                    Input HTML document to process.
	 * @param string|null $known_definite_encoding Optional. If provided, specifies the charset used
	 *                                             in the input byte stream. Currently must be UTF-8.
	 * @return static|null The created processor if successful, otherwise null.
	 */
	public static function create_full_parser( $html, $known_definite_encoding = 'UTF-8' ) {
		if ( 'UTF-8' !== $known_definite_encoding ) {
			return null;
		}

		$processor                             = new static( $html, self::CONSTRUCTOR_UNLOCK_CODE );
		$processor-&gt;state-&gt;encoding            = $known_definite_encoding;
		$processor-&gt;state-&gt;encoding_confidence = 'certain';

		return $processor;
	}

	/**
	 * Constructor.
	 *
	 * Do not use this method. Use the static creator methods instead.
	 *
	 * @access private
	 *
	 * @since 6.4.0
	 *
	 * @see WP_HTML_Processor::create_fragment()
	 *
	 * @param string      $html                                  HTML to process.
	 * @param string|null $use_the_static_create_methods_instead This constructor should not be called manually.
	 */
	public function __construct( $html, $use_the_static_create_methods_instead = null ) {
		parent::__construct( $html );

		if ( self::CONSTRUCTOR_UNLOCK_CODE !== $use_the_static_create_methods_instead ) {
			_doing_it_wrong(
				__METHOD__,
				sprintf(
					/* translators: %s: WP_HTML_Processor::create_fragment(). */
					__( 'Call %s to create an HTML Processor instead of calling the constructor directly.' ),
					'&lt;code&gt;WP_HTML_Processor::create_fragment()&lt;/code&gt;'
				),
				'6.4.0'
			);
		}

		$this-&gt;state = new WP_HTML_Processor_State();

		$this-&gt;state-&gt;stack_of_open_elements-&gt;set_push_handler(
			function ( WP_HTML_Token $token ): void {
				$is_virtual            = ! isset( $this-&gt;state-&gt;current_token ) || $this-&gt;is_tag_closer();
				$same_node             = isset( $this-&gt;state-&gt;current_token ) &amp;&amp; $token-&gt;node_name === $this-&gt;state-&gt;current_token-&gt;node_name;
				$provenance            = ( ! $same_node || $is_virtual ) ? 'virtual' : 'real';
				$this-&gt;element_queue[] = new WP_HTML_Stack_Event( $token, WP_HTML_Stack_Event::PUSH, $provenance );

				$this-&gt;change_parsing_namespace( $token-&gt;integration_node_type ? 'html' : $token-&gt;namespace );
			}
		);

		$this-&gt;state-&gt;stack_of_open_elements-&gt;set_pop_handler(
			function ( WP_HTML_Token $token ): void {
				$is_virtual            = ! isset( $this-&gt;state-&gt;current_token ) || ! $this-&gt;is_tag_closer();
				$same_node             = isset( $this-&gt;state-&gt;current_token ) &amp;&amp; $token-&gt;node_name === $this-&gt;state-&gt;current_token-&gt;node_name;
				$provenance            = ( ! $same_node || $is_virtual ) ? 'virtual' : 'real';
				$this-&gt;element_queue[] = new WP_HTML_Stack_Event( $token, WP_HTML_Stack_Event::POP, $provenance );

				$adjusted_current_node = $this-&gt;get_adjusted_current_node();

				if ( $adjusted_current_node ) {
					$this-&gt;change_parsing_namespace( $adjusted_current_node-&gt;integration_node_type ? 'html' : $adjusted_current_node-&gt;namespace );
				} else {
					$this-&gt;change_parsing_namespace( 'html' );
				}
			}
		);

		/*
		 * Create this wrapper so that it's possible to pass
		 * a private method into WP_HTML_Token classes without
		 * exposing it to any public API.
		 */
		$this-&gt;release_internal_bookmark_on_destruct = function ( string $name ): void {
			parent::release_bookmark( $name );
		};
	}

	/**
	 * Stops the parser and terminates its execution when encountering unsupported markup.
	 *
	 * @throws WP_HTML_Unsupported_Exception Halts execution of the parser.
	 *
	 * @since 6.7.0
	 *
	 * @param string $message Explains support is missing in order to parse the current node.
	 */
	private function bail( string $message ) {
		$here  = $this-&gt;bookmarks[ $this-&gt;state-&gt;current_token-&gt;bookmark_name ];
		$token = substr( $this-&gt;html, $here-&gt;start, $here-&gt;length );

		$open_elements = array();
		foreach ( $this-&gt;state-&gt;stack_of_open_elements-&gt;stack as $item ) {
			$open_elements[] = $item-&gt;node_name;
		}

		$active_formats = array();
		foreach ( $this-&gt;state-&gt;active_formatting_elements-&gt;walk_down() as $item ) {
			$active_formats[] = $item-&gt;node_name;
		}

		$this-&gt;last_error = self::ERROR_UNSUPPORTED;

		$this-&gt;unsupported_exception = new WP_HTML_Unsupported_Exception(
			$message,
			$this-&gt;state-&gt;current_token-&gt;node_name,
			$here-&gt;start,
			$token,
			$open_elements,
			$active_formats
		);

		throw $this-&gt;unsupported_exception;
	}

	/**
	 * Returns the last error, if any.
	 *
	 * Various situations lead to parsing failure but this class will
	 * return `false` in all those cases. To determine why something
	 * failed it's possible to request the last error. This can be
	 * helpful to know to distinguish whether a given tag couldn't
	 * be found or if content in the document caused the processor
	 * to give up and abort processing.
	 *
	 * Example
	 *
	 *     $processor = WP_HTML_Processor::create_fragment( '&lt;template&gt;&lt;strong&gt;&lt;button&gt;&lt;em&gt;&lt;p&gt;&lt;em&gt;' );
	 *     false === $processor-&gt;next_tag();
	 *     WP_HTML_Processor::ERROR_UNSUPPORTED === $processor-&gt;get_last_error();
	 *
	 * @since 6.4.0
	 *
	 * @see self::ERROR_UNSUPPORTED
	 * @see self::ERROR_EXCEEDED_MAX_BOOKMARKS
	 *
	 * @return string|null The last error, if one exists, otherwise null.
	 */
	public function get_last_error(): ?string {
		return $this-&gt;last_error;
	}

	/**
	 * Returns context for why the parser aborted due to unsupported HTML, if it did.
	 *
	 * This is meant for debugging purposes, not for production use.
	 *
	 * @since 6.7.0
	 *
	 * @see self::$unsupported_exception
	 *
	 * @return WP_HTML_Unsupported_Exception|null
	 */
	public function get_unsupported_exception() {
		return $this-&gt;unsupported_exception;
	}

	/**
	 * Finds the next tag matching the $query.
	 *
	 * @todo Support matching the class name and tag name.
	 *
	 * @since 6.4.0
	 * @since 6.6.0 Visits all tokens, including virtual ones.
	 *
	 * @throws Exception When unable to allocate a bookmark for the next token in the input HTML document.
	 *
	 * @param array|string|null $query {
	 *     Optional. Which tag name to find, having which class, etc. Default is to find any tag.
	 *
	 *     @type string|null $tag_name     Which tag to find, or `null` for "any tag."
	 *     @type string      $tag_closers  'visit' to pause at tag closers, 'skip' or unset to only visit openers.
	 *     @type int|null    $match_offset Find the Nth tag matching all search criteria.
	 *                                     1 for "first" tag, 3 for "third," etc.
	 *                                     Defaults to first tag.
	 *     @type string|null $class_name   Tag must contain this whole class name to match.
	 *     @type string[]    $breadcrumbs  DOM sub-path at which element is found, e.g. `array( 'FIGURE', 'IMG' )`.
	 *                                     May also contain the wildcard `*` which matches a single element, e.g. `array( 'SECTION', '*' )`.
	 * }
	 * @return bool Whether a tag was matched.
	 */
	public function next_tag( $query = null ): bool {
		$visit_closers = isset( $query['tag_closers'] ) &amp;&amp; 'visit' === $query['tag_closers'];

		if ( null === $query ) {
			while ( $this-&gt;next_token() ) {
				if ( '#tag' !== $this-&gt;get_token_type() ) {
					continue;
				}

				if ( ! $this-&gt;is_tag_closer() || $visit_closers ) {
					return true;
				}
			}

			return false;
		}

		if ( is_string( $query ) ) {
			$query = array( 'breadcrumbs' =&gt; array( $query ) );
		}

		if ( ! is_array( $query ) ) {
			_doing_it_wrong(
				__METHOD__,
				__( 'Please pass a query array to this function.' ),
				'6.4.0'
			);
			return false;
		}

		$needs_class = ( isset( $query['class_name'] ) &amp;&amp; is_string( $query['class_name'] ) )
			? $query['class_name']
			: null;

		if ( ! ( array_key_exists( 'breadcrumbs', $query ) &amp;&amp; is_array( $query['breadcrumbs'] ) ) ) {
			while ( $this-&gt;next_token() ) {
				if ( '#tag' !== $this-&gt;get_token_type() ) {
					continue;
				}

				if ( isset( $query['tag_name'] ) &amp;&amp; $query['tag_name'] !== $this-&gt;get_token_name() ) {
					continue;
				}

				if ( isset( $needs_class ) &amp;&amp; ! $this-&gt;has_class( $needs_class ) ) {
					continue;
				}

				if ( ! $this-&gt;is_tag_closer() || $visit_closers ) {
					return true;
				}
			}

			return false;
		}

		$breadcrumbs  = $query['breadcrumbs'];
		$match_offset = isset( $query['match_offset'] ) ? (int) $query['match_offset'] : 1;

		while ( $match_offset &gt; 0 &amp;&amp; $this-&gt;next_token() ) {
			if ( '#tag' !== $this-&gt;get_token_type() || $this-&gt;is_tag_closer() ) {
				continue;
			}

			if ( isset( $needs_class ) &amp;&amp; ! $this-&gt;has_class( $needs_class ) ) {
				continue;
			}

			if ( $this-&gt;matches_breadcrumbs( $breadcrumbs ) &amp;&amp; 0 === --$match_offset ) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Ensures internal accounting is maintained for HTML semantic rules while
	 * the underlying Tag Processor class is seeking to a bookmark.
	 *
	 * This doesn't currently have a way to represent non-tags and doesn't process
	 * semantic rules for text nodes. For access to the raw tokens consider using
	 * WP_HTML_Tag_Processor instead.
	 *
	 * @since 6.5.0 Added for internal support; do not use.
	 *
	 * @access private
	 *
	 * @return bool
	 */
	public function next_token(): bool {
		$this-&gt;current_element = null;

		if ( isset( $this-&gt;last_error ) ) {
			return false;
		}

		/*
		 * Prime the events if there are none.
		 *
		 * @todo In some cases, probably related to the adoption agency
		 *       algorithm, this call to step() doesn't create any new
		 *       events. Calling it again creates them. Figure out why
		 *       this is and if it's inherent or if it's a bug. Looping
		 *       until there are events or until there are no more
		 *       tokens works in the meantime and isn't obviously wrong.
		 */
		if ( empty( $this-&gt;element_queue ) &amp;&amp; $this-&gt;step() ) {
			return $this-&gt;next_token();
		}

		// Process the next event on the queue.
		$this-&gt;current_element = array_shift( $this-&gt;element_queue );
		if ( ! isset( $this-&gt;current_element ) ) {
			// There are no tokens left, so close all remaining open elements.
			while ( $this-&gt;state-&gt;stack_of_open_elements-&gt;pop() ) {
				continue;
			}

			return empty( $this-&gt;element_queue ) ? false : $this-&gt;next_token();
		}

		$is_pop = WP_HTML_Stack_Event::POP === $this-&gt;current_element-&gt;operation;

		/*
		 * The root node only exists in the fragment parser, and closing it
		 * indicates that the parse is complete. Stop before popping it from
		 * the breadcrumbs.
		 */
		if ( 'root-node' === $this-&gt;current_element-&gt;token-&gt;bookmark_name ) {
			return $this-&gt;next_token();
		}

		// Adjust the breadcrumbs for this event.
		if ( $is_pop ) {
			array_pop( $this-&gt;breadcrumbs );
		} else {
			$this-&gt;breadcrumbs[] = $this-&gt;current_element-&gt;token-&gt;node_name;
		}

		// Avoid sending close events for elements which don't expect a closing.
		if ( $is_pop &amp;&amp; ! $this-&gt;expects_closer( $this-&gt;current_element-&gt;token ) ) {
			return $this-&gt;next_token();
		}

		return true;
	}

	/**
	 * Indicates if the current tag token is a tag closer.
	 *
	 * Example:
	 *
	 *     $p = WP_HTML_Processor::create_fragment( '&lt;div&gt;&lt;/div&gt;' );
	 *     $p-&gt;next_tag( array( 'tag_name' =&gt; 'div', 'tag_closers' =&gt; 'visit' ) );
	 *     $p-&gt;is_tag_closer() === false;
	 *
	 *     $p-&gt;next_tag( array( 'tag_name' =&gt; 'div', 'tag_closers' =&gt; 'visit' ) );
	 *     $p-&gt;is_tag_closer() === true;
	 *
	 * @since 6.6.0 Subclassed for HTML Processor.
	 *
	 * @return bool Whether the current tag is a tag closer.
	 */
	public function is_tag_closer(): bool {
		return $this-&gt;is_virtual()
			? ( WP_HTML_Stack_Event::POP === $this-&gt;current_element-&gt;operation &amp;&amp; '#tag' === $this-&gt;get_token_type() )
			: parent::is_tag_closer();
	}

	/**
	 * Indicates if the currently-matched token is virtual, created by a stack operation
	 * while processing HTML, rather than a token found in the HTML text itself.
	 *
	 * @since 6.6.0
	 *
	 * @return bool Whether the current token is virtual.
	 */
	private function is_virtual(): bool {
		return (
			isset( $this-&gt;current_element-&gt;provenance ) &amp;&amp;
			'virtual' === $this-&gt;current_element-&gt;provenance
		);
	}

	/**
	 * Indicates if the currently-matched tag matches the given breadcrumbs.
	 *
	 * A "*" represents a single tag wildcard, where any tag matches, but not no tags.
	 *
	 * At some point this function _may_ support a `**` syntax for matching any number
	 * of unspecified tags in the breadcrumb stack. This has been intentionally left
	 * out, however, to keep this function simple and to avoid introducing backtracking,
	 * which could open up surprising performance breakdowns.
	 *
	 * Example:
	 *
	 *     $processor = WP_HTML_Processor::create_fragment( '&lt;div&gt;&lt;span&gt;&lt;figure&gt;&lt;img&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/div&gt;' );
	 *     $processor-&gt;next_tag( 'img' );
	 *     true  === $processor-&gt;matches_breadcrumbs( array( 'figure', 'img' ) );
	 *     true  === $processor-&gt;matches_breadcrumbs( array( 'span', 'figure', 'img' ) );
	 *     false === $processor-&gt;matches_breadcrumbs( array( 'span', 'img' ) );
	 *     true  === $processor-&gt;matches_breadcrumbs( array( 'span', '*', 'img' ) );
	 *
	 * @since 6.4.0
	 *
	 * @param string[] $breadcrumbs DOM sub-path at which element is found, e.g. `array( 'FIGURE', 'IMG' )`.
	 *                              May also contain the wildcard `*` which matches a single element, e.g. `array( 'SECTION', '*' )`.
	 * @return bool Whether the currently-matched tag is found at the given nested structure.
	 */
	public function matches_breadcrumbs( $breadcrumbs ): bool {
		// Everything matches when there are zero constraints.
		if ( 0 === count( $breadcrumbs ) ) {
			return true;
		}

		// Start at the last crumb.
		$crumb = end( $breadcrumbs );

		if ( '*' !== $crumb &amp;&amp; $this-&gt;get_tag() !== strtoupper( $crumb ) ) {
			return false;
		}

		for ( $i = count( $this-&gt;breadcrumbs ) - 1; $i &gt;= 0; $i-- ) {
			$node  = $this-&gt;breadcrumbs[ $i ];
			$crumb = strtoupper( current( $breadcrumbs ) );

			if ( '*' !== $crumb &amp;&amp; $node !== $crumb ) {
				return false;
			}

			if ( false === prev( $breadcrumbs ) ) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Indicates if the currently-matched node expects a closing
	 * token, or if it will self-close on the next step.
	 *
	 * Most HTML elements expect a closer, such as a P element or
	 * a DIV element. Others, like an IMG element are void and don't
	 * have a closing tag. Special elements, such as SCRIPT and STYLE,
	 * are treated just like void tags. Text nodes and self-closing
	 * foreign content will also act just like a void tag, immediately
	 * closing as soon as the processor advances to the next token.
	 *
	 * @since 6.6.0
	 *
	 * @param WP_HTML_Token|null $node Optional. Node to examine, if provided.
	 *                                 Default is to examine current node.
	 * @return bool|null Whether to expect a closer for the currently-matched node,
	 *                   or `null` if not matched on any token.
	 */
	public function expects_closer( ?WP_HTML_Token $node = null ): ?bool {
		$token_name = $node-&gt;node_name ?? $this-&gt;get_token_name();

		if ( ! isset( $token_name ) ) {
			return null;
		}

		$token_namespace        = $node-&gt;namespace ?? $this-&gt;get_namespace();
		$token_has_self_closing = $node-&gt;has_self_closing_flag ?? $this-&gt;has_self_closing_flag();

		return ! (
			// Comments, text nodes, and other atomic tokens.
			'#' === $token_name[0] ||
			// Doctype declarations.
			'html' === $token_name ||
			// Void elements.
			self::is_void( $token_name ) ||
			// Special atomic elements.
			( 'html' === $token_namespace &amp;&amp; in_array( $token_name, array( 'IFRAME', 'NOEMBED', 'NOFRAMES', 'SCRIPT', 'STYLE', 'TEXTAREA', 'TITLE', 'XMP' ), true ) ) ||
			// Self-closing elements in foreign content.
			( 'html' !== $token_namespace &amp;&amp; $token_has_self_closing )
		);
	}

	/**
	 * Steps through the HTML document and stop at the next tag, if any.
	 *
	 * @since 6.4.0
	 *
	 * @throws Exception When unable to allocate a bookmark for the next token in the input HTML document.
	 *
	 * @see self::PROCESS_NEXT_NODE
	 * @see self::REPROCESS_CURRENT_NODE
	 *
	 * @param string $node_to_process Whether to parse the next node or reprocess the current node.
	 * @return bool Whether a tag was matched.
	 */
	public function step( $node_to_process = self::PROCESS_NEXT_NODE ): bool {
		// Refuse to proceed if there was a previous error.
		if ( null !== $this-&gt;last_error ) {
			return false;
		}

		if ( self::REPROCESS_CURRENT_NODE !== $node_to_process ) {
			/*
			 * Void elements still hop onto the stack of open elements even though
			 * there's no corresponding closing tag. This is important for managing
			 * stack-based operations such as "navigate to parent node" or checking
			 * on an element's breadcrumbs.
			 *
			 * When moving on to the next node, therefore, if the bottom-most element
			 * on the stack is a void element, it must be closed.
			 */
			$top_node = $this-&gt;state-&gt;stack_of_open_elements-&gt;current_node();
			if ( isset( $top_node ) &amp;&amp; ! $this-&gt;expects_closer( $top_node ) ) {
				$this-&gt;state-&gt;stack_of_open_elements-&gt;pop();
			}
		}

		if ( self::PROCESS_NEXT_NODE === $node_to_process ) {
			parent::next_token();
			if ( WP_HTML_Tag_Processor::STATE_TEXT_NODE === $this-&gt;parser_state ) {
				parent::subdivide_text_appropriately();
			}
		}

		// Finish stepping when there are no more tokens in the document.
		if (
			WP_HTML_Tag_Processor::STATE_INCOMPLETE_INPUT === $this-&gt;parser_state ||
			WP_HTML_Tag_Processor::STATE_COMPLETE === $this-&gt;parser_state
		) {
			return false;
		}

		$adjusted_current_node = $this-&gt;get_adjusted_current_node();
		$is_closer             = $this-&gt;is_tag_closer();
		$is_start_tag          = WP_HTML_Tag_Processor::STATE_MATCHED_TAG === $this-&gt;parser_state &amp;&amp; ! $is_closer;
		$token_name            = $this-&gt;get_token_name();

		if ( self::REPROCESS_CURRENT_NODE !== $node_to_process ) {
			$this-&gt;state-&gt;current_token = new WP_HTML_Token(
				$this-&gt;bookmark_token(),
				$token_name,
				$this-&gt;has_self_closing_flag(),
				$this-&gt;release_internal_bookmark_on_destruct
			);
		}

		$parse_in_current_insertion_mode = (
			0 === $this-&gt;state-&gt;stack_of_open_elements-&gt;count() ||
			'html' === $adjusted_current_node-&gt;namespace ||
			(
				'math' === $adjusted_current_node-&gt;integration_node_type &amp;&amp;
				(
					( $is_start_tag &amp;&amp; ! in_array( $token_name, array( 'MGLYPH', 'MALIGNMARK' ), true ) ) ||
					'#text' === $token_name
				)
			) ||
			(
				'math' === $adjusted_current_node-&gt;namespace &amp;&amp;
				'ANNOTATION-XML' === $adjusted_current_node-&gt;node_name &amp;&amp;
				$is_start_tag &amp;&amp; 'SVG' === $token_name
			) ||
			(
				'html' === $adjusted_current_node-&gt;integration_node_type &amp;&amp;
				( $is_start_tag || '#text' === $token_name )
			)
		);

		try {
			if ( ! $parse_in_current_insertion_mode ) {
				return $this-&gt;step_in_foreign_content();
			}

			switch ( $this-&gt;state-&gt;insertion_mode ) {
				case WP_HTML_Processor_State::INSERTION_MODE_INITIAL:
					return $this-&gt;step_initial();

				case WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HTML:
					return $this-&gt;step_before_html();

				case WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HEAD:
					return $this-&gt;step_before_head();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_HEAD:
					return $this-&gt;step_in_head();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_HEAD_NOSCRIPT:
					return $this-&gt;step_in_head_noscript();

				case WP_HTML_Processor_State::INSERTION_MODE_AFTER_HEAD:
					return $this-&gt;step_after_head();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_BODY:
					return $this-&gt;step_in_body();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_TABLE:
					return $this-&gt;step_in_table();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_TABLE_TEXT:
					return $this-&gt;step_in_table_text();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_CAPTION:
					return $this-&gt;step_in_caption();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_COLUMN_GROUP:
					return $this-&gt;step_in_column_group();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_TABLE_BODY:
					return $this-&gt;step_in_table_body();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_ROW:
					return $this-&gt;step_in_row();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_CELL:
					return $this-&gt;step_in_cell();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_SELECT:
					return $this-&gt;step_in_select();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_SELECT_IN_TABLE:
					return $this-&gt;step_in_select_in_table();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_TEMPLATE:
					return $this-&gt;step_in_template();

				case WP_HTML_Processor_State::INSERTION_MODE_AFTER_BODY:
					return $this-&gt;step_after_body();

				case WP_HTML_Processor_State::INSERTION_MODE_IN_FRAMESET:
					return $this-&gt;step_in_frameset();

				case WP_HTML_Processor_State::INSERTION_MODE_AFTER_FRAMESET:
					return $this-&gt;step_after_frameset();

				case WP_HTML_Processor_State::INSERTION_MODE_AFTER_AFTER_BODY:
					return $this-&gt;step_after_after_body();

				case WP_HTML_Processor_State::INSERTION_MODE_AFTER_AFTER_FRAMESET:
					return $this-&gt;step_after_after_frameset();

				// This should be unreachable but PHP doesn't have total type checking on switch.
				default:
					$this-&gt;bail( "Unaware of the requested parsing mode: '{$this-&gt;state-&gt;insertion_mode}'." );
			}
		} catch ( WP_HTML_Unsupported_Exception $e ) {
			/*
			 * Exceptions are used in this class to escape deep call stacks that
			 * otherwise might involve messier calling and return conventions.
			 */
			return false;
		}
	}

	/**
	 * Computes the HTML breadcrumbs for the currently-matched node, if matched.
	 *
	 * Breadcrumbs start at the outermost parent and descend toward the matched element.
	 * They always include the entire path from the root HTML node to the matched element.
	 *
	 * @todo It could be more efficient to expose a generator-based version of this function
	 *       to avoid creating the array copy on tag iteration. If this is done, it would likely
	 *       be more useful to walk up the stack when yielding instead of starting at the top.
	 *
	 * Example
	 *
	 *     $processor = WP_HTML_Processor::create_fragment( '&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;img&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;' );
	 *     $processor-&gt;next_tag( 'IMG' );
	 *     $processor-&gt;get_breadcrumbs() === array( 'HTML', 'BODY', 'P', 'STRONG', 'EM', 'IMG' );
	 *
	 * @since 6.4.0
	 *
	 * @return string[]|null Array of tag names representing path to matched node, if matched, otherwise NULL.
	 */
	public function get_breadcrumbs(): ?array {
		return $this-&gt;breadcrumbs;
	}

	/**
	 * Returns the nesting depth of the current location in the document.
	 *
	 * Example:
	 *
	 *     $processor = WP_HTML_Processor::create_fragment( '&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;' );
	 *     // The processor starts in the BODY context, meaning it has depth from the start: HTML &gt; BODY.
	 *     2 === $processor-&gt;get_current_depth();
	 *
	 *     // Opening the DIV element increases the depth.
	 *     $processor-&gt;next_token();
	 *     3 === $processor-&gt;get_current_depth();
	 *
	 *     // Opening the P element increases the depth.
	 *     $processor-&gt;next_token();
	 *     4 === $processor-&gt;get_current_depth();
	 *
	 *     // The P element is closed during `next_token()` so the depth is decreased to reflect that.
	 *     $processor-&gt;next_token();
	 *     3 === $processor-&gt;get_current_depth();
	 *
	 * @since 6.6.0
	 *
	 * @return int Nesting-depth of current location in the document.
	 */
	public function get_current_depth(): int {
		return count( $this-&gt;breadcrumbs );
	}

	/**
	 * Normalizes an HTML fragment by serializing it.
	 *
	 * This method assumes that the given HTML snippet is found in BODY context.
	 * For normalizing full documents or fragments found in other contexts, create
	 * a new processor using <a href="wp_html_processor/create_fragment.html">WP_HTML_Processor::create_fragment</a> or
	 * <a href="wp_html_processor/create_full_parser.html">WP_HTML_Processor::create_full_parser</a> and call <a href="wp_html_processor/serialize.html">WP_HTML_Processor::serialize</a>
	 * on the created instances.
	 *
	 * Many aspects of an input HTML fragment may be changed during normalization.
	 *
	 *  - Attribute values will be double-quoted.
	 *  - Duplicate attributes will be removed.
	 *  - Omitted tags will be added.
	 *  - Tag and attribute name casing will be lower-cased,
	 *    except for specific SVG and MathML tags or attributes.
	 *  - Text will be re-encoded, null bytes handled,
	 *    and invalid UTF-8 replaced with U+FFFD.
	 *  - Any incomplete syntax trailing at the end will be omitted,
	 *    for example, an unclosed comment opener will be removed.
	 *
	 * Example:
	 *
	 *     echo WP_HTML_Processor::normalize( '&lt;a href=#anchor v=5 href="/.html" enabled&gt;One&lt;/a another v=5&gt;&lt;!--' );
	 *     // &lt;a href="#anchor" v="5" enabled&gt;One&lt;/a&gt;
	 *
	 *     echo WP_HTML_Processor::normalize( '&lt;div&gt;&lt;/p&gt;fun&lt;table&gt;&lt;td&gt;cell&lt;/div&gt;' );
	 *     // &lt;div&gt;&lt;p&gt;&lt;/p&gt;fun&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;cell&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
	 *
	 *     echo WP_HTML_Processor::normalize( '&lt;![CDATA[invalid comment]]&gt; syntax &lt; &lt;&gt; "oddities"' );
	 *     // &lt;!--[CDATA[invalid comment]]--&gt; syntax &amp;lt; &amp;lt;&amp;gt; &amp;quot;oddities&amp;quot;
	 *
	 * @since 6.7.0
	 *
	 * @param string $html Input HTML to normalize.
	 *
	 * @return string|null Normalized output, or `null` if unable to normalize.
	 */
	public static function normalize( string $html ): ?string {
		return static::create_fragment( $html )-&gt;serialize();
	}

	/**
	 * Returns normalized HTML for a fragment by serializing it.
	 *
	 * This differs from <a href="wp_html_processor/normalize.html">WP_HTML_Processor::normalize</a> in that it starts with
	 * a specific HTML Processor, which _must_ not have already started scanning;
	 * it must be in the initial ready state and will be in the completed state once
	 * serialization is complete.
	 *
	 * Many aspects of an input HTML fragment may be changed during normalization.
	 *
	 *  - Attribute values will be double-quoted.
	 *  - Duplicate attributes will be removed.
	 *  - Omitted tags will be added.
	 *  - Tag and attribute name casing will be lower-cased,
	 *    except for specific SVG and MathML tags or attributes.
	 *  - Text will be re-encoded, null bytes handled,
	 *    and invalid UTF-8 replaced with U+FFFD.
	 *  - Any incomplete syntax trailing at the end will be omitted,
	 *    for example, an unclosed comment opener will be removed.
	 *
	 * Example:
	 *
	 *     $processor = WP_HTML_Processor::create_fragment( '&lt;a href=#anchor v=5 href="/.html" enabled&gt;One&lt;/a another v=5&gt;&lt;!--' );
	 *     echo $processor-&gt;serialize();
	 *     // &lt;a href="#anchor" v="5" enabled&gt;One&lt;/a&gt;
	 *
	 *     $processor = WP_HTML_Processor::create_fragment( '&lt;div&gt;&lt;/p&gt;fun&lt;table&gt;&lt;td&gt;cell&lt;/div&gt;' );
	 *     echo $processor-&gt;serialize();
	 *     // &lt;div&gt;&lt;p&gt;&lt;/p&gt;fun&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;cell&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
	 *
	 *     $processor = WP_HTML_Processor::create_fragment( '&lt;![CDATA[invalid comment]]&gt; syntax &lt; &lt;&gt; "oddities"' );
	 *     echo $processor-&gt;serialize();
	 *     // &lt;!--[CDATA[invalid comment]]--&gt; syntax &amp;lt; &amp;lt;&amp;gt; &amp;quot;oddities&amp;quot;
	 *
	 * @since 6.7.0
	 *
	 * @return string|null Normalized HTML markup represented by processor,
	 *                     or `null` if unable to generate serialization.
	 */
	public function serialize(): ?string {
		if ( WP_HTML_Tag_Processor::STATE_READY !== $this-&gt;parser_state ) {
			wp_trigger_error(
				__METHOD__,
				'An HTML Processor which has already started processing cannot serialize its contents. Serialize immediately after creating the instance.',
				E_USER_WARNING
			);
			return null;
		}

		$html = '';
		while ( $this-&gt;next_token() ) {
			$html .= $this-&gt;serialize_token();
		}

		if ( null !== $this-&gt;get_last_error() ) {
			wp_trigger_error(
				__METHOD__,
				"Cannot serialize HTML Processor with parsing error: {$this-&gt;get_last_error()}.",
				E_USER_WARNING
			);
			return null;
		}

		return $html;
	}

	/**
	 * Serializes the currently-matched token.
	 *
	 * This method produces a fully-normative HTML string for the currently-matched token,
	 * if able. If not matched at any token or if the token doesn't correspond to any HTML
	 * it will return an empty string (for example, presumptuous end tags are ignored).
	 *
	 * @see static::serialize()
	 *
	 * @since 6.7.0
	 *
	 * @return string Serialization of token, or empty string if no serialization exists.
	 */
	protected function serialize_token(): string {
		$html       = '';
		$token_type = $this-&gt;get_token_type();

		switch ( $token_type ) {
			case '#text':
				$html .= htmlspecialchars( $this-&gt;get_modifiable_text(), ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML5, 'UTF-8' );
				break;

			// Unlike the `&lt;&gt;` which is interpreted as plaintext, this is ignored entirely.
			case '#presumptuous-tag':
				break;

			case '#funky-comment':
			case '#comment':
				$html .= "&lt;!--{$this-&gt;get_full_comment_text()}--&gt;";
				break;

			case '#cdata-section':
				$html .= "&lt;![CDATA[{$this-&gt;get_modifiable_text()}]]&gt;";
				break;

			case 'html':
				$html .= '&lt;!DOCTYPE html&gt;';
				break;
		}

		if ( '#tag' !== $token_type ) {
			return $html;
		}

		$tag_name       = str_replace( "\x00", "\u{FFFD}", $this-&gt;get_tag() );
		$in_html        = 'html' === $this-&gt;get_namespace();
		$qualified_name = $in_html ? strtolower( $tag_name ) : $this-&gt;get_qualified_tag_name();

		if ( $this-&gt;is_tag_closer() ) {
			$html .= "&lt;/{$qualified_name}&gt;";
			return $html;
		}

		$attribute_names = $this-&gt;get_attribute_names_with_prefix( '' );
		if ( ! isset( $attribute_names ) ) {
			$html .= "&lt;{$qualified_name}&gt;";
			return $html;
		}

		$html .= "&lt;{$qualified_name}";
		foreach ( $attribute_names as $attribute_name ) {
			$html .= " {$this-&gt;get_qualified_attribute_name( $attribute_name )}";
			$value = $this-&gt;get_attribute( $attribute_name );

			if ( is_string( $value ) ) {
				$html .= '="' . htmlspecialchars( $value, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML5 ) . '"';
			}

			$html = str_replace( "\x00", "\u{FFFD}", $html );
		}

		if ( ! $in_html &amp;&amp; $this-&gt;has_self_closing_flag() ) {
			$html .= ' /';
		}

		$html .= '&gt;';

		// Flush out self-contained elements.
		if ( $in_html &amp;&amp; in_array( $tag_name, array( 'IFRAME', 'NOEMBED', 'NOFRAMES', 'SCRIPT', 'STYLE', 'TEXTAREA', 'TITLE', 'XMP' ), true ) ) {
			$text = $this-&gt;get_modifiable_text();

			switch ( $tag_name ) {
				case 'IFRAME':
				case 'NOEMBED':
				case 'NOFRAMES':
					$text = '';
					break;

				case 'SCRIPT':
				case 'STYLE':
					break;

				default:
					$text = htmlspecialchars( $text, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML5, 'UTF-8' );
			}

			$html .= "{$text}&lt;/{$qualified_name}&gt;";
		}

		return $html;
	}

	/**
	 * Parses next element in the 'initial' insertion mode.
	 *
	 * This internal function performs the 'initial' insertion mode
	 * logic for the generalized WP_HTML_Processor::step() function.
	 *
	 * @since 6.7.0
	 *
	 * @throws WP_HTML_Unsupported_Exception When encountering unsupported HTML input.
	 *
	 * @see https://html.spec.whatwg.org/#the-initial-insertion-mode
	 * @see WP_HTML_Processor::step
	 *
	 * @return bool Whether an element was found.
	 */
	private function step_initial(): bool {
		$token_name = $this-&gt;get_token_name();
		$token_type = $this-&gt;get_token_type();
		$op_sigil   = '#tag' === $token_type ? ( parent::is_tag_closer() ? '-' : '+' ) : '';
		$op         = "{$op_sigil}{$token_name}";

		switch ( $op ) {
			/*
			 * &gt; A character token that is one of U+0009 CHARACTER TABULATION,
			 * &gt; U+000A LINE FEED (LF), U+000C FORM FEED (FF),
			 * &gt; U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
			 *
			 * Parse error: ignore the token.
			 */
			case '#text':
				if ( parent::TEXT_IS_WHITESPACE === $this-&gt;text_node_classification ) {
					return $this-&gt;step();
				}
				goto initial_anything_else;
				break;

			/*
			 * &gt; A comment token
			 */
			case '#comment':
			case '#funky-comment':
			case '#presumptuous-tag':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A DOCTYPE token
			 */
			case 'html':
				$doctype = $this-&gt;get_doctype_info();
				if ( null !== $doctype &amp;&amp; 'quirks' === $doctype-&gt;indicated_compatability_mode ) {
					$this-&gt;compat_mode = WP_HTML_Tag_Processor::QUIRKS_MODE;
				}

				/*
				 * &gt; Then, switch the insertion mode to "before html".
				 */
				$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HTML;
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;
		}

		/*
		 * &gt; Anything else
		 */
		initial_anything_else:
		$this-&gt;compat_mode           = WP_HTML_Tag_Processor::QUIRKS_MODE;
		$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HTML;
		return $this-&gt;step( self::REPROCESS_CURRENT_NODE );
	}

	/**
	 * Parses next element in the 'before html' insertion mode.
	 *
	 * This internal function performs the 'before html' insertion mode
	 * logic for the generalized WP_HTML_Processor::step() function.
	 *
	 * @since 6.7.0
	 *
	 * @throws WP_HTML_Unsupported_Exception When encountering unsupported HTML input.
	 *
	 * @see https://html.spec.whatwg.org/#the-before-html-insertion-mode
	 * @see WP_HTML_Processor::step
	 *
	 * @return bool Whether an element was found.
	 */
	private function step_before_html(): bool {
		$token_name = $this-&gt;get_token_name();
		$token_type = $this-&gt;get_token_type();
		$is_closer  = parent::is_tag_closer();
		$op_sigil   = '#tag' === $token_type ? ( $is_closer ? '-' : '+' ) : '';
		$op         = "{$op_sigil}{$token_name}";

		switch ( $op ) {
			/*
			 * &gt; A DOCTYPE token
			 */
			case 'html':
				// Parse error: ignore the token.
				return $this-&gt;step();

			/*
			 * &gt; A comment token
			 */
			case '#comment':
			case '#funky-comment':
			case '#presumptuous-tag':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A character token that is one of U+0009 CHARACTER TABULATION,
			 * &gt; U+000A LINE FEED (LF), U+000C FORM FEED (FF),
			 * &gt; U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
			 *
			 * Parse error: ignore the token.
			 */
			case '#text':
				if ( parent::TEXT_IS_WHITESPACE === $this-&gt;text_node_classification ) {
					return $this-&gt;step();
				}
				goto before_html_anything_else;
				break;

			/*
			 * &gt; A start tag whose tag name is "html"
			 */
			case '+HTML':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HEAD;
				return true;

			/*
			 * &gt; An end tag whose tag name is one of: "head", "body", "html", "br"
			 *
			 * Closing BR tags are always reported by the Tag Processor as opening tags.
			 */
			case '-HEAD':
			case '-BODY':
			case '-HTML':
				/*
				 * &gt; Act as described in the "anything else" entry below.
				 */
				goto before_html_anything_else;
				break;
		}

		/*
		 * &gt; Any other end tag
		 */
		if ( $is_closer ) {
			// Parse error: ignore the token.
			return $this-&gt;step();
		}

		/*
		 * &gt; Anything else.
		 *
		 * &gt; Create an html element whose node document is the Document object.
		 * &gt; Append it to the Document object. Put this element in the stack of open elements.
		 * &gt; Switch the insertion mode to "before head", then reprocess the token.
		 */
		before_html_anything_else:
		$this-&gt;insert_virtual_node( 'HTML' );
		$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HEAD;
		return $this-&gt;step( self::REPROCESS_CURRENT_NODE );
	}

	/**
	 * Parses next element in the 'before head' insertion mode.
	 *
	 * This internal function performs the 'before head' insertion mode
	 * logic for the generalized WP_HTML_Processor::step() function.
	 *
	 * @since 6.7.0 Stub implementation.
	 *
	 * @throws WP_HTML_Unsupported_Exception When encountering unsupported HTML input.
	 *
	 * @see https://html.spec.whatwg.org/#the-before-head-insertion-mode
	 * @see WP_HTML_Processor::step
	 *
	 * @return bool Whether an element was found.
	 */
	private function step_before_head(): bool {
		$token_name = $this-&gt;get_token_name();
		$token_type = $this-&gt;get_token_type();
		$is_closer  = parent::is_tag_closer();
		$op_sigil   = '#tag' === $token_type ? ( $is_closer ? '-' : '+' ) : '';
		$op         = "{$op_sigil}{$token_name}";

		switch ( $op ) {
			/*
			 * &gt; A character token that is one of U+0009 CHARACTER TABULATION,
			 * &gt; U+000A LINE FEED (LF), U+000C FORM FEED (FF),
			 * &gt; U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
			 *
			 * Parse error: ignore the token.
			 */
			case '#text':
				if ( parent::TEXT_IS_WHITESPACE === $this-&gt;text_node_classification ) {
					return $this-&gt;step();
				}
				goto before_head_anything_else;
				break;

			/*
			 * &gt; A comment token
			 */
			case '#comment':
			case '#funky-comment':
			case '#presumptuous-tag':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A DOCTYPE token
			 */
			case 'html':
				// Parse error: ignore the token.
				return $this-&gt;step();

			/*
			 * &gt; A start tag whose tag name is "html"
			 */
			case '+HTML':
				return $this-&gt;step_in_body();

			/*
			 * &gt; A start tag whose tag name is "head"
			 */
			case '+HEAD':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				$this-&gt;state-&gt;head_element   = $this-&gt;state-&gt;current_token;
				$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_IN_HEAD;
				return true;

			/*
			 * &gt; An end tag whose tag name is one of: "head", "body", "html", "br"
			 * &gt; Act as described in the "anything else" entry below.
			 *
			 * Closing BR tags are always reported by the Tag Processor as opening tags.
			 */
			case '-HEAD':
			case '-BODY':
			case '-HTML':
				goto before_head_anything_else;
				break;
		}

		if ( $is_closer ) {
			// Parse error: ignore the token.
			return $this-&gt;step();
		}

		/*
		 * &gt; Anything else
		 *
		 * &gt; Insert an HTML element for a "head" start tag token with no attributes.
		 */
		before_head_anything_else:
		$this-&gt;state-&gt;head_element   = $this-&gt;insert_virtual_node( 'HEAD' );
		$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_IN_HEAD;
		return $this-&gt;step( self::REPROCESS_CURRENT_NODE );
	}

	/**
	 * Parses next element in the 'in head' insertion mode.
	 *
	 * This internal function performs the 'in head' insertion mode
	 * logic for the generalized WP_HTML_Processor::step() function.
	 *
	 * @since 6.7.0
	 *
	 * @throws WP_HTML_Unsupported_Exception When encountering unsupported HTML input.
	 *
	 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inhead
	 * @see WP_HTML_Processor::step
	 *
	 * @return bool Whether an element was found.
	 */
	private function step_in_head(): bool {
		$token_name = $this-&gt;get_token_name();
		$token_type = $this-&gt;get_token_type();
		$is_closer  = parent::is_tag_closer();
		$op_sigil   = '#tag' === $token_type ? ( $is_closer ? '-' : '+' ) : '';
		$op         = "{$op_sigil}{$token_name}";

		switch ( $op ) {
			case '#text':
				/*
				 * &gt; A character token that is one of U+0009 CHARACTER TABULATION,
				 * &gt; U+000A LINE FEED (LF), U+000C FORM FEED (FF),
				 * &gt; U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
				 */
				if ( parent::TEXT_IS_WHITESPACE === $this-&gt;text_node_classification ) {
					// Insert the character.
					$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
					return true;
				}

				goto in_head_anything_else;
				break;

			/*
			 * &gt; A comment token
			 */
			case '#comment':
			case '#funky-comment':
			case '#presumptuous-tag':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A DOCTYPE token
			 */
			case 'html':
				// Parse error: ignore the token.
				return $this-&gt;step();

			/*
			 * &gt; A start tag whose tag name is "html"
			 */
			case '+HTML':
				return $this-&gt;step_in_body();

			/*
			 * &gt; A start tag whose tag name is one of: "base", "basefont", "bgsound", "link"
			 */
			case '+BASE':
			case '+BASEFONT':
			case '+BGSOUND':
			case '+LINK':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A start tag whose tag name is "meta"
			 */
			case '+META':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );

				/*
				 * &gt; If the active speculative HTML parser is null, then:
				 * &gt;   - If the element has a charset attribute, and getting an encoding from
				 * &gt;     its value results in an encoding, and the confidence is currently
				 * &gt;     tentative, then change the encoding to the resulting encoding.
				 */
				$charset = $this-&gt;get_attribute( 'charset' );
				if ( is_string( $charset ) &amp;&amp; 'tentative' === $this-&gt;state-&gt;encoding_confidence ) {
					$this-&gt;bail( 'Cannot yet process META tags with charset to determine encoding.' );
				}

				/*
				 * &gt;   - Otherwise, if the element has an http-equiv attribute whose value is
				 * &gt;     an ASCII case-insensitive match for the string "Content-Type", and
				 * &gt;     the element has a content attribute, and applying the algorithm for
				 * &gt;     extracting a character encoding from a meta element to that attribute's
				 * &gt;     value returns an encoding, and the confidence is currently tentative,
				 * &gt;     then change the encoding to the extracted encoding.
				 */
				$http_equiv = $this-&gt;get_attribute( 'http-equiv' );
				$content    = $this-&gt;get_attribute( 'content' );
				if (
					is_string( $http_equiv ) &amp;&amp;
					is_string( $content ) &amp;&amp;
					0 === strcasecmp( $http_equiv, 'Content-Type' ) &amp;&amp;
					'tentative' === $this-&gt;state-&gt;encoding_confidence
				) {
					$this-&gt;bail( 'Cannot yet process META tags with http-equiv Content-Type to determine encoding.' );
				}

				return true;

			/*
			 * &gt; A start tag whose tag name is "title"
			 */
			case '+TITLE':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A start tag whose tag name is "noscript", if the scripting flag is enabled
			 * &gt; A start tag whose tag name is one of: "noframes", "style"
			 *
			 * The scripting flag is never enabled in this parser.
			 */
			case '+NOFRAMES':
			case '+STYLE':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A start tag whose tag name is "noscript", if the scripting flag is disabled
			 */
			case '+NOSCRIPT':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_IN_HEAD_NOSCRIPT;
				return true;

			/*
			 * &gt; A start tag whose tag name is "script"
			 *
			 * @todo Could the adjusted insertion location be anything other than the current location?
			 */
			case '+SCRIPT':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; An end tag whose tag name is "head"
			 */
			case '-HEAD':
				$this-&gt;state-&gt;stack_of_open_elements-&gt;pop();
				$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_AFTER_HEAD;
				return true;

			/*
			 * &gt; An end tag whose tag name is one of: "body", "html", "br"
			 *
			 * BR tags are always reported by the Tag Processor as opening tags.
			 */
			case '-BODY':
			case '-HTML':
				/*
				 * &gt; Act as described in the "anything else" entry below.
				 */
				goto in_head_anything_else;
				break;

			/*
			 * &gt; A start tag whose tag name is "template"
			 *
			 * @todo Could the adjusted insertion location be anything other than the current location?
			 */
			case '+TEMPLATE':
				$this-&gt;state-&gt;active_formatting_elements-&gt;insert_marker();
				$this-&gt;state-&gt;frameset_ok = false;

				$this-&gt;state-&gt;insertion_mode                      = WP_HTML_Processor_State::INSERTION_MODE_IN_TEMPLATE;
				$this-&gt;state-&gt;stack_of_template_insertion_modes[] = WP_HTML_Processor_State::INSERTION_MODE_IN_TEMPLATE;

				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; An end tag whose tag name is "template"
			 */
			case '-TEMPLATE':
				if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;contains( 'TEMPLATE' ) ) {
					// @todo Indicate a parse error once it's possible.
					return $this-&gt;step();
				}

				$this-&gt;generate_implied_end_tags_thoroughly();
				if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;current_node_is( 'TEMPLATE' ) ) {
					// @todo Indicate a parse error once it's possible.
				}

				$this-&gt;state-&gt;stack_of_open_elements-&gt;pop_until( 'TEMPLATE' );
				$this-&gt;state-&gt;active_formatting_elements-&gt;clear_up_to_last_marker();
				array_pop( $this-&gt;state-&gt;stack_of_template_insertion_modes );
				$this-&gt;reset_insertion_mode_appropriately();
				return true;
		}

		/*
		 * &gt; A start tag whose tag name is "head"
		 * &gt; Any other end tag
		 */
		if ( '+HEAD' === $op || $is_closer ) {
			// Parse error: ignore the token.
			return $this-&gt;step();
		}

		/*
		 * &gt; Anything else
		 */
		in_head_anything_else:
		$this-&gt;state-&gt;stack_of_open_elements-&gt;pop();
		$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_AFTER_HEAD;
		return $this-&gt;step( self::REPROCESS_CURRENT_NODE );
	}

	/**
	 * Parses next element in the 'in head noscript' insertion mode.
	 *
	 * This internal function performs the 'in head noscript' insertion mode
	 * logic for the generalized WP_HTML_Processor::step() function.
	 *
	 * @since 6.7.0 Stub implementation.
	 *
	 * @throws WP_HTML_Unsupported_Exception When encountering unsupported HTML input.
	 *
	 * @see https://html.spec.whatwg.org/#parsing-main-inheadnoscript
	 * @see WP_HTML_Processor::step
	 *
	 * @return bool Whether an element was found.
	 */
	private function step_in_head_noscript(): bool {
		$token_name = $this-&gt;get_token_name();
		$token_type = $this-&gt;get_token_type();
		$is_closer  = parent::is_tag_closer();
		$op_sigil   = '#tag' === $token_type ? ( $is_closer ? '-' : '+' ) : '';
		$op         = "{$op_sigil}{$token_name}";

		switch ( $op ) {
			/*
			 * &gt; A character token that is one of U+0009 CHARACTER TABULATION,
			 * &gt; U+000A LINE FEED (LF), U+000C FORM FEED (FF),
			 * &gt; U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
			 *
			 * Parse error: ignore the token.
			 */
			case '#text':
				if ( parent::TEXT_IS_WHITESPACE === $this-&gt;text_node_classification ) {
					return $this-&gt;step_in_head();
				}

				goto in_head_noscript_anything_else;
				break;

			/*
			 * &gt; A DOCTYPE token
			 */
			case 'html':
				// Parse error: ignore the token.
				return $this-&gt;step();

			/*
			 * &gt; A start tag whose tag name is "html"
			 */
			case '+HTML':
				return $this-&gt;step_in_body();

			/*
			 * &gt; An end tag whose tag name is "noscript"
			 */
			case '-NOSCRIPT':
				$this-&gt;state-&gt;stack_of_open_elements-&gt;pop();
				$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_IN_HEAD;
				return true;

			/*
			 * &gt; A comment token
			 * &gt;
			 * &gt; A start tag whose tag name is one of: "basefont", "bgsound",
			 * &gt; "link", "meta", "noframes", "style"
			 */
			case '#comment':
			case '#funky-comment':
			case '#presumptuous-tag':
			case '+BASEFONT':
			case '+BGSOUND':
			case '+LINK':
			case '+META':
			case '+NOFRAMES':
			case '+STYLE':
				return $this-&gt;step_in_head();

			/*
			 * &gt; An end tag whose tag name is "br"
			 *
			 * This should never happen, as the Tag Processor prevents showing a BR closing tag.
			 */
		}

		/*
		 * &gt; A start tag whose tag name is one of: "head", "noscript"
		 * &gt; Any other end tag
		 */
		if ( '+HEAD' === $op || '+NOSCRIPT' === $op || $is_closer ) {
			// Parse error: ignore the token.
			return $this-&gt;step();
		}

		/*
		 * &gt; Anything else
		 *
		 * Anything here is a parse error.
		 */
		in_head_noscript_anything_else:
		$this-&gt;state-&gt;stack_of_open_elements-&gt;pop();
		$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_IN_HEAD;
		return $this-&gt;step( self::REPROCESS_CURRENT_NODE );
	}

	/**
	 * Parses next element in the 'after head' insertion mode.
	 *
	 * This internal function performs the 'after head' insertion mode
	 * logic for the generalized WP_HTML_Processor::step() function.
	 *
	 * @since 6.7.0 Stub implementation.
	 *
	 * @throws WP_HTML_Unsupported_Exception When encountering unsupported HTML input.
	 *
	 * @see https://html.spec.whatwg.org/#the-after-head-insertion-mode
	 * @see WP_HTML_Processor::step
	 *
	 * @return bool Whether an element was found.
	 */
	private function step_after_head(): bool {
		$token_name = $this-&gt;get_token_name();
		$token_type = $this-&gt;get_token_type();
		$is_closer  = parent::is_tag_closer();
		$op_sigil   = '#tag' === $token_type ? ( $is_closer ? '-' : '+' ) : '';
		$op         = "{$op_sigil}{$token_name}";

		switch ( $op ) {
			/*
			 * &gt; A character token that is one of U+0009 CHARACTER TABULATION,
			 * &gt; U+000A LINE FEED (LF), U+000C FORM FEED (FF),
			 * &gt; U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
			 */
			case '#text':
				if ( parent::TEXT_IS_WHITESPACE === $this-&gt;text_node_classification ) {
					// Insert the character.
					$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
					return true;
				}
				goto after_head_anything_else;
				break;

			/*
			 * &gt; A comment token
			 */
			case '#comment':
			case '#funky-comment':
			case '#presumptuous-tag':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A DOCTYPE token
			 */
			case 'html':
				// Parse error: ignore the token.
				return $this-&gt;step();

			/*
			 * &gt; A start tag whose tag name is "html"
			 */
			case '+HTML':
				return $this-&gt;step_in_body();

			/*
			 * &gt; A start tag whose tag name is "body"
			 */
			case '+BODY':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				$this-&gt;state-&gt;frameset_ok    = false;
				$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_IN_BODY;
				return true;

			/*
			 * &gt; A start tag whose tag name is "frameset"
			 */
			case '+FRAMESET':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_IN_FRAMESET;
				return true;

			/*
			 * &gt; A start tag whose tag name is one of: "base", "basefont", "bgsound",
			 * &gt; "link", "meta", "noframes", "script", "style", "template", "title"
			 *
			 * Anything here is a parse error.
			 */
			case '+BASE':
			case '+BASEFONT':
			case '+BGSOUND':
			case '+LINK':
			case '+META':
			case '+NOFRAMES':
			case '+SCRIPT':
			case '+STYLE':
			case '+TEMPLATE':
			case '+TITLE':
				/*
				 * &gt; Push the node pointed to by the head element pointer onto the stack of open elements.
				 * &gt; Process the token using the rules for the "in head" insertion mode.
				 * &gt; Remove the node pointed to by the head element pointer from the stack of open elements. (It might not be the current node at this point.)
				 */
				$this-&gt;bail( 'Cannot process elements after HEAD which reopen the HEAD element.' );
				/*
				 * Do not leave this break in when adding support; it's here to prevent
				 * WPCS from getting confused at the switch structure without a return,
				 * because it doesn't know that `bail()` always throws.
				 */
				break;

			/*
			 * &gt; An end tag whose tag name is "template"
			 */
			case '-TEMPLATE':
				return $this-&gt;step_in_head();

			/*
			 * &gt; An end tag whose tag name is one of: "body", "html", "br"
			 *
			 * Closing BR tags are always reported by the Tag Processor as opening tags.
			 */
			case '-BODY':
			case '-HTML':
				/*
				 * &gt; Act as described in the "anything else" entry below.
				 */
				goto after_head_anything_else;
				break;
		}

		/*
		 * &gt; A start tag whose tag name is "head"
		 * &gt; Any other end tag
		 */
		if ( '+HEAD' === $op || $is_closer ) {
			// Parse error: ignore the token.
			return $this-&gt;step();
		}

		/*
		 * &gt; Anything else
		 * &gt; Insert an HTML element for a "body" start tag token with no attributes.
		 */
		after_head_anything_else:
		$this-&gt;insert_virtual_node( 'BODY' );
		$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_IN_BODY;
		return $this-&gt;step( self::REPROCESS_CURRENT_NODE );
	}

	/**
	 * Parses next element in the 'in body' insertion mode.
	 *
	 * This internal function performs the 'in body' insertion mode
	 * logic for the generalized WP_HTML_Processor::step() function.
	 *
	 * @since 6.4.0
	 *
	 * @throws WP_HTML_Unsupported_Exception When encountering unsupported HTML input.
	 *
	 * @see https://html.spec.whatwg.org/#parsing-main-inbody
	 * @see WP_HTML_Processor::step
	 *
	 * @return bool Whether an element was found.
	 */
	private function step_in_body(): bool {
		$token_name = $this-&gt;get_token_name();
		$token_type = $this-&gt;get_token_type();
		$op_sigil   = '#tag' === $token_type ? ( parent::is_tag_closer() ? '-' : '+' ) : '';
		$op         = "{$op_sigil}{$token_name}";

		switch ( $op ) {
			case '#text':
				/*
				 * &gt; A character token that is U+0000 NULL
				 *
				 * Any successive sequence of NULL bytes is ignored and won't
				 * trigger active format reconstruction. Therefore, if the text
				 * only comprises NULL bytes then the token should be ignored
				 * here, but if there are any other characters in the stream
				 * the active formats should be reconstructed.
				 */
				if ( parent::TEXT_IS_NULL_SEQUENCE === $this-&gt;text_node_classification ) {
					// Parse error: ignore the token.
					return $this-&gt;step();
				}

				$this-&gt;reconstruct_active_formatting_elements();

				/*
				 * Whitespace-only text does not affect the frameset-ok flag.
				 * It is probably inter-element whitespace, but it may also
				 * contain character references which decode only to whitespace.
				 */
				if ( parent::TEXT_IS_GENERIC === $this-&gt;text_node_classification ) {
					$this-&gt;state-&gt;frameset_ok = false;
				}

				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			case '#comment':
			case '#funky-comment':
			case '#presumptuous-tag':
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A DOCTYPE token
			 * &gt; Parse error. Ignore the token.
			 */
			case 'html':
				return $this-&gt;step();

			/*
			 * &gt; A start tag whose tag name is "html"
			 */
			case '+HTML':
				if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;contains( 'TEMPLATE' ) ) {
					/*
					 * &gt; Otherwise, for each attribute on the token, check to see if the attribute
					 * &gt; is already present on the top element of the stack of open elements. If
					 * &gt; it is not, add the attribute and its corresponding value to that element.
					 *
					 * This parser does not currently support this behavior: ignore the token.
					 */
				}

				// Ignore the token.
				return $this-&gt;step();

			/*
			 * &gt; A start tag whose tag name is one of: "base", "basefont", "bgsound", "link",
			 * &gt; "meta", "noframes", "script", "style", "template", "title"
			 * &gt;
			 * &gt; An end tag whose tag name is "template"
			 */
			case '+BASE':
			case '+BASEFONT':
			case '+BGSOUND':
			case '+LINK':
			case '+META':
			case '+NOFRAMES':
			case '+SCRIPT':
			case '+STYLE':
			case '+TEMPLATE':
			case '+TITLE':
			case '-TEMPLATE':
				return $this-&gt;step_in_head();

			/*
			 * &gt; A start tag whose tag name is "body"
			 *
			 * This tag in the IN BODY insertion mode is a parse error.
			 */
			case '+BODY':
				if (
					1 === $this-&gt;state-&gt;stack_of_open_elements-&gt;count() ||
					'BODY' !== ( $this-&gt;state-&gt;stack_of_open_elements-&gt;at( 2 )-&gt;node_name ?? null ) ||
					$this-&gt;state-&gt;stack_of_open_elements-&gt;contains( 'TEMPLATE' )
				) {
					// Ignore the token.
					return $this-&gt;step();
				}

				/*
				 * &gt; Otherwise, set the frameset-ok flag to "not ok"; then, for each attribute
				 * &gt; on the token, check to see if the attribute is already present on the body
				 * &gt; element (the second element) on the stack of open elements, and if it is
				 * &gt; not, add the attribute and its corresponding value to that element.
				 *
				 * This parser does not currently support this behavior: ignore the token.
				 */
				$this-&gt;state-&gt;frameset_ok = false;
				return $this-&gt;step();

			/*
			 * &gt; A start tag whose tag name is "frameset"
			 *
			 * This tag in the IN BODY insertion mode is a parse error.
			 */
			case '+FRAMESET':
				if (
					1 === $this-&gt;state-&gt;stack_of_open_elements-&gt;count() ||
					'BODY' !== ( $this-&gt;state-&gt;stack_of_open_elements-&gt;at( 2 )-&gt;node_name ?? null ) ||
					false === $this-&gt;state-&gt;frameset_ok
				) {
					// Ignore the token.
					return $this-&gt;step();
				}

				/*
				 * &gt; Otherwise, run the following steps:
				 */
				$this-&gt;bail( 'Cannot process non-ignored FRAMESET tags.' );
				break;

			/*
			 * &gt; An end tag whose tag name is "body"
			 */
			case '-BODY':
				if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;has_element_in_scope( 'BODY' ) ) {
					// Parse error: ignore the token.
					return $this-&gt;step();
				}

				/*
				 * &gt; Otherwise, if there is a node in the stack of open elements that is not either a
				 * &gt; dd element, a dt element, an li element, an optgroup element, an option element,
				 * &gt; a p element, an rb element, an rp element, an rt element, an rtc element, a tbody
				 * &gt; element, a td element, a tfoot element, a th element, a thread element, a tr
				 * &gt; element, the body element, or the html element, then this is a parse error.
				 *
				 * There is nothing to do for this parse error, so don't check for it.
				 */

				$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_AFTER_BODY;
				return true;

			/*
			 * &gt; An end tag whose tag name is "html"
			 */
			case '-HTML':
				if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;has_element_in_scope( 'BODY' ) ) {
					// Parse error: ignore the token.
					return $this-&gt;step();
				}

				/*
				 * &gt; Otherwise, if there is a node in the stack of open elements that is not either a
				 * &gt; dd element, a dt element, an li element, an optgroup element, an option element,
				 * &gt; a p element, an rb element, an rp element, an rt element, an rtc element, a tbody
				 * &gt; element, a td element, a tfoot element, a th element, a thread element, a tr
				 * &gt; element, the body element, or the html element, then this is a parse error.
				 *
				 * There is nothing to do for this parse error, so don't check for it.
				 */

				$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_AFTER_BODY;
				return $this-&gt;step( self::REPROCESS_CURRENT_NODE );

			/*
			 * &gt; A start tag whose tag name is one of: "address", "article", "aside",
			 * &gt; "blockquote", "center", "details", "dialog", "dir", "div", "dl",
			 * &gt; "fieldset", "figcaption", "figure", "footer", "header", "hgroup",
			 * &gt; "main", "menu", "nav", "ol", "p", "search", "section", "summary", "ul"
			 */
			case '+ADDRESS':
			case '+ARTICLE':
			case '+ASIDE':
			case '+BLOCKQUOTE':
			case '+CENTER':
			case '+DETAILS':
			case '+DIALOG':
			case '+DIR':
			case '+DIV':
			case '+DL':
			case '+FIELDSET':
			case '+FIGCAPTION':
			case '+FIGURE':
			case '+FOOTER':
			case '+HEADER':
			case '+HGROUP':
			case '+MAIN':
			case '+MENU':
			case '+NAV':
			case '+OL':
			case '+P':
			case '+SEARCH':
			case '+SECTION':
			case '+SUMMARY':
			case '+UL':
				if ( $this-&gt;state-&gt;stack_of_open_elements-&gt;has_p_in_button_scope() ) {
					$this-&gt;close_a_p_element();
				}

				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A start tag whose tag name is one of: "h1", "h2", "h3", "h4", "h5", "h6"
			 */
			case '+H1':
			case '+H2':
			case '+H3':
			case '+H4':
			case '+H5':
			case '+H6':
				if ( $this-&gt;state-&gt;stack_of_open_elements-&gt;has_p_in_button_scope() ) {
					$this-&gt;close_a_p_element();
				}

				if (
					in_array(
						$this-&gt;state-&gt;stack_of_open_elements-&gt;current_node()-&gt;node_name,
						array( 'H1', 'H2', 'H3', 'H4', 'H5', 'H6' ),
						true
					)
				) {
					// @todo Indicate a parse error once it's possible.
					$this-&gt;state-&gt;stack_of_open_elements-&gt;pop();
				}

				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			/*
			 * &gt; A start tag whose tag name is one of: "pre", "listing"
			 */
			case '+PRE':
			case '+LISTING':
				if ( $this-&gt;state-&gt;stack_of_open_elements-&gt;has_p_in_button_scope() ) {
					$this-&gt;close_a_p_element();
				}

				/*
				 * &gt; If the next token is a U+000A LINE FEED (LF) character token,
				 * &gt; then ignore that token and move on to the next one. (Newlines
				 * &gt; at the start of pre blocks are ignored as an authoring convenience.)
				 *
				 * This is handled in `get_modifiable_text()`.
				 */

				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				$this-&gt;state-&gt;frameset_ok = false;
				return true;

			/*
			 * &gt; A start tag whose tag name is "form"
			 */
			case '+FORM':
				$stack_contains_template = $this-&gt;state-&gt;stack_of_open_elements-&gt;contains( 'TEMPLATE' );

				if ( isset( $this-&gt;state-&gt;form_element ) &amp;&amp; ! $stack_contains_template ) {
					// Parse error: ignore the token.
					return $this-&gt;step();
				}

				if ( $this-&gt;state-&gt;stack_of_open_elements-&gt;has_p_in_button_scope() ) {
					$this-&gt;close_a_p_element();
				}

				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				if ( ! $stack_contains_template ) {
					$this-&gt;state-&gt;form_element = $this-&gt;state-&gt;current_token;
				}

				return true;

			/*
			 * &gt; A start tag whose tag name is "li"
			 * &gt; A start tag whose tag name is one of: "dd", "dt"
			 */
			case '+DD':
			case '+DT':
			case '+LI':
				$this-&gt;state-&gt;frameset_ok = false;
				$node                     = $this-&gt;state-&gt;stack_of_open_elements-&gt;current_node();
				$is_li                    = 'LI' === $token_name;

				in_body_list_loop:
				/*
				 * The logic for LI and DT/DD is the same except for one point: LI elements _only_
				 * close other LI elements, but a DT or DD element closes _any_ open DT or DD element.
				 */
				if ( $is_li ? 'LI' === $node-&gt;node_name : ( 'DD' === $node-&gt;node_name || 'DT' === $node-&gt;node_name ) ) {
					$node_name = $is_li ? 'LI' : $node-&gt;node_name;
					$this-&gt;generate_implied_end_tags( $node_name );
					if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;current_node_is( $node_name ) ) {
						// @todo Indicate a parse error once it's possible. This error does not impact the logic here.
					}

					$this-&gt;state-&gt;stack_of_open_elements-&gt;pop_until( $node_name );
					goto in_body_list_done;
				}

				if (
					'ADDRESS' !== $node-&gt;node_name &amp;&amp;
					'DIV' !== $node-&gt;node_name &amp;&amp;
					'P' !== $node-&gt;node_name &amp;&amp;
					self::is_special( $node )
				) {
					/*
					 * &gt; If node is in the special category, but is not an address, div,
					 * &gt; or p element, then jump to the step labeled done below.
					 */
					goto in_body_list_done;
				} else {
					/*
					 * &gt; Otherwise, set node to the previous entry in the stack of open elements
					 * &gt; and return to the step labeled loop.
					 */
					foreach ( $this-&gt;state-&gt;stack_of_open_elements-&gt;walk_up( $node ) as $item ) {
						$node = $item;
						break;
					}
					goto in_body_list_loop;
				}

				in_body_list_done:
				if ( $this-&gt;state-&gt;stack_of_open_elements-&gt;has_p_in_button_scope() ) {
					$this-&gt;close_a_p_element();
				}

				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				return true;

			case '+PLAINTEXT':
				if ( $this-&gt;state-&gt;stack_of_open_elements-&gt;has_p_in_button_scope() ) {
					$this-&gt;close_a_p_element();
				}

				/*
				 * @todo This may need to be handled in the Tag Processor and turn into
				 *       a single self-contained tag like TEXTAREA, whose modifiable text
				 *       is the rest of the input document as plaintext.
				 */
				$this-&gt;bail( 'Cannot process PLAINTEXT elements.' );
				break;

			/*
			 * &gt; A start tag whose tag name is "button"
			 */
			case '+BUTTON':
				if ( $this-&gt;state-&gt;stack_of_open_elements-&gt;has_element_in_scope( 'BUTTON' ) ) {
					// @todo Indicate a parse error once it's possible. This error does not impact the logic here.
					$this-&gt;generate_implied_end_tags();
					$this-&gt;state-&gt;stack_of_open_elements-&gt;pop_until( 'BUTTON' );
				}

				$this-&gt;reconstruct_active_formatting_elements();
				$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				$this-&gt;state-&gt;frameset_ok = false;

				return true;

			/*
			 * &gt; An end tag whose tag name is one of: "address", "article", "aside", "blockquote",
			 * &gt; "button", "center", "details", "dialog", "dir", "div", "dl", "fieldset",
			 * &gt; "figcaption", "figure", "footer", "header", "hgroup", "listing", "main",
			 * &gt; "menu", "nav", "ol", "pre", "search", "section", "summary", "ul"
			 */
			case '-ADDRESS':
			case '-ARTICLE':
			case '-ASIDE':
			case '-BLOCKQUOTE':
			case '-BUTTON':
			case '-CENTER':
			case '-DETAILS':
			case '-DIALOG':
			case '-DIR':
			case '-DIV':
			case '-DL':
			case '-FIELDSET':
			case '-FIGCAPTION':
			case '-FIGURE':
			case '-FOOTER':
			case '-HEADER':
			case '-HGROUP':
			case '-LISTING':
			case '-MAIN':
			case '-MENU':
			case '-NAV':
			case '-OL':
			case '-PRE':
			case '-SEARCH':
			case '-SECTION':
			case '-SUMMARY':
			case '-UL':
				if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;has_element_in_scope( $token_name ) ) {
					// @todo Report parse error.
					// Ignore the token.
					return $this-&gt;step();
				}

				$this-&gt;generate_implied_end_tags();
				if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;current_node_is( $token_name ) ) {
					// @todo Record parse error: this error doesn't impact parsing.
				}
				$this-&gt;state-&gt;stack_of_open_elements-&gt;pop_until( $token_name );
				return true;

			/*
			 * &gt; An end tag whose tag name is "form"
			 */
			case '-FORM':
				if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;contains( 'TEMPLATE' ) ) {
					$node                      = $this-&gt;state-&gt;form_element;
					$this-&gt;state-&gt;form_element = null;

					/*
					 * &gt; If node is null or if the stack of open elements does not have node
					 * &gt; in scope, then this is a parse error; return and ignore the token.
					 *
					 * @todo It's necessary to check if the form token itself is in scope, not
					 *       simply whether any FORM is in scope.
					 */
					if (
						null === $node ||
						! $this-&gt;state-&gt;stack_of_open_elements-&gt;has_element_in_scope( 'FORM' )
					) {
						// Parse error: ignore the token.
						return $this-&gt;step();
					}

					$this-&gt;generate_implied_end_tags();
					if ( $node !== $this-&gt;state-&gt;stack_of_open_elements-&gt;current_node() ) {
						// @todo Indicate a parse error once it's possible. This error does not impact the logic here.
						$this-&gt;bail( 'Cannot close a FORM when other elements remain open as this would throw off the breadcrumbs for the following tokens.' );
					}

					$this-&gt;state-&gt;stack_of_open_elements-&gt;remove_node( $node );
					return true;
				} else {
					/*
					 * &gt; If the stack of open elements does not have a form element in scope,
					 * &gt; then this is a parse error; return and ignore the token.
					 *
					 * Note that unlike in the clause above, this is checking for any FORM in scope.
					 */
					if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;has_element_in_scope( 'FORM' ) ) {
						// Parse error: ignore the token.
						return $this-&gt;step();
					}

					$this-&gt;generate_implied_end_tags();

					if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;current_node_is( 'FORM' ) ) {
						// @todo Indicate a parse error once it's possible. This error does not impact the logic here.
					}

					$this-&gt;state-&gt;stack_of_open_elements-&gt;pop_until( 'FORM' );
					return true;
				}
				break;

			/*
			 * &gt; An end tag whose tag name is "p"
			 */
			case '-P':
				if ( ! $this-&gt;state-&gt;stack_of_open_elements-&gt;has_p_in_button_scope() ) {
					$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
				}

				$this-&gt;close_a_p_element();
				return true;

			/*
			 * &gt; An end tag whose tag name is "li"
</code></pre>
<p class="wporg-dot-link-list"><a href="https://developer.wordpress.org/reference/files/wp-includes/html-api/class-wp-html-processor.php/">View all references</a> <a href="https://core.trac.wordpress.org/browser/tags/6.7/src/wp-includes/html-api/class-wp-html-processor.php#L139">View on Trac</a> <a href="https://github.com/WordPress/wordpress-develop/blob/6.7/src/wp-includes/html-api/class-wp-html-processor.php#L139-L2472">View on GitHub</a></p></section>  <section><h2 id="changelog">Changelog</h2> <section style="margin-top:var(--wp--preset--spacing--20);"><figure class="wp-block-table "><table>
<thead><tr>
<th scope="col">Version</th>
<th scope="col">Description</th>
</tr></thead>
<tbody><tr class="">
<td><a href="https://developer.wordpress.org/reference/since/6.4.0/">6.4.0</a></td>
<td>Introduced.</td>
</tr></tbody>
</table></figure></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2003&ndash;2024 WordPress Foundation<br>Licensed under the GNU GPLv2+ License.<br>
    <a href="https://developer.wordpress.org/reference/classes/wp_html_processor" class="_attribution-link">https://developer.wordpress.org/reference/classes/wp_html_processor</a>
  </p>
</div>
