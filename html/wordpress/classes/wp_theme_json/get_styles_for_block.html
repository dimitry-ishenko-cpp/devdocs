<h1>WP_Theme_JSON::get_styles_for_block( array $block_metadata ): string</h1>  <section> <p>Gets the CSS rules for a particular block from theme.json.</p> </section>   <section> <header class="toc-header"><h2 id="parameters">Parameters</h2></header> <dl> <dt> <code>$block_metadata</code> <span class="type"><span class="array">array</span></span> <span class="required">Required</span> </dt> <dd> <div class="desc"> <span class="description">Metadata about the block to get styles for.</span> </div> </dd> </dl> </section>  <section> <header class="toc-header"><h2 id="return">Return</h2></header> <p><span class="return-type">string</span> Styles for the block.</p> </section>  <section> <header class="toc-header"><h2 id="source">Source</h2></header> <p> File: <code>wp-includes/class-wp-theme-json.php</code>. <a href="https://developer.wordpress.org/reference/files/wp-includes/class-wp-theme-json.php/">View all references</a> </p> <pre class="wp-block-code" data-start="2006" aria-label="Function source code" data-language="php"><code lang="php" class="language-php line-numbers">public function get_styles_for_block( $block_metadata ) {
	$node             = _wp_array_get( $this-&gt;theme_json, $block_metadata['path'], array() );
	$use_root_padding = isset( $this-&gt;theme_json['settings']['useRootPaddingAwareAlignments'] ) &amp;&amp; true === $this-&gt;theme_json['settings']['useRootPaddingAwareAlignments'];
	$selector         = $block_metadata['selector'];
	$settings         = _wp_array_get( $this-&gt;theme_json, array( 'settings' ) );

	/*
	 * Process style declarations for block support features the current
	 * block contains selectors for. Values for a feature with a custom
	 * selector are filtered from the theme.json node before it is
	 * processed as normal.
	*/
	$feature_declarations = array();

	if ( ! empty( $block_metadata['features'] ) ) {
		foreach ( $block_metadata['features'] as $feature_name =&gt; $feature_selector ) {
			if ( ! empty( $node[ $feature_name ] ) ) {
				// Create temporary node containing only the feature data
				// to leverage existing `compute_style_properties` function.
				$feature = array( $feature_name =&gt; $node[ $feature_name ] );
				// Generate the feature's declarations only.
				$new_feature_declarations = static::compute_style_properties( $feature, $settings, null, $this-&gt;theme_json );

				// Merge new declarations with any that already exist for
				// the feature selector. This may occur when multiple block
				// support features use the same custom selector.
				if ( isset( $feature_declarations[ $feature_selector ] ) ) {
					$feature_declarations[ $feature_selector ] = array_merge( $feature_declarations[ $feature_selector ], $new_feature_declarations );
				} else {
					$feature_declarations[ $feature_selector ] = $new_feature_declarations;
				}

				// Remove the feature from the block's node now the
				// styles will be included under the feature level selector.
				unset( $node[ $feature_name ] );
			}
		}
	}

	/*
	 * Get a reference to element name from path.
	 * $block_metadata['path'] = array( 'styles','elements','link' );
	 * Make sure that $block_metadata['path'] describes an element node, like [ 'styles', 'element', 'link' ].
	 * Skip non-element paths like just ['styles'].
	 */
	$is_processing_element = in_array( 'elements', $block_metadata['path'], true );

	$current_element = $is_processing_element ? $block_metadata['path'][ count( $block_metadata['path'] ) - 1 ] : null;

	$element_pseudo_allowed = array();

	if ( array_key_exists( $current_element, static::VALID_ELEMENT_PSEUDO_SELECTORS ) ) {
		$element_pseudo_allowed = static::VALID_ELEMENT_PSEUDO_SELECTORS[ $current_element ];
	}

	/*
	 * Check for allowed pseudo classes (e.g. ":hover") from the $selector ("a:hover").
	 * This also resets the array keys.
	 */
	$pseudo_matches = array_values(
		array_filter(
			$element_pseudo_allowed,
			function( $pseudo_selector ) use ( $selector ) {
				return str_contains( $selector, $pseudo_selector );
			}
		)
	);

	$pseudo_selector = isset( $pseudo_matches[0] ) ? $pseudo_matches[0] : null;

	/*
	 * If the current selector is a pseudo selector that's defined in the allow list for the current
	 * element then compute the style properties for it.
	 * Otherwise just compute the styles for the default selector as normal.
	 */
	if ( $pseudo_selector &amp;&amp; isset( $node[ $pseudo_selector ] ) &amp;&amp;
		array_key_exists( $current_element, static::VALID_ELEMENT_PSEUDO_SELECTORS )
		&amp;&amp; in_array( $pseudo_selector, static::VALID_ELEMENT_PSEUDO_SELECTORS[ $current_element ], true )
	) {
		$declarations = static::compute_style_properties( $node[ $pseudo_selector ], $settings, null, $this-&gt;theme_json, $selector, $use_root_padding );
	} else {
		$declarations = static::compute_style_properties( $node, $settings, null, $this-&gt;theme_json, $selector, $use_root_padding );
	}

	$block_rules = '';

	/*
	 * 1. Separate the declarations that use the general selector
	 * from the ones using the duotone selector.
	 */
	$declarations_duotone = array();
	foreach ( $declarations as $index =&gt; $declaration ) {
		if ( 'filter' === $declaration['name'] ) {
			unset( $declarations[ $index ] );
			$declarations_duotone[] = $declaration;
		}
	}

	// 2. Generate and append the rules that use the general selector.
	$block_rules .= static::to_ruleset( $selector, $declarations );

	// 3. Generate and append the rules that use the duotone selector.
	if ( isset( $block_metadata['duotone'] ) &amp;&amp; ! empty( $declarations_duotone ) ) {
		$selector_duotone = static::scope_selector( $block_metadata['selector'], $block_metadata['duotone'] );
		$block_rules     .= static::to_ruleset( $selector_duotone, $declarations_duotone );
	}

	// 4. Generate Layout block gap styles.
	if (
		static::ROOT_BLOCK_SELECTOR !== $selector &amp;&amp;
		! empty( $block_metadata['name'] )
	) {
		$block_rules .= $this-&gt;get_layout_styles( $block_metadata );
	}

	// 5. Generate and append the feature level rulesets.
	foreach ( $feature_declarations as $feature_selector =&gt; $individual_feature_declarations ) {
		$block_rules .= static::to_ruleset( $feature_selector, $individual_feature_declarations );
	}

	return $block_rules;
}
</code></pre>  </section>  <section> <header class="toc-header"><h2 id="related">Related</h2></header> <article class="uses"> <header class="toc-header"><h3 id="uses">Uses</h3></header> <table id="uses-table" data-show="2">  <thead> <tr> <th>Uses</th> <th class="related-desc">Description</th> </tr> </thead> <tbody> <tr> <td class="related-title"> <a href="get_layout_styles.html">WP_Theme_JSON::get_layout_styles()</a> <span>wp-includes/class-wp-theme-json.php</span> </td> <td class="related-desc"> <p>Gets the CSS layout rules for a particular block from theme.json layout definitions.</p> </td> </tr> <tr> <td class="related-title"> <a href="../../functions/_wp_array_get.html">_wp_array_get()</a> <span>wp-includes/functions.php</span> </td> <td class="related-desc"> <p>Accesses an array in depth based on a path of keys.</p> </td> </tr> </tbody>

</table> </article> </section>  <section> <header class="toc-header"><h2 id="changelog">Changelog</h2></header> <table>  <thead> <tr> <th class="changelog-version">Version</th> <th class="changelog-desc">Description</th> </tr> </thead> <tbody> <tr> <td><a href="https://developer.wordpress.org/reference/since/6.1.0/" alt="WordPress 6.1.0">6.1.0</a></td> <td>Introduced.</td> </tr> </tbody> </table> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2003&ndash;2022 WordPress Foundation<br>Licensed under the GNU GPLv2+ License.<br>
    <a href="https://developer.wordpress.org/reference/classes/wp_theme_json/get_styles_for_block" class="_attribution-link">https://developer.wordpress.org/reference/classes/wp_theme_json/get_styles_for_block</a>
  </p>
</div>
