<h1 class="wp-block-wporg-code-reference-title">
<span class="keyword">class</span> WP_User_Query {}</h1> <section><p>Core class used for querying users.</p> </section> <section><h2 id="description">Description</h2> <h3 id="see-also">See also</h3>
<ul>
<li>
<a href="wp_user_query/prepare_query.html">WP_User_Query::prepare_query()</a>: for information on accepted arguments.</li> </ul></section> <section><h2 id="more-information">More Information</h2> <p>This class allows querying WordPress database tables ‘<tt>wp_users</tt>‘ and ‘<tt>wp_usermeta</tt>‘.</p> <h2 id="usage">Usage</h2> <pre class="wp-block-preformatted" data-language="php">&lt;?php
$args = array(
	.
	.
	.
);

// The Query
$user_query = new WP_User_Query( $args );

// User Loop
if ( ! empty( $user_query-&gt;get_results() ) ) {
	foreach ( $user_query-&gt;get_results() as $user ) {
		echo '&lt;p&gt;' . $user-&gt;display_name . '&lt;/p&gt;';
	}
} else {
	echo 'No users found.';
}
?&gt;
</pre> <h2 id="parameters">Parameters</h2> <h3 id="user-role-parameter">User Role Parameter</h3> <p>Show users associated with certain role.</p> <ul class="wp-block-list"> <li>
<b><tt>role</tt></b> (<i>string / array</i>) – use <a title="Roles and Capabilities" href="https://wordpress.org/support/article/roles-and-capabilities/">User Role</a>. An array or a comma-separated list of role names that users must match to be included in results. Note that this is an inclusive list: users must match *each* role. Default empty.</li> <li>
<b><tt>role__in</tt></b> (<i>array</i>) – An array of role names. Matched users must have at least one of these roles. Default empty array. (since <a title="Version 4.4" href="https://codex.wordpress.org/Version_4.4">Version 4.4</a>).</li> <li>
<b><tt>role__not_in</tt></b> (<i>array</i>) – An array of role names to exclude. Users matching one or more of these roles will not be included in results. Default empty array. (since <a title="Version 4.4" href="https://codex.wordpress.org/Version_4.4">Version 4.4</a>).</li> </ul> <p><b>Display Administrator role users</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'role' =&gt; 'Administrator' ) );
</pre> <p><b>Display Subscriber role users</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'role' =&gt; 'Subscriber' ) );
</pre> <p><b>Display all users except Subscriber role users</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'role__not_in' =&gt; 'Subscriber' ) );
</pre> <h3 id="include-exclude-parameters">Include &amp; Exclude Parameters</h3> <p>Show specific users.</p> <ul class="wp-block-list"> <li>
<b><tt>include</tt></b> (<i>array</i>) – List of users to be included.</li> <li>
<b><tt>exclude</tt></b> (<i>array</i>) – List of users to be excluded.</li> </ul> <p><b>Display specific users list</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'include' =&gt; array( 1, 2, 3 ) ) );
</pre> <p><b>Display all users except a specific list of users</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'exclude' =&gt; array( 4, 5, 6 ) ) );
</pre> <h3 id="blog-parameter">Blog Parameter</h3> <p>Show users associated with certain blog on the network.</p> <ul class="wp-block-list"> <li>
<b><tt>blog_id</tt></b> (<i>int</i>) – The blog id on a multisite environment. Defaults to the current blog id.</li> </ul> <p><b>Display users from blog 33</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'blog_id' =&gt; 33 ) );
</pre> <h3 id="search-parameters">Search Parameters</h3> <p>Search users.</p> <ul class="wp-block-list"> <li>
<b><tt>search</tt></b> (<i>string</i>) – Searches for possible string matches on columns. Use of the * wildcard before and/or after the string will match on columns <tt>starting with*</tt>, <tt>*ending with</tt>, or <tt>*containing*</tt> the string you enter.</li> <li>
<b><tt>search_columns</tt></b> (<i>array</i>) – List of <a title="Database Description" href="https://codex.wordpress.org/Database_Description#Table:_wp_users">database table columns</a> to matches the search string across multiple columns. <ul class="wp-block-list"> <li>‘<tt>ID</tt>‘ – Search by user id.</li> <li>‘<tt>user_login</tt>‘ – Search by user login.</li> <li>‘<tt>user_nicename</tt>‘ – Search by user nicename.</li> <li>‘<tt>user_email</tt>‘ – Search by user email.</li> <li>‘<tt>user_url</tt>‘ – Search by user url.</li> </ul> </li> </ul> <p>We can use the <a title="Plugin API/Filter Reference/user search columns" href="../hooks/user_search_columns.html">user_search_columns</a> filter to modify the search columns.</p> <p><b>Display users based on a keyword search</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'search' =&gt; 'Rami' ) );
</pre> <p><b>Display users based on a keyword search, only on login and email columns</b></p> <pre class="wp-block-preformatted" data-language="php">$args = array(
	'search'         =&gt; 'Rami',
	'search_columns' =&gt; array( 'user_login', 'user_email' )
);
$user_query = new WP_User_Query( $args );
</pre> <h3 id="pagination-parameters">Pagination Parameters</h3> <p>Limit retrieved Users.</p> <ul class="wp-block-list"> <li>
<b><tt>number</tt></b> (<i>int</i>) – The maximum returned number of results (needed in pagination).</li> <li>
<b><tt>offset</tt></b> (<i>int</i>) – Offset the returned results (needed in pagination).</li> <li>
<b><tt>paged</tt></b> (<i>int</i>) – When used with number, defines the page of results to return. Default 1. (since <a title="Version 4.4" href="https://codex.wordpress.org/Version_4.4">Version 4.4</a>).</li> </ul> <p><b>Display 10 users</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'number' =&gt; 10 ) );
</pre> <p><b>Display 5 users starting from 25</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'number' =&gt; 5, 'offset' =&gt; 25 ) );
</pre> <h3 id="order-orderby-parameters">Order &amp; Orderby Parameters</h3> <p>Sort retrieved Users.</p> <ul class="wp-block-list"> <li>
<b><tt>orderby</tt></b> (<i>string|array</i>) – Sort retrieved users by parameter. Defaults to ‘login’. It can be a string with a single field, a string containing a list of values separated by commas or spaces, or an array with fields. <ul class="wp-block-list"> <li>‘<tt>ID</tt>‘ – Order by user id.</li> <li>‘<tt>display_name</tt>‘ – Order by user display name.</li> <li>‘<tt>name</tt>‘ / ‘<tt>user_name</tt>‘ – Order by user name.</li> <li>‘<tt>include</tt>‘ – Order by the included list of user_ids (requires the include parameter) (since <a title="Version 4.1" href="https://codex.wordpress.org/Version_4.1">Version 4.1</a>).</li> <li>‘<tt>login</tt>‘ / ‘<tt>user_login</tt>‘ – Order by user login.</li> <li>‘<tt>nicename</tt>‘ / ‘<tt>user_nicename</tt>‘ – Order by user nicename.</li> <li>‘<tt>email</tt>‘ / ‘<tt>user_email</tt>‘ – Order by user email.</li> <li>‘<tt>url</tt>‘ / ‘<tt>user_url</tt>‘ – Order by user url.</li> <li>‘<tt>registered</tt>‘ / ‘<tt>user_registered</tt>‘ – Order by user registered date.</li> <li>‘<tt>post_count</tt>‘ – Order by user post count.</li> <li>‘<tt>meta_value</tt>‘ – Note that a ‘meta_key=keyname’ must also be present in the query (available with <a title="Version 3.7" href="https://codex.wordpress.org/Version_3.7">Version 3.7</a>).</li> <li>‘<tt>meta_value_num</tt>‘ – Note that a ‘meta_key=keyname’ must also be present in the query (available with <a title="Version 4.2" href="https://codex.wordpress.org/Version_4.2">Version 4.2</a>).</li> </ul> </li> <li>
<b><tt>order</tt></b> (<i>string</i>) – Designates the ascending or descending order of the ‘<tt>orderby</tt>‘ parameter. Defaults to ‘ASC’. <ul class="wp-block-list"> <li>‘<tt>ASC</tt>‘ – ascending order from lowest to highest values (1, 2, 3; a, b, c).</li> <li>‘<tt>DESC</tt>‘ – descending order from highest to lowest values (3, 2, 1; c, b, a).</li> </ul> </li> </ul> <p><b>Display users sorted by Post Count, Descending order</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array ( 'orderby' =&gt; 'post_count', 'order' =&gt; 'DESC' ) );
</pre> <p><b>Display users sorted by registered, Ascending order</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array ( 'orderby' =&gt; 'registered', 'order' =&gt; 'ASC' ) );
</pre> <h3 id="date-parameters">Date Parameters</h3> <p>Date queries are handled through to the <tt><a href="wp_date_query.html" rel="class">WP_Date_Query</a></tt> object and are applied to the <tt>user_registered</tt> field.</p> <p>Available since <a class="external text" href="https://codex.wordpress.org/Version_4.1" rel="nofollow">version 4.1</a>.</p> <ul class="wp-block-list"> <li>
<b><tt>date_query</tt></b> (<i>array</i>) – See the documentation for the <tt><a title="Class Reference/WP Query" href="wp_query.html"> WP_Query</a></tt> class.</li> </ul> <p><b>Find users that registered during the last 12 hours:</b></p> <pre class="wp-block-preformatted" data-language="php">$args = array(
    'date_query' =&gt; array( 
        array( 'after' =&gt; '12 hours ago', 'inclusive' =&gt; true )  
    )
);
$user_query = new WP_User_Query( $args );
</pre> <h3 id="custom-field-parameters">Custom Field Parameters</h3> <p>Show users associated with a certain custom field.</p> <p>The <tt><a title="Class Reference/WP Meta Query" href="wp_meta_query.html"> WP_Meta_Query</a></tt> class is used to parse this part of the query since <a title="Version 3.2" href="https://codex.wordpress.org/Version_3.2">3.2.0</a>, so check the docs for that class for the full, up to date <a title="Class Reference/WP Meta Query" href="wp_meta_query.html"> list of arguments</a>.</p> <ul class="wp-block-list"> <li>
<b><tt>meta_key</tt></b> (<i>string</i>) – Custom field key.</li> <li>
<b><tt>meta_value</tt></b> (<i>string</i>) – Custom field value.</li> <li>
<b><tt>meta_compare</tt></b> (<i>string</i>) – Operator to test the ‘<tt>meta_value</tt>‘. See <tt>'compare'</tt> below.</li> <li>
<b><tt>meta_query</tt></b> (<i>array</i>) – Custom field parameters (available with <a title="Version 3.5" href="https://codex.wordpress.org/Version_3.5">Version 3.5</a>). <ul class="wp-block-list"> <li>
<b><tt>key</tt></b> (<i>string</i>) – Custom field key.</li> <li>
<b><tt>value</tt></b> (<i>string</i>|<i>array</i>) – Custom field value (<i>Note</i>: Array support is limited to a compare value of ‘IN’, ‘NOT IN’, ‘BETWEEN’, ‘NOT BETWEEN’, ‘EXISTS’ or ‘NOT EXISTS’)</li> <li>
<b><tt>compare</tt></b> (<i>string</i>) – Operator to test. Possible values are ‘=’, ‘!=’, ‘&gt;’, ‘&gt;=’, ‘&lt;‘, ‘&lt;=’, ‘LIKE’, ‘NOT LIKE’, ‘IN’, ‘NOT IN’, ‘BETWEEN’, ‘NOT BETWEEN’, ‘EXISTS’, and ‘NOT EXISTS’ ; ‘REGEXP’, ‘NOT REGEXP’ and ‘RLIKE’ were added in WordPress 3.7. Default value is ‘=’.<br> <b>Note:</b> Currently <tt>'NOT EXISTS'</tt> does not always work as intended if <tt>'relation'</tt> is <tt>'OR'</tt> when, (1) using the <a href="https://codex.wordpress.org/Class_Reference/WP_User_Query#User_Role_Parameter"><tt>'role'</tt></a> parameter on single site installs, or (2) for any query on multisite. See <a class="external text" href="https://core.trac.wordpress.org/ticket/23849" rel="nofollow">ticket #23849</a>.<br> <b>Note 2:</b> with ‘LIKE’ the value parameter is change to ‘%&lt;value&gt;%’. So the string is searched anywhere in the custom field value. If value parameter contain a ‘%’ it is escaped. So it bans to search a string beginning by some characters, for exemple… To construct this query you must use ‘REGEXP’ with a regular expression in value parameter (ex : ‘^n.*’ matchs all values that beginning by “n” or “N”).</li> <li>
<b><tt>type</tt></b> (<i>string</i>) – Custom field type. Possible values are ‘NUMERIC’, ‘BINARY’, ‘CHAR’, ‘DATE’, ‘DATETIME’, ‘DECIMAL’, ‘SIGNED’, ‘TIME’, ‘UNSIGNED’. Default value is ‘CHAR’. You can also specify precision and scale for the ‘DECIMAL’ and ‘NUMERIC’ types (for example, ‘DECIMAL(10,5)’ or ‘NUMERIC(10)’ are valid).</li> </ul> </li> </ul> <p><b>Display users from Israel</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'meta_key' =&gt; 'country', 'meta_value' =&gt; 'Israel' ) );
</pre> <p><b>Display users under 30 years old</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'meta_key' =&gt; 'age', 'meta_value' =&gt; '30', 'meta_compare' =&gt; '&lt;' ) );
</pre> <p><b>Multiple custom user fields handling</b></p> <pre class="wp-block-preformatted" data-language="php">$args = array(
	'meta_query' =&gt; array(
		'relation' =&gt; 'OR',
			array(
				'key'     =&gt; 'country',
				'value'   =&gt; 'Israel',
	 			'compare' =&gt; '='
			),
			array(
				'key'     =&gt; 'age',
				'value'   =&gt; array( 20, 30 ),
				'type'    =&gt; 'numeric',
				'compare' =&gt; 'BETWEEN'
			)
	)
 );
$user_query = new WP_User_Query( $args );
</pre> <h3 id="who-parameter">Who Parameter</h3> <p>Which users?</p> <ul class="wp-block-list"> <li>
<b><tt>who</tt></b> (<i>string</i>) – Which users to query. Currently only ‘authors’ is supported. Default is all users.</li> </ul> <p><b>Display only authors</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'who' =&gt; 'authors' ) );
</pre> <p>Equals to:</p> <pre class="wp-block-preformatted" data-language="php">$args = array(
	'meta_key'     =&gt; 'user_level',
	'meta_value'   =&gt; '0',
	'meta_compare' =&gt; '!=',
	'blog_id'      =&gt; 0
)
$user_query = new WP_User_Query( $args );
</pre> <h3 id="total-count-parameter">Total Count Parameter</h3> <ul class="wp-block-list"> <li>
<b><tt>count_total</tt></b> (<i>boolean</i>) – Whether to count the total number of users found. When <tt>true</tt> (default), the total number of results for the query can be retrieved using the <tt>get_total()</tt> method. If you don’t need the total number of results, set this to <tt>false</tt>.</li> </ul> <h3 id="has-published-posts-parameter">Has Published Posts Parameter</h3> <ul class="wp-block-list"> <li>
<b><tt>has_published_posts</tt></b> (<i>boolean / array</i>) – Pass an array of post types to filter results to users who have published posts in those post types. <tt>true</tt> is an alias for all public post types. Default is <tt>null</tt>. Since <a title="Version 4.3" href="https://codex.wordpress.org/Version_4.3">Version 4.3</a>.</li> </ul> <h3 id="return-fields-parameter">Return Fields Parameter</h3> <p>Set return values.</p> <ul class="wp-block-list"> <li>
<b><tt>fields</tt></b> (<i>string|array</i>) – Which fields to return. Defaults to <i>all</i>. <ul class="wp-block-list"> <li>‘<tt>ID</tt>‘ – Return an array of user id’s.</li> <li>‘<tt>display_name</tt>‘ – Return an array of user display names.</li> <li>‘<tt>login</tt>‘ / ‘<tt>user_login</tt>‘ – Return an array of user login names.</li> <li>‘<tt>nicename</tt>‘ / ‘<tt>user_nicename</tt>‘ – Return an array of user nicenames.</li> <li>‘<tt>email</tt>‘ / ‘<tt>user_email</tt>‘ – Return an array of user emails.</li> <li>‘<tt>url</tt>‘ / ‘<tt>user_url</tt>‘ – Return an array of user urls.</li> <li>‘<tt>registered</tt>‘ / ‘<tt>user_registered</tt>‘ – Return an array of user registered dates.</li> <li>‘<tt>all</tt> (default) or <tt>all_with_meta</tt>‘ – Returns an array of <a title="Class Reference/WP User" href="https://codex.wordpress.org/Class_Reference/WP_User">WP_User</a> objects. Must pass an array to subset fields returned. *’all_with_meta’ currently returns the same fields as ‘all’ which does not include user fields stored in wp_usermeta. You must create a second query to get the user meta fields by ID or use the __get PHP magic method to get the values of these fields.</li> </ul> </li> </ul> <p><b>Return an array of <a href="wp_user.html" rel="class">WP_User</a> object</b></p> <pre class="wp-block-preformatted" data-language="php">$user_query = new WP_User_Query( array( 'role' =&gt; 'editor', 'fields' =&gt; 'all' ) );
</pre> <p><b>Return List all blog editors, return limited fields in resulting row objects:</b></p> <pre class="wp-block-preformatted" data-language="php">$user_fields = array( 'user_login', 'user_nicename', 'user_email', 'user_url' );
$user_query = new WP_User_Query( array( 'role' =&gt; 'editor', 'fields' =&gt; $user_fields ) );
</pre> <h2 id="return-values">Return Values</h2> <dl> <dt>(Array)</dt> <dd>An array of IDs, stdClass objects, or <a title="Class Reference/WP User" href="https://codex.wordpress.org/Class_Reference/WP_User">WP_User</a> objects, depending on the value of the ‘<tt>fields</tt>‘ parameter. <ul> <li>If ‘<tt>fields</tt>‘ is set to ‘all’ (default), or ‘all_with_meta’, it will return an array of <a title="Class Reference/WP User" href="https://codex.wordpress.org/Class_Reference/WP_User">WP_User</a> objects (does not include related user meta fields even with ‘all_with_meta’ set) .</li> <li>If ‘<tt>fields</tt>‘ is set to an array of <tt><a title="Database Description" href="https://codex.wordpress.org/Database_Description#Table:_wp_users"> wp_users</a></tt> table fields, it will return an array of stdClass objects with only those fields.</li> <li>If ‘<tt>fields</tt>‘ is set to any individual <tt><a title="Database Description" href="https://codex.wordpress.org/Database_Description#Table:_wp_users"> wp_users</a></tt> table field, an array of IDs will be returned.</li> </ul> </dd> </dl> <h2 id="filters">Filters</h2> <ul class="wp-block-list"> <li>
<b><tt><a class="new" title="Plugin API/Filter Reference/found users query (page does not exist)" href="../hooks/found_users_query.html">found_users_query</a></tt></b> – Alters SQL ‘SELECT FOUND_ROWS()’ clause to the query that returns the count total.</li> </ul> </section> <section><h2 id="methods">Methods</h2> <section style="margin-top:var(--wp--preset--spacing--20);" id="uses"><figure class="wp-block-table "><table>
<thead><tr>
<th scope="col">Name</th>
<th scope="col">Description</th>
</tr></thead>
<tbody>
<tr class="">
<td><a href="wp_user_query/__call.html">WP_User_Query::__call</a></td>
<td>Makes private/protected methods readable for backward compatibility.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/__construct.html">WP_User_Query::__construct</a></td>
<td>Constructor.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/__get.html">WP_User_Query::__get</a></td>
<td>Makes private properties readable for backward compatibility.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/__isset.html">WP_User_Query::__isset</a></td>
<td>Makes private properties checkable for backward compatibility.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/__set.html">WP_User_Query::__set</a></td>
<td>Makes private properties settable for backward compatibility.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/__unset.html">WP_User_Query::__unset</a></td>
<td>Makes private properties un-settable for backward compatibility.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/fill_query_vars.html">WP_User_Query::fill_query_vars</a></td>
<td>Fills in missing query variables with default values.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/generate_cache_key.html">WP_User_Query::generate_cache_key</a></td>
<td>Generate cache key.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/get.html">WP_User_Query::get</a></td>
<td>Retrieves query variable.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/get_results.html">WP_User_Query::get_results</a></td>
<td>Returns the list of users.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/get_search_sql.html">WP_User_Query::get_search_sql</a></td>
<td>Used internally to generate an SQL string for searching across multiple columns.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/get_total.html">WP_User_Query::get_total</a></td>
<td>Returns the total number of users for the current query.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/parse_order.html">WP_User_Query::parse_order</a></td>
<td>Parses an ‘order’ query variable and casts it to ASC or DESC as necessary.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/parse_orderby.html">WP_User_Query::parse_orderby</a></td>
<td>Parses and sanitizes ‘orderby’ keys passed to the user query.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/prepare_query.html">WP_User_Query::prepare_query</a></td>
<td>Prepares the query variables.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/query.html">WP_User_Query::query</a></td>
<td>Executes the query, with the current variables.</td>
</tr>
<tr class="">
<td><a href="wp_user_query/set.html">WP_User_Query::set</a></td>
<td>Sets query variable.</td>
</tr>
</tbody>
</table></figure></section> </section> <section><h2 id="source">Source</h2> <pre class="wp-block-code" data-start="18" aria-label="Function source code" data-language="php"><code id="wporg-source-code" lang="php" class="language-php line-numbers">class WP_User_Query {

	/**
	 * Query vars, after parsing
	 *
	 * @since 3.5.0
	 * @var array
	 */
	public $query_vars = array();

	/**
	 * List of found user IDs.
	 *
	 * @since 3.1.0
	 * @var array
	 */
	private $results;

	/**
	 * Total number of found users for the current query
	 *
	 * @since 3.1.0
	 * @var int
	 */
	private $total_users = 0;

	/**
	 * Metadata query container.
	 *
	 * @since 4.2.0
	 * @var WP_Meta_Query
	 */
	public $meta_query = false;

	/**
	 * The SQL query used to fetch matching users.
	 *
	 * @since 4.4.0
	 * @var string
	 */
	public $request;

	private $compat_fields = array( 'results', 'total_users' );

	// SQL clauses.
	public $query_fields;
	public $query_from;
	public $query_where;
	public $query_orderby;
	public $query_limit;

	/**
	 * Constructor.
	 *
	 * @since 3.1.0
	 *
	 * @param null|string|array $query Optional. The query variables.
	 *                                 See WP_User_Query::prepare_query() for information on accepted arguments.
	 */
	public function __construct( $query = null ) {
		if ( ! empty( $query ) ) {
			$this-&gt;prepare_query( $query );
			$this-&gt;query();
		}
	}

	/**
	 * Fills in missing query variables with default values.
	 *
	 * @since 4.4.0
	 *
	 * @param string|array $args Query vars, as passed to `WP_User_Query`.
	 * @return array Complete query variables with undefined ones filled in with defaults.
	 */
	public static function fill_query_vars( $args ) {
		$defaults = array(
			'blog_id'             =&gt; get_current_blog_id(),
			'role'                =&gt; '',
			'role__in'            =&gt; array(),
			'role__not_in'        =&gt; array(),
			'capability'          =&gt; '',
			'capability__in'      =&gt; array(),
			'capability__not_in'  =&gt; array(),
			'meta_key'            =&gt; '',
			'meta_value'          =&gt; '',
			'meta_compare'        =&gt; '',
			'include'             =&gt; array(),
			'exclude'             =&gt; array(),
			'search'              =&gt; '',
			'search_columns'      =&gt; array(),
			'orderby'             =&gt; 'login',
			'order'               =&gt; 'ASC',
			'offset'              =&gt; '',
			'number'              =&gt; '',
			'paged'               =&gt; 1,
			'count_total'         =&gt; true,
			'fields'              =&gt; 'all',
			'who'                 =&gt; '',
			'has_published_posts' =&gt; null,
			'nicename'            =&gt; '',
			'nicename__in'        =&gt; array(),
			'nicename__not_in'    =&gt; array(),
			'login'               =&gt; '',
			'login__in'           =&gt; array(),
			'login__not_in'       =&gt; array(),
			'cache_results'       =&gt; true,
		);

		return wp_parse_args( $args, $defaults );
	}

	/**
	 * Prepares the query variables.
	 *
	 * @since 3.1.0
	 * @since 4.1.0 Added the ability to order by the `include` value.
	 * @since 4.2.0 Added 'meta_value_num' support for `$orderby` parameter. Added multi-dimensional array syntax
	 *              for `$orderby` parameter.
	 * @since 4.3.0 Added 'has_published_posts' parameter.
	 * @since 4.4.0 Added 'paged', 'role__in', and 'role__not_in' parameters. The 'role' parameter was updated to
	 *              permit an array or comma-separated list of values. The 'number' parameter was updated to support
	 *              querying for all users with using -1.
	 * @since 4.7.0 Added 'nicename', 'nicename__in', 'nicename__not_in', 'login', 'login__in',
	 *              and 'login__not_in' parameters.
	 * @since 5.1.0 Introduced the 'meta_compare_key' parameter.
	 * @since 5.3.0 Introduced the 'meta_type_key' parameter.
	 * @since 5.9.0 Added 'capability', 'capability__in', and 'capability__not_in' parameters.
	 *              Deprecated the 'who' parameter.
	 * @since 6.3.0 Added 'cache_results' parameter.
	 *
	 * @global wpdb     $wpdb     WordPress database abstraction object.
	 * @global WP_Roles $wp_roles WordPress role management object.
	 *
	 * @param string|array $query {
	 *     Optional. Array or string of query parameters.
	 *
	 *     @type int             $blog_id             The site ID. Default is the current site.
	 *     @type string|string[] $role                An array or a comma-separated list of role names that users
	 *                                                must match to be included in results. Note that this is
	 *                                                an inclusive list: users must match *each* role. Default empty.
	 *     @type string[]        $role__in            An array of role names. Matched users must have at least one
	 *                                                of these roles. Default empty array.
	 *     @type string[]        $role__not_in        An array of role names to exclude. Users matching one or more
	 *                                                of these roles will not be included in results. Default empty array.
	 *     @type string|string[] $meta_key            Meta key or keys to filter by.
	 *     @type string|string[] $meta_value          Meta value or values to filter by.
	 *     @type string          $meta_compare        MySQL operator used for comparing the meta value.
	 *                                                See WP_Meta_Query::__construct() for accepted values and default value.
	 *     @type string          $meta_compare_key    MySQL operator used for comparing the meta key.
	 *                                                See WP_Meta_Query::__construct() for accepted values and default value.
	 *     @type string          $meta_type           MySQL data type that the meta_value column will be CAST to for comparisons.
	 *                                                See WP_Meta_Query::__construct() for accepted values and default value.
	 *     @type string          $meta_type_key       MySQL data type that the meta_key column will be CAST to for comparisons.
	 *                                                See WP_Meta_Query::__construct() for accepted values and default value.
	 *     @type array           $meta_query          An associative array of WP_Meta_Query arguments.
	 *                                                See WP_Meta_Query::__construct() for accepted values.
	 *     @type string|string[] $capability          An array or a comma-separated list of capability names that users
	 *                                                must match to be included in results. Note that this is
	 *                                                an inclusive list: users must match *each* capability.
	 *                                                Does NOT work for capabilities not in the database or filtered
	 *                                                via <a href="../hooks/map_meta_cap.html">'map_meta_cap'</a>. Default empty.
	 *     @type string[]        $capability__in      An array of capability names. Matched users must have at least one
	 *                                                of these capabilities.
	 *                                                Does NOT work for capabilities not in the database or filtered
	 *                                                via <a href="../hooks/map_meta_cap.html">'map_meta_cap'</a>. Default empty array.
	 *     @type string[]        $capability__not_in  An array of capability names to exclude. Users matching one or more
	 *                                                of these capabilities will not be included in results.
	 *                                                Does NOT work for capabilities not in the database or filtered
	 *                                                via <a href="../hooks/map_meta_cap.html">'map_meta_cap'</a>. Default empty array.
	 *     @type int[]           $include             An array of user IDs to include. Default empty array.
	 *     @type int[]           $exclude             An array of user IDs to exclude. Default empty array.
	 *     @type string          $search              Search keyword. Searches for possible string matches on columns.
	 *                                                When `$search_columns` is left empty, it tries to determine which
	 *                                                column to search in based on search string. Default empty.
	 *     @type string[]        $search_columns      Array of column names to be searched. Accepts 'ID', 'user_login',
	 *                                                'user_email', 'user_url', 'user_nicename', 'display_name'.
	 *                                                Default empty array.
	 *     @type string|array    $orderby             Field(s) to sort the retrieved users by. May be a single value,
	 *                                                an array of values, or a multi-dimensional array with fields as
	 *                                                keys and orders ('ASC' or 'DESC') as values. Accepted values are:
	 *                                                - 'ID'
	 *                                                - 'display_name' (or 'name')
	 *                                                - 'include'
	 *                                                - 'user_login' (or 'login')
	 *                                                - 'login__in'
	 *                                                - 'user_nicename' (or 'nicename')
	 *                                                - 'nicename__in'
	 *                                                - 'user_email (or 'email')
	 *                                                - 'user_url' (or 'url')
	 *                                                - 'user_registered' (or 'registered')
	 *                                                - 'post_count'
	 *                                                - 'meta_value'
	 *                                                - 'meta_value_num'
	 *                                                - The value of `$meta_key`
	 *                                                - An array key of `$meta_query`
	 *                                                To use 'meta_value' or 'meta_value_num', `$meta_key`
	 *                                                must be also be defined. Default 'user_login'.
	 *     @type string          $order               Designates ascending or descending order of users. Order values
	 *                                                passed as part of an `$orderby` array take precedence over this
	 *                                                parameter. Accepts 'ASC', 'DESC'. Default 'ASC'.
	 *     @type int             $offset              Number of users to offset in retrieved results. Can be used in
	 *                                                conjunction with pagination. Default 0.
	 *     @type int             $number              Number of users to limit the query for. Can be used in
	 *                                                conjunction with pagination. Value -1 (all) is supported, but
	 *                                                should be used with caution on larger sites.
	 *                                                Default -1 (all users).
	 *     @type int             $paged               When used with number, defines the page of results to return.
	 *                                                Default 1.
	 *     @type bool            $count_total         Whether to count the total number of users found. If pagination
	 *                                                is not needed, setting this to false can improve performance.
	 *                                                Default true.
	 *     @type string|string[] $fields              Which fields to return. Single or all fields (string), or array
	 *                                                of fields. Accepts:
	 *                                                - 'ID'
	 *                                                - 'display_name'
	 *                                                - 'user_login'
	 *                                                - 'user_nicename'
	 *                                                - 'user_email'
	 *                                                - 'user_url'
	 *                                                - 'user_registered'
	 *                                                - 'user_pass'
	 *                                                - 'user_activation_key'
	 *                                                - 'user_status'
	 *                                                - 'spam' (only available on multisite installs)
	 *                                                - 'deleted' (only available on multisite installs)
	 *                                                - 'all' for all fields and loads user meta.
	 *                                                - 'all_with_meta' Deprecated. Use 'all'.
	 *                                                Default 'all'.
	 *     @type string          $who                 Deprecated, use `$capability` instead.
	 *                                                Type of users to query. Accepts 'authors'.
	 *                                                Default empty (all users).
	 *     @type bool|string[]   $has_published_posts Pass an array of post types to filter results to users who have
	 *                                                published posts in those post types. `true` is an alias for all
	 *                                                public post types.
	 *     @type string          $nicename            The user nicename. Default empty.
	 *     @type string[]        $nicename__in        An array of nicenames to include. Users matching one of these
	 *                                                nicenames will be included in results. Default empty array.
	 *     @type string[]        $nicename__not_in    An array of nicenames to exclude. Users matching one of these
	 *                                                nicenames will not be included in results. Default empty array.
	 *     @type string          $login               The user login. Default empty.
	 *     @type string[]        $login__in           An array of logins to include. Users matching one of these
	 *                                                logins will be included in results. Default empty array.
	 *     @type string[]        $login__not_in       An array of logins to exclude. Users matching one of these
	 *                                                logins will not be included in results. Default empty array.
	 *     @type bool            $cache_results       Whether to cache user information. Default true.
	 * }
	 */
	public function prepare_query( $query = array() ) {
		global $wpdb, $wp_roles;

		if ( empty( $this-&gt;query_vars ) || ! empty( $query ) ) {
			$this-&gt;query_limit = null;
			$this-&gt;query_vars  = $this-&gt;fill_query_vars( $query );
		}

		/**
		 * Fires before the WP_User_Query has been parsed.
		 *
		 * The passed WP_User_Query object contains the query variables,
		 * not yet passed into SQL.
		 *
		 * @since 4.0.0
		 *
		 * @param WP_User_Query $query Current instance of WP_User_Query (passed by reference).
		 */
		do_action_ref_array( 'pre_get_users', array( &amp;$this ) );

		// Ensure that query vars are filled after 'pre_get_users'.
		$qv =&amp; $this-&gt;query_vars;
		$qv = $this-&gt;fill_query_vars( $qv );

		$allowed_fields = array(
			'id',
			'user_login',
			'user_pass',
			'user_nicename',
			'user_email',
			'user_url',
			'user_registered',
			'user_activation_key',
			'user_status',
			'display_name',
		);
		if ( is_multisite() ) {
			$allowed_fields[] = 'spam';
			$allowed_fields[] = 'deleted';
		}

		if ( is_array( $qv['fields'] ) ) {
			$qv['fields'] = array_map( 'strtolower', $qv['fields'] );
			$qv['fields'] = array_intersect( array_unique( $qv['fields'] ), $allowed_fields );

			if ( empty( $qv['fields'] ) ) {
				$qv['fields'] = array( 'id' );
			}

			$this-&gt;query_fields = array();
			foreach ( $qv['fields'] as $field ) {
				$field                = 'id' === $field ? 'ID' : sanitize_key( $field );
				$this-&gt;query_fields[] = "$wpdb-&gt;users.$field";
			}
			$this-&gt;query_fields = implode( ',', $this-&gt;query_fields );
		} elseif ( 'all_with_meta' === $qv['fields'] || 'all' === $qv['fields'] || ! in_array( $qv['fields'], $allowed_fields, true ) ) {
			$this-&gt;query_fields = "$wpdb-&gt;users.ID";
		} else {
			$field              = 'id' === strtolower( $qv['fields'] ) ? 'ID' : sanitize_key( $qv['fields'] );
			$this-&gt;query_fields = "$wpdb-&gt;users.$field";
		}

		if ( isset( $qv['count_total'] ) &amp;&amp; $qv['count_total'] ) {
			$this-&gt;query_fields = 'SQL_CALC_FOUND_ROWS ' . $this-&gt;query_fields;
		}

		$this-&gt;query_from  = "FROM $wpdb-&gt;users";
		$this-&gt;query_where = 'WHERE 1=1';

		// Parse and sanitize 'include', for use by 'orderby' as well as 'include' below.
		if ( ! empty( $qv['include'] ) ) {
			$include = wp_parse_id_list( $qv['include'] );
		} else {
			$include = false;
		}

		$blog_id = 0;
		if ( isset( $qv['blog_id'] ) ) {
			$blog_id = absint( $qv['blog_id'] );
		}

		if ( $qv['has_published_posts'] &amp;&amp; $blog_id ) {
			if ( true === $qv['has_published_posts'] ) {
				$post_types = get_post_types( array( 'public' =&gt; true ) );
			} else {
				$post_types = (array) $qv['has_published_posts'];
			}

			foreach ( $post_types as &amp;$post_type ) {
				$post_type = $wpdb-&gt;prepare( '%s', $post_type );
			}

			$posts_table        = $wpdb-&gt;get_blog_prefix( $blog_id ) . 'posts';
			$this-&gt;query_where .= " AND $wpdb-&gt;users.ID IN ( SELECT DISTINCT $posts_table.post_author FROM $posts_table WHERE $posts_table.post_status = 'publish' AND $posts_table.post_type IN ( " . implode( ', ', $post_types ) . ' ) )';
		}

		// nicename
		if ( '' !== $qv['nicename'] ) {
			$this-&gt;query_where .= $wpdb-&gt;prepare( ' AND user_nicename = %s', $qv['nicename'] );
		}

		if ( ! empty( $qv['nicename__in'] ) ) {
			$sanitized_nicename__in = array_map( 'esc_sql', $qv['nicename__in'] );
			$nicename__in           = implode( "','", $sanitized_nicename__in );
			$this-&gt;query_where     .= " AND user_nicename IN ( '$nicename__in' )";
		}

		if ( ! empty( $qv['nicename__not_in'] ) ) {
			$sanitized_nicename__not_in = array_map( 'esc_sql', $qv['nicename__not_in'] );
			$nicename__not_in           = implode( "','", $sanitized_nicename__not_in );
			$this-&gt;query_where         .= " AND user_nicename NOT IN ( '$nicename__not_in' )";
		}

		// login
		if ( '' !== $qv['login'] ) {
			$this-&gt;query_where .= $wpdb-&gt;prepare( ' AND user_login = %s', $qv['login'] );
		}

		if ( ! empty( $qv['login__in'] ) ) {
			$sanitized_login__in = array_map( 'esc_sql', $qv['login__in'] );
			$login__in           = implode( "','", $sanitized_login__in );
			$this-&gt;query_where  .= " AND user_login IN ( '$login__in' )";
		}

		if ( ! empty( $qv['login__not_in'] ) ) {
			$sanitized_login__not_in = array_map( 'esc_sql', $qv['login__not_in'] );
			$login__not_in           = implode( "','", $sanitized_login__not_in );
			$this-&gt;query_where      .= " AND user_login NOT IN ( '$login__not_in' )";
		}

		// Meta query.
		$this-&gt;meta_query = new WP_Meta_Query();
		$this-&gt;meta_query-&gt;parse_query_vars( $qv );

		if ( isset( $qv['who'] ) &amp;&amp; 'authors' === $qv['who'] &amp;&amp; $blog_id ) {
			_deprecated_argument(
				'WP_User_Query',
				'5.9.0',
				sprintf(
					/* translators: 1: who, 2: capability */
					__( '%1$s is deprecated. Use %2$s instead.' ),
					'&lt;code&gt;who&lt;/code&gt;',
					'&lt;code&gt;capability&lt;/code&gt;'
				)
			);

			$who_query = array(
				'key'     =&gt; $wpdb-&gt;get_blog_prefix( $blog_id ) . 'user_level',
				'value'   =&gt; 0,
				'compare' =&gt; '!=',
			);

			// Prevent extra meta query.
			$qv['blog_id'] = 0;
			$blog_id       = 0;

			if ( empty( $this-&gt;meta_query-&gt;queries ) ) {
				$this-&gt;meta_query-&gt;queries = array( $who_query );
			} else {
				// Append the cap query to the original queries and reparse the query.
				$this-&gt;meta_query-&gt;queries = array(
					'relation' =&gt; 'AND',
					array( $this-&gt;meta_query-&gt;queries, $who_query ),
				);
			}

			$this-&gt;meta_query-&gt;parse_query_vars( $this-&gt;meta_query-&gt;queries );
		}

		// Roles.
		$roles = array();
		if ( isset( $qv['role'] ) ) {
			if ( is_array( $qv['role'] ) ) {
				$roles = $qv['role'];
			} elseif ( is_string( $qv['role'] ) &amp;&amp; ! empty( $qv['role'] ) ) {
				$roles = array_map( 'trim', explode( ',', $qv['role'] ) );
			}
		}

		$role__in = array();
		if ( isset( $qv['role__in'] ) ) {
			$role__in = (array) $qv['role__in'];
		}

		$role__not_in = array();
		if ( isset( $qv['role__not_in'] ) ) {
			$role__not_in = (array) $qv['role__not_in'];
		}

		// Capabilities.
		$available_roles = array();

		if ( ! empty( $qv['capability'] ) || ! empty( $qv['capability__in'] ) || ! empty( $qv['capability__not_in'] ) ) {
			$wp_roles-&gt;for_site( $blog_id );
			$available_roles = $wp_roles-&gt;roles;
		}

		$capabilities = array();
		if ( ! empty( $qv['capability'] ) ) {
			if ( is_array( $qv['capability'] ) ) {
				$capabilities = $qv['capability'];
			} elseif ( is_string( $qv['capability'] ) ) {
				$capabilities = array_map( 'trim', explode( ',', $qv['capability'] ) );
			}
		}

		$capability__in = array();
		if ( ! empty( $qv['capability__in'] ) ) {
			$capability__in = (array) $qv['capability__in'];
		}

		$capability__not_in = array();
		if ( ! empty( $qv['capability__not_in'] ) ) {
			$capability__not_in = (array) $qv['capability__not_in'];
		}

		// Keep track of all capabilities and the roles they're added on.
		$caps_with_roles = array();

		foreach ( $available_roles as $role =&gt; $role_data ) {
			$role_caps = array_keys( array_filter( $role_data['capabilities'] ) );

			foreach ( $capabilities as $cap ) {
				if ( in_array( $cap, $role_caps, true ) ) {
					$caps_with_roles[ $cap ][] = $role;
					break;
				}
			}

			foreach ( $capability__in as $cap ) {
				if ( in_array( $cap, $role_caps, true ) ) {
					$role__in[] = $role;
					break;
				}
			}

			foreach ( $capability__not_in as $cap ) {
				if ( in_array( $cap, $role_caps, true ) ) {
					$role__not_in[] = $role;
					break;
				}
			}
		}

		$role__in     = array_merge( $role__in, $capability__in );
		$role__not_in = array_merge( $role__not_in, $capability__not_in );

		$roles        = array_unique( $roles );
		$role__in     = array_unique( $role__in );
		$role__not_in = array_unique( $role__not_in );

		// Support querying by capabilities added directly to users.
		if ( $blog_id &amp;&amp; ! empty( $capabilities ) ) {
			$capabilities_clauses = array( 'relation' =&gt; 'AND' );

			foreach ( $capabilities as $cap ) {
				$clause = array( 'relation' =&gt; 'OR' );

				$clause[] = array(
					'key'     =&gt; $wpdb-&gt;get_blog_prefix( $blog_id ) . 'capabilities',
					'value'   =&gt; '"' . $cap . '"',
					'compare' =&gt; 'LIKE',
				);

				if ( ! empty( $caps_with_roles[ $cap ] ) ) {
					foreach ( $caps_with_roles[ $cap ] as $role ) {
						$clause[] = array(
							'key'     =&gt; $wpdb-&gt;get_blog_prefix( $blog_id ) . 'capabilities',
							'value'   =&gt; '"' . $role . '"',
							'compare' =&gt; 'LIKE',
						);
					}
				}

				$capabilities_clauses[] = $clause;
			}

			$role_queries[] = $capabilities_clauses;

			if ( empty( $this-&gt;meta_query-&gt;queries ) ) {
				$this-&gt;meta_query-&gt;queries[] = $capabilities_clauses;
			} else {
				// Append the cap query to the original queries and reparse the query.
				$this-&gt;meta_query-&gt;queries = array(
					'relation' =&gt; 'AND',
					array( $this-&gt;meta_query-&gt;queries, array( $capabilities_clauses ) ),
				);
			}

			$this-&gt;meta_query-&gt;parse_query_vars( $this-&gt;meta_query-&gt;queries );
		}

		if ( $blog_id &amp;&amp; ( ! empty( $roles ) || ! empty( $role__in ) || ! empty( $role__not_in ) || is_multisite() ) ) {
			$role_queries = array();

			$roles_clauses = array( 'relation' =&gt; 'AND' );
			if ( ! empty( $roles ) ) {
				foreach ( $roles as $role ) {
					$roles_clauses[] = array(
						'key'     =&gt; $wpdb-&gt;get_blog_prefix( $blog_id ) . 'capabilities',
						'value'   =&gt; '"' . $role . '"',
						'compare' =&gt; 'LIKE',
					);
				}

				$role_queries[] = $roles_clauses;
			}

			$role__in_clauses = array( 'relation' =&gt; 'OR' );
			if ( ! empty( $role__in ) ) {
				foreach ( $role__in as $role ) {
					$role__in_clauses[] = array(
						'key'     =&gt; $wpdb-&gt;get_blog_prefix( $blog_id ) . 'capabilities',
						'value'   =&gt; '"' . $role . '"',
						'compare' =&gt; 'LIKE',
					);
				}

				$role_queries[] = $role__in_clauses;
			}

			$role__not_in_clauses = array( 'relation' =&gt; 'AND' );
			if ( ! empty( $role__not_in ) ) {
				foreach ( $role__not_in as $role ) {
					$role__not_in_clauses[] = array(
						'key'     =&gt; $wpdb-&gt;get_blog_prefix( $blog_id ) . 'capabilities',
						'value'   =&gt; '"' . $role . '"',
						'compare' =&gt; 'NOT LIKE',
					);
				}

				$role_queries[] = $role__not_in_clauses;
			}

			// If there are no specific roles named, make sure the user is a member of the site.
			if ( empty( $role_queries ) ) {
				$role_queries[] = array(
					'key'     =&gt; $wpdb-&gt;get_blog_prefix( $blog_id ) . 'capabilities',
					'compare' =&gt; 'EXISTS',
				);
			}

			// Specify that role queries should be joined with AND.
			$role_queries['relation'] = 'AND';

			if ( empty( $this-&gt;meta_query-&gt;queries ) ) {
				$this-&gt;meta_query-&gt;queries = $role_queries;
			} else {
				// Append the cap query to the original queries and reparse the query.
				$this-&gt;meta_query-&gt;queries = array(
					'relation' =&gt; 'AND',
					array( $this-&gt;meta_query-&gt;queries, $role_queries ),
				);
			}

			$this-&gt;meta_query-&gt;parse_query_vars( $this-&gt;meta_query-&gt;queries );
		}

		if ( ! empty( $this-&gt;meta_query-&gt;queries ) ) {
			$clauses            = $this-&gt;meta_query-&gt;get_sql( 'user', $wpdb-&gt;users, 'ID', $this );
			$this-&gt;query_from  .= $clauses['join'];
			$this-&gt;query_where .= $clauses['where'];

			if ( $this-&gt;meta_query-&gt;has_or_relation() ) {
				$this-&gt;query_fields = 'DISTINCT ' . $this-&gt;query_fields;
			}
		}

		// Sorting.
		$qv['order'] = isset( $qv['order'] ) ? strtoupper( $qv['order'] ) : '';
		$order       = $this-&gt;parse_order( $qv['order'] );

		if ( empty( $qv['orderby'] ) ) {
			// Default order is by 'user_login'.
			$ordersby = array( 'user_login' =&gt; $order );
		} elseif ( is_array( $qv['orderby'] ) ) {
			$ordersby = $qv['orderby'];
		} else {
			// 'orderby' values may be a comma- or space-separated list.
			$ordersby = preg_split( '/[,\s]+/', $qv['orderby'] );
		}

		$orderby_array = array();
		foreach ( $ordersby as $_key =&gt; $_value ) {
			if ( ! $_value ) {
				continue;
			}

			if ( is_int( $_key ) ) {
				// Integer key means this is a flat array of 'orderby' fields.
				$_orderby = $_value;
				$_order   = $order;
			} else {
				// Non-integer key means this the key is the field and the value is ASC/DESC.
				$_orderby = $_key;
				$_order   = $_value;
			}

			$parsed = $this-&gt;parse_orderby( $_orderby );

			if ( ! $parsed ) {
				continue;
			}

			if ( 'nicename__in' === $_orderby || 'login__in' === $_orderby ) {
				$orderby_array[] = $parsed;
			} else {
				$orderby_array[] = $parsed . ' ' . $this-&gt;parse_order( $_order );
			}
		}

		// If no valid clauses were found, order by user_login.
		if ( empty( $orderby_array ) ) {
			$orderby_array[] = "user_login $order";
		}

		$this-&gt;query_orderby = 'ORDER BY ' . implode( ', ', $orderby_array );

		// Limit.
		if ( isset( $qv['number'] ) &amp;&amp; $qv['number'] &gt; 0 ) {
			if ( $qv['offset'] ) {
				$this-&gt;query_limit = $wpdb-&gt;prepare( 'LIMIT %d, %d', $qv['offset'], $qv['number'] );
			} else {
				$this-&gt;query_limit = $wpdb-&gt;prepare( 'LIMIT %d, %d', $qv['number'] * ( $qv['paged'] - 1 ), $qv['number'] );
			}
		}

		$search = '';
		if ( isset( $qv['search'] ) ) {
			$search = trim( $qv['search'] );
		}

		if ( $search ) {
			$leading_wild  = ( ltrim( $search, '*' ) !== $search );
			$trailing_wild = ( rtrim( $search, '*' ) !== $search );
			if ( $leading_wild &amp;&amp; $trailing_wild ) {
				$wild = 'both';
			} elseif ( $leading_wild ) {
				$wild = 'leading';
			} elseif ( $trailing_wild ) {
				$wild = 'trailing';
			} else {
				$wild = false;
			}
			if ( $wild ) {
				$search = trim( $search, '*' );
			}

			$search_columns = array();
			if ( $qv['search_columns'] ) {
				$search_columns = array_intersect( $qv['search_columns'], array( 'ID', 'user_login', 'user_email', 'user_url', 'user_nicename', 'display_name' ) );
			}
			if ( ! $search_columns ) {
				if ( str_contains( $search, '@' ) ) {
					$search_columns = array( 'user_email' );
				} elseif ( is_numeric( $search ) ) {
					$search_columns = array( 'user_login', 'ID' );
				} elseif ( preg_match( '|^https?://|', $search ) &amp;&amp; ! ( is_multisite() &amp;&amp; wp_is_large_network( 'users' ) ) ) {
					$search_columns = array( 'user_url' );
				} else {
					$search_columns = array( 'user_login', 'user_url', 'user_email', 'user_nicename', 'display_name' );
				}
			}

			/**
			 * Filters the columns to search in a WP_User_Query search.
			 *
			 * The default columns depend on the search term, and include 'ID', 'user_login',
			 * 'user_email', 'user_url', 'user_nicename', and 'display_name'.
			 *
			 * @since 3.6.0
			 *
			 * @param string[]      $search_columns Array of column names to be searched.
			 * @param string        $search         Text being searched.
			 * @param WP_User_Query $query          The current WP_User_Query instance.
			 */
			$search_columns = apply_filters( 'user_search_columns', $search_columns, $search, $this );

			$this-&gt;query_where .= $this-&gt;get_search_sql( $search, $search_columns, $wild );
		}

		if ( ! empty( $include ) ) {
			// Sanitized earlier.
			$ids                = implode( ',', $include );
			$this-&gt;query_where .= " AND $wpdb-&gt;users.ID IN ($ids)";
		} elseif ( ! empty( $qv['exclude'] ) ) {
			$ids                = implode( ',', wp_parse_id_list( $qv['exclude'] ) );
			$this-&gt;query_where .= " AND $wpdb-&gt;users.ID NOT IN ($ids)";
		}

		// Date queries are allowed for the user_registered field.
		if ( ! empty( $qv['date_query'] ) &amp;&amp; is_array( $qv['date_query'] ) ) {
			$date_query         = new WP_Date_Query( $qv['date_query'], 'user_registered' );
			$this-&gt;query_where .= $date_query-&gt;get_sql();
		}

		/**
		 * Fires after the WP_User_Query has been parsed, and before
		 * the query is executed.
		 *
		 * The passed WP_User_Query object contains SQL parts formed
		 * from parsing the given query.
		 *
		 * @since 3.1.0
		 *
		 * @param WP_User_Query $query Current instance of WP_User_Query (passed by reference).
		 */
		do_action_ref_array( 'pre_user_query', array( &amp;$this ) );
	}

	/**
	 * Executes the query, with the current variables.
	 *
	 * @since 3.1.0
	 *
	 * @global wpdb $wpdb WordPress database abstraction object.
	 */
	public function query() {
		global $wpdb;

		if ( ! did_action( 'plugins_loaded' ) ) {
			_doing_it_wrong(
				'WP_User_Query::query',
				sprintf(
				/* translators: %s: plugins_loaded */
					__( 'User queries should not be run before the %s hook.' ),
					'&lt;code&gt;plugins_loaded&lt;/code&gt;'
				),
				'6.1.1'
			);
		}

		$qv =&amp; $this-&gt;query_vars;

		// Do not cache results if more than 3 fields are requested.
		if ( is_array( $qv['fields'] ) &amp;&amp; count( $qv['fields'] ) &gt; 3 ) {
			$qv['cache_results'] = false;
		}

		/**
		 * Filters the users array before the query takes place.
		 *
		 * Return a non-null value to bypass WordPress' default user queries.
		 *
		 * Filtering functions that require pagination information are encouraged to set
		 * the `total_users` property of the WP_User_Query object, passed to the filter
		 * by reference. If WP_User_Query does not perform a database query, it will not
		 * have enough information to generate these values itself.
		 *
		 * @since 5.1.0
		 *
		 * @param array|null    $results Return an array of user data to short-circuit WP's user query
		 *                               or null to allow WP to run its normal queries.
		 * @param WP_User_Query $query   The WP_User_Query instance (passed by reference).
		 */
		$this-&gt;results = apply_filters_ref_array( 'users_pre_query', array( null, &amp;$this ) );

		if ( null === $this-&gt;results ) {
			// Beginning of the string is on a new line to prevent leading whitespace. See https://core.trac.wordpress.org/ticket/56841.
			$this-&gt;request =
				"SELECT {$this-&gt;query_fields}
				 {$this-&gt;query_from}
				 {$this-&gt;query_where}
				 {$this-&gt;query_orderby}
				 {$this-&gt;query_limit}";
			$cache_value   = false;
			$cache_key     = $this-&gt;generate_cache_key( $qv, $this-&gt;request );
			$cache_group   = 'user-queries';
			if ( $qv['cache_results'] ) {
				$cache_value = wp_cache_get( $cache_key, $cache_group );
			}
			if ( false !== $cache_value ) {
				$this-&gt;results     = $cache_value['user_data'];
				$this-&gt;total_users = $cache_value['total_users'];
			} else {

				if ( is_array( $qv['fields'] ) ) {
					$this-&gt;results = $wpdb-&gt;get_results( $this-&gt;request );
				} else {
					$this-&gt;results = $wpdb-&gt;get_col( $this-&gt;request );
				}

				if ( isset( $qv['count_total'] ) &amp;&amp; $qv['count_total'] ) {
					/**
					 * Filters SELECT FOUND_ROWS() query for the current WP_User_Query instance.
					 *
					 * @since 3.2.0
					 * @since 5.1.0 Added the `$this` parameter.
					 *
					 * @global wpdb $wpdb WordPress database abstraction object.
					 *
					 * @param string        $sql   The SELECT FOUND_ROWS() query for the current WP_User_Query.
					 * @param WP_User_Query $query The current WP_User_Query instance.
					 */
					$found_users_query = apply_filters( 'found_users_query', 'SELECT FOUND_ROWS()', $this );

					$this-&gt;total_users = (int) $wpdb-&gt;get_var( $found_users_query );
				}

				if ( $qv['cache_results'] ) {
					$cache_value = array(
						'user_data'   =&gt; $this-&gt;results,
						'total_users' =&gt; $this-&gt;total_users,
					);
					wp_cache_add( $cache_key, $cache_value, $cache_group );
				}
			}
		}

		if ( ! $this-&gt;results ) {
			return;
		}
		if (
			is_array( $qv['fields'] ) &amp;&amp;
			isset( $this-&gt;results[0]-&gt;ID )
		) {
			foreach ( $this-&gt;results as $result ) {
				$result-&gt;id = $result-&gt;ID;
			}
		} elseif ( 'all_with_meta' === $qv['fields'] || 'all' === $qv['fields'] ) {
			if ( function_exists( 'cache_users' ) ) {
				cache_users( $this-&gt;results );
			}

			$r = array();
			foreach ( $this-&gt;results as $userid ) {
				if ( 'all_with_meta' === $qv['fields'] ) {
					$r[ $userid ] = new WP_User( $userid, '', $qv['blog_id'] );
				} else {
					$r[] = new WP_User( $userid, '', $qv['blog_id'] );
				}
			}

			$this-&gt;results = $r;
		}
	}

	/**
	 * Retrieves query variable.
	 *
	 * @since 3.5.0
	 *
	 * @param string $query_var Query variable key.
	 * @return mixed
	 */
	public function get( $query_var ) {
		if ( isset( $this-&gt;query_vars[ $query_var ] ) ) {
			return $this-&gt;query_vars[ $query_var ];
		}

		return null;
	}

	/**
	 * Sets query variable.
	 *
	 * @since 3.5.0
	 *
	 * @param string $query_var Query variable key.
	 * @param mixed  $value     Query variable value.
	 */
	public function set( $query_var, $value ) {
		$this-&gt;query_vars[ $query_var ] = $value;
	}

	/**
	 * Used internally to generate an SQL string for searching across multiple columns.
	 *
	 * @since 3.1.0
	 *
	 * @global wpdb $wpdb WordPress database abstraction object.
	 *
	 * @param string   $search  Search string.
	 * @param string[] $columns Array of columns to search.
	 * @param bool     $wild    Whether to allow wildcard searches. Default is false for Network Admin, true for single site.
	 *                          Single site allows leading and trailing wildcards, Network Admin only trailing.
	 * @return string
	 */
	protected function get_search_sql( $search, $columns, $wild = false ) {
		global $wpdb;

		$searches      = array();
		$leading_wild  = ( 'leading' === $wild || 'both' === $wild ) ? '%' : '';
		$trailing_wild = ( 'trailing' === $wild || 'both' === $wild ) ? '%' : '';
		$like          = $leading_wild . $wpdb-&gt;esc_like( $search ) . $trailing_wild;

		foreach ( $columns as $column ) {
			if ( 'ID' === $column ) {
				$searches[] = $wpdb-&gt;prepare( "$column = %s", $search );
			} else {
				$searches[] = $wpdb-&gt;prepare( "$column LIKE %s", $like );
			}
		}

		return ' AND (' . implode( ' OR ', $searches ) . ')';
	}

	/**
	 * Returns the list of users.
	 *
	 * @since 3.1.0
	 *
	 * @return array Array of results.
	 */
	public function get_results() {
		return $this-&gt;results;
	}

	/**
	 * Returns the total number of users for the current query.
	 *
	 * @since 3.1.0
	 *
	 * @return int Number of total users.
	 */
	public function get_total() {
		return $this-&gt;total_users;
	}

	/**
	 * Parses and sanitizes 'orderby' keys passed to the user query.
	 *
	 * @since 4.2.0
	 *
	 * @global wpdb $wpdb WordPress database abstraction object.
	 *
	 * @param string $orderby Alias for the field to order by.
	 * @return string Value to used in the ORDER clause, if `$orderby` is valid.
	 */
	protected function parse_orderby( $orderby ) {
		global $wpdb;

		$meta_query_clauses = $this-&gt;meta_query-&gt;get_clauses();

		$_orderby = '';
		if ( in_array( $orderby, array( 'login', 'nicename', 'email', 'url', 'registered' ), true ) ) {
			$_orderby = 'user_' . $orderby;
		} elseif ( in_array( $orderby, array( 'user_login', 'user_nicename', 'user_email', 'user_url', 'user_registered' ), true ) ) {
			$_orderby = $orderby;
		} elseif ( 'name' === $orderby || 'display_name' === $orderby ) {
			$_orderby = 'display_name';
		} elseif ( 'post_count' === $orderby ) {
			// @todo Avoid the JOIN.
			$where             = get_posts_by_author_sql( 'post' );
			$this-&gt;query_from .= " LEFT OUTER JOIN (
				SELECT post_author, COUNT(*) as post_count
				FROM $wpdb-&gt;posts
				$where
				GROUP BY post_author
			) p ON ({$wpdb-&gt;users}.ID = p.post_author)";
			$_orderby          = 'post_count';
		} elseif ( 'ID' === $orderby || 'id' === $orderby ) {
			$_orderby = 'ID';
		} elseif ( 'meta_value' === $orderby || $this-&gt;get( 'meta_key' ) === $orderby ) {
			$_orderby = "$wpdb-&gt;usermeta.meta_value";
		} elseif ( 'meta_value_num' === $orderby ) {
			$_orderby = "$wpdb-&gt;usermeta.meta_value+0";
		} elseif ( 'include' === $orderby &amp;&amp; ! empty( $this-&gt;query_vars['include'] ) ) {
			$include     = wp_parse_id_list( $this-&gt;query_vars['include'] );
			$include_sql = implode( ',', $include );
			$_orderby    = "FIELD( $wpdb-&gt;users.ID, $include_sql )";
		} elseif ( 'nicename__in' === $orderby ) {
			$sanitized_nicename__in = array_map( 'esc_sql', $this-&gt;query_vars['nicename__in'] );
			$nicename__in           = implode( "','", $sanitized_nicename__in );
			$_orderby               = "FIELD( user_nicename, '$nicename__in' )";
		} elseif ( 'login__in' === $orderby ) {
			$sanitized_login__in = array_map( 'esc_sql', $this-&gt;query_vars['login__in'] );
			$login__in           = implode( "','", $sanitized_login__in );
			$_orderby            = "FIELD( user_login, '$login__in' )";
		} elseif ( isset( $meta_query_clauses[ $orderby ] ) ) {
			$meta_clause = $meta_query_clauses[ $orderby ];
			$_orderby    = sprintf( 'CAST(%s.meta_value AS %s)', esc_sql( $meta_clause['alias'] ), esc_sql( $meta_clause['cast'] ) );
		}

		return $_orderby;
	}

	/**
	 * Generate cache key.
	 *
	 * @since 6.3.0
	 *
	 * @global wpdb $wpdb WordPress database abstraction object.
	 *
	 * @param array  $args Query arguments.
	 * @param string $sql  SQL statement.
	 * @return string Cache key.
	 */
	protected function generate_cache_key( array $args, $sql ) {
		global $wpdb;

		// Replace wpdb placeholder in the SQL statement used by the cache key.
		$sql = $wpdb-&gt;remove_placeholder_escape( $sql );

		$key          = md5( $sql );
		$last_changed = wp_cache_get_last_changed( 'users' );

		if ( empty( $args['orderby'] ) ) {
			// Default order is by 'user_login'.
			$ordersby = array( 'user_login' =&gt; '' );
		} elseif ( is_array( $args['orderby'] ) ) {
			$ordersby = $args['orderby'];
		} else {
			// 'orderby' values may be a comma- or space-separated list.
			$ordersby = preg_split( '/[,\s]+/', $args['orderby'] );
		}

		$blog_id = 0;
		if ( isset( $args['blog_id'] ) ) {
			$blog_id = absint( $args['blog_id'] );
		}

		if ( $args['has_published_posts'] || in_array( 'post_count', $ordersby, true ) ) {
			$switch = $blog_id &amp;&amp; get_current_blog_id() !== $blog_id;
			if ( $switch ) {
				switch_to_blog( $blog_id );
			}

			$last_changed .= wp_cache_get_last_changed( 'posts' );

			if ( $switch ) {
				restore_current_blog();
			}
		}

		return "get_users:$key:$last_changed";
	}

	/**
	 * Parses an 'order' query variable and casts it to ASC or DESC as necessary.
	 *
	 * @since 4.2.0
	 *
	 * @param string $order The 'order' query variable.
	 * @return string The sanitized 'order' query variable.
	 */
	protected function parse_order( $order ) {
		if ( ! is_string( $order ) || empty( $order ) ) {
			return 'DESC';
		}

		if ( 'ASC' === strtoupper( $order ) ) {
			return 'ASC';
		} else {
			return 'DESC';
		}
	}

	/**
	 * Makes private properties readable for backward compatibility.
	 *
	 * @since 4.0.0
	 * @since 6.4.0 Getting a dynamic property is deprecated.
	 *
	 * @param string $name Property to get.
	 * @return mixed Property.
	 */
	public function __get( $name ) {
		if ( in_array( $name, $this-&gt;compat_fields, true ) ) {
			return $this-&gt;$name;
		}

		wp_trigger_error(
			__METHOD__,
			"The property `{$name}` is not declared. Getting a dynamic property is " .
			'deprecated since version 6.4.0! Instead, declare the property on the class.',
			E_USER_DEPRECATED
		);
		return null;
	}

	/**
	 * Makes private properties settable for backward compatibility.
	 *
	 * @since 4.0.0
	 * @since 6.4.0 Setting a dynamic property is deprecated.
	 *
	 * @param string $name  Property to check if set.
	 * @param mixed  $value Property value.
	 */
	public function __set( $name, $value ) {
		if ( in_array( $name, $this-&gt;compat_fields, true ) ) {
			$this-&gt;$name = $value;
			return;
		}

		wp_trigger_error(
			__METHOD__,
			"The property `{$name}` is not declared. Setting a dynamic property is " .
			'deprecated since version 6.4.0! Instead, declare the property on the class.',
			E_USER_DEPRECATED
		);
	}

	/**
	 * Makes private properties checkable for backward compatibility.
	 *
	 * @since 4.0.0
	 * @since 6.4.0 Checking a dynamic property is deprecated.
	 *
	 * @param string $name Property to check if set.
	 * @return bool Whether the property is set.
	 */
	public function __isset( $name ) {
		if ( in_array( $name, $this-&gt;compat_fields, true ) ) {
			return isset( $this-&gt;$name );
		}

		wp_trigger_error(
			__METHOD__,
			"The property `{$name}` is not declared. Checking `isset()` on a dynamic property " .
			'is deprecated since version 6.4.0! Instead, declare the property on the class.',
			E_USER_DEPRECATED
		);
		return false;
	}

	/**
	 * Makes private properties un-settable for backward compatibility.
	 *
	 * @since 4.0.0
	 * @since 6.4.0 Unsetting a dynamic property is deprecated.
	 *
	 * @param string $name Property to unset.
	 */
	public function __unset( $name ) {
		if ( in_array( $name, $this-&gt;compat_fields, true ) ) {
			unset( $this-&gt;$name );
			return;
		}

		wp_trigger_error(
			__METHOD__,
			"A property `{$name}` is not declared. Unsetting a dynamic property is " .
			'deprecated since version 6.4.0! Instead, declare the property on the class.',
			E_USER_DEPRECATED
		);
	}

	/**
	 * Makes private/protected methods readable for backward compatibility.
	 *
	 * @since 4.0.0
	 *
	 * @param string $name      Method to call.
	 * @param array  $arguments Arguments to pass when calling.
	 * @return mixed Return value of the callback, false otherwise.
	 */
	public function __call( $name, $arguments ) {
		if ( 'get_search_sql' === $name ) {
			return $this-&gt;get_search_sql( ...$arguments );
		}
		return false;
	}
}
</code></pre>
<p class="wporg-dot-link-list"><a href="https://developer.wordpress.org/reference/files/wp-includes/class-wp-user-query.php/">View all references</a> <a href="https://core.trac.wordpress.org/browser/tags/6.7/src/wp-includes/class-wp-user-query.php#L18">View on Trac</a> <a href="https://github.com/WordPress/wordpress-develop/blob/6.7/src/wp-includes/class-wp-user-query.php#L18-L1219">View on GitHub</a></p></section> <section><h2 id="changelog">Changelog</h2> <section style="margin-top:var(--wp--preset--spacing--20);"><figure class="wp-block-table "><table>
<thead><tr>
<th scope="col">Version</th>
<th scope="col">Description</th>
</tr></thead>
<tbody><tr class="">
<td><a href="https://developer.wordpress.org/reference/since/3.1.0/">3.1.0</a></td>
<td>Introduced.</td>
</tr></tbody>
</table></figure></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2003&ndash;2024 WordPress Foundation<br>Licensed under the GNU GPLv2+ License.<br>
    <a href="https://developer.wordpress.org/reference/classes/wp_user_query" class="_attribution-link">https://developer.wordpress.org/reference/classes/wp_user_query</a>
  </p>
</div>
