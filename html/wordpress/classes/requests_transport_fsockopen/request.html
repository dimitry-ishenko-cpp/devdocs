<h1>Requests_Transport_fsockopen::request( string $url, array $headers = array(), string|array $data = array(), array $options = array() ): string</h1>  <section> <p>Perform a request</p> </section>   <section> <header class="toc-header"><h2 id="parameters">Parameters</h2></header> <dl> <dt> <code>$url</code> <span class="type"><span class="string">string</span></span> <span class="required">Required</span> </dt> <dd> <div class="desc"> <span class="description">URL to request</span> </div> </dd> <dt> <code>$headers</code> <span class="type"><span class="array">array</span></span> <span class="required">Optional</span> </dt> <dd> <div class="desc"> <span class="description">Associative array of request headers</span> </div> <p class="default">Default: <code>array()</code></p> </dd> <dt> <code>$data</code> <span class="type"><span class="string">string</span>|<span class="array">array</span></span> <span class="required">Optional</span> </dt> <dd> <div class="desc"> <span class="description">Data to send either as the POST body, or as parameters in the URL for a GET/HEAD</span> </div> <p class="default">Default: <code>array()</code></p> </dd> <dt> <code>$options</code> <span class="type"><span class="array">array</span></span> <span class="required">Optional</span> </dt> <dd> <div class="desc"> <span class="description">Request options, see <a href="../requests/response.html">Requests::response()</a> for documentation</span> </div> <p class="default">Default: <code>array()</code></p> </dd> </dl> </section>  <section> <header class="toc-header"><h2 id="return">Return</h2></header> <p><span class="return-type">string</span> Raw HTTP result</p> </section>  <section> <header class="toc-header"><h2 id="source">Source</h2></header> <p> File: <code>wp-includes/Requests/Transport/fsockopen.php</code>. <a href="https://developer.wordpress.org/reference/files/wp-includes/requests/transport/fsockopen.php/">View all references</a> </p> <pre class="wp-block-code" data-start="58" aria-label="Function source code" data-language="php"><code lang="php" class="language-php line-numbers">public function request($url, $headers = array(), $data = array(), $options = array()) {
	$options['hooks']-&gt;dispatch('fsockopen.before_request');

	$url_parts = parse_url($url);
	if (empty($url_parts)) {
		throw new Requests_Exception('Invalid URL.', 'invalidurl', $url);
	}
	$host                     = $url_parts['host'];
	$context                  = stream_context_create();
	$verifyname               = false;
	$case_insensitive_headers = new Requests_Utility_CaseInsensitiveDictionary($headers);

	// HTTPS support
	if (isset($url_parts['scheme']) &amp;&amp; strtolower($url_parts['scheme']) === 'https') {
		$remote_socket = 'ssl://' . $host;
		if (!isset($url_parts['port'])) {
			$url_parts['port'] = 443;
		}

		$context_options = array(
			'verify_peer'       =&gt; true,
			'capture_peer_cert' =&gt; true,
		);
		$verifyname      = true;

		// SNI, if enabled (OpenSSL &gt;=0.9.8j)
		// phpcs:ignore PHPCompatibility.Constants.NewConstants.openssl_tlsext_server_nameFound
		if (defined('OPENSSL_TLSEXT_SERVER_NAME') &amp;&amp; OPENSSL_TLSEXT_SERVER_NAME) {
			$context_options['SNI_enabled'] = true;
			if (isset($options['verifyname']) &amp;&amp; $options['verifyname'] === false) {
				$context_options['SNI_enabled'] = false;
			}
		}

		if (isset($options['verify'])) {
			if ($options['verify'] === false) {
				$context_options['verify_peer']      = false;
				$context_options['verify_peer_name'] = false;
				$verifyname                          = false;
			}
			elseif (is_string($options['verify'])) {
				$context_options['cafile'] = $options['verify'];
			}
		}

		if (isset($options['verifyname']) &amp;&amp; $options['verifyname'] === false) {
			$context_options['verify_peer_name'] = false;
			$verifyname                          = false;
		}

		stream_context_set_option($context, array('ssl' =&gt; $context_options));
	}
	else {
		$remote_socket = 'tcp://' . $host;
	}

	$this-&gt;max_bytes = $options['max_bytes'];

	if (!isset($url_parts['port'])) {
		$url_parts['port'] = 80;
	}
	$remote_socket .= ':' . $url_parts['port'];

	// phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_set_error_handler
	set_error_handler(array($this, 'connect_error_handler'), E_WARNING | E_NOTICE);

	$options['hooks']-&gt;dispatch('fsockopen.remote_socket', array(&amp;$remote_socket));

	$socket = stream_socket_client($remote_socket, $errno, $errstr, ceil($options['connect_timeout']), STREAM_CLIENT_CONNECT, $context);

	restore_error_handler();

	if ($verifyname &amp;&amp; !$this-&gt;verify_certificate_from_context($host, $context)) {
		throw new Requests_Exception('SSL certificate did not match the requested domain name', 'ssl.no_match');
	}

	if (!$socket) {
		if ($errno === 0) {
			// Connection issue
			throw new Requests_Exception(rtrim($this-&gt;connect_error), 'fsockopen.connect_error');
		}

		throw new Requests_Exception($errstr, 'fsockopenerror', null, $errno);
	}

	$data_format = $options['data_format'];

	if ($data_format === 'query') {
		$path = self::format_get($url_parts, $data);
		$data = '';
	}
	else {
		$path = self::format_get($url_parts, array());
	}

	$options['hooks']-&gt;dispatch('fsockopen.remote_host_path', array(&amp;$path, $url));

	$request_body = '';
	$out          = sprintf("%s %s HTTP/%.1F\r\n", $options['type'], $path, $options['protocol_version']);

	if ($options['type'] !== Requests::TRACE) {
		if (is_array($data)) {
			$request_body = http_build_query($data, '', '&amp;');
		}
		else {
			$request_body = $data;
		}

		// Always include Content-length on POST requests to prevent
		// 411 errors from some servers when the body is empty.
		if (!empty($data) || $options['type'] === Requests::POST) {
			if (!isset($case_insensitive_headers['Content-Length'])) {
				$headers['Content-Length'] = strlen($request_body);
			}

			if (!isset($case_insensitive_headers['Content-Type'])) {
				$headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
			}
		}
	}

	if (!isset($case_insensitive_headers['Host'])) {
		$out .= sprintf('Host: %s', $url_parts['host']);

		if ((strtolower($url_parts['scheme']) === 'http' &amp;&amp; $url_parts['port'] !== 80) || (strtolower($url_parts['scheme']) === 'https' &amp;&amp; $url_parts['port'] !== 443)) {
			$out .= ':' . $url_parts['port'];
		}
		$out .= "\r\n";
	}

	if (!isset($case_insensitive_headers['User-Agent'])) {
		$out .= sprintf("User-Agent: %s\r\n", $options['useragent']);
	}

	$accept_encoding = $this-&gt;accept_encoding();
	if (!isset($case_insensitive_headers['Accept-Encoding']) &amp;&amp; !empty($accept_encoding)) {
		$out .= sprintf("Accept-Encoding: %s\r\n", $accept_encoding);
	}

	$headers = Requests::flatten($headers);

	if (!empty($headers)) {
		$out .= implode("\r\n", $headers) . "\r\n";
	}

	$options['hooks']-&gt;dispatch('fsockopen.after_headers', array(&amp;$out));

	if (substr($out, -2) !== "\r\n") {
		$out .= "\r\n";
	}

	if (!isset($case_insensitive_headers['Connection'])) {
		$out .= "Connection: Close\r\n";
	}

	$out .= "\r\n" . $request_body;

	$options['hooks']-&gt;dispatch('fsockopen.before_send', array(&amp;$out));

	fwrite($socket, $out);
	$options['hooks']-&gt;dispatch('fsockopen.after_send', array($out));

	if (!$options['blocking']) {
		fclose($socket);
		$fake_headers = '';
		$options['hooks']-&gt;dispatch('fsockopen.after_request', array(&amp;$fake_headers));
		return '';
	}

	$timeout_sec = (int) floor($options['timeout']);
	if ($timeout_sec === $options['timeout']) {
		$timeout_msec = 0;
	}
	else {
		$timeout_msec = self::SECOND_IN_MICROSECONDS * $options['timeout'] % self::SECOND_IN_MICROSECONDS;
	}
	stream_set_timeout($socket, $timeout_sec, $timeout_msec);

	$response   = '';
	$body       = '';
	$headers    = '';
	$this-&gt;info = stream_get_meta_data($socket);
	$size       = 0;
	$doingbody  = false;
	$download   = false;
	if ($options['filename']) {
		$download = fopen($options['filename'], 'wb');
	}

	while (!feof($socket)) {
		$this-&gt;info = stream_get_meta_data($socket);
		if ($this-&gt;info['timed_out']) {
			throw new Requests_Exception('fsocket timed out', 'timeout');
		}

		$block = fread($socket, Requests::BUFFER_SIZE);
		if (!$doingbody) {
			$response .= $block;
			if (strpos($response, "\r\n\r\n")) {
				list($headers, $block) = explode("\r\n\r\n", $response, 2);
				$doingbody             = true;
			}
		}

		// Are we in body mode now?
		if ($doingbody) {
			$options['hooks']-&gt;dispatch('request.progress', array($block, $size, $this-&gt;max_bytes));
			$data_length = strlen($block);
			if ($this-&gt;max_bytes) {
				// Have we already hit a limit?
				if ($size === $this-&gt;max_bytes) {
					continue;
				}
				if (($size + $data_length) &gt; $this-&gt;max_bytes) {
					// Limit the length
					$limited_length = ($this-&gt;max_bytes - $size);
					$block          = substr($block, 0, $limited_length);
				}
			}

			$size += strlen($block);
			if ($download) {
				fwrite($download, $block);
			}
			else {
				$body .= $block;
			}
		}
	}
	$this-&gt;headers = $headers;

	if ($download) {
		fclose($download);
	}
	else {
		$this-&gt;headers .= "\r\n\r\n" . $body;
	}
	fclose($socket);

	$options['hooks']-&gt;dispatch('fsockopen.after_request', array(&amp;$this-&gt;headers, &amp;$this-&gt;info));
	return $this-&gt;headers;
}
</code></pre>  </section>  <section> <header class="toc-header"><h2 id="related">Related</h2></header> <article class="uses"> <header class="toc-header"><h3 id="uses">Uses</h3></header> <table id="uses-table" data-show="5">  <thead> <tr> <th>Uses</th> <th class="related-desc">Description</th> </tr> </thead> <tbody> <tr> <td class="related-title"> <a href="../requests/flatten.html">Requests::flatten()</a> <span>wp-includes/class-requests.php</span> </td> <td class="related-desc"> <p>Convert a key =&gt; value array to a ‘key: value’ array for headers</p> </td> </tr> <tr> <td class="related-title"> <a href="../requests_utility_caseinsensitivedictionary/__construct.html">Requests_Utility_CaseInsensitiveDictionary::__construct()</a> <span>wp-includes/Requests/Utility/CaseInsensitiveDictionary.php</span> </td> <td class="related-desc"> <p>Creates a case insensitive dictionary.</p> </td> </tr> <tr> <td class="related-title"> <a href="../requests_exception/__construct.html">Requests_Exception::__construct()</a> <span>wp-includes/Requests/Exception.php</span> </td> <td class="related-desc"> <p>Create a new exception</p> </td> </tr> <tr> <td class="related-title"> <a href="verify_certificate_from_context.html">Requests_Transport_fsockopen::verify_certificate_from_context()</a> <span>wp-includes/Requests/Transport/fsockopen.php</span> </td> <td class="related-desc"> <p>Verify the certificate against common name and subject alternative names</p> </td> </tr> <tr> <td class="related-title"> <a href="format_get.html">Requests_Transport_fsockopen::format_get()</a> <span>wp-includes/Requests/Transport/fsockopen.php</span> </td> <td class="related-desc"> <p>Format a URL given GET data</p> </td> </tr> <tr> <td class="related-title"> <a href="accept_encoding.html">Requests_Transport_fsockopen::accept_encoding()</a> <span>wp-includes/Requests/Transport/fsockopen.php</span> </td> <td class="related-desc"> <p>Retrieve the encodings we can accept</p> </td> </tr> </tbody>

</table>   </article> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2003&ndash;2022 WordPress Foundation<br>Licensed under the GNU GPLv2+ License.<br>
    <a href="https://developer.wordpress.org/reference/classes/requests_transport_fsockopen/request" class="_attribution-link">https://developer.wordpress.org/reference/classes/requests_transport_fsockopen/request</a>
  </p>
</div>
