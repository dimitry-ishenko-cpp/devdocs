<h1 class="wp-block-wporg-code-reference-title">
<span class="keyword">class</span> WP_HTML_Tag_Processor {}</h1> <section><p>Core class used to modify attributes in an HTML document for tags matching a query.</p> </section> <section><h2 id="description">Description</h2> <h2 id="usage">Usage</h2> <p>Use of this class requires three steps:</p> <ol> <li>Create a new class instance with your input HTML document.</li> <li>Find the tag(s) you are looking for.</li> <li>Request changes to the attributes in those tag(s).</li> </ol> <p>Example:</p> <pre class="wp-block-code" data-language="php"><code lang="php" class="language-php ">$tags = new WP_HTML_Tag_Processor( $html );
if ( $tags-&gt;next_tag( 'option' ) ) {
    $tags-&gt;set_attribute( 'selected', true );
}</code></pre> <h3 id="finding-tags">Finding tags</h3> <p>The <code>next_tag()</code> function moves the internal cursor through your input HTML document until it finds a tag meeting any of the supplied restrictions in the optional query argument. If no argument is provided then it will find the next HTML tag, regardless of what kind it is.</p> <p>If you want to <em>find whatever the next tag is</em>:</p> <pre class="wp-block-code" data-language="php"><code lang="php" class="language-php ">$tags-&gt;next_tag();</code></pre> <table> <thead> <tr> <th>Goal</th> <th>Query</th> </tr> </thead> <tbody> <tr> <td>Find any tag.</td> <td><code>$tags-&gt;next_tag();</code></td> </tr> <tr> <td>Find next image tag.</td> <td><code>$tags-&gt;next_tag( array( 'tag_name' =&gt; 'img' ) );</code></td> </tr> <tr> <td>Find next image tag (without passing the array).</td> <td><code>$tags-&gt;next_tag( 'img' );</code></td> </tr> <tr> <td>Find next tag containing the <code>fullwidth</code> CSS class.</td> <td><code>$tags-&gt;next_tag( array( 'class_name' =&gt; 'fullwidth' ) );</code></td> </tr> <tr> <td>Find next image tag containing the <code>fullwidth</code> CSS class.</td> <td><code>$tags-&gt;next_tag( array( 'tag_name' =&gt; 'img', 'class_name' =&gt; 'fullwidth' ) );</code></td> </tr> </tbody> </table> <p>If a tag was found meeting your criteria then <code>next_tag()</code> will return <code>true</code> and you can proceed to modify it. If it returns <code>false</code>, however, it failed to find the tag and moved the cursor to the end of the file.</p> <p>Once the cursor reaches the end of the file the processor is done and if you want to reach an earlier tag you will need to recreate the processor and start over, as it’s unable to back up or move in reverse.</p> <p>See the section on bookmarks for an exception to this no-backing-up rule.</p> <h4>Custom queries</h4> <p>Sometimes it’s necessary to further inspect an HTML tag than the query syntax here permits. In these cases one may further inspect the search results using the read-only functions provided by the processor or external state or variables.</p> <p>Example:</p> <pre class="wp-block-code" data-language="php"><code lang="php" class="language-php line-numbers">// Paint up to the first five DIV or SPAN tags marked with the "jazzy" style.
$remaining_count = 5;
while ( $remaining_count &gt; 0 &amp;&amp; $tags-&gt;next_tag() ) {
    if (
         ( 'DIV' === $tags-&gt;get_tag() || 'SPAN' === $tags-&gt;get_tag() ) &amp;&amp;
         'jazzy' === $tags-&gt;get_attribute( 'data-style' )
    ) {
        $tags-&gt;add_class( 'theme-style-everest-jazz' );
        $remaining_count--;
    }
}</code></pre> <p><code>get_attribute()</code> will return <code>null</code> if the attribute wasn’t present on the tag when it was called. It may return <code>""</code> (the empty string) in cases where the attribute was present but its value was empty.<br>For boolean attributes, those whose name is present but no value is given, it will return <code>true</code> (the only way to set <code>false</code> for an attribute is to remove it).</p> <h4>When matching fails</h4> <p>When <code>next_tag()</code> returns <code>false</code> it could mean different things:</p> <ul> <li>The requested tag wasn’t found in the input document.</li> <li>The input document ended in the middle of an HTML syntax element.</li> </ul> <p>When a document ends in the middle of a syntax element it will pause the processor. This is to make it possible in the future to extend the input document and proceed – an important requirement for chunked streaming parsing of a document.</p> <p>Example:</p> <pre class="wp-block-code" data-language="php"><code lang="php" class="language-php ">$processor = new WP_HTML_Tag_Processor( 'This &lt;div is="a" partial="token' );
false === $processor-&gt;next_tag();</code></pre> <p>If a special element (see next section) is encountered but no closing tag is found it will count as an incomplete tag. The parser will pause as if the opening tag were incomplete.</p> <p>Example:</p> <pre class="wp-block-code" data-language="php"><code lang="php" class="language-php line-numbers">$processor = new WP_HTML_Tag_Processor( '&lt;style&gt;// there could be more styling to come' );
false === $processor-&gt;next_tag();

$processor = new WP_HTML_Tag_Processor( '&lt;style&gt;// this is everything&lt;/style&gt;&lt;div&gt;' );
true === $processor-&gt;next_tag( 'DIV' );</code></pre> <h4>Special elements</h4> <p>Some HTML elements are handled in a special way; their start and end tags act like a void tag. These are special because their contents can’t contain HTML markup. Everything inside these elements is handled in a special way and content that <em>appears</em> like HTML tags inside of them isn’t. There can be no nesting in these elements.</p> <p>In the following list, "raw text" means that all of the content in the HTML until the matching closing tag is treated verbatim without any replacements and without any parsing.</p> <ul> <li>IFRAME allows no content but requires a closing tag.</li> <li>NOEMBED (deprecated) content is raw text.</li> <li>NOFRAMES (deprecated) content is raw text.</li> <li>SCRIPT content is plaintext apart from legacy rules allowing <code>&lt;/script&gt;</code> inside an HTML comment.</li> <li>STYLE content is raw text.</li> <li>TITLE content is plain text but character references are decoded.</li> <li>TEXTAREA content is plain text but character references are decoded.</li> <li>XMP (deprecated) content is raw text.</li> </ul> <h3 id="modifying-html-attributes-for-a-found-tag">Modifying HTML attributes for a found tag</h3> <p>Once you’ve found the start of an opening tag you can modify any number of the attributes on that tag. You can set a new value for an attribute, remove the entire attribute, or do nothing and move on to the next opening tag.</p> <p>Example:</p> <pre class="wp-block-code" data-language="php"><code lang="php" class="language-php ">if ( $tags-&gt;next_tag( array( 'class_name' =&gt; 'wp-group-block' ) ) ) {
    $tags-&gt;set_attribute( 'title', 'This groups the contained content.' );
    $tags-&gt;remove_attribute( 'data-test-id' );
}</code></pre> <p>If <code>set_attribute()</code> is called for an existing attribute it will overwrite the existing value. Similarly, calling <code>remove_attribute()</code> for a non-existing attribute has no effect on the document. Both of these methods are safe to call without knowing if a given attribute exists beforehand.</p> <h3 id="modifying-css-classes-for-a-found-tag">Modifying CSS classes for a found tag</h3> <p>The tag processor treats the <code>class</code> attribute as a special case.<br>Because it’s a common operation to add or remove CSS classes, this interface adds helper methods to make that easier.</p> <p>As with attribute values, adding or removing CSS classes is a safe operation that doesn’t require checking if the attribute or class exists before making changes. If removing the only class then the entire <code>class</code> attribute will be removed.</p> <p>Example:</p> <pre class="wp-block-code" data-language="php"><code lang="php" class="language-php line-numbers">// from `&lt;span&gt;Yippee!&lt;/span&gt;`
//   to `&lt;span class="is-active"&gt;Yippee!&lt;/span&gt;`
$tags-&gt;add_class( 'is-active' );

// from `&lt;span class="excited"&gt;Yippee!&lt;/span&gt;`
//   to `&lt;span class="excited is-active"&gt;Yippee!&lt;/span&gt;`
$tags-&gt;add_class( 'is-active' );

// from `&lt;span class="is-active heavy-accent"&gt;Yippee!&lt;/span&gt;`
//   to `&lt;span class="is-active heavy-accent"&gt;Yippee!&lt;/span&gt;`
$tags-&gt;add_class( 'is-active' );

// from `&lt;input type="text" class="is-active rugby not-disabled" length="24"&gt;`
//   to `&lt;input type="text" class="is-active not-disabled" length="24"&gt;
$tags-&gt;remove_class( 'rugby' );

// from `&lt;input type="text" class="rugby" length="24"&gt;`
//   to `&lt;input type="text" length="24"&gt;
$tags-&gt;remove_class( 'rugby' );

// from `&lt;input type="text" length="24"&gt;`
//   to `&lt;input type="text" length="24"&gt;
$tags-&gt;remove_class( 'rugby' );</code></pre> <p>When class changes are enqueued but a direct change to <code>class</code> is made via <code>set_attribute</code> then the changes to <code>set_attribute</code> (or <code>remove_attribute</code>) will take precedence over those made through <code>add_class</code> and <code>remove_class</code>.</p> <h3 id="bookmarks">Bookmarks</h3> <p>While scanning through the input HTMl document it’s possible to set a named bookmark when a particular tag is found. Later on, after continuing to scan other tags, it’s possible to <code>seek</code> to one of the set bookmarks and then proceed again from that point forward.</p> <p>Because bookmarks create processing overhead one should avoid creating too many of them. As a rule, create only bookmarks of known string literal names; avoid creating "mark_{$index}" and so on. It’s fine from a performance standpoint to create a bookmark and update it frequently, such as within a loop.</p> <pre class="wp-block-code" data-language="php"><code lang="php" class="language-php line-numbers">$total_todos = 0;
while ( $p-&gt;next_tag( array( 'tag_name' =&gt; 'UL', 'class_name' =&gt; 'todo' ) ) ) {
    $p-&gt;set_bookmark( 'list-start' );
    while ( $p-&gt;next_tag( array( 'tag_closers' =&gt; 'visit' ) ) ) {
        if ( 'UL' === $p-&gt;get_tag() &amp;&amp; $p-&gt;is_tag_closer() ) {
            $p-&gt;set_bookmark( 'list-end' );
            $p-&gt;seek( 'list-start' );
            $p-&gt;set_attribute( 'data-contained-todos', (string) $total_todos );
            $total_todos = 0;
            $p-&gt;seek( 'list-end' );
            break;
        }

        if ( 'LI' === $p-&gt;get_tag() &amp;&amp; ! $p-&gt;is_tag_closer() ) {
            $total_todos++;
        }
    }
}</code></pre> <h2 id="tokens-and-finer-grained-processing">Tokens and finer-grained processing.</h2> <p>It’s possible to scan through every lexical token in the HTML document using the <code>next_token()</code> function. This alternative form takes no argument and provides no built-in query syntax.</p> <p>Example:</p> <pre class="wp-block-code" data-language="php"><code lang="php" class="language-php line-numbers"> $title = '(untitled)';
 $text  = '';
 while ( $processor-&gt;next_token() ) {
     switch ( $processor-&gt;get_token_name() ) {
         case '#text':
             $text .= $processor-&gt;get_modifiable_text();
             break;

         case 'BR':
             $text .= "\n";
             break;

         case 'TITLE':
             $title = $processor-&gt;get_modifiable_text();
             break;
     }
 }
 return trim( "# {$title}\n\n{$text}" );</code></pre> <h3 id="tokens-and-modifiable-text">Tokens and modifiable text.</h3> <h4>Special "atomic" HTML elements.</h4> <p>Not all HTML elements are able to contain other elements inside of them.<br>For instance, the contents inside a TITLE element are plaintext (except that character references like &amp; will be decoded). This means that if the string <code>&lt;img&gt;</code> appears inside a TITLE element, then it’s not an image tag, but rather it’s text describing an image tag. Likewise, the contents of a SCRIPT or STYLE element are handled entirely separately in a browser than the contents of other elements because they represent a different language than HTML.</p> <p>For these elements the Tag Processor treats the entire sequence as one, from the opening tag, including its contents, through its closing tag.<br>This means that the it’s not possible to match the closing tag for a SCRIPT element unless it’s unexpected; the Tag Processor already matched it when it found the opening tag.</p> <p>The inner contents of these elements are that element’s <em>modifiable text</em>.</p> <p>The special elements are:</p> <ul> <li>
<code>SCRIPT</code> whose contents are treated as raw plaintext but supports a legacy style of including JavaScript inside of HTML comments to avoid accidentally closing the SCRIPT from inside a JavaScript string. E.g. <code>console.log( '&lt;/script&gt;' )</code>.</li> <li>
<code>TITLE</code> and <code>TEXTAREA</code> whose contents are treated as plaintext and then any character references are decoded. E.g. <code>1 &amp;lt; 2 &lt; 3</code> becomes <code>1 &lt; 2 &lt; 3</code>.</li> <li>
<code>IFRAME</code>, <code>NOSCRIPT</code>, <code>NOEMBED</code>, <code>NOFRAME</code>, <code>STYLE</code> whose contents are treated as raw plaintext and left as-is. E.g. <code>1 &amp;lt; 2 &lt; 3</code> remains <code>1 &amp;lt; 2 &lt; 3</code>.</li> </ul> <h4>Other tokens with modifiable text.</h4> <p>There are also non-elements which are void/self-closing in nature and contain modifiable text that is part of that individual syntax token itself.</p> <ul> <li>
<code>#text</code> nodes, whose entire token <em>is</em> the modifiable text.</li> <li>HTML comments and tokens that become comments due to some syntax error. The text for these tokens is the portion of the comment inside of the syntax.<br>E.g. for <code>&lt;!-- comment --&gt;</code> the text is <code>" comment "</code> (note the spaces are included).</li> <li>
<code>CDATA</code> sections, whose text is the content inside of the section itself. E.g. for <code>&lt;![CDATA[some content]]&gt;</code> the text is <code>"some content"</code> (with restrictions [1]).</li> <li>"Funky comments," which are a special case of invalid closing tags whose name is invalid. The text for these nodes is the text that a browser would transform into an HTML comment when parsing. E.g. for <code>&lt;/%post_author&gt;</code> the text is <code>%post_author</code>.</li> <li>
<code>DOCTYPE</code> declarations like <code>&lt;DOCTYPE html&gt;</code> which have no closing tag.</li> <li>XML Processing instruction nodes like <code>&lt;?wp __( "Like" ); ?&gt;</code> (with restrictions [2]).</li> <li>The empty end tag <code>&lt;/&gt;</code> which is ignored in the browser and DOM.</li> </ul> <p>[1]: There are no CDATA sections in HTML. When encountering <code>&lt;![CDATA[</code>, everything until the next <code>&gt;</code> becomes a bogus HTML comment, meaning there can be no CDATA section in an HTML document containing <code>&gt;</code>. The Tag Processor will first find all valid and bogus HTML comments, and then if the comment <em>would</em> have been a CDATA section <em>were they to exist</em>, it will indicate this as the type of comment.</p> <p>[2]: XML allows a broader range of characters in a processing instruction’s target name and disallows "xml" as a name, since it’s special. The Tag Processor only recognizes target names with an ASCII-representable subset of characters. It also exhibits the same constraint as with CDATA sections, in that <code>&gt;</code> cannot exist within the token since Processing Instructions do no exist within HTML and their syntax transforms into a bogus comment in the DOM.</p> <h2 id="design-and-limitations">Design and limitations</h2> <p>The Tag Processor is designed to linearly scan HTML documents and tokenize HTML tags and their attributes. It’s designed to do this as efficiently as possible without compromising parsing integrity. Therefore it will be slower than some methods of modifying HTML, such as those incorporating over-simplified PCRE patterns, but will not introduce the defects and failures that those methods bring in, which lead to broken page renders and often to security vulnerabilities. On the other hand, it will be faster than full-blown HTML parsers such as DOMDocument and use considerably less memory. It requires a negligible memory overhead, enough to consider it a zero-overhead system.</p> <p>The performance characteristics are maintained by avoiding tree construction and semantic cleanups which are specified in HTML5. Because of this, for example, it’s not possible for the Tag Processor to associate any given opening tag with its corresponding closing tag, or to return the inner markup inside an element. Systems may be built on top of the Tag Processor to do this, but the Tag Processor is and should be constrained so it can remain an efficient, low-level, and reliable HTML scanner.</p> <p>The Tag Processor’s design incorporates a "garbage-in-garbage-out" philosophy.<br>HTML5 specifies that certain invalid content be transformed into different forms for display, such as removing null bytes from an input document and replacing invalid characters with the Unicode replacement character <code>U+FFFD</code> (visually "�").<br>Where errors or transformations exist within the HTML5 specification, the Tag Processor leaves those invalid inputs untouched, passing them through to the final browser to handle. While this implies that certain operations will be non-spec-compliant, such as reading the value of an attribute with invalid content, it also preserves a simplicity and efficiency for handling those error cases.</p> <p>Most operations within the Tag Processor are designed to minimize the difference between an input and output document for any given change. For example, the <code>add_class</code> and <code>remove_class</code> methods preserve whitespace and the class ordering within the <code>class</code> attribute; and when encountering tags with duplicated attributes, the Tag Processor will leave those invalid duplicate attributes where they are but update the proper attribute which the browser will read for parsing its value. An exception to this rule is that all attribute updates store their values as double-quoted strings, meaning that attributes on input with single-quoted or unquoted values will appear in the output with double-quotes.</p> <h3 id="scripting-flag">Scripting Flag</h3> <p>The Tag Processor parses HTML with the "scripting flag" disabled. This means that it doesn’t run any scripts while parsing the page. In a browser with JavaScript enabled, for example, the script can change the parse of the document as it loads. On the server, however, evaluating JavaScript is not only impractical, but also unwanted.</p> <p>Practically this means that the Tag Processor will descend into NOSCRIPT elements and process its child tags. Were the scripting flag enabled, such as in a typical browser, the contents of NOSCRIPT are skipped entirely.</p> <p>This allows the HTML API to process the content that will be presented in a browser when scripting is disabled, but it offers a different view of a page than most browser sessions will experience. E.g. the tags inside the NOSCRIPT disappear.</p> <h3 id="text-encoding">Text Encoding</h3> <p>The Tag Processor assumes that the input HTML document is encoded with a text encoding compatible with 7-bit ASCII’s ‘&lt;‘, ‘&gt;’, ‘&amp;’, ‘;’, ‘/’, ‘=’, "’", ‘"’, ‘a’ – ‘z’, ‘A’ – ‘Z’, and the whitespace characters ‘ ‘, tab, carriage-return, newline, and form-feed.</p> <p>In practice, this includes almost every single-byte encoding as well as UTF-8. Notably, however, it does not include UTF-16. If providing input that’s incompatible, then convert the encoding beforehand.</p></section> <section><h2 id="methods">Methods</h2> <section style="margin-top:var(--wp--preset--spacing--20);" id="uses"><figure class="wp-block-table "><table>
<thead><tr>
<th scope="col">Name</th>
<th scope="col">Description</th>
</tr></thead>
<tbody>
<tr class="">
<td><a href="wp_html_tag_processor/__construct.html">WP_HTML_Tag_Processor::__construct</a></td>
<td>Constructor.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/__tostring.html">WP_HTML_Tag_Processor::__toString</a></td>
<td>Returns the string representation of the HTML Tag Processor.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/add_class.html">WP_HTML_Tag_Processor::add_class</a></td>
<td>Adds a new class name to the currently matched tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/after_tag.html">WP_HTML_Tag_Processor::after_tag</a></td>
<td>Applies attribute updates and cleans up once a tag is fully parsed.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/apply_attributes_updates.html">WP_HTML_Tag_Processor::apply_attributes_updates</a></td>
<td>Applies attribute updates to HTML document.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/base_class_next_token.html">WP_HTML_Tag_Processor::base_class_next_token</a></td>
<td>Internal method which finds the next token in the HTML document.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/class_list.html">WP_HTML_Tag_Processor::class_list</a></td>
<td>Generator for a foreach loop to step through each class name for the matched tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/class_name_updates_to_attributes_updates.html">WP_HTML_Tag_Processor::class_name_updates_to_attributes_updates</a></td>
<td>Converts class name updates into tag attributes updates (they are accumulated in different data formats for performance).</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/get_attribute.html">WP_HTML_Tag_Processor::get_attribute</a></td>
<td>Returns the value of a requested attribute from a matched tag opener if that attribute exists.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/get_attribute_names_with_prefix.html">WP_HTML_Tag_Processor::get_attribute_names_with_prefix</a></td>
<td>Gets lowercase names of all attributes matching a given prefix in the current tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/get_comment_type.html">WP_HTML_Tag_Processor::get_comment_type</a></td>
<td>Indicates what kind of comment produced the comment node.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/get_enqueued_attribute_value.html">WP_HTML_Tag_Processor::get_enqueued_attribute_value</a></td>
<td>Return the enqueued value for a given attribute, if one exists.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/get_modifiable_text.html">WP_HTML_Tag_Processor::get_modifiable_text</a></td>
<td>Returns the modifiable text for a matched token, or an empty string.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/get_tag.html">WP_HTML_Tag_Processor::get_tag</a></td>
<td>Returns the uppercase name of the matched tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/get_token_name.html">WP_HTML_Tag_Processor::get_token_name</a></td>
<td>Returns the node name represented by the token.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/get_token_type.html">WP_HTML_Tag_Processor::get_token_type</a></td>
<td>Indicates the kind of matched token, if any.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/get_updated_html.html">WP_HTML_Tag_Processor::get_updated_html</a></td>
<td>Returns the string representation of the HTML Tag Processor.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/has_bookmark.html">WP_HTML_Tag_Processor::has_bookmark</a></td>
<td>Checks whether a bookmark with the given name exists.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/has_class.html">WP_HTML_Tag_Processor::has_class</a></td>
<td>Returns if a matched tag contains the given ASCII case-insensitive class name.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/has_self_closing_flag.html">WP_HTML_Tag_Processor::has_self_closing_flag</a></td>
<td>Indicates if the currently matched tag contains the self-closing flag.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/is_tag_closer.html">WP_HTML_Tag_Processor::is_tag_closer</a></td>
<td>Indicates if the current tag token is a tag closer.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/matches.html">WP_HTML_Tag_Processor::matches</a></td>
<td>Checks whether a given tag and its attributes match the search criteria.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/next_tag.html">WP_HTML_Tag_Processor::next_tag</a></td>
<td>Finds the next tag matching the $query.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/next_token.html">WP_HTML_Tag_Processor::next_token</a></td>
<td>Finds the next token in the HTML document.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/parse_next_attribute.html">WP_HTML_Tag_Processor::parse_next_attribute</a></td>
<td>Parses the next attribute.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/parse_next_tag.html">WP_HTML_Tag_Processor::parse_next_tag</a></td>
<td>Parses the next tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/parse_query.html">WP_HTML_Tag_Processor::parse_query</a></td>
<td>Parses tag query input into internal search criteria.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/paused_at_incomplete_token.html">WP_HTML_Tag_Processor::paused_at_incomplete_token</a></td>
<td>Whether the processor paused because the input HTML document ended in the middle of a syntax element, such as in the middle of a tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/release_bookmark.html">WP_HTML_Tag_Processor::release_bookmark</a></td>
<td>Removes a bookmark that is no longer needed.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/remove_attribute.html">WP_HTML_Tag_Processor::remove_attribute</a></td>
<td>Remove an attribute from the currently-matched tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/remove_class.html">WP_HTML_Tag_Processor::remove_class</a></td>
<td>Removes a class name from the currently matched tag.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/seek.html">WP_HTML_Tag_Processor::seek</a></td>
<td>Move the internal cursor in the Tag Processor to a given bookmark’s location.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/set_attribute.html">WP_HTML_Tag_Processor::set_attribute</a></td>
<td>Updates or creates a new attribute on the currently matched tag with the passed value.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/set_bookmark.html">WP_HTML_Tag_Processor::set_bookmark</a></td>
<td>Sets a bookmark in the HTML document.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/skip_rawtext.html">WP_HTML_Tag_Processor::skip_rawtext</a></td>
<td>Skips contents of generic rawtext elements.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/skip_rcdata.html">WP_HTML_Tag_Processor::skip_rcdata</a></td>
<td>Skips contents of RCDATA elements, namely title and textarea tags.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/skip_script_data.html">WP_HTML_Tag_Processor::skip_script_data</a></td>
<td>Skips contents of script tags.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/skip_whitespace.html">WP_HTML_Tag_Processor::skip_whitespace</a></td>
<td>Move the internal cursor past any immediate successive whitespace.</td>
</tr>
<tr class="">
<td><a href="wp_html_tag_processor/sort_start_ascending.html">WP_HTML_Tag_Processor::sort_start_ascending</a></td>
<td>Compare two <a href="wp_html_text_replacement.html" rel="class">WP_HTML_Text_Replacement</a> objects.</td>
</tr>
</tbody>
</table></figure></section> </section> <section><h2 id="source">Source</h2> <pre class="wp-block-code" data-start="411" aria-label="Function source code" data-language="php"><code id="wporg-source-code" lang="php" class="language-php line-numbers">class WP_HTML_Tag_Processor {
	/**
	 * The maximum number of bookmarks allowed to exist at
	 * any given time.
	 *
	 * @since 6.2.0
	 * @var int
	 *
	 * @see WP_HTML_Tag_Processor::set_bookmark()
	 */
	const MAX_BOOKMARKS = 10;

	/**
	 * Maximum number of times seek() can be called.
	 * Prevents accidental infinite loops.
	 *
	 * @since 6.2.0
	 * @var int
	 *
	 * @see WP_HTML_Tag_Processor::seek()
	 */
	const MAX_SEEK_OPS = 1000;

	/**
	 * The HTML document to parse.
	 *
	 * @since 6.2.0
	 * @var string
	 */
	protected $html;

	/**
	 * The last query passed to next_tag().
	 *
	 * @since 6.2.0
	 * @var array|null
	 */
	private $last_query;

	/**
	 * The tag name this processor currently scans for.
	 *
	 * @since 6.2.0
	 * @var string|null
	 */
	private $sought_tag_name;

	/**
	 * The CSS class name this processor currently scans for.
	 *
	 * @since 6.2.0
	 * @var string|null
	 */
	private $sought_class_name;

	/**
	 * The match offset this processor currently scans for.
	 *
	 * @since 6.2.0
	 * @var int|null
	 */
	private $sought_match_offset;

	/**
	 * Whether to visit tag closers, e.g. &lt;/div&gt;, when walking an input document.
	 *
	 * @since 6.2.0
	 * @var bool
	 */
	private $stop_on_tag_closers;

	/**
	 * Specifies mode of operation of the parser at any given time.
	 *
	 * | State           | Meaning                                                              |
	 * | ----------------|----------------------------------------------------------------------|
	 * | *Ready*         | The parser is ready to run.                                          |
	 * | *Complete*      | There is nothing left to parse.                                      |
	 * | *Incomplete*    | The HTML ended in the middle of a token; nothing more can be parsed. |
	 * | *Matched tag*   | Found an HTML tag; it's possible to modify its attributes.           |
	 * | *Text node*     | Found a #text node; this is plaintext and modifiable.                |
	 * | *CDATA node*    | Found a CDATA section; this is modifiable.                           |
	 * | *Comment*       | Found a comment or bogus comment; this is modifiable.                |
	 * | *Presumptuous*  | Found an empty tag closer: `&lt;/&gt;`.                                    |
	 * | *Funky comment* | Found a tag closer with an invalid tag name; this is modifiable.     |
	 *
	 * @since 6.5.0
	 *
	 * @see WP_HTML_Tag_Processor::STATE_READY
	 * @see WP_HTML_Tag_Processor::STATE_COMPLETE
	 * @see WP_HTML_Tag_Processor::STATE_INCOMPLETE_INPUT
	 * @see WP_HTML_Tag_Processor::STATE_MATCHED_TAG
	 * @see WP_HTML_Tag_Processor::STATE_TEXT_NODE
	 * @see WP_HTML_Tag_Processor::STATE_CDATA_NODE
	 * @see WP_HTML_Tag_Processor::STATE_COMMENT
	 * @see WP_HTML_Tag_Processor::STATE_DOCTYPE
	 * @see WP_HTML_Tag_Processor::STATE_PRESUMPTUOUS_TAG
	 * @see WP_HTML_Tag_Processor::STATE_FUNKY_COMMENT
	 *
	 * @var string
	 */
	protected $parser_state = self::STATE_READY;

	/**
	 * Indicates if the document is in quirks mode or no-quirks mode.
	 *
	 *  Impact on HTML parsing:
	 *
	 *   - In `NO_QUIRKS_MODE` (also known as "standard mode"):
	 *       - CSS class and ID selectors match byte-for-byte (case-sensitively).
	 *       - A TABLE start tag `&lt;table&gt;` implicitly closes any open `P` element.
	 *
	 *   - In `QUIRKS_MODE`:
	 *       - CSS class and ID selectors match match in an ASCII case-insensitive manner.
	 *       - A TABLE start tag `&lt;table&gt;` opens a `TABLE` element as a child of a `P`
	 *         element if one is open.
	 *
	 * Quirks and no-quirks mode are thus mostly about styling, but have an impact when
	 * tables are found inside paragraph elements.
	 *
	 * @see self::QUIRKS_MODE
	 * @see self::NO_QUIRKS_MODE
	 *
	 * @since 6.7.0
	 *
	 * @var string
	 */
	protected $compat_mode = self::NO_QUIRKS_MODE;

	/**
	 * Indicates whether the parser is inside foreign content,
	 * e.g. inside an SVG or MathML element.
	 *
	 * One of 'html', 'svg', or 'math'.
	 *
	 * Several parsing rules change based on whether the parser
	 * is inside foreign content, including whether CDATA sections
	 * are allowed and whether a self-closing flag indicates that
	 * an element has no content.
	 *
	 * @since 6.7.0
	 *
	 * @var string
	 */
	private $parsing_namespace = 'html';

	/**
	 * What kind of syntax token became an HTML comment.
	 *
	 * Since there are many ways in which HTML syntax can create an HTML comment,
	 * this indicates which of those caused it. This allows the Tag Processor to
	 * represent more from the original input document than would appear in the DOM.
	 *
	 * @since 6.5.0
	 *
	 * @var string|null
	 */
	protected $comment_type = null;

	/**
	 * What kind of text the matched text node represents, if it was subdivided.
	 *
	 * @see self::TEXT_IS_NULL_SEQUENCE
	 * @see self::TEXT_IS_WHITESPACE
	 * @see self::TEXT_IS_GENERIC
	 * @see self::subdivide_text_appropriately
	 *
	 * @since 6.7.0
	 *
	 * @var string
	 */
	protected $text_node_classification = self::TEXT_IS_GENERIC;

	/**
	 * How many bytes from the original HTML document have been read and parsed.
	 *
	 * This value points to the latest byte offset in the input document which
	 * has been already parsed. It is the internal cursor for the Tag Processor
	 * and updates while scanning through the HTML tokens.
	 *
	 * @since 6.2.0
	 * @var int
	 */
	private $bytes_already_parsed = 0;

	/**
	 * Byte offset in input document where current token starts.
	 *
	 * Example:
	 *
	 *     &lt;div id="test"&gt;...
	 *     01234
	 *     - token starts at 0
	 *
	 * @since 6.5.0
	 *
	 * @var int|null
	 */
	private $token_starts_at;

	/**
	 * Byte length of current token.
	 *
	 * Example:
	 *
	 *     &lt;div id="test"&gt;...
	 *     012345678901234
	 *     - token length is 14 - 0 = 14
	 *
	 *     a &lt;!-- comment --&gt; is a token.
	 *     0123456789 123456789 123456789
	 *     - token length is 17 - 2 = 15
	 *
	 * @since 6.5.0
	 *
	 * @var int|null
	 */
	private $token_length;

	/**
	 * Byte offset in input document where current tag name starts.
	 *
	 * Example:
	 *
	 *     &lt;div id="test"&gt;...
	 *     01234
	 *      - tag name starts at 1
	 *
	 * @since 6.2.0
	 *
	 * @var int|null
	 */
	private $tag_name_starts_at;

	/**
	 * Byte length of current tag name.
	 *
	 * Example:
	 *
	 *     &lt;div id="test"&gt;...
	 *     01234
	 *      --- tag name length is 3
	 *
	 * @since 6.2.0
	 *
	 * @var int|null
	 */
	private $tag_name_length;

	/**
	 * Byte offset into input document where current modifiable text starts.
	 *
	 * @since 6.5.0
	 *
	 * @var int
	 */
	private $text_starts_at;

	/**
	 * Byte length of modifiable text.
	 *
	 * @since 6.5.0
	 *
	 * @var int
	 */
	private $text_length;

	/**
	 * Whether the current tag is an opening tag, e.g. &lt;div&gt;, or a closing tag, e.g. &lt;/div&gt;.
	 *
	 * @var bool
	 */
	private $is_closing_tag;

	/**
	 * Lazily-built index of attributes found within an HTML tag, keyed by the attribute name.
	 *
	 * Example:
	 *
	 *     // Supposing the parser is working through this content
	 *     // and stops after recognizing the `id` attribute.
	 *     // &lt;div id="test-4" class=outline title="data:text/plain;base64=asdk3nk1j3fo8"&gt;
	 *     //                 ^ parsing will continue from this point.
	 *     $this-&gt;attributes = array(
	 *         'id' =&gt; new WP_HTML_Attribute_Token( 'id', 9, 6, 5, 11, false )
	 *     );
	 *
	 *     // When picking up parsing again, or when asking to find the
	 *     // `class` attribute we will continue and add to this array.
	 *     $this-&gt;attributes = array(
	 *         'id'    =&gt; new WP_HTML_Attribute_Token( 'id', 9, 6, 5, 11, false ),
	 *         'class' =&gt; new WP_HTML_Attribute_Token( 'class', 23, 7, 17, 13, false )
	 *     );
	 *
	 *     // Note that only the `class` attribute value is stored in the index.
	 *     // That's because it is the only value used by this class at the moment.
	 *
	 * @since 6.2.0
	 * @var WP_HTML_Attribute_Token[]
	 */
	private $attributes = array();

	/**
	 * Tracks spans of duplicate attributes on a given tag, used for removing
	 * all copies of an attribute when calling `remove_attribute()`.
	 *
	 * @since 6.3.2
	 *
	 * @var (WP_HTML_Span[])[]|null
	 */
	private $duplicate_attributes = null;

	/**
	 * Which class names to add or remove from a tag.
	 *
	 * These are tracked separately from attribute updates because they are
	 * semantically distinct, whereas this interface exists for the common
	 * case of adding and removing class names while other attributes are
	 * generally modified as with DOM `setAttribute` calls.
	 *
	 * When modifying an HTML document these will eventually be collapsed
	 * into a single `set_attribute( 'class', $changes )` call.
	 *
	 * Example:
	 *
	 *     // Add the `wp-block-group` class, remove the `wp-group` class.
	 *     $classname_updates = array(
	 *         // Indexed by a comparable class name.
	 *         'wp-block-group' =&gt; WP_HTML_Tag_Processor::ADD_CLASS,
	 *         'wp-group'       =&gt; WP_HTML_Tag_Processor::REMOVE_CLASS
	 *     );
	 *
	 * @since 6.2.0
	 * @var bool[]
	 */
	private $classname_updates = array();

	/**
	 * Tracks a semantic location in the original HTML which
	 * shifts with updates as they are applied to the document.
	 *
	 * @since 6.2.0
	 * @var WP_HTML_Span[]
	 */
	protected $bookmarks = array();

	const ADD_CLASS    = true;
	const REMOVE_CLASS = false;
	const SKIP_CLASS   = null;

	/**
	 * Lexical replacements to apply to input HTML document.
	 *
	 * "Lexical" in this class refers to the part of this class which
	 * operates on pure text _as text_ and not as HTML. There's a line
	 * between the public interface, with HTML-semantic methods like
	 * `set_attribute` and `add_class`, and an internal state that tracks
	 * text offsets in the input document.
	 *
	 * When higher-level HTML methods are called, those have to transform their
	 * operations (such as setting an attribute's value) into text diffing
	 * operations (such as replacing the sub-string from indices A to B with
	 * some given new string). These text-diffing operations are the lexical
	 * updates.
	 *
	 * As new higher-level methods are added they need to collapse their
	 * operations into these lower-level lexical updates since that's the
	 * Tag Processor's internal language of change. Any code which creates
	 * these lexical updates must ensure that they do not cross HTML syntax
	 * boundaries, however, so these should never be exposed outside of this
	 * class or any classes which intentionally expand its functionality.
	 *
	 * These are enqueued while editing the document instead of being immediately
	 * applied to avoid processing overhead, string allocations, and string
	 * copies when applying many updates to a single document.
	 *
	 * Example:
	 *
	 *     // Replace an attribute stored with a new value, indices
	 *     // sourced from the lazily-parsed HTML recognizer.
	 *     $start  = $attributes['src']-&gt;start;
	 *     $length = $attributes['src']-&gt;length;
	 *     $modifications[] = new WP_HTML_Text_Replacement( $start, $length, $new_value );
	 *
	 *     // Correspondingly, something like this will appear in this array.
	 *     $lexical_updates = array(
	 *         WP_HTML_Text_Replacement( 14, 28, 'https://my-site.my-domain/wp-content/uploads/2014/08/kittens.jpg' )
	 *     );
	 *
	 * @since 6.2.0
	 * @var WP_HTML_Text_Replacement[]
	 */
	protected $lexical_updates = array();

	/**
	 * Tracks and limits `seek()` calls to prevent accidental infinite loops.
	 *
	 * @since 6.2.0
	 * @var int
	 *
	 * @see WP_HTML_Tag_Processor::seek()
	 */
	protected $seek_count = 0;

	/**
	 * Whether the parser should skip over an immediately-following linefeed
	 * character, as is the case with LISTING, PRE, and TEXTAREA.
	 *
	 * &gt; If the next token is a U+000A LINE FEED (LF) character token, then
	 * &gt; ignore that token and move on to the next one. (Newlines at the start
	 * &gt; of [these] elements are ignored as an authoring convenience.)
	 *
	 * @since 6.7.0
	 *
	 * @var int|null
	 */
	private $skip_newline_at = null;

	/**
	 * Constructor.
	 *
	 * @since 6.2.0
	 *
	 * @param string $html HTML to process.
	 */
	public function __construct( $html ) {
		$this-&gt;html = $html;
	}

	/**
	 * Switches parsing mode into a new namespace, such as when
	 * encountering an SVG tag and entering foreign content.
	 *
	 * @since 6.7.0
	 *
	 * @param string $new_namespace One of 'html', 'svg', or 'math' indicating into what
	 *                              namespace the next tokens will be processed.
	 * @return bool Whether the namespace was valid and changed.
	 */
	public function change_parsing_namespace( string $new_namespace ): bool {
		if ( ! in_array( $new_namespace, array( 'html', 'math', 'svg' ), true ) ) {
			return false;
		}

		$this-&gt;parsing_namespace = $new_namespace;
		return true;
	}

	/**
	 * Finds the next tag matching the $query.
	 *
	 * @since 6.2.0
	 * @since 6.5.0 No longer processes incomplete tokens at end of document; pauses the processor at start of token.
	 *
	 * @param array|string|null $query {
	 *     Optional. Which tag name to find, having which class, etc. Default is to find any tag.
	 *
	 *     @type string|null $tag_name     Which tag to find, or `null` for "any tag."
	 *     @type int|null    $match_offset Find the Nth tag matching all search criteria.
	 *                                     1 for "first" tag, 3 for "third," etc.
	 *                                     Defaults to first tag.
	 *     @type string|null $class_name   Tag must contain this whole class name to match.
	 *     @type string|null $tag_closers  "visit" or "skip": whether to stop on tag closers, e.g. &lt;/div&gt;.
	 * }
	 * @return bool Whether a tag was matched.
	 */
	public function next_tag( $query = null ): bool {
		$this-&gt;parse_query( $query );
		$already_found = 0;

		do {
			if ( false === $this-&gt;next_token() ) {
				return false;
			}

			if ( self::STATE_MATCHED_TAG !== $this-&gt;parser_state ) {
				continue;
			}

			if ( $this-&gt;matches() ) {
				++$already_found;
			}
		} while ( $already_found &lt; $this-&gt;sought_match_offset );

		return true;
	}

	/**
	 * Finds the next token in the HTML document.
	 *
	 * An HTML document can be viewed as a stream of tokens,
	 * where tokens are things like HTML tags, HTML comments,
	 * text nodes, etc. This method finds the next token in
	 * the HTML document and returns whether it found one.
	 *
	 * If it starts parsing a token and reaches the end of the
	 * document then it will seek to the start of the last
	 * token and pause, returning `false` to indicate that it
	 * failed to find a complete token.
	 *
	 * Possible token types, based on the HTML specification:
	 *
	 *  - an HTML tag, whether opening, closing, or void.
	 *  - a text node - the plaintext inside tags.
	 *  - an HTML comment.
	 *  - a DOCTYPE declaration.
	 *  - a processing instruction, e.g. `&lt;?xml version="1.0" ?&gt;`.
	 *
	 * The Tag Processor currently only supports the tag token.
	 *
	 * @since 6.5.0
	 * @since 6.7.0 Recognizes CDATA sections within foreign content.
	 *
	 * @return bool Whether a token was parsed.
	 */
	public function next_token(): bool {
		return $this-&gt;base_class_next_token();
	}

	/**
	 * Internal method which finds the next token in the HTML document.
	 *
	 * This method is a protected internal function which implements the logic for
	 * finding the next token in a document. It exists so that the parser can update
	 * its state without affecting the location of the cursor in the document and
	 * without triggering subclass methods for things like `next_token()`, e.g. when
	 * applying patches before searching for the next token.
	 *
	 * @since 6.5.0
	 *
	 * @access private
	 *
	 * @return bool Whether a token was parsed.
	 */
	private function base_class_next_token(): bool {
		$was_at = $this-&gt;bytes_already_parsed;
		$this-&gt;after_tag();

		// Don't proceed if there's nothing more to scan.
		if (
			self::STATE_COMPLETE === $this-&gt;parser_state ||
			self::STATE_INCOMPLETE_INPUT === $this-&gt;parser_state
		) {
			return false;
		}

		/*
		 * The next step in the parsing loop determines the parsing state;
		 * clear it so that state doesn't linger from the previous step.
		 */
		$this-&gt;parser_state = self::STATE_READY;

		if ( $this-&gt;bytes_already_parsed &gt;= strlen( $this-&gt;html ) ) {
			$this-&gt;parser_state = self::STATE_COMPLETE;
			return false;
		}

		// Find the next tag if it exists.
		if ( false === $this-&gt;parse_next_tag() ) {
			if ( self::STATE_INCOMPLETE_INPUT === $this-&gt;parser_state ) {
				$this-&gt;bytes_already_parsed = $was_at;
			}

			return false;
		}

		/*
		 * For legacy reasons the rest of this function handles tags and their
		 * attributes. If the processor has reached the end of the document
		 * or if it matched any other token then it should return here to avoid
		 * attempting to process tag-specific syntax.
		 */
		if (
			self::STATE_INCOMPLETE_INPUT !== $this-&gt;parser_state &amp;&amp;
			self::STATE_COMPLETE !== $this-&gt;parser_state &amp;&amp;
			self::STATE_MATCHED_TAG !== $this-&gt;parser_state
		) {
			return true;
		}

		// Parse all of its attributes.
		while ( $this-&gt;parse_next_attribute() ) {
			continue;
		}

		// Ensure that the tag closes before the end of the document.
		if (
			self::STATE_INCOMPLETE_INPUT === $this-&gt;parser_state ||
			$this-&gt;bytes_already_parsed &gt;= strlen( $this-&gt;html )
		) {
			// Does this appropriately clear state (parsed attributes)?
			$this-&gt;parser_state         = self::STATE_INCOMPLETE_INPUT;
			$this-&gt;bytes_already_parsed = $was_at;

			return false;
		}

		$tag_ends_at = strpos( $this-&gt;html, '&gt;', $this-&gt;bytes_already_parsed );
		if ( false === $tag_ends_at ) {
			$this-&gt;parser_state         = self::STATE_INCOMPLETE_INPUT;
			$this-&gt;bytes_already_parsed = $was_at;

			return false;
		}
		$this-&gt;parser_state         = self::STATE_MATCHED_TAG;
		$this-&gt;bytes_already_parsed = $tag_ends_at + 1;
		$this-&gt;token_length         = $this-&gt;bytes_already_parsed - $this-&gt;token_starts_at;

		/*
		 * Certain tags require additional processing. The first-letter pre-check
		 * avoids unnecessary string allocation when comparing the tag names.
		 *
		 *  - IFRAME
		 *  - LISTING (deprecated)
		 *  - NOEMBED (deprecated)
		 *  - NOFRAMES (deprecated)
		 *  - PRE
		 *  - SCRIPT
		 *  - STYLE
		 *  - TEXTAREA
		 *  - TITLE
		 *  - XMP (deprecated)
		 */
		if (
			$this-&gt;is_closing_tag ||
			'html' !== $this-&gt;parsing_namespace ||
			1 !== strspn( $this-&gt;html, 'iIlLnNpPsStTxX', $this-&gt;tag_name_starts_at, 1 )
		) {
			return true;
		}

		$tag_name = $this-&gt;get_tag();

		/*
		 * For LISTING, PRE, and TEXTAREA, the first linefeed of an immediately-following
		 * text node is ignored as an authoring convenience.
		 *
		 * @see static::skip_newline_at
		 */
		if ( 'LISTING' === $tag_name || 'PRE' === $tag_name ) {
			$this-&gt;skip_newline_at = $this-&gt;bytes_already_parsed;
			return true;
		}

		/*
		 * There are certain elements whose children are not DATA but are instead
		 * RCDATA or RAWTEXT. These cannot contain other elements, and the contents
		 * are parsed as plaintext, with character references decoded in RCDATA but
		 * not in RAWTEXT.
		 *
		 * These elements are described here as "self-contained" or special atomic
		 * elements whose end tag is consumed with the opening tag, and they will
		 * contain modifiable text inside of them.
		 *
		 * Preserve the opening tag pointers, as these will be overwritten
		 * when finding the closing tag. They will be reset after finding
		 * the closing to tag to point to the opening of the special atomic
		 * tag sequence.
		 */
		$tag_name_starts_at   = $this-&gt;tag_name_starts_at;
		$tag_name_length      = $this-&gt;tag_name_length;
		$tag_ends_at          = $this-&gt;token_starts_at + $this-&gt;token_length;
		$attributes           = $this-&gt;attributes;
		$duplicate_attributes = $this-&gt;duplicate_attributes;

		// Find the closing tag if necessary.
		switch ( $tag_name ) {
			case 'SCRIPT':
				$found_closer = $this-&gt;skip_script_data();
				break;

			case 'TEXTAREA':
			case 'TITLE':
				$found_closer = $this-&gt;skip_rcdata( $tag_name );
				break;

			/*
			 * In the browser this list would include the NOSCRIPT element,
			 * but the Tag Processor is an environment with the scripting
			 * flag disabled, meaning that it needs to descend into the
			 * NOSCRIPT element to be able to properly process what will be
			 * sent to a browser.
			 *
			 * Note that this rule makes HTML5 syntax incompatible with XML,
			 * because the parsing of this token depends on client application.
			 * The NOSCRIPT element cannot be represented in the XHTML syntax.
			 */
			case 'IFRAME':
			case 'NOEMBED':
			case 'NOFRAMES':
			case 'STYLE':
			case 'XMP':
				$found_closer = $this-&gt;skip_rawtext( $tag_name );
				break;

			// No other tags should be treated in their entirety here.
			default:
				return true;
		}

		if ( ! $found_closer ) {
			$this-&gt;parser_state         = self::STATE_INCOMPLETE_INPUT;
			$this-&gt;bytes_already_parsed = $was_at;
			return false;
		}

		/*
		 * The values here look like they reference the opening tag but they reference
		 * the closing tag instead. This is why the opening tag values were stored
		 * above in a variable. It reads confusingly here, but that's because the
		 * functions that skip the contents have moved all the internal cursors past
		 * the inner content of the tag.
		 */
		$this-&gt;token_starts_at      = $was_at;
		$this-&gt;token_length         = $this-&gt;bytes_already_parsed - $this-&gt;token_starts_at;
		$this-&gt;text_starts_at       = $tag_ends_at;
		$this-&gt;text_length          = $this-&gt;tag_name_starts_at - $this-&gt;text_starts_at;
		$this-&gt;tag_name_starts_at   = $tag_name_starts_at;
		$this-&gt;tag_name_length      = $tag_name_length;
		$this-&gt;attributes           = $attributes;
		$this-&gt;duplicate_attributes = $duplicate_attributes;

		return true;
	}

	/**
	 * Whether the processor paused because the input HTML document ended
	 * in the middle of a syntax element, such as in the middle of a tag.
	 *
	 * Example:
	 *
	 *     $processor = new WP_HTML_Tag_Processor( '&lt;input type="text" value="Th' );
	 *     false      === $processor-&gt;get_next_tag();
	 *     true       === $processor-&gt;paused_at_incomplete_token();
	 *
	 * @since 6.5.0
	 *
	 * @return bool Whether the parse paused at the start of an incomplete token.
	 */
	public function paused_at_incomplete_token(): bool {
		return self::STATE_INCOMPLETE_INPUT === $this-&gt;parser_state;
	}

	/**
	 * Generator for a foreach loop to step through each class name for the matched tag.
	 *
	 * This generator function is designed to be used inside a "foreach" loop.
	 *
	 * Example:
	 *
	 *     $p = new WP_HTML_Tag_Processor( "&lt;div class='free &amp;lt;egg&amp;lt;\tlang-en'&gt;" );
	 *     $p-&gt;next_tag();
	 *     foreach ( $p-&gt;class_list() as $class_name ) {
	 *         echo "{$class_name} ";
	 *     }
	 *     // Outputs: "free &lt;egg&gt; lang-en "
	 *
	 * @since 6.4.0
	 */
	public function class_list() {
		if ( self::STATE_MATCHED_TAG !== $this-&gt;parser_state ) {
			return;
		}

		/** @var string $class contains the string value of the class attribute, with character references decoded. */
		$class = $this-&gt;get_attribute( 'class' );

		if ( ! is_string( $class ) ) {
			return;
		}

		$seen = array();

		$is_quirks = self::QUIRKS_MODE === $this-&gt;compat_mode;

		$at = 0;
		while ( $at &lt; strlen( $class ) ) {
			// Skip past any initial boundary characters.
			$at += strspn( $class, " \t\f\r\n", $at );
			if ( $at &gt;= strlen( $class ) ) {
				return;
			}

			// Find the byte length until the next boundary.
			$length = strcspn( $class, " \t\f\r\n", $at );
			if ( 0 === $length ) {
				return;
			}

			$name = str_replace( "\x00", "\u{FFFD}", substr( $class, $at, $length ) );
			if ( $is_quirks ) {
				$name = strtolower( $name );
			}
			$at += $length;

			/*
			 * It's expected that the number of class names for a given tag is relatively small.
			 * Given this, it is probably faster overall to scan an array for a value rather
			 * than to use the class name as a key and check if it's a key of $seen.
			 */
			if ( in_array( $name, $seen, true ) ) {
				continue;
			}

			$seen[] = $name;
			yield $name;
		}
	}


	/**
	 * Returns if a matched tag contains the given ASCII case-insensitive class name.
	 *
	 * @since 6.4.0
	 *
	 * @param string $wanted_class Look for this CSS class name, ASCII case-insensitive.
	 * @return bool|null Whether the matched tag contains the given class name, or null if not matched.
	 */
	public function has_class( $wanted_class ): ?bool {
		if ( self::STATE_MATCHED_TAG !== $this-&gt;parser_state ) {
			return null;
		}

		$case_insensitive = self::QUIRKS_MODE === $this-&gt;compat_mode;

		$wanted_length = strlen( $wanted_class );
		foreach ( $this-&gt;class_list() as $class_name ) {
			if (
				strlen( $class_name ) === $wanted_length &amp;&amp;
				0 === substr_compare( $class_name, $wanted_class, 0, strlen( $wanted_class ), $case_insensitive )
			) {
				return true;
			}
		}

		return false;
	}


	/**
	 * Sets a bookmark in the HTML document.
	 *
	 * Bookmarks represent specific places or tokens in the HTML
	 * document, such as a tag opener or closer. When applying
	 * edits to a document, such as setting an attribute, the
	 * text offsets of that token may shift; the bookmark is
	 * kept updated with those shifts and remains stable unless
	 * the entire span of text in which the token sits is removed.
	 *
	 * Release bookmarks when they are no longer needed.
	 *
	 * Example:
	 *
	 *     &lt;main&gt;&lt;h2&gt;Surprising fact you may not know!&lt;/h2&gt;&lt;/main&gt;
	 *           ^  ^
	 *            \-|-- this `H2` opener bookmark tracks the token
	 *
	 *     &lt;main class="clickbait"&gt;&lt;h2&gt;Surprising fact you may no…
	 *                             ^  ^
	 *                              \-|-- it shifts with edits
	 *
	 * Bookmarks provide the ability to seek to a previously-scanned
	 * place in the HTML document. This avoids the need to re-scan
	 * the entire document.
	 *
	 * Example:
	 *
	 *     &lt;ul&gt;&lt;li&gt;One&lt;/li&gt;&lt;li&gt;Two&lt;/li&gt;&lt;li&gt;Three&lt;/li&gt;&lt;/ul&gt;
	 *                                 ^^^^
	 *                                 want to note this last item
	 *
	 *     $p = new WP_HTML_Tag_Processor( $html );
	 *     $in_list = false;
	 *     while ( $p-&gt;next_tag( array( 'tag_closers' =&gt; $in_list ? 'visit' : 'skip' ) ) ) {
	 *         if ( 'UL' === $p-&gt;get_tag() ) {
	 *             if ( $p-&gt;is_tag_closer() ) {
	 *                 $in_list = false;
	 *                 $p-&gt;set_bookmark( 'resume' );
	 *                 if ( $p-&gt;seek( 'last-li' ) ) {
	 *                     $p-&gt;add_class( 'last-li' );
	 *                 }
	 *                 $p-&gt;seek( 'resume' );
	 *                 $p-&gt;release_bookmark( 'last-li' );
	 *                 $p-&gt;release_bookmark( 'resume' );
	 *             } else {
	 *                 $in_list = true;
	 *             }
	 *         }
	 *
	 *         if ( 'LI' === $p-&gt;get_tag() ) {
	 *             $p-&gt;set_bookmark( 'last-li' );
	 *         }
	 *     }
	 *
	 * Bookmarks intentionally hide the internal string offsets
	 * to which they refer. They are maintained internally as
	 * updates are applied to the HTML document and therefore
	 * retain their "position" - the location to which they
	 * originally pointed. The inability to use bookmarks with
	 * functions like `substr` is therefore intentional to guard
	 * against accidentally breaking the HTML.
	 *
	 * Because bookmarks allocate memory and require processing
	 * for every applied update, they are limited and require
	 * a name. They should not be created with programmatically-made
	 * names, such as "li_{$index}" with some loop. As a general
	 * rule they should only be created with string-literal names
	 * like "start-of-section" or "last-paragraph".
	 *
	 * Bookmarks are a powerful tool to enable complicated behavior.
	 * Consider double-checking that you need this tool if you are
	 * reaching for it, as inappropriate use could lead to broken
	 * HTML structure or unwanted processing overhead.
	 *
	 * @since 6.2.0
	 *
	 * @param string $name Identifies this particular bookmark.
	 * @return bool Whether the bookmark was successfully created.
	 */
	public function set_bookmark( $name ): bool {
		// It only makes sense to set a bookmark if the parser has paused on a concrete token.
		if (
			self::STATE_COMPLETE === $this-&gt;parser_state ||
			self::STATE_INCOMPLETE_INPUT === $this-&gt;parser_state
		) {
			return false;
		}

		if ( ! array_key_exists( $name, $this-&gt;bookmarks ) &amp;&amp; count( $this-&gt;bookmarks ) &gt;= static::MAX_BOOKMARKS ) {
			_doing_it_wrong(
				__METHOD__,
				__( 'Too many bookmarks: cannot create any more.' ),
				'6.2.0'
			);
			return false;
		}

		$this-&gt;bookmarks[ $name ] = new WP_HTML_Span( $this-&gt;token_starts_at, $this-&gt;token_length );

		return true;
	}


	/**
	 * Removes a bookmark that is no longer needed.
	 *
	 * Releasing a bookmark frees up the small
	 * performance overhead it requires.
	 *
	 * @param string $name Name of the bookmark to remove.
	 * @return bool Whether the bookmark already existed before removal.
	 */
	public function release_bookmark( $name ): bool {
		if ( ! array_key_exists( $name, $this-&gt;bookmarks ) ) {
			return false;
		}

		unset( $this-&gt;bookmarks[ $name ] );

		return true;
	}

	/**
	 * Skips contents of generic rawtext elements.
	 *
	 * @since 6.3.2
	 *
	 * @see https://html.spec.whatwg.org/#generic-raw-text-element-parsing-algorithm
	 *
	 * @param string $tag_name The uppercase tag name which will close the RAWTEXT region.
	 * @return bool Whether an end to the RAWTEXT region was found before the end of the document.
	 */
	private function skip_rawtext( string $tag_name ): bool {
		/*
		 * These two functions distinguish themselves on whether character references are
		 * decoded, and since functionality to read the inner markup isn't supported, it's
		 * not necessary to implement these two functions separately.
		 */
		return $this-&gt;skip_rcdata( $tag_name );
	}

	/**
	 * Skips contents of RCDATA elements, namely title and textarea tags.
	 *
	 * @since 6.2.0
	 *
	 * @see https://html.spec.whatwg.org/multipage/parsing.html#rcdata-state
	 *
	 * @param string $tag_name The uppercase tag name which will close the RCDATA region.
	 * @return bool Whether an end to the RCDATA region was found before the end of the document.
	 */
	private function skip_rcdata( string $tag_name ): bool {
		$html       = $this-&gt;html;
		$doc_length = strlen( $html );
		$tag_length = strlen( $tag_name );

		$at = $this-&gt;bytes_already_parsed;

		while ( false !== $at &amp;&amp; $at &lt; $doc_length ) {
			$at                       = strpos( $this-&gt;html, '&lt;/', $at );
			$this-&gt;tag_name_starts_at = $at;

			// Fail if there is no possible tag closer.
			if ( false === $at || ( $at + $tag_length ) &gt;= $doc_length ) {
				return false;
			}

			$at += 2;

			/*
			 * Find a case-insensitive match to the tag name.
			 *
			 * Because tag names are limited to US-ASCII there is no
			 * need to perform any kind of Unicode normalization when
			 * comparing; any character which could be impacted by such
			 * normalization could not be part of a tag name.
			 */
			for ( $i = 0; $i &lt; $tag_length; $i++ ) {
				$tag_char  = $tag_name[ $i ];
				$html_char = $html[ $at + $i ];

				if ( $html_char !== $tag_char &amp;&amp; strtoupper( $html_char ) !== $tag_char ) {
					$at += $i;
					continue 2;
				}
			}

			$at                        += $tag_length;
			$this-&gt;bytes_already_parsed = $at;

			if ( $at &gt;= strlen( $html ) ) {
				return false;
			}

			/*
			 * Ensure that the tag name terminates to avoid matching on
			 * substrings of a longer tag name. For example, the sequence
			 * "&lt;/textarearug" should not match for "&lt;/textarea" even
			 * though "textarea" is found within the text.
			 */
			$c = $html[ $at ];
			if ( ' ' !== $c &amp;&amp; "\t" !== $c &amp;&amp; "\r" !== $c &amp;&amp; "\n" !== $c &amp;&amp; '/' !== $c &amp;&amp; '&gt;' !== $c ) {
				continue;
			}

			while ( $this-&gt;parse_next_attribute() ) {
				continue;
			}

			$at = $this-&gt;bytes_already_parsed;
			if ( $at &gt;= strlen( $this-&gt;html ) ) {
				return false;
			}

			if ( '&gt;' === $html[ $at ] ) {
				$this-&gt;bytes_already_parsed = $at + 1;
				return true;
			}

			if ( $at + 1 &gt;= strlen( $this-&gt;html ) ) {
				return false;
			}

			if ( '/' === $html[ $at ] &amp;&amp; '&gt;' === $html[ $at + 1 ] ) {
				$this-&gt;bytes_already_parsed = $at + 2;
				return true;
			}
		}

		return false;
	}

	/**
	 * Skips contents of script tags.
	 *
	 * @since 6.2.0
	 *
	 * @return bool Whether the script tag was closed before the end of the document.
	 */
	private function skip_script_data(): bool {
		$state      = 'unescaped';
		$html       = $this-&gt;html;
		$doc_length = strlen( $html );
		$at         = $this-&gt;bytes_already_parsed;

		while ( false !== $at &amp;&amp; $at &lt; $doc_length ) {
			$at += strcspn( $html, '-&lt;', $at );

			/*
			 * For all script states a "--&gt;"  transitions
			 * back into the normal unescaped script mode,
			 * even if that's the current state.
			 */
			if (
				$at + 2 &lt; $doc_length &amp;&amp;
				'-' === $html[ $at ] &amp;&amp;
				'-' === $html[ $at + 1 ] &amp;&amp;
				'&gt;' === $html[ $at + 2 ]
			) {
				$at   += 3;
				$state = 'unescaped';
				continue;
			}

			if ( $at + 1 &gt;= $doc_length ) {
				return false;
			}

			/*
			 * Everything of interest past here starts with "&lt;".
			 * Check this character and advance position regardless.
			 */
			if ( '&lt;' !== $html[ $at++ ] ) {
				continue;
			}

			/*
			 * Unlike with "--&gt;", the "&lt;!--" only transitions
			 * into the escaped mode if not already there.
			 *
			 * Inside the escaped modes it will be ignored; and
			 * should never break out of the double-escaped
			 * mode and back into the escaped mode.
			 *
			 * While this requires a mode change, it does not
			 * impact the parsing otherwise, so continue
			 * parsing after updating the state.
			 */
			if (
				$at + 2 &lt; $doc_length &amp;&amp;
				'!' === $html[ $at ] &amp;&amp;
				'-' === $html[ $at + 1 ] &amp;&amp;
				'-' === $html[ $at + 2 ]
			) {
				$at   += 3;
				$state = 'unescaped' === $state ? 'escaped' : $state;
				continue;
			}

			if ( '/' === $html[ $at ] ) {
				$closer_potentially_starts_at = $at - 1;
				$is_closing                   = true;
				++$at;
			} else {
				$is_closing = false;
			}

			/*
			 * At this point the only remaining state-changes occur with the
			 * &lt;script&gt; and &lt;/script&gt; tags; unless one of these appears next,
			 * proceed scanning to the next potential token in the text.
			 */
			if ( ! (
				$at + 6 &lt; $doc_length &amp;&amp;
				( 's' === $html[ $at ] || 'S' === $html[ $at ] ) &amp;&amp;
				( 'c' === $html[ $at + 1 ] || 'C' === $html[ $at + 1 ] ) &amp;&amp;
				( 'r' === $html[ $at + 2 ] || 'R' === $html[ $at + 2 ] ) &amp;&amp;
				( 'i' === $html[ $at + 3 ] || 'I' === $html[ $at + 3 ] ) &amp;&amp;
				( 'p' === $html[ $at + 4 ] || 'P' === $html[ $at + 4 ] ) &amp;&amp;
				( 't' === $html[ $at + 5 ] || 'T' === $html[ $at + 5 ] )
			) ) {
				++$at;
				continue;
			}

			/*
			 * Ensure that the script tag terminates to avoid matching on
			 * substrings of a non-match. For example, the sequence
			 * "&lt;script123" should not end a script region even though
			 * "&lt;script" is found within the text.
			 */
			if ( $at + 6 &gt;= $doc_length ) {
				continue;
			}
			$at += 6;
			$c   = $html[ $at ];
			if ( ' ' !== $c &amp;&amp; "\t" !== $c &amp;&amp; "\r" !== $c &amp;&amp; "\n" !== $c &amp;&amp; '/' !== $c &amp;&amp; '&gt;' !== $c ) {
				++$at;
				continue;
			}

			if ( 'escaped' === $state &amp;&amp; ! $is_closing ) {
				$state = 'double-escaped';
				continue;
			}

			if ( 'double-escaped' === $state &amp;&amp; $is_closing ) {
				$state = 'escaped';
				continue;
			}

			if ( $is_closing ) {
				$this-&gt;bytes_already_parsed = $closer_potentially_starts_at;
				$this-&gt;tag_name_starts_at   = $closer_potentially_starts_at;
				if ( $this-&gt;bytes_already_parsed &gt;= $doc_length ) {
					return false;
				}

				while ( $this-&gt;parse_next_attribute() ) {
					continue;
				}

				if ( $this-&gt;bytes_already_parsed &gt;= $doc_length ) {
					$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

					return false;
				}

				if ( '&gt;' === $html[ $this-&gt;bytes_already_parsed ] ) {
					++$this-&gt;bytes_already_parsed;
					return true;
				}
			}

			++$at;
		}

		return false;
	}

	/**
	 * Parses the next tag.
	 *
	 * This will find and start parsing the next tag, including
	 * the opening `&lt;`, the potential closer `/`, and the tag
	 * name. It does not parse the attributes or scan to the
	 * closing `&gt;`; these are left for other methods.
	 *
	 * @since 6.2.0
	 * @since 6.2.1 Support abruptly-closed comments, invalid-tag-closer-comments, and empty elements.
	 *
	 * @return bool Whether a tag was found before the end of the document.
	 */
	private function parse_next_tag(): bool {
		$this-&gt;after_tag();

		$html       = $this-&gt;html;
		$doc_length = strlen( $html );
		$was_at     = $this-&gt;bytes_already_parsed;
		$at         = $was_at;

		while ( $at &lt; $doc_length ) {
			$at = strpos( $html, '&lt;', $at );
			if ( false === $at ) {
				break;
			}

			if ( $at &gt; $was_at ) {
				/*
				 * A "&lt;" normally starts a new HTML tag or syntax token, but in cases where the
				 * following character can't produce a valid token, the "&lt;" is instead treated
				 * as plaintext and the parser should skip over it. This avoids a problem when
				 * following earlier practices of typing emoji with text, e.g. "&lt;3". This
				 * should be a heart, not a tag. It's supposed to be rendered, not hidden.
				 *
				 * At this point the parser checks if this is one of those cases and if it is
				 * will continue searching for the next "&lt;" in search of a token boundary.
				 *
				 * @see https://html.spec.whatwg.org/#tag-open-state
				 */
				if ( 1 !== strspn( $html, '!/?abcdefghijklmnopqrstuvwxyzABCEFGHIJKLMNOPQRSTUVWXYZ', $at + 1, 1 ) ) {
					++$at;
					continue;
				}

				$this-&gt;parser_state         = self::STATE_TEXT_NODE;
				$this-&gt;token_starts_at      = $was_at;
				$this-&gt;token_length         = $at - $was_at;
				$this-&gt;text_starts_at       = $was_at;
				$this-&gt;text_length          = $this-&gt;token_length;
				$this-&gt;bytes_already_parsed = $at;
				return true;
			}

			$this-&gt;token_starts_at = $at;

			if ( $at + 1 &lt; $doc_length &amp;&amp; '/' === $this-&gt;html[ $at + 1 ] ) {
				$this-&gt;is_closing_tag = true;
				++$at;
			} else {
				$this-&gt;is_closing_tag = false;
			}

			/*
			 * HTML tag names must start with [a-zA-Z] otherwise they are not tags.
			 * For example, "&lt;3" is rendered as text, not a tag opener. If at least
			 * one letter follows the "&lt;" then _it is_ a tag, but if the following
			 * character is anything else it _is not a tag_.
			 *
			 * It's not uncommon to find non-tags starting with `&lt;` in an HTML
			 * document, so it's good for performance to make this pre-check before
			 * continuing to attempt to parse a tag name.
			 *
			 * Reference:
			 * * https://html.spec.whatwg.org/multipage/parsing.html#data-state
			 * * https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
			 */
			$tag_name_prefix_length = strspn( $html, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', $at + 1 );
			if ( $tag_name_prefix_length &gt; 0 ) {
				++$at;
				$this-&gt;parser_state         = self::STATE_MATCHED_TAG;
				$this-&gt;tag_name_starts_at   = $at;
				$this-&gt;tag_name_length      = $tag_name_prefix_length + strcspn( $html, " \t\f\r\n/&gt;", $at + $tag_name_prefix_length );
				$this-&gt;bytes_already_parsed = $at + $this-&gt;tag_name_length;
				return true;
			}

			/*
			 * Abort if no tag is found before the end of
			 * the document. There is nothing left to parse.
			 */
			if ( $at + 1 &gt;= $doc_length ) {
				$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

				return false;
			}

			/*
			 * `&lt;!` transitions to markup declaration open state
			 * https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
			 */
			if ( ! $this-&gt;is_closing_tag &amp;&amp; '!' === $html[ $at + 1 ] ) {
				/*
				 * `&lt;!--` transitions to a comment state – apply further comment rules.
				 * https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
				 */
				if ( 0 === substr_compare( $html, '--', $at + 2, 2 ) ) {
					$closer_at = $at + 4;
					// If it's not possible to close the comment then there is nothing more to scan.
					if ( $doc_length &lt;= $closer_at ) {
						$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

						return false;
					}

					// Abruptly-closed empty comments are a sequence of dashes followed by `&gt;`.
					$span_of_dashes = strspn( $html, '-', $closer_at );
					if ( '&gt;' === $html[ $closer_at + $span_of_dashes ] ) {
						/*
						 * @todo When implementing `set_modifiable_text()` ensure that updates to this token
						 *       don't break the syntax for short comments, e.g. `&lt;!---&gt;`. Unlike other comment
						 *       and bogus comment syntax, these leave no clear insertion point for text and
						 *       they need to be modified specially in order to contain text. E.g. to store
						 *       `?` as the modifiable text, the `&lt;!---&gt;` needs to become `&lt;!--?--&gt;`, which
						 *       involves inserting an additional `-` into the token after the modifiable text.
						 */
						$this-&gt;parser_state = self::STATE_COMMENT;
						$this-&gt;comment_type = self::COMMENT_AS_ABRUPTLY_CLOSED_COMMENT;
						$this-&gt;token_length = $closer_at + $span_of_dashes + 1 - $this-&gt;token_starts_at;

						// Only provide modifiable text if the token is long enough to contain it.
						if ( $span_of_dashes &gt;= 2 ) {
							$this-&gt;comment_type   = self::COMMENT_AS_HTML_COMMENT;
							$this-&gt;text_starts_at = $this-&gt;token_starts_at + 4;
							$this-&gt;text_length    = $span_of_dashes - 2;
						}

						$this-&gt;bytes_already_parsed = $closer_at + $span_of_dashes + 1;
						return true;
					}

					/*
					 * Comments may be closed by either a --&gt; or an invalid --!&gt;.
					 * The first occurrence closes the comment.
					 *
					 * See https://html.spec.whatwg.org/#parse-error-incorrectly-closed-comment
					 */
					--$closer_at; // Pre-increment inside condition below reduces risk of accidental infinite looping.
					while ( ++$closer_at &lt; $doc_length ) {
						$closer_at = strpos( $html, '--', $closer_at );
						if ( false === $closer_at ) {
							$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

							return false;
						}

						if ( $closer_at + 2 &lt; $doc_length &amp;&amp; '&gt;' === $html[ $closer_at + 2 ] ) {
							$this-&gt;parser_state         = self::STATE_COMMENT;
							$this-&gt;comment_type         = self::COMMENT_AS_HTML_COMMENT;
							$this-&gt;token_length         = $closer_at + 3 - $this-&gt;token_starts_at;
							$this-&gt;text_starts_at       = $this-&gt;token_starts_at + 4;
							$this-&gt;text_length          = $closer_at - $this-&gt;text_starts_at;
							$this-&gt;bytes_already_parsed = $closer_at + 3;
							return true;
						}

						if (
							$closer_at + 3 &lt; $doc_length &amp;&amp;
							'!' === $html[ $closer_at + 2 ] &amp;&amp;
							'&gt;' === $html[ $closer_at + 3 ]
						) {
							$this-&gt;parser_state         = self::STATE_COMMENT;
							$this-&gt;comment_type         = self::COMMENT_AS_HTML_COMMENT;
							$this-&gt;token_length         = $closer_at + 4 - $this-&gt;token_starts_at;
							$this-&gt;text_starts_at       = $this-&gt;token_starts_at + 4;
							$this-&gt;text_length          = $closer_at - $this-&gt;text_starts_at;
							$this-&gt;bytes_already_parsed = $closer_at + 4;
							return true;
						}
					}
				}

				/*
				 * `&lt;!DOCTYPE` transitions to DOCTYPE state – skip to the nearest &gt;
				 * These are ASCII-case-insensitive.
				 * https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
				 */
				if (
					$doc_length &gt; $at + 8 &amp;&amp;
					( 'D' === $html[ $at + 2 ] || 'd' === $html[ $at + 2 ] ) &amp;&amp;
					( 'O' === $html[ $at + 3 ] || 'o' === $html[ $at + 3 ] ) &amp;&amp;
					( 'C' === $html[ $at + 4 ] || 'c' === $html[ $at + 4 ] ) &amp;&amp;
					( 'T' === $html[ $at + 5 ] || 't' === $html[ $at + 5 ] ) &amp;&amp;
					( 'Y' === $html[ $at + 6 ] || 'y' === $html[ $at + 6 ] ) &amp;&amp;
					( 'P' === $html[ $at + 7 ] || 'p' === $html[ $at + 7 ] ) &amp;&amp;
					( 'E' === $html[ $at + 8 ] || 'e' === $html[ $at + 8 ] )
				) {
					$closer_at = strpos( $html, '&gt;', $at + 9 );
					if ( false === $closer_at ) {
						$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

						return false;
					}

					$this-&gt;parser_state         = self::STATE_DOCTYPE;
					$this-&gt;token_length         = $closer_at + 1 - $this-&gt;token_starts_at;
					$this-&gt;text_starts_at       = $this-&gt;token_starts_at + 9;
					$this-&gt;text_length          = $closer_at - $this-&gt;text_starts_at;
					$this-&gt;bytes_already_parsed = $closer_at + 1;
					return true;
				}

				if (
					'html' !== $this-&gt;parsing_namespace &amp;&amp;
					strlen( $html ) &gt; $at + 8 &amp;&amp;
					'[' === $html[ $at + 2 ] &amp;&amp;
					'C' === $html[ $at + 3 ] &amp;&amp;
					'D' === $html[ $at + 4 ] &amp;&amp;
					'A' === $html[ $at + 5 ] &amp;&amp;
					'T' === $html[ $at + 6 ] &amp;&amp;
					'A' === $html[ $at + 7 ] &amp;&amp;
					'[' === $html[ $at + 8 ]
				) {
					$closer_at = strpos( $html, ']]&gt;', $at + 9 );
					if ( false === $closer_at ) {
						$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

						return false;
					}

					$this-&gt;parser_state         = self::STATE_CDATA_NODE;
					$this-&gt;text_starts_at       = $at + 9;
					$this-&gt;text_length          = $closer_at - $this-&gt;text_starts_at;
					$this-&gt;token_length         = $closer_at + 3 - $this-&gt;token_starts_at;
					$this-&gt;bytes_already_parsed = $closer_at + 3;
					return true;
				}

				/*
				 * Anything else here is an incorrectly-opened comment and transitions
				 * to the bogus comment state - skip to the nearest &gt;. If no closer is
				 * found then the HTML was truncated inside the markup declaration.
				 */
				$closer_at = strpos( $html, '&gt;', $at + 1 );
				if ( false === $closer_at ) {
					$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

					return false;
				}

				$this-&gt;parser_state         = self::STATE_COMMENT;
				$this-&gt;comment_type         = self::COMMENT_AS_INVALID_HTML;
				$this-&gt;token_length         = $closer_at + 1 - $this-&gt;token_starts_at;
				$this-&gt;text_starts_at       = $this-&gt;token_starts_at + 2;
				$this-&gt;text_length          = $closer_at - $this-&gt;text_starts_at;
				$this-&gt;bytes_already_parsed = $closer_at + 1;

				/*
				 * Identify nodes that would be CDATA if HTML had CDATA sections.
				 *
				 * This section must occur after identifying the bogus comment end
				 * because in an HTML parser it will span to the nearest `&gt;`, even
				 * if there's no `]]&gt;` as would be required in an XML document. It
				 * is therefore not possible to parse a CDATA section containing
				 * a `&gt;` in the HTML syntax.
				 *
				 * Inside foreign elements there is a discrepancy between browsers
				 * and the specification on this.
				 *
				 * @todo Track whether the Tag Processor is inside a foreign element
				 *       and require the proper closing `]]&gt;` in those cases.
				 */
				if (
					$this-&gt;token_length &gt;= 10 &amp;&amp;
					'[' === $html[ $this-&gt;token_starts_at + 2 ] &amp;&amp;
					'C' === $html[ $this-&gt;token_starts_at + 3 ] &amp;&amp;
					'D' === $html[ $this-&gt;token_starts_at + 4 ] &amp;&amp;
					'A' === $html[ $this-&gt;token_starts_at + 5 ] &amp;&amp;
					'T' === $html[ $this-&gt;token_starts_at + 6 ] &amp;&amp;
					'A' === $html[ $this-&gt;token_starts_at + 7 ] &amp;&amp;
					'[' === $html[ $this-&gt;token_starts_at + 8 ] &amp;&amp;
					']' === $html[ $closer_at - 1 ] &amp;&amp;
					']' === $html[ $closer_at - 2 ]
				) {
					$this-&gt;parser_state    = self::STATE_COMMENT;
					$this-&gt;comment_type    = self::COMMENT_AS_CDATA_LOOKALIKE;
					$this-&gt;text_starts_at += 7;
					$this-&gt;text_length    -= 9;
				}

				return true;
			}

			/*
			 * &lt;/&gt; is a missing end tag name, which is ignored.
			 *
			 * This was also known as the "presumptuous empty tag"
			 * in early discussions as it was proposed to close
			 * the nearest previous opening tag.
			 *
			 * See https://html.spec.whatwg.org/#parse-error-missing-end-tag-name
			 */
			if ( '&gt;' === $html[ $at + 1 ] ) {
				// `&lt;&gt;` is interpreted as plaintext.
				if ( ! $this-&gt;is_closing_tag ) {
					++$at;
					continue;
				}

				$this-&gt;parser_state         = self::STATE_PRESUMPTUOUS_TAG;
				$this-&gt;token_length         = $at + 2 - $this-&gt;token_starts_at;
				$this-&gt;bytes_already_parsed = $at + 2;
				return true;
			}

			/*
			 * `&lt;?` transitions to a bogus comment state – skip to the nearest &gt;
			 * See https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
			 */
			if ( ! $this-&gt;is_closing_tag &amp;&amp; '?' === $html[ $at + 1 ] ) {
				$closer_at = strpos( $html, '&gt;', $at + 2 );
				if ( false === $closer_at ) {
					$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

					return false;
				}

				$this-&gt;parser_state         = self::STATE_COMMENT;
				$this-&gt;comment_type         = self::COMMENT_AS_INVALID_HTML;
				$this-&gt;token_length         = $closer_at + 1 - $this-&gt;token_starts_at;
				$this-&gt;text_starts_at       = $this-&gt;token_starts_at + 2;
				$this-&gt;text_length          = $closer_at - $this-&gt;text_starts_at;
				$this-&gt;bytes_already_parsed = $closer_at + 1;

				/*
				 * Identify a Processing Instruction node were HTML to have them.
				 *
				 * This section must occur after identifying the bogus comment end
				 * because in an HTML parser it will span to the nearest `&gt;`, even
				 * if there's no `?&gt;` as would be required in an XML document. It
				 * is therefore not possible to parse a Processing Instruction node
				 * containing a `&gt;` in the HTML syntax.
				 *
				 * XML allows for more target names, but this code only identifies
				 * those with ASCII-representable target names. This means that it
				 * may identify some Processing Instruction nodes as bogus comments,
				 * but it will not misinterpret the HTML structure. By limiting the
				 * identification to these target names the Tag Processor can avoid
				 * the need to start parsing UTF-8 sequences.
				 *
				 * &gt; NameStartChar ::= ":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
				 *                     [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] |
				 *                     [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |
				 *                     [#x10000-#xEFFFF]
				 * &gt; NameChar      ::= NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
				 *
				 * @todo Processing instruction nodes in SGML may contain any kind of markup. XML defines a
				 *       special case with `&lt;?xml ... ?&gt;` syntax, but the `?` is part of the bogus comment.
				 *
				 * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-PITarget
				 */
				if ( $this-&gt;token_length &gt;= 5 &amp;&amp; '?' === $html[ $closer_at - 1 ] ) {
					$comment_text     = substr( $html, $this-&gt;token_starts_at + 2, $this-&gt;token_length - 4 );
					$pi_target_length = strspn( $comment_text, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ:_' );

					if ( 0 &lt; $pi_target_length ) {
						$pi_target_length += strspn( $comment_text, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:_-.', $pi_target_length );

						$this-&gt;comment_type       = self::COMMENT_AS_PI_NODE_LOOKALIKE;
						$this-&gt;tag_name_starts_at = $this-&gt;token_starts_at + 2;
						$this-&gt;tag_name_length    = $pi_target_length;
						$this-&gt;text_starts_at    += $pi_target_length;
						$this-&gt;text_length       -= $pi_target_length + 1;
					}
				}

				return true;
			}

			/*
			 * If a non-alpha starts the tag name in a tag closer it's a comment.
			 * Find the first `&gt;`, which closes the comment.
			 *
			 * This parser classifies these particular comments as special "funky comments"
			 * which are made available for further processing.
			 *
			 * See https://html.spec.whatwg.org/#parse-error-invalid-first-character-of-tag-name
			 */
			if ( $this-&gt;is_closing_tag ) {
				// No chance of finding a closer.
				if ( $at + 3 &gt; $doc_length ) {
					$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

					return false;
				}

				$closer_at = strpos( $html, '&gt;', $at + 2 );
				if ( false === $closer_at ) {
					$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

					return false;
				}

				$this-&gt;parser_state         = self::STATE_FUNKY_COMMENT;
				$this-&gt;token_length         = $closer_at + 1 - $this-&gt;token_starts_at;
				$this-&gt;text_starts_at       = $this-&gt;token_starts_at + 2;
				$this-&gt;text_length          = $closer_at - $this-&gt;text_starts_at;
				$this-&gt;bytes_already_parsed = $closer_at + 1;
				return true;
			}

			++$at;
		}

		/*
		 * This does not imply an incomplete parse; it indicates that there
		 * can be nothing left in the document other than a #text node.
		 */
		$this-&gt;parser_state         = self::STATE_TEXT_NODE;
		$this-&gt;token_starts_at      = $was_at;
		$this-&gt;token_length         = $doc_length - $was_at;
		$this-&gt;text_starts_at       = $was_at;
		$this-&gt;text_length          = $this-&gt;token_length;
		$this-&gt;bytes_already_parsed = $doc_length;
		return true;
	}

	/**
	 * Parses the next attribute.
	 *
	 * @since 6.2.0
	 *
	 * @return bool Whether an attribute was found before the end of the document.
	 */
	private function parse_next_attribute(): bool {
		$doc_length = strlen( $this-&gt;html );

		// Skip whitespace and slashes.
		$this-&gt;bytes_already_parsed += strspn( $this-&gt;html, " \t\f\r\n/", $this-&gt;bytes_already_parsed );
		if ( $this-&gt;bytes_already_parsed &gt;= $doc_length ) {
			$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

			return false;
		}

		/*
		 * Treat the equal sign as a part of the attribute
		 * name if it is the first encountered byte.
		 *
		 * @see https://html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state
		 */
		$name_length = '=' === $this-&gt;html[ $this-&gt;bytes_already_parsed ]
			? 1 + strcspn( $this-&gt;html, "=/&gt; \t\f\r\n", $this-&gt;bytes_already_parsed + 1 )
			: strcspn( $this-&gt;html, "=/&gt; \t\f\r\n", $this-&gt;bytes_already_parsed );

		// No attribute, just tag closer.
		if ( 0 === $name_length || $this-&gt;bytes_already_parsed + $name_length &gt;= $doc_length ) {
			return false;
		}

		$attribute_start             = $this-&gt;bytes_already_parsed;
		$attribute_name              = substr( $this-&gt;html, $attribute_start, $name_length );
		$this-&gt;bytes_already_parsed += $name_length;
		if ( $this-&gt;bytes_already_parsed &gt;= $doc_length ) {
			$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

			return false;
		}

		$this-&gt;skip_whitespace();
		if ( $this-&gt;bytes_already_parsed &gt;= $doc_length ) {
			$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

			return false;
		}

		$has_value = '=' === $this-&gt;html[ $this-&gt;bytes_already_parsed ];
		if ( $has_value ) {
			++$this-&gt;bytes_already_parsed;
			$this-&gt;skip_whitespace();
			if ( $this-&gt;bytes_already_parsed &gt;= $doc_length ) {
				$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

				return false;
			}

			switch ( $this-&gt;html[ $this-&gt;bytes_already_parsed ] ) {
				case "'":
				case '"':
					$quote                      = $this-&gt;html[ $this-&gt;bytes_already_parsed ];
					$value_start                = $this-&gt;bytes_already_parsed + 1;
					$end_quote_at               = strpos( $this-&gt;html, $quote, $value_start );
					$end_quote_at               = false === $end_quote_at ? $doc_length : $end_quote_at;
					$value_length               = $end_quote_at - $value_start;
					$attribute_end              = $end_quote_at + 1;
					$this-&gt;bytes_already_parsed = $attribute_end;
					break;

				default:
					$value_start                = $this-&gt;bytes_already_parsed;
					$value_length               = strcspn( $this-&gt;html, "&gt; \t\f\r\n", $value_start );
					$attribute_end              = $value_start + $value_length;
					$this-&gt;bytes_already_parsed = $attribute_end;
			}
		} else {
			$value_start   = $this-&gt;bytes_already_parsed;
			$value_length  = 0;
			$attribute_end = $attribute_start + $name_length;
		}

		if ( $attribute_end &gt;= $doc_length ) {
			$this-&gt;parser_state = self::STATE_INCOMPLETE_INPUT;

			return false;
		}

		if ( $this-&gt;is_closing_tag ) {
			return true;
		}

		/*
		 * &gt; There must never be two or more attributes on
		 * &gt; the same start tag whose names are an ASCII
		 * &gt; case-insensitive match for each other.
		 *     - HTML 5 spec
		 *
		 * @see https://html.spec.whatwg.org/multipage/syntax.html#attributes-2:ascii-case-insensitive
		 */
		$comparable_name = strtolower( $attribute_name );

		// If an attribute is listed many times, only use the first declaration and ignore the rest.
		if ( ! isset( $this-&gt;attributes[ $comparable_name ] ) ) {
			$this-&gt;attributes[ $comparable_name ] = new WP_HTML_Attribute_Token(
				$attribute_name,
				$value_start,
				$value_length,
				$attribute_start,
				$attribute_end - $attribute_start,
				! $has_value
			);

			return true;
		}

		/*
		 * Track the duplicate attributes so if we remove it, all disappear together.
		 *
		 * While `$this-&gt;duplicated_attributes` could always be stored as an `array()`,
		 * which would simplify the logic here, storing a `null` and only allocating
		 * an array when encountering duplicates avoids needless allocations in the
		 * normative case of parsing tags with no duplicate attributes.
		 */
		$duplicate_span = new WP_HTML_Span( $attribute_start, $attribute_end - $attribute_start );
		if ( null === $this-&gt;duplicate_attributes ) {
			$this-&gt;duplicate_attributes = array( $comparable_name =&gt; array( $duplicate_span ) );
		} elseif ( ! isset( $this-&gt;duplicate_attributes[ $comparable_name ] ) ) {
			$this-&gt;duplicate_attributes[ $comparable_name ] = array( $duplicate_span );
		} else {
			$this-&gt;duplicate_attributes[ $comparable_name ][] = $duplicate_span;
		}

		return true;
	}

	/**
	 * Move the internal cursor past any immediate successive whitespace.
	 *
	 * @since 6.2.0
	 */
	private function skip_whitespace(): void {
		$this-&gt;bytes_already_parsed += strspn( $this-&gt;html, " \t\f\r\n", $this-&gt;bytes_already_parsed );
	}

	/**
	 * Applies attribute updates and cleans up once a tag is fully parsed.
	 *
	 * @since 6.2.0
	 */
	private function after_tag(): void {
		/*
		 * There could be lexical updates enqueued for an attribute that
		 * also exists on the next tag. In order to avoid conflating the
		 * attributes across the two tags, lexical updates with names
		 * need to be flushed to raw lexical updates.
		 */
		$this-&gt;class_name_updates_to_attributes_updates();

		/*
		 * Purge updates if there are too many. The actual count isn't
		 * scientific, but a few values from 100 to a few thousand were
		 * tests to find a practically-useful limit.
		 *
		 * If the update queue grows too big, then the Tag Processor
		 * will spend more time iterating through them and lose the
		 * efficiency gains of deferring applying them.
		 */
		if ( 1000 &lt; count( $this-&gt;lexical_updates ) ) {
			$this-&gt;get_updated_html();
		}

		foreach ( $this-&gt;lexical_updates as $name =&gt; $update ) {
			/*
			 * Any updates appearing after the cursor should be applied
			 * before proceeding, otherwise they may be overlooked.
			 */
			if ( $update-&gt;start &gt;= $this-&gt;bytes_already_parsed ) {
				$this-&gt;get_updated_html();
				break;
			}

			if ( is_int( $name ) ) {
				continue;
			}

			$this-&gt;lexical_updates[] = $update;
			unset( $this-&gt;lexical_updates[ $name ] );
		}

		$this-&gt;token_starts_at          = null;
		$this-&gt;token_length             = null;
		$this-&gt;tag_name_starts_at       = null;
		$this-&gt;tag_name_length          = null;
		$this-&gt;text_starts_at           = 0;
		$this-&gt;text_length              = 0;
		$this-&gt;is_closing_tag           = null;
		$this-&gt;attributes               = array();
		$this-&gt;comment_type             = null;
		$this-&gt;text_node_classification = self::TEXT_IS_GENERIC;
		$this-&gt;duplicate_attributes     = null;
	}

	/**
	 * Converts class name updates into tag attributes updates
	 * (they are accumulated in different data formats for performance).
	 *
	 * @since 6.2.0
	 *
	 * @see WP_HTML_Tag_Processor::$lexical_updates
	 * @see WP_HTML_Tag_Processor::$classname_updates
	 */
	private function class_name_updates_to_attributes_updates(): void {
		if ( count( $this-&gt;classname_updates ) === 0 ) {
			return;
		}

		$existing_class = $this-&gt;get_enqueued_attribute_value( 'class' );
		if ( null === $existing_class || true === $existing_class ) {
			$existing_class = '';
		}

		if ( false === $existing_class &amp;&amp; isset( $this-&gt;attributes['class'] ) ) {
			$existing_class = substr(
				$this-&gt;html,
				$this-&gt;attributes['class']-&gt;value_starts_at,
				$this-&gt;attributes['class']-&gt;value_length
			);
		}

		if ( false === $existing_class ) {
			$existing_class = '';
		}

		/**
		 * Updated "class" attribute value.
		 *
		 * This is incrementally built while scanning through the existing class
		 * attribute, skipping removed classes on the way, and then appending
		 * added classes at the end. Only when finished processing will the
		 * value contain the final new value.

		 * @var string $class
		 */
		$class = '';

		/**
		 * Tracks the cursor position in the existing
		 * class attribute value while parsing.
		 *
		 * @var int $at
		 */
		$at = 0;

		/**
		 * Indicates if there's any need to modify the existing class attribute.
		 *
		 * If a call to `add_class()` and `remove_class()` wouldn't impact
		 * the `class` attribute value then there's no need to rebuild it.
		 * For example, when adding a class that's already present or
		 * removing one that isn't.
		 *
		 * This flag enables a performance optimization when none of the enqueued
		 * class updates would impact the `class` attribute; namely, that the
		 * processor can continue without modifying the input document, as if
		 * none of the `add_class()` or `remove_class()` calls had been made.
		 *
		 * This flag is set upon the first change that requires a string update.
		 *
		 * @var bool $modified
		 */
		$modified = false;

		$seen      = array();
		$to_remove = array();
		$is_quirks = self::QUIRKS_MODE === $this-&gt;compat_mode;
		if ( $is_quirks ) {
			foreach ( $this-&gt;classname_updates as $updated_name =&gt; $action ) {
				if ( self::REMOVE_CLASS === $action ) {
					$to_remove[] = strtolower( $updated_name );
				}
			}
		} else {
			foreach ( $this-&gt;classname_updates as $updated_name =&gt; $action ) {
				if ( self::REMOVE_CLASS === $action ) {
					$to_remove[] = $updated_name;
				}
			}
		}

		// Remove unwanted classes by only copying the new ones.
		$existing_class_length = strlen( $existing_class );
		while ( $at &lt; $existing_class_length ) {
			// Skip to the first non-whitespace character.
			$ws_at     = $at;
			$ws_length = strspn( $existing_class, " \t\f\r\n", $ws_at );
			$at       += $ws_length;

			// Capture the class name – it's everything until the next whitespace.
			$name_length = strcspn( $existing_class, " \t\f\r\n", $at );
			if ( 0 === $name_length ) {
				// If no more class names are found then that's the end.
				break;
			}

			$name                  = substr( $existing_class, $at, $name_length );
			$comparable_class_name = $is_quirks ? strtolower( $name ) : $name;
			$at                   += $name_length;

			// If this class is marked for removal, remove it and move on to the next one.
			if ( in_array( $comparable_class_name, $to_remove, true ) ) {
				$modified = true;
				continue;
			}

			// If a class has already been seen then skip it; it should not be added twice.
			if ( in_array( $comparable_class_name, $seen, true ) ) {
				continue;
			}

			$seen[] = $comparable_class_name;

			/*
			 * Otherwise, append it to the new "class" attribute value.
			 *
			 * There are options for handling whitespace between tags.
			 * Preserving the existing whitespace produces fewer changes
			 * to the HTML content and should clarify the before/after
			 * content when debugging the modified output.
			 *
			 * This approach contrasts normalizing the inter-class
			 * whitespace to a single space, which might appear cleaner
			 * in the output HTML but produce a noisier change.
			 */
			if ( '' !== $class ) {
				$class .= substr( $existing_class, $ws_at, $ws_length );
			}
			$class .= $name;
		}

		// Add new classes by appending those which haven't already been seen.
		foreach ( $this-&gt;classname_updates as $name =&gt; $operation ) {
			$comparable_name = $is_quirks ? strtolower( $name ) : $name;
			if ( self::ADD_CLASS === $operation &amp;&amp; ! in_array( $comparable_name, $seen, true ) ) {
				$modified = true;

				$class .= strlen( $class ) &gt; 0 ? ' ' : '';
				$class .= $name;
			}
		}

		$this-&gt;classname_updates = array();
		if ( ! $modified ) {
			return;
		}

		if ( strlen( $class ) &gt; 0 ) {
			$this-&gt;set_attribute( 'class', $class );
		} else {
			$this-&gt;remove_attribute( 'class' );
		}
	}

	/**
	 * Applies attribute updates to HTML document.
	 *
	 * @since 6.2.0
	 * @since 6.2.1 Accumulates shift for internal cursor and passed pointer.
	 * @since 6.3.0 Invalidate any bookmarks whose targets are overwritten.
	 *
	 * @param int $shift_this_point Accumulate and return shift for this position.
	 * @return int How many bytes the given pointer moved in response to the updates.
	 */
	private function apply_attributes_updates( int $shift_this_point ): int {
		if ( ! count( $this-&gt;lexical_updates ) ) {
			return 0;
		}

		$accumulated_shift_for_given_point = 0;

		/*
		 * Attribute updates can be enqueued in any order but updates
		 * to the document must occur in lexical order; that is, each
		 * replacement must be made before all others which follow it
		 * at later string indices in the input document.
		 *
		 * Sorting avoid making out-of-order replacements which
		 * can lead to mangled output, partially-duplicated
		 * attributes, and overwritten attributes.
		 */
		usort( $this-&gt;lexical_updates, array( self::class, 'sort_start_ascending' ) );

		$bytes_already_copied = 0;
		$output_buffer        = '';
		foreach ( $this-&gt;lexical_updates as $diff ) {
			$shift = strlen( $diff-&gt;text ) - $diff-&gt;length;

			// Adjust the cursor position by however much an update affects it.
			if ( $diff-&gt;start &lt; $this-&gt;bytes_already_parsed ) {
				$this-&gt;bytes_already_parsed += $shift;
			}

			// Accumulate shift of the given pointer within this function call.
			if ( $diff-&gt;start &lt; $shift_this_point ) {
				$accumulated_shift_for_given_point += $shift;
			}

			$output_buffer       .= substr( $this-&gt;html, $bytes_already_copied, $diff-&gt;start - $bytes_already_copied );
			$output_buffer       .= $diff-&gt;text;
			$bytes_already_copied = $diff-&gt;start + $diff-&gt;length;
		}

		$this-&gt;html = $output_buffer . substr( $this-&gt;html, $bytes_already_copied );

		/*
		 * Adjust bookmark locations to account for how the text
		 * replacements adjust offsets in the input document.
		 */
		foreach ( $this-&gt;bookmarks as $bookmark_name =&gt; $bookmark ) {
			$bookmark_end = $bookmark-&gt;start + $bookmark-&gt;length;

			/*
			 * Each lexical update which appears before the bookmark's endpoints
			 * might shift the offsets for those endpoints. Loop through each change
			 * and accumulate the total shift for each bookmark, then apply that
			 * shift after tallying the full delta.
			 */
			$head_delta = 0;
			$tail_delta = 0;

			foreach ( $this-&gt;lexical_updates as $diff ) {
				$diff_end = $diff-&gt;start + $diff-&gt;length;

				if ( $bookmark-&gt;start &lt; $diff-&gt;start &amp;&amp; $bookmark_end &lt; $diff-&gt;start ) {
					break;
				}

				if ( $bookmark-&gt;start &gt;= $diff-&gt;start &amp;&amp; $bookmark_end &lt; $diff_end ) {
					$this-&gt;release_bookmark( $bookmark_name );
					continue 2;
				}

				$delta = strlen( $diff-&gt;text ) - $diff-&gt;length;

				if ( $bookmark-&gt;start &gt;= $diff-&gt;start ) {
					$head_delta += $delta;
				}

				if ( $bookmark_end &gt;= $diff_end ) {
					$tail_delta += $delta;
				}
			}

			$bookmark-&gt;start  += $head_delta;
			$bookmark-&gt;length += $tail_delta - $head_delta;
		}

		$this-&gt;lexical_updates = array();

		return $accumulated_shift_for_given_point;
	}

	/**
	 * Checks whether a bookmark with the given name exists.
	 *
	 * @since 6.3.0
	 *
	 * @param string $bookmark_name Name to identify a bookmark that potentially exists.
	 * @return bool Whether that bookmark exists.
	 */
	public function has_bookmark( $bookmark_name ): bool {
		return array_key_exists( $bookmark_name, $this-&gt;bookmarks );
	}

	/**
	 * Move the internal cursor in the Tag Processor to a given bookmark's location.
	 *
	 * In order to prevent accidental infinite loops, there's a
	 * maximum limit on the number of times seek() can be called.
	 *
	 * @since 6.2.0
	 *
	 * @param string $bookmark_name Jump to the place in the document identified by this bookmark name.
	 * @return bool Whether the internal cursor was successfully moved to the bookmark's location.
	 */
	public function seek( $bookmark_name ): bool {
		if ( ! array_key_exists( $bookmark_name, $this-&gt;bookmarks ) ) {
			_doing_it_wrong(
				__METHOD__,
				__( 'Unknown bookmark name.' ),
				'6.2.0'
			);
			return false;
		}

		if ( ++$this-&gt;seek_count &gt; static::MAX_SEEK_OPS ) {
			_doing_it_wrong(
				__METHOD__,
				__( 'Too many calls to seek() - this can lead to performance issues.' ),
				'6.2.0'
			);
			return false;
		}

		// Flush out any pending updates to the document.
		$this-&gt;get_updated_html();

		// Point this tag processor before the sought tag opener and consume it.
		$this-&gt;bytes_already_parsed = $this-&gt;bookmarks[ $bookmark_name ]-&gt;start;
		$this-&gt;parser_state         = self::STATE_READY;
		return $this-&gt;next_token();
	}

	/**
	 * Compare two WP_HTML_Text_Replacement objects.
	 *
	 * @since 6.2.0
	 *
	 * @param WP_HTML_Text_Replacement $a First attribute update.
	 * @param WP_HTML_Text_Replacement $b Second attribute update.
	 * @return int Comparison value for string order.
	 */
	private static function sort_start_ascending( WP_HTML_Text_Replacement $a, WP_HTML_Text_Replacement $b ): int {
		$by_start = $a-&gt;start - $b-&gt;start;
		if ( 0 !== $by_start ) {
			return $by_start;
		}

		$by_text = isset( $a-&gt;text, $b-&gt;text ) ? strcmp( $a-&gt;text, $b-&gt;text ) : 0;
		if ( 0 !== $by_text ) {
			return $by_text;
		}

		/*
		 * This code should be unreachable, because it implies the two replacements
		 * start at the same location and contain the same text.
		 */
		return $a-&gt;length - $b-&gt;length;
	}

	/**
	 * Return the enqueued value for a given attribute, if one exists.
	 *
	 * Enqueued updates can take different data types:
	 *  - If an update is enqueued and is boolean, the return will be `true`
	 *  - If an update is otherwise enqueued, the return will be the string value of that update.
	 *  - If an attribute is enqueued to be removed, the return will be `null` to indicate that.
	 *  - If no updates are enqueued, the return will be `false` to differentiate from "removed."
	 *
	 * @since 6.2.0
	 *
	 * @param string $comparable_name The attribute name in its comparable form.
	 * @return string|boolean|null Value of enqueued update if present, otherwise false.
	 */
	private function get_enqueued_attribute_value( string $comparable_name ) {
		if ( self::STATE_MATCHED_TAG !== $this-&gt;parser_state ) {
			return false;
		}

		if ( ! isset( $this-&gt;lexical_updates[ $comparable_name ] ) ) {
			return false;
		}

		$enqueued_text = $this-&gt;lexical_updates[ $comparable_name ]-&gt;text;

		// Removed attributes erase the entire span.
		if ( '' === $enqueued_text ) {
			return null;
		}

		/*
		 * Boolean attribute updates are just the attribute name without a corresponding value.
		 *
		 * This value might differ from the given comparable name in that there could be leading
		 * or trailing whitespace, and that the casing follows the name given in `set_attribute`.
		 *
		 * Example:
		 *
		 *     $p-&gt;set_attribute( 'data-TEST-id', 'update' );
		 *     'update' === $p-&gt;get_enqueued_attribute_value( 'data-test-id' );
		 *
		 * Detect this difference based on the absence of the `=`, which _must_ exist in any
		 * attribute containing a value, e.g. `&lt;input type="text" enabled /&gt;`.
		 *                                            ¹           ²
		 *                                       1. Attribute with a string value.
		 *                                       2. Boolean attribute whose value is `true`.
		 */
		$equals_at = strpos( $enqueued_text, '=' );
		if ( false === $equals_at ) {
			return true;
		}

		/*
		 * Finally, a normal update's value will appear after the `=` and
		 * be double-quoted, as performed incidentally by `set_attribute`.
		 *
		 * e.g. `type="text"`
		 *           ¹²    ³
		 *        1. Equals is here.
		 *        2. Double-quoting starts one after the equals sign.
		 *        3. Double-quoting ends at the last character in the update.
		 */
		$enqueued_value = substr( $enqueued_text, $equals_at + 2, -1 );
		return WP_HTML_Decoder::decode_attribute( $enqueued_value );
	}

	/**
	 * Returns the value of a requested attribute from a matched tag opener if that attribute exists.
	 *
	 * Example:
	 *
	 *     $p = new WP_HTML_Tag_Processor( '&lt;div enabled class="test" data-test-id="14"&gt;Test&lt;/div&gt;' );
	 *     $p-&gt;next_tag( array( 'class_name' =&gt; 'test' ) ) === true;
	 *     $p-&gt;get_attribute( 'data-test-id' ) === '14';
	 *     $p-&gt;get_attribute( 'enabled' ) === true;
	 *     $p-&gt;get_attribute( 'aria-label' ) === null;
	 *
	 *     $p-&gt;next_tag() === false;
	 *     $p-&gt;get_attribute( 'class' ) === null;
	 *
	 * @since 6.2.0
	 *
	 * @param string $name Name of attribute whose value is requested.
	 * @return string|true|null Value of attribute or `null` if not available. Boolean attributes return `true`.
	 */
	public function get_attribute( $name ) {
		if ( self::STATE_MATCHED_TAG !== $this-&gt;parser_state ) {
			return null;
		}

		$comparable = strtolower( $name );

		/*
		 * For every attribute other than `class` it's possible to perform a quick check if
		 * there's an enqueued lexical update whose value takes priority over what's found in
		 * the input document.
		 *
		 * The `class` attribute is special though because of the exposed helpers `add_class`
		 * and `remove_class`. These form a builder for the `class` attribute, so an additional
		 * check for enqueued class changes is required in addition to the check for any enqueued
		 * attribute values. If any exist, those enqueued class changes must first be flushed out
		 * into an attribute value update.
		 */
		if ( 'class' === $name ) {
			$this-&gt;class_name_updates_to_attributes_updates();
		}

		// Return any enqueued attribute value updates if they exist.
		$enqueued_value = $this-&gt;get_enqueued_attribute_value( $comparable );
		if ( false !== $enqueued_value ) {
			return $enqueued_value;
		}

		if ( ! isset( $this-&gt;attributes[ $comparable ] ) ) {
			return null;
		}

		$attribute = $this-&gt;attributes[ $comparable ];

		/*
		 * This flag distinguishes an attribute with no value
		 * from an attribute with an empty string value. For
		 * unquoted attributes this could look very similar.
		 * It refers to whether an `=` follows the name.
		 *
		 * e.g. &lt;div boolean-attribute empty-attribute=&gt;&lt;/div&gt;
		 *           ¹                 ²
		 *        1. Attribute `boolean-attribute` is `true`.
		 *        2. Attribute `empty-attribute` is `""`.
		 */
		if ( true === $attribute-&gt;is_true ) {
			return true;
		}

		$raw_value = substr( $this-&gt;html, $attribute-&gt;value_starts_at, $attribute-&gt;value_length );

		return WP_HTML_Decoder::decode_attribute( $raw_value );
	}

	/**
	 * Gets lowercase names of all attributes matching a given prefix in the current tag.
	 *
	 * Note that matching is case-insensitive. This is in accordance with the spec:
	 *
	 * &gt; There must never be two or more attributes on
	 * &gt; the same start tag whose names are an ASCII
	 * &gt; case-insensitive match for each other.
	 *     - HTML 5 spec
	 *
	 * Example:
	 *
	 *     $p = new WP_HTML_Tag_Processor( '&lt;div data-ENABLED class="test" DATA-test-id="14"&gt;Test&lt;/div&gt;' );
	 *     $p-&gt;next_tag( array( 'class_name' =&gt; 'test' ) ) === true;
	 *     $p-&gt;get_attribute_names_with_prefix( 'data-' ) === array( 'data-enabled', 'data-test-id' );
	 *
	 *     $p-&gt;next_tag() === false;
	 *     $p-&gt;get_attribute_names_with_prefix( 'data-' ) === null;
	 *
	 * @since 6.2.0
	 *
	 * @see https://html.spec.whatwg.org/multipage/syntax.html#attributes-2:ascii-case-insensitive
	 *
	 * @param string $prefix Prefix of requested attribute names.
	 * @return array|null List of attribute names, or `null` when no tag opener is matched.
	 */
	public function get_attribute_names_with_prefix( $prefix ): ?array {
		if (
			self::STATE_MATCHED_TAG !== $this-&gt;parser_state ||
			$this-&gt;is_closing_tag
		) {
			return null;
		}

		$comparable = strtolower( $prefix );

		$matches = array();
		foreach ( array_keys( $this-&gt;attributes ) as $attr_name ) {
			if ( str_starts_with( $attr_name, $comparable ) ) {
				$matches[] = $attr_name;
			}
		}
		return $matches;
	}

	/**
	 * Returns the namespace of the matched token.
	 *
	 * @since 6.7.0
	 *
	 * @return string One of 'html', 'math', or 'svg'.
	 */
	public function get_namespace(): string {
		return $this-&gt;parsing_namespace;
	}

	/**
	 * Returns the uppercase name of the matched tag.
	 *
	 * Example:
	 *
	 *     $p = new WP_HTML_Tag_Processor( '&lt;div class="test"&gt;Test&lt;/div&gt;' );
	 *     $p-&gt;next_tag() === true;
	 *     $p-&gt;get_tag() === 'DIV';
	 *
	 *     $p-&gt;next_tag() === false;
	 *     $p-&gt;get_tag() === null;
	 *
	 * @since 6.2.0
	 *
	 * @return string|null Name of currently matched tag in input HTML, or `null` if none found.
	 */
	public function get_tag(): ?string {
		if ( null === $this-&gt;tag_name_starts_at ) {
			return null;
		}

		$tag_name = substr( $this-&gt;html, $this-&gt;tag_name_starts_at, $this-&gt;tag_name_length );

		if ( self::STATE_MATCHED_TAG === $this-&gt;parser_state ) {
			return strtoupper( $tag_name );
		}

		if (
			self::STATE_COMMENT === $this-&gt;parser_state &amp;&amp;
			self::COMMENT_AS_PI_NODE_LOOKALIKE === $this-&gt;get_comment_type()
		) {
			return $tag_name;
		}

		return null;
	}

	/**
	 * Returns the adjusted tag name for a given token, taking into
	 * account the current parsing context, whether HTML, SVG, or MathML.
	 *
	 * @since 6.7.0
	 *
	 * @return string|null Name of current tag name.
	 */
	public function get_qualified_tag_name(): ?string {
		$tag_name = $this-&gt;get_tag();
		if ( null === $tag_name ) {
			return null;
		}

		if ( 'html' === $this-&gt;get_namespace() ) {
			return $tag_name;
		}

		$lower_tag_name = strtolower( $tag_name );
		if ( 'math' === $this-&gt;get_namespace() ) {
			return $lower_tag_name;
		}

		if ( 'svg' === $this-&gt;get_namespace() ) {
			switch ( $lower_tag_name ) {
				case 'altglyph':
					return 'altGlyph';

				case 'altglyphdef':
					return 'altGlyphDef';

				case 'altglyphitem':
					return 'altGlyphItem';

				case 'animatecolor':
					return 'animateColor';

				case 'animatemotion':
					return 'animateMotion';

				case 'animatetransform':
					return 'animateTransform';

				case 'clippath':
					return 'clipPath';

				case 'feblend':
					return 'feBlend';

				case 'fecolormatrix':
					return 'feColorMatrix';

				case 'fecomponenttransfer':
					return 'feComponentTransfer';

				case 'fecomposite':
					return 'feComposite';

				case 'feconvolvematrix':
					return 'feConvolveMatrix';

				case 'fediffuselighting':
					return 'feDiffuseLighting';

				case 'fedisplacementmap':
					return 'feDisplacementMap';

				case 'fedistantlight':
					return 'feDistantLight';

				case 'fedropshadow':
					return 'feDropShadow';

				case 'feflood':
					return 'feFlood';

				case 'fefunca':
					return 'feFuncA';

				case 'fefuncb':
					return 'feFuncB';

				case 'fefuncg':
					return 'feFuncG';

				case 'fefuncr':
					return 'feFuncR';

				case 'fegaussianblur':
					return 'feGaussianBlur';

				case 'feimage':
					return 'feImage';

				case 'femerge':
					return 'feMerge';

				case 'femergenode':
					return 'feMergeNode';

				case 'femorphology':
					return 'feMorphology';

				case 'feoffset':
					return 'feOffset';

				case 'fepointlight':
					return 'fePointLight';

				case 'fespecularlighting':
					return 'feSpecularLighting';

				case 'fespotlight':
					return 'feSpotLight';

				case 'fetile':
					return 'feTile';

				case 'feturbulence':
					return 'feTurbulence';

				case 'foreignobject':
					return 'foreignObject';

				case 'glyphref':
					return 'glyphRef';

				case 'lineargradient':
					return 'linearGradient';

				case 'radialgradient':
					return 'radialGradient';

				case 'textpath':
					return 'textPath';

				default:
					return $lower_tag_name;
			}
		}

		// This unnecessary return prevents tools from inaccurately reporting type errors.
		return $tag_name;
	}

	/**
	 * Returns the adjusted attribute name for a given attribute, taking into
	 * account the current parsing context, whether HTML, SVG, or MathML.
	 *
	 * @since 6.7.0
	 *
	 * @param string $attribute_name Which attribute to adjust.
	 *
	 * @return string|null
	 */
	public function get_qualified_attribute_name( $attribute_name ): ?string {
		if ( self::STATE_MATCHED_TAG !== $this-&gt;parser_state ) {
			return null;
		}

		$namespace  = $this-&gt;get_namespace();
		$lower_name = strtolower( $attribute_name );

		if ( 'math' === $namespace &amp;&amp; 'definitionurl' === $lower_name ) {
			return 'definitionURL';
		}

		if ( 'svg' === $this-&gt;get_namespace() ) {
			switch ( $lower_name ) {
				case 'attributename':
					return 'attributeName';

				case 'attributetype':
					return 'attributeType';

				case 'basefrequency':
					return 'baseFrequency';

				case 'baseprofile':
					return 'baseProfile';

				case 'calcmode':
					return 'calcMode';

				case 'clippathunits':
					return 'clipPathUnits';

				case 'diffuseconstant':
					return 'diffuseConstant';

				case 'edgemode':
					return 'edgeMode';

				case 'filterunits':
					return 'filterUnits';

				case 'glyphref':
					return 'glyphRef';

				case 'gradienttransform':
					return 'gradientTransform';

				case 'gradientunits':
					return 'gradientUnits';

				case 'kernelmatrix':
					return 'kernelMatrix';

				case 'kernelunitlength':
					return 'kernelUnitLength';

				case 'keypoints':
					return 'keyPoints';

				case 'keysplines':
					return 'keySplines';

				case 'keytimes':
					return 'keyTimes';

				case 'lengthadjust':
					return 'lengthAdjust';

				case 'limitingconeangle':
					return 'limitingConeAngle';

				case 'markerheight':
					return 'markerHeight';

				case 'markerunits':
					return 'markerUnits';

				case 'markerwidth':
					return 'markerWidth';

				case 'maskcontentunits':
					return 'maskContentUnits';

				case 'maskunits':
					return 'maskUnits';

				case 'numoctaves':
					return 'numOctaves';

				case 'pathlength':
					return 'pathLength';

				case 'patterncontentunits':
					return 'patternContentUnits';

				case 'patterntransform':
					return 'patternTransform';

				case 'patternunits':
					return 'patternUnits';

				case 'pointsatx':
					return 'pointsAtX';

				case 'pointsaty':
					return 'pointsAtY';

				case 'pointsatz':
					return 'pointsAtZ';

				case 'preservealpha':
					return 'preserveAlpha';

				case 'preserveaspectratio':
					return 'preserveAspectRatio';

				case 'primitiveunits':
					return 'primitiveUnits';

				case 'refx':
					return 'refX';

				case 'refy':
					return 'refY';

				case 'repeatcount':
					return 'repeatCount';

				case 'repeatdur':
					return 'repeatDur';

				case 'requiredextensions':
					return 'requiredExtensions';

				case 'requiredfeatures':
					return 'requiredFeatures';

				case 'specularconstant':
					return 'specularConstant';

				case 'specularexponent':
					return 'specularExponent';

				case 'spreadmethod':
					return 'spreadMethod';

				case 'startoffset':
					return 'startOffset';

				case 'stddeviation':
					return 'stdDeviation';

				case 'stitchtiles':
					return 'stitchTiles';

				case 'surfacescale':
					return 'surfaceScale';

				case 'systemlanguage':
					return 'systemLanguage';

				case 'tablevalues':
					return 'tableValues';

				case 'targetx':
					return 'targetX';

				case 'targety':
					return 'targetY';

				case 'textlength':
					return 'textLength';

				case 'viewbox':
					return 'viewBox';

				case 'viewtarget':
					return 'viewTarget';

				case 'xchannelselector':
					return 'xChannelSelector';

				case 'ychannelselector':
					return 'yChannelSelector';

				case 'zoomandpan':
					return 'zoomAndPan';
			}
		}

		if ( 'html' !== $namespace ) {
			switch ( $lower_name ) {
				case 'xlink:actuate':
					return 'xlink actuate';

				case 'xlink:arcrole':
					return 'xlink arcrole';

				case 'xlink:href':
					return 'xlink href';

				case 'xlink:role':
					return 'xlink role';

				case 'xlink:show':
					return 'xlink show';

				case 'xlink:title':
					return 'xlink title';

				case 'xlink:type':
					return 'xlink type';

				case 'xml:lang':
					return 'xml lang';

				case 'xml:space':
					return 'xml space';

				case 'xmlns':
					return 'xmlns';

				case 'xmlns:xlink':
					return 'xmlns xlink';
			}
		}

		return $attribute_name;
	}

	/**
	 * Indicates if the currently matched tag contains the self-closing flag.
	 *
	 * No HTML elements ought to have the self-closing flag and for those, the self-closing
	 * flag will be ignored. For void elements this is benign because they "self close"
	 * automatically. For non-void HTML elements though problems will appear if someone
	 * intends to use a self-closing element in place of that element with an empty body.
	 * For HTML foreign elements and custom elements the self-closing flag determines if
	 * they self-close or not.
	 *
	 * This function does not determine if a tag is self-closing,
	 * but only if the self-closing flag is present in the syntax.
	 *
	 * @since 6.3.0
	 *
	 * @return bool Whether the currently matched tag contains the self-closing flag.
	 */
	public function has_self_closing_flag(): bool {
		if ( self::STATE_MATCHED_TAG !== $this-&gt;parser_state ) {
			return false;
		}

		/*
		 * The self-closing flag is the solidus at the _end_ of the tag, not the beginning.
		 *
		 * Example:
		 *
		 *     &lt;figure /&gt;
		 *             ^ this appears one character before the end of the closing "&gt;".
		 */
		return '/' === $this-&gt;html[ $this-&gt;token_starts_at + $this-&gt;token_length - 2 ];
	}

	/**
	 * Indicates if the current tag token is a tag closer.
	 *
	 * Example:
	 *
	 *     $p = new WP_HTML_Tag_Processor( '&lt;div&gt;&lt;/div&gt;' );
	 *     $p-&gt;next_tag( array( 'tag_name' =&gt; 'div', 'tag_closers' =&gt; 'visit' ) );
	 *     $p-&gt;is_tag_closer() === false;
	 *
	 *     $p-&gt;next_tag( array( 'tag_name' =&gt; 'div', 'tag_closers' =&gt; 'visit' ) );
	 *     $p-&gt;is_tag_closer() === true;
	 *
	 * @since 6.2.0
	 * @since 6.7.0 Reports all BR tags as opening tags.
	 *
	 * @return bool Whether the current tag is a tag closer.
	 */
	public function is_tag_closer(): bool {
		return (
			self::STATE_MATCHED_TAG === $this-&gt;parser_state &amp;&amp;
			$this-&gt;is_closing_tag &amp;&amp;

			/*
			 * The BR tag can only exist as an opening tag. If something like `&lt;/br&gt;`
			 * appears then the HTML parser will treat it as an opening tag with no
			 * attributes. The BR tag is unique in this way.
			 *
			 * @see https://html.spec.whatwg.org/#parsing-main-inbody
			 */
			'BR' !== $this-&gt;get_tag()
		);
	}

	/**
	 * Indicates the kind of matched token, if any.
	 *
	 * This differs from `get_token_name()` in that it always
	 * returns a static string indicating the type, whereas
	 * `get_token_name()` may return values derived from the
	 * token itself, such as a tag name or processing
	 * instruction tag.
	 *
	 * Possible values:
	 *  - `#tag` when matched on a tag.
	 *  - `#text` when matched on a text node.
	 *  - `#cdata-section` when matched on a CDATA node.
	 *  - `#comment` when matched on a comment.
	 *  - `#doctype` when matched on a DOCTYPE declaration.
	 *  - `#presumptuous-tag` when matched on an empty tag closer.
	 *  - `#funky-comment` when matched on a funky comment.
	 *
	 * @since 6.5.0
	 *
	 * @return string|null What kind of token is matched, or null.
	 */
	public function get_token_type(): ?string {
		switch ( $this-&gt;parser_state ) {
			case self::STATE_MATCHED_TAG:
				return '#tag';

			case self::STATE_DOCTYPE:
				return '#doctype';

			default:
				return $this-&gt;get_token_name();
		}
	}

	/**
	 * Returns the node name represented by the token.
	 *
	 * This matches the DOM API value `nodeName`. Some values
	 * are static, such as `#text` for a text node, while others
	 * are dynamically generated from the token itself.
	 *
	 * Dynamic names:
	 *  - Uppercase tag name for tag matches.
	 *  - `html` for DOCTYPE declarations.
	 *
	 * Note that if the Tag Processor is not matched on a token
	 * then this function will return `null`, either because it
	 * hasn't yet found a token or because it reached the end
	 * of the document without matching a token.
	 *
	 * @since 6.5.0
	 *
	 * @return string|null Name of the matched token.
	 */
	public function get_token_name(): ?string {
		switch ( $this-&gt;parser_state ) {
			case self::STATE_MATCHED_TAG:
				return $this-&gt;get_tag();

			case self::STATE_TEXT_NODE:
				return '#text';

			case self::STATE_CDATA_NODE:
				return '#cdata-section';

			case self::STATE_COMMENT:
				return '#comment';

			case self::STATE_DOCTYPE:
				return 'html';

			case self::STATE_PRESUMPTUOUS_TAG:
				return '#presumptuous-tag';

			case self::STATE_FUNKY_COMMENT:
				return '#funky-comment';
		}

		return null;
	}

	/**
	 * Indicates what kind of comment produced the comment node.
	 *
	 * Because there are different kinds of HTML syntax which produce
	 * comments, the Tag Processor tracks and exposes this as a type
	 * for the comment. Nominally only regular HTML comments exist as
	 * they are commonly known, but a number of unrelated syntax errors
	 * also produce comments.
	 *
	 * @see self::COMMENT_AS_ABRUPTLY_CLOSED_COMMENT
	 * @see self::COMMENT_AS_CDATA_LOOKALIKE
	 * @see self::COMMENT_AS_INVALID_HTML
	 * @see self::COMMENT_AS_HTML_COMMENT
	 * @see self::COMMENT_AS_PI_NODE_LOOKALIKE
	 *
	 * @since 6.5.0
	 *
	 * @return string|null
	 */
	public function get_comment_type(): ?string {
		if ( self::STATE_COMMENT !== $this-&gt;parser_state ) {
			return null;
		}

		return $this-&gt;comment_type;
	}

	/**
	 * Returns the text of a matched comment or null if not on a comment type node.
	 *
	 * This method returns the entire text content of a comment node as it
	 * would appear in the browser.
	 *
	 * This differs from <a href="get_modifiable_text.html">::get_modifiable_text()</a> in that certain comment
	 * types in the HTML API cannot allow their entire comment text content to
	 * be modified. Namely, "bogus comments" of the form `&lt;?not allowed in html&gt;`
	 * will create a comment whose text content starts with `?`. Note that if
	 * that character were modified, it would be possible to change the node
	 * type.
	 *
	 * @since 6.7.0
	 *
	 * @return string|null The comment text as it would appear in the browser or null
	 *                     if not on a comment type node.
	 */
	public function get_full_comment_text(): ?string {
		if ( self::STATE_FUNKY_COMMENT === $this-&gt;parser_state ) {
			return $this-&gt;get_modifiable_text();
		}

		if ( self::STATE_COMMENT !== $this-&gt;parser_state ) {
			return null;
		}

		switch ( $this-&gt;get_comment_type() ) {
			case self::COMMENT_AS_HTML_COMMENT:
			case self::COMMENT_AS_ABRUPTLY_CLOSED_COMMENT:
				return $this-&gt;get_modifiable_text();

			case self::COMMENT_AS_CDATA_LOOKALIKE:
				return "[CDATA[{$this-&gt;get_modifiable_text()}]]";

			case self::COMMENT_AS_PI_NODE_LOOKALIKE:
				return "?{$this-&gt;get_tag()}{$this-&gt;get_modifiable_text()}?";

			/*
			 * This represents "bogus comments state" from HTML tokenization.
			 * This can be entered by `&lt;?` or `&lt;!`, where `?` is included in
			 * the comment text but `!` is not.
			 */
			case self::COMMENT_AS_INVALID_HTML:
				$preceding_character = $this-&gt;html[ $this-&gt;text_starts_at - 1 ];
				$comment_start       = '?' === $preceding_character ? '?' : '';
				return "{$comment_start}{$this-&gt;get_modifiable_text()}";
		}

		return null;
	}

	/**
	 * Subdivides a matched text node, splitting NULL byte sequences and decoded whitespace as
	 * distinct nodes prefixes.
	 *
	 * Note that once anything that's neither a NULL byte nor decoded whitespace is
	 * encountered, then the remainder of the text node is left intact as generic text.
	 *
	 *  - The HTML Processor uses this to apply distinct rules for different kinds of text.
	 *  - Inter-element whitespace can be detected and skipped with this method.
	 *
	 * Text nodes aren't eagerly subdivided because there's no need to split them unless
	 * decisions are being made on NULL byte sequences or whitespace-only text.
	 *
	 * Example:
	 *
	 *     $processor = new WP_HTML_Tag_Processor( "\x00Apples &amp; Oranges" );
	 *     true  === $processor-&gt;next_token();                   // Text is "Apples &amp; Oranges".
	 *     true  === $processor-&gt;subdivide_text_appropriately(); // Text is "".
	 *     true  === $processor-&gt;next_token();                   // Text is "Apples &amp; Oranges".
	 *     false === $processor-&gt;subdivide_text_appropriately();
	 *
	 *     $processor = new WP_HTML_Tag_Processor( "&amp;#x13; \r\n\tMore" );
	 *     true  === $processor-&gt;next_token();                   // Text is "␤ ␤␉More".
	 *     true  === $processor-&gt;subdivide_text_appropriately(); // Text is "␤ ␤␉".
	 *     true  === $processor-&gt;next_token();                   // Text is "More".
	 *     false === $processor-&gt;subdivide_text_appropriately();
	 *
	 * @since 6.7.0
	 *
	 * @return bool Whether the text node was subdivided.
	 */
	public function subdivide_text_appropriately(): bool {
		if ( self::STATE_TEXT_NODE !== $this-&gt;parser_state ) {
			return false;
		}

		$this-&gt;text_node_classification = self::TEXT_IS_GENERIC;

		/*
		 * NULL bytes are treated categorically different than numeric character
		 * references whose number is zero. `&amp;#x00;` is not the same as `"\x00"`.
		 */
		$leading_nulls = strspn( $this-&gt;html, "\x00", $this-&gt;text_starts_at, $this-&gt;text_length );
		if ( $leading_nulls &gt; 0 ) {
			$this-&gt;token_length             = $leading_nulls;
			$this-&gt;text_length              = $leading_nulls;
			$this-&gt;bytes_already_parsed     = $this-&gt;token_starts_at + $leading_nulls;
			$this-&gt;text_node_classification = self::TEXT_IS_NULL_SEQUENCE;
			return true;
		}

		/*
		 * Start a decoding loop to determine the point at which the
		 * text subdivides. This entails raw whitespace bytes and any
		 * character reference that decodes to the same.
		 */
		$at  = $this-&gt;text_starts_at;
		$end = $this-&gt;text_starts_at + $this-&gt;text_length;
		while ( $at &lt; $end ) {
			$skipped = strspn( $this-&gt;html, " \t\f\r\n", $at, $end - $at );
			$at     += $skipped;

			if ( $at &lt; $end &amp;&amp; '&amp;' === $this-&gt;html[ $at ] ) {
				$matched_byte_length = null;
				$replacement         = WP_HTML_Decoder::read_character_reference( 'data', $this-&gt;html, $at, $matched_byte_length );
				if ( isset( $replacement ) &amp;&amp; 1 === strspn( $replacement, " \t\f\r\n" ) ) {
					$at += $matched_byte_length;
					continue;
				}
			}

			break;
		}

		if ( $at &gt; $this-&gt;text_starts_at ) {
			$new_length                     = $at - $this-&gt;text_starts_at;
			$this-&gt;text_length              = $new_length;
			$this-&gt;token_length             = $new_length;
			$this-&gt;bytes_already_parsed     = $at;
			$this-&gt;text_node_classification = self::TEXT_IS_WHITESPACE;
			return true;
		}

		return false;
	}

	/**
	 * Returns the modifiable text for a matched token, or an empty string.
	 *
	 * Modifiable text is text content that may be read and changed without
	 * changing the HTML structure of the document around it. This includes
	 * the contents of `#text` nodes in the HTML as well as the inner
	 * contents of HTML comments, Processing Instructions, and others, even
	 * though these nodes aren't part of a parsed DOM tree. They also contain
	 * the contents of SCRIPT and STYLE tags, of TEXTAREA tags, and of any
	 * other section in an HTML document which cannot contain HTML markup (DATA).
	 *
	 * If a token has no modifiable text then an empty string is returned to
	 * avoid needless crashing or type errors. An empty string does not mean
	 * that a token has modifiable text, and a token with modifiable text may
	 * have an empty string (e.g. a comment with no contents).
	 *
	 * Limitations:
	 *
	 *  - This function will not strip the leading newline appropriately
	 *    after seeking into a LISTING or PRE element. To ensure that the
	 *    newline is treated properly, seek to the LISTING or PRE opening
	 *    tag instead of to the first text node inside the element.
	 *
	 * @since 6.5.0
	 * @since 6.7.0 Replaces NULL bytes (U+0000) and newlines appropriately.
	 *
	 * @return string
	 */
	public function get_modifiable_text(): string {
		$has_enqueued_update = isset( $this-&gt;lexical_updates['modifiable text'] );

		if ( ! $has_enqueued_update &amp;&amp; ( null === $this-&gt;text_starts_at || 0 === $this-&gt;text_length ) ) {
			return '';
		}

		$text = $has_enqueued_update
			? $this-&gt;lexical_updates['modifiable text']-&gt;text
</code></pre>
<p class="wporg-dot-link-list"><a href="https://developer.wordpress.org/reference/files/wp-includes/html-api/class-wp-html-tag-processor.php/">View all references</a> <a href="https://core.trac.wordpress.org/browser/tags/6.7/src/wp-includes/html-api/class-wp-html-tag-processor.php#L411">View on Trac</a> <a href="https://github.com/WordPress/wordpress-develop/blob/6.7/src/wp-includes/html-api/class-wp-html-tag-processor.php#L411-L3565">View on GitHub</a></p></section>  <section><h2 id="changelog">Changelog</h2> <section style="margin-top:var(--wp--preset--spacing--20);"><figure class="wp-block-table "><table>
<thead><tr>
<th scope="col">Version</th>
<th scope="col">Description</th>
</tr></thead>
<tbody>
<tr class="">
<td><a href="https://developer.wordpress.org/reference/since/6.5.0/">6.5.0</a></td>
<td><span class="since-description">Pauses processor when input ends in an incomplete syntax token.<br> Introduces "special" elements which act like void elements, e.g. TITLE, STYLE.<br> Allows scanning through all tokens and processing modifiable text, where applicable.</span></td>
</tr>
<tr class="">
<td><a href="https://developer.wordpress.org/reference/since/6.3.2/">6.3.2</a></td>
<td><span class="since-description">Fix: Skip HTML-like content inside rawtext elements such as STYLE.</span></td>
</tr>
<tr class="">
<td><a href="https://developer.wordpress.org/reference/since/6.2.1/">6.2.1</a></td>
<td><span class="since-description">Fix: Support for various invalid comments; attribute updates are case-insensitive.</span></td>
</tr>
<tr class="">
<td><a href="https://developer.wordpress.org/reference/since/6.2.0/">6.2.0</a></td>
<td>Introduced.</td>
</tr>
</tbody>
</table></figure></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2003&ndash;2024 WordPress Foundation<br>Licensed under the GNU GPLv2+ License.<br>
    <a href="https://developer.wordpress.org/reference/classes/wp_html_tag_processor" class="_attribution-link">https://developer.wordpress.org/reference/classes/wp_html_tag_processor</a>
  </p>
</div>
