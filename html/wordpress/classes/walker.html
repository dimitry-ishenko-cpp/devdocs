<h1 class="wp-block-wporg-code-reference-title">
<span class="keyword">class</span> Walker {}</h1> <section><p>A class for displaying various tree-like structures.</p> </section> <section><h2 id="description">Description</h2> <p>Extend the <a href="walker.html" rel="class">Walker</a> class to use it, see examples below. Child classes do not need to implement all of the abstract methods in the class. The child only needs to implement the methods that are needed.</p> </section> <section><h2 id="more-information">More Information</h2> <p>The <tt><a href="walker.html" rel="class">Walker</a></tt> class was implemented in <a title="Version 2.1" href="https://codex.wordpress.org/Version_2.1">WordPress 2.1</a> to provide developers with a means to traverse tree-like data structures for the purpose of rendering HTML.</p> <h3 id="tree-like-structures">Tree-Like Structures</h3> <p>In terms of web development, a tree-like structure is an array or object with hierarchical data – such that it can be visually represented with a root element and subtrees of children.</p> <p>Examples of WordPress objects with data that are structured in a “tree-like” way include navigational menus, page categories, and breadcrumbs.</p> <h3 id="role-of-walker">Role of Walker</h3> <p><tt><a href="walker.html" rel="class">Walker</a></tt> is an <i><a class="external text" href="http://php.net/manual/en/language.oop5.abstract.php" rel="nofollow">abstract</a></i> class. In order to be useful the class must be <a class="external text" href="http://php.net/manual/en/reflection.extending.php" rel="nofollow">extended</a> and any necessary abstract methods defined (see “Abstract Methods” below for more).</p> <p>The class itself simply “walks” through each node in a tree (e.g. an object or associative array) and executes an abstract function at each node. In order to take an action at one of these nodes, a developer must define those abstract methods within a custom child class.</p> <p>Although the <tt><a href="walker.html" rel="class">Walker</a></tt> class has many uses, one of the most common usages by developers is outputting HTML for custom menus (usually ones that have been defined using the <a title="Appearance Menus Screen" href="https://wordpress.org/support/article/appearance-menus-screen/">Appearance <span aria-hidden="true" class="wp-exclude-emoji"><span aria-hidden="true" class="wp-exclude-emoji">→</span></span> Menus</a> screen in the <a title="Administration Screens" href="https://wordpress.org/support/article/administration-screens/">Administration Screens</a>).</p> <p><b>Abstraction Note:</b> The <tt><a href="walker.html" rel="class">Walker</a></tt> class was created <i>prior</i> to PHP5 and so does <b>not</b> make use of PHP5’s explicit abstraction keywords or features. In this case, the class and its methods are <i>implicitly</i> abstract (PHP4 compatible) and <b>not</b> <i>explicitly</i> abstract (PHP5 compatible). Developers are not required to implement any methods of the class, and may use or override only those methods that are needed. If you chose not to extend a specific abstract method, that method will simply do nothing.</p> <h2 id="methods-properties">Methods &amp; Properties</h2> <p>Please refer source code for the complete lists of methods and properties. Below description may cover some of them.</p> <h3 id="properties">Properties</h3> <p>Note that the properties of the <a href="walker.html" rel="class">Walker</a> class are intended to be set by the extending class and probably should not vary over the lifetime of an instance.</p> <dl> <dt><tt>$db_fields</tt></dt> <dd>
<b>Required</b>. Because <a href="walker.html" rel="class">Walker</a> can take any type of tree object, you need to specify what object properties the <a href="walker.html" rel="class">Walker</a> class should treat as parent id and item id (usually these are the names of database fields, hence the property name). This property <b>must</b> be an associative array with two keys: <code>'parent'</code> and <code>'id'</code>. The value of each key should be the names of the object properties that hold the <i>parent id</i> and <i>item id</i>, respectively.</dd> </dl> <dl> <dt><tt>$tree_type</tt></dt> <dd>Optional. The <a href="walker.html" rel="class">Walker</a> class itself makes no use of this value, although it may be useful to developers. Internally, WordPress’s own extended <a href="walker.html" rel="class">Walker</a> classes will set this to values like ‘category’ or ‘page’.</dd> </dl> <dl> <dt><tt>$max_pages</tt></dt> <dd>Optional. The maximum number of pages walked by the <tt>paged</tt> walker.</dd> </dl> <h2 id="usage">Usage</h2> <p>There are two general use-cases for the <tt><a href="walker.html" rel="class">Walker</a></tt> class.</p> <h3 id="usage-as-a-callback">Usage as a Callback</h3> <p>Some WordPress APIs and functions ( such as <a title="Function Reference/wp nav menu" href="../functions/wp_nav_menu.html">wp_nav_menu()</a> ) allow developers to specify a custom <tt><a href="walker.html" rel="class">Walker</a></tt> class as a callback. This is the most common usage of the <tt><a href="walker.html" rel="class">Walker</a></tt> class by developers.</p> <p>In this scenario, the class is automatically passed a tree of elements. When creating a custom walker for this scenario, you will generally only need to define the <b>abstract</b> methods needed to create the kind of structure you want. Everything else is handled automatically for you.</p> <h3 id="custom-usage">Custom Usage</h3> <p>It is also possible to call your custom <tt><a href="walker.html" rel="class">Walker</a></tt> classes manually. This is particularly useful for plugin developers.</p> <p>In this scenario, you can initiate the walker by calling either the <tt>walk()</tt> or <tt>paged_walk()</tt> method of your child class, with the appropriate parameters.</p> </section> <section><h2 id="methods">Methods</h2> <section style="margin-top:var(--wp--preset--spacing--20);" id="uses"><figure class="wp-block-table "><table>
<thead><tr>
<th scope="col">Name</th>
<th scope="col">Description</th>
</tr></thead>
<tbody>
<tr class="">
<td><a href="walker/display_element.html">Walker::display_element</a></td>
<td>Traverses elements to create list from elements.</td>
</tr>
<tr class="">
<td><a href="walker/end_el.html">Walker::end_el</a></td>
<td>Ends the element output, if needed.</td>
</tr>
<tr class="">
<td><a href="walker/end_lvl.html">Walker::end_lvl</a></td>
<td>Ends the list of after the elements are added.</td>
</tr>
<tr class="">
<td><a href="walker/get_number_of_root_elements.html">Walker::get_number_of_root_elements</a></td>
<td>Calculates the total number of root elements.</td>
</tr>
<tr class="">
<td><a href="walker/paged_walk.html">Walker::paged_walk</a></td>
<td>Produces a page of nested elements.</td>
</tr>
<tr class="">
<td><a href="walker/start_el.html">Walker::start_el</a></td>
<td>Starts the element output.</td>
</tr>
<tr class="">
<td><a href="walker/start_lvl.html">Walker::start_lvl</a></td>
<td>Starts the list before the elements are added.</td>
</tr>
<tr class="">
<td><a href="walker/unset_children.html">Walker::unset_children</a></td>
<td>Unsets all the children for a given top level element.</td>
</tr>
<tr class="">
<td><a href="walker/walk.html">Walker::walk</a></td>
<td>Displays array of elements hierarchically.</td>
</tr>
</tbody>
</table></figure></section> </section> <section><h2 id="source">Source</h2> <pre class="wp-block-code" data-start="15" aria-label="Function source code" data-language="php"><code id="wporg-source-code" lang="php" class="language-php line-numbers">class Walker {
	/**
	 * What the class handles.
	 *
	 * @since 2.1.0
	 * @var string
	 */
	public $tree_type;

	/**
	 * DB fields to use.
	 *
	 * @since 2.1.0
	 * @var string[]
	 */
	public $db_fields;

	/**
	 * Max number of pages walked by the paged walker.
	 *
	 * @since 2.7.0
	 * @var int
	 */
	public $max_pages = 1;

	/**
	 * Whether the current element has children or not.
	 *
	 * To be used in start_el().
	 *
	 * @since 4.0.0
	 * @var bool
	 */
	public $has_children;

	/**
	 * Starts the list before the elements are added.
	 *
	 * The $args parameter holds additional values that may be used with the child
	 * class methods. This method is called at the start of the output list.
	 *
	 * @since 2.1.0
	 * @abstract
	 *
	 * @param string $output Used to append additional content (passed by reference).
	 * @param int    $depth  Depth of the item.
	 * @param array  $args   An array of additional arguments.
	 */
	public function start_lvl( &amp;$output, $depth = 0, $args = array() ) {}

	/**
	 * Ends the list of after the elements are added.
	 *
	 * The $args parameter holds additional values that may be used with the child
	 * class methods. This method finishes the list at the end of output of the elements.
	 *
	 * @since 2.1.0
	 * @abstract
	 *
	 * @param string $output Used to append additional content (passed by reference).
	 * @param int    $depth  Depth of the item.
	 * @param array  $args   An array of additional arguments.
	 */
	public function end_lvl( &amp;$output, $depth = 0, $args = array() ) {}

	/**
	 * Starts the element output.
	 *
	 * The $args parameter holds additional values that may be used with the child
	 * class methods. Also includes the element output.
	 *
	 * @since 2.1.0
	 * @since 5.9.0 Renamed `$object` (a PHP reserved keyword) to `$data_object` for PHP 8 named parameter support.
	 * @abstract
	 *
	 * @param string $output            Used to append additional content (passed by reference).
	 * @param object $data_object       The data object.
	 * @param int    $depth             Depth of the item.
	 * @param array  $args              An array of additional arguments.
	 * @param int    $current_object_id Optional. ID of the current item. Default 0.
	 */
	public function start_el( &amp;$output, $data_object, $depth = 0, $args = array(), $current_object_id = 0 ) {}

	/**
	 * Ends the element output, if needed.
	 *
	 * The $args parameter holds additional values that may be used with the child class methods.
	 *
	 * @since 2.1.0
	 * @since 5.9.0 Renamed `$object` (a PHP reserved keyword) to `$data_object` for PHP 8 named parameter support.
	 * @abstract
	 *
	 * @param string $output      Used to append additional content (passed by reference).
	 * @param object $data_object The data object.
	 * @param int    $depth       Depth of the item.
	 * @param array  $args        An array of additional arguments.
	 */
	public function end_el( &amp;$output, $data_object, $depth = 0, $args = array() ) {}

	/**
	 * Traverses elements to create list from elements.
	 *
	 * Display one element if the element doesn't have any children otherwise,
	 * display the element and its children. Will only traverse up to the max
	 * depth and no ignore elements under that depth. It is possible to set the
	 * max depth to include all depths, see walk() method.
	 *
	 * This method should not be called directly, use the walk() method instead.
	 *
	 * @since 2.5.0
	 *
	 * @param object $element           Data object.
	 * @param array  $children_elements List of elements to continue traversing (passed by reference).
	 * @param int    $max_depth         Max depth to traverse.
	 * @param int    $depth             Depth of current element.
	 * @param array  $args              An array of arguments.
	 * @param string $output            Used to append additional content (passed by reference).
	 */
	public function display_element( $element, &amp;$children_elements, $max_depth, $depth, $args, &amp;$output ) {
		if ( ! $element ) {
			return;
		}

		$max_depth = (int) $max_depth;
		$depth     = (int) $depth;

		$id_field = $this-&gt;db_fields['id'];
		$id       = $element-&gt;$id_field;

		// Display this element.
		$this-&gt;has_children = ! empty( $children_elements[ $id ] );
		if ( isset( $args[0] ) &amp;&amp; is_array( $args[0] ) ) {
			$args[0]['has_children'] = $this-&gt;has_children; // Back-compat.
		}

		$this-&gt;start_el( $output, $element, $depth, ...array_values( $args ) );

		// Descend only when the depth is right and there are children for this element.
		if ( ( 0 === $max_depth || $max_depth &gt; $depth + 1 ) &amp;&amp; isset( $children_elements[ $id ] ) ) {

			foreach ( $children_elements[ $id ] as $child ) {

				if ( ! isset( $newlevel ) ) {
					$newlevel = true;
					// Start the child delimiter.
					$this-&gt;start_lvl( $output, $depth, ...array_values( $args ) );
				}
				$this-&gt;display_element( $child, $children_elements, $max_depth, $depth + 1, $args, $output );
			}
			unset( $children_elements[ $id ] );
		}

		if ( isset( $newlevel ) &amp;&amp; $newlevel ) {
			// End the child delimiter.
			$this-&gt;end_lvl( $output, $depth, ...array_values( $args ) );
		}

		// End this element.
		$this-&gt;end_el( $output, $element, $depth, ...array_values( $args ) );
	}

	/**
	 * Displays array of elements hierarchically.
	 *
	 * Does not assume any existing order of elements.
	 *
	 * $max_depth = -1 means flatly display every element.
	 * $max_depth = 0 means display all levels.
	 * $max_depth &gt; 0 specifies the number of display levels.
	 *
	 * @since 2.1.0
	 * @since 5.3.0 Formalized the existing `...$args` parameter by adding it
	 *              to the function signature.
	 *
	 * @param array $elements  An array of elements.
	 * @param int   $max_depth The maximum hierarchical depth.
	 * @param mixed ...$args   Optional additional arguments.
	 * @return string The hierarchical item output.
	 */
	public function walk( $elements, $max_depth, ...$args ) {
		$output = '';

		$max_depth = (int) $max_depth;

		// Invalid parameter or nothing to walk.
		if ( $max_depth &lt; -1 || empty( $elements ) ) {
			return $output;
		}

		$parent_field = $this-&gt;db_fields['parent'];

		// Flat display.
		if ( -1 === $max_depth ) {
			$empty_array = array();
			foreach ( $elements as $e ) {
				$this-&gt;display_element( $e, $empty_array, 1, 0, $args, $output );
			}
			return $output;
		}

		/*
		 * Need to display in hierarchical order.
		 * Separate elements into two buckets: top level and children elements.
		 * Children_elements is two dimensional array. Example:
		 * Children_elements[10][] contains all sub-elements whose parent is 10.
		 */
		$top_level_elements = array();
		$children_elements  = array();
		foreach ( $elements as $e ) {
			if ( empty( $e-&gt;$parent_field ) ) {
				$top_level_elements[] = $e;
			} else {
				$children_elements[ $e-&gt;$parent_field ][] = $e;
			}
		}

		/*
		 * When none of the elements is top level.
		 * Assume the first one must be root of the sub elements.
		 */
		if ( empty( $top_level_elements ) ) {

			$first = array_slice( $elements, 0, 1 );
			$root  = $first[0];

			$top_level_elements = array();
			$children_elements  = array();
			foreach ( $elements as $e ) {
				if ( $root-&gt;$parent_field === $e-&gt;$parent_field ) {
					$top_level_elements[] = $e;
				} else {
					$children_elements[ $e-&gt;$parent_field ][] = $e;
				}
			}
		}

		foreach ( $top_level_elements as $e ) {
			$this-&gt;display_element( $e, $children_elements, $max_depth, 0, $args, $output );
		}

		/*
		 * If we are displaying all levels, and remaining children_elements is not empty,
		 * then we got orphans, which should be displayed regardless.
		 */
		if ( ( 0 === $max_depth ) &amp;&amp; count( $children_elements ) &gt; 0 ) {
			$empty_array = array();
			foreach ( $children_elements as $orphans ) {
				foreach ( $orphans as $op ) {
					$this-&gt;display_element( $op, $empty_array, 1, 0, $args, $output );
				}
			}
		}

		return $output;
	}

	/**
	 * Produces a page of nested elements.
	 *
	 * Given an array of hierarchical elements, the maximum depth, a specific page number,
	 * and number of elements per page, this function first determines all top level root elements
	 * belonging to that page, then lists them and all of their children in hierarchical order.
	 *
	 * $max_depth = 0 means display all levels.
	 * $max_depth &gt; 0 specifies the number of display levels.
	 *
	 * @since 2.7.0
	 * @since 5.3.0 Formalized the existing `...$args` parameter by adding it
	 *              to the function signature.
	 *
	 * @param array $elements  An array of elements.
	 * @param int   $max_depth The maximum hierarchical depth.
	 * @param int   $page_num  The specific page number, beginning with 1.
	 * @param int   $per_page  Number of elements per page.
	 * @param mixed ...$args   Optional additional arguments.
	 * @return string XHTML of the specified page of elements.
	 */
	public function paged_walk( $elements, $max_depth, $page_num, $per_page, ...$args ) {
		$output = '';

		$max_depth = (int) $max_depth;

		if ( empty( $elements ) || $max_depth &lt; -1 ) {
			return $output;
		}

		$parent_field = $this-&gt;db_fields['parent'];

		$count = -1;
		if ( -1 === $max_depth ) {
			$total_top = count( $elements );
		}
		if ( $page_num &lt; 1 || $per_page &lt; 0 ) {
			// No paging.
			$paging = false;
			$start  = 0;
			if ( -1 === $max_depth ) {
				$end = $total_top;
			}
			$this-&gt;max_pages = 1;
		} else {
			$paging = true;
			$start  = ( (int) $page_num - 1 ) * (int) $per_page;
			$end    = $start + $per_page;
			if ( -1 === $max_depth ) {
				$this-&gt;max_pages = (int) ceil( $total_top / $per_page );
			}
		}

		// Flat display.
		if ( -1 === $max_depth ) {
			if ( ! empty( $args[0]['reverse_top_level'] ) ) {
				$elements = array_reverse( $elements );
				$oldstart = $start;
				$start    = $total_top - $end;
				$end      = $total_top - $oldstart;
			}

			$empty_array = array();
			foreach ( $elements as $e ) {
				++$count;
				if ( $count &lt; $start ) {
					continue;
				}
				if ( $count &gt;= $end ) {
					break;
				}
				$this-&gt;display_element( $e, $empty_array, 1, 0, $args, $output );
			}
			return $output;
		}

		/*
		 * Separate elements into two buckets: top level and children elements.
		 * Children_elements is two dimensional array, e.g.
		 * $children_elements[10][] contains all sub-elements whose parent is 10.
		 */
		$top_level_elements = array();
		$children_elements  = array();
		foreach ( $elements as $e ) {
			if ( empty( $e-&gt;$parent_field ) ) {
				$top_level_elements[] = $e;
			} else {
				$children_elements[ $e-&gt;$parent_field ][] = $e;
			}
		}

		$total_top = count( $top_level_elements );
		if ( $paging ) {
			$this-&gt;max_pages = (int) ceil( $total_top / $per_page );
		} else {
			$end = $total_top;
		}

		if ( ! empty( $args[0]['reverse_top_level'] ) ) {
			$top_level_elements = array_reverse( $top_level_elements );
			$oldstart           = $start;
			$start              = $total_top - $end;
			$end                = $total_top - $oldstart;
		}
		if ( ! empty( $args[0]['reverse_children'] ) ) {
			foreach ( $children_elements as $parent =&gt; $children ) {
				$children_elements[ $parent ] = array_reverse( $children );
			}
		}

		foreach ( $top_level_elements as $e ) {
			++$count;

			// For the last page, need to unset earlier children in order to keep track of orphans.
			if ( $end &gt;= $total_top &amp;&amp; $count &lt; $start ) {
					$this-&gt;unset_children( $e, $children_elements );
			}

			if ( $count &lt; $start ) {
				continue;
			}

			if ( $count &gt;= $end ) {
				break;
			}

			$this-&gt;display_element( $e, $children_elements, $max_depth, 0, $args, $output );
		}

		if ( $end &gt;= $total_top &amp;&amp; count( $children_elements ) &gt; 0 ) {
			$empty_array = array();
			foreach ( $children_elements as $orphans ) {
				foreach ( $orphans as $op ) {
					$this-&gt;display_element( $op, $empty_array, 1, 0, $args, $output );
				}
			}
		}

		return $output;
	}

	/**
	 * Calculates the total number of root elements.
	 *
	 * @since 2.7.0
	 *
	 * @param array $elements Elements to list.
	 * @return int Number of root elements.
	 */
	public function get_number_of_root_elements( $elements ) {
		$num          = 0;
		$parent_field = $this-&gt;db_fields['parent'];

		foreach ( $elements as $e ) {
			if ( empty( $e-&gt;$parent_field ) ) {
				++$num;
			}
		}
		return $num;
	}

	/**
	 * Unsets all the children for a given top level element.
	 *
	 * @since 2.7.0
	 *
	 * @param object $element           The top level element.
	 * @param array  $children_elements The children elements.
	 */
	public function unset_children( $element, &amp;$children_elements ) {
		if ( ! $element || ! $children_elements ) {
			return;
		}

		$id_field = $this-&gt;db_fields['id'];
		$id       = $element-&gt;$id_field;

		if ( ! empty( $children_elements[ $id ] ) &amp;&amp; is_array( $children_elements[ $id ] ) ) {
			foreach ( (array) $children_elements[ $id ] as $child ) {
				$this-&gt;unset_children( $child, $children_elements );
			}
		}

		unset( $children_elements[ $id ] );
	}
}
</code></pre>
<p class="wporg-dot-link-list"><a href="https://developer.wordpress.org/reference/files/wp-includes/class-wp-walker.php/">View all references</a> <a href="https://core.trac.wordpress.org/browser/tags/6.7/src/wp-includes/class-wp-walker.php#L15">View on Trac</a> <a href="https://github.com/WordPress/wordpress-develop/blob/6.7/src/wp-includes/class-wp-walker.php#L15-L456">View on GitHub</a></p></section>  <section><h2 id="changelog">Changelog</h2> <section style="margin-top:var(--wp--preset--spacing--20);"><figure class="wp-block-table "><table>
<thead><tr>
<th scope="col">Version</th>
<th scope="col">Description</th>
</tr></thead>
<tbody><tr class="">
<td><a href="https://developer.wordpress.org/reference/since/2.1.0/">2.1.0</a></td>
<td>Introduced.</td>
</tr></tbody>
</table></figure></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2003&ndash;2024 WordPress Foundation<br>Licensed under the GNU GPLv2+ License.<br>
    <a href="https://developer.wordpress.org/reference/classes/walker" class="_attribution-link">https://developer.wordpress.org/reference/classes/walker</a>
  </p>
</div>
