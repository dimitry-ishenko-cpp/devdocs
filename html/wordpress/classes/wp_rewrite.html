<h1>class WP_Rewrite {}</h1>  <section> <p>Core class used to implement a rewrite component API.</p> </section>   <section> <header class="toc-header"><h2 id="description">Description</h2></header> <p>The WordPress Rewrite class writes the rewrite module rules to the .htaccess file. It also handles parsing the request to get the correct setup for the WordPress Query class.</p> <p>The Rewrite along with WP class function as a front controller for WordPress.<br>You can add rules to trigger your page view and processing using this component. The full functionality of a front controller does not exist, meaning you can’t define how the template files load based on the rewrite rules.</p> </section>  <section> <header class="toc-header"><h2 id="more-information">More Information</h2></header> <p>This document assumes familiarity with <a class="external text" href="http://httpd.apache.org" rel="nofollow">Apache</a>‘s <a class="external text" href="http://httpd.apache.org/docs/2.0/mod/mod_rewrite.html" rel="nofollow">mod_rewrite</a>. If you’ve never heard of this before, try reading about <a href="https://en.wikipedia.org/wiki/URL_Rewriting">URL Rewriting</a>. Also see Otto’s explanation of <a class="external text" href="http://lists.automattic.com/pipermail/wp-testers/2009-January/011110.html" rel="nofollow">hierarchy of rewrite rules</a> in the wp-hackers email list.</p> <p>Please note that these rules are usually called inside the init hook. Furthermore, permalinks will need to be refreshed (you can do this in WP Admin under Settings -&gt; Permalinks) before the rewrite changes will take effect. Requires one-time use of <code>flush_rules()</code> to take effect.</p>  <header class="toc-header"><h2 id="role-of-wp_rewrite">Role of WP_Rewrite</h2></header> <p><tt><a href="wp_rewrite.html" rel="class">WP_Rewrite</a></tt> is WordPress’ class for managing the rewrite rules that allow you to use <a title="Introduction to Blogging" href="https://wordpress.org/support/article/introduction-to-blogging/#pretty-permalinks">Pretty Permalinks</a> feature. It has several methods that generate the rewrite rules from values in the database. It is used internally when updating the rewrite rules, and also to find the URL of a specific post, Page, category archive, etc.. It’s defined in <tt>wp-includes/rewrite.php</tt> as a single instance global variable, <tt>$wp_rewrite</tt>, is initialised in <tt>wp-settings.php</tt>.</p> <header class="toc-header"><h2 id="properties">Properties</h2></header> <p>Try not to access or set the properties directly, instead use the methods to interact with the <tt>$wp_rewrite</tt> object. See also <a title="Rewrite API" href="https://developer.wordpress.org/apis/handbook/rewrite/">Rewrite API</a>.</p> <dl> <dt><tt>$permalink_structure</tt></dt> <dd>The permalink structure as in the database. This is what you set on the Permalink Options page, and includes ‘tags’ like %year%, %month% and %post_id%.</dd> <dt><tt>$category_base</tt></dt> <dd>Anything to be inserted before category archive URLs. Defaults to ‘category/’.</dd> <dt><tt>$category_structure</tt></dt> <dd>Structure for category archive URLs. This is just the <tt>$category_base</tt> plus ‘%category%’.</dd> <dt><tt>$author_base</tt></dt> <dd>Anything to be inserted before author archive URLs. Defaults to ‘author/’.</dd> <dt><tt>$author_structure</tt></dt> <dd>Structure for author archive URLs. This is just the <tt>$author_base</tt> plus ‘%author%’.</dd> <dt><tt>$pagination_base</tt></dt> <dd>Anything to be inserted before pagination indices. Defaults to ‘page/’.</dd> <dt><tt>$feeds</tt></dt> <dd>Supported feeds names (rdf, rss, atom) Use <a title="Rewrite API/add feed" href="../functions/add_feed.html">add_feed</a> to override or add.</dd> <dt><tt>$feed_base</tt></dt> <dd>Anything to be inserted before feed URLs. Defaults to ‘feed/’.</dd> <dt><tt>$feed_structure</tt></dt> <dd>Structure for feed URLs. This is just the <tt>$feed_base</tt> plus ‘%feed%’.</dd> <dt><tt>$search_base</tt></dt> <dd>Anything to be inserted before searches. Defaults to ‘search/’.</dd> <dt><tt>$search_structure</tt></dt> <dd>Structure for search URLs. This is just the <tt>$search_base</tt> plus ‘%search%’.</dd> <dt><tt>$comments_base</tt></dt> <dd>Anything to be inserted just before the <tt>$feed_structure</tt> to get the latest comments feed. Defaults to ‘comments’.</dd> <dt><tt>$comments_feed_structure</tt></dt> <dd>The structure for the latest comments feed. This is just <tt>$comments_base</tt> plus <tt>$feed_base</tt> plus ‘%feed%’.</dd> <dt><tt>$date_structure</tt></dt> <dd>Structure for dated archive URLs. Tries to be ‘%year%/%monthnum%/%day%’, ‘%day%/%monthnum%/%year%’ or ‘%monthnum%/%day%/%year%’, but if none of these are detected in your <tt>$permalink_structure</tt>, defaults to ‘%year%/%monthnum%/%day%’. Various functions use this structure to obtain less specific structures: for example, <tt>get_year_permastruct()</tt> simply removes the ‘%monthnum%’ and ‘%day%’ tags from <tt>$date_structure</tt>.</dd> <dt><tt>$page_structure</tt></dt> <dd>Structure for Pages. Just ‘%pagename%’.</dd> <dt><tt>$front</tt></dt> <dd>Anything up to the start of the first tag in your <tt>$permalink_structure</tt>.</dd> <dt><tt>$root</tt></dt> <dd>The root of your WordPress install. Prepended to all structures.</dd> <dt><tt>$matches</tt></dt> <dd>Used internally when calculating back references for the redirect part of the rewrite rules.</dd> <dt><tt>$rules</tt></dt> <dd>The rewrite rules. Set when <tt>rewrite_rules()</tt> is called.</dd> <dt><tt>$non_wp_rules</tt></dt> <dd>Associative array of “rules that don’t redirect to WP’s index.php (and thus shouldn’t be handled by WP at all)” roughly in the form <code>'Pattern' =&gt; 'Substitution'</code> (see below).</dd> <dt><tt>$rewritecode</tt></dt> <dd>An array of all the tags available for the permalink structure. See <a title="Using Permalinks" href="https://wordpress.org/support/article/using-permalinks/">Using Permalinks</a> for a list.</dd> <dt><tt>$rewritereplace</tt></dt> <dd>What each tag will be replaced with for the regex part of the rewrite rule. The first element in <tt>$rewritereplace</tt> is the regex for the first element in <tt>$rewritecode</tt>, the second corresponds to the second, and so on.</dd> <dt><tt>$queryreplace</tt></dt> <dd>What each tag will be replaced with in the rewrite part of the rewrite rule. The same correspondance applies here as with <tt>$rewritereplace</tt>.</dd> </dl>  <header class="toc-header"><h2 id="plugin-hooks">Plugin Hooks</h2></header> <p>As the rewrite rules are a crucial part of your website’s functionality, WordPress allows plugins to hook into the generation process at several points. <tt>rewrite_rules()</tt>, specifically, contains nine filters and one hook for really precise control over the rewrite rules process. Here’s what you can filter in <tt>rewrite_rules()</tt>:</p> <ul> <li>
<tt><a title="Plugin API/Filter Reference/post rewrite rules" href="../hooks/post_rewrite_rules.html">post_rewrite_rules</a></tt> – Used to filter the rewrite rules generated for permalink URLs.</li> <li>
<tt><a title="Plugin API/Filter Reference/date rewrite rules" href="../hooks/date_rewrite_rules.html">date_rewrite_rules</a></tt> – Used to filter the rewrite rules generated for dated archive URLs.</li> <li>
<tt><a title="Plugin API/Filter Reference/$permastruct rewrite rules" href="../hooks/permastructname_rewrite_rules.html">{$permastruct}_rewrite_rules</a></tt> – Can be used to filter permastructs like ‘category’ or other taxonomies.</li> <li>
<tt><a title="Plugin API/Filter Reference/search rewrite rules" href="../hooks/search_rewrite_rules.html">search_rewrite_rules</a></tt> – Used to filter the rewrite rules generated for search URLs.</li> <li>
<tt><a title="Plugin API/Filter Reference/comments rewrite rules" href="../hooks/comments_rewrite_rules.html">comments_rewrite_rules</a></tt> – Used to filter the rewrite rules generated for the latest comment feed URLs.</li> <li>
<tt><a title="Plugin API/Filter Reference/author rewrite rules" href="../hooks/author_rewrite_rules.html">author_rewrite_rules</a></tt> – Used to filter the rewrite rules generated for author archive URLs.</li> <li>
<tt><a title="Plugin API/Filter Reference/page rewrite rules" href="../hooks/page_rewrite_rules.html">page_rewrite_rules</a></tt> – Used to filter the rewrite rules generated for your Pages.</li> <li>
<tt><a title="Plugin API/Filter Reference/root rewrite rules" href="../hooks/root_rewrite_rules.html">root_rewrite_rules</a></tt> – Used to filter the rewrite rules generated for the root of your weblog.</li> <li>
<tt><a title="Plugin API/Filter Reference/rewrite rules array" href="../hooks/rewrite_rules_array.html">rewrite_rules_array</a></tt> – Use to filter <i>all</i> the rewrite rules at once.</li> <li>
<tt><a title="Plugin API/Action Reference/generate rewrite rules" href="../hooks/generate_rewrite_rules.html">generate_rewrite_rules</a></tt> – This action hook runs <strong>after</strong> all the rules have been created. If your function takes a parameter, it will be passed a <a class="external text" href="http://www.php.net/manual/en/language.references.php" rel="nofollow">reference</a> to the entire <tt>$wp_rewrite</tt> object.</li> </ul> <p><tt>mod_rewrite_rules()</tt> is the function that takes the array generated by <tt>rewrite_rules()</tt> and actually turns it into a set of rewrite rules for the .htaccess file. This function also has a filter, <tt>mod_rewrite_rules</tt>, which will pass functions the string of all the rules to be written out to .htaccess, including the <tt>&lt;IfModule&gt;</tt> surrounding section. (Note: you may also see plugins using the <tt>rewrite_rules</tt> hook, but this is deprecated).</p> </section>  <section> <header class="toc-header"><h2 id="methods">Methods</h2></header> <ul> <li>
<a href="wp_rewrite/__construct.html"> __construct</a> — Constructor - Calls init(), which runs setup. </li> <li>
<a href="wp_rewrite/add_endpoint.html"> add_endpoint</a> — Adds an endpoint, like /trackback/. </li> <li>
<a href="wp_rewrite/add_external_rule.html"> add_external_rule</a> — Adds a rewrite rule that doesn't correspond to index.php. </li> <li>
<a href="wp_rewrite/add_permastruct.html"> add_permastruct</a> — Adds a new permalink structure. </li> <li>
<a href="wp_rewrite/add_rewrite_tag.html"> add_rewrite_tag</a> — Adds or updates existing rewrite tags (e.g. %postname%). </li> <li>
<a href="wp_rewrite/add_rule.html"> add_rule</a> — Adds a rewrite rule that transforms a URL structure to a set of query vars. </li> <li>
<a href="wp_rewrite/flush_rules.html"> flush_rules</a> — Removes rewrite rules and then recreate rewrite rules. </li> <li>
<a href="wp_rewrite/generate_rewrite_rule.html"> generate_rewrite_rule</a> — Generates rewrite rules with permalink structure and walking directory only. </li> <li>
<a href="wp_rewrite/generate_rewrite_rules.html"> generate_rewrite_rules</a> — Generates rewrite rules from a permalink structure. </li> <li>
<a href="wp_rewrite/get_author_permastruct.html"> get_author_permastruct</a> — Retrieves the author permalink structure. </li> <li>
<a href="wp_rewrite/get_category_permastruct.html"> get_category_permastruct</a> — Retrieves the permalink structure for categories. </li> <li>
<a href="wp_rewrite/get_comment_feed_permastruct.html"> get_comment_feed_permastruct</a> — Retrieves the comment feed permalink structure. </li> <li>
<a href="wp_rewrite/get_date_permastruct.html"> get_date_permastruct</a> — Retrieves date permalink structure, with year, month, and day. </li> <li>
<a href="wp_rewrite/get_day_permastruct.html"> get_day_permastruct</a> — Retrieves the day permalink structure with month and year. </li> <li>
<a href="wp_rewrite/get_extra_permastruct.html"> get_extra_permastruct</a> — Retrieves an extra permalink structure by name. </li> <li>
<a href="wp_rewrite/get_feed_permastruct.html"> get_feed_permastruct</a> — Retrieves the feed permalink structure. </li> <li>
<a href="wp_rewrite/get_month_permastruct.html"> get_month_permastruct</a> — Retrieves the month permalink structure without day and with year. </li> <li>
<a href="wp_rewrite/get_page_permastruct.html"> get_page_permastruct</a> — Retrieves the page permalink structure. </li> <li>
<a href="wp_rewrite/get_search_permastruct.html"> get_search_permastruct</a> — Retrieves the search permalink structure. </li> <li>
<a href="wp_rewrite/get_tag_permastruct.html"> get_tag_permastruct</a> — Retrieves the permalink structure for tags. </li> <li>
<a href="wp_rewrite/get_year_permastruct.html"> get_year_permastruct</a> — Retrieves the year permalink structure without month and day. </li> <li>
<a href="wp_rewrite/iis7_url_rewrite_rules.html"> iis7_url_rewrite_rules</a> — Retrieves IIS7 URL Rewrite formatted rewrite rules to write to web.config file. </li> <li>
<a href="wp_rewrite/init.html"> init</a> — Sets up the object's properties. </li> <li>
<a href="wp_rewrite/mod_rewrite_rules.html"> mod_rewrite_rules</a> — Retrieves mod_rewrite-formatted rewrite rules to write to .htaccess. </li> <li>
<a href="wp_rewrite/page_rewrite_rules.html"> page_rewrite_rules</a> — Retrieves all of the rewrite rules for pages. </li> <li>
<a href="wp_rewrite/page_uri_index.html"> page_uri_index</a> — Retrieves all pages and attachments for pages URIs. </li> <li>
<a href="wp_rewrite/preg_index.html"> preg_index</a> — Indexes for matches for usage in preg_*() functions. </li> <li>
<a href="wp_rewrite/remove_permastruct.html"> remove_permastruct</a> — Removes a permalink structure. </li> <li>
<a href="wp_rewrite/remove_rewrite_tag.html"> remove_rewrite_tag</a> — Removes an existing rewrite tag. </li> <li>
<a href="wp_rewrite/rewrite_rules.html"> rewrite_rules</a> — Constructs rewrite matches and queries from permalink structure. </li> <li>
<a href="wp_rewrite/set_category_base.html"> set_category_base</a> — Sets the category base for the category permalink. </li> <li>
<a href="wp_rewrite/set_permalink_structure.html"> set_permalink_structure</a> — Sets the main permalink structure for the site. </li> <li>
<a href="wp_rewrite/set_tag_base.html"> set_tag_base</a> — Sets the tag base for the tag permalink. </li> <li>
<a href="wp_rewrite/using_index_permalinks.html"> using_index_permalinks</a> — Determines whether permalinks are being used and rewrite module is not enabled. </li> <li>
<a href="wp_rewrite/using_mod_rewrite_permalinks.html"> using_mod_rewrite_permalinks</a> — Determines whether permalinks are being used and rewrite module is enabled. </li> <li>
<a href="wp_rewrite/using_permalinks.html"> using_permalinks</a> — Determines whether permalinks are being used. </li> <li>
<a href="wp_rewrite/wp_rewrite_rules.html"> wp_rewrite_rules</a> — Retrieves the rewrite rules. </li> </ul> </section>  <section> <header class="toc-header"><h2 id="source">Source</h2></header> <p> File: <code>wp-includes/class-wp-rewrite.php</code>. <a href="https://developer.wordpress.org/reference/files/wp-includes/class-wp-rewrite.php/">View all references</a> </p> <pre class="wp-block-code" data-start="26" aria-label="Function source code" data-language="php"><code lang="php" class="language-php line-numbers">class WP_Rewrite {
	/**
	 * Permalink structure for posts.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $permalink_structure;

	/**
	 * Whether to add trailing slashes.
	 *
	 * @since 2.2.0
	 * @var bool
	 */
	public $use_trailing_slashes;

	/**
	 * Base for the author permalink structure (example.com/$author_base/authorname).
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $author_base = 'author';

	/**
	 * Permalink structure for author archives.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $author_structure;

	/**
	 * Permalink structure for date archives.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $date_structure;

	/**
	 * Permalink structure for pages.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $page_structure;

	/**
	 * Base of the search permalink structure (example.com/$search_base/query).
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $search_base = 'search';

	/**
	 * Permalink structure for searches.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $search_structure;

	/**
	 * Comments permalink base.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $comments_base = 'comments';

	/**
	 * Pagination permalink base.
	 *
	 * @since 3.1.0
	 * @var string
	 */
	public $pagination_base = 'page';

	/**
	 * Comments pagination permalink base.
	 *
	 * @since 4.2.0
	 * @var string
	 */
	public $comments_pagination_base = 'comment-page';

	/**
	 * Feed permalink base.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $feed_base = 'feed';

	/**
	 * Comments feed permalink structure.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $comment_feed_structure;

	/**
	 * Feed request permalink structure.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $feed_structure;

	/**
	 * The static portion of the post permalink structure.
	 *
	 * If the permalink structure is "/archive/%post_id%" then the front
	 * is "/archive/". If the permalink structure is "/%year%/%postname%/"
	 * then the front is "/".
	 *
	 * @since 1.5.0
	 * @var string
	 *
	 * @see WP_Rewrite::init()
	 */
	public $front;

	/**
	 * The prefix for all permalink structures.
	 *
	 * If PATHINFO/index permalinks are in use then the root is the value of
	 * `WP_Rewrite::$index` with a trailing slash appended. Otherwise the root
	 * will be empty.
	 *
	 * @since 1.5.0
	 * @var string
	 *
	 * @see WP_Rewrite::init()
	 * @see WP_Rewrite::using_index_permalinks()
	 */
	public $root = '';

	/**
	 * The name of the index file which is the entry point to all requests.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $index = 'index.php';

	/**
	 * Variable name to use for regex matches in the rewritten query.
	 *
	 * @since 1.5.0
	 * @var string
	 */
	public $matches = '';

	/**
	 * Rewrite rules to match against the request to find the redirect or query.
	 *
	 * @since 1.5.0
	 * @var string[]
	 */
	public $rules;

	/**
	 * Additional rules added external to the rewrite class.
	 *
	 * Those not generated by the class, see add_rewrite_rule().
	 *
	 * @since 2.1.0
	 * @var string[]
	 */
	public $extra_rules = array();

	/**
	 * Additional rules that belong at the beginning to match first.
	 *
	 * Those not generated by the class, see add_rewrite_rule().
	 *
	 * @since 2.3.0
	 * @var string[]
	 */
	public $extra_rules_top = array();

	/**
	 * Rules that don't redirect to WordPress' index.php.
	 *
	 * These rules are written to the mod_rewrite portion of the .htaccess,
	 * and are added by add_external_rule().
	 *
	 * @since 2.1.0
	 * @var string[]
	 */
	public $non_wp_rules = array();

	/**
	 * Extra permalink structures, e.g. categories, added by add_permastruct().
	 *
	 * @since 2.1.0
	 * @var array[]
	 */
	public $extra_permastructs = array();

	/**
	 * Endpoints (like /trackback/) added by add_rewrite_endpoint().
	 *
	 * @since 2.1.0
	 * @var array[]
	 */
	public $endpoints;

	/**
	 * Whether to write every mod_rewrite rule for WordPress into the .htaccess file.
	 *
	 * This is off by default, turning it on might print a lot of rewrite rules
	 * to the .htaccess file.
	 *
	 * @since 2.0.0
	 * @var bool
	 *
	 * @see WP_Rewrite::mod_rewrite_rules()
	 */
	public $use_verbose_rules = false;

	/**
	 * Could post permalinks be confused with those of pages?
	 *
	 * If the first rewrite tag in the post permalink structure is one that could
	 * also match a page name (e.g. %postname% or %author%) then this flag is
	 * set to true. Prior to WordPress 3.3 this flag indicated that every page
	 * would have a set of rules added to the top of the rewrite rules array.
	 * Now it tells WP::parse_request() to check if a URL matching the page
	 * permastruct is actually a page before accepting it.
	 *
	 * @since 2.5.0
	 * @var bool
	 *
	 * @see WP_Rewrite::init()
	 */
	public $use_verbose_page_rules = true;

	/**
	 * Rewrite tags that can be used in permalink structures.
	 *
	 * These are translated into the regular expressions stored in
	 * `WP_Rewrite::$rewritereplace` and are rewritten to the query
	 * variables listed in WP_Rewrite::$queryreplace.
	 *
	 * Additional tags can be added with add_rewrite_tag().
	 *
	 * @since 1.5.0
	 * @var string[]
	 */
	public $rewritecode = array(
		'%year%',
		'%monthnum%',
		'%day%',
		'%hour%',
		'%minute%',
		'%second%',
		'%postname%',
		'%post_id%',
		'%author%',
		'%pagename%',
		'%search%',
	);

	/**
	 * Regular expressions to be substituted into rewrite rules in place
	 * of rewrite tags, see WP_Rewrite::$rewritecode.
	 *
	 * @since 1.5.0
	 * @var string[]
	 */
	public $rewritereplace = array(
		'([0-9]{4})',
		'([0-9]{1,2})',
		'([0-9]{1,2})',
		'([0-9]{1,2})',
		'([0-9]{1,2})',
		'([0-9]{1,2})',
		'([^/]+)',
		'([0-9]+)',
		'([^/]+)',
		'([^/]+?)',
		'(.+)',
	);

	/**
	 * Query variables that rewrite tags map to, see WP_Rewrite::$rewritecode.
	 *
	 * @since 1.5.0
	 * @var string[]
	 */
	public $queryreplace = array(
		'year=',
		'monthnum=',
		'day=',
		'hour=',
		'minute=',
		'second=',
		'name=',
		'p=',
		'author_name=',
		'pagename=',
		's=',
	);

	/**
	 * Supported default feeds.
	 *
	 * @since 1.5.0
	 * @var string[]
	 */
	public $feeds = array( 'feed', 'rdf', 'rss', 'rss2', 'atom' );

	/**
	 * Determines whether permalinks are being used.
	 *
	 * This can be either rewrite module or permalink in the HTTP query string.
	 *
	 * @since 1.5.0
	 *
	 * @return bool True, if permalinks are enabled.
	 */
	public function using_permalinks() {
		return ! empty( $this-&gt;permalink_structure );
	}

	/**
	 * Determines whether permalinks are being used and rewrite module is not enabled.
	 *
	 * Means that permalink links are enabled and index.php is in the URL.
	 *
	 * @since 1.5.0
	 *
	 * @return bool Whether permalink links are enabled and index.php is in the URL.
	 */
	public function using_index_permalinks() {
		if ( empty( $this-&gt;permalink_structure ) ) {
			return false;
		}

		// If the index is not in the permalink, we're using mod_rewrite.
		return preg_match( '#^/*' . $this-&gt;index . '#', $this-&gt;permalink_structure );
	}

	/**
	 * Determines whether permalinks are being used and rewrite module is enabled.
	 *
	 * Using permalinks and index.php is not in the URL.
	 *
	 * @since 1.5.0
	 *
	 * @return bool Whether permalink links are enabled and index.php is NOT in the URL.
	 */
	public function using_mod_rewrite_permalinks() {
		return $this-&gt;using_permalinks() &amp;&amp; ! $this-&gt;using_index_permalinks();
	}

	/**
	 * Indexes for matches for usage in preg_*() functions.
	 *
	 * The format of the string is, with empty matches property value, '$NUM'.
	 * The 'NUM' will be replaced with the value in the $number parameter. With
	 * the matches property not empty, the value of the returned string will
	 * contain that value of the matches property. The format then will be
	 * '$MATCHES[NUM]', with MATCHES as the value in the property and NUM the
	 * value of the $number parameter.
	 *
	 * @since 1.5.0
	 *
	 * @param int $number Index number.
	 * @return string
	 */
	public function preg_index( $number ) {
		$match_prefix = '$';
		$match_suffix = '';

		if ( ! empty( $this-&gt;matches ) ) {
			$match_prefix = '$' . $this-&gt;matches . '[';
			$match_suffix = ']';
		}

		return "$match_prefix$number$match_suffix";
	}

	/**
	 * Retrieves all pages and attachments for pages URIs.
	 *
	 * The attachments are for those that have pages as parents and will be
	 * retrieved.
	 *
	 * @since 2.5.0
	 *
	 * @global wpdb $wpdb WordPress database abstraction object.
	 *
	 * @return array Array of page URIs as first element and attachment URIs as second element.
	 */
	public function page_uri_index() {
		global $wpdb;

		// Get pages in order of hierarchy, i.e. children after parents.
		$pages = $wpdb-&gt;get_results( "SELECT ID, post_name, post_parent FROM $wpdb-&gt;posts WHERE post_type = 'page' AND post_status != 'auto-draft'" );
		$posts = get_page_hierarchy( $pages );

		// If we have no pages get out quick.
		if ( ! $posts ) {
			return array( array(), array() );
		}

		// Now reverse it, because we need parents after children for rewrite rules to work properly.
		$posts = array_reverse( $posts, true );

		$page_uris            = array();
		$page_attachment_uris = array();

		foreach ( $posts as $id =&gt; $post ) {
			// URL =&gt; page name.
			$uri         = get_page_uri( $id );
			$attachments = $wpdb-&gt;get_results( $wpdb-&gt;prepare( "SELECT ID, post_name, post_parent FROM $wpdb-&gt;posts WHERE post_type = 'attachment' AND post_parent = %d", $id ) );
			if ( ! empty( $attachments ) ) {
				foreach ( $attachments as $attachment ) {
					$attach_uri                          = get_page_uri( $attachment-&gt;ID );
					$page_attachment_uris[ $attach_uri ] = $attachment-&gt;ID;
				}
			}

			$page_uris[ $uri ] = $id;
		}

		return array( $page_uris, $page_attachment_uris );
	}

	/**
	 * Retrieves all of the rewrite rules for pages.
	 *
	 * @since 1.5.0
	 *
	 * @return string[] Page rewrite rules.
	 */
	public function page_rewrite_rules() {
		// The extra .? at the beginning prevents clashes with other regular expressions in the rules array.
		$this-&gt;add_rewrite_tag( '%pagename%', '(.?.+?)', 'pagename=' );

		return $this-&gt;generate_rewrite_rules( $this-&gt;get_page_permastruct(), EP_PAGES, true, true, false, false );
	}

	/**
	 * Retrieves date permalink structure, with year, month, and day.
	 *
	 * The permalink structure for the date, if not set already depends on the
	 * permalink structure. It can be one of three formats. The first is year,
	 * month, day; the second is day, month, year; and the last format is month,
	 * day, year. These are matched against the permalink structure for which
	 * one is used. If none matches, then the default will be used, which is
	 * year, month, day.
	 *
	 * Prevents post ID and date permalinks from overlapping. In the case of
	 * post_id, the date permalink will be prepended with front permalink with
	 * 'date/' before the actual permalink to form the complete date permalink
	 * structure.
	 *
	 * @since 1.5.0
	 *
	 * @return string|false Date permalink structure on success, false on failure.
	 */
	public function get_date_permastruct() {
		if ( isset( $this-&gt;date_structure ) ) {
			return $this-&gt;date_structure;
		}

		if ( empty( $this-&gt;permalink_structure ) ) {
			$this-&gt;date_structure = '';
			return false;
		}

		// The date permalink must have year, month, and day separated by slashes.
		$endians = array( '%year%/%monthnum%/%day%', '%day%/%monthnum%/%year%', '%monthnum%/%day%/%year%' );

		$this-&gt;date_structure = '';
		$date_endian          = '';

		foreach ( $endians as $endian ) {
			if ( false !== strpos( $this-&gt;permalink_structure, $endian ) ) {
				$date_endian = $endian;
				break;
			}
		}

		if ( empty( $date_endian ) ) {
			$date_endian = '%year%/%monthnum%/%day%';
		}

		/*
		 * Do not allow the date tags and %post_id% to overlap in the permalink
		 * structure. If they do, move the date tags to $front/date/.
		 */
		$front = $this-&gt;front;
		preg_match_all( '/%.+?%/', $this-&gt;permalink_structure, $tokens );
		$tok_index = 1;
		foreach ( (array) $tokens[0] as $token ) {
			if ( '%post_id%' === $token &amp;&amp; ( $tok_index &lt;= 3 ) ) {
				$front = $front . 'date/';
				break;
			}
			$tok_index++;
		}

		$this-&gt;date_structure = $front . $date_endian;

		return $this-&gt;date_structure;
	}

	/**
	 * Retrieves the year permalink structure without month and day.
	 *
	 * Gets the date permalink structure and strips out the month and day
	 * permalink structures.
	 *
	 * @since 1.5.0
	 *
	 * @return string|false Year permalink structure on success, false on failure.
	 */
	public function get_year_permastruct() {
		$structure = $this-&gt;get_date_permastruct();

		if ( empty( $structure ) ) {
			return false;
		}

		$structure = str_replace( '%monthnum%', '', $structure );
		$structure = str_replace( '%day%', '', $structure );
		$structure = preg_replace( '#/+#', '/', $structure );

		return $structure;
	}

	/**
	 * Retrieves the month permalink structure without day and with year.
	 *
	 * Gets the date permalink structure and strips out the day permalink
	 * structures. Keeps the year permalink structure.
	 *
	 * @since 1.5.0
	 *
	 * @return string|false Year/Month permalink structure on success, false on failure.
	 */
	public function get_month_permastruct() {
		$structure = $this-&gt;get_date_permastruct();

		if ( empty( $structure ) ) {
			return false;
		}

		$structure = str_replace( '%day%', '', $structure );
		$structure = preg_replace( '#/+#', '/', $structure );

		return $structure;
	}

	/**
	 * Retrieves the day permalink structure with month and year.
	 *
	 * Keeps date permalink structure with all year, month, and day.
	 *
	 * @since 1.5.0
	 *
	 * @return string|false Year/Month/Day permalink structure on success, false on failure.
	 */
	public function get_day_permastruct() {
		return $this-&gt;get_date_permastruct();
	}

	/**
	 * Retrieves the permalink structure for categories.
	 *
	 * If the category_base property has no value, then the category structure
	 * will have the front property value, followed by 'category', and finally
	 * '%category%'. If it does, then the root property will be used, along with
	 * the category_base property value.
	 *
	 * @since 1.5.0
	 *
	 * @return string|false Category permalink structure on success, false on failure.
	 */
	public function get_category_permastruct() {
		return $this-&gt;get_extra_permastruct( 'category' );
	}

	/**
	 * Retrieves the permalink structure for tags.
	 *
	 * If the tag_base property has no value, then the tag structure will have
	 * the front property value, followed by 'tag', and finally '%tag%'. If it
	 * does, then the root property will be used, along with the tag_base
	 * property value.
	 *
	 * @since 2.3.0
	 *
	 * @return string|false Tag permalink structure on success, false on failure.
	 */
	public function get_tag_permastruct() {
		return $this-&gt;get_extra_permastruct( 'post_tag' );
	}

	/**
	 * Retrieves an extra permalink structure by name.
	 *
	 * @since 2.5.0
	 *
	 * @param string $name Permalink structure name.
	 * @return string|false Permalink structure string on success, false on failure.
	 */
	public function get_extra_permastruct( $name ) {
		if ( empty( $this-&gt;permalink_structure ) ) {
			return false;
		}

		if ( isset( $this-&gt;extra_permastructs[ $name ] ) ) {
			return $this-&gt;extra_permastructs[ $name ]['struct'];
		}

		return false;
	}

	/**
	 * Retrieves the author permalink structure.
	 *
	 * The permalink structure is front property, author base, and finally
	 * '/%author%'. Will set the author_structure property and then return it
	 * without attempting to set the value again.
	 *
	 * @since 1.5.0
	 *
	 * @return string|false Author permalink structure on success, false on failure.
	 */
	public function get_author_permastruct() {
		if ( isset( $this-&gt;author_structure ) ) {
			return $this-&gt;author_structure;
		}

		if ( empty( $this-&gt;permalink_structure ) ) {
			$this-&gt;author_structure = '';
			return false;
		}

		$this-&gt;author_structure = $this-&gt;front . $this-&gt;author_base . '/%author%';

		return $this-&gt;author_structure;
	}

	/**
	 * Retrieves the search permalink structure.
	 *
	 * The permalink structure is root property, search base, and finally
	 * '/%search%'. Will set the search_structure property and then return it
	 * without attempting to set the value again.
	 *
	 * @since 1.5.0
	 *
	 * @return string|false Search permalink structure on success, false on failure.
	 */
	public function get_search_permastruct() {
		if ( isset( $this-&gt;search_structure ) ) {
			return $this-&gt;search_structure;
		}

		if ( empty( $this-&gt;permalink_structure ) ) {
			$this-&gt;search_structure = '';
			return false;
		}

		$this-&gt;search_structure = $this-&gt;root . $this-&gt;search_base . '/%search%';

		return $this-&gt;search_structure;
	}

	/**
	 * Retrieves the page permalink structure.
	 *
	 * The permalink structure is root property, and '%pagename%'. Will set the
	 * page_structure property and then return it without attempting to set the
	 * value again.
	 *
	 * @since 1.5.0
	 *
	 * @return string|false Page permalink structure on success, false on failure.
	 */
	public function get_page_permastruct() {
		if ( isset( $this-&gt;page_structure ) ) {
			return $this-&gt;page_structure;
		}

		if ( empty( $this-&gt;permalink_structure ) ) {
			$this-&gt;page_structure = '';
			return false;
		}

		$this-&gt;page_structure = $this-&gt;root . '%pagename%';

		return $this-&gt;page_structure;
	}

	/**
	 * Retrieves the feed permalink structure.
	 *
	 * The permalink structure is root property, feed base, and finally
	 * '/%feed%'. Will set the feed_structure property and then return it
	 * without attempting to set the value again.
	 *
	 * @since 1.5.0
	 *
	 * @return string|false Feed permalink structure on success, false on failure.
	 */
	public function get_feed_permastruct() {
		if ( isset( $this-&gt;feed_structure ) ) {
			return $this-&gt;feed_structure;
		}

		if ( empty( $this-&gt;permalink_structure ) ) {
			$this-&gt;feed_structure = '';
			return false;
		}

		$this-&gt;feed_structure = $this-&gt;root . $this-&gt;feed_base . '/%feed%';

		return $this-&gt;feed_structure;
	}

	/**
	 * Retrieves the comment feed permalink structure.
	 *
	 * The permalink structure is root property, comment base property, feed
	 * base and finally '/%feed%'. Will set the comment_feed_structure property
	 * and then return it without attempting to set the value again.
	 *
	 * @since 1.5.0
	 *
	 * @return string|false Comment feed permalink structure on success, false on failure.
	 */
	public function get_comment_feed_permastruct() {
		if ( isset( $this-&gt;comment_feed_structure ) ) {
			return $this-&gt;comment_feed_structure;
		}

		if ( empty( $this-&gt;permalink_structure ) ) {
			$this-&gt;comment_feed_structure = '';
			return false;
		}

		$this-&gt;comment_feed_structure = $this-&gt;root . $this-&gt;comments_base . '/' . $this-&gt;feed_base . '/%feed%';

		return $this-&gt;comment_feed_structure;
	}

	/**
	 * Adds or updates existing rewrite tags (e.g. %postname%).
	 *
	 * If the tag already exists, replace the existing pattern and query for
	 * that tag, otherwise add the new tag.
	 *
	 * @since 1.5.0
	 *
	 * @see WP_Rewrite::$rewritecode
	 * @see WP_Rewrite::$rewritereplace
	 * @see WP_Rewrite::$queryreplace
	 *
	 * @param string $tag   Name of the rewrite tag to add or update.
	 * @param string $regex Regular expression to substitute the tag for in rewrite rules.
	 * @param string $query String to append to the rewritten query. Must end in '='.
	 */
	public function add_rewrite_tag( $tag, $regex, $query ) {
		$position = array_search( $tag, $this-&gt;rewritecode, true );
		if ( false !== $position &amp;&amp; null !== $position ) {
			$this-&gt;rewritereplace[ $position ] = $regex;
			$this-&gt;queryreplace[ $position ]   = $query;
		} else {
			$this-&gt;rewritecode[]    = $tag;
			$this-&gt;rewritereplace[] = $regex;
			$this-&gt;queryreplace[]   = $query;
		}
	}


	/**
	 * Removes an existing rewrite tag.
	 *
	 * @since 4.5.0
	 *
	 * @see WP_Rewrite::$rewritecode
	 * @see WP_Rewrite::$rewritereplace
	 * @see WP_Rewrite::$queryreplace
	 *
	 * @param string $tag Name of the rewrite tag to remove.
	 */
	public function remove_rewrite_tag( $tag ) {
		$position = array_search( $tag, $this-&gt;rewritecode, true );
		if ( false !== $position &amp;&amp; null !== $position ) {
			unset( $this-&gt;rewritecode[ $position ] );
			unset( $this-&gt;rewritereplace[ $position ] );
			unset( $this-&gt;queryreplace[ $position ] );
		}
	}

	/**
	 * Generates rewrite rules from a permalink structure.
	 *
	 * The main WP_Rewrite function for building the rewrite rule list. The
	 * contents of the function is a mix of black magic and regular expressions,
	 * so best just ignore the contents and move to the parameters.
	 *
	 * @since 1.5.0
	 *
	 * @param string $permalink_structure The permalink structure.
	 * @param int    $ep_mask             Optional. Endpoint mask defining what endpoints are added to the structure.
	 *                                    Accepts a mask of:
	 *                                    - `EP_ALL`
	 *                                    - `EP_NONE`
	 *                                    - `EP_ALL_ARCHIVES`
	 *                                    - `EP_ATTACHMENT`
	 *                                    - `EP_AUTHORS`
	 *                                    - `EP_CATEGORIES`
	 *                                    - `EP_COMMENTS`
	 *                                    - `EP_DATE`
	 *                                    - `EP_DAY`
	 *                                    - `EP_MONTH`
	 *                                    - `EP_PAGES`
	 *                                    - `EP_PERMALINK`
	 *                                    - `EP_ROOT`
	 *                                    - `EP_SEARCH`
	 *                                    - `EP_TAGS`
	 *                                    - `EP_YEAR`
	 *                                    Default `EP_NONE`.
	 * @param bool   $paged               Optional. Whether archive pagination rules should be added for the structure.
	 *                                    Default true.
	 * @param bool   $feed                Optional. Whether feed rewrite rules should be added for the structure.
	 *                                    Default true.
	 * @param bool   $forcomments         Optional. Whether the feed rules should be a query for a comments feed.
	 *                                    Default false.
	 * @param bool   $walk_dirs           Optional. Whether the 'directories' making up the structure should be walked
	 *                                    over and rewrite rules built for each in-turn. Default true.
	 * @param bool   $endpoints           Optional. Whether endpoints should be applied to the generated rewrite rules.
	 *                                    Default true.
	 * @return string[] Array of rewrite rules keyed by their regex pattern.
	 */
	public function generate_rewrite_rules( $permalink_structure, $ep_mask = EP_NONE, $paged = true, $feed = true, $forcomments = false, $walk_dirs = true, $endpoints = true ) {
		// Build a regex to match the feed section of URLs, something like (feed|atom|rss|rss2)/?
		$feedregex2 = '';
		foreach ( (array) $this-&gt;feeds as $feed_name ) {
			$feedregex2 .= $feed_name . '|';
		}
		$feedregex2 = '(' . trim( $feedregex2, '|' ) . ')/?$';

		/*
		 * $feedregex is identical but with /feed/ added on as well, so URLs like &lt;permalink&gt;/feed/atom
		 * and &lt;permalink&gt;/atom are both possible
		 */
		$feedregex = $this-&gt;feed_base . '/' . $feedregex2;

		// Build a regex to match the trackback and page/xx parts of URLs.
		$trackbackregex = 'trackback/?$';
		$pageregex      = $this-&gt;pagination_base . '/?([0-9]{1,})/?$';
		$commentregex   = $this-&gt;comments_pagination_base . '-([0-9]{1,})/?$';
		$embedregex     = 'embed/?$';

		// Build up an array of endpoint regexes to append =&gt; queries to append.
		if ( $endpoints ) {
			$ep_query_append = array();
			foreach ( (array) $this-&gt;endpoints as $endpoint ) {
				// Match everything after the endpoint name, but allow for nothing to appear there.
				$epmatch = $endpoint[1] . '(/(.*))?/?$';

				// This will be appended on to the rest of the query for each dir.
				$epquery                     = '&amp;' . $endpoint[2] . '=';
				$ep_query_append[ $epmatch ] = array( $endpoint[0], $epquery );
			}
		}

		// Get everything up to the first rewrite tag.
		$front = substr( $permalink_structure, 0, strpos( $permalink_structure, '%' ) );

		// Build an array of the tags (note that said array ends up being in $tokens[0]).
		preg_match_all( '/%.+?%/', $permalink_structure, $tokens );

		$num_tokens = count( $tokens[0] );

		$index          = $this-&gt;index; // Probably 'index.php'.
		$feedindex      = $index;
		$trackbackindex = $index;
		$embedindex     = $index;

		/*
		 * Build a list from the rewritecode and queryreplace arrays, that will look something
		 * like tagname=$matches[i] where i is the current $i.
		 */
		$queries = array();
		for ( $i = 0; $i &lt; $num_tokens; ++$i ) {
			if ( 0 &lt; $i ) {
				$queries[ $i ] = $queries[ $i - 1 ] . '&amp;';
			} else {
				$queries[ $i ] = '';
			}

			$query_token    = str_replace( $this-&gt;rewritecode, $this-&gt;queryreplace, $tokens[0][ $i ] ) . $this-&gt;preg_index( $i + 1 );
			$queries[ $i ] .= $query_token;
		}

		// Get the structure, minus any cruft (stuff that isn't tags) at the front.
		$structure = $permalink_structure;
		if ( '/' !== $front ) {
			$structure = str_replace( $front, '', $structure );
		}

		/*
		 * Create a list of dirs to walk over, making rewrite rules for each level
		 * so for example, a $structure of /%year%/%monthnum%/%postname% would create
		 * rewrite rules for /%year%/, /%year%/%monthnum%/ and /%year%/%monthnum%/%postname%
		 */
		$structure = trim( $structure, '/' );
		$dirs      = $walk_dirs ? explode( '/', $structure ) : array( $structure );
		$num_dirs  = count( $dirs );

		// Strip slashes from the front of $front.
		$front = preg_replace( '|^/+|', '', $front );

		// The main workhorse loop.
		$post_rewrite = array();
		$struct       = $front;
		for ( $j = 0; $j &lt; $num_dirs; ++$j ) {
			// Get the struct for this dir, and trim slashes off the front.
			$struct .= $dirs[ $j ] . '/'; // Accumulate. see comment near explode('/', $structure) above.
			$struct  = ltrim( $struct, '/' );

			// Replace tags with regexes.
			$match = str_replace( $this-&gt;rewritecode, $this-&gt;rewritereplace, $struct );

			// Make a list of tags, and store how many there are in $num_toks.
			$num_toks = preg_match_all( '/%.+?%/', $struct, $toks );

			// Get the 'tagname=$matches[i]'.
			$query = ( ! empty( $num_toks ) &amp;&amp; isset( $queries[ $num_toks - 1 ] ) ) ? $queries[ $num_toks - 1 ] : '';

			// Set up $ep_mask_specific which is used to match more specific URL types.
			switch ( $dirs[ $j ] ) {
				case '%year%':
					$ep_mask_specific = EP_YEAR;
					break;
				case '%monthnum%':
					$ep_mask_specific = EP_MONTH;
					break;
				case '%day%':
					$ep_mask_specific = EP_DAY;
					break;
				default:
					$ep_mask_specific = EP_NONE;
			}

			// Create query for /page/xx.
			$pagematch = $match . $pageregex;
			$pagequery = $index . '?' . $query . '&amp;paged=' . $this-&gt;preg_index( $num_toks + 1 );

			// Create query for /comment-page-xx.
			$commentmatch = $match . $commentregex;
			$commentquery = $index . '?' . $query . '&amp;cpage=' . $this-&gt;preg_index( $num_toks + 1 );

			if ( get_option( 'page_on_front' ) ) {
				// Create query for Root /comment-page-xx.
				$rootcommentmatch = $match . $commentregex;
				$rootcommentquery = $index . '?' . $query . '&amp;page_id=' . get_option( 'page_on_front' ) . '&amp;cpage=' . $this-&gt;preg_index( $num_toks + 1 );
			}

			// Create query for /feed/(feed|atom|rss|rss2|rdf).
			$feedmatch = $match . $feedregex;
			$feedquery = $feedindex . '?' . $query . '&amp;feed=' . $this-&gt;preg_index( $num_toks + 1 );

			// Create query for /(feed|atom|rss|rss2|rdf) (see comment near creation of $feedregex).
			$feedmatch2 = $match . $feedregex2;
			$feedquery2 = $feedindex . '?' . $query . '&amp;feed=' . $this-&gt;preg_index( $num_toks + 1 );

			// Create query and regex for embeds.
			$embedmatch = $match . $embedregex;
			$embedquery = $embedindex . '?' . $query . '&amp;embed=true';

			// If asked to, turn the feed queries into comment feed ones.
			if ( $forcomments ) {
				$feedquery  .= '&amp;withcomments=1';
				$feedquery2 .= '&amp;withcomments=1';
			}

			// Start creating the array of rewrites for this dir.
			$rewrite = array();

			// ...adding on /feed/ regexes =&gt; queries.
			if ( $feed ) {
				$rewrite = array(
					$feedmatch  =&gt; $feedquery,
					$feedmatch2 =&gt; $feedquery2,
					$embedmatch =&gt; $embedquery,
				);
			}

			// ...and /page/xx ones.
			if ( $paged ) {
				$rewrite = array_merge( $rewrite, array( $pagematch =&gt; $pagequery ) );
			}

			// Only on pages with comments add ../comment-page-xx/.
			if ( EP_PAGES &amp; $ep_mask || EP_PERMALINK &amp; $ep_mask ) {
				$rewrite = array_merge( $rewrite, array( $commentmatch =&gt; $commentquery ) );
			} elseif ( EP_ROOT &amp; $ep_mask &amp;&amp; get_option( 'page_on_front' ) ) {
				$rewrite = array_merge( $rewrite, array( $rootcommentmatch =&gt; $rootcommentquery ) );
			}

			// Do endpoints.
			if ( $endpoints ) {
				foreach ( (array) $ep_query_append as $regex =&gt; $ep ) {
					// Add the endpoints on if the mask fits.
					if ( $ep[0] &amp; $ep_mask || $ep[0] &amp; $ep_mask_specific ) {
						$rewrite[ $match . $regex ] = $index . '?' . $query . $ep[1] . $this-&gt;preg_index( $num_toks + 2 );
					}
				}
			}

			// If we've got some tags in this dir.
			if ( $num_toks ) {
				$post = false;
				$page = false;

				/*
				 * Check to see if this dir is permalink-level: i.e. the structure specifies an
				 * individual post. Do this by checking it contains at least one of 1) post name,
				 * 2) post ID, 3) page name, 4) timestamp (year, month, day, hour, second and
				 * minute all present). Set these flags now as we need them for the endpoints.
				 */
				if ( strpos( $struct, '%postname%' ) !== false
						|| strpos( $struct, '%post_id%' ) !== false
						|| strpos( $struct, '%pagename%' ) !== false
						|| ( strpos( $struct, '%year%' ) !== false &amp;&amp; strpos( $struct, '%monthnum%' ) !== false &amp;&amp; strpos( $struct, '%day%' ) !== false &amp;&amp; strpos( $struct, '%hour%' ) !== false &amp;&amp; strpos( $struct, '%minute%' ) !== false &amp;&amp; strpos( $struct, '%second%' ) !== false )
						) {
					$post = true;
					if ( strpos( $struct, '%pagename%' ) !== false ) {
						$page = true;
					}
				}

				if ( ! $post ) {
					// For custom post types, we need to add on endpoints as well.
					foreach ( get_post_types( array( '_builtin' =&gt; false ) ) as $ptype ) {
						if ( strpos( $struct, "%$ptype%" ) !== false ) {
							$post = true;

							// This is for page style attachment URLs.
							$page = is_post_type_hierarchical( $ptype );
							break;
						}
					}
				}

				// If creating rules for a permalink, do all the endpoints like attachments etc.
				if ( $post ) {
					// Create query and regex for trackback.
					$trackbackmatch = $match . $trackbackregex;
					$trackbackquery = $trackbackindex . '?' . $query . '&amp;tb=1';

					// Create query and regex for embeds.
					$embedmatch = $match . $embedregex;
					$embedquery = $embedindex . '?' . $query . '&amp;embed=true';

					// Trim slashes from the end of the regex for this dir.
					$match = rtrim( $match, '/' );

					// Get rid of brackets.
					$submatchbase = str_replace( array( '(', ')' ), '', $match );

					// Add a rule for at attachments, which take the form of &lt;permalink&gt;/some-text.
					$sub1 = $submatchbase . '/([^/]+)/';

					// Add trackback regex &lt;permalink&gt;/trackback/...
					$sub1tb = $sub1 . $trackbackregex;

					// And &lt;permalink&gt;/feed/(atom|...)
					$sub1feed = $sub1 . $feedregex;

					// And &lt;permalink&gt;/(feed|atom...)
					$sub1feed2 = $sub1 . $feedregex2;

					// And &lt;permalink&gt;/comment-page-xx
					$sub1comment = $sub1 . $commentregex;

					// And &lt;permalink&gt;/embed/...
					$sub1embed = $sub1 . $embedregex;

					/*
					 * Add another rule to match attachments in the explicit form:
					 * &lt;permalink&gt;/attachment/some-text
					 */
					$sub2 = $submatchbase . '/attachment/([^/]+)/';

					// And add trackbacks &lt;permalink&gt;/attachment/trackback.
					$sub2tb = $sub2 . $trackbackregex;

					// Feeds, &lt;permalink&gt;/attachment/feed/(atom|...)
					$sub2feed = $sub2 . $feedregex;

					// And feeds again on to this &lt;permalink&gt;/attachment/(feed|atom...)
					$sub2feed2 = $sub2 . $feedregex2;

					// And &lt;permalink&gt;/comment-page-xx
					$sub2comment = $sub2 . $commentregex;

					// And &lt;permalink&gt;/embed/...
					$sub2embed = $sub2 . $embedregex;

					// Create queries for these extra tag-ons we've just dealt with.
					$subquery        = $index . '?attachment=' . $this-&gt;preg_index( 1 );
					$subtbquery      = $subquery . '&amp;tb=1';
					$subfeedquery    = $subquery . '&amp;feed=' . $this-&gt;preg_index( 2 );
					$subcommentquery = $subquery . '&amp;cpage=' . $this-&gt;preg_index( 2 );
					$subembedquery   = $subquery . '&amp;embed=true';

					// Do endpoints for attachments.
					if ( ! empty( $endpoints ) ) {
						foreach ( (array) $ep_query_append as $regex =&gt; $ep ) {
							if ( $ep[0] &amp; EP_ATTACHMENT ) {
								$rewrite[ $sub1 . $regex ] = $subquery . $ep[1] . $this-&gt;preg_index( 3 );
								$rewrite[ $sub2 . $regex ] = $subquery . $ep[1] . $this-&gt;preg_index( 3 );
							}
						}
					}

					/*
					 * Now we've finished with endpoints, finish off the $sub1 and $sub2 matches
					 * add a ? as we don't have to match that last slash, and finally a $ so we
					 * match to the end of the URL
					 */
					$sub1 .= '?$';
					$sub2 .= '?$';

					/*
					 * Post pagination, e.g. &lt;permalink&gt;/2/
					 * Previously: '(/[0-9]+)?/?$', which produced '/2' for page.
					 * When cast to int, returned 0.
					 */
					$match = $match . '(?:/([0-9]+))?/?$';
					$query = $index . '?' . $query . '&amp;page=' . $this-&gt;preg_index( $num_toks + 1 );

					// Not matching a permalink so this is a lot simpler.
				} else {
					// Close the match and finalize the query.
					$match .= '?$';
					$query  = $index . '?' . $query;
				}

				/*
				 * Create the final array for this dir by joining the $rewrite array (which currently
				 * only contains rules/queries for trackback, pages etc) to the main regex/query for
				 * this dir
				 */
				$rewrite = array_merge( $rewrite, array( $match =&gt; $query ) );

				// If we're matching a permalink, add those extras (attachments etc) on.
				if ( $post ) {
					// Add trackback.
					$rewrite = array_merge( array( $trackbackmatch =&gt; $trackbackquery ), $rewrite );

					// Add embed.
					$rewrite = array_merge( array( $embedmatch =&gt; $embedquery ), $rewrite );

					// Add regexes/queries for attachments, attachment trackbacks and so on.
					if ( ! $page ) {
						// Require &lt;permalink&gt;/attachment/stuff form for pages because of confusion with subpages.
						$rewrite = array_merge(
							$rewrite,
							array(
								$sub1        =&gt; $subquery,
								$sub1tb      =&gt; $subtbquery,
								$sub1feed    =&gt; $subfeedquery,
								$sub1feed2   =&gt; $subfeedquery,
								$sub1comment =&gt; $subcommentquery,
								$sub1embed   =&gt; $subembedquery,
							)
						);
					}

					$rewrite = array_merge(
						array(
							$sub2        =&gt; $subquery,
							$sub2tb      =&gt; $subtbquery,
							$sub2feed    =&gt; $subfeedquery,
							$sub2feed2   =&gt; $subfeedquery,
							$sub2comment =&gt; $subcommentquery,
							$sub2embed   =&gt; $subembedquery,
						),
						$rewrite
					);
				}
			}
			// Add the rules for this dir to the accumulating $post_rewrite.
			$post_rewrite = array_merge( $rewrite, $post_rewrite );
		}

		// The finished rules. phew!
		return $post_rewrite;
	}

	/**
	 * Generates rewrite rules with permalink structure and walking directory only.
	 *
	 * Shorten version of WP_Rewrite::generate_rewrite_rules() that allows for shorter
	 * list of parameters. See the method for longer description of what generating
	 * rewrite rules does.
	 *
	 * @since 1.5.0
	 *
	 * @see WP_Rewrite::generate_rewrite_rules() See for long description and rest of parameters.
	 *
	 * @param string $permalink_structure The permalink structure to generate rules.
	 * @param bool   $walk_dirs           Optional. Whether to create list of directories to walk over.
	 *                                    Default false.
	 * @return array An array of rewrite rules keyed by their regex pattern.
	 */
	public function generate_rewrite_rule( $permalink_structure, $walk_dirs = false ) {
		return $this-&gt;generate_rewrite_rules( $permalink_structure, EP_NONE, false, false, false, $walk_dirs );
	}

	/**
	 * Constructs rewrite matches and queries from permalink structure.
	 *
	 * Runs the action {@see 'generate_rewrite_rules'} with the parameter that is an
	 * reference to the current WP_Rewrite instance to further manipulate the
	 * permalink structures and rewrite rules. Runs the {@see 'rewrite_rules_array'}
	 * filter on the full rewrite rule array.
	 *
	 * There are two ways to manipulate the rewrite rules, one by hooking into
	 * the {@see 'generate_rewrite_rules'} action and gaining full control of the
	 * object or just manipulating the rewrite rule array before it is passed
	 * from the function.
	 *
	 * @since 1.5.0
	 *
	 * @return string[] An associative array of matches and queries.
	 */
	public function rewrite_rules() {
		$rewrite = array();

		if ( empty( $this-&gt;permalink_structure ) ) {
			return $rewrite;
		}

		// robots.txt -- only if installed at the root.
		$home_path      = parse_url( home_url() );
		$robots_rewrite = ( empty( $home_path['path'] ) || '/' === $home_path['path'] ) ? array( 'robots\.txt$' =&gt; $this-&gt;index . '?robots=1' ) : array();

		// favicon.ico -- only if installed at the root.
		$favicon_rewrite = ( empty( $home_path['path'] ) || '/' === $home_path['path'] ) ? array( 'favicon\.ico$' =&gt; $this-&gt;index . '?favicon=1' ) : array();

		// Old feed and service files.
		$deprecated_files = array(
			'.*wp-(atom|rdf|rss|rss2|feed|commentsrss2)\.php$' =&gt; $this-&gt;index . '?feed=old',
			'.*wp-app\.php(/.*)?$' =&gt; $this-&gt;index . '?error=403',
		);

		// Registration rules.
		$registration_pages = array();
		if ( is_multisite() &amp;&amp; is_main_site() ) {
			$registration_pages['.*wp-signup.php$']   = $this-&gt;index . '?signup=true';
			$registration_pages['.*wp-activate.php$'] = $this-&gt;index . '?activate=true';
		}

		// Deprecated.
		$registration_pages['.*wp-register.php$'] = $this-&gt;index . '?register=true';

		// Post rewrite rules.
		$post_rewrite = $this-&gt;generate_rewrite_rules( $this-&gt;permalink_structure, EP_PERMALINK );

		/**
		 * Filters rewrite rules used for "post" archives.
		 *
		 * @since 1.5.0
		 *
		 * @param string[] $post_rewrite Array of rewrite rules for posts, keyed by their regex pattern.
		 */
		$post_rewrite = apply_filters( 'post_rewrite_rules', $post_rewrite );

		// Date rewrite rules.
		$date_rewrite = $this-&gt;generate_rewrite_rules( $this-&gt;get_date_permastruct(), EP_DATE );

		/**
		 * Filters rewrite rules used for date archives.
		 *
		 * Likely date archives would include `/yyyy/`, `/yyyy/mm/`, and `/yyyy/mm/dd/`.
		 *
		 * @since 1.5.0
		 *
		 * @param string[] $date_rewrite Array of rewrite rules for date archives, keyed by their regex pattern.
		 */
		$date_rewrite = apply_filters( 'date_rewrite_rules', $date_rewrite );

		// Root-level rewrite rules.
		$root_rewrite = $this-&gt;generate_rewrite_rules( $this-&gt;root . '/', EP_ROOT );

		/**
		 * Filters rewrite rules used for root-level archives.
		 *
		 * Likely root-level archives would include pagination rules for the homepage
		 * as well as site-wide post feeds (e.g. `/feed/`, and `/feed/atom/`).
		 *
		 * @since 1.5.0
		 *
		 * @param string[] $root_rewrite Array of root-level rewrite rules, keyed by their regex pattern.
		 */
		$root_rewrite = apply_filters( 'root_rewrite_rules', $root_rewrite );

		// Comments rewrite rules.
		$comments_rewrite = $this-&gt;generate_rewrite_rules( $this-&gt;root . $this-&gt;comments_base, EP_COMMENTS, false, true, true, false );

		/**
		 * Filters rewrite rules used for comment feed archives.
		 *
		 * Likely comments feed archives include `/comments/feed/` and `/comments/feed/atom/`.
		 *
		 * @since 1.5.0
		 *
		 * @param string[] $comments_rewrite Array of rewrite rules for the site-wide comments feeds, keyed by their regex pattern.
		 */
		$comments_rewrite = apply_filters( 'comments_rewrite_rules', $comments_rewrite );

		// Search rewrite rules.
		$search_structure = $this-&gt;get_search_permastruct();
		$search_rewrite   = $this-&gt;generate_rewrite_rules( $search_structure, EP_SEARCH );

		/**
		 * Filters rewrite rules used for search archives.
		 *
		 * Likely search-related archives include `/search/search+query/` as well as
		 * pagination and feed paths for a search.
		 *
		 * @since 1.5.0
		 *
		 * @param string[] $search_rewrite Array of rewrite rules for search queries, keyed by their regex pattern.
		 */
		$search_rewrite = apply_filters( 'search_rewrite_rules', $search_rewrite );

		// Author rewrite rules.
		$author_rewrite = $this-&gt;generate_rewrite_rules( $this-&gt;get_author_permastruct(), EP_AUTHORS );

		/**
		 * Filters rewrite rules used for author archives.
		 *
		 * Likely author archives would include `/author/author-name/`, as well as
		 * pagination and feed paths for author archives.
		 *
		 * @since 1.5.0
		 *
		 * @param string[] $author_rewrite Array of rewrite rules for author archives, keyed by their regex pattern.
		 */
		$author_rewrite = apply_filters( 'author_rewrite_rules', $author_rewrite );

		// Pages rewrite rules.
		$page_rewrite = $this-&gt;page_rewrite_rules();

		/**
		 * Filters rewrite rules used for "page" post type archives.
		 *
		 * @since 1.5.0
		 *
		 * @param string[] $page_rewrite Array of rewrite rules for the "page" post type, keyed by their regex pattern.
		 */
		$page_rewrite = apply_filters( 'page_rewrite_rules', $page_rewrite );

		// Extra permastructs.
		foreach ( $this-&gt;extra_permastructs as $permastructname =&gt; $struct ) {
			if ( is_array( $struct ) ) {
				if ( count( $struct ) == 2 ) {
					$rules = $this-&gt;generate_rewrite_rules( $struct[0], $struct[1] );
				} else {
					$rules = $this-&gt;generate_rewrite_rules( $struct['struct'], $struct['ep_mask'], $struct['paged'], $struct['feed'], $struct['forcomments'], $struct['walk_dirs'], $struct['endpoints'] );
				}
			} else {
				$rules = $this-&gt;generate_rewrite_rules( $struct );
			}

			/**
			 * Filters rewrite rules used for individual permastructs.
			 *
			 * The dynamic portion of the hook name, `$permastructname`, refers
			 * to the name of the registered permastruct.
			 *
			 * Possible hook names include:
			 *
			 *  - `category_rewrite_rules`
			 *  - `post_format_rewrite_rules`
			 *  - `post_tag_rewrite_rules`
			 *
			 * @since 3.1.0
			 *
			 * @param string[] $rules Array of rewrite rules generated for the current permastruct, keyed by their regex pattern.
			 */
			$rules = apply_filters( "{$permastructname}_rewrite_rules", $rules );

			if ( 'post_tag' === $permastructname ) {

				/**
				 * Filters rewrite rules used specifically for Tags.
				 *
				 * @since 2.3.0
				 * @deprecated 3.1.0 Use {@see 'post_tag_rewrite_rules'} instead.
				 *
				 * @param string[] $rules Array of rewrite rules generated for tags, keyed by their regex pattern.
				 */
				$rules = apply_filters_deprecated( 'tag_rewrite_rules', array( $rules ), '3.1.0', 'post_tag_rewrite_rules' );
			}

			$this-&gt;extra_rules_top = array_merge( $this-&gt;extra_rules_top, $rules );
		}

		// Put them together.
		if ( $this-&gt;use_verbose_page_rules ) {
			$this-&gt;rules = array_merge( $this-&gt;extra_rules_top, $robots_rewrite, $favicon_rewrite, $deprecated_files, $registration_pages, $root_rewrite, $comments_rewrite, $search_rewrite, $author_rewrite, $date_rewrite, $page_rewrite, $post_rewrite, $this-&gt;extra_rules );
		} else {
			$this-&gt;rules = array_merge( $this-&gt;extra_rules_top, $robots_rewrite, $favicon_rewrite, $deprecated_files, $registration_pages, $root_rewrite, $comments_rewrite, $search_rewrite, $author_rewrite, $date_rewrite, $post_rewrite, $page_rewrite, $this-&gt;extra_rules );
		}

		/**
		 * Fires after the rewrite rules are generated.
		 *
		 * @since 1.5.0
		 *
		 * @param WP_Rewrite $wp_rewrite Current WP_Rewrite instance (passed by reference).
		 */
		do_action_ref_array( 'generate_rewrite_rules', array( &amp;$this ) );

		/**
		 * Filters the full set of generated rewrite rules.
		 *
		 * @since 1.5.0
		 *
		 * @param string[] $rules The compiled array of rewrite rules, keyed by their regex pattern.
		 */
		$this-&gt;rules = apply_filters( 'rewrite_rules_array', $this-&gt;rules );

		return $this-&gt;rules;
	}

	/**
	 * Retrieves the rewrite rules.
	 *
	 * The difference between this method and WP_Rewrite::rewrite_rules() is that
	 * this method stores the rewrite rules in the 'rewrite_rules' option and retrieves
	 * it. This prevents having to process all of the permalinks to get the rewrite rules
	 * in the form of caching.
	 *
	 * @since 1.5.0
	 *
	 * @return string[] Array of rewrite rules keyed by their regex pattern.
	 */
	public function wp_rewrite_rules() {
		$this-&gt;rules = get_option( 'rewrite_rules' );
		if ( empty( $this-&gt;rules ) ) {
			$this-&gt;matches = 'matches';
			$this-&gt;rewrite_rules();
			if ( ! did_action( 'wp_loaded' ) ) {
				add_action( 'wp_loaded', array( $this, 'flush_rules' ) );
				return $this-&gt;rules;
			}
			update_option( 'rewrite_rules', $this-&gt;rules );
		}

		return $this-&gt;rules;
	}

	/**
	 * Retrieves mod_rewrite-formatted rewrite rules to write to .htaccess.
	 *
	 * Does not actually write to the .htaccess file, but creates the rules for
	 * the process that will.
	 *
	 * Will add the non_wp_rules property rules to the .htaccess file before
	 * the WordPress rewrite rules one.
	 *
	 * @since 1.5.0
	 *
	 * @return string
	 */
	public function mod_rewrite_rules() {
		if ( ! $this-&gt;using_permalinks() ) {
			return '';
		}

		$site_root = parse_url( site_url() );
		if ( isset( $site_root['path'] ) ) {
			$site_root = trailingslashit( $site_root['path'] );
		}

		$home_root = parse_url( home_url() );
		if ( isset( $home_root['path'] ) ) {
			$home_root = trailingslashit( $home_root['path'] );
		} else {
			$home_root = '/';
		}

		$rules  = "&lt;IfModule mod_rewrite.c&gt;\n";
		$rules .= "RewriteEngine On\n";
		$rules .= "RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n";
		$rules .= "RewriteBase $home_root\n";

		// Prevent -f checks on index.php.
		$rules .= "RewriteRule ^index\.php$ - [L]\n";

		// Add in the rules that don't redirect to WP's index.php (and thus shouldn't be handled by WP at all).
		foreach ( (array) $this-&gt;non_wp_rules as $match =&gt; $query ) {
			// Apache 1.3 does not support the reluctant (non-greedy) modifier.
			$match = str_replace( '.+?', '.+', $match );

			$rules .= 'RewriteRule ^' . $match . ' ' . $home_root . $query . " [QSA,L]\n";
		}

		if ( $this-&gt;use_verbose_rules ) {
			$this-&gt;matches = '';
			$rewrite       = $this-&gt;rewrite_rules();
			$num_rules     = count( $rewrite );
			$rules        .= "RewriteCond %{REQUEST_FILENAME} -f [OR]\n" .
				"RewriteCond %{REQUEST_FILENAME} -d\n" .
				"RewriteRule ^.*$ - [S=$num_rules]\n";

			foreach ( (array) $rewrite as $match =&gt; $query ) {
				// Apache 1.3 does not support the reluctant (non-greedy) modifier.
				$match = str_replace( '.+?', '.+', $match );

				if ( strpos( $query, $this-&gt;index ) !== false ) {
					$rules .= 'RewriteRule ^' . $match . ' ' . $home_root . $query . " [QSA,L]\n";
				} else {
					$rules .= 'RewriteRule ^' . $match . ' ' . $site_root . $query . " [QSA,L]\n";
				}
			}
		} else {
			$rules .= "RewriteCond %{REQUEST_FILENAME} !-f\n" .
				"RewriteCond %{REQUEST_FILENAME} !-d\n" .
				"RewriteRule . {$home_root}{$this-&gt;index} [L]\n";
		}

		$rules .= "&lt;/IfModule&gt;\n";

		/**
		 * Filters the list of rewrite rules formatted for output to an .htaccess file.
		 *
		 * @since 1.5.0
		 *
		 * @param string $rules mod_rewrite Rewrite rules formatted for .htaccess.
		 */
		$rules = apply_filters( 'mod_rewrite_rules', $rules );

		/**
		 * Filters the list of rewrite rules formatted for output to an .htaccess file.
		 *
		 * @since 1.5.0
		 * @deprecated 1.5.0 Use the {@see 'mod_rewrite_rules'} filter instead.
		 *
		 * @param string $rules mod_rewrite Rewrite rules formatted for .htaccess.
		 */
		return apply_filters_deprecated( 'rewrite_rules', array( $rules ), '1.5.0', 'mod_rewrite_rules' );
	}

	/**
	 * Retrieves IIS7 URL Rewrite formatted rewrite rules to write to web.config file.
	 *
	 * Does not actually write to the web.config file, but creates the rules for
	 * the process that will.
	 *
	 * @since 2.8.0
	 *
	 * @param bool $add_parent_tags Optional. Whether to add parent tags to the rewrite rule sets.
	 *                              Default false.
	 * @return string IIS7 URL rewrite rule sets.
	 */
	public function iis7_url_rewrite_rules( $add_parent_tags = false ) {
		if ( ! $this-&gt;using_permalinks() ) {
			return '';
		}
		$rules = '';
		if ( $add_parent_tags ) {
			$rules .= '&lt;configuration&gt;
	&lt;system.webServer&gt;
		&lt;rewrite&gt;
			&lt;rules&gt;';
		}

		$rules .= '
			&lt;rule name="WordPress: ' . esc_attr( home_url() ) . '" patternSyntax="Wildcard"&gt;
				&lt;match url="*" /&gt;
					&lt;conditions&gt;
						&lt;add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" /&gt;
						&lt;add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" /&gt;
					&lt;/conditions&gt;
				&lt;action type="Rewrite" url="index.php" /&gt;
			&lt;/rule&gt;';

		if ( $add_parent_tags ) {
			$rules .= '
			&lt;/rules&gt;
		&lt;/rewrite&gt;
	&lt;/system.webServer&gt;
&lt;/configuration&gt;';
		}

		/**
		 * Filters the list of rewrite rules formatted for output to a web.config.
		 *
		 * @since 2.8.0
		 *
		 * @param string $rules Rewrite rules formatted for IIS web.config.
		 */
		return apply_filters( 'iis7_url_rewrite_rules', $rules );
	}

	/**
	 * Adds a rewrite rule that transforms a URL structure to a set of query vars.
	 *
	 * Any value in the $after parameter that isn't 'bottom' will result in the rule
	 * being placed at the top of the rewrite rules.
	 *
	 * @since 2.1.0
	 * @since 4.4.0 Array support was added to the `$query` parameter.
	 *
	 * @param string       $regex Regular expression to match request against.
	 * @param string|array $query The corresponding query vars for this rewrite rule.
	 * @param string       $after Optional. Priority of the new rule. Accepts 'top'
	 *                            or 'bottom'. Default 'bottom'.
	 */
	public function add_rule( $regex, $query, $after = 'bottom' ) {
		if ( is_array( $query ) ) {
			$external = false;
			$query    = add_query_arg( $query, 'index.php' );
		} else {
			$index = false === strpos( $query, '?' ) ? strlen( $query ) : strpos( $query, '?' );
			$front = substr( $query, 0, $index );

			$external = $front != $this-&gt;index;
		}

		// "external" = it doesn't correspond to index.php.
		if ( $external ) {
			$this-&gt;add_external_rule( $regex, $query );
		} else {
			if ( 'bottom' === $after ) {
				$this-&gt;extra_rules = array_merge( $this-&gt;extra_rules, array( $regex =&gt; $query ) );
			} else {
				$this-&gt;extra_rules_top = array_merge( $this-&gt;extra_rules_top, array( $regex =&gt; $query ) );
			}
		}
	}

	/**
	 * Adds a rewrite rule that doesn't correspond to index.php.
	 *
	 * @since 2.1.0
	 *
	 * @param string $regex Regular expression to match request against.
	 * @param string $query The corresponding query vars for this rewrite rule.
	 */
	public function add_external_rule( $regex, $query ) {
		$this-&gt;non_wp_rules[ $regex ] = $query;
	}

	/**
	 * Adds an endpoint, like /trackback/.
	 *
	 * @since 2.1.0
	 * @since 3.9.0 $query_var parameter added.
	 * @since 4.3.0 Added support for skipping query var registration by passing `false` to `$query_var`.
	 *
	 * @see add_rewrite_endpoint() for full documentation.
	 * @global WP $wp Current WordPress environment instance.
	 *
	 * @param string      $name      Name of the endpoint.
	 * @param int         $places    Endpoint mask describing the places the endpoint should be added.
	 *                               Accepts a mask of:
	 *                               - `EP_ALL`
	 *                               - `EP_NONE`
	 *                               - `EP_ALL_ARCHIVES`
	 *                               - `EP_ATTACHMENT`
	 *                               - `EP_AUTHORS`
	 *                               - `EP_CATEGORIES`
	 *                               - `EP_COMMENTS`
	 *                               - `EP_DATE`
	 *                               - `EP_DAY`
	 *                               - `EP_MONTH`
	 *                               - `EP_PAGES`
	 *                               - `EP_PERMALINK`
	 *                               - `EP_ROOT`
	 *                               - `EP_SEARCH`
	 *                               - `EP_TAGS`
	 *                               - `EP_YEAR`
	 * @param string|bool $query_var Optional. Name of the corresponding query variable. Pass `false` to
	 *                               skip registering a query_var for this endpoint. Defaults to the
	 *                               value of `$name`.
	 */
	public function add_endpoint( $name, $places, $query_var = true ) {
		global $wp;

		// For backward compatibility, if null has explicitly been passed as `$query_var`, assume `true`.
		if ( true === $query_var || null === $query_var ) {
			$query_var = $name;
		}
		$this-&gt;endpoints[] = array( $places, $name, $query_var );

		if ( $query_var ) {
			$wp-&gt;add_query_var( $query_var );
		}
	}

	/**
	 * Adds a new permalink structure.
	 *
	 * A permalink structure (permastruct) is an abstract definition of a set of rewrite rules;
	 * it is an easy way of expressing a set of regular expressions that rewrite to a set of
	 * query strings. The new permastruct is added to the WP_Rewrite::$extra_permastructs array.
	 *
	 * When the rewrite rules are built by WP_Rewrite::rewrite_rules(), all of these extra
	 * permastructs are passed to WP_Rewrite::generate_rewrite_rules() which transforms them
	 * into the regular expressions that many love to hate.
	 *
	 * The `$args` parameter gives you control over how WP_Rewrite::generate_rewrite_rules()
	 * works on the new permastruct.
	 *
	 * @since 2.5.0
	 *
	 * @param string $name   Name for permalink structure.
	 * @param string $struct Permalink structure (e.g. category/%category%)
	 * @param array  $args   {
	 *     Optional. Arguments for building rewrite rules based on the permalink structure.
	 *     Default empty array.
	 *
	 *     @type bool $with_front  Whether the structure should be prepended with `WP_Rewrite::$front`.
	 *                             Default true.
	 *     @type int  $ep_mask     The endpoint mask defining which endpoints are added to the structure.
	 *                             Accepts a mask of:
	 *                             - `EP_ALL`
	 *                             - `EP_NONE`
	 *                             - `EP_ALL_ARCHIVES`
	 *                             - `EP_ATTACHMENT`
	 *                             - `EP_AUTHORS`
	 *                             - `EP_CATEGORIES`
	 *                             - `EP_COMMENTS`
	 *                             - `EP_DATE`
	 *                             - `EP_DAY`
	 *                             - `EP_MONTH`
	 *                             - `EP_PAGES`
	 *                             - `EP_PERMALINK`
	 *                             - `EP_ROOT`
	 *                             - `EP_SEARCH`
	 *                             - `EP_TAGS`
	 *                             - `EP_YEAR`
	 *                             Default `EP_NONE`.
	 *     @type bool $paged       Whether archive pagination rules should be added for the structure.
	 *                             Default true.
	 *     @type bool $feed        Whether feed rewrite rules should be added for the structure. Default true.
	 *     @type bool $forcomments Whether the feed rules should be a query for a comments feed. Default false.
	 *     @type bool $walk_dirs   Whether the 'directories' making up the structure should be walked over
	 *                             and rewrite rules built for each in-turn. Default true.
	 *     @type bool $endpoints   Whether endpoints should be applied to the generated rules. Default true.
	 * }
	 */
	public function add_permastruct( $name, $struct, $args = array() ) {
		// Back-compat for the old parameters: $with_front and $ep_mask.
		if ( ! is_array( $args ) ) {
			$args = array( 'with_front' =&gt; $args );
		}
		if ( func_num_args() == 4 ) {
			$args['ep_mask'] = func_get_arg( 3 );
		}

		$defaults = array(
			'with_front'  =&gt; true,
			'ep_mask'     =&gt; EP_NONE,
			'paged'       =&gt; true,
			'feed'        =&gt; true,
			'forcomments' =&gt; false,
			'walk_dirs'   =&gt; true,
			'endpoints'   =&gt; true,
		);
		$args     = array_intersect_key( $args, $defaults );
		$args     = wp_parse_args( $args, $defaults );

		if ( $args['with_front'] ) {
			$struct = $this-&gt;front . $struct;
		} else {
			$struct = $this-&gt;root . $struct;
		}
		$args['struct'] = $struct;

		$this-&gt;extra_permastructs[ $name ] = $args;
	}

	/**
	 * Removes a permalink structure.
	 *
	 * @since 4.5.0
	 *
	 * @param string $name Name for permalink structure.
	 */
	public function remove_permastruct( $name ) {
		unset( $this-&gt;extra_permastructs[ $name ] );
	}

	/**
	 * Removes rewrite rules and then recreate rewrite rules.
	 *
	 * Calls WP_Rewrite::wp_rewrite_rules() after removing the 'rewrite_rules' option.
	 * If the function named 'save_mod_rewrite_rules' exists, it will be called.
	 *
	 * @since 2.0.1
	 *
	 * @param bool $hard Whether to update .htaccess (hard flush) or just update rewrite_rules option (soft flush). Default is true (hard).
	 */
	public function flush_rules( $hard = true ) {
		static $do_hard_later = null;

		// Prevent this action from running before everyone has registered their rewrites.
		if ( ! did_action( 'wp_loaded' ) ) {
			add_action( 'wp_loaded', array( $this, 'flush_rules' ) );
			$do_hard_later = ( isset( $do_hard_later ) ) ? $do_hard_later || $hard : $hard;
			return;
		}

		if ( isset( $do_hard_later ) ) {
			$hard = $do_hard_later;
			unset( $do_hard_later );
		}

		update_option( 'rewrite_rules', '' );
		$this-&gt;wp_rewrite_rules();

		/**
		 * Filters whether a "hard" rewrite rule flush should be performed when requested.
		 *
		 * A "hard" flush updates .htaccess (Apache) or web.config (IIS).
		 *
		 * @since 3.7.0
		 *
		 * @param bool $hard Whether to flush rewrite rules "hard". Default true.
		 */
		if ( ! $hard || ! apply_filters( 'flush_rewrite_rules_hard', true ) ) {
			return;
		}
		if ( function_exists( 'save_mod_rewrite_rules' ) ) {
			save_mod_rewrite_rules();
		}
		if ( function_exists( 'iis7_save_url_rewrite_rules' ) ) {
			iis7_save_url_rewrite_rules();
		}
	}

	/**
	 * Sets up the object's properties.
	 *
	 * The 'use_verbose_page_rules' object property will be set to true if the
	 * permalink structure begins with one of the following: '%postname%', '%category%',
	 * '%tag%', or '%author%'.
	 *
	 * @since 1.5.0
	 */
	public function init() {
		$this-&gt;extra_rules         = array();
		$this-&gt;non_wp_rules        = array();
		$this-&gt;endpoints           = array();
		$this-&gt;permalink_structure = get_option( 'permalink_structure' );
		$this-&gt;front               = substr( $this-&gt;permalink_structure, 0, strpos( $this-&gt;permalink_structure, '%' ) );
		$this-&gt;root                = '';

		if ( $this-&gt;using_index_permalinks() ) {
			$this-&gt;root = $this-&gt;index . '/';
		}

		unset( $this-&gt;author_structure );
		unset( $this-&gt;date_structure );
		unset( $this-&gt;page_structure );
		unset( $this-&gt;search_structure );
		unset( $this-&gt;feed_structure );
		unset( $this-&gt;comment_feed_structure );

		$this-&gt;use_trailing_slashes = ( '/' === substr( $this-&gt;permalink_structure, -1, 1 ) );

		// Enable generic rules for pages if permalink structure doesn't begin with a wildcard.
		if ( preg_match( '/^[^%]*%(?:postname|category|tag|author)%/', $this-&gt;permalink_structure ) ) {
			$this-&gt;use_verbose_page_rules = true;
		} else {
			$this-&gt;use_verbose_page_rules = false;
		}
	}

	/**
	 * Sets the main permalink structure for the site.
	 *
	 * Will update the 'permalink_structure' option, if there is a difference
	 * between the current permalink structure and the parameter value. Calls
	 * WP_Rewrite::init() after the option is updated.
	 *
	 * Fires the {@see 'permalink_structure_changed'} action once the init call has
	 * processed passing the old and new values
	 *
	 * @since 1.5.0
	 *
	 * @param string $permalink_structure Permalink structure.
	 */
	public function set_permalink_structure( $permalink_structure ) {
		if ( $permalink_structure != $this-&gt;permalink_structure ) {
			$old_permalink_structure = $this-&gt;permalink_structure;
			update_option( 'permalink_structure', $permalink_structure );

			$this-&gt;init();

			/**
			 * Fires after the permalink structure is updated.
			 *
			 * @since 2.8.0
			 *
			 * @param string $old_permalink_structure The previous permalink structure.
			 * @param string $permalink_structure     The new permalink structure.
			 */
			do_action( 'permalink_structure_changed', $old_permalink_structure, $permalink_structure );
		}
	}

	/**
	 * Sets the category base for the category permalink.
	 *
	 * Will update the 'category_base' option, if there is a difference between
	 * the current category base and the parameter value. Calls WP_Rewrite::init()
	 * after the option is updated.
	 *
	 * @since 1.5.0
	 *
	 * @param string $category_base Category permalink structure base.
	 */
	public function set_category_base( $category_base ) {
		if ( get_option( 'category_base' ) !== $category_base ) {
			update_option( 'category_base', $category_base );
			$this-&gt;init();
		}
	}

	/**
	 * Sets the tag base for the tag permalink.
	 *
	 * Will update the 'tag_base' option, if there is a difference between the
	 * current tag base and the parameter value. Calls WP_Rewrite::init() after
	 * the option is updated.
	 *
	 * @since 2.3.0
	 *
	 * @param string $tag_base Tag permalink structure base.
	 */
	public function set_tag_base( $tag_base ) {
		if ( get_option( 'tag_base' ) !== $tag_base ) {
			update_option( 'tag_base', $tag_base );
			$this-&gt;init();
		}
	}

	/**
	 * Constructor - Calls init(), which runs setup.
	 *
	 * @since 1.5.0
	 */
	public function __construct() {
		$this-&gt;init();
	}
}
</code></pre>  </section>  <section> <header class="toc-header"><h2 id="changelog">Changelog</h2></header> <table>  <thead> <tr> <th class="changelog-version">Version</th> <th class="changelog-desc">Description</th> </tr> </thead> <tbody> <tr> <td><a href="https://developer.wordpress.org/reference/since/1.5.0/" alt="WordPress 1.5.0">1.5.0</a></td> <td>Introduced.</td> </tr> </tbody> </table> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2003&ndash;2022 WordPress Foundation<br>Licensed under the GNU GPLv2+ License.<br>
    <a href="https://developer.wordpress.org/reference/classes/wp_rewrite" class="_attribution-link">https://developer.wordpress.org/reference/classes/wp_rewrite</a>
  </p>
</div>
