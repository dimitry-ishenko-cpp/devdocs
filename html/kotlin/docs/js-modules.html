<h1 data-toc="js-modules" id="js-modules.md">JavaScript modules</h1>
<p id="cf23ec5c">You can compile your Kotlin projects to JavaScript modules for various popular module systems. We currently support the following configurations for JavaScript modules:</p>
<ul class="list _bullet" id="e7f94509">
<li class="list__item" id="b8cf2b80"><p><a href="https://github.com/umdjs/umd" id="f56cb6f1" data-external="true" rel="noopener noreferrer">Unified Module Definitions (UMD)</a>, which is compatible with both <em id="acafe131" class="">AMD</em> and <em id="b5d84814" class="">CommonJS</em>. UMD modules are also able to be executed without being imported or when no module system is present. This is the default option for the <code class="code ">browser</code> and <code class="code ">nodejs</code> targets.</p></li>
<li class="list__item" id="ca204082"><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" id="96706da6" data-external="true" rel="noopener noreferrer">Asynchronous Module Definitions (AMD)</a>, which is in particular used by the <a href="https://requirejs.org/" id="e5712f95" data-external="true" rel="noopener noreferrer">RequireJS</a> library.</p></li>
<li class="list__item" id="52017e8b"><p><a href="http://wiki.commonjs.org/wiki/Modules/1.1" id="c3ff3cb8" data-external="true" rel="noopener noreferrer">CommonJS</a>, widely used by Node.js/npm (<code class="code ">require</code> function and <code class="code ">module.exports</code> object)</p></li>
<li class="list__item" id="1b2914c2"><p>Plain. Don't compile for any module system. You can access a module by its name in the global scope.</p></li>
</ul>
<section class="chapter"><h2 id="browser-targets" data-toc="browser-targets">Browser targets</h2>
<p id="af5e3e27">If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the <code class="code ">webpackTask</code> configuration block. For example, to switch to CommonJS, use:</p>
<pre class="code" data-language="groovy">kotlin {
    js {
        browser {
            webpackTask {
                output.libraryTarget = "commonjs2"
            }
        }
        binaries.executable()
    }
}

</pre>
<p id="dace3631">Webpack provides two different "flavors" of CommonJS, <code class="code ">commonjs</code> and <code class="code ">commonjs2</code>, which affect the way your declarations are made available. While in most cases, you probably want <code class="code ">commonjs2</code>, which adds the <code class="code ">module.exports</code> syntax to the generated library, you can also opt for the "pure" <code class="code ">commonjs</code> option, which implements the CommonJS specification exactly. To learn more about the difference between <code class="code ">commonjs</code> and <code class="code ">commonjs2</code>, check <a href="https://github.com/webpack/webpack/issues/1114" id="7457f217" data-external="true" rel="noopener noreferrer">here</a>.</p></section><section class="chapter"><h2 id="javascript-libraries-and-node-js-files" data-toc="javascript-libraries-and-node-js-files">JavaScript libraries and Node.js files</h2>
<p id="7c9ffef">If you are creating a library that will be consumed from JavaScript or a Node.js file, and want to use a different module system, the instructions are slightly different.</p>
<section class="chapter"><h3 id="choose-the-target-module-system" data-toc="choose-the-target-module-system">Choose the target module system</h3>
<p id="a51a008b">To select module kind, set the <code class="code ">moduleKind</code> compiler option in the Gradle build script.</p>
<div class="tabs" id="6d7d8092" data-group="build-script" data-anchors="[c9d6899f,a3fa9e20,5e29a4fd,86bb4cd5,6d7d8092]">
<div class="tabs__content" data-gtm="tab" id="c9d6899f" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">tasks.named&lt;KotlinJsCompile&gt;("compileKotlinJs").configure {
    compilerOptions.moduleKind.set(org.jetbrains.kotlin.gradle.dsl.JsModuleKind.MODULE_COMMONJS)
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="5e29a4fd" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">compileKotlinJs.compilerOptions.moduleKind = org.jetbrains.kotlin.gradle.dsl.JsModuleKind.MODULE_COMMONJS
</pre></div>
</div>
<p id="9bf35617">Available values are: <code class="code ">umd</code> (default), <code class="code ">commonjs</code>, <code class="code ">amd</code>, <code class="code ">plain</code>.</p>
<aside data-type="note" class="prompt" data-title="" id="cf426e3e"><p id="ecd5afe">This is different from adjusting <code class="code ">webpackTask.output.libraryTarget</code>. The library target changes the output <em id="aec35db8" class="">generated by webpack</em> (after your code has already been compiled). <code class="code ">compilerOptions.moduleKind</code> changes the output generated <em id="a4aed810" class="">by the Kotlin compiler</em>.</p></aside><p id="215323cd">In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</p>
<pre class="code" data-language="kotlin">kotlin {
    js {
         useCommonJs()
         // ...
    }
}
</pre></section></section><section class="chapter"><h2 id="jsmodule-annotation" data-toc="jsmodule-annotation">@JsModule annotation</h2>
<p id="fccec4f6">To tell Kotlin that an <code class="code ">external</code> class, package, function or property is a JavaScript module, you can use <code class="code ">@JsModule</code> annotation. Consider you have the following CommonJS module called "hello":</p>
<pre class="code" data-language="javascript">module.exports.sayHello = function(name) { alert("Hello, " + name); }
</pre>
<p id="480ad873">You should declare it like this in Kotlin:</p>
<pre class="code" data-language="kotlin">@JsModule("hello")
external fun sayHello(name: String)
</pre>
<section class="chapter"><h3 id="apply-jsmodule-to-packages" data-toc="apply-jsmodule-to-packages">Apply @JsModule to packages</h3>
<p id="ae50a134">Some JavaScript libraries export packages (namespaces) instead of functions and classes. In terms of JavaScript, it's an <em id="a9935004" class="">object</em> that has <em id="67ab4127" class="">members</em> that are classes, functions and properties. Importing these packages as Kotlin objects often looks unnatural. The compiler can map imported JavaScript packages to Kotlin packages, using the following notation:</p>
<pre class="code" data-language="kotlin">@file:JsModule("extModule")
package ext.jspackage.name

external fun foo()

external class C
</pre>
<p id="cebf026e">where the corresponding JavaScript module is declared like this:</p>
<pre class="code" data-language="javascript">module.exports = {
    foo:  { /* some code here */ },
    C:  { /* some code here */ }
}
</pre>
<p id="6573a595">Files marked with <code class="code ">@file:JsModule</code> annotation can't declare non-external members. The example below produces a compile-time error:</p>
<pre class="code" data-language="kotlin">@file:JsModule("extModule")
package ext.jspackage.name

external fun foo()

fun bar() = "!" + foo() + "!" // error here
</pre></section><section class="chapter"><h3 id="import-deeper-package-hierarchies" data-toc="import-deeper-package-hierarchies">Import deeper package hierarchies</h3>
<p id="d995b18f">In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new <code class="code ">.kt</code> file for each package you import.</p>
<p id="4bf1ba47">For example, let's make the example a bit more complicated:</p>
<pre class="code" data-language="javascript">module.exports = {
    mylib: {
        pkg1: {
            foo: function() { /* some code here */ },
            bar: function() { /* some code here */ }
        },
        pkg2: {
            baz: function() { /* some code here */ }
        }
    }
}
</pre>
<p id="f74fb21e">To import this module in Kotlin, you have to write two Kotlin source files:</p>
<pre class="code" data-language="kotlin">@file:JsModule("extModule")
@file:JsQualifier("mylib.pkg1")
package extlib.pkg1

external fun foo()

external fun bar()
</pre>
<p id="3c7996c4">and</p>
<pre class="code" data-language="kotlin">@file:JsModule("extModule")
@file:JsQualifier("mylib.pkg2")
package extlib.pkg2

external fun baz()
</pre></section><section class="chapter"><h3 id="jsnonmodule-annotation" data-toc="jsnonmodule-annotation">@JsNonModule annotation</h3>
<p id="77ec11a1">When a declaration is marked as <code class="code ">@JsModule</code>, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable <code class="code ">.js</code> files that you can copy to your project's static resources and include via a <code class="code ">&lt;script&gt;</code> tag. To tell Kotlin that it's okay to use a <code class="code ">@JsModule</code> declaration from a non-module environment, add the <code class="code ">@JsNonModule</code> annotation. For example, consider the following JavaScript code:</p>
<pre class="code" data-language="javascript">function topLevelSayHello(name) { alert("Hello, " + name); }
if (module &amp;&amp; module.exports) {
    module.exports = topLevelSayHello;
}
</pre>
<p id="3da734c8">You could describe it from Kotlin as follows:</p>
<pre class="code" data-language="kotlin">@JsModule("hello")
@JsNonModule
@JsName("topLevelSayHello")
external fun sayHello(name: String)
</pre></section><section class="chapter"><h3 id="module-system-used-by-the-kotlin-standard-library" data-toc="module-system-used-by-the-kotlin-standard-library">Module system used by the Kotlin Standard Library</h3>
<p id="1a4bd1c4">Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on <code class="code ">kotlin-stdlib-js</code>, it is also available on NPM as the <a href="https://www.npmjs.com/package/kotlin" id="5a226985" data-external="true" rel="noopener noreferrer"><code class="code ">kotlin</code></a> package.</p></section></section><div class="last-modified"> Last modified: 11 May 2023</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="js-to-kotlin-interop.html">Use Kotlin code from JavaScript</a> <a class="navigation-links__next" href="js-reflection.html">Kotlin/JS reflection</a> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 JetBrains s.r.o. and Kotlin Programming Language contributors<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://kotlinlang.org/docs/js-modules.html" class="_attribution-link">https://kotlinlang.org/docs/js-modules.html</a>
  </p>
</div>
