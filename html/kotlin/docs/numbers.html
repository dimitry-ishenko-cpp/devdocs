<h1 data-toc="numbers" id="numbers.md">Numbers</h1>
<section class="chapter"><h2 id="integer-types" data-toc="integer-types">Integer types</h2>
<p id="966014a6">Kotlin provides a set of built-in types that represent numbers.<br> For integer numbers, there are four types with different sizes and, hence, value ranges:</p>
<div class="table-wrapper"><table class=" wide" id="45939c39">
<thead><tr class="ijRowHead" id="7019c44a">
<th id="55a25b79"><p>Type</p></th>
<th id="421a15d4"><p>Size (bits)</p></th>
<th id="1cd5b81e"><p>Min value</p></th>
<th id="3ab0729a"><p>Max value</p></th>
</tr></thead>
<tbody>
<tr class="" id="f72fffd2">
<td id="f6c3fab1"><p><code class="code ">Byte</code></p></td>
<td id="1bb6e612"><p>8</p></td>
<td id="df2cf28d"><p>-128</p></td>
<td id="46d29121"><p>127</p></td>
</tr>
<tr class="" id="715d9206">
<td id="2e41e754"><p><code class="code ">Short</code></p></td>
<td id="f6fddd12"><p>16</p></td>
<td id="eb91be1c"><p>-32768</p></td>
<td id="b79e500"><p>32767</p></td>
</tr>
<tr class="" id="bb36d67f">
<td id="d0c11a49"><p><code class="code ">Int</code></p></td>
<td id="c1bf88b2"><p>32</p></td>
<td id="6a04787a"><p>-2,147,483,648 (-2<sup class="superscript" id="d9ad5c73">31</sup>)</p></td>
<td id="1fbd34f"><p>2,147,483,647 (2<sup class="superscript" id="d750272e">31</sup> - 1)</p></td>
</tr>
<tr class="" id="3adbec68">
<td id="78bd9c7a"><p><code class="code ">Long</code></p></td>
<td id="f1c47fda"><p>64</p></td>
<td id="bcede044"><p>-9,223,372,036,854,775,808 (-2<sup class="superscript" id="784dc71a">63</sup>)</p></td>
<td id="f9d85832"><p>9,223,372,036,854,775,807 (2<sup class="superscript" id="d2777f6c">63</sup> - 1)</p></td>
</tr>
</tbody>
</table></div>
<p id="101a00">When you initialize a variable with no explicit type specification, the compiler automatically infers the type with the smallest range enough to represent the value. If it is not exceeding the range of <code class="code ">Int</code>, the type is <code class="code ">Int</code>. If it exceeds, the type is <code class="code ">Long</code>. To specify the <code class="code ">Long</code> value explicitly, append the suffix <code class="code ">L</code> to the value. Explicit type specification triggers the compiler to check the value not to exceed the range of the specified type.</p>
<pre class="code" data-language="kotlin">val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1
</pre>
<aside data-type="tip" class="prompt" data-title="" id="eb138fba"><p id="34b93625">In addition to integer types, Kotlin also provides unsigned integer types. For more information, see <a href="unsigned-integer-types.html" id="7b08b447">Unsigned integer types</a>.</p></aside></section><section class="chapter"><h2 id="floating-point-types" data-toc="floating-point-types">Floating-point types</h2>
<p id="6df38f96">For real numbers, Kotlin provides floating-point types <code class="code ">Float</code> and <code class="code ">Double</code> that adhere to the <a href="https://en.wikipedia.org/wiki/IEEE_754" id="72b0a932" data-external="true" rel="noopener noreferrer">IEEE 754 standard</a>. <code class="code ">Float</code> reflects the IEEE 754 <em id="11cfbd2" class="">single precision</em>, while <code class="code ">Double</code> reflects <em id="e0211f5f" class="">double precision</em>.</p>
<p id="30f2cdd3">These types differ in their size and provide storage for floating-point numbers with different precision:</p>
<div class="table-wrapper"><table class=" wide" id="e94e4dc2">
<thead><tr class="ijRowHead" id="41ecc3f3">
<th id="28020a93"><p>Type</p></th>
<th id="304e0ab0"><p>Size (bits)</p></th>
<th id="78146b9b"><p>Significant bits</p></th>
<th id="c547de47"><p>Exponent bits</p></th>
<th id="1974eb74"><p>Decimal digits</p></th>
</tr></thead>
<tbody>
<tr class="" id="21353cbb">
<td id="39e3040d"><p><code class="code ">Float</code></p></td>
<td id="7fbab818"><p>32</p></td>
<td id="61a4fe1a"><p>24</p></td>
<td id="a235db7"><p>8</p></td>
<td id="6d462233"><p>6-7</p></td>
</tr>
<tr class="" id="24f739d9">
<td id="b15514f3"><p><code class="code ">Double</code></p></td>
<td id="8be2c5e5"><p>64</p></td>
<td id="2d6bf46a"><p>53</p></td>
<td id="53d8ceeb"><p>11</p></td>
<td id="4e94c9f6"><p>15-16</p></td>
</tr>
</tbody>
</table></div>
<p id="fe5f958e">You can initialize <code class="code ">Double</code> and <code class="code ">Float</code> variables with numbers having a fractional part. It's separated from the integer part by a period (<code class="code ">.</code>) For variables initialized with fractional numbers, the compiler infers the <code class="code ">Double</code> type:</p>
<pre class="code" data-language="kotlin">val pi = 3.14 // Double
// val one: Double = 1 // Error: type mismatch
val oneDouble = 1.0 // Double
</pre>
<p id="b8051f1e">To explicitly specify the <code class="code ">Float</code> type for a value, add the suffix <code class="code ">f</code> or <code class="code ">F</code>. If such a value contains more than 6-7 decimal digits, it will be rounded:</p>
<pre class="code" data-language="kotlin">val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float, actual value is 2.7182817
</pre>
<p id="d72a581d">Unlike some other languages, there are no implicit widening conversions for numbers in Kotlin. For example, a function with a <code class="code ">Double</code> parameter can be called only on <code class="code ">Double</code> values, but not <code class="code ">Float</code>, <code class="code ">Int</code>, or other numeric values:</p>
<pre class="code" data-language="kotlin">fun main() {
    fun printDouble(d: Double) { print(d) }

    val i = 1    
    val d = 1.0
    val f = 1.0f 

    printDouble(d)
//    printDouble(i) // Error: Type mismatch
//    printDouble(f) // Error: Type mismatch
}
</pre>
<p id="888dbde3">To convert numeric values to different types, use <a href="#explicit-number-conversions" id="c1bcb189">explicit conversions</a>.</p></section><section class="chapter"><h2 id="literal-constants-for-numbers" data-toc="literal-constants-for-numbers">Literal constants for numbers</h2>
<p id="b00fe14">There are the following kinds of literal constants for integral values:</p>
<ul class="list _bullet" id="176e07e6">
<li class="list__item" id="84974d7f"><p>Decimals: <code class="code ">123</code></p></li>
<li class="list__item" id="44c3c854"><p>Longs are tagged by a capital <code class="code ">L</code>: <code class="code ">123L</code></p></li>
<li class="list__item" id="e05b3c5e"><p>Hexadecimals: <code class="code ">0x0F</code></p></li>
<li class="list__item" id="dd46cae9"><p>Binaries: <code class="code ">0b00001011</code></p></li>
</ul>
<aside data-type="note" class="prompt" data-title="" id="5f1a8caf"><p id="8ec5faee">Octal literals are not supported in Kotlin.</p></aside><p id="3a227fce">Kotlin also supports a conventional notation for floating-point numbers:</p>
<ul class="list _bullet" id="8898a93e">
<li class="list__item" id="fa19f045"><p>Doubles by default: <code class="code ">123.5</code>, <code class="code ">123.5e10</code></p></li>
<li class="list__item" id="7bdecbbb"><p>Floats are tagged by <code class="code ">f</code> or <code class="code ">F</code>: <code class="code ">123.5f</code></p></li>
</ul>
<p id="1d704a60">You can use underscores to make number constants more readable:</p>
<pre class="code" data-language="kotlin">val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
</pre>
<aside data-type="tip" class="prompt" data-title="" id="c9c2b56a"><p id="99a9829c">There are also special tags for unsigned integer literals.<br> Read more about <a href="unsigned-integer-types.html" id="b2fdf0ab">literals for unsigned integer types</a>.</p></aside></section><section class="chapter"><h2 id="numbers-representation-on-the-jvm" data-toc="numbers-representation-on-the-jvm">Numbers representation on the JVM</h2>
<p id="ec1a8c15">On the JVM platform, numbers are stored as primitive types: <code class="code ">int</code>, <code class="code ">double</code>, and so on. Exceptions are cases when you create a nullable number reference such as <code class="code ">Int?</code> or use generics. In these cases numbers are boxed in Java classes <code class="code ">Integer</code>, <code class="code ">Double</code>, and so on.</p>
<p id="262d0638">Nullable references to the same number can refer to different objects:</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val a: Int = 100
    val boxedA: Int? = a
    val anotherBoxedA: Int? = a
    
    val b: Int = 10000
    val boxedB: Int? = b
    val anotherBoxedB: Int? = b
    
    println(boxedA === anotherBoxedA) // true
    println(boxedB === anotherBoxedB) // false
//sampleEnd
}
</pre>
<p id="6d72dc6b">All nullable references to <code class="code ">a</code> are actually the same object because of the memory optimization that JVM applies to <code class="code ">Integer</code>s between <code class="code ">-128</code> and <code class="code ">127</code>. It doesn't apply to the <code class="code ">b</code> references, so they are different objects.</p>
<p id="31b2ab31">On the other hand, they are still equal:</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val b: Int = 10000
    println(b == b) // Prints 'true'
    val boxedB: Int? = b
    val anotherBoxedB: Int? = b
    println(boxedB == anotherBoxedB) // Prints 'true'
//sampleEnd
}
</pre></section><section class="chapter"><h2 id="explicit-number-conversions" data-toc="explicit-number-conversions">Explicit number conversions</h2>
<p id="40e8bcca">Due to different representations, smaller types <em id="325087ed" class="">are not subtypes</em> of bigger ones. If they were, we would have troubles of the following sort:</p>
<pre class="code" data-language="kotlin">// Hypothetical code, does not actually compile:
val a: Int? = 1 // A boxed Int (java.lang.Integer)
val b: Long? = a // Implicit conversion yields a boxed Long (java.lang.Long)
print(b == a) // Surprise! This prints "false" as Long's equals() checks whether the other is Long as well
</pre>
<p id="62f8cbf3">So equality would have been lost silently, not to mention identity.</p>
<p id="5b544216">As a consequence, smaller types <em id="529f85d8" class="">are NOT implicitly converted</em> to bigger types. This means that assigning a value of type <code class="code ">Byte</code> to an <code class="code ">Int</code> variable requires an explicit conversion:</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val b: Byte = 1 // OK, literals are checked statically
    // val i: Int = b // ERROR
    val i1: Int = b.toInt()
//sampleEnd
}
</pre>
<p id="fc4f4738">All number types support conversions to other types:</p>
<ul class="list _bullet" id="65d0fb1c">
<li class="list__item" id="4c0eb532"><p><code class="code ">toByte(): Byte</code></p></li>
<li class="list__item" id="b62c5add"><p><code class="code ">toShort(): Short</code></p></li>
<li class="list__item" id="40d5b2d3"><p><code class="code ">toInt(): Int</code></p></li>
<li class="list__item" id="71fd74fb"><p><code class="code ">toLong(): Long</code></p></li>
<li class="list__item" id="1ed6f978"><p><code class="code ">toFloat(): Float</code></p></li>
<li class="list__item" id="a20b339a"><p><code class="code ">toDouble(): Double</code></p></li>
</ul>
<p id="285d0f3d">In many cases, there is no need for explicit conversions because the type is inferred from the context, and arithmetical operations are overloaded for appropriate conversions, for example:</p>
<pre class="code" data-language="kotlin">val l = 1L + 3 // Long + Int =&gt; Long
</pre></section><section class="chapter"><h2 id="operations-on-numbers" data-toc="operations-on-numbers">Operations on numbers</h2>
<p id="46354530">Kotlin supports the standard set of arithmetical operations over numbers: <code class="code ">+</code>, <code class="code ">-</code>, <code class="code ">*</code>, <code class="code ">/</code>, <code class="code ">%</code>. They are declared as members of appropriate classes:</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    println(1 + 2)
    println(2_500_000_000L - 1L)
    println(3.14 * 2.71)
    println(10.0 / 3)
//sampleEnd
}
</pre>
<p id="21eddb1">You can also override these operators for custom classes. See <a href="operator-overloading.html" id="ea6664f4">Operator overloading</a> for details.</p>
<section class="chapter"><h3 id="division-of-integers" data-toc="division-of-integers">Division of integers</h3>
<p id="d0d34076">Division between integers numbers always returns an integer number. Any fractional part is discarded.</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val x = 5 / 2
    //println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'
    println(x == 2)
//sampleEnd
}
</pre>
<p id="97c2f111">This is true for a division between any two integer types:</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val x = 5L / 2
    println(x == 2L)
//sampleEnd
}
</pre>
<p id="b48eeb58">To return a floating-point type, explicitly convert one of the arguments to a floating-point type:</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val x = 5 / 2.toDouble()
    println(x == 2.5)
//sampleEnd
}
</pre></section><section class="chapter"><h3 id="bitwise-operations" data-toc="bitwise-operations">Bitwise operations</h3>
<p id="61980711">Kotlin provides a set of <em id="15b67b0b" class="">bitwise operations</em> on integer numbers. They operate on the binary level directly with bits of the numbers' representation. Bitwise operations are represented by functions that can be called in infix form. They can be applied only to <code class="code ">Int</code> and <code class="code ">Long</code>:</p>
<pre class="code" data-language="kotlin">val x = (1 shl 2) and 0x000FF000
</pre>
<p id="e5329870">Here is the complete list of bitwise operations:</p>
<ul class="list _bullet" id="a7d383b">
<li class="list__item" id="94bd3d79"><p><code class="code ">shl(bits)</code> – signed shift left</p></li>
<li class="list__item" id="72813859"><p><code class="code ">shr(bits)</code> – signed shift right</p></li>
<li class="list__item" id="59711128"><p><code class="code ">ushr(bits)</code> – unsigned shift right</p></li>
<li class="list__item" id="e477fb4f"><p><code class="code ">and(bits)</code> – bitwise <b id="93be14b1" class="">AND</b></p></li>
<li class="list__item" id="9523f9a6"><p><code class="code ">or(bits)</code> – bitwise <b id="8b54754d" class="">OR</b></p></li>
<li class="list__item" id="3e3d4200"><p><code class="code ">xor(bits)</code> – bitwise <b id="19d26c3a" class="">XOR</b></p></li>
<li class="list__item" id="eaa80e45"><p><code class="code ">inv()</code> – bitwise inversion</p></li>
</ul></section><section class="chapter"><h3 id="floating-point-numbers-comparison" data-toc="floating-point-numbers-comparison">Floating-point numbers comparison</h3>
<p id="f945fcc">The operations on floating-point numbers discussed in this section are:</p>
<ul class="list _bullet" id="a4f0f1eb">
<li class="list__item" id="8814a96e"><p>Equality checks: <code class="code ">a == b</code> and <code class="code ">a != b</code></p></li>
<li class="list__item" id="dc4daaa3"><p>Comparison operators: <code class="code ">a &lt; b</code>, <code class="code ">a &gt; b</code>, <code class="code ">a &lt;= b</code>, <code class="code ">a &gt;= b</code></p></li>
<li class="list__item" id="939e2413"><p>Range instantiation and range checks: <code class="code ">a..b</code>, <code class="code ">x in a..b</code>, <code class="code ">x !in a..b</code></p></li>
</ul>
<p id="740c0878">When the operands <code class="code ">a</code> and <code class="code ">b</code> are statically known to be <code class="code ">Float</code> or <code class="code ">Double</code> or their nullable counterparts (the type is declared or inferred or is a result of a <a href="typecasts.html#smart-casts" id="43b6ea5f">smart cast</a>), the operations on the numbers and the range that they form follow the <a href="https://en.wikipedia.org/wiki/IEEE_754" id="e2be61a3" data-external="true" rel="noopener noreferrer">IEEE 754 Standard for Floating-Point Arithmetic</a>.</p>
<p id="bf6c5fa0">However, to support generic use cases and provide total ordering, the behavior is different for operands that are <b id="d6e7a559" class="">not</b> statically typed as floating-point numbers. For example, <code class="code ">Any</code>, <code class="code ">Comparable&lt;...&gt;</code>, or <code class="code ">Collection&lt;T&gt;</code> types. In this case, the operations use the <code class="code ">equals</code> and <code class="code ">compareTo</code> implementations for <code class="code ">Float</code> and <code class="code ">Double</code>. As a result:</p>
<ul class="list _bullet" id="c13a92b0">
<li class="list__item" id="952338ba"><p><code class="code ">NaN</code> is considered equal to itself</p></li>
<li class="list__item" id="26f2dd9"><p><code class="code ">NaN</code> is considered greater than any other element including <code class="code ">POSITIVE_INFINITY</code></p></li>
<li class="list__item" id="939b0b91"><p><code class="code ">-0.0</code> is considered less than <code class="code ">0.0</code></p></li>
</ul>
<p id="113b1de9">Here is an example that shows the difference in behavior between operands statically typed as floating-point numbers (<code class="code ">Double.NaN</code>) and operands <b id="349293ac" class="">not</b> statically typed as floating-point numbers (<code class="code ">listOf(T)</code>).</p>
<pre class="code" data-language="kotlin">fun main() {
    //sampleStart
    println(Double.NaN == Double.NaN)                 // false
    println(listOf(Double.NaN) == listOf(Double.NaN)) // true
    
    println(0.0 == -0.0)                              // true
    println(listOf(0.0) == listOf(-0.0))              // false

    println(listOf(Double.NaN, Double.POSITIVE_INFINITY, 0.0, -0.0).sorted())
    // [-0.0, 0.0, Infinity, NaN]
    //sampleEnd
}
</pre></section></section><div class="last-modified"> Last modified: 26 April 2023</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="basic-types.html">Basic types</a> <a class="navigation-links__next" href="unsigned-integer-types.html">Unsigned integer types</a> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 JetBrains s.r.o. and Kotlin Programming Language contributors<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://kotlinlang.org/docs/numbers.html" class="_attribution-link">https://kotlinlang.org/docs/numbers.html</a>
  </p>
</div>
