<header> <h1>Svelte 5 migration guide</h1></header> <aside class="on-this-page svelte-ro60mh"><label class="svelte-ro60mh"> <h3 class="svelte-ro60mh">On this page</h3></label> <nav class="svelte-ro60mh"><ul class="svelte-ro60mh">
<li class="svelte-ro60mh"><a href="v5-migration-guide.html" class="svelte-ro60mh active">Svelte 5 migration guide</a></li> <li class="svelte-ro60mh"><a href="#Reactivity-syntax-changes" class="svelte-ro60mh ">Reactivity syntax changes</a></li>
<li class="svelte-ro60mh"><a href="#Event-changes" class="svelte-ro60mh ">Event changes</a></li>
<li class="svelte-ro60mh"><a href="#Snippets-instead-of-slots" class="svelte-ro60mh ">Snippets instead of slots</a></li>
<li class="svelte-ro60mh"><a href="#Migration-script" class="svelte-ro60mh ">Migration script</a></li>
<li class="svelte-ro60mh"><a href="#Components-are-no-longer-classes" class="svelte-ro60mh ">Components are no longer classes</a></li>
<li class="svelte-ro60mh"><a href="#Whitespace-handling-changed" class="svelte-ro60mh ">Whitespace handling changed</a></li>
<li class="svelte-ro60mh"><a href="#Modern-browser-required" class="svelte-ro60mh ">Modern browser required</a></li>
<li class="svelte-ro60mh"><a href="#Changes-to-compiler-options" class="svelte-ro60mh ">Changes to compiler options</a></li>
<li class="svelte-ro60mh"><a href="#The-children-prop-is-reserved" class="svelte-ro60mh ">The children prop is reserved</a></li>
<li class="svelte-ro60mh"><a href="#Dot-notation-indicates-a-component" class="svelte-ro60mh ">Dot notation indicates a component</a></li>
<li class="svelte-ro60mh"><a href="#Breaking-changes-in-runes-mode" class="svelte-ro60mh ">Breaking changes in runes mode</a></li>
<li class="svelte-ro60mh"><a href="#Other-breaking-changes" class="svelte-ro60mh ">Other breaking changes</a></li>
</ul></nav></aside> <div class="text content"><div class="text svelte-1uul45">
<p>Version 5 comes with an overhauled syntax and reactivity system. While it may look different at first, you’ll soon notice many similarities. This guide goes over the changes in detail and shows you how to upgrade. Along with it, we also provide information on <em>why</em> we did these changes.</p> <p>You don’t have to migrate to the new syntax right away - Svelte 5 still supports the old Svelte 4 syntax, and you can mix and match components using the new syntax with components using the old and vice versa. We expect many people to be able to upgrade with only a few lines of code changed initially. There’s also a <a href="#Migration-script">migration script</a> that helps you with many of these steps automatically.</p> <h2 id="Reactivity-syntax-changes">
<span>Reactivity syntax changes</span>
</h2>
<p>At the heart of Svelte 5 is the new runes API. Runes are basically compiler instructions that inform Svelte about reactivity. Syntactically, runes are functions starting with a dollar-sign.</p> <h3 id="Reactivity-syntax-changes-let-$state">
<span>let -&gt; $state</span>
</h3>
<p>In Svelte 4, a <code>let</code> declaration at the top level of a component was implicitly reactive. In Svelte 5, things are more explicit: a variable is reactive when created using the <code>$state</code> rune. Let’s migrate the counter to runes mode by wrapping the counter in <code>$state</code>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let count = $state(0);
&lt;/script&gt;</pre>
</div>
<p>Nothing else changes. <code>count</code> is still the number itself, and you read and write directly to it, without a wrapper like <code>.value</code> or <code>getCount()</code>.</p> <blockquote class="note"><details><summary>Why we did this</summary><p> <code>let</code> being implicitly reactive at the top level worked great, but it meant that reactivity was constrained - a <code>let</code> declaration anywhere else was not reactive. This forced you to resort to using stores when refactoring code out of the top level of components for reuse. This meant you had to learn an entirely separate reactivity model, and the result often wasn’t as nice to work with. Because reactivity is more explicit in Svelte 5, you can keep using the same API outside the top level of components. Head to <a href="https://svelte.dev/tutorial">the tutorial</a> to learn more.</p> </details></blockquote>
<h3 id="Reactivity-syntax-changes-$:-$derived-$effect">
<span>$: -&gt; $derived/$effect</span>
</h3>
<p>In Svelte 4, a <code>$:</code> statement at the top level of a component could be used to declare a derivation, i.e. state that is entirely defined through a computation of other state. In Svelte 5, this is achieved using the <code>$derived</code> rune:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let count = $state(0);
	$: const double = $derived(count * 2);
&lt;/script&gt;</pre>
</div>
<p>As with <code>$state</code>, nothing else changes. <code>double</code> is still the number itself, and you read it directly, without a wrapper like <code>.value</code> or <code>getDouble()</code>.</p> <p>A <code>$:</code> statement could also be used to create side effects. In Svelte 5, this is achieved using the <code>$effect</code> rune:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let count = $state(0);
	$:$effect(() =&gt; {
		if (count &gt; 5) {
			alert('Count is too high!');
		}
	});
&lt;/script&gt;</pre>
</div>
<blockquote class="note"><details><summary>Why we did this</summary><p> <code>$:</code> was a great shorthand and easy to get started with: you could slap a <code>$:</code> in front of most code and it would somehow work. This intuitiveness was also its drawback the more complicated your code became, because it wasn’t as easy to reason about. Was the intent of the code to create a derivation, or a side effect? With <code>$derived</code> and <code>$effect</code>, you have a bit more up-front decision making to do (spoiler alert: 90% of the time you want <code>$derived</code>), but future-you and other developers on your team will have an easier time.</p> <p>There were also gotchas that were hard to spot:</p> <ul> <li>
<code>$:</code> only updated directly before rendering, which meant you could read stale values in-between rerenders</li> <li>
<code>$:</code> only ran once per tick, which meant that statements may run less often than you think</li> <li>
<code>$:</code> dependencies were determined through static analysis of the dependencies. This worked in most cases, but could break in subtle ways during a refactoring where dependencies would be for example moved into a function and no longer be visible as a result</li> <li>
<code>$:</code> statements were also ordered by using static analysis of the dependencies. In some cases there could be ties and the ordering would be wrong as a result, needing manual interventions. Ordering could also break while refactoring code and some dependencies no longer being visible as a result.</li> </ul> <p>Lastly, it wasn’t TypeScript-friendly (our editor tooling had to jump through some hoops to make it valid for TypeScript), which was a blocker for making Svelte’s reactivity model truly universal.</p> <p><code>$derived</code> and <code>$effect</code> fix all of these by</p> <ul> <li>always returning the latest value</li> <li>running as often as needed to be stable</li> <li>determining the dependencies at runtime, and therefore being immune to refactorings</li> <li>executing dependencies as needed and therefore being immune to ordering problems</li> <li>being TypeScript-friendly</li> </ul> </details></blockquote>
<h3 id="Reactivity-syntax-changes-export-let-$props">
<span>export let -&gt; $props</span>
</h3>
<p>In Svelte 4, properties of a component were declared using <code>export let</code>. Each property was one declaration. In Svelte 5, all properties are declared through the <code>$props</code> rune, through destructuring:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	export let optional = 'unset';
	export let required;
	let { optional = 'unset', required } = $props();
&lt;/script&gt;</pre>
</div>
<p>There are multiple cases where declaring properties becomes less straightforward than having a few <code>export let</code> declarations:</p> <ul> <li>you want to rename the property, for example because the name is a reserved identifier (e.g. <code>class</code>)</li> <li>you don’t know which other properties to expect in advance</li> <li>you want to forward every property to another component</li> </ul> <p>All these cases need special syntax in Svelte 4:</p> <ul> <li>renaming: <code>export { klass as class}</code>
</li> <li>other properties: <code>$$restProps</code>
</li> <li>all properties <code>$$props</code>
</li> </ul> <p>In Svelte 5, the <code>$props</code> rune makes this straightforward without any additional Svelte-specific syntax:</p> <ul> <li>renaming: use property renaming <code>let { class: klass } = $props();</code>
</li> <li>other properties: use spreading <code>let { foo, bar, ...rest } = $props();</code>
</li> <li>all properties: don’t destructure <code>let props = $props();</code>
</li> </ul> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let klass = '';
	export { klass as class};
	let { class: klass, ...rest } = $props();
&lt;/script&gt;
&lt;button class={klass} {...$$restPropsrest}&gt;click me&lt;/button&gt;</pre>
</div>
<blockquote class="note"><details><summary>Why we did this</summary><p> <code>export let</code> was one of the more controversial API decisions, and there was a lot of debate about whether you should think about a property being <code>export</code>ed or <code>import</code>ed. <code>$props</code> doesn’t have this trait. It’s also in line with the other runes, and the general thinking reduces to “everything special to reactivity in Svelte is a rune”.</p> <p>There were also a lot of limitations around <code>export let</code>, which required additional API, as shown above. <code>$props</code> unite this in one syntactical concept that leans heavily on regular JavaScript destructuring syntax.</p> </details></blockquote>
<h2 id="Event-changes">
<span>Event changes</span>
</h2>
<p>Event handlers have been given a facelift in Svelte 5. Whereas in Svelte 4 we use the <code>on:</code> directive to attach an event listener to an element, in Svelte 5 they are properties like any other (in other words - remove the colon):</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let count = $state(0);
&lt;/script&gt;

&lt;button on:click={() =&gt; count++}&gt;
	clicks: {count}
&lt;/button&gt;</pre>
</div>
<p>Since they’re just properties, you can use the normal shorthand syntax...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let count = $state(0);

	function onclick() {
		count++;
	}
&lt;/script&gt;

&lt;button {onclick}&gt;
	clicks: {count}
&lt;/button&gt;</pre>
</div>
<p>...though when using a named event handler function it’s usually better to use a more descriptive name.</p> <h3 id="Event-changes-Component-events">
<span>Component events</span>
</h3>
<p>In Svelte 4, components could emit events by creating a dispatcher with <code>createEventDispatcher</code>.</p> <p>This function is deprecated in Svelte 5. Instead, components should accept <em>callback props</em> - which means you then pass functions as properties to these components:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">App</span>
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	import Pump from './Pump.svelte';

	let size = $state(15);
	let burst = $state(false);

	function reset() {
		size = 15;
		burst = false;
	}
&lt;/script&gt;

&lt;Pump
	on:inflate={(power) =&gt; {
		size += power.details;
		if (size &gt; 75) burst = true;
	}}
	on:deflate={(power) =&gt; {
		if (size &gt; 0) size -= power.details;
	}}
/&gt;

{#if burst}
	&lt;button onclick={reset}&gt;new balloon&lt;/button&gt;
	&lt;span class="boom"&gt;💥&lt;/span&gt;
{:else}
	&lt;span class="balloon" style="scale: {0.01 * size}"&gt;
		🎈
	&lt;/span&gt;
{/if}</pre>
</div>
<div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">Pump</span>
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();
	
	let { inflate, deflate } = $props();
	let power = $state(5);
&lt;/script&gt;

&lt;button onclick={() =&gt; dispatch('inflate', power)inflate(power)}&gt;
	inflate
&lt;/button&gt;
&lt;button onclick={() =&gt; dispatch('deflate', power)deflate(power)}&gt;
	deflate
&lt;/button&gt;
&lt;button onclick={() =&gt; power--}&gt;-&lt;/button&gt;
Pump power: {power}
&lt;button onclick={() =&gt; power++}&gt;+&lt;/button&gt;</pre>
</div>
<h3 id="Event-changes-Bubbling-events">
<span>Bubbling events</span>
</h3>
<p>Instead of doing <code>&lt;button on:click&gt;</code> to ‘forward’ the event from the element to the component, the component should accept an <code>onclick</code> callback prop:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let { onclick } = $props();
&lt;/script&gt;

&lt;button on:click {onclick}&gt;
	click me
&lt;/button&gt;</pre>
</div>
<p>Note that this also means you can ‘spread’ event handlers onto the element along with other props instead of tediously forwarding each event separately:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let props = $props();
&lt;/script&gt;

&lt;button {...$$props} on:click on:keydown on:all_the_other_stuff {...props}&gt;
	click me
&lt;/button&gt;</pre>
</div>
<h3 id="Event-changes-Event-modifiers">
<span>Event modifiers</span>
</h3>
<p>In Svelte 4, you can add event modifiers to handlers:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;button on:click|once|preventDefault={handler}&gt;...&lt;/button&gt;</pre>
</div>
<p>Modifiers are specific to <code>on:</code> and as such do not work with modern event handlers. Adding things like <code>event.preventDefault()</code> inside the handler itself is preferable, since all the logic lives in one place rather than being split between handler and modifiers.</p> <p>Since event handlers are just functions, you can create your own wrappers as necessary:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	function once(fn) {
		return function (event) {
			if (fn) fn.call(this, event);
			fn = null;
		};
	}

	function preventDefault(fn) {
		return function (event) {
			event.preventDefault();
			fn.call(this, event);
		};
	}
&lt;/script&gt;

&lt;button onclick={once(preventDefault(handler))}&gt;...&lt;/button&gt;</pre>
</div>
<p>There are three modifiers — <code>capture</code>, <code>passive</code> and <code>nonpassive</code> — that can’t be expressed as wrapper functions, since they need to be applied when the event handler is bound rather than when it runs.</p> <p>For <code>capture</code>, we add the modifier to the event name:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;button onclickcapture={...}&gt;...&lt;/button&gt;</pre>
</div>
<p>Changing the <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#using_passive_listeners"><code>passive</code></a> option of an event handler, meanwhile, is not something to be done lightly. If you have a use case for it — and you probably don’t! — then you will need to use an action to apply the event handler yourself.</p> <h3 id="Event-changes-Multiple-event-handlers">
<span>Multiple event handlers</span>
</h3>
<p>In Svelte 4, this is possible:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;button on:click={one} on:click={two}&gt;...&lt;/button&gt;</pre>
</div>
<p>Duplicate attributes/properties on elements — which now includes event handlers — are not allowed. Instead, do this:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;button
	onclick={(e) =&gt; {
		one(e);
		two(e);
	}}
&gt;
	...
&lt;/button&gt;</pre>
</div>
<p>When spreading props, local event handlers must go <em>after</em> the spread, or they risk being overwritten:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;button
	{...props}
	onclick={(e) =&gt; {
		doStuff(e);
		props.onclick?.(e);
	}}
&gt;
	...
&lt;/button&gt;</pre>
</div>
<blockquote class="note"><details><summary>Why we did this</summary><p> <code>createEventDispatcher</code> was always a bit boilerplate-y:</p> <ul> <li>import the function</li> <li>call the function to get a dispatch function</li> <li>call said dispatch function with a string and possibly a payload</li> <li>retrieve said payload on the other end through a <code>.details</code> property, because the event itself was always a <code>CustomEvent</code>
</li> </ul> <p>It was always possible to use component callback props, but because you had to listen to DOM events using <code>on:</code>, it made sense to use <code>createEventDispatcher</code> for component events due to syntactical consistency. Now that we have event attributes (<code>onclick</code>), it’s the other way around: Callback props are now the more sensible thing to do.</p> <p>The removal of event modifiers is arguably one of the changes that seems like a step back for those who’ve liked the shorthand syntax of event modifiers. Given that they are not used that frequently, we traded a smaller surface area for more explicitness. Modifiers also were inconsistent, because most of them were only useable on DOM elements.</p> <p>Multiple listeners for the same event are also no longer possible, but it was something of an anti-pattern anyway, since it impedes readability: if there are many attributes, it becomes harder to spot that there are two handlers unless they are right next to each other. It also implies that the two handlers are independent, when in fact something like <code>event.stopImmediatePropagation()</code> inside <code>one</code> would prevent <code>two</code> from being called.</p> <p>By deprecating <code>createEventDispatcher</code> and the <code>on:</code> directive in favour of callback props and normal element properties, we:</p> <ul> <li>reduce Svelte’s learning curve</li> <li>remove boilerplate, particularly around <code>createEventDispatcher</code>
</li> <li>remove the overhead of creating <code>CustomEvent</code> objects for events that may not even have listeners</li> <li>add the ability to spread event handlers</li> <li>add the ability to know which event handlers were provided to a component</li> <li>add the ability to express whether a given event handler is required or optional</li> <li>increase type safety (previously, it was effectively impossible for Svelte to guarantee that a component didn’t emit a particular event)</li> </ul> </details></blockquote>
<h2 id="Snippets-instead-of-slots">
<span>Snippets instead of slots</span>
</h2>
<p>In Svelte 4, content can be passed to components using slots. Svelte 5 replaces them with snippets which are more powerful and flexible, and as such slots are deprecated in Svelte 5.</p> <p>They continue to work, however, and you can mix and match snippets and slots in your components.</p> <p>When using custom elements, you should still use <code>&lt;slot /&gt;</code> like before. In a future version, when Svelte removes its internal version of slots, it will leave those slots as-is, i.e. output a regular DOM tag instead of transforming it.</p> <h3 id="Snippets-instead-of-slots-Default-content">
<span>Default content</span>
</h3>
<p>In Svelte 4, the easiest way to pass a piece of UI to the child was using a <code>&lt;slot /&gt;</code>. In Svelte 5, this is done using the <code>children</code> prop instead, which is then shown with <code>{@render children()}</code>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let { children } = $props();
&lt;/script&gt;

&lt;slot /&gt;
{@render children?.()}</pre>
</div>
<h3 id="Snippets-instead-of-slots-Multiple-content-placeholders">
<span>Multiple content placeholders</span>
</h3>
<p>If you wanted multiple UI placeholders, you had to use named slots. In Svelte 5, use props instead, name them however you like and <code>{@render ...}</code> them:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let { header, main, footer } = $props();
&lt;/script&gt;

&lt;header&gt;
	&lt;slot name="header" /&gt;
	{@render header()}
&lt;/header&gt;

&lt;main&gt;
	&lt;slot name="main" /&gt;
	{@render main()}
&lt;/main&gt;

&lt;footer&gt;
	&lt;slot name="footer" /&gt;
	{@render footer()}
&lt;/footer&gt;</pre>
</div>
<h3 id="Snippets-instead-of-slots-Passing-data-back-up">
<span>Passing data back up</span>
</h3>
<p>In Svelte 4, you would pass data to a <code>&lt;slot /&gt;</code> and then retrieve it with <code>let:</code> in the parent component. In Svelte 5, snippets take on that responsibility:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">App</span>
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	import List from './List.svelte';
&lt;/script&gt;

&lt;List items={['one', 'two', 'three']} let:item&gt;
	{#snippet item(text)}
		&lt;span&gt;{text}&lt;/span&gt;
	{/snippet}
	&lt;span slot="empty"&gt;No items yet&lt;/span&gt;
	{#snippet empty()}
		&lt;span&gt;No items yet&lt;/span&gt;
	{/snippet}
&lt;/List&gt;</pre>
</div>
<div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">List</span>
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let { items, item, empty } = $props();
&lt;/script&gt;

{#if items.length}
	&lt;ul&gt;
		{#each items as entry}
			&lt;li&gt;
				&lt;slot item={entry} /&gt;
				{@render item(entry)}
			&lt;/li&gt;
		{/each}
	&lt;/ul&gt;
{:else}
	&lt;slot name="empty" /&gt;
	{@render empty?.()}
{/if}</pre>
</div>
<blockquote class="note"><details><summary>Why we did this</summary><p> Slots were easy to get started with, but the more advanced the use case became, the more involved and confusing the syntax became:</p> <ul> <li>the <code>let:</code> syntax was confusing to many people as it <em>creates</em> a variable whereas all other <code>:</code> directives <em>receive</em> a variable</li> <li>the scope of a variable declared with <code>let:</code> wasn’t clear. In the example above, it may look like you can use the <code>item</code> slot prop in the <code>empty</code> slot, but that’s not true</li> <li>named slots had to be applied to an element using the <code>slot</code> attribute. Sometimes you didn’t want to create an element, so we had to add the <code>&lt;svelte:fragment&gt;</code> API</li> <li>named slots could also be applied to a component, which changed the semantics of where <code>let:</code> directives are available (even today us maintainers often don’t know which way around it works)</li> </ul> <p>Snippets solve all of these problems by being much more readable and clear. At the same time they’re more powerful as they allow you to define sections of UI that you can render <em>anywhere</em>, not just passing them as props to a component.</p> </details></blockquote>
<h2 id="Migration-script">
<span>Migration script</span>
</h2>
<p>By now you should have a pretty good understanding of the before/after and how the old syntax relates to the new syntax. It probably also became clear that a lot of these migrations are rather technical and repetitive - something you don’t want to do by hand.</p> <p>We thought the same, which is why we provide a migration script to do most of the migration automatically. You can upgrade your project by using <code>npx sv migrate svelte-5</code>. This will do the following things:</p> <ul> <li>bump core dependencies in your <code>package.json</code>
</li> <li>migrate to runes (<code>let</code> -&gt; <code>$state</code> etc)</li> <li>migrate to event attributes for DOM elements (<code>on:click</code> -&gt; <code>onclick</code>)</li> <li>migrate slot creations to render tags (<code>&lt;slot /&gt;</code> -&gt; <code>{@render children()}</code>)</li> <li>migrate slot usages to snippets (<code>&lt;div slot="x"&gt;...&lt;/div&gt;</code> -&gt; <code>{#snippet x()}&lt;div&gt;...&lt;/div&gt;{/snippet}</code>)</li> <li>migrate obvious component creations (<code>new Component(...)</code> -&gt; <code>mount(Component, ...)</code>)</li> </ul> <p>You can also migrate a single component in VS Code through the <code>Migrate Component to Svelte 5 Syntax</code> command, or in our Playground through the <code>Migrate</code> button.</p> <p>Not everything can be migrated automatically, and some migrations need manual cleanup afterwards. The following sections describe these in more detail.</p> <h3 id="Migration-script-run">
<span>run</span>
</h3>
<p>You may see that the migration script converts some of your <code>$:</code> statements to a <code>run</code> function which is imported from <code>svelte/legacy</code>. This happens if the migration script couldn’t reliably migrate the statement to a <code>$derived</code> and concluded this is a side effect instead. In some cases this may be wrong and it’s best to change this to use a <code>$derived</code> instead. In other cases it may be right, but since <code>$:</code> statements also ran on the server but <code>$effect</code> does not, it isn’t safe to transform it as such. Instead, <code>run</code> is used as a stopgap solution. <code>run</code> mimics most of the characteristics of <code>$:</code>, in that it runs on the server once, and runs as <code>$effect.pre</code> on the client (<code>$effect.pre</code> runs <em>before</em> changes are applied to the DOM; most likely you want to use <code>$effect</code> instead).</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	import { run } from 'svelte/legacy';
	run(() =&gt; {
	$effect(() =&gt; {
		// some side effect code
	})
&lt;/script&gt;</pre>
</div>
<h3 id="Migration-script-Event-modifiers">
<span>Event modifiers</span>
</h3>
<p>Event modifiers are not applicable to event attributes (e.g. you can’t do <code>onclick|preventDefault={...}</code>). Therefore, when migrating event directives to event attributes, we need a function-replacement for these modifiers. These are imported from <code>svelte/legacy</code>, and should be migrated away from in favor of e.g. just using <code>event.preventDefault()</code>.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	import { preventDefault } from 'svelte/legacy';
&lt;/script&gt;

&lt;button
	onclick={preventDefault((event) =&gt; {
		event.preventDefault();
		// ...
	})}
&gt;
	click me
&lt;/button&gt;</pre>
</div>
<h3 id="Migration-script-Things-that-are-not-automigrated">
<span>Things that are not automigrated</span>
</h3>
<p>The migration script does not convert <code>createEventDispatcher</code>. You need to adjust those parts manually. It doesn’t do it because it’s too risky because it could result in breakage for users of the component, which the migration script cannot find out.</p> <p>The migration script does not convert <code>beforeUpdate/afterUpdate</code>. It doesn’t do it because it’s impossible to determine the actual intent of the code. As a rule of thumb you can often go with a combination of <code>$effect.pre</code> (runs at the same time as <code>beforeUpdate</code> did) and <code>tick</code> (imported from <code>svelte</code>, allows you to wait until changes are applied to the DOM and then do some work).</p> <h2 id="Components-are-no-longer-classes">
<span>Components are no longer classes</span>
</h2>
<p>In Svelte 3 and 4, components are classes. In Svelte 5 they are functions and should be instantiated differently. If you need to manually instantiate components, you should use <code>mount</code> or <code>hydrate</code> (imported from <code>svelte</code>) instead. If you see this error using SvelteKit, try updating to the latest version of SvelteKit first, which adds support for Svelte 5. If you’re using Svelte without SvelteKit, you’ll likely have a <code>main.js</code> file (or similar) which you need to adjust:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">import { mount } from 'svelte';
import App from './App.svelte'

const app = new App({ target: document.getElementById("app") });
const 
    $on?(type: string, callback: (e: any) =&gt; void): () =&gt; void;
    $set?(props: Partial&lt;Record&lt;string, any&gt;&gt;): void;
} &amp; Record&lt;string, any&gt;
    $on?(type: string, callback: (e: any) =&gt; void): () =&gt; void;
    $set?(props: Partial&lt;Record&lt;string, any&gt;&gt;): void;
} &amp; Record&lt;string, any&gt;</pre>app <span style="color:var(--shiki-token-keyword)">=</span> <span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">mount&lt;Record&lt;string, any&gt;, {</pre></code></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$on</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(type</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-function)">callback</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">(e</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">)</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">()</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$set</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(props</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Partial</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;...&gt;&gt;</span><span style="color:var(--shiki-foreground)">(component</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">ComponentType</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-function)">Component</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">options</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">MountOptions</span><span style="color:var(--shiki-foreground)">&lt;...&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">{</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-keyword)">...</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span></span><div class="twoslash-popup-docs">
<p>Mounts a component to the given target and returns the exports and potentially the props (if compiled with <code>accessors: true</code>) of the component. <span class="highlight add">Transitions will play during the initial render unless the <code>intro</code> option is set to <code>false</code>.</span></p> 
</div></span>mount</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)">App</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">ComponentType</span></code></span>App</span></span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">{</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">target</span><span style="color:var(--shiki-token-punctuation)">:</span> <span style="color:var(--shiki-foreground)">Document</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">Element</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">ShadowRoot</span></code><div class="twoslash-popup-docs">
<p>Target element where the component will be mounted.</p> 
</div></span>target</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">var</span> <span style="color:var(--shiki-foreground)">document</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Document</span></code><div class="twoslash-popup-docs">
<p><a href="https://developer.mozilla.org/docs/Web/API/Window/document">MDN Reference</a></p> 
</div></span>document</span></span><span style="color:var(--shiki-token-function)">.</span><span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-constant)">Document</span><span style="color:var(--shiki-token-function)">.getElementById</span><span style="color:var(--shiki-foreground)">(elementId: string): HTMLElement</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-constant)">null</span></code><div class="twoslash-popup-docs">
<p>Returns a reference to the first object with the specified value of the ID attribute.</p> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@param</span><span class="value"><span class="param">elementId</span> String that specifies the ID value.</span>
</div></div></span>getElementById</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-token-string-expression)">"app"</span><span style="color:var(--shiki-foreground)">) });</span>  <span class="line"><span style="color:var(--shiki-token-keyword)">export</span> <span style="color:var(--shiki-token-keyword)">default</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">const app: {
    $on?(type: string, callback: (e: any) =&gt; void): () =&gt; void;
    $set?(props: Partial&lt;Record&lt;string, any&gt;&gt;): void;
} &amp; Record&lt;string, any&gt;</pre></code></span>app</span></span><span style="color:var(--shiki-foreground)">;</span></span>
</div>
<p><code>mount</code> and <code>hydrate</code> have the exact same API. The difference is that <code>hydrate</code> will pick up the Svelte’s server-rendered HTML inside its target and hydrate it. Both return an object with the exports of the component and potentially property accessors (if compiled with <code>accessors: true</code>). They do not come with the <code>$on</code>, <code>$set</code> and <code>$destroy</code> methods you may know from the class component API. These are its replacements:</p> <p>For <code>$on</code>, instead of listening to events, pass them via the <code>events</code> property on the options argument.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">import { mount } from 'svelte';
import App from './App.svelte'

const app = new App({ target: document.getElementById("app") });
app.$on('event', callback);
const 
    $on?(type: string, callback: (e: any) =&gt; void): () =&gt; void;
    $set?(props: Partial&lt;Record&lt;string, any&gt;&gt;): void;
} &amp; Record&lt;string, any&gt;
    $on?(type: string, callback: (e: any) =&gt; void): () =&gt; void;
    $set?(props: Partial&lt;Record&lt;string, any&gt;&gt;): void;
} &amp; Record&lt;string, any&gt;</pre>app <span style="color:var(--shiki-token-keyword)">=</span> <span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">mount&lt;Record&lt;string, any&gt;, {</pre></code></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$on</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(type</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-function)">callback</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">(e</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">)</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">()</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$set</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(props</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Partial</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;...&gt;&gt;</span><span style="color:var(--shiki-foreground)">(component</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">ComponentType</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-function)">Component</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">options</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">MountOptions</span><span style="color:var(--shiki-foreground)">&lt;...&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">{</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-keyword)">...</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span></span><div class="twoslash-popup-docs">
<p>Mounts a component to the given target and returns the exports and potentially the props (if compiled with <code>accessors: true</code>) of the component. <span class="highlight add">Transitions will play during the initial render unless the <code>intro</code> option is set to <code>false</code>.</span></p> 
</div></span>mount</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)">App</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">ComponentType</span></code></span>App</span></span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">{</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">target</span><span style="color:var(--shiki-token-punctuation)">:</span> <span style="color:var(--shiki-foreground)">Document</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">Element</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">ShadowRoot</span></code><div class="twoslash-popup-docs">
<p>Target element where the component will be mounted.</p> 
</div></span>target</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">var</span> <span style="color:var(--shiki-foreground)">document</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Document</span></code><div class="twoslash-popup-docs">
<p><a href="https://developer.mozilla.org/docs/Web/API/Window/document">MDN Reference</a></p> 
</div></span>document</span></span><span style="color:var(--shiki-token-function)">.</span><span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-constant)">Document</span><span style="color:var(--shiki-token-function)">.getElementById</span><span style="color:var(--shiki-foreground)">(elementId: string): HTMLElement</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-constant)">null</span></code><div class="twoslash-popup-docs">
<p>Returns a reference to the first object with the specified value of the ID attribute.</p> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@param</span><span class="value"><span class="param">elementId</span> String that specifies the ID value.</span>
</div></div></span>getElementById</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-token-string-expression)">"app"</span><span style="color:var(--shiki-foreground)">)</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">events</span><span style="color:var(--shiki-token-keyword)">?:</span> <span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">(e</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">)</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-foreground)">any</span><span style="color:var(--shiki-token-keyword)">&gt;</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-constant)">undefined</span></code><div class="twoslash-popup-docs">
<p>Allows the specification of events.</p> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@deprecated</span><span class="value">Use callback props instead.</span>
</div></div></span>events</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">{</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">event</span><span style="color:var(--shiki-token-punctuation)">:</span> <span style="color:var(--shiki-foreground)">any</span></code></span>event</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">callback</span> <span style="color:var(--shiki-foreground)">} });</span>
</div>
<blockquote class="note">
<p> Note that using <code>events</code> is discouraged — instead, <a href="#Event-changes">use callbacks</a></p> </blockquote>
<p>For <code>$set</code>, use <code>$state</code> instead to create a reactive property object and manipulate it. If you’re doing this inside a <code>.js</code> or <code>.ts</code> file, adjust the ending to include <code>.svelte</code>, i.e. <code>.svelte.js</code> or <code>.svelte.ts</code>.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">import { mount } from 'svelte';
import App from './App.svelte'

const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } });
app.$set({ foo: 'baz' });
const 
    foo: string;
}
    foo: string;
}</pre>props <span style="color:var(--shiki-token-keyword)">=</span> <span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">function $state&lt;{</pre></code></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-foreground)">foo</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}&gt;(initial</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">{</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-foreground)">foo</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">})</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">{</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-foreground)">foo</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">} (+</span><span style="color:var(--shiki-token-constant)">1</span> <span style="color:var(--shiki-token-function)">overload</span><span style="color:var(--shiki-foreground)">)</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-token-keyword)">namespace</span> <span style="color:var(--shiki-token-function)">$state</span></span><div class="twoslash-popup-docs">
<p>Declares reactive state.</p> <span class="highlight add"><p>Example:</p></span> <span class="highlight add"><div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">let count = $state(0);</pre>
</div>
<p><a href="$state.html">https://svelte.dev/docs/svelte/$state</a></p></span> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@param</span><span class="value"><span class="param">initial</span> The initial value</span>
</div></div></span>$state</span></span><span style="color:var(--shiki-foreground)">({</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">foo</span><span style="color:var(--shiki-token-punctuation)">:</span> <span style="color:var(--shiki-foreground)">string</span></code></span>foo</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-string-expression)">'bar'</span> <span style="color:var(--shiki-foreground)">});</span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">const app: {</pre></code></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$on</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(type</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-function)">callback</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">(e</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">)</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">()</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$set</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(props</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Partial</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;</span></span></span>app</span></span> <span style="color:var(--shiki-token-keyword)">=</span> <span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">mount&lt;Record&lt;string, any&gt;, {</pre></code></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$on</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(type</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-function)">callback</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">(e</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">)</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">()</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$set</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(props</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Partial</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;...&gt;&gt;</span><span style="color:var(--shiki-foreground)">(component</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">ComponentType</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-function)">Component</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">options</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">MountOptions</span><span style="color:var(--shiki-foreground)">&lt;...&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">{</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-keyword)">...</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span></span><div class="twoslash-popup-docs">
<p>Mounts a component to the given target and returns the exports and potentially the props (if compiled with <code>accessors: true</code>) of the component. <span class="highlight add">Transitions will play during the initial render unless the <code>intro</code> option is set to <code>false</code>.</span></p> 
</div></span>mount</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)">App</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">ComponentType</span></code></span>App</span></span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">{</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">target</span><span style="color:var(--shiki-token-punctuation)">:</span> <span style="color:var(--shiki-foreground)">Document</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">Element</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">ShadowRoot</span></code><div class="twoslash-popup-docs">
<p>Target element where the component will be mounted.</p> 
</div></span>target</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">var</span> <span style="color:var(--shiki-foreground)">document</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Document</span></code><div class="twoslash-popup-docs">
<p><a href="https://developer.mozilla.org/docs/Web/API/Window/document">MDN Reference</a></p> 
</div></span>document</span></span><span style="color:var(--shiki-token-function)">.</span><span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-constant)">Document</span><span style="color:var(--shiki-token-function)">.getElementById</span><span style="color:var(--shiki-foreground)">(elementId: string): HTMLElement</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-constant)">null</span></code><div class="twoslash-popup-docs">
<p>Returns a reference to the first object with the specified value of the ID attribute.</p> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@param</span><span class="value"><span class="param">elementId</span> String that specifies the ID value.</span>
</div></div></span>getElementById</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-token-string-expression)">"app"</span><span style="color:var(--shiki-foreground)">)</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">props</span><span style="color:var(--shiki-token-keyword)">?:</span> <span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">any</span><span style="color:var(--shiki-token-keyword)">&gt;</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-constant)">undefined</span></code><div class="twoslash-popup-docs">
<p>Component properties.</p> 
</div></span>props</span></span> <span style="color:var(--shiki-foreground)">});</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-token-constant)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">const props: {</pre></code></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-foreground)">foo</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span></span></span>props</span></span><span style="color:var(--shiki-foreground)">.</span><span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">foo</span><span style="color:var(--shiki-token-punctuation)">:</span> <span style="color:var(--shiki-foreground)">string</span></code></span>foo</span></span> <span style="color:var(--shiki-token-keyword)">=</span> <span style="color:var(--shiki-token-string-expression)">'baz'</span><span style="color:var(--shiki-foreground)">;</span></span></span>
</div>
<p>For <code>$destroy</code>, use <code>unmount</code> instead.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">import { mount, unmount } from 'svelte';
import App from './App.svelte'

const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } });
app.$destroy();
const 
    $on?(type: string, callback: (e: any) =&gt; void): () =&gt; void;
    $set?(props: Partial&lt;Record&lt;string, any&gt;&gt;): void;
} &amp; Record&lt;string, any&gt;
    $on?(type: string, callback: (e: any) =&gt; void): () =&gt; void;
    $set?(props: Partial&lt;Record&lt;string, any&gt;&gt;): void;
} &amp; Record&lt;string, any&gt;</pre>app <span style="color:var(--shiki-token-keyword)">=</span> <span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">mount&lt;Record&lt;string, any&gt;, {</pre></code></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$on</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(type</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-function)">callback</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">(e</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">)</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">()</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$set</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(props</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Partial</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;...&gt;&gt;</span><span style="color:var(--shiki-foreground)">(component</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">ComponentType</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-function)">Component</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">options</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">MountOptions</span><span style="color:var(--shiki-foreground)">&lt;...&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">{</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-keyword)">...</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;...&gt;</span></span><div class="twoslash-popup-docs">
<p>Mounts a component to the given target and returns the exports and potentially the props (if compiled with <code>accessors: true</code>) of the component. <span class="highlight add">Transitions will play during the initial render unless the <code>intro</code> option is set to <code>false</code>.</span></p> 
</div></span>mount</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)">App</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">ComponentType</span></code></span>App</span></span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">{</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">target</span><span style="color:var(--shiki-token-punctuation)">:</span> <span style="color:var(--shiki-foreground)">Document</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">Element</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">ShadowRoot</span></code><div class="twoslash-popup-docs">
<p>Target element where the component will be mounted.</p> 
</div></span>target</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">var</span> <span style="color:var(--shiki-foreground)">document</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Document</span></code><div class="twoslash-popup-docs">
<p><a href="https://developer.mozilla.org/docs/Web/API/Window/document">MDN Reference</a></p> 
</div></span>document</span></span><span style="color:var(--shiki-token-function)">.</span><span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-constant)">Document</span><span style="color:var(--shiki-token-function)">.getElementById</span><span style="color:var(--shiki-foreground)">(elementId: string): HTMLElement</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-constant)">null</span></code><div class="twoslash-popup-docs">
<p>Returns a reference to the first object with the specified value of the ID attribute.</p> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@param</span><span class="value"><span class="param">elementId</span> String that specifies the ID value.</span>
</div></div></span>getElementById</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-token-string-expression)">"app"</span><span style="color:var(--shiki-foreground)">) });</span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">function</span> <span style="color:var(--shiki-token-function)">unmount</span><span style="color:var(--shiki-foreground)">(component</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">void</span></code><div class="twoslash-popup-docs">
<p>Unmounts a component that was previously mounted using <code>mount</code> or <code>hydrate</code>.</p> 
</div></span>unmount</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">const app: {</pre></code></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$on</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(type</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-function)">callback</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">(e</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">)</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">()</span> <span style="color:var(--shiki-token-keyword)">=&gt;</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-function)">$set</span><span style="color:var(--shiki-token-keyword)">?</span><span style="color:var(--shiki-foreground)">(props</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Partial</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;&gt;)</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">void</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;</span></span></span>app</span></span><span style="color:var(--shiki-foreground)">);</span></span></span>
</div>
<p>As a stop-gap-solution, you can also use <code>createClassComponent</code> or <code>asClassComponent</code> (imported from <code>svelte/legacy</code>) instead to keep the same API known from Svelte 4 after instantiating.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">import { 
    component: ComponentType&lt;SvelteComponent&lt;Props, Events, Slots&gt;&gt; | Component&lt;Props&gt;;
}): SvelteComponent&lt;Props, Events, Slots&gt; &amp; Exports
    component: ComponentType&lt;SvelteComponent&lt;Props, Events, Slots&gt;&gt; | Component&lt;Props&gt;;
}): SvelteComponent&lt;Props, Events, Slots&gt; &amp; Exports</pre>
<div class="twoslash-popup-docs">
<p>Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.</p> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@deprecated</span><span class="value">Use this only as a temporary solution to migrate your imperative component code to Svelte 5.</span>
</div></div>createClassComponent <span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">from</span> <span style="color:var(--shiki-token-string-expression)">'svelte/legacy'</span><span style="color:var(--shiki-foreground)">;</span> <span class="line"><span style="color:var(--shiki-token-keyword)">import</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">type App = SvelteComponent&lt;Record&lt;string, any&gt;, any, any&gt;
const App: ComponentType</pre></code></span>App</span></span> <span style="color:var(--shiki-token-keyword)">from</span> <span style="color:var(--shiki-token-string-expression)">'./App.svelte'</span></span>  <span class="line"><span class="highlight remove"><span style="color:var(--shiki-foreground)">const app = new App({ target: document.getElementById("app") });</span></span></span> <span class="line"><span class="highlight add"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)">app</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">SvelteComponent</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;</span></code></span>app</span></span> <span style="color:var(--shiki-token-keyword)">=</span> <span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">createClassComponent&lt;Record&lt;string, any&gt;, Record&lt;string, any&gt;, any, any&gt;(options: ComponentConstructorOptions&lt;Record&lt;string, any&gt;&gt; &amp; {</pre></code></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-foreground)">component</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">Component</span><span style="color:var(--shiki-token-keyword)">&lt;...&gt;</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">ComponentType</span><span style="color:var(--shiki-token-keyword)">&lt;...&gt;</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}): SvelteComponent</span><span style="color:var(--shiki-token-keyword)">&lt;...&gt;</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;...&gt;</span></span><div class="twoslash-popup-docs">
<p>Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.</p> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@deprecated</span><span class="value">Use this only as a temporary solution to migrate your imperative component code to Svelte 5.</span>
</div></div></span>createClassComponent</span></span><span style="color:var(--shiki-foreground)">({</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">component</span><span style="color:var(--shiki-token-punctuation)">:</span> <span style="color:var(--shiki-foreground)">Component</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">any</span><span style="color:var(--shiki-token-keyword)">&gt;</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">{}</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">string</span><span style="color:var(--shiki-token-keyword)">&gt;</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">ComponentType</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">SvelteComponent</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">any</span><span style="color:var(--shiki-token-keyword)">&gt;</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">any</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">any</span><span style="color:var(--shiki-token-keyword)">&gt;&gt;</span></code></span>component</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)">App</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">ComponentType</span></code></span>App</span></span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">ComponentConstructorOptions</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">Props extends Record</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">any</span><span style="color:var(--shiki-token-keyword)">&gt;</span> <span style="color:var(--shiki-token-keyword)">=</span> <span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">any</span><span style="color:var(--shiki-token-keyword)">&gt;&gt;</span><span style="color:var(--shiki-foreground)">.target: Document</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">Element</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-foreground)">ShadowRoot</span></code></span>target</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">var</span> <span style="color:var(--shiki-foreground)">document</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">Document</span></code><div class="twoslash-popup-docs">
<p><a href="https://developer.mozilla.org/docs/Web/API/Window/document">MDN Reference</a></p> 
</div></span>document</span></span><span style="color:var(--shiki-token-function)">.</span><span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-constant)">Document</span><span style="color:var(--shiki-token-function)">.getElementById</span><span style="color:var(--shiki-foreground)">(elementId: string): HTMLElement</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-constant)">null</span></code><div class="twoslash-popup-docs">
<p>Returns a reference to the first object with the specified value of the ID attribute.</p> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@param</span><span class="value"><span class="param">elementId</span> String that specifies the ID value.</span>
</div></div></span>getElementById</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-token-string-expression)">"app"</span><span style="color:var(--shiki-foreground)">) });</span></span></span>  <span class="line"><span style="color:var(--shiki-token-keyword)">export</span> <span style="color:var(--shiki-token-keyword)">default</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)">app</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">SvelteComponent</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;</span> <span style="color:var(--shiki-token-keyword)">&amp;</span> <span style="color:var(--shiki-token-function)">Record</span><span style="color:var(--shiki-foreground)">&lt;</span><span style="color:var(--shiki-token-constant)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)">any</span><span style="color:var(--shiki-foreground)">&gt;</span></code></span>app</span></span><span style="color:var(--shiki-foreground)">;</span></span>
</div>
<p>If this component is not under your control, you can use the <code>compatibility.componentApi</code> compiler option for auto-applied backwards compatibility, which means code using <code>new Component(...)</code> keeps working without adjustments (note that this adds a bit of overhead to each component). This will also add <code>$set</code> and <code>$on</code> methods for all component instances you get through <code>bind:this</code>.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">/// svelte.config.js
export default {
	compilerOptions: {
		compatibility: {
			componentApi: 4
		}
	}
};</pre>
</div>
<p>Note that <code>mount</code> and <code>hydrate</code> are <em>not</em> synchronous, so things like <code>onMount</code> won’t have been called by the time the function returns and the pending block of promises will not have been rendered yet (because <code>#await</code> waits a microtask to wait for a potentially immediately-resolved promise). If you need that guarantee, call <code>flushSync</code> (import from <code>'svelte'</code>) after calling <code>mount/hydrate</code>.</p> <h3 id="Components-are-no-longer-classes-Server-API-changes">
<span>Server API changes</span>
</h3>
<p>Similarly, components no longer have a <code>render</code> method when compiled for server side rendering. Instead, pass the function to <code>render</code> from <code>svelte/server</code>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">import { 
    props?: Omit&lt;Props, "$$slots" | "$$events"&gt;;
    context?: Map&lt;any, any&gt;;
}] : [component: Comp extends SvelteComponent&lt;any&gt; ? ComponentType&lt;Comp&gt; : Comp, options: {
    props: Omit&lt;Props, "$$slots" | "$$events"&gt;;
    context?: Map&lt;any, any&gt;;
}]): RenderOutput
    props?: Omit&lt;Props, "$$slots" | "$$events"&gt;;
    context?: Map&lt;any, any&gt;;
}] : [component: Comp extends SvelteComponent&lt;any&gt; ? ComponentType&lt;Comp&gt; : Comp, options: {
    props: Omit&lt;Props, "$$slots" | "$$events"&gt;;
    context?: Map&lt;any, any&gt;;
}]): RenderOutput</pre>
<div class="twoslash-popup-docs">
<p>Only available on the server and when compiling with the <code>server</code> option. <span class="highlight add">Takes a component and returns an object with <code>body</code> and <code>head</code> properties on it, which you can use to populate the HTML when server-rendering your app.</span></p> 
</div>render <span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">from</span> <span style="color:var(--shiki-token-string-expression)">'svelte/server'</span><span style="color:var(--shiki-foreground)">;</span> <span class="line"><span style="color:var(--shiki-token-keyword)">import</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">type App = SvelteComponent&lt;Record&lt;string, any&gt;, any, any&gt;
const App: ComponentType</pre></code></span>App</span></span> <span style="color:var(--shiki-token-keyword)">from</span> <span style="color:var(--shiki-token-string-expression)">'./App.svelte'</span><span style="color:var(--shiki-foreground)">;</span></span>  <span class="line"><span class="highlight remove"><span style="color:var(--shiki-foreground)">const { html, head } = App.render({ props: { message: 'hello' }});</span></span></span> <span class="line"><span class="highlight add"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-foreground)">{</span> <span style="color:var(--shiki-token-constant)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)">html</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span></code></span>html</span></span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-constant)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)">head</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">string</span></code><div class="twoslash-popup-docs">
<p>HTML that goes into the <code>&amp;#x3C;head&gt;</code></p> 
</div></span>head</span></span> <span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">=</span> <span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">render&lt;SvelteComponent&lt;Record&lt;string, any&gt;, any, any&gt;, Record&lt;string, any&gt;&gt;(component: ComponentType&lt;SvelteComponent&lt;Record&lt;string, any&gt;, any, any&gt;&gt;, options?: {</pre></code></span> <span class="highlight add"><span class="line"> <span style="color:var(--shiki-token-keyword)">...</span><span style="color:var(--shiki-foreground)">;</span></span></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-foreground)">}</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-constant)">undefined</span><span style="color:var(--shiki-foreground)">): RenderOutput</span></span><div class="twoslash-popup-docs">
<p>Only available on the server and when compiling with the <code>server</code> option. <span class="highlight add">Takes a component and returns an object with <code>body</code> and <code>head</code> properties on it, which you can use to populate the HTML when server-rendering your app.</span></p> 
</div></span>render</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">const</span> <span style="color:var(--shiki-token-constant)">App</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-function)">ComponentType</span></code></span>App</span></span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">{</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">props</span><span style="color:var(--shiki-token-keyword)">?:</span> <span style="color:var(--shiki-foreground)">Omit</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">Record</span><span style="color:var(--shiki-token-keyword)">&lt;</span><span style="color:var(--shiki-foreground)">string</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-foreground)">any</span><span style="color:var(--shiki-token-keyword)">&gt;</span><span style="color:var(--shiki-token-punctuation)">,</span> <span style="color:var(--shiki-token-string-expression)">"$$slots"</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-string-expression)">"$$events"</span><span style="color:var(--shiki-token-keyword)">&gt;</span> <span style="color:var(--shiki-token-keyword)">|</span> <span style="color:var(--shiki-token-constant)">undefined</span></code></span>props</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-foreground)">{</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-foreground)">message</span><span style="color:var(--shiki-token-punctuation)">:</span> <span style="color:var(--shiki-foreground)">string</span></code></span>message</span></span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-string-expression)">'hello'</span> <span style="color:var(--shiki-foreground)">}});</span></span></span>
</div>
<p>In Svelte 4, rendering a component to a string also returned the CSS of all components. In Svelte 5, this is no longer the case by default because most of the time you’re using a tooling chain that takes care of it in other ways (like SvelteKit). If you need CSS to be returned from <code>render</code>, you can set the <code>css</code> compiler option to <code>'injected'</code> and it will add <code>&lt;style&gt;</code> elements to the <code>head</code>.</p> <h3 id="Components-are-no-longer-classes-Component-typing-changes">
<span>Component typing changes</span>
</h3>
<p>The change from classes towards functions is also reflected in the typings: <code>SvelteComponent</code>, the base class from Svelte 4, is deprecated in favour of the new <code>Component</code> type which defines the function shape of a Svelte component. To manually define a component shape in a <code>d.ts</code> file:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">import type { Component } from 'svelte';
export declare const MyComponent: Component&lt;{
	foo: string;
}&gt;;</pre>
</div>
<p>To declare that a component of a certain type is required:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script lang="ts"&gt;
	import type { SvelteComponent Component } from 'svelte';
	import {
		ComponentA,
		ComponentB
	} from 'component-library';

	let component: typeof SvelteComponent&lt;{ foo: string }&gt;
	let component: Component&lt;{ foo: string }&gt; = $state(
		Math.random() ? ComponentA : ComponentB
	);
&lt;/script&gt;

&lt;svelte:component this={component} foo="bar" /&gt;</pre>
</div>
<p>The two utility types <code>ComponentEvents</code> and <code>ComponentType</code> are also deprecated. <code>ComponentEvents</code> is obsolete because events are defined as callback props now, and <code>ComponentType</code> is obsolete because the new <code>Component</code> type is the component type already (e.g. <code>ComponentType&lt;SvelteComponent&lt;{ prop: string }&gt;&gt;</code> == <code>Component&lt;{ prop: string }&gt;</code>).</p> <h3 id="Components-are-no-longer-classes-bind:this-changes">
<span>bind:this changes</span>
</h3>
<p>Because components are no longer classes, using <code>bind:this</code> no longer returns a class instance with <code>$set</code>, <code>$on</code> and <code>$destroy</code> methods on it. It only returns the instance exports (<code>export function/const</code>) and, if you’re using the <code>accessors</code> option, a getter/setter-pair for each property.</p> <h2 id="Whitespace-handling-changed">
<span>Whitespace handling changed</span>
</h2>
<p>Previously, Svelte employed a very complicated algorithm to determine if whitespace should be kept or not. Svelte 5 simplifies this which makes it easier to reason about as a developer. The rules are:</p> <ul> <li>Whitespace between nodes is collapsed to one whitespace</li> <li>Whitespace at the start and end of a tag is removed completely</li> <li>Certain exceptions apply such as keeping whitespace inside <code>pre</code> tags</li> </ul> <p>As before, you can disable whitespace trimming by setting the <code>preserveWhitespace</code> option in your compiler settings or on a per-component basis in <code>&lt;svelte:options&gt;</code>.</p> <h2 id="Modern-browser-required">
<span>Modern browser required</span>
</h2>
<p>Svelte 5 requires a modern browser (in other words, not Internet Explorer) for various reasons:</p> <ul> <li>it uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><code>Proxies</code></a>
</li> <li>elements with <code>clientWidth</code> / <code>clientHeight</code>/<code>offsetWidth</code>/<code>offsetHeight</code> bindings use a <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code>ResizeObserver</code></a> rather than a convoluted <code>&lt;iframe&gt;</code> hack</li> <li>
<code>&lt;input type="range" bind:value={...} /&gt;</code> only uses an <code>input</code> event listener, rather than also listening for <code>change</code> events as a fallback</li> </ul> <p>The <code>legacy</code> compiler option, which generated bulkier but IE-friendly code, no longer exists.</p> <h2 id="Changes-to-compiler-options">
<span>Changes to compiler options</span>
</h2>
<ul> <li>The <code>false</code> / <code>true</code> (already deprecated previously) and the <code>"none"</code> values were removed as valid values from the <code>css</code> option</li> <li>The <code>legacy</code> option was repurposed</li> <li>The <code>hydratable</code> option has been removed. Svelte components are always hydratable now</li> <li>The <code>enableSourcemap</code> option has been removed. Source maps are always generated now, tooling can choose to ignore it</li> <li>The <code>tag</code> option was removed. Use <code>&lt;svelte:options customElement="tag-name" /&gt;</code> inside the component instead</li> <li>The <code>loopGuardTimeout</code>, <code>format</code>, <code>sveltePath</code>, <code>errorMode</code> and <code>varsReport</code> options were removed</li> </ul> <h2 id="The-children-prop-is-reserved">
<span>The children prop is reserved</span>
</h2>
<p>Content inside component tags becomes a snippet prop called <code>children</code>. You cannot have a separate prop by that name.</p> <h2 id="Dot-notation-indicates-a-component">
<span>Dot notation indicates a component</span>
</h2>
<p>In Svelte 4, <code>&lt;foo.bar&gt;</code> would create an element with a tag name of <code>"foo.bar"</code>. In Svelte 5, <code>foo.bar</code> is treated as a component instead. This is particularly useful inside <code>each</code> blocks:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">{#each items as item}
	&lt;item.component {...item.props} /&gt;
{/each}</pre>
</div>
<h2 id="Breaking-changes-in-runes-mode">
<span>Breaking changes in runes mode</span>
</h2>
<p>Some breaking changes only apply once your component is in runes mode.</p> <h3 id="Breaking-changes-in-runes-mode-Bindings-to-component-exports-are-not-allowed">
<span>Bindings to component exports are not allowed</span>
</h3>
<p>Exports from runes mode components cannot be bound to directly. For example, having <code>export const foo = ...</code> in component <code>A</code> and then doing <code>&lt;A bind:foo /&gt;</code> causes an error. Use <code>bind:this</code> instead — <code>&lt;A bind:this={a} /&gt;</code> — and access the export as <code>a.foo</code>. This change makes things easier to reason about, as it enforces a clear separation between props and exports.</p> <h3 id="Breaking-changes-in-runes-mode-Bindings-need-to-be-explicitly-defined-using-$bindable()">
<span>Bindings need to be explicitly defined using $bindable()</span>
</h3>
<p>In Svelte 4 syntax, every property (declared via <code>export let</code>) is bindable, meaning you can <code>bind:</code> to it. In runes mode, properties are not bindable by default: you need to denote bindable props with the <code>$bindable</code> rune.</p> <p>If a bindable property has a default value (e.g. <code>let { foo = $bindable('bar') } = $props();</code>), you need to pass a non-<code>undefined</code> value to that property if you’re binding to it. This prevents ambiguous behavior — the parent and child must have the same value — and results in better performance (in Svelte 4, the default value was reflected back to the parent, resulting in wasteful additional render cycles).</p> <h3 id="Breaking-changes-in-runes-mode-accessors-option-is-ignored">
<span>accessors option is ignored</span>
</h3>
<p>Setting the <code>accessors</code> option to <code>true</code> makes properties of a component directly accessible on the component instance. In runes mode, properties are never accessible on the component instance. You can use component exports instead if you need to expose them.</p> <h3 id="Breaking-changes-in-runes-mode-immutable-option-is-ignored">
<span>immutable option is ignored</span>
</h3>
<p>Setting the <code>immutable</code> option has no effect in runes mode. This concept is replaced by how <code>$state</code> and its variations work.</p> <h3 id="Breaking-changes-in-runes-mode-Classes-are-no-longer-auto-reactive">
<span>Classes are no longer “auto-reactive”</span>
</h3>
<p>In Svelte 4, doing the following triggered reactivity:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let foo = new Foo();
&lt;/script&gt;

&lt;button on:click={() =&gt; (foo.value = 1)}&gt;{foo.value}&lt;/button
&gt;</pre>
</div>
<p>This is because the Svelte compiler treated the assignment to <code>foo.value</code> as an instruction to update anything that referenced <code>foo</code>. In Svelte 5, reactivity is determined at runtime rather than compile time, so you should define <code>value</code> as a reactive <code>$state</code> field on the <code>Foo</code> class. Wrapping <code>new Foo()</code> with <code>$state(...)</code> will have no effect — only vanilla objects and arrays are made deeply reactive.</p> <h3 id="Breaking-changes-in-runes-mode-svelte:component-is-no-longer-necessary">
<span>&lt;svelte:component&gt; is no longer necessary</span>
</h3>
<p>In Svelte 4, components are <em>static</em> — if you render <code>&lt;Thing&gt;</code>, and the value of <code>Thing</code> changes, <a href="https://svelte.dev/playground/7f1fa24f0ab44c1089dcbb03568f8dfa?version=4.2.18">nothing happens</a>. To make it dynamic you must use <code>&lt;svelte:component&gt;</code>.</p> <p>This is no longer true in Svelte 5:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	import A from './A.svelte';
	import B from './B.svelte';

	let Thing = $state();
&lt;/script&gt;

&lt;select bind:value={Thing}&gt;
	&lt;option value={A}&gt;A&lt;/option&gt;
	&lt;option value={B}&gt;B&lt;/option&gt;
&lt;/select&gt;

&lt;!-- these are equivalent --&gt;
&lt;Thing /&gt;
&lt;svelte:component this={Thing} /&gt;</pre>
</div>
<h3 id="Breaking-changes-in-runes-mode-Touch-and-wheel-events-are-passive">
<span>Touch and wheel events are passive</span>
</h3>
<p>When using <code>onwheel</code>, <code>onmousewheel</code>, <code>ontouchstart</code> and <code>ontouchmove</code> event attributes, the handlers are <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#using_passive_listeners">passive</a> to align with browser defaults. This greatly improves responsiveness by allowing the browser to scroll the document immediately, rather than waiting to see if the event handler calls <code>event.preventDefault()</code>.</p> <p>In the very rare cases that you need to prevent these event defaults, you should use <a href="svelte-events.html#on"><code>on</code></a> instead (for example inside an action).</p> <h3 id="Breaking-changes-in-runes-mode-Attribute-prop-syntax-is-stricter">
<span>Attribute/prop syntax is stricter</span>
</h3>
<p>In Svelte 4, complex attribute values needn’t be quoted:</p>  <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;Component prop=this{is}valid /&gt;</pre>
</div>
<p>This is a footgun. In runes mode, if you want to concatenate stuff you must wrap the value in quotes:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;Component prop="this{is}valid" /&gt;</pre>
</div>
<p>Note that Svelte 5 will also warn if you have a single expression wrapped in quotes, like <code>answer="{42}"</code> — in Svelte 6, that will cause the value to be converted to a string, rather than passed as a number.</p> <h3 id="Breaking-changes-in-runes-mode-HTML-structure-is-stricter">
<span>HTML structure is stricter</span>
</h3>
<p>In Svelte 4, you were allowed to write HTML code that would be repaired by the browser when server side rendering it. For example you could write this...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;table&gt;
	&lt;tr&gt;
		&lt;td&gt;hi&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;</pre>
</div>
<p>... and the browser would auto-insert a <code>&lt;tbody&gt;</code> element:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;table&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;hi&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;</pre>
</div>
<p>Svelte 5 is more strict about the HTML structure and will throw a compiler error in cases where the browser would repair the DOM.</p> <h2 id="Other-breaking-changes">
<span>Other breaking changes</span>
</h2>
<h3 id="Other-breaking-changes-Stricter-const-assignment-validation">
<span>Stricter @const assignment validation</span>
</h3>
<p>Assignments to destructured parts of a <code>@const</code> declaration are no longer allowed. It was an oversight that this was ever allowed.</p> <h3 id="Other-breaking-changes-:is()-and-:where()-are-scoped">
<span>:is(...) and :where(...) are scoped</span>
</h3>
<p>Previously, Svelte did not analyse selectors inside <code>:is(...)</code> and <code>:where(...)</code>, effectively treating them as global. Svelte 5 analyses them in the context of the current component. As such, some selectors may now be treated as unused if they were relying on this treatment. To fix this, use <code>:global(...)</code> inside the <code>:is(...)/:where(...)</code> selectors.</p> <p>When using Tailwind’s <code>@apply</code> directive, add a <code>:global</code> selector to preserve rules that use Tailwind-generated <code>:is(...)</code> selectors:</p>  <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">main :global {
	@apply bg-blue-100 dark:bg-blue-900;
}</pre>
</div>
<h3 id="Other-breaking-changes-CSS-hash-position-no-longer-deterministic">
<span>CSS hash position no longer deterministic</span>
</h3>
<p>Previously Svelte would always insert the CSS hash last. This is no longer guaranteed in Svelte 5. This is only breaking if you <a href="https://stackoverflow.com/questions/15670631/does-the-order-of-classes-listed-on-an-item-affect-the-css">have very weird css selectors</a>.</p> <h3 id="Other-breaking-changes-Scoped-CSS-uses-:where()">
<span>Scoped CSS uses :where(...)</span>
</h3>
<p>To avoid issues caused by unpredictable specificity changes, scoped CSS selectors now use <code>:where(.svelte-xyz123)</code> selector modifiers alongside <code>.svelte-xyz123</code> (where <code>xyz123</code> is, as previously, a hash of the <code>&lt;style&gt;</code> contents). You can read more detail <a href="https://github.com/sveltejs/svelte/pull/10443">here</a>.</p> <p>In the event that you need to support ancient browsers that don’t implement <code>:where</code>, you can manually alter the emitted CSS, at the cost of unpredictable specificity changes:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">css = css.replace(/:where\((.+?)\)/, '$1');</pre>
</div>
<h3 id="Other-breaking-changes-Error-warning-codes-have-been-renamed">
<span>Error/warning codes have been renamed</span>
</h3>
<p>Error and warning codes have been renamed. Previously they used dashes to separate the words, they now use underscores (e.g. foo-bar becomes foo_bar). Additionally, a handful of codes have been reworded slightly.</p> <h3 id="Other-breaking-changes-Reduced-number-of-namespaces">
<span>Reduced number of namespaces</span>
</h3>
<p>The number of valid namespaces you can pass to the compiler option <code>namespace</code> has been reduced to <code>html</code> (the default), <code>mathml</code> and <code>svg</code>.</p> <p>The <code>foreign</code> namespace was only useful for Svelte Native, which we’re planning to support differently in a 5.x minor.</p> <h3 id="Other-breaking-changes-beforeUpdate-afterUpdate-changes">
<span>beforeUpdate/afterUpdate changes</span>
</h3>
<p><code>beforeUpdate</code> no longer runs twice on initial render if it modifies a variable referenced in the template.</p> <p><code>afterUpdate</code> callbacks in a parent component will now run after <code>afterUpdate</code> callbacks in any child components.</p> <p>Both functions are disallowed in runes mode — use <code>$effect.pre(...)</code> and <code>$effect(...)</code> instead.</p> <h3 id="Other-breaking-changes-contenteditable-behavior-change">
<span>contenteditable behavior change</span>
</h3>
<p>If you have a <code>contenteditable</code> node with a corresponding binding <em>and</em> a reactive value inside it (example: <code>&lt;div contenteditable=true bind:textContent&gt;count is {count}&lt;/div&gt;</code>), then the value inside the contenteditable will not be updated by updates to <code>count</code> because the binding takes full control over the content immediately and it should only be updated through it.</p> <h3 id="Other-breaking-changes-oneventname-attributes-no-longer-accept-string-values">
<span>oneventname attributes no longer accept string values</span>
</h3>
<p>In Svelte 4, it was possible to specify event attributes on HTML elements as a string:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;button onclick="alert('hello')"&gt;...&lt;/button&gt;</pre>
</div>
<p>This is not recommended, and is no longer possible in Svelte 5, where properties like <code>onclick</code> replace <code>on:click</code> as the mechanism for adding event handlers.</p> <h3 id="Other-breaking-changes-null-and-undefined-become-the-empty-string">
<span>null and undefined become the empty string</span>
</h3>
<p>In Svelte 4, <code>null</code> and <code>undefined</code> were printed as the corresponding string. In 99 out of 100 cases you want this to become the empty string instead, which is also what most other frameworks out there do. Therefore, in Svelte 5, <code>null</code> and <code>undefined</code> become the empty string.</p> <h3 id="Other-breaking-changes-bind:files-values-can-only-be-null-undefined-or-FileList">
<span>bind:files values can only be null, undefined or FileList</span>
</h3>
<p><code>bind:files</code> is now a two-way binding. As such, when setting a value, it needs to be either falsy (<code>null</code> or <code>undefined</code>) or of type <code>FileList</code>.</p> <h3 id="Other-breaking-changes-Bindings-now-react-to-form-resets">
<span>Bindings now react to form resets</span>
</h3>
<p>Previously, bindings did not take into account <code>reset</code> event of forms, and therefore values could get out of sync with the DOM. Svelte 5 fixes this by placing a <code>reset</code> listener on the document and invoking bindings where necessary.</p> <h3 id="Other-breaking-changes-walk-no-longer-exported">
<span>walk no longer exported</span>
</h3>
<p><code>svelte/compiler</code> reexported <code>walk</code> from <code>estree-walker</code> for convenience. This is no longer true in Svelte 5, import it directly from that package instead in case you need it.</p> <h3 id="Other-breaking-changes-Content-inside-svelte:options-is-forbidden">
<span>Content inside svelte:options is forbidden</span>
</h3>
<p>In Svelte 4 you could have content inside a <code>&lt;svelte:options /&gt;</code> tag. It was ignored, but you could write something in there. In Svelte 5, content inside that tag is a compiler error.</p> <h3 id="Other-breaking-changes-slot-elements-in-declarative-shadow-roots-are-preserved">
<span>&lt;slot&gt; elements in declarative shadow roots are preserved</span>
</h3>
<p>Svelte 4 replaced the <code>&lt;slot /&gt;</code> tag in all places with its own version of slots. Svelte 5 preserves them in the case they are a child of a <code>&lt;template shadowrootmode="..."&gt;</code> element.</p> <h3 id="Other-breaking-changes-svelte:element-tag-must-be-an-expression">
<span>&lt;svelte:element&gt; tag must be an expression</span>
</h3>
<p>In Svelte 4, <code>&lt;svelte:element this="div"&gt;</code> is valid code. This makes little sense — you should just do <code>&lt;div&gt;</code>. In the vanishingly rare case that you <em>do</em> need to use a literal value for some reason, you can do this:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;svelte:element this={"div"}&gt;</pre>
</div>
<p>Note that whereas Svelte 4 would treat <code>&lt;svelte:element this="input"&gt;</code> (for example) identically to <code>&lt;input&gt;</code> for the purposes of determining which <code>bind:</code> directives could be applied, Svelte 5 does not.</p> <h3 id="Other-breaking-changes-mount-plays-transitions-by-default">
<span>mount plays transitions by default</span>
</h3>
<p>The <code>mount</code> function used to render a component tree plays transitions by default unless the <code>intro</code> option is set to <code>false</code>. This is different from legacy class components which, when manually instantiated, didn’t play transitions by default.</p> <h3 id="Other-breaking-changes-img-src-and-html-hydration-mismatches-are-not-repaired">
<span>&lt;img src={...}&gt; and {@html ...} hydration mismatches are not repaired</span>
</h3>
<p>In Svelte 4, if the value of a <code>src</code> attribute or <code>{@html ...}</code> tag differ between server and client (a.k.a. a hydration mismatch), the mismatch is repaired. This is very costly: setting a <code>src</code> attribute (even if it evaluates to the same thing) causes images and iframes to be reloaded, and reinserting a large blob of HTML is slow.</p> <p>Since these mismatches are extremely rare, Svelte 5 assumes that the values are unchanged, but in development will warn you if they are not. To force an update you can do something like this:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0">&lt;script&gt;
	let { markup, src } = $props();

	if (typeof window !== 'undefined') {
		// stash the values...
		const initial = { markup, src };

		// unset them...
		markup = src = undefined;

		$effect(() =&gt; {
			// ...and reset after we've mounted
			markup = initial.markup;
			src = initial.src;
		});
	}
&lt;/script&gt;

{@html markup}
&lt;img {src} /&gt;</pre>
</div>
<h3 id="Other-breaking-changes-Hydration-works-differently">
<span>Hydration works differently</span>
</h3>
<p>Svelte 5 makes use of comments during server side rendering which are used for more robust and efficient hydration on the client. As such, you shouldn’t remove comments from your HTML output if you intend to hydrate it, and if you manually authored HTML to be hydrated by a Svelte component, you need to adjust that HTML to include said comments at the correct positions.</p> <h3 id="Other-breaking-changes-onevent-attributes-are-delegated">
<span>onevent attributes are delegated</span>
</h3>
<p>Event attributes replace event directives: Instead of <code>on:click={handler}</code> you write <code>onclick={handler}</code>. For backwards compatibility the <code>on:event</code> syntax is still supported and behaves the same as in Svelte 4. Some of the <code>onevent</code> attributes however are delegated, which means you need to take care to not stop event propagation on those manually, as they then might never reach the listener for this event type at the root.</p> <h3 id="Other-breaking-changes-style-props-uses-a-different-element">
<span>--style-props uses a different element</span>
</h3>
<p>Svelte 5 uses an extra <code>&lt;svelte-css-wrapper&gt;</code> element instead of a <code>&lt;div&gt;</code> to wrap the component when using CSS custom properties.</p> </div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2024 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/svelte/v5-migration-guide" class="_attribution-link">https://svelte.dev/docs/svelte/v5-migration-guide</a>
  </p>
</div>
