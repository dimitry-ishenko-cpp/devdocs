<h1>svelte/store</h1> <div class="text" id="docs-content">  <p>The <code>svelte/store</code> module exports functions for creating <a href="svelte-store.html#readable">readable</a>, <a href="svelte-store.html#writable">writable</a> and <a href="svelte-store.html#derived">derived</a> stores.</p> <p>Keep in mind that you don't <em>have</em> to use these functions to enjoy the <a href="svelte-components.html#script-4-prefix-stores-with-$-to-access-their-values">reactive <code>$store</code> syntax</a> in your components. Any object that correctly implements <code>.subscribe</code>, unsubscribe, and (optionally) <code>.set</code> is a valid store, and will work both with the special syntax, and with Svelte's built-in <a href="svelte-store.html#derived"><code>derived</code> stores</a>.</p> <p>This makes it possible to wrap almost any other reactive state handling library for use in Svelte. Read more about the <a href="svelte-components.html#script-4-prefix-stores-with-$-to-access-their-values">store contract</a> to see what a correct implementation looks like.</p> <h2 id="writable">writable</h2>
<div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">function writable&lt;T&gt;(
	value?: T | undefined,
	start?: StartStopNotifier&lt;T&gt; | undefined
): Writable&lt;T&gt;;</pre>
</div> <p>Function that creates a store which has values that can be set from 'outside' components. It gets created as an object with additional <code>set</code> and <code>update</code> methods.</p> <p><code>set</code> is a method that takes one argument which is the value to be set. The store value gets set to the value of the argument if the store value is not already equal to it.</p> <p><code>update</code> is a method that takes one argument which is a callback. The callback takes the existing store value as its argument and returns the new value to be set to the store.</p> <div class="js-version copy-code-block code-block">
<span class="filename">store.js</span><pre class="shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { writable } from 'svelte/store';


const count = writable(0);


count.subscribe((value) =&gt; {
	console.log(value);
}); // logs '0'


count.set(1); // logs '1'


count.update((n) =&gt; n + 1); // logs '2'</pre>
</div>
<div class="ts-version copy-code-block code-block">
<span class="filename">store.ts</span><pre class="shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { writable } from 'svelte/store';


const count = writable(0);


count.subscribe((value) =&gt; {
	console.log(value);
}); // logs '0'


count.set(1); // logs '1'


count.update((n) =&gt; n + 1); // logs '2'</pre>
</div>
<p>If a function is passed as the second argument, it will be called when the number of subscribers goes from zero to one (but not from one to two, etc). That function will be passed a <code>set</code> function which changes the value of the store, and an <code>update</code> function which works like the <code>update</code> method on the store, taking a callback to calculate the store's new value from its old value. It must return a <code>stop</code> function that is called when the subscriber count goes from one to zero.</p> <div class="js-version copy-code-block code-block">
<span class="filename">store.js</span><pre class="shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { writable } from 'svelte/store';


const count = writable(0, () =&gt; {
	console.log('got a subscriber');
	return () =&gt; console.log('no more subscribers');
});


count.set(1); // does nothing


const unsubscribe = count.subscribe((value) =&gt; {
	console.log(value);
}); // logs 'got a subscriber', then '1'


unsubscribe(); // logs 'no more subscribers'</pre>
</div>
<div class="ts-version copy-code-block code-block">
<span class="filename">store.ts</span><pre class="shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { writable } from 'svelte/store';


const count = writable(0, () =&gt; {
	console.log('got a subscriber');
	return () =&gt; console.log('no more subscribers');
});


count.set(1); // does nothing


const unsubscribe = count.subscribe((value) =&gt; {
	console.log(value);
}); // logs 'got a subscriber', then '1'


unsubscribe(); // logs 'no more subscribers'</pre>
</div>
<p>Note that the value of a <code>writable</code> is lost when it is destroyed, for example when the page is refreshed. However, you can write your own logic to sync the value to for example the <code>localStorage</code>.</p> <h2 id="readable">readable</h2>
<div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">function readable&lt;T&gt;(
	value?: T | undefined,
	start?: StartStopNotifier&lt;T&gt; | undefined
): Readable&lt;T&gt;;</pre>
</div> <p>Creates a store whose value cannot be set from 'outside', the first argument is the store's initial value, and the second argument to <code>readable</code> is the same as the second argument to <code>writable</code>.</p> <pre class="copy-code-block shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { readable } from 'svelte/store';


const time = readable(new Date(), (set) =&gt; {
	set(new Date());


	const interval = setInterval(() =&gt; {
		set(new Date());
	}, 1000);


	return () =&gt; clearInterval(interval);
});


const ticktock = readable('tick', (set, update) =&gt; {
	const interval = setInterval(() =&gt; {
		update((sound) =&gt; (sound === 'tick' ? 'tock' : 'tick'));
	}, 1000);


	return () =&gt; clearInterval(interval);
});</pre>
<h2 id="derived">derived</h2>
<div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">function derived&lt;S extends Stores, T&gt;(
	stores: S,
	fn: (
		values: StoresValues&lt;S&gt;,
		set: (value: T) =&gt; void,
		update: (fn: Updater&lt;T&gt;) =&gt; void
	) =&gt; Unsubscriber | void,
	initial_value?: T | undefined
): Readable&lt;T&gt;;</pre>
</div> <div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">function derived&lt;S extends Stores, T&gt;(
	stores: S,
	fn: (values: StoresValues&lt;S&gt;) =&gt; T,
	initial_value?: T | undefined
): Readable&lt;T&gt;;</pre>
</div> <p>Derives a store from one or more other stores. The callback runs initially when the first subscriber subscribes and then whenever the store dependencies change.</p> <p>In the simplest version, <code>derived</code> takes a single store, and the callback returns a derived value.</p> <pre class="copy-code-block shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { derived } from 'svelte/store';


const doubled = derived(a, ($a) =&gt; $a * 2);</pre>
<p>The callback can set a value asynchronously by accepting a second argument, <code>set</code>, and an optional third argument, <code>update</code>, calling either or both of them when appropriate.</p> <p>In this case, you can also pass a third argument to <code>derived</code> — the initial value of the derived store before <code>set</code> or <code>update</code> is first called. If no initial value is specified, the store's initial value will be <code>undefined</code>.</p> <pre class="copy-code-block shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { derived } from 'svelte/store';


const delayed = derived(
	a,
	($a, set) =&gt; {
		setTimeout(() =&gt; set($a), 1000);
	},
	2000
);


const delayedIncrement = derived(a, ($a, set, update) =&gt; {
	set($a);
	setTimeout(() =&gt; update((x) =&gt; x + 1), 1000);
	// every time $a produces a value, this produces two
	// values, $a immediately and then $a + 1 a second later
});</pre>
<p>If you return a function from the callback, it will be called when a) the callback runs again, or b) the last subscriber unsubscribes.</p> <pre class="copy-code-block shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { derived } from 'svelte/store';


const tick = derived(
	frequency,
	($frequency, set) =&gt; {
		const interval = setInterval(() =&gt; {
			set(Date.now());
		}, 1000 / $frequency);


		return () =&gt; {
			clearInterval(interval);
		};
	},
	2000
);</pre>
<p>In both cases, an array of arguments can be passed as the first argument instead of a single store.</p> <pre class="copy-code-block shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { derived } from 'svelte/store';


const summed = derived([a, b], ([$a, $b]) =&gt; $a + $b);


const delayed = derived([a, b], ([$a, $b], set) =&gt; {
	setTimeout(() =&gt; set($a + $b), 1000);
});</pre>
<h2 id="readonly">readonly</h2>
<div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">function readonly&lt;T&gt;(store: Readable&lt;T&gt;): Readable&lt;T&gt;;</pre>
</div> <p>This simple helper function makes a store readonly. You can still subscribe to the changes from the original one using this new readable store.</p> <pre class="copy-code-block shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { readonly, writable } from 'svelte/store';


const writableStore = writable(1);
const readableStore = readonly(writableStore);


readableStore.subscribe(console.log);


writableStore.set(2); // console: 2
readableStore.set(2); // ERROR</pre>
<h2 id="get">get</h2>
<div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">function get&lt;T&gt;(store: Readable&lt;T&gt;): T;</pre>
</div> <p>Generally, you should read the value of a store by subscribing to it and using the value as it changes over time. Occasionally, you may need to retrieve the value of a store to which you're not subscribed. <code>get</code> allows you to do so.</p> <blockquote> <p>This works by creating a subscription, reading the value, then unsubscribing. It's therefore not recommended in hot code paths.</p> </blockquote> <pre class="copy-code-block shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">import { get } from 'svelte/store';


const value = get(store);</pre>
<h2 id="types">Types</h2>
<h3 id="types-readable">Readable</h3>
<p>Readable interface for subscribing.</p> <div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">interface Readable&lt;T&gt; {…}</pre>
<div class="ts-block-property"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">subscribe(this: void, run: Subscriber&lt;T&gt;, invalidate?: Invalidator&lt;T&gt;): Unsubscriber;</pre>
<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> <ul> <li>
<code>run</code> subscription callback</li> <li>
<code>invalidate</code> cleanup callback</li>
</ul>
</div> <p>Subscribe on value changes.</p> </div>
</div>
</div> <h3 id="types-startstopnotifier">StartStopNotifier</h3>
<p>Start and stop notification callbacks. This function is called when the first subscriber subscribes.</p> <div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">type StartStopNotifier&lt;T&gt; = (
	set: (value: T) =&gt; void,
	update: (fn: Updater&lt;T&gt;) =&gt; void
) =&gt; void | (() =&gt; void);</pre>
</div> <h3 id="types-subscriber">Subscriber</h3>
<p>Callback to inform of a value updates.</p> <div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">type Subscriber&lt;T&gt; = (value: T) =&gt; void;</pre>
</div> <h3 id="types-unsubscriber">Unsubscriber</h3>
<p>Unsubscribes from value updates.</p> <div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">type Unsubscriber = () =&gt; void;</pre>
</div> <h3 id="types-updater">Updater</h3>
<p>Callback to update a value.</p> <div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">type Updater&lt;T&gt; = (value: T) =&gt; T;</pre>
</div> <h3 id="types-writable">Writable</h3>
<p>Writable interface for both updating and subscribing.</p> <div class="ts-block"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">interface Writable&lt;T&gt; extends Readable&lt;T&gt; {…}</pre>
<div class="ts-block-property"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">set(this: void, value: T): void;</pre>
<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> <ul> <li>
<code>value</code> to set</li>
</ul>
</div> <p>Set value and inform subscribers.</p> </div>
</div> <div class="ts-block-property"> <pre class="copy-code-block shiki css-variables" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">update(this: void, updater: Updater&lt;T&gt;): void;</pre>
<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> <ul> <li>
<code>updater</code> callback</li>
</ul>
</div> <p>Update value using callback and inform subscribers.</p> </div>
</div>
</div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2023 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/svelte-store" class="_attribution-link">https://svelte.dev/docs/svelte-store</a>
  </p>
</div>
