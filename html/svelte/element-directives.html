<h1>Element directives</h1> <div class="text" id="docs-content">  <p>As well as attributes, elements can have <em>directives</em>, which control the element's behaviour in some way.</p> <h2 id="on-eventname">on:<em>eventname</em>
</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">on:eventname={handler}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">on:eventname|modifiers={handler}</pre>
<p>Use the <code>on:</code> directive to listen to DOM events.</p> <div class="js-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	let count = 0;

	/** @param {MouseEvent} event */
	function handleClick(event) {
		count += 1;
	}
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
	count: {count}
&lt;/button&gt;</pre>
</div>
<div class="ts-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script lang="ts"&gt;
	let count = 0;
	
	function handleClick(event: MouseEvent) {
		count += 1;
	}
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
	count: {count}
&lt;/button&gt;</pre>
</div>
<p>Handlers can be declared inline with no performance penalty. As with attributes, directive values may be quoted for the sake of syntax highlighters.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;button on:click={() =&gt; (count += 1)}&gt;
	count: {count}
&lt;/button&gt;</pre>
<p>Add <em>modifiers</em> to DOM events with the <code>|</code> character.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;form on:submit|preventDefault={handleSubmit}&gt;
	&lt;!-- the `submit` event's default is prevented,
		 so the page won't reload --&gt;
&lt;/form&gt;</pre>
<p>The following modifiers are available:</p> <ul> <li>
<code>preventDefault</code> — calls <code>event.preventDefault()</code> before running the handler</li> <li>
<code>stopPropagation</code> — calls <code>event.stopPropagation()</code>, preventing the event reaching the next element</li> <li>
<code>stopImmediatePropagation</code> - calls <code>event.stopImmediatePropagation()</code>, preventing other listeners of the same event from being fired.</li> <li>
<code>passive</code> — improves scrolling performance on touch/wheel events (Svelte will add it automatically where it's safe to do so)</li> <li>
<code>nonpassive</code> — explicitly set <code>passive: false</code>
</li> <li>
<code>capture</code> — fires the handler during the <em>capture</em> phase instead of the <em>bubbling</em> phase</li> <li>
<code>once</code> — remove the handler after the first time it runs</li> <li>
<code>self</code> — only trigger handler if <code>event.target</code> is the element itself</li> <li>
<code>trusted</code> — only trigger handler if <code>event.isTrusted</code> is <code>true</code>. I.e. if the event is triggered by a user action.</li> </ul> <p>Modifiers can be chained together, e.g. <code>on:click|once|capture={...}</code>.</p> <p>If the <code>on:</code> directive is used without a value, the component will <em>forward</em> the event, meaning that a consumer of the component can listen for it.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;button on:click&gt; The component itself will emit the click event &lt;/button&gt;</pre>
<p>It's possible to have multiple event listeners for the same event:</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	let counter = 0;
	function increment() {
		counter = counter + 1;
	}

	/** @param {MouseEvent} event */
	function track(event) {
		trackEvent(event);
	}
&lt;/script&gt;

&lt;button on:click={increment} on:click={track}&gt;Click me!&lt;/button&gt;</pre>
<h2 id="bind-property">bind:<em>property</em>
</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">bind:property={variable}</pre>
<p>Data ordinarily flows down, from parent to child. The <code>bind:</code> directive allows data to flow the other way, from child to parent. Most bindings are specific to particular elements.</p> <p>The simplest bindings reflect the value of a property, such as <code>input.value</code>.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;input bind:value={name} /&gt;
&lt;textarea bind:value={text} /&gt;

&lt;input type="checkbox" bind:checked={yes} /&gt;</pre>
<p>If the name matches the value, you can use a shorthand.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;input bind:value /&gt;
&lt;!-- equivalent to
&lt;input bind:value={value} /&gt;
--&gt;</pre>
<p>Numeric input values are coerced; even though <code>input.value</code> is a string as far as the DOM is concerned, Svelte will treat it as a number. If the input is empty or invalid (in the case of <code>type="number"</code>), the value is <code>undefined</code>.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;input type="number" bind:value={num} /&gt;
&lt;input type="range" bind:value={num} /&gt;</pre>
<p>On <code>&lt;input&gt;</code> elements with <code>type="file"</code>, you can use <code>bind:files</code> to get the <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileList"><code>FileList</code> of selected files</a>. It is readonly.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;label for="avatar"&gt;Upload a picture:&lt;/label&gt;
&lt;input accept="image/png, image/jpeg" bind:files id="avatar" name="avatar" type="file" /&gt;</pre>
<p>If you're using <code>bind:</code> directives together with <code>on:</code> directives, the order that they're defined in affects the value of the bound variable when the event handler is called.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	let value = 'Hello World';
&lt;/script&gt;

&lt;input
	on:input={() =&gt; console.log('Old value:', value)}
	bind:value
	on:input={() =&gt; console.log('New value:', value)}
/&gt;</pre>
<p>Here we were binding to the value of a text input, which uses the <code>input</code> event. Bindings on other elements may use different events such as <code>change</code>.</p> <h2 id="binding-select-value">Binding &lt;select&gt; value</h2>
<p>A <code>&lt;select&gt;</code> value binding corresponds to the <code>value</code> property on the selected <code>&lt;option&gt;</code>, which can be any value (not just strings, as is normally the case in the DOM).</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;select bind:value={selected}&gt;
	&lt;option value={a}&gt;a&lt;/option&gt;
	&lt;option value={b}&gt;b&lt;/option&gt;
	&lt;option value={c}&gt;c&lt;/option&gt;
&lt;/select&gt;</pre>
<p>A <code>&lt;select multiple&gt;</code> element behaves similarly to a checkbox group. The bound variable is an array with an entry corresponding to the <code>value</code> property of each selected <code>&lt;option&gt;</code>.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;select multiple bind:value={fillings}&gt;
	&lt;option value="Rice"&gt;Rice&lt;/option&gt;
	&lt;option value="Beans"&gt;Beans&lt;/option&gt;
	&lt;option value="Cheese"&gt;Cheese&lt;/option&gt;
	&lt;option value="Guac (extra)"&gt;Guac (extra)&lt;/option&gt;
&lt;/select&gt;</pre>
<p>When the value of an <code>&lt;option&gt;</code> matches its text content, the attribute can be omitted.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;select multiple bind:value={fillings}&gt;
	&lt;option&gt;Rice&lt;/option&gt;
	&lt;option&gt;Beans&lt;/option&gt;
	&lt;option&gt;Cheese&lt;/option&gt;
	&lt;option&gt;Guac (extra)&lt;/option&gt;
&lt;/select&gt;</pre>
<p>Elements with the <code>contenteditable</code> attribute support the following bindings:</p> <ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML"><code>innerHTML</code></a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText"><code>innerText</code></a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent"><code>textContent</code></a></li> </ul> <p>There are slight differences between each of these, read more about them <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#Differences_from_innerText">here</a>.</p>   <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;div contenteditable="true" bind:innerHTML={html} /&gt;</pre>
<p><code>&lt;details&gt;</code> elements support binding to the <code>open</code> property.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;details bind:open={isOpen}&gt;
	&lt;summary&gt;Details&lt;/summary&gt;
	&lt;p&gt;Something small enough to escape casual notice.&lt;/p&gt;
&lt;/details&gt;</pre>
<h2 id="media-element-bindings">Media element bindings</h2>
<p>Media elements (<code>&lt;audio&gt;</code> and <code>&lt;video&gt;</code>) have their own set of bindings — seven <em>readonly</em> ones...</p> <ul> <li>
<code>duration</code> (readonly) — the total duration of the video, in seconds</li> <li>
<code>buffered</code> (readonly) — an array of <code>{start, end}</code> objects</li> <li>
<code>played</code> (readonly) — ditto</li> <li>
<code>seekable</code> (readonly) — ditto</li> <li>
<code>seeking</code> (readonly) — boolean</li> <li>
<code>ended</code> (readonly) — boolean</li> <li>
<code>readyState</code> (readonly) — number between (and including) 0 and 4</li> </ul> <p>...and five <em>two-way</em> bindings:</p> <ul> <li>
<code>currentTime</code> — the current playback time in the video, in seconds</li> <li>
<code>playbackRate</code> — how fast or slow to play the video, where 1 is 'normal'</li> <li>
<code>paused</code> — this one should be self-explanatory</li> <li>
<code>volume</code> — a value between 0 and 1</li> <li>
<code>muted</code> — a boolean value indicating whether the player is muted</li> </ul> <p>Videos additionally have readonly <code>videoWidth</code> and <code>videoHeight</code> bindings.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;video
	src={clip}
	bind:duration
	bind:buffered
	bind:played
	bind:seekable
	bind:seeking
	bind:ended
	bind:readyState
	bind:currentTime
	bind:playbackRate
	bind:paused
	bind:volume
	bind:muted
	bind:videoWidth
	bind:videoHeight
/&gt;</pre>
<h2 id="image-element-bindings">Image element bindings</h2>
<p>Image elements (<code>&lt;img&gt;</code>) have two readonly bindings:</p> <ul> <li>
<code>naturalWidth</code> (readonly) — the original width of the image, available after the image has loaded</li> <li>
<code>naturalHeight</code> (readonly) — the original height of the image, available after the image has loaded</li> </ul> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;img
	bind:naturalWidth
	bind:naturalHeight
&gt;&lt;/img&gt;</pre>
<h2 id="block-level-element-bindings">Block-level element bindings</h2>
<p>Block-level elements have 4 read-only bindings, measured using a technique similar to <a href="http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/">this one</a>:</p> <ul> <li><code>clientWidth</code></li> <li><code>clientHeight</code></li> <li><code>offsetWidth</code></li> <li><code>offsetHeight</code></li> </ul> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;div bind:offsetWidth={width} bind:offsetHeight={height}&gt;
	&lt;Chart {width} {height} /&gt;
&lt;/div&gt;</pre>
<h2 id="bind-group">bind:group</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">bind:group={variable}</pre>
<p>Inputs that work together can use <code>bind:group</code>.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	let tortilla = 'Plain';

	/** @type {Array&lt;string&gt;} */
	let fillings = [];
&lt;/script&gt;

&lt;!-- grouped radio inputs are mutually exclusive --&gt;
&lt;input type="radio" bind:group={tortilla} value="Plain" /&gt;
&lt;input type="radio" bind:group={tortilla} value="Whole wheat" /&gt;
&lt;input type="radio" bind:group={tortilla} value="Spinach" /&gt;

&lt;!-- grouped checkbox inputs populate an array --&gt;
&lt;input type="checkbox" bind:group={fillings} value="Rice" /&gt;
&lt;input type="checkbox" bind:group={fillings} value="Beans" /&gt;
&lt;input type="checkbox" bind:group={fillings} value="Cheese" /&gt;
&lt;input type="checkbox" bind:group={fillings} value="Guac (extra)" /&gt;</pre>
<blockquote> <p><code>bind:group</code> only works if the inputs are in the same Svelte component.</p> </blockquote> <h2 id="bind-this">bind:this</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">bind:this={dom_node}</pre>
<p>To get a reference to a DOM node, use <code>bind:this</code>.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	import { onMount } from 'svelte';

	/** @type {HTMLCanvasElement} */
	let canvasElement;

	onMount(() =&gt; {
		const ctx = canvasElement.getContext('2d');
		drawStuff(ctx);
	});
&lt;/script&gt;

&lt;canvas bind:this={canvasElement} /&gt;</pre>
<h2 id="class-name">class:<em>name</em>
</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">class:name={value}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">class:name</pre>
<p>A <code>class:</code> directive provides a shorter way of toggling a class on an element.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;!-- These are equivalent --&gt;
&lt;div class={isActive ? 'active' : ''}&gt;...&lt;/div&gt;
&lt;div class:active={isActive}&gt;...&lt;/div&gt;

&lt;!-- Shorthand, for when name and value match --&gt;
&lt;div class:active&gt;...&lt;/div&gt;

&lt;!-- Multiple class toggles can be included --&gt;
&lt;div class:active class:inactive={!active} class:isAdmin&gt;...&lt;/div&gt;</pre>
<h2 id="style-property">style:<em>property</em>
</h2>
<pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">style:property={value}</pre>
<pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">style:property="value"</pre>
<pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">style:property</pre>
<p>The <code>style:</code> directive provides a shorthand for setting multiple styles on an element.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;!-- These are equivalent --&gt;
&lt;div style:color="red"&gt;...&lt;/div&gt;
&lt;div style="color: red;"&gt;...&lt;/div&gt;

&lt;!-- Variables can be used --&gt;
&lt;div style:color={myColor}&gt;...&lt;/div&gt;

&lt;!-- Shorthand, for when property and variable name match --&gt;
&lt;div style:color&gt;...&lt;/div&gt;

&lt;!-- Multiple styles can be included --&gt;
&lt;div style:color style:width="12rem" style:background-color={darkMode ? 'black' : 'white'}&gt;...&lt;/div&gt;

&lt;!-- Styles can be marked as important --&gt;
&lt;div style:color|important="red"&gt;...&lt;/div&gt;</pre>
<p>When <code>style:</code> directives are combined with <code>style</code> attributes, the directives will take precedence:</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;div style="color: blue;" style:color="red"&gt;This will be red&lt;/div&gt;</pre>
<h2 id="use-action">use:<em>action</em>
</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">use:action</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">use:action={parameters}</pre>
<pre class="shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">action = (node: HTMLElement, parameters: any) =&gt; {
	update?: (parameters: any) =&gt; void,
	destroy?: () =&gt; void
}</pre>
<p>Actions are functions that are called when an element is created. They can return an object with a <code>destroy</code> method that is called after the element is unmounted:</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	/** @type {import('svelte/action').Action}  */
	function foo(node) {
		// the node has been mounted in the DOM

		return {
			destroy() {
				// the node has been removed from the DOM
			}
		};
	}
&lt;/script&gt;

&lt;div use:foo /&gt;</pre>
<p>An action can have a parameter. If the returned value has an <code>update</code> method, it will be called whenever that parameter changes, immediately after Svelte has applied updates to the markup.</p> <blockquote> <p>Don't worry about the fact that we're redeclaring the <code>foo</code> function for every component instance — Svelte will hoist any functions that don't depend on local state out of the component definition.</p> </blockquote> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	export let bar;

	/** @type {import('svelte/action').Action}  */
	function foo(node, bar) {
		// the node has been mounted in the DOM

		return {
			update(bar) {
				// the value of `bar` has changed
			},

			destroy() {
				// the node has been removed from the DOM
			}
		};
	}
&lt;/script&gt;

&lt;div use:foo={bar} /&gt;</pre>
<p>Read more in the <a href="svelte-action.html"><code>svelte/action</code></a> page.</p> <h2 id="transition-fn">transition:<em>fn</em>
</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">transition:fn</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">transition:fn={params}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">transition:fn|global</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">transition:fn|global={params}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">transition:fn|local</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">transition:fn|local={params}</pre>
<pre class="shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">transition = (node: HTMLElement, params: any, options: { direction: 'in' | 'out' | 'both' }) =&gt; {
	delay?: number,
	duration?: number,
	easing?: (t: number) =&gt; number,
	css?: (t: number, u: number) =&gt; string,
	tick?: (t: number, u: number) =&gt; void
}</pre>
<p>A transition is triggered by an element entering or leaving the DOM as a result of a state change.</p> <p>When a block is transitioning out, all elements inside the block, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed.</p> <p>The <code>transition:</code> directive indicates a <em>bidirectional</em> transition, which means it can be smoothly reversed while the transition is in progress.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#if visible}
	&lt;div transition:fade&gt;fades in and out&lt;/div&gt;
{/if}</pre>
<p>Transitions are local by default (in Svelte 3, they were global by default). Local transitions only play when the block they belong to is created or destroyed, <em>not</em> when parent blocks are created or destroyed.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#if x}
	{#if y}
		&lt;!-- Svelte 3: &lt;p transition:fade|local&gt; --&gt;
		&lt;p transition:fade&gt;fades in and out only when y changes&lt;/p&gt;

		&lt;!-- Svelte 3: &lt;p transition:fade&gt; --&gt;
		&lt;p transition:fade|global&gt;fades in and out when x or y change&lt;/p&gt;
	{/if}
{/if}</pre>
<blockquote> <p>By default intro transitions will not play on first render. You can modify this behaviour by setting <code>intro: true</code> when you <a href="client-side-component-api.html">create a component</a> and marking the transition as <code>global</code>.</p> </blockquote> <h2 id="transition-parameters">Transition parameters</h2>
<p>Like actions, transitions can have parameters.</p> <p>(The double <code>{{curlies}}</code> aren't a special syntax; this is an object literal inside an expression tag.)</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#if visible}
	&lt;div transition:fade={{ duration: 2000 }}&gt;fades in and out over two seconds&lt;/div&gt;
{/if}</pre>
<h2 id="custom-transition-functions">Custom transition functions</h2>
<p>Transitions can use custom functions. If the returned object has a <code>css</code> function, Svelte will create a CSS animation that plays on the element.</p> <p>The <code>t</code> argument passed to <code>css</code> is a value between <code>0</code> and <code>1</code> after the <code>easing</code> function has been applied. <em>In</em> transitions run from <code>0</code> to <code>1</code>, <em>out</em> transitions run from <code>1</code> to <code>0</code> — in other words, <code>1</code> is the element's natural state, as though no transition had been applied. The <code>u</code> argument is equal to <code>1 - t</code>.</p> <p>The function is called repeatedly <em>before</em> the transition begins, with different <code>t</code> and <code>u</code> arguments.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	import { elasticOut } from 'svelte/easing';

	/** @type {boolean} */
	export let visible;

	/**
	 * @param {HTMLElement} node
	 * @param {{ delay?: number, duration?: number, easing?: (t: number) =&gt; number }} params
	 */
	function whoosh(node, params) {
		const existingTransform = getComputedStyle(node).transform.replace('none', '');

		return {
			delay: params.delay || 0,
			duration: params.duration || 400,
			easing: params.easing || elasticOut,
			css: (t, u) =&gt; `transform: ${existingTransform} scale(${t})`
		};
	}
&lt;/script&gt;

{#if visible}
	&lt;div in:whoosh&gt;whooshes in&lt;/div&gt;
{/if}</pre>
<p>A custom transition function can also return a <code>tick</code> function, which is called <em>during</em> the transition with the same <code>t</code> and <code>u</code> arguments.</p> <blockquote> <p>If it's possible to use <code>css</code> instead of <code>tick</code>, do so — CSS animations can run off the main thread, preventing jank on slower devices.</p> </blockquote> <div class="js-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	export let visible = false;

	/**
	 * @param {HTMLElement} node
	 * @param {{ speed?: number }} params
	 */
	function typewriter(node, { speed = 1 }) {
		const valid = node.childNodes.length === 1 &amp;&amp; node.childNodes[0].nodeType === Node.TEXT_NODE;

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length / (speed * 0.01);

		return {
			duration,
			tick: (t) =&gt; {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
&lt;/script&gt;

{#if visible}
	&lt;p in:typewriter={{ speed: 1 }}&gt;The quick brown fox jumps over the lazy dog&lt;/p&gt;
{/if}</pre>
</div>
<div class="ts-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script lang="ts"&gt;
	export let visible = false;
	
	function typewriter(node: HTMLElement, { speed = 1 }: { speed?: number }) {
		const valid = node.childNodes.length === 1 &amp;&amp; node.childNodes[0].nodeType === Node.TEXT_NODE;
	
		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}
	
		const text = node.textContent;
		const duration = text.length / (speed * 0.01);
	
		return {
			duration,
			tick: (t) =&gt; {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			},
		};
	}
&lt;/script&gt;

{#if visible}
	&lt;p in:typewriter={{ speed: 1 }}&gt;The quick brown fox jumps over the lazy dog&lt;/p&gt;
{/if}</pre>
</div>
<p>If a transition returns a function instead of a transition object, the function will be called in the next microtask. This allows multiple transitions to coordinate, making <a href="https://learn.svelte.dev/tutorial/deferred-transitions">crossfade effects</a> possible.</p> <p>Transition functions also receive a third argument, <code>options</code>, which contains information about the transition.</p> <p>Available values in the <code>options</code> object are:</p> <ul> <li>
<code>direction</code> - one of <code>in</code>, <code>out</code>, or <code>both</code> depending on the type of transition</li> </ul> <h2 id="transition-events">Transition events</h2>
<p>An element with transitions will dispatch the following events in addition to any standard DOM events:</p> <ul> <li><code>introstart</code></li> <li><code>introend</code></li> <li><code>outrostart</code></li> <li><code>outroend</code></li> </ul> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#if visible}
	&lt;p
		transition:fly={{ y: 200, duration: 2000 }}
		on:introstart={() =&gt; (status = 'intro started')}
		on:outrostart={() =&gt; (status = 'outro started')}
		on:introend={() =&gt; (status = 'intro ended')}
		on:outroend={() =&gt; (status = 'outro ended')}
	&gt;
		Flies in and out
	&lt;/p&gt;
{/if}</pre>
<h2 id="in-fn-out-fn">in:<em>fn</em>/out:<em>fn</em>
</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">in:fn</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">in:fn={params}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">in:fn|global</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">in:fn|global={params}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">in:fn|local</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">in:fn|local={params}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">out:fn</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">out:fn={params}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">out:fn|global</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">out:fn|global={params}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">out:fn|local</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">out:fn|local={params}</pre>
<p>Similar to <code>transition:</code>, but only applies to elements entering (<code>in:</code>) or leaving (<code>out:</code>) the DOM.</p> <p>Unlike with <code>transition:</code>, transitions applied with <code>in:</code> and <code>out:</code> are not bidirectional — an in transition will continue to 'play' alongside the out transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#if visible}
	&lt;div in:fly out:fade&gt;flies in, fades out&lt;/div&gt;
{/if}</pre>
<h2 id="animate-fn">animate:<em>fn</em>
</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">animate:name</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">animate:name={params}</pre>
<pre class="shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">animation = (node: HTMLElement, { from: DOMRect, to: DOMRect } , params: any) =&gt; {
	delay?: number,
	duration?: number,
	easing?: (t: number) =&gt; number,
	css?: (t: number, u: number) =&gt; string,
	tick?: (t: number, u: number) =&gt; void
}</pre>
<pre class="shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">DOMRect {
	bottom: number,
	height: number,
	​​left: number,
	right: number,
	​top: number,
	width: number,
	x: number,
	y: number
}</pre>
<p>An animation is triggered when the contents of a <a href="logic-blocks.html#each">keyed each block</a> are re-ordered. Animations do not run when an element is added or removed, only when the index of an existing data item within the each block changes. Animate directives must be on an element that is an <em>immediate</em> child of a keyed each block.</p> <p>Animations can be used with Svelte's <a href="svelte-animate.html">built-in animation functions</a> or <a href="element-directives.html#custom-animation-functions">custom animation functions</a>.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;!-- When `list` is reordered the animation will run--&gt;
{#each list as item, index (item)}
	&lt;li animate:flip&gt;{item}&lt;/li&gt;
{/each}</pre>
<h2 id="animation-parameters">Animation Parameters</h2>
<p>As with actions and transitions, animations can have parameters.</p> <p>(The double <code>{{curlies}}</code> aren't a special syntax; this is an object literal inside an expression tag.)</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#each list as item, index (item)}
	&lt;li animate:flip={{ delay: 500 }}&gt;{item}&lt;/li&gt;
{/each}</pre>
<h2 id="custom-animation-functions">Custom animation functions</h2>
<p>Animations can use custom functions that provide the <code>node</code>, an <code>animation</code> object and any <code>parameters</code> as arguments. The <code>animation</code> parameter is an object containing <code>from</code> and <code>to</code> properties each containing a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMRect#Properties">DOMRect</a> describing the geometry of the element in its <code>start</code> and <code>end</code> positions. The <code>from</code> property is the DOMRect of the element in its starting position, and the <code>to</code> property is the DOMRect of the element in its final position after the list has been reordered and the DOM updated.</p> <p>If the returned object has a <code>css</code> method, Svelte will create a CSS animation that plays on the element.</p> <p>The <code>t</code> argument passed to <code>css</code> is a value that goes from <code>0</code> and <code>1</code> after the <code>easing</code> function has been applied. The <code>u</code> argument is equal to <code>1 - t</code>.</p> <p>The function is called repeatedly <em>before</em> the animation begins, with different <code>t</code> and <code>u</code> arguments.</p>  <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	import { cubicOut } from 'svelte/easing';

	/**
	 * @param {HTMLElement} node
	 * @param {{ from: DOMRect; to: DOMRect }} states
	 * @param {any} params
	 */
	function whizz(node, { from, to }, params) {
		const dx = from.left - to.left;
		const dy = from.top - to.top;

		const d = Math.sqrt(dx * dx + dy * dy);

		return {
			delay: 0,
			duration: Math.sqrt(d) * 120,
			easing: cubicOut,
			css: (t, u) =&gt; `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`
		};
	}
&lt;/script&gt;

{#each list as item, index (item)}
	&lt;div animate:whizz&gt;{item}&lt;/div&gt;
{/each}</pre>
<p>A custom animation function can also return a <code>tick</code> function, which is called <em>during</em> the animation with the same <code>t</code> and <code>u</code> arguments.</p> <blockquote> <p>If it's possible to use <code>css</code> instead of <code>tick</code>, do so — CSS animations can run off the main thread, preventing jank on slower devices.</p> </blockquote> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	import { cubicOut } from 'svelte/easing';

	/**
	 * @param {HTMLElement} node
	 * @param {{ from: DOMRect; to: DOMRect }} states
	 * @param {any} params
	 */
	function whizz(node, { from, to }, params) {
		const dx = from.left - to.left;
		const dy = from.top - to.top;

		const d = Math.sqrt(dx * dx + dy * dy);

		return {
			delay: 0,
			duration: Math.sqrt(d) * 120,
			easing: cubicOut,
			tick: (t, u) =&gt; Object.assign(node.style, { color: t &gt; 0.5 ? 'Pink' : 'Blue' })
		};
	}
&lt;/script&gt;

{#each list as item, index (item)}
	&lt;div animate:whizz&gt;{item}&lt;/div&gt;
{/each}</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2023 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/element-directives" class="_attribution-link">https://svelte.dev/docs/element-directives</a>
  </p>
</div>
