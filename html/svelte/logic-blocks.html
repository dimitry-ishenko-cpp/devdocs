<h1>Logic blocks</h1> <div class="text" id="docs-content">  <h2 id="if">{#if ...}</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#if expression}...{/if}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#if expression}...{:else if expression}...{/if}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#if expression}...{:else}...{/if}</pre>
<p>Content that is conditionally rendered can be wrapped in an if block.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#if answer === 42}
	&lt;p&gt;what was the question?&lt;/p&gt;
{/if}</pre>
<p>Additional conditions can be added with <code>{:else if expression}</code>, optionally ending in an <code>{:else}</code> clause.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#if porridge.temperature &gt; 100}
	&lt;p&gt;too hot!&lt;/p&gt;
{:else if 80 &gt; porridge.temperature}
	&lt;p&gt;too cold!&lt;/p&gt;
{:else}
	&lt;p&gt;just right!&lt;/p&gt;
{/if}</pre>
<p>(Blocks don't have to wrap elements, they can also wrap text within elements!)</p> <h2 id="each">{#each ...}</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#each expression as name}...{/each}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#each expression as name, index}...{/each}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#each expression as name (key)}...{/each}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#each expression as name, index (key)}...{/each}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#each expression as name}...{:else}...{/each}</pre>
<p>Iterating over lists of values can be done with an each block.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;h1&gt;Shopping list&lt;/h1&gt;
&lt;ul&gt;
	{#each items as item}
		&lt;li&gt;{item.name} x {item.qty}&lt;/li&gt;
	{/each}
&lt;/ul&gt;</pre>
<p>You can use each blocks to iterate over any array or array-like value — that is, any object with a <code>length</code> property.</p> <p>An each block can also specify an <em>index</em>, equivalent to the second argument in an <code>array.map(...)</code> callback:</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#each items as item, i}
	&lt;li&gt;{i + 1}: {item.name} x {item.qty}&lt;/li&gt;
{/each}</pre>
<p>If a <em>key</em> expression is provided — which must uniquely identify each list item — Svelte will use it to diff the list when data changes, rather than adding or removing items at the end. The key can be any object, but strings and numbers are recommended since they allow identity to persist when the objects themselves change.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#each items as item (item.id)}
	&lt;li&gt;{item.name} x {item.qty}&lt;/li&gt;
{/each}

&lt;!-- or with additional index value --&gt;
{#each items as item, i (item.id)}
	&lt;li&gt;{i + 1}: {item.name} x {item.qty}&lt;/li&gt;
{/each}</pre>
<p>You can freely use destructuring and rest patterns in each blocks.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#each items as { id, name, qty }, i (id)}
	&lt;li&gt;{i + 1}: {name} x {qty}&lt;/li&gt;
{/each}

{#each objects as { id, ...rest }}
	&lt;li&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;MyComponent {...rest} /&gt;&lt;/li&gt;
{/each}

{#each items as [id, ...rest]}
	&lt;li&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;MyComponent values={rest} /&gt;&lt;/li&gt;
{/each}</pre>
<p>An each block can also have an <code>{:else}</code> clause, which is rendered if the list is empty.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#each todos as todo}
	&lt;p&gt;{todo.text}&lt;/p&gt;
{:else}
	&lt;p&gt;No tasks today!&lt;/p&gt;
{/each}</pre>
<p>Since Svelte 4 it is possible to iterate over iterables like <code>Map</code> or <code>Set</code>. Iterables need to be finite and static (they shouldn't change while being iterated over). Under the hood, they are transformed to an array using <code>Array.from</code> before being passed off to rendering. If you're writing performance-sensitive code, try to avoid iterables and use regular arrays as they are more performant.</p> <h2 id="await">{#await ...}</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#await expression}...{:then name}...{:catch name}...{/await}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#await expression}...{:then name}...{/await}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#await expression then name}...{/await}</pre>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#await expression catch name}...{/await}</pre>
<p>Await blocks allow you to branch on the three possible states of a Promise — pending, fulfilled or rejected. In SSR mode, only the pending state will be rendered on the server.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#await promise}
	&lt;!-- promise is pending --&gt;
	&lt;p&gt;waiting for the promise to resolve...&lt;/p&gt;
{:then value}
	&lt;!-- promise was fulfilled --&gt;
	&lt;p&gt;The value is {value}&lt;/p&gt;
{:catch error}
	&lt;!-- promise was rejected --&gt;
	&lt;p&gt;Something went wrong: {error.message}&lt;/p&gt;
{/await}</pre>
<p>The <code>catch</code> block can be omitted if you don't need to render anything when the promise rejects (or no error is possible).</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#await promise}
	&lt;!-- promise is pending --&gt;
	&lt;p&gt;waiting for the promise to resolve...&lt;/p&gt;
{:then value}
	&lt;!-- promise was fulfilled --&gt;
	&lt;p&gt;The value is {value}&lt;/p&gt;
{/await}</pre>
<p>If you don't care about the pending state, you can also omit the initial block.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#await promise then value}
	&lt;p&gt;The value is {value}&lt;/p&gt;
{/await}</pre>
<p>Similarly, if you only want to show the error state, you can omit the <code>then</code> block.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#await promise catch error}
	&lt;p&gt;The error is {error}&lt;/p&gt;
{/await}</pre>
<h2 id="key">{#key ...}</h2>
<pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#key expression}...{/key}</pre>
<p>Key blocks destroy and recreate their contents when the value of an expression changes.</p> <p>This is useful if you want an element to play its transition whenever a value changes.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#key value}
	&lt;div transition:fade&gt;{value}&lt;/div&gt;
{/key}</pre>
<p>When used around components, this will cause them to be reinstantiated and reinitialised.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">{#key value}
	&lt;Component /&gt;
{/key}</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2023 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/logic-blocks" class="_attribution-link">https://svelte.dev/docs/logic-blocks</a>
  </p>
</div>
