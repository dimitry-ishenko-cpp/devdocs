<h1>Svelte components</h1> <div class="text" id="docs-content">  <p>Components are the building blocks of Svelte applications. They are written into <code>.svelte</code> files, using a superset of HTML.</p> <p>All three sections — script, styles and markup — are optional.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	// logic goes here
&lt;/script&gt;

&lt;!-- markup (zero or more items) goes here --&gt;

&lt;style&gt;
	/* styles go here */
&lt;/style&gt;</pre>
<h2 id="script">&lt;script&gt;</h2>
<p>A <code>&lt;script&gt;</code> block contains JavaScript that runs when a component instance is created. Variables declared (or imported) at the top level are 'visible' from the component's markup. There are four additional rules:</p> <h3 id="script-1-export-creates-a-component-prop">1. export creates a component prop</h3>
<p>Svelte uses the <code>export</code> keyword to mark a variable declaration as a <em>property</em> or <em>prop</em>, which means it becomes accessible to consumers of the component (see the section on <a href="basic-markup.html#attributes-and-props">attributes and props</a> for more information).</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	export let foo;

	// Values that are passed in as props
	// are immediately available
	console.log({ foo });
&lt;/script&gt;</pre>
<p>You can specify a default initial value for a prop. It will be used if the component's consumer doesn't specify the prop on the component (or if its initial value is <code>undefined</code>) when instantiating the component. Note that if the values of props are subsequently updated, then any prop whose value is not specified will be set to <code>undefined</code> (rather than its initial value).</p> <p>In development mode (see the <a href="svelte-compiler.html#compile">compiler options</a>), a warning will be printed if no default initial value is provided and the consumer does not specify a value. To squelch this warning, ensure that a default initial value is specified, even if it is <code>undefined</code>.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	export let bar = 'optional default initial value';
	export let baz = undefined;
&lt;/script&gt;</pre>
<p>If you export a <code>const</code>, <code>class</code> or <code>function</code>, it is readonly from outside the component. Functions are valid prop values, however, as shown below.</p> <div class="js-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	// these are readonly
	export const thisIs = 'readonly';

	/** @param {string} name */
	export function greet(name) {
		alert(`hello ${name}!`);
	}

	// this is a prop
	export let format = (n) =&gt; n.toFixed(2);
&lt;/script&gt;</pre>
</div>
<div class="ts-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script lang="ts"&gt;
	// these are readonly
	export const thisIs = 'readonly';
	
	export function greet(name: string) {
		alert(`hello ${name}!`);
	}
	
	// this is a prop
	export let format = (n) =&gt; n.toFixed(2);
&lt;/script&gt;</pre>
</div>
<p>Readonly props can be accessed as properties on the element, tied to the component using <a href="component-directives.html#bind-this"><code>bind:this</code> syntax</a>.</p> <p>You can use reserved words as prop names.</p> <div class="js-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	/** @type {string} */
	let className;

	// creates a `class` property, even
	// though it is a reserved word
	export { className as class };
&lt;/script&gt;</pre>
</div>
<div class="ts-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script lang="ts"&gt;
	let className: string;
	
	// creates a `class` property, even
	// though it is a reserved word
	export { className as class };
&lt;/script&gt;</pre>
</div>
<h3 id="script-2-assignments-are-reactive">2. Assignments are 'reactive'</h3>
<p>To change component state and trigger a re-render, just assign to a locally declared variable.</p> <p>Update expressions (<code>count += 1</code>) and property assignments (<code>obj.x = y</code>) have the same effect.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	let count = 0;

	function handleClick() {
		// calling this function will trigger an
		// update if the markup references `count`
		count = count + 1;
	}
&lt;/script&gt;</pre>
<p>Because Svelte's reactivity is based on assignments, using array methods like <code>.push()</code> and <code>.splice()</code> won't automatically trigger updates. A subsequent assignment is required to trigger the update. This and more details can also be found in the <a href="https://learn.svelte.dev/tutorial/updating-arrays-and-objects">tutorial</a>.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	let arr = [0, 1];

	function handleClick() {
		// this method call does not trigger an update
		arr.push(2);
		// this assignment will trigger an update
		// if the markup references `arr`
		arr = arr;
	}
&lt;/script&gt;</pre>
<p>Svelte's <code>&lt;script&gt;</code> blocks are run only when the component is created, so assignments within a <code>&lt;script&gt;</code> block are not automatically run again when a prop updates. If you'd like to track changes to a prop, see the next example in the following section.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	export let person;
	// this will only set `name` on component creation
	// it will not update when `person` does
	let { name } = person;
&lt;/script&gt;</pre>
<h3 id="script-3-$-marks-a-statement-as-reactive">3. $: marks a statement as reactive</h3>
<p>Any top-level statement (i.e. not inside a block or a function) can be made reactive by prefixing it with the <code>$:</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label">JS label syntax</a>. Reactive statements run after other script code and before the component markup is rendered, whenever the values that they depend on have changed.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	export let title;
	export let person;

	// this will update `document.title` whenever
	// the `title` prop changes
	$: document.title = title;

	$: {
		console.log(`multiple statements can be combined`);
		console.log(`the current title is ${title}`);
	}

	// this will update `name` when 'person' changes
	$: ({ name } = person);

	// don't do this. it will run before the previous line
	let name2 = name;
&lt;/script&gt;</pre>
<p>Only values which directly appear within the <code>$:</code> block will become dependencies of the reactive statement. For example, in the code below <code>total</code> will only update when <code>x</code> changes, but not <code>y</code>.</p> <div class="js-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	let x = 0;
	let y = 0;

	/** @param {number} value */
	function yPlusAValue(value) {
		return value + y;
	}

	$: total = yPlusAValue(x);
&lt;/script&gt;

Total: {total}
&lt;button on:click={() =&gt; x++}&gt; Increment X &lt;/button&gt;

&lt;button on:click={() =&gt; y++}&gt; Increment Y &lt;/button&gt;</pre>
</div>
<div class="ts-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script lang="ts"&gt;
	let x = 0;
	let y = 0;
	
	function yPlusAValue(value: number) {
		return value + y;
	}
	
	$: total = yPlusAValue(x);
&lt;/script&gt;

Total: {total}
&lt;button on:click={() =&gt; x++}&gt; Increment X &lt;/button&gt;

&lt;button on:click={() =&gt; y++}&gt; Increment Y &lt;/button&gt;</pre>
</div>
<p>It is important to note that the reactive blocks are ordered via simple static analysis at compile time, and all the compiler looks at are the variables that are assigned to and used within the block itself, not in any functions called by them. This means that <code>yDependent</code> will not be updated when <code>x</code> is updated in the following example:</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	let x = 0;
	let y = 0;

	/** @param {number} value */
	function setY(value) {
		y = value;
	}

	$: yDependent = y;
	$: setY(x);
&lt;/script&gt;</pre>
<p>Moving the line <code>$: yDependent = y</code> below <code>$: setY(x)</code> will cause <code>yDependent</code> to be updated when <code>x</code> is updated.</p> <p>If a statement consists entirely of an assignment to an undeclared variable, Svelte will inject a <code>let</code> declaration on your behalf.</p> <div class="js-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	/** @type {number} */
	export let num;

	// we don't need to declare `squared` and `cubed`
	// — Svelte does it for us
	$: squared = num * num;
	$: cubed = squared * num;
&lt;/script&gt;</pre>
</div>
<div class="ts-version copy-code-block code-block">
<span class="filename">App.svelte</span><pre class="shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script lang="ts"&gt;
	export let num: number;
	
	// we don't need to declare `squared` and `cubed`
	// — Svelte does it for us
	$: squared = num * num;
	$: cubed = squared * num;
&lt;/script&gt;</pre>
</div>
<h3 id="script-4-prefix-stores-with-$-to-access-their-values">4. Prefix stores with $ to access their values</h3>
<p>A <em>store</em> is an object that allows reactive access to a value via a simple <em>store contract</em>. The <a href="svelte-store.html"><code>svelte/store</code> module</a> contains minimal store implementations which fulfil this contract.</p> <p>Any time you have a reference to a store, you can access its value inside a component by prefixing it with the <code>$</code> character. This causes Svelte to declare the prefixed variable, subscribe to the store at component initialization and unsubscribe when appropriate.</p> <p>Assignments to <code>$</code>-prefixed variables require that the variable be a writable store, and will result in a call to the store's <code>.set</code> method.</p> <p>Note that the store must be declared at the top level of the component — not inside an <code>if</code> block or a function, for example.</p> <p>Local variables (that do not represent store values) must <em>not</em> have a <code>$</code> prefix.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script&gt;
	import { writable } from 'svelte/store';

	const count = writable(0);
	console.log($count); // logs 0

	count.set(1);
	console.log($count); // logs 1

	$count = 2;
	console.log($count); // logs 2
&lt;/script&gt;</pre>
<h4 id="script-4-prefix-stores-with-$-to-access-their-values-store-contract">Store contract</h4>
<pre class="copy-code-block shiki twoslash lsp" style="background-color: var(--shiki-color-background); color: var(--shiki-color-text)" data-language="javascript">store = { subscribe: (subscription: (value: any) =&gt; void) =&gt; (() =&gt; void), set?: (value: any) =&gt; void }</pre>
<p>You can create your own stores without relying on <a href="svelte-store.html"><code>svelte/store</code></a>, by implementing the <em>store contract</em>:</p> <ol> <li>A store must contain a <code>.subscribe</code> method, which must accept as its argument a subscription function. This subscription function must be immediately and synchronously called with the store's current value upon calling <code>.subscribe</code>. All of a store's active subscription functions must later be synchronously called whenever the store's value changes.</li> <li>The <code>.subscribe</code> method must return an unsubscribe function. Calling an unsubscribe function must stop its subscription, and its corresponding subscription function must not be called again by the store.</li> <li>A store may <em>optionally</em> contain a <code>.set</code> method, which must accept as its argument a new value for the store, and which synchronously calls all of the store's active subscription functions. Such a store is called a <em>writable store</em>.</li> </ol> <p>For interoperability with RxJS Observables, the <code>.subscribe</code> method is also allowed to return an object with an <code>.unsubscribe</code> method, rather than return the unsubscription function directly. Note however that unless <code>.subscribe</code> synchronously calls the subscription (which is not required by the Observable spec), Svelte will see the value of the store as <code>undefined</code> until it does.</p> <h2 id="script-context-module">&lt;script context="module"&gt;</h2>
<p>A <code>&lt;script&gt;</code> tag with a <code>context="module"</code> attribute runs once when the module first evaluates, rather than for each component instance. Values declared in this block are accessible from a regular <code>&lt;script&gt;</code> (and the component markup) but not vice versa.</p> <p>You can <code>export</code> bindings from this block, and they will become exports of the compiled module.</p> <p>You cannot <code>export default</code>, since the default export is the component itself.</p> <blockquote> <p>Variables defined in <code>module</code> scripts are not reactive — reassigning them will not trigger a rerender even though the variable itself will update. For values shared between multiple components, consider using a <a href="svelte-store.html">store</a>.</p> </blockquote> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;script context="module"&gt;
	let totalComponents = 0;

	// the export keyword allows this function to imported with e.g.
	// `import Example, { alertTotal } from './Example.svelte'`
	export function alertTotal() {
		alert(totalComponents);
	}
&lt;/script&gt;

&lt;script&gt;
	totalComponents += 1;
	console.log(`total number of times this component has been created: ${totalComponents}`);
&lt;/script&gt;</pre>
<h2 id="style">&lt;style&gt;</h2>
<p>CSS inside a <code>&lt;style&gt;</code> block will be scoped to that component.</p> <p>This works by adding a class to affected elements, which is based on a hash of the component styles (e.g. <code>svelte-123xyz</code>).</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;style&gt;
	p {
		/* this will only affect &lt;p&gt; elements in this component */
		color: burlywood;
	}
&lt;/style&gt;</pre>
<p>To apply styles to a selector globally, use the <code>:global(...)</code> modifier.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;style&gt;
	:global(body) {
		/* this will apply to &lt;body&gt; */
		margin: 0;
	}

	div :global(strong) {
		/* this will apply to all &lt;strong&gt; elements, in any
			 component, that are inside &lt;div&gt; elements belonging
			 to this component */
		color: goldenrod;
	}

	p:global(.red) {
		/* this will apply to all &lt;p&gt; elements belonging to this
			 component with a class of red, even if class="red" does
			 not initially appear in the markup, and is instead
			 added at runtime. This is useful when the class
			 of the element is dynamically applied, for instance
			 when updating the element's classList property directly. */
	}
&lt;/style&gt;</pre>
<p>If you want to make @keyframes that are accessible globally, you need to prepend your keyframe names with <code>-global-</code>.</p> <p>The <code>-global-</code> part will be removed when compiled, and the keyframe then be referenced using just <code>my-animation-name</code> elsewhere in your code.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;style&gt;
	@keyframes -global-my-animation-name {
		/* code goes here */
	}
&lt;/style&gt;</pre>
<p>There should only be 1 top-level <code>&lt;style&gt;</code> tag per component.</p> <p>However, it is possible to have <code>&lt;style&gt;</code> tag nested inside other elements or logic blocks.</p> <p>In that case, the <code>&lt;style&gt;</code> tag will be inserted as-is into the DOM, no scoping or processing will be done on the <code>&lt;style&gt;</code> tag.</p> <pre class="copy-code-block shiki" style="background-color: var(--shiki-color-background)" data-language="javascript">&lt;div&gt;
	&lt;style&gt;
		/* this style tag will be inserted as-is */
		div {
			/* this will apply to all `&lt;div&gt;` elements in the DOM */
			color: red;
		}
	&lt;/style&gt;
&lt;/div&gt;</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2023 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/svelte-components" class="_attribution-link">https://svelte.dev/docs/svelte-components</a>
  </p>
</div>
