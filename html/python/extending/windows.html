 <span id="building-on-windows"></span><h1> Building C and C++ Extensions on Windows</h1> <p>This chapter briefly explains how to create a Windows extension module for Python using Microsoft Visual C++, and follows with more detailed background information on how it works. The explanatory material is useful for both the Windows programmer learning to build Python extensions and the Unix programmer interested in producing software which can be successfully built on both Unix and Windows.</p> <p>Module authors are encouraged to use the distutils approach for building extension modules, instead of the one described in this section. You will still need the C compiler that was used to build Python; typically Microsoft Visual C++.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This chapter mentions a number of filenames that include an encoded Python version number. These filenames are represented with the version number shown as <code>XY</code>; in practice, <code>'X'</code> will be the major version number and <code>'Y'</code> will be the minor version number of the Python release you’re working with. For example, if you are using Python 2.2.1, <code>XY</code> will actually be <code>22</code>.</p> </div> <section id="a-cookbook-approach"> <span id="win-cookbook"></span><h2>
<span class="section-number">5.1. </span>A Cookbook Approach</h2> <p>There are two approaches to building extension modules on Windows, just as there are on Unix: use the <code>setuptools</code> package to control the build process, or do things manually. The setuptools approach works well for most extensions; documentation on using <code>setuptools</code> to build and package extension modules is available in <a class="reference internal" href="building.html#setuptools-index"><span class="std std-ref">Building C and C++ Extensions with setuptools</span></a>. If you find you really need to do things manually, it may be instructive to study the project file for the <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/PCbuild/winsound.vcxproj">winsound</a> standard library module.</p> </section> <section id="differences-between-unix-and-windows"> <span id="dynamic-linking"></span><h2>
<span class="section-number">5.2. </span>Differences Between Unix and Windows</h2> <p>Unix and Windows use completely different paradigms for run-time loading of code. Before you try to build a module that can be dynamically loaded, be aware of how your system works.</p> <p>In Unix, a shared object (<code>.so</code>) file contains code to be used by the program, and also the names of functions and data that it expects to find in the program. When the file is joined to the program, all references to those functions and data in the file’s code are changed to point to the actual locations in the program where the functions and data are placed in memory. This is basically a link operation.</p> <p>In Windows, a dynamic-link library (<code>.dll</code>) file has no dangling references. Instead, an access to functions or data goes through a lookup table. So the DLL code does not have to be fixed up at runtime to refer to the program’s memory; instead, the code already uses the DLL’s lookup table, and the lookup table is modified at runtime to point to the functions and data.</p> <p>In Unix, there is only one type of library file (<code>.a</code>) which contains code from several object files (<code>.o</code>). During the link step to create a shared object file (<code>.so</code>), the linker may find that it doesn’t know where an identifier is defined. The linker will look for it in the object files in the libraries; if it finds it, it will include all the code from that object file.</p> <p>In Windows, there are two types of library, a static library and an import library (both called <code>.lib</code>). A static library is like a Unix <code>.a</code> file; it contains code to be included as necessary. An import library is basically used only to reassure the linker that a certain identifier is legal, and will be present in the program when the DLL is loaded. So the linker uses the information from the import library to build the lookup table for using identifiers that are not included in the DLL. When an application or a DLL is linked, an import library may be generated, which will need to be used for all future DLLs that depend on the symbols in the application or DLL.</p> <p>Suppose you are building two dynamic-load modules, B and C, which should share another block of code A. On Unix, you would <em>not</em> pass <code>A.a</code> to the linker for <code>B.so</code> and <code>C.so</code>; that would cause it to be included twice, so that B and C would each have their own copy. In Windows, building <code>A.dll</code> will also build <code>A.lib</code>. You <em>do</em> pass <code>A.lib</code> to the linker for B and C. <code>A.lib</code> does not contain code; it just contains information which will be used at runtime to access A’s code.</p> <p>In Windows, using an import library is sort of like using <code>import spam</code>; it gives you access to spam’s names, but does not create a separate copy. On Unix, linking with a library is more like <code>from spam import *</code>; it does create a separate copy.</p> </section> <section id="using-dlls-in-practice"> <span id="win-dlls"></span><h2>
<span class="section-number">5.3. </span>Using DLLs in Practice</h2> <p>Windows Python is built in Microsoft Visual C++; using other compilers may or may not work. The rest of this section is MSVC++ specific.</p> <p>When creating DLLs in Windows, you must pass <code>pythonXY.lib</code> to the linker. To build two DLLs, spam and ni (which uses C functions found in spam), you could use these commands:</p> <pre data-language="c">cl /LD /I/python/include spam.c ../libs/pythonXY.lib
cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib
</pre> <p>The first command created three files: <code>spam.obj</code>, <code>spam.dll</code> and <code>spam.lib</code>. <code>Spam.dll</code> does not contain any Python functions (such as <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a>), but it does know how to find the Python code thanks to <code>pythonXY.lib</code>.</p> <p>The second command created <code>ni.dll</code> (and <code>.obj</code> and <code>.lib</code>), which knows how to find the necessary functions from spam, and also from the Python executable.</p> <p>Not every identifier is exported to the lookup table. If you want any other modules (including Python) to be able to see your identifiers, you have to say <code>_declspec(dllexport)</code>, as in <code>void _declspec(dllexport) initspam(void)</code> or <code>PyObject _declspec(dllexport) *NiGetSpamData(void)</code>.</p> <p>Developer Studio will throw in a lot of import libraries that you do not really need, adding about 100K to your executable. To get rid of them, use the Project Settings dialog, Link tab, to specify <em>ignore default libraries</em>. Add the correct <code>msvcrt<em>xx</em>.lib</code> to the list of libraries.</p> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/extending/windows.html" class="_attribution-link">https://docs.python.org/3.13/extending/windows.html</a>
  </p>
</div>
