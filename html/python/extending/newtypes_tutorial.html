 <span id="defining-new-types"></span><h1> Defining Extension Types: Tutorial</h1> <p>Python allows the writer of a C extension module to define new types that can be manipulated from Python code, much like the built-in <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> and <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code>list</code></a> types. The code for all extension types follows a pattern, but there are some details that you need to understand before you can get started. This document is a gentle introduction to the topic.</p> <section id="the-basics"> <span id="dnt-basics"></span><h2>
<span class="section-number">2.1. </span>The Basics</h2> <p>The <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a> runtime sees all Python objects as variables of type <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>, which serves as a “base type” for all Python objects. The <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> structure itself only contains the object’s <a class="reference internal" href="../glossary.html#term-reference-count"><span class="xref std std-term">reference count</span></a> and a pointer to the object’s “type object”. This is where the action is; the type object determines which (C) functions get called by the interpreter when, for instance, an attribute gets looked up on an object, a method called, or it is multiplied by another object. These C functions are called “type methods”.</p> <p>So, if you want to define a new extension type, you need to create a new type object.</p> <p>This sort of thing can only be explained by example, so here’s a minimal, but complete, module that defines a new type named <code>Custom</code> inside a C extension module <code>custom</code>:</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>What we’re showing here is the traditional way of defining <em>static</em> extension types. It should be adequate for most uses. The C API also allows defining heap-allocated extension types using the <a class="reference internal" href="../c-api/type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code>PyType_FromSpec()</code></a> function, which isn’t covered in this tutorial.</p> </div> <pre data-language="c">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

typedef struct {
    PyObject_HEAD
    /* Type-specific fields go here. */
} CustomObject;

static PyTypeObject CustomType = {
    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "custom.Custom",
    .tp_doc = PyDoc_STR("Custom objects"),
    .tp_basicsize = sizeof(CustomObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_new = PyType_GenericNew,
};

static PyModuleDef custommodule = {
    .m_base = PyModuleDef_HEAD_INIT,
    .m_name = "custom",
    .m_doc = "Example module that creates an extension type.",
    .m_size = -1,
};

PyMODINIT_FUNC
PyInit_custom(void)
{
    PyObject *m;
    if (PyType_Ready(&amp;CustomType) &lt; 0)
        return NULL;

    m = PyModule_Create(&amp;custommodule);
    if (m == NULL)
        return NULL;

    Py_INCREF(&amp;CustomType);
    if (PyModule_AddObject(m, "Custom", (PyObject *) &amp;CustomType) &lt; 0) {
        Py_DECREF(&amp;CustomType);
        Py_DECREF(m);
        return NULL;
    }

    return m;
}
</pre> <p>Now that’s quite a bit to take in at once, but hopefully bits will seem familiar from the previous chapter. This file defines three things:</p> <ol class="arabic simple"> <li>What a <code>Custom</code> <strong>object</strong> contains: this is the <code>CustomObject</code> struct, which is allocated once for each <code>Custom</code> instance.</li> <li>How the <code>Custom</code> <strong>type</strong> behaves: this is the <code>CustomType</code> struct, which defines a set of flags and function pointers that the interpreter inspects when specific operations are requested.</li> <li>How to initialize the <code>custom</code> module: this is the <code>PyInit_custom</code> function and the associated <code>custommodule</code> struct.</li> </ol> <p>The first bit is:</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
} CustomObject;
</pre> <p>This is what a Custom object will contain. <code>PyObject_HEAD</code> is mandatory at the start of each object struct and defines a field called <code>ob_base</code> of type <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a>, containing a pointer to a type object and a reference count (these can be accessed using the macros <a class="reference internal" href="../c-api/structures.html#c.Py_TYPE" title="Py_TYPE"><code>Py_TYPE</code></a> and <a class="reference internal" href="../c-api/refcounting.html#c.Py_REFCNT" title="Py_REFCNT"><code>Py_REFCNT</code></a> respectively). The reason for the macro is to abstract away the layout and to enable additional fields in <a class="reference internal" href="../using/configure.html#debug-build"><span class="std std-ref">debug builds</span></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>There is no semicolon above after the <a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code>PyObject_HEAD</code></a> macro. Be wary of adding one by accident: some compilers will complain.</p> </div> <p>Of course, objects generally store additional data besides the standard <code>PyObject_HEAD</code> boilerplate; for example, here is the definition for standard Python floats:</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
    double ob_fval;
} PyFloatObject;
</pre> <p>The second bit is the definition of the type object.</p> <pre data-language="c">static PyTypeObject CustomType = {
    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "custom.Custom",
    .tp_doc = PyDoc_STR("Custom objects"),
    .tp_basicsize = sizeof(CustomObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_new = PyType_GenericNew,
};
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>We recommend using C99-style designated initializers as above, to avoid listing all the <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> fields that you don’t care about and also to avoid caring about the fields’ declaration order.</p> </div> <p>The actual definition of <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> in <code>object.h</code> has many more <a class="reference internal" href="../c-api/typeobj.html#type-structs"><span class="std std-ref">fields</span></a> than the definition above. The remaining fields will be filled with zeros by the C compiler, and it’s common practice to not specify them explicitly unless you need them.</p> <p>We’re going to pick it apart, one field at a time:</p> <pre data-language="c">.ob_base = PyVarObject_HEAD_INIT(NULL, 0)
</pre> <p>This line is mandatory boilerplate to initialize the <code>ob_base</code> field mentioned above.</p> <pre data-language="c">.tp_name = "custom.Custom",
</pre> <p>The name of our type. This will appear in the default textual representation of our objects and in some error messages, for example:</p> <pre data-language="pycon">&gt;&gt;&gt; "" + custom.Custom()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate str (not "custom.Custom") to str
</pre> <p>Note that the name is a dotted name that includes both the module name and the name of the type within the module. The module in this case is <code>custom</code> and the type is <code>Custom</code>, so we set the type name to <code>custom.Custom</code>. Using the real dotted import path is important to make your type compatible with the <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code>pydoc</code></a> and <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> modules.</p> <pre data-language="c">.tp_basicsize = sizeof(CustomObject),
.tp_itemsize = 0,
</pre> <p>This is so that Python knows how much memory to allocate when creating new <code>Custom</code> instances. <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a> is only used for variable-sized objects and should otherwise be zero.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you want your type to be subclassable from Python, and your type has the same <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a> as its base type, you may have problems with multiple inheritance. A Python subclass of your type will have to list your type first in its <a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code>__bases__</code></a>, or else it will not be able to call your type’s <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> method without getting an error. You can avoid this problem by ensuring that your type has a larger value for <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a> than its base type does. Most of the time, this will be true anyway, because either your base type will be <a class="reference internal" href="../library/functions.html#object" title="object"><code>object</code></a>, or else you will be adding data members to your base type, and therefore increasing its size.</p> </div> <p>We set the class flags to <a class="reference internal" href="../c-api/typeobj.html#c.Py_TPFLAGS_DEFAULT" title="Py_TPFLAGS_DEFAULT"><code>Py_TPFLAGS_DEFAULT</code></a>.</p> <pre data-language="c">.tp_flags = Py_TPFLAGS_DEFAULT,
</pre> <p>All types should include this constant in their flags. It enables all of the members defined until at least Python 3.3. If you need further members, you will need to OR the corresponding flags.</p> <p>We provide a doc string for the type in <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_doc" title="PyTypeObject.tp_doc"><code>tp_doc</code></a>.</p> <pre data-language="c">.tp_doc = PyDoc_STR("Custom objects"),
</pre> <p>To enable object creation, we have to provide a <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> handler. This is the equivalent of the Python method <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a>, but has to be specified explicitly. In this case, we can just use the default implementation provided by the API function <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code>PyType_GenericNew()</code></a>.</p> <pre data-language="c">.tp_new = PyType_GenericNew,
</pre> <p>Everything else in the file should be familiar, except for some code in <code>PyInit_custom()</code>:</p> <pre data-language="c">if (PyType_Ready(&amp;CustomType) &lt; 0)
    return;
</pre> <p>This initializes the <code>Custom</code> type, filling in a number of members to the appropriate default values, including <a class="reference internal" href="../c-api/typeobj.html#c.PyObject.ob_type" title="PyObject.ob_type"><code>ob_type</code></a> that we initially set to <code>NULL</code>.</p> <pre data-language="c">Py_INCREF(&amp;CustomType);
if (PyModule_AddObject(m, "Custom", (PyObject *) &amp;CustomType) &lt; 0) {
    Py_DECREF(&amp;CustomType);
    Py_DECREF(m);
    return NULL;
}
</pre> <p>This adds the type to the module dictionary. This allows us to create <code>Custom</code> instances by calling the <code>Custom</code> class:</p> <pre data-language="pycon">&gt;&gt;&gt; import custom
&gt;&gt;&gt; mycustom = custom.Custom()
</pre> <p>That’s it! All that remains is to build it; put the above code in a file called <code>custom.c</code>,</p> <pre data-language="c">[build-system]
requires = ["setuptools"]
build-backend = "setuptools.build_meta"

[project]
name = "custom"
version = "1"
</pre> <p>in a file called <code>pyproject.toml</code>, and</p> <pre data-language="python">from setuptools import Extension, setup
setup(ext_modules=[Extension("custom", ["custom.c"])])
</pre> <p>in a file called <code>setup.py</code>; then typing</p> <pre data-language="shell">$ python -m pip install .
</pre> <p>in a shell should produce a file <code>custom.so</code> in a subdirectory and install it; now fire up Python — you should be able to <code>import custom</code> and play around with <code>Custom</code> objects.</p> <p>That wasn’t so hard, was it?</p> <p>Of course, the current Custom type is pretty uninteresting. It has no data and doesn’t do anything. It can’t even be subclassed.</p> </section> <section id="adding-data-and-methods-to-the-basic-example"> <h2>
<span class="section-number">2.2. </span>Adding data and methods to the Basic example</h2> <p>Let’s extend the basic example to add some data and methods. Let’s also make the type usable as a base class. We’ll create a new module, <code>custom2</code> that adds these capabilities:</p> <pre data-language="c">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;
#include &lt;stddef.h&gt; /* for offsetof() */

typedef struct {
    PyObject_HEAD
    PyObject *first; /* first name */
    PyObject *last;  /* last name */
    int number;
} CustomObject;

static void
Custom_dealloc(CustomObject *self)
{
    Py_XDECREF(self-&gt;first);
    Py_XDECREF(self-&gt;last);
    Py_TYPE(self)-&gt;tp_free((PyObject *) self);
}

static PyObject *
Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    CustomObject *self;
    self = (CustomObject *) type-&gt;tp_alloc(type, 0);
    if (self != NULL) {
        self-&gt;first = PyUnicode_FromString("");
        if (self-&gt;first == NULL) {
            Py_DECREF(self);
            return NULL;
        }
        self-&gt;last = PyUnicode_FromString("");
        if (self-&gt;last == NULL) {
            Py_DECREF(self);
            return NULL;
        }
        self-&gt;number = 0;
    }
    return (PyObject *) self;
}

static int
Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"first", "last", "number", NULL};
    PyObject *first = NULL, *last = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,
                                     &amp;first, &amp;last,
                                     &amp;self-&gt;number))
        return -1;

    if (first) {
        Py_XSETREF(self-&gt;first, Py_NewRef(first));
    }
    if (last) {
        Py_XSETREF(self-&gt;last, Py_NewRef(last));
    }
    return 0;
}

static PyMemberDef Custom_members[] = {
    {"first", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,
     "first name"},
    {"last", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,
     "last name"},
    {"number", Py_T_INT, offsetof(CustomObject, number), 0,
     "custom number"},
    {NULL}  /* Sentinel */
};

static PyObject *
Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))
{
    if (self-&gt;first == NULL) {
        PyErr_SetString(PyExc_AttributeError, "first");
        return NULL;
    }
    if (self-&gt;last == NULL) {
        PyErr_SetString(PyExc_AttributeError, "last");
        return NULL;
    }
    return PyUnicode_FromFormat("%S %S", self-&gt;first, self-&gt;last);
}

static PyMethodDef Custom_methods[] = {
    {"name", (PyCFunction) Custom_name, METH_NOARGS,
     "Return the name, combining the first and last name"
    },
    {NULL}  /* Sentinel */
};

static PyTypeObject CustomType = {
    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "custom2.Custom",
    .tp_doc = PyDoc_STR("Custom objects"),
    .tp_basicsize = sizeof(CustomObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = Custom_new,
    .tp_init = (initproc) Custom_init,
    .tp_dealloc = (destructor) Custom_dealloc,
    .tp_members = Custom_members,
    .tp_methods = Custom_methods,
};

static PyModuleDef custommodule = {
    .m_base =PyModuleDef_HEAD_INIT,
    .m_name = "custom2",
    .m_doc = "Example module that creates an extension type.",
    .m_size = -1,
};

PyMODINIT_FUNC
PyInit_custom2(void)
{
    PyObject *m;
    if (PyType_Ready(&amp;CustomType) &lt; 0)
        return NULL;

    m = PyModule_Create(&amp;custommodule);
    if (m == NULL)
        return NULL;

    if (PyModule_AddObjectRef(m, "Custom", (PyObject *) &amp;CustomType) &lt; 0) {
        Py_DECREF(m);
        return NULL;
    }

    return m;
}
</pre> <p>This version of the module has a number of changes.</p> <p>The <code>Custom</code> type now has three data attributes in its C struct, <em>first</em>, <em>last</em>, and <em>number</em>. The <em>first</em> and <em>last</em> variables are Python strings containing first and last names. The <em>number</em> attribute is a C integer.</p> <p>The object structure is updated accordingly:</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
    PyObject *first; /* first name */
    PyObject *last;  /* last name */
    int number;
} CustomObject;
</pre> <p>Because we now have data to manage, we have to be more careful about object allocation and deallocation. At a minimum, we need a deallocation method:</p> <pre data-language="c">static void
Custom_dealloc(CustomObject *self)
{
    Py_XDECREF(self-&gt;first);
    Py_XDECREF(self-&gt;last);
    Py_TYPE(self)-&gt;tp_free((PyObject *) self);
}
</pre> <p>which is assigned to the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a> member:</p> <pre data-language="c">.tp_dealloc = (destructor) Custom_dealloc,
</pre> <p>This method first clears the reference counts of the two Python attributes. <a class="reference internal" href="../c-api/refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code>Py_XDECREF()</code></a> correctly handles the case where its argument is <code>NULL</code> (which might happen here if <code>tp_new</code> failed midway). It then calls the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code>tp_free</code></a> member of the object’s type (computed by <code>Py_TYPE(self)</code>) to free the object’s memory. Note that the object’s type might not be <code>CustomType</code>, because the object may be an instance of a subclass.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The explicit cast to <code>destructor</code> above is needed because we defined <code>Custom_dealloc</code> to take a <code>CustomObject *</code> argument, but the <code>tp_dealloc</code> function pointer expects to receive a <code>PyObject *</code> argument. Otherwise, the compiler will emit a warning. This is object-oriented polymorphism, in C!</p> </div> <p>We want to make sure that the first and last names are initialized to empty strings, so we provide a <code>tp_new</code> implementation:</p> <pre data-language="c">static PyObject *
Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    CustomObject *self;
    self = (CustomObject *) type-&gt;tp_alloc(type, 0);
    if (self != NULL) {
        self-&gt;first = PyUnicode_FromString("");
        if (self-&gt;first == NULL) {
            Py_DECREF(self);
            return NULL;
        }
        self-&gt;last = PyUnicode_FromString("");
        if (self-&gt;last == NULL) {
            Py_DECREF(self);
            return NULL;
        }
        self-&gt;number = 0;
    }
    return (PyObject *) self;
}
</pre> <p>and install it in the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> member:</p> <pre data-language="c">.tp_new = Custom_new,
</pre> <p>The <code>tp_new</code> handler is responsible for creating (as opposed to initializing) objects of the type. It is exposed in Python as the <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> method. It is not required to define a <code>tp_new</code> member, and indeed many extension types will simply reuse <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code>PyType_GenericNew()</code></a> as done in the first version of the <code>Custom</code> type above. In this case, we use the <code>tp_new</code> handler to initialize the <code>first</code> and <code>last</code> attributes to non-<code>NULL</code> default values.</p> <p><code>tp_new</code> is passed the type being instantiated (not necessarily <code>CustomType</code>, if a subclass is instantiated) and any arguments passed when the type was called, and is expected to return the instance created. <code>tp_new</code> handlers always accept positional and keyword arguments, but they often ignore the arguments, leaving the argument handling to initializer (a.k.a. <code>tp_init</code> in C or <code>__init__</code> in Python) methods.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>tp_new</code> shouldn’t call <code>tp_init</code> explicitly, as the interpreter will do it itself.</p> </div> <p>The <code>tp_new</code> implementation calls the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code>tp_alloc</code></a> slot to allocate memory:</p> <pre data-language="c">self = (CustomObject *) type-&gt;tp_alloc(type, 0);
</pre> <p>Since memory allocation may fail, we must check the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code>tp_alloc</code></a> result against <code>NULL</code> before proceeding.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>We didn’t fill the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code>tp_alloc</code></a> slot ourselves. Rather <a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> fills it for us by inheriting it from our base class, which is <a class="reference internal" href="../library/functions.html#object" title="object"><code>object</code></a> by default. Most types use the default allocation strategy.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you are creating a co-operative <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> (one that calls a base type’s <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> or <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a>), you must <em>not</em> try to determine what method to call using method resolution order at runtime. Always statically determine what type you are going to call, and call its <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> directly, or via <code>type-&gt;tp_base-&gt;tp_new</code>. If you do not do this, Python subclasses of your type that also inherit from other Python-defined classes may not work correctly. (Specifically, you may not be able to create instances of such subclasses without getting a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.)</p> </div> <p>We also define an initialization function which accepts arguments to provide initial values for our instance:</p> <pre data-language="c">static int
Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"first", "last", "number", NULL};
    PyObject *first = NULL, *last = NULL, *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,
                                     &amp;first, &amp;last,
                                     &amp;self-&gt;number))
        return -1;

    if (first) {
        tmp = self-&gt;first;
        Py_INCREF(first);
        self-&gt;first = first;
        Py_XDECREF(tmp);
    }
    if (last) {
        tmp = self-&gt;last;
        Py_INCREF(last);
        self-&gt;last = last;
        Py_XDECREF(tmp);
    }
    return 0;
}
</pre> <p>by filling the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a> slot.</p> <pre data-language="c">.tp_init = (initproc) Custom_init,
</pre> <p>The <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a> slot is exposed in Python as the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> method. It is used to initialize an object after it’s created. Initializers always accept positional and keyword arguments, and they should return either <code>0</code> on success or <code>-1</code> on error.</p> <p>Unlike the <code>tp_new</code> handler, there is no guarantee that <code>tp_init</code> is called at all (for example, the <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module by default doesn’t call <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> on unpickled instances). It can also be called multiple times. Anyone can call the <code>__init__()</code> method on our objects. For this reason, we have to be extra careful when assigning the new attribute values. We might be tempted, for example to assign the <code>first</code> member like this:</p> <pre data-language="c">if (first) {
    Py_XDECREF(self-&gt;first);
    Py_INCREF(first);
    self-&gt;first = first;
}
</pre> <p>But this would be risky. Our type doesn’t restrict the type of the <code>first</code> member, so it could be any kind of object. It could have a destructor that causes code to be executed that tries to access the <code>first</code> member; or that destructor could release the <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">Global interpreter Lock</span></a> and let arbitrary code run in other threads that accesses and modifies our object.</p> <p>To be paranoid and protect ourselves against this possibility, we almost always reassign members before decrementing their reference counts. When don’t we have to do this?</p> <ul class="simple"> <li>when we absolutely know that the reference count is greater than 1;</li> <li>when we know that deallocation of the object <a class="footnote-reference brackets" href="#id5" id="id1">1</a> will neither release the <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> nor cause any calls back into our type’s code;</li> <li>when decrementing a reference count in a <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a> handler on a type which doesn’t support cyclic garbage collection <a class="footnote-reference brackets" href="#id6" id="id2">2</a>.</li> </ul> <p>We want to expose our instance variables as attributes. There are a number of ways to do that. The simplest way is to define member definitions:</p> <pre data-language="c">static PyMemberDef Custom_members[] = {
    {"first", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,
     "first name"},
    {"last", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,
     "last name"},
    {"number", Py_T_INT, offsetof(CustomObject, number), 0,
     "custom number"},
    {NULL}  /* Sentinel */
};
</pre> <p>and put the definitions in the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code>tp_members</code></a> slot:</p> <pre data-language="c">.tp_members = Custom_members,
</pre> <p>Each member definition has a member name, type, offset, access flags and documentation string. See the <a class="reference internal" href="newtypes.html#generic-attribute-management"><span class="std std-ref">Generic Attribute Management</span></a> section below for details.</p> <p>A disadvantage of this approach is that it doesn’t provide a way to restrict the types of objects that can be assigned to the Python attributes. We expect the first and last names to be strings, but any Python objects can be assigned. Further, the attributes can be deleted, setting the C pointers to <code>NULL</code>. Even though we can make sure the members are initialized to non-<code>NULL</code> values, the members can be set to <code>NULL</code> if the attributes are deleted.</p> <p>We define a single method, <code>Custom.name()</code>, that outputs the objects name as the concatenation of the first and last names.</p> <pre data-language="c">static PyObject *
Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))
{
    if (self-&gt;first == NULL) {
        PyErr_SetString(PyExc_AttributeError, "first");
        return NULL;
    }
    if (self-&gt;last == NULL) {
        PyErr_SetString(PyExc_AttributeError, "last");
        return NULL;
    }
    return PyUnicode_FromFormat("%S %S", self-&gt;first, self-&gt;last);
}
</pre> <p>The method is implemented as a C function that takes a <code>Custom</code> (or <code>Custom</code> subclass) instance as the first argument. Methods always take an instance as the first argument. Methods often take positional and keyword arguments as well, but in this case we don’t take any and don’t need to accept a positional argument tuple or keyword argument dictionary. This method is equivalent to the Python method:</p> <pre data-language="python">def name(self):
    return "%s %s" % (self.first, self.last)
</pre> <p>Note that we have to check for the possibility that our <code>first</code> and <code>last</code> members are <code>NULL</code>. This is because they can be deleted, in which case they are set to <code>NULL</code>. It would be better to prevent deletion of these attributes and to restrict the attribute values to be strings. We’ll see how to do that in the next section.</p> <p>Now that we’ve defined the method, we need to create an array of method definitions:</p> <pre data-language="c">static PyMethodDef Custom_methods[] = {
    {"name", (PyCFunction) Custom_name, METH_NOARGS,
     "Return the name, combining the first and last name"
    },
    {NULL}  /* Sentinel */
};
</pre> <p>(note that we used the <a class="reference internal" href="../c-api/structures.html#c.METH_NOARGS" title="METH_NOARGS"><code>METH_NOARGS</code></a> flag to indicate that the method is expecting no arguments other than <em>self</em>)</p> <p>and assign it to the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code>tp_methods</code></a> slot:</p> <pre data-language="c">.tp_methods = Custom_methods,
</pre> <p>Finally, we’ll make our type usable as a base class for subclassing. We’ve written our methods carefully so far so that they don’t make any assumptions about the type of the object being created or used, so all we need to do is to add the <a class="reference internal" href="../c-api/typeobj.html#c.Py_TPFLAGS_BASETYPE" title="Py_TPFLAGS_BASETYPE"><code>Py_TPFLAGS_BASETYPE</code></a> to our class flag definition:</p> <pre data-language="c">.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
</pre> <p>We rename <code>PyInit_custom()</code> to <code>PyInit_custom2()</code>, update the module name in the <a class="reference internal" href="../c-api/module.html#c.PyModuleDef" title="PyModuleDef"><code>PyModuleDef</code></a> struct, and update the full class name in the <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> struct.</p> <p>Finally, we update our <code>setup.py</code> file to include the new module,</p> <pre data-language="python">from setuptools import Extension, setup
setup(ext_modules=[
    Extension("custom", ["custom.c"]),
    Extension("custom2", ["custom2.c"]),
])
</pre> <p>and then we re-install so that we can <code>import custom2</code>:</p> <pre data-language="shell">$ python -m pip install .
</pre> </section> <section id="providing-finer-control-over-data-attributes"> <h2>
<span class="section-number">2.3. </span>Providing finer control over data attributes</h2> <p>In this section, we’ll provide finer control over how the <code>first</code> and <code>last</code> attributes are set in the <code>Custom</code> example. In the previous version of our module, the instance variables <code>first</code> and <code>last</code> could be set to non-string values or even deleted. We want to make sure that these attributes always contain strings.</p> <pre data-language="c">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;
#include &lt;stddef.h&gt; /* for offsetof() */

typedef struct {
    PyObject_HEAD
    PyObject *first; /* first name */
    PyObject *last;  /* last name */
    int number;
} CustomObject;

static void
Custom_dealloc(CustomObject *self)
{
    Py_XDECREF(self-&gt;first);
    Py_XDECREF(self-&gt;last);
    Py_TYPE(self)-&gt;tp_free((PyObject *) self);
}

static PyObject *
Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    CustomObject *self;
    self = (CustomObject *) type-&gt;tp_alloc(type, 0);
    if (self != NULL) {
        self-&gt;first = PyUnicode_FromString("");
        if (self-&gt;first == NULL) {
            Py_DECREF(self);
            return NULL;
        }
        self-&gt;last = PyUnicode_FromString("");
        if (self-&gt;last == NULL) {
            Py_DECREF(self);
            return NULL;
        }
        self-&gt;number = 0;
    }
    return (PyObject *) self;
}

static int
Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"first", "last", "number", NULL};
    PyObject *first = NULL, *last = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "|UUi", kwlist,
                                     &amp;first, &amp;last,
                                     &amp;self-&gt;number))
        return -1;

    if (first) {
        Py_SETREF(self-&gt;first, Py_NewRef(first));
    }
    if (last) {
        Py_SETREF(self-&gt;last, Py_NewRef(last));
    }
    return 0;
}

static PyMemberDef Custom_members[] = {
    {"number", Py_T_INT, offsetof(CustomObject, number), 0,
     "custom number"},
    {NULL}  /* Sentinel */
};

static PyObject *
Custom_getfirst(CustomObject *self, void *closure)
{
    return Py_NewRef(self-&gt;first);
}

static int
Custom_setfirst(CustomObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
        return -1;
    }
    if (!PyUnicode_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "The first attribute value must be a string");
        return -1;
    }
    Py_SETREF(self-&gt;first, Py_NewRef(value));
    return 0;
}

static PyObject *
Custom_getlast(CustomObject *self, void *closure)
{
    return Py_NewRef(self-&gt;last);
}

static int
Custom_setlast(CustomObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the last attribute");
        return -1;
    }
    if (!PyUnicode_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "The last attribute value must be a string");
        return -1;
    }
    Py_SETREF(self-&gt;last, Py_NewRef(value));
    return 0;
}

static PyGetSetDef Custom_getsetters[] = {
    {"first", (getter) Custom_getfirst, (setter) Custom_setfirst,
     "first name", NULL},
    {"last", (getter) Custom_getlast, (setter) Custom_setlast,
     "last name", NULL},
    {NULL}  /* Sentinel */
};

static PyObject *
Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))
{
    return PyUnicode_FromFormat("%S %S", self-&gt;first, self-&gt;last);
}

static PyMethodDef Custom_methods[] = {
    {"name", (PyCFunction) Custom_name, METH_NOARGS,
     "Return the name, combining the first and last name"
    },
    {NULL}  /* Sentinel */
};

static PyTypeObject CustomType = {
    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "custom3.Custom",
    .tp_doc = PyDoc_STR("Custom objects"),
    .tp_basicsize = sizeof(CustomObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = Custom_new,
    .tp_init = (initproc) Custom_init,
    .tp_dealloc = (destructor) Custom_dealloc,
    .tp_members = Custom_members,
    .tp_methods = Custom_methods,
    .tp_getset = Custom_getsetters,
};

static PyModuleDef custommodule = {
    .m_base = PyModuleDef_HEAD_INIT,
    .m_name = "custom3",
    .m_doc = "Example module that creates an extension type.",
    .m_size = -1,
};

PyMODINIT_FUNC
PyInit_custom3(void)
{
    PyObject *m;
    if (PyType_Ready(&amp;CustomType) &lt; 0)
        return NULL;

    m = PyModule_Create(&amp;custommodule);
    if (m == NULL)
        return NULL;

    if (PyModule_AddObjectRef(m, "Custom", (PyObject *) &amp;CustomType) &lt; 0) {
        Py_DECREF(m);
        return NULL;
    }

    return m;
}
</pre> <p>To provide greater control, over the <code>first</code> and <code>last</code> attributes, we’ll use custom getter and setter functions. Here are the functions for getting and setting the <code>first</code> attribute:</p> <pre data-language="c">static PyObject *
Custom_getfirst(CustomObject *self, void *closure)
{
    Py_INCREF(self-&gt;first);
    return self-&gt;first;
}

static int
Custom_setfirst(CustomObject *self, PyObject *value, void *closure)
{
    PyObject *tmp;
    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
        return -1;
    }
    if (!PyUnicode_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "The first attribute value must be a string");
        return -1;
    }
    tmp = self-&gt;first;
    Py_INCREF(value);
    self-&gt;first = value;
    Py_DECREF(tmp);
    return 0;
}
</pre> <p>The getter function is passed a <code>Custom</code> object and a “closure”, which is a void pointer. In this case, the closure is ignored. (The closure supports an advanced usage in which definition data is passed to the getter and setter. This could, for example, be used to allow a single set of getter and setter functions that decide the attribute to get or set based on data in the closure.)</p> <p>The setter function is passed the <code>Custom</code> object, the new value, and the closure. The new value may be <code>NULL</code>, in which case the attribute is being deleted. In our setter, we raise an error if the attribute is deleted or if its new value is not a string.</p> <p>We create an array of <a class="reference internal" href="../c-api/structures.html#c.PyGetSetDef" title="PyGetSetDef"><code>PyGetSetDef</code></a> structures:</p> <pre data-language="c">static PyGetSetDef Custom_getsetters[] = {
    {"first", (getter) Custom_getfirst, (setter) Custom_setfirst,
     "first name", NULL},
    {"last", (getter) Custom_getlast, (setter) Custom_setlast,
     "last name", NULL},
    {NULL}  /* Sentinel */
};
</pre> <p>and register it in the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code>tp_getset</code></a> slot:</p> <pre data-language="c">.tp_getset = Custom_getsetters,
</pre> <p>The last item in a <a class="reference internal" href="../c-api/structures.html#c.PyGetSetDef" title="PyGetSetDef"><code>PyGetSetDef</code></a> structure is the “closure” mentioned above. In this case, we aren’t using a closure, so we just pass <code>NULL</code>.</p> <p>We also remove the member definitions for these attributes:</p> <pre data-language="c">static PyMemberDef Custom_members[] = {
    {"number", Py_T_INT, offsetof(CustomObject, number), 0,
     "custom number"},
    {NULL}  /* Sentinel */
};
</pre> <p>We also need to update the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a> handler to only allow strings <a class="footnote-reference brackets" href="#id7" id="id3">3</a> to be passed:</p> <pre data-language="c">static int
Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"first", "last", "number", NULL};
    PyObject *first = NULL, *last = NULL, *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "|UUi", kwlist,
                                     &amp;first, &amp;last,
                                     &amp;self-&gt;number))
        return -1;

    if (first) {
        tmp = self-&gt;first;
        Py_INCREF(first);
        self-&gt;first = first;
        Py_DECREF(tmp);
    }
    if (last) {
        tmp = self-&gt;last;
        Py_INCREF(last);
        self-&gt;last = last;
        Py_DECREF(tmp);
    }
    return 0;
}
</pre> <p>With these changes, we can assure that the <code>first</code> and <code>last</code> members are never <code>NULL</code> so we can remove checks for <code>NULL</code> values in almost all cases. This means that most of the <a class="reference internal" href="../c-api/refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code>Py_XDECREF()</code></a> calls can be converted to <a class="reference internal" href="../c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> calls. The only place we can’t change these calls is in the <code>tp_dealloc</code> implementation, where there is the possibility that the initialization of these members failed in <code>tp_new</code>.</p> <p>We also rename the module initialization function and module name in the initialization function, as we did before, and we add an extra definition to the <code>setup.py</code> file.</p> </section> <section id="supporting-cyclic-garbage-collection"> <h2>
<span class="section-number">2.4. </span>Supporting cyclic garbage collection</h2> <p>Python has a <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector (GC)</span></a> that can identify unneeded objects even when their reference counts are not zero. This can happen when objects are involved in cycles. For example, consider:</p> <pre data-language="pycon">&gt;&gt;&gt; l = []
&gt;&gt;&gt; l.append(l)
&gt;&gt;&gt; del l
</pre> <p>In this example, we create a list that contains itself. When we delete it, it still has a reference from itself. Its reference count doesn’t drop to zero. Fortunately, Python’s cyclic garbage collector will eventually figure out that the list is garbage and free it.</p> <p>In the second version of the <code>Custom</code> example, we allowed any kind of object to be stored in the <code>first</code> or <code>last</code> attributes <a class="footnote-reference brackets" href="#id8" id="id4">4</a>. Besides, in the second and third versions, we allowed subclassing <code>Custom</code>, and subclasses may add arbitrary attributes. For any of those two reasons, <code>Custom</code> objects can participate in cycles:</p> <pre data-language="pycon">&gt;&gt;&gt; import custom3
&gt;&gt;&gt; class Derived(custom3.Custom): pass
...
&gt;&gt;&gt; n = Derived()
&gt;&gt;&gt; n.some_attribute = n
</pre> <p>To allow a <code>Custom</code> instance participating in a reference cycle to be properly detected and collected by the cyclic GC, our <code>Custom</code> type needs to fill two additional slots and to enable a flag that enables these slots:</p> <pre data-language="c">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;
#include &lt;stddef.h&gt; /* for offsetof() */

typedef struct {
    PyObject_HEAD
    PyObject *first; /* first name */
    PyObject *last;  /* last name */
    int number;
} CustomObject;

static int
Custom_traverse(CustomObject *self, visitproc visit, void *arg)
{
    Py_VISIT(self-&gt;first);
    Py_VISIT(self-&gt;last);
    return 0;
}

static int
Custom_clear(CustomObject *self)
{
    Py_CLEAR(self-&gt;first);
    Py_CLEAR(self-&gt;last);
    return 0;
}

static void
Custom_dealloc(CustomObject *self)
{
    PyObject_GC_UnTrack(self);
    Custom_clear(self);
    Py_TYPE(self)-&gt;tp_free((PyObject *) self);
}

static PyObject *
Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    CustomObject *self;
    self = (CustomObject *) type-&gt;tp_alloc(type, 0);
    if (self != NULL) {
        self-&gt;first = PyUnicode_FromString("");
        if (self-&gt;first == NULL) {
            Py_DECREF(self);
            return NULL;
        }
        self-&gt;last = PyUnicode_FromString("");
        if (self-&gt;last == NULL) {
            Py_DECREF(self);
            return NULL;
        }
        self-&gt;number = 0;
    }
    return (PyObject *) self;
}

static int
Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"first", "last", "number", NULL};
    PyObject *first = NULL, *last = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "|UUi", kwlist,
                                     &amp;first, &amp;last,
                                     &amp;self-&gt;number))
        return -1;

    if (first) {
        Py_SETREF(self-&gt;first, Py_NewRef(first));
    }
    if (last) {
        Py_SETREF(self-&gt;last, Py_NewRef(last));
    }
    return 0;
}

static PyMemberDef Custom_members[] = {
    {"number", Py_T_INT, offsetof(CustomObject, number), 0,
     "custom number"},
    {NULL}  /* Sentinel */
};

static PyObject *
Custom_getfirst(CustomObject *self, void *closure)
{
    return Py_NewRef(self-&gt;first);
}

static int
Custom_setfirst(CustomObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
        return -1;
    }
    if (!PyUnicode_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "The first attribute value must be a string");
        return -1;
    }
    Py_XSETREF(self-&gt;first, Py_NewRef(value));
    return 0;
}

static PyObject *
Custom_getlast(CustomObject *self, void *closure)
{
    return Py_NewRef(self-&gt;last);
}

static int
Custom_setlast(CustomObject *self, PyObject *value, void *closure)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the last attribute");
        return -1;
    }
    if (!PyUnicode_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "The last attribute value must be a string");
        return -1;
    }
    Py_XSETREF(self-&gt;last, Py_NewRef(value));
    return 0;
}

static PyGetSetDef Custom_getsetters[] = {
    {"first", (getter) Custom_getfirst, (setter) Custom_setfirst,
     "first name", NULL},
    {"last", (getter) Custom_getlast, (setter) Custom_setlast,
     "last name", NULL},
    {NULL}  /* Sentinel */
};

static PyObject *
Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))
{
    return PyUnicode_FromFormat("%S %S", self-&gt;first, self-&gt;last);
}

static PyMethodDef Custom_methods[] = {
    {"name", (PyCFunction) Custom_name, METH_NOARGS,
     "Return the name, combining the first and last name"
    },
    {NULL}  /* Sentinel */
};

static PyTypeObject CustomType = {
    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "custom4.Custom",
    .tp_doc = PyDoc_STR("Custom objects"),
    .tp_basicsize = sizeof(CustomObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
    .tp_new = Custom_new,
    .tp_init = (initproc) Custom_init,
    .tp_dealloc = (destructor) Custom_dealloc,
    .tp_traverse = (traverseproc) Custom_traverse,
    .tp_clear = (inquiry) Custom_clear,
    .tp_members = Custom_members,
    .tp_methods = Custom_methods,
    .tp_getset = Custom_getsetters,
};

static PyModuleDef custommodule = {
    .m_base = PyModuleDef_HEAD_INIT,
    .m_name = "custom4",
    .m_doc = "Example module that creates an extension type.",
    .m_size = -1,
};

PyMODINIT_FUNC
PyInit_custom4(void)
{
    PyObject *m;
    if (PyType_Ready(&amp;CustomType) &lt; 0)
        return NULL;

    m = PyModule_Create(&amp;custommodule);
    if (m == NULL)
        return NULL;

    if (PyModule_AddObjectRef(m, "Custom", (PyObject *) &amp;CustomType) &lt; 0) {
        Py_DECREF(m);
        return NULL;
    }

    return m;
}
</pre> <p>First, the traversal method lets the cyclic GC know about subobjects that could participate in cycles:</p> <pre data-language="c">static int
Custom_traverse(CustomObject *self, visitproc visit, void *arg)
{
    int vret;
    if (self-&gt;first) {
        vret = visit(self-&gt;first, arg);
        if (vret != 0)
            return vret;
    }
    if (self-&gt;last) {
        vret = visit(self-&gt;last, arg);
        if (vret != 0)
            return vret;
    }
    return 0;
}
</pre> <p>For each subobject that can participate in cycles, we need to call the <code>visit()</code> function, which is passed to the traversal method. The <code>visit()</code> function takes as arguments the subobject and the extra argument <em>arg</em> passed to the traversal method. It returns an integer value that must be returned if it is non-zero.</p> <p>Python provides a <a class="reference internal" href="../c-api/gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code>Py_VISIT()</code></a> macro that automates calling visit functions. With <a class="reference internal" href="../c-api/gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code>Py_VISIT()</code></a>, we can minimize the amount of boilerplate in <code>Custom_traverse</code>:</p> <pre data-language="c">static int
Custom_traverse(CustomObject *self, visitproc visit, void *arg)
{
    Py_VISIT(self-&gt;first);
    Py_VISIT(self-&gt;last);
    return 0;
}
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> implementation must name its arguments exactly <em>visit</em> and <em>arg</em> in order to use <a class="reference internal" href="../c-api/gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code>Py_VISIT()</code></a>.</p> </div> <p>Second, we need to provide a method for clearing any subobjects that can participate in cycles:</p> <pre data-language="c">static int
Custom_clear(CustomObject *self)
{
    Py_CLEAR(self-&gt;first);
    Py_CLEAR(self-&gt;last);
    return 0;
}
</pre> <p>Notice the use of the <a class="reference internal" href="../c-api/refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code>Py_CLEAR()</code></a> macro. It is the recommended and safe way to clear data attributes of arbitrary types while decrementing their reference counts. If you were to call <a class="reference internal" href="../c-api/refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code>Py_XDECREF()</code></a> instead on the attribute before setting it to <code>NULL</code>, there is a possibility that the attribute’s destructor would call back into code that reads the attribute again (<em>especially</em> if there is a reference cycle).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You could emulate <a class="reference internal" href="../c-api/refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code>Py_CLEAR()</code></a> by writing:</p> <pre data-language="c">PyObject *tmp;
tmp = self-&gt;first;
self-&gt;first = NULL;
Py_XDECREF(tmp);
</pre> <p>Nevertheless, it is much easier and less error-prone to always use <a class="reference internal" href="../c-api/refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code>Py_CLEAR()</code></a> when deleting an attribute. Don’t try to micro-optimize at the expense of robustness!</p> </div> <p>The deallocator <code>Custom_dealloc</code> may call arbitrary code when clearing attributes. It means the circular GC can be triggered inside the function. Since the GC assumes reference count is not zero, we need to untrack the object from the GC by calling <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code>PyObject_GC_UnTrack()</code></a> before clearing members. Here is our reimplemented deallocator using <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code>PyObject_GC_UnTrack()</code></a> and <code>Custom_clear</code>:</p> <pre data-language="c">static void
Custom_dealloc(CustomObject *self)
{
    PyObject_GC_UnTrack(self);
    Custom_clear(self);
    Py_TYPE(self)-&gt;tp_free((PyObject *) self);
}
</pre> <p>Finally, we add the <a class="reference internal" href="../c-api/typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag to the class flags:</p> <pre data-language="c">.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
</pre> <p>That’s pretty much it. If we had written custom <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code>tp_alloc</code></a> or <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code>tp_free</code></a> handlers, we’d need to modify them for cyclic garbage collection. Most extensions will use the versions automatically provided.</p> </section> <section id="subclassing-other-types"> <h2>
<span class="section-number">2.5. </span>Subclassing other types</h2> <p>It is possible to create new extension types that are derived from existing types. It is easiest to inherit from the built in types, since an extension can easily use the <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> it needs. It can be difficult to share these <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> structures between extension modules.</p> <p>In this example we will create a <code>SubList</code> type that inherits from the built-in <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code>list</code></a> type. The new type will be completely compatible with regular lists, but will have an additional <code>increment()</code> method that increases an internal counter:</p> <pre data-language="pycon">&gt;&gt;&gt; import sublist
&gt;&gt;&gt; s = sublist.SubList(range(3))
&gt;&gt;&gt; s.extend(s)
&gt;&gt;&gt; print(len(s))
6
&gt;&gt;&gt; print(s.increment())
1
&gt;&gt;&gt; print(s.increment())
2
</pre> <pre data-language="c">#define PY_SSIZE_T_CLEAN
#include &lt;Python.h&gt;

typedef struct {
    PyListObject list;
    int state;
} SubListObject;

static PyObject *
SubList_increment(SubListObject *self, PyObject *unused)
{
    self-&gt;state++;
    return PyLong_FromLong(self-&gt;state);
}

static PyMethodDef SubList_methods[] = {
    {"increment", (PyCFunction) SubList_increment, METH_NOARGS,
     PyDoc_STR("increment state counter")},
    {NULL},
};

static int
SubList_init(SubListObject *self, PyObject *args, PyObject *kwds)
{
    if (PyList_Type.tp_init((PyObject *) self, args, kwds) &lt; 0)
        return -1;
    self-&gt;state = 0;
    return 0;
}

static PyTypeObject SubListType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "sublist.SubList",
    .tp_doc = PyDoc_STR("SubList objects"),
    .tp_basicsize = sizeof(SubListObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_init = (initproc) SubList_init,
    .tp_methods = SubList_methods,
};

static PyModuleDef sublistmodule = {
    PyModuleDef_HEAD_INIT,
    .m_name = "sublist",
    .m_doc = "Example module that creates an extension type.",
    .m_size = -1,
};

PyMODINIT_FUNC
PyInit_sublist(void)
{
    PyObject *m;
    SubListType.tp_base = &amp;PyList_Type;
    if (PyType_Ready(&amp;SubListType) &lt; 0)
        return NULL;

    m = PyModule_Create(&amp;sublistmodule);
    if (m == NULL)
        return NULL;

    Py_INCREF(&amp;SubListType);
    if (PyModule_AddObject(m, "SubList", (PyObject *) &amp;SubListType) &lt; 0) {
        Py_DECREF(&amp;SubListType);
        Py_DECREF(m);
        return NULL;
    }

    return m;
}
</pre> <p>As you can see, the source code closely resembles the <code>Custom</code> examples in previous sections. We will break down the main differences between them.</p> <pre data-language="c">typedef struct {
    PyListObject list;
    int state;
} SubListObject;
</pre> <p>The primary difference for derived type objects is that the base type’s object structure must be the first value. The base type will already include the <a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code>PyObject_HEAD()</code></a> at the beginning of its structure.</p> <p>When a Python object is a <code>SubList</code> instance, its <code>PyObject *</code> pointer can be safely cast to both <code>PyListObject *</code> and <code>SubListObject *</code>:</p> <pre data-language="c">static int
SubList_init(SubListObject *self, PyObject *args, PyObject *kwds)
{
    if (PyList_Type.tp_init((PyObject *) self, args, kwds) &lt; 0)
        return -1;
    self-&gt;state = 0;
    return 0;
}
</pre> <p>We see above how to call through to the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> method of the base type.</p> <p>This pattern is important when writing a type with custom <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> and <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a> members. The <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> handler should not actually create the memory for the object with its <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code>tp_alloc</code></a>, but let the base class handle it by calling its own <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a>.</p> <p>The <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> struct supports a <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code>tp_base</code></a> specifying the type’s concrete base class. Due to cross-platform compiler issues, you can’t fill that field directly with a reference to <a class="reference internal" href="../c-api/list.html#c.PyList_Type" title="PyList_Type"><code>PyList_Type</code></a>; it should be done later in the module initialization function:</p> <pre data-language="c">PyMODINIT_FUNC
PyInit_sublist(void)
{
    PyObject* m;
    SubListType.tp_base = &amp;PyList_Type;
    if (PyType_Ready(&amp;SubListType) &lt; 0)
        return NULL;

    m = PyModule_Create(&amp;sublistmodule);
    if (m == NULL)
        return NULL;

    Py_INCREF(&amp;SubListType);
    if (PyModule_AddObject(m, "SubList", (PyObject *) &amp;SubListType) &lt; 0) {
        Py_DECREF(&amp;SubListType);
        Py_DECREF(m);
        return NULL;
    }

    return m;
}
</pre> <p>Before calling <a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a>, the type structure must have the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code>tp_base</code></a> slot filled in. When we are deriving an existing type, it is not necessary to fill out the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code>tp_alloc</code></a> slot with <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code>PyType_GenericNew()</code></a> – the allocation function from the base type will be inherited.</p> <p>After that, calling <a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> and adding the type object to the module is the same as with the basic <code>Custom</code> examples.</p> <h4 class="rubric">Footnotes</h4> <dl class="footnote brackets"> <dt class="label" id="id5">
<code>1</code> </dt> <dd>
<p>This is true when we know that the object is a basic type, like a string or a float.</p> </dd> <dt class="label" id="id6">
<code>2</code> </dt> <dd>
<p>We relied on this in the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a> handler in this example, because our type doesn’t support garbage collection.</p> </dd> <dt class="label" id="id7">
<code>3</code> </dt> <dd>
<p>We now know that the first and last members are strings, so perhaps we could be less careful about decrementing their reference counts, however, we accept instances of string subclasses. Even though deallocating normal strings won’t call back into our objects, we can’t guarantee that deallocating an instance of a string subclass won’t call back into our objects.</p> </dd> <dt class="label" id="id8">
<code>4</code> </dt> <dd>
<p>Also, even with our attributes restricted to strings instances, the user could pass arbitrary <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> subclasses and therefore still create reference cycles.</p> </dd> </dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/extending/newtypes_tutorial.html" class="_attribution-link">https://docs.python.org/3.12/extending/newtypes_tutorial.html</a>
  </p>
</div>
