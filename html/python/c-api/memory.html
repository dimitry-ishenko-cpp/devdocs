 <span id="memory"></span><h1>Memory Management</h1> <section id="overview"> <span id="memoryoverview"></span><h2>Overview</h2> <p>Memory management in Python involves a private heap containing all Python objects and data structures. The management of this private heap is ensured internally by the <em>Python memory manager</em>. The Python memory manager has different components which deal with various dynamic storage management aspects, like sharing, segmentation, preallocation or caching.</p> <p>At the lowest level, a raw memory allocator ensures that there is enough room in the private heap for storing all Python-related data by interacting with the memory manager of the operating system. On top of the raw memory allocator, several object-specific allocators operate on the same heap and implement distinct memory management policies adapted to the peculiarities of every object type. For example, integer objects are managed differently within the heap than strings, tuples or dictionaries because integers imply different storage requirements and speed/space tradeoffs. The Python memory manager thus delegates some of the work to the object-specific allocators, but ensures that the latter operate within the bounds of the private heap.</p> <p>It is important to understand that the management of the Python heap is performed by the interpreter itself and that the user has no control over it, even if they regularly manipulate object pointers to memory blocks inside that heap. The allocation of heap space for Python objects and other internal buffers is performed on demand by the Python memory manager through the Python/C API functions listed in this document.</p> <p id="index-0">To avoid memory corruption, extension writers should never try to operate on Python objects with the functions exported by the C library: <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> and <code>free()</code>. This will result in mixed calls between the C allocator and the Python memory manager with fatal consequences, because they implement different algorithms and operate on different heaps. However, one may safely allocate and release memory blocks with the C library allocator for individual purposes, as shown in the following example:</p> <pre data-language="c">PyObject *res;
char *buf = (char *) malloc(BUFSIZ); /* for I/O */

if (buf == NULL)
    return PyErr_NoMemory();
...Do some I/O operation involving buf...
res = PyBytes_FromString(buf);
free(buf); /* malloc'ed */
return res;
</pre> <p>In this example, the memory request for the I/O buffer is handled by the C library allocator. The Python memory manager is involved only in the allocation of the bytes object returned as a result.</p> <p>In most situations, however, it is recommended to allocate memory from the Python heap specifically because the latter is under control of the Python memory manager. For example, this is required when the interpreter is extended with new object types written in C. Another reason for using the Python heap is the desire to <em>inform</em> the Python memory manager about the memory needs of the extension module. Even when the requested memory is used exclusively for internal, highly specific purposes, delegating all memory requests to the Python memory manager causes the interpreter to have a more accurate image of its memory footprint as a whole. Consequently, under certain circumstances, the Python memory manager may or may not trigger appropriate actions, like garbage collection, memory compaction or other preventive procedures. Note that by using the C library allocator as shown in the previous example, the allocated memory for the I/O buffer escapes completely the Python memory manager.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <span class="target" id="index-1"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code>PYTHONMALLOC</code></a> environment variable can be used to configure the memory allocators used by Python.</p> <p>The <span class="target" id="index-2"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOCSTATS"><code>PYTHONMALLOCSTATS</code></a> environment variable can be used to print statistics of the <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc memory allocator</span></a> every time a new pymalloc object arena is created, and on shutdown.</p> </div> </section> <section id="allocator-domains"> <h2>Allocator Domains</h2> <p id="id1">All allocating functions belong to one of three different “domains” (see also <a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain"><code>PyMemAllocatorDomain</code></a>). These domains represent different allocation strategies and are optimized for different purposes. The specific details on how every domain allocates memory or what internal functions each domain calls is considered an implementation detail, but for debugging purposes a simplified table can be found at <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">here</span></a>. The APIs used to allocate and free a block of memory must be from the same domain. For example, <a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code>PyMem_Free()</code></a> must be used to free memory allocated using <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code>PyMem_Malloc()</code></a>.</p> <p>The three allocation domains are:</p> <ul class="simple"> <li>Raw domain: intended for allocating memory for general-purpose memory buffers where the allocation <em>must</em> go to the system allocator or where the allocator can operate without the <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>. The memory is requested directly from the system. See <a class="reference internal" href="#raw-memoryinterface"><span class="std std-ref">Raw Memory Interface</span></a>.</li> <li>“Mem” domain: intended for allocating memory for Python buffers and general-purpose memory buffers where the allocation must be performed with the <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> held. The memory is taken from the Python private heap. See <a class="reference internal" href="#memoryinterface"><span class="std std-ref">Memory Interface</span></a>.</li> <li>Object domain: intended for allocating memory for Python objects. The memory is taken from the Python private heap. See <a class="reference internal" href="#objectinterface"><span class="std std-ref">Object allocators</span></a>.</li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="../glossary.html#term-free-threading"><span class="xref std std-term">free-threaded</span></a> build requires that only Python objects are allocated using the “object” domain and that all Python objects are allocated using that domain. This differs from the prior Python versions, where this was only a best practice and not a hard requirement.</p> <p>For example, buffers (non-Python objects) should be allocated using <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code>PyMem_Malloc()</code></a>, <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code>PyMem_RawMalloc()</code></a>, or <code>malloc()</code>, but not <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code>PyObject_Malloc()</code></a>.</p> <p>See <a class="reference internal" href="../howto/free-threading-extensions.html#free-threaded-memory-allocation"><span class="std std-ref">Memory Allocation APIs</span></a>.</p> </div> </section> <section id="raw-memory-interface"> <span id="raw-memoryinterface"></span><h2>Raw Memory Interface</h2> <p>The following function sets are wrappers to the system allocator. These functions are thread-safe, the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> does not need to be held.</p> <p>The <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">default raw memory allocator</span></a> uses the following functions: <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> and <code>free()</code>; call <code>malloc(1)</code> (or <code>calloc(1, 1)</code>) when requesting zero bytes.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_RawMalloc">
<code>void *PyMem_RawMalloc(size_t n)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Allocates <em>n</em> bytes and returns a pointer of type <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> to the allocated memory, or <code>NULL</code> if the request fails.</p> <p>Requesting zero bytes returns a distinct non-<code>NULL</code> pointer if possible, as if <code>PyMem_RawMalloc(1)</code> had been called instead. The memory will not have been initialized in any way.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_RawCalloc">
<code>void *PyMem_RawCalloc(size_t nelem, size_t elsize)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Allocates <em>nelem</em> elements each whose size in bytes is <em>elsize</em> and returns a pointer of type <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> to the allocated memory, or <code>NULL</code> if the request fails. The memory is initialized to zeros.</p> <p>Requesting zero elements or elements of size zero bytes returns a distinct non-<code>NULL</code> pointer if possible, as if <code>PyMem_RawCalloc(1, 1)</code> had been called instead.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_RawRealloc">
<code>void *PyMem_RawRealloc(void *p, size_t n)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Resizes the memory block pointed to by <em>p</em> to <em>n</em> bytes. The contents will be unchanged to the minimum of the old and the new sizes.</p> <p>If <em>p</em> is <code>NULL</code>, the call is equivalent to <code>PyMem_RawMalloc(n)</code>; else if <em>n</em> is equal to zero, the memory block is resized but is not freed, and the returned pointer is non-<code>NULL</code>.</p> <p>Unless <em>p</em> is <code>NULL</code>, it must have been returned by a previous call to <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code>PyMem_RawMalloc()</code></a>, <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code>PyMem_RawRealloc()</code></a> or <a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code>PyMem_RawCalloc()</code></a>.</p> <p>If the request fails, <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code>PyMem_RawRealloc()</code></a> returns <code>NULL</code> and <em>p</em> remains a valid pointer to the previous memory area.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_RawFree">
<code>void PyMem_RawFree(void *p)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Frees the memory block pointed to by <em>p</em>, which must have been returned by a previous call to <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code>PyMem_RawMalloc()</code></a>, <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code>PyMem_RawRealloc()</code></a> or <a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code>PyMem_RawCalloc()</code></a>. Otherwise, or if <code>PyMem_RawFree(p)</code> has been called before, undefined behavior occurs.</p> <p>If <em>p</em> is <code>NULL</code>, no operation is performed.</p> </dd>
</dl> </section> <section id="memory-interface"> <span id="memoryinterface"></span><h2>Memory Interface</h2> <p>The following function sets, modeled after the ANSI C standard, but specifying behavior when requesting zero bytes, are available for allocating and releasing memory from the Python heap.</p> <p>The <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">default memory allocator</span></a> uses the <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc memory allocator</span></a>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> must be held when using these functions.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>The default allocator is now pymalloc instead of system <code>malloc()</code>.</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_Malloc">
<code>void *PyMem_Malloc(size_t n)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Allocates <em>n</em> bytes and returns a pointer of type <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> to the allocated memory, or <code>NULL</code> if the request fails.</p> <p>Requesting zero bytes returns a distinct non-<code>NULL</code> pointer if possible, as if <code>PyMem_Malloc(1)</code> had been called instead. The memory will not have been initialized in any way.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_Calloc">
<code>void *PyMem_Calloc(size_t nelem, size_t elsize)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Allocates <em>nelem</em> elements each whose size in bytes is <em>elsize</em> and returns a pointer of type <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> to the allocated memory, or <code>NULL</code> if the request fails. The memory is initialized to zeros.</p> <p>Requesting zero elements or elements of size zero bytes returns a distinct non-<code>NULL</code> pointer if possible, as if <code>PyMem_Calloc(1, 1)</code> had been called instead.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_Realloc">
<code>void *PyMem_Realloc(void *p, size_t n)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Resizes the memory block pointed to by <em>p</em> to <em>n</em> bytes. The contents will be unchanged to the minimum of the old and the new sizes.</p> <p>If <em>p</em> is <code>NULL</code>, the call is equivalent to <code>PyMem_Malloc(n)</code>; else if <em>n</em> is equal to zero, the memory block is resized but is not freed, and the returned pointer is non-<code>NULL</code>.</p> <p>Unless <em>p</em> is <code>NULL</code>, it must have been returned by a previous call to <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code>PyMem_Malloc()</code></a>, <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code>PyMem_Realloc()</code></a> or <a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code>PyMem_Calloc()</code></a>.</p> <p>If the request fails, <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code>PyMem_Realloc()</code></a> returns <code>NULL</code> and <em>p</em> remains a valid pointer to the previous memory area.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_Free">
<code>void PyMem_Free(void *p)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Frees the memory block pointed to by <em>p</em>, which must have been returned by a previous call to <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code>PyMem_Malloc()</code></a>, <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code>PyMem_Realloc()</code></a> or <a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code>PyMem_Calloc()</code></a>. Otherwise, or if <code>PyMem_Free(p)</code> has been called before, undefined behavior occurs.</p> <p>If <em>p</em> is <code>NULL</code>, no operation is performed.</p> </dd>
</dl> <p>The following type-oriented macros are provided for convenience. Note that <em>TYPE</em> refers to any C type.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyMem_New">
<code>PyMem_New(TYPE, n)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code>PyMem_Malloc()</code></a>, but allocates <code>(n * sizeof(TYPE))</code> bytes of memory. Returns a pointer cast to <code>TYPE*</code>. The memory will not have been initialized in any way.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyMem_Resize">
<code>PyMem_Resize(p, TYPE, n)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code>PyMem_Realloc()</code></a>, but the memory block is resized to <code>(n *
sizeof(TYPE))</code> bytes. Returns a pointer cast to <code>TYPE*</code>. On return, <em>p</em> will be a pointer to the new memory area, or <code>NULL</code> in the event of failure.</p> <p>This is a C preprocessor macro; <em>p</em> is always reassigned. Save the original value of <em>p</em> to avoid losing memory when handling errors.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_Del">
<code>void PyMem_Del(void *p)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code>PyMem_Free()</code></a>.</p> </dd>
</dl> <p>In addition, the following macro sets are provided for calling the Python memory allocator directly, without involving the C API functions listed above. However, note that their use does not preserve binary compatibility across Python versions and is therefore deprecated in extension modules.</p> <ul class="simple"> <li><code>PyMem_MALLOC(size)</code></li> <li><code>PyMem_NEW(type, size)</code></li> <li><code>PyMem_REALLOC(ptr, size)</code></li> <li><code>PyMem_RESIZE(ptr, type, size)</code></li> <li><code>PyMem_FREE(ptr)</code></li> <li><code>PyMem_DEL(ptr)</code></li> </ul> </section> <section id="object-allocators"> <span id="objectinterface"></span><h2>Object allocators</h2> <p>The following function sets, modeled after the ANSI C standard, but specifying behavior when requesting zero bytes, are available for allocating and releasing memory from the Python heap.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>There is no guarantee that the memory returned by these allocators can be successfully cast to a Python object when intercepting the allocating functions in this domain by the methods described in the <a class="reference internal" href="#customize-memory-allocators"><span class="std std-ref">Customize Memory Allocators</span></a> section.</p> </div> <p>The <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">default object allocator</span></a> uses the <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc memory allocator</span></a>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> must be held when using these functions.</p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_Malloc">
<code>void *PyObject_Malloc(size_t n)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Allocates <em>n</em> bytes and returns a pointer of type <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> to the allocated memory, or <code>NULL</code> if the request fails.</p> <p>Requesting zero bytes returns a distinct non-<code>NULL</code> pointer if possible, as if <code>PyObject_Malloc(1)</code> had been called instead. The memory will not have been initialized in any way.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_Calloc">
<code>void *PyObject_Calloc(size_t nelem, size_t elsize)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Allocates <em>nelem</em> elements each whose size in bytes is <em>elsize</em> and returns a pointer of type <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> to the allocated memory, or <code>NULL</code> if the request fails. The memory is initialized to zeros.</p> <p>Requesting zero elements or elements of size zero bytes returns a distinct non-<code>NULL</code> pointer if possible, as if <code>PyObject_Calloc(1, 1)</code> had been called instead.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_Realloc">
<code>void *PyObject_Realloc(void *p, size_t n)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Resizes the memory block pointed to by <em>p</em> to <em>n</em> bytes. The contents will be unchanged to the minimum of the old and the new sizes.</p> <p>If <em>p</em> is <code>NULL</code>, the call is equivalent to <code>PyObject_Malloc(n)</code>; else if <em>n</em> is equal to zero, the memory block is resized but is not freed, and the returned pointer is non-<code>NULL</code>.</p> <p>Unless <em>p</em> is <code>NULL</code>, it must have been returned by a previous call to <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code>PyObject_Malloc()</code></a>, <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code>PyObject_Realloc()</code></a> or <a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code>PyObject_Calloc()</code></a>.</p> <p>If the request fails, <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code>PyObject_Realloc()</code></a> returns <code>NULL</code> and <em>p</em> remains a valid pointer to the previous memory area.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_Free">
<code>void PyObject_Free(void *p)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Frees the memory block pointed to by <em>p</em>, which must have been returned by a previous call to <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code>PyObject_Malloc()</code></a>, <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code>PyObject_Realloc()</code></a> or <a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code>PyObject_Calloc()</code></a>. Otherwise, or if <code>PyObject_Free(p)</code> has been called before, undefined behavior occurs.</p> <p>If <em>p</em> is <code>NULL</code>, no operation is performed.</p> </dd>
</dl> </section> <section id="default-memory-allocators"> <span id="id2"></span><h2>Default Memory Allocators</h2> <p>Default memory allocators:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Configuration</p></th> <th class="head"><p>Name</p></th> <th class="head"><p>PyMem_RawMalloc</p></th> <th class="head"><p>PyMem_Malloc</p></th> <th class="head"><p>PyObject_Malloc</p></th> </tr> </thead>  <tr>
<td><p>Release build</p></td> <td><p><code>"pymalloc"</code></p></td> <td><p><code>malloc</code></p></td> <td><p><code>pymalloc</code></p></td> <td><p><code>pymalloc</code></p></td> </tr> <tr>
<td><p>Debug build</p></td> <td><p><code>"pymalloc_debug"</code></p></td> <td><p><code>malloc</code> + debug</p></td> <td><p><code>pymalloc</code> + debug</p></td> <td><p><code>pymalloc</code> + debug</p></td> </tr> <tr>
<td><p>Release build, without pymalloc</p></td> <td><p><code>"malloc"</code></p></td> <td><p><code>malloc</code></p></td> <td><p><code>malloc</code></p></td> <td><p><code>malloc</code></p></td> </tr> <tr>
<td><p>Debug build, without pymalloc</p></td> <td><p><code>"malloc_debug"</code></p></td> <td><p><code>malloc</code> + debug</p></td> <td><p><code>malloc</code> + debug</p></td> <td><p><code>malloc</code> + debug</p></td> </tr>  </table> <p>Legend:</p> <ul class="simple"> <li>Name: value for <span class="target" id="index-3"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code>PYTHONMALLOC</code></a> environment variable.</li> <li>
<code>malloc</code>: system allocators from the standard C library, C functions: <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> and <code>free()</code>.</li> <li>
<code>pymalloc</code>: <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc memory allocator</span></a>.</li> <li>
<code>mimalloc</code>: <a class="reference internal" href="#mimalloc"><span class="std std-ref">mimalloc memory allocator</span></a>. The pymalloc allocator will be used if mimalloc support isn’t available.</li> <li>“+ debug”: with <a class="reference internal" href="#pymem-debug-hooks"><span class="std std-ref">debug hooks on the Python memory allocators</span></a>.</li> <li>“Debug build”: <a class="reference internal" href="../using/configure.html#debug-build"><span class="std std-ref">Python build in debug mode</span></a>.</li> </ul> </section> <section id="customize-memory-allocators"> <span id="id3"></span><h2>Customize Memory Allocators</h2> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> <dl class="c type"> <dt class="sig sig-object c" id="c.PyMemAllocatorEx">
<code>type PyMemAllocatorEx</code> </dt> <dd>
<p>Structure used to describe a memory block allocator. The structure has the following fields:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Field</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><code>void *ctx</code></p></td> <td><p>user context passed as first argument</p></td> </tr> <tr>
<td><p><code>void* malloc(void *ctx, size_t size)</code></p></td> <td><p>allocate a memory block</p></td> </tr> <tr>
<td><p><code>void* calloc(void *ctx, size_t nelem, size_t elsize)</code></p></td> <td><p>allocate a memory block initialized with zeros</p></td> </tr> <tr>
<td><p><code>void* realloc(void *ctx, void *ptr, size_t new_size)</code></p></td> <td><p>allocate or resize a memory block</p></td> </tr> <tr>
<td><p><code>void free(void *ctx, void *ptr)</code></p></td> <td><p>free a memory block</p></td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The <code>PyMemAllocator</code> structure was renamed to <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx"><code>PyMemAllocatorEx</code></a> and a new <code>calloc</code> field was added.</p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyMemAllocatorDomain">
<code>type PyMemAllocatorDomain</code> </dt> <dd>
<p>Enum used to identify an allocator domain. Domains:</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.PYMEM_DOMAIN_RAW">
<code>PYMEM_DOMAIN_RAW</code> </dt> <dd>
<p>Functions:</p> <ul class="simple"> <li><a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code>PyMem_RawMalloc()</code></a></li> <li><a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code>PyMem_RawRealloc()</code></a></li> <li><a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code>PyMem_RawCalloc()</code></a></li> <li><a class="reference internal" href="#c.PyMem_RawFree" title="PyMem_RawFree"><code>PyMem_RawFree()</code></a></li> </ul> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PYMEM_DOMAIN_MEM">
<code>PYMEM_DOMAIN_MEM</code> </dt> <dd>
<p>Functions:</p> <ul class="simple"> <li>
<a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code>PyMem_Malloc()</code></a>,</li> <li><a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code>PyMem_Realloc()</code></a></li> <li><a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code>PyMem_Calloc()</code></a></li> <li><a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code>PyMem_Free()</code></a></li> </ul> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PYMEM_DOMAIN_OBJ">
<code>PYMEM_DOMAIN_OBJ</code> </dt> <dd>
<p>Functions:</p> <ul class="simple"> <li><a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code>PyObject_Malloc()</code></a></li> <li><a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code>PyObject_Realloc()</code></a></li> <li><a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code>PyObject_Calloc()</code></a></li> <li><a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code>PyObject_Free()</code></a></li> </ul> </dd>
</dl> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_GetAllocator">
<code>void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)</code> </dt> <dd>
<p>Get the memory block allocator of the specified domain.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_SetAllocator">
<code>void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)</code> </dt> <dd>
<p>Set the memory block allocator of the specified domain.</p> <p>The new allocator must return a distinct non-<code>NULL</code> pointer when requesting zero bytes.</p> <p>For the <a class="reference internal" href="#c.PYMEM_DOMAIN_RAW" title="PYMEM_DOMAIN_RAW"><code>PYMEM_DOMAIN_RAW</code></a> domain, the allocator must be thread-safe: the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> is not held when the allocator is called.</p> <p>For the remaining domains, the allocator must also be thread-safe: the allocator may be called in different interpreters that do not share a <code>GIL</code>.</p> <p>If the new allocator is not a hook (does not call the previous allocator), the <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code>PyMem_SetupDebugHooks()</code></a> function must be called to reinstall the debug hooks on top on the new allocator.</p> <p>See also <a class="reference internal" href="init_config.html#c.PyPreConfig.allocator" title="PyPreConfig.allocator"><code>PyPreConfig.allocator</code></a> and <a class="reference internal" href="init_config.html#c-preinit"><span class="std std-ref">Preinitialize Python with PyPreConfig</span></a>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#c.PyMem_SetAllocator" title="PyMem_SetAllocator"><code>PyMem_SetAllocator()</code></a> does have the following contract:</p> <ul class="simple"> <li>It can be called after <a class="reference internal" href="init_config.html#c.Py_PreInitialize" title="Py_PreInitialize"><code>Py_PreInitialize()</code></a> and before <a class="reference internal" href="init.html#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code>Py_InitializeFromConfig()</code></a> to install a custom memory allocator. There are no restrictions over the installed allocator other than the ones imposed by the domain (for instance, the Raw Domain allows the allocator to be called without the GIL held). See <a class="reference internal" href="#id1"><span class="std std-ref">the section on allocator domains</span></a> for more information.</li> <li>If called after Python has finish initializing (after <a class="reference internal" href="init.html#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code>Py_InitializeFromConfig()</code></a> has been called) the allocator <strong>must</strong> wrap the existing allocator. Substituting the current allocator for some other arbitrary one is <strong>not supported</strong>.</li> </ul> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>All allocators must be thread-safe.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMem_SetupDebugHooks">
<code>void PyMem_SetupDebugHooks(void)</code> </dt> <dd>
<p>Setup <a class="reference internal" href="#pymem-debug-hooks"><span class="std std-ref">debug hooks in the Python memory allocators</span></a> to detect memory errors.</p> </dd>
</dl> </section> <section id="debug-hooks-on-the-python-memory-allocators"> <span id="pymem-debug-hooks"></span><h2>Debug hooks on the Python memory allocators</h2> <p>When <a class="reference internal" href="../using/configure.html#debug-build"><span class="std std-ref">Python is built in debug mode</span></a>, the <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code>PyMem_SetupDebugHooks()</code></a> function is called at the <a class="reference internal" href="init_config.html#c-preinit"><span class="std std-ref">Python preinitialization</span></a> to setup debug hooks on Python memory allocators to detect memory errors.</p> <p>The <span class="target" id="index-4"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code>PYTHONMALLOC</code></a> environment variable can be used to install debug hooks on a Python compiled in release mode (ex: <code>PYTHONMALLOC=debug</code>).</p> <p>The <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code>PyMem_SetupDebugHooks()</code></a> function can be used to set debug hooks after calling <a class="reference internal" href="#c.PyMem_SetAllocator" title="PyMem_SetAllocator"><code>PyMem_SetAllocator()</code></a>.</p> <p>These debug hooks fill dynamically allocated memory blocks with special, recognizable bit patterns. Newly allocated memory is filled with the byte <code>0xCD</code> (<code>PYMEM_CLEANBYTE</code>), freed memory is filled with the byte <code>0xDD</code> (<code>PYMEM_DEADBYTE</code>). Memory blocks are surrounded by “forbidden bytes” filled with the byte <code>0xFD</code> (<code>PYMEM_FORBIDDENBYTE</code>). Strings of these bytes are unlikely to be valid addresses, floats, or ASCII strings.</p> <p>Runtime checks:</p> <ul class="simple"> <li>Detect API violations. For example, detect if <a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code>PyObject_Free()</code></a> is called on a memory block allocated by <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code>PyMem_Malloc()</code></a>.</li> <li>Detect write before the start of the buffer (buffer underflow).</li> <li>Detect write after the end of the buffer (buffer overflow).</li> <li>Check that the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> is held when allocator functions of <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code>PYMEM_DOMAIN_OBJ</code></a> (ex: <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code>PyObject_Malloc()</code></a>) and <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code>PYMEM_DOMAIN_MEM</code></a> (ex: <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code>PyMem_Malloc()</code></a>) domains are called.</li> </ul> <p>On error, the debug hooks use the <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code>tracemalloc</code></a> module to get the traceback where a memory block was allocated. The traceback is only displayed if <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code>tracemalloc</code></a> is tracing Python memory allocations and the memory block was traced.</p> <p>Let <em>S</em> = <code>sizeof(size_t)</code>. <code>2*S</code> bytes are added at each end of each block of <em>N</em> bytes requested. The memory layout is like so, where p represents the address returned by a malloc-like or realloc-like function (<code>p[i:j]</code> means the slice of bytes from <code>*(p+i)</code> inclusive up to <code>*(p+j)</code> exclusive; note that the treatment of negative indices differs from a Python slice):</p> <dl> <dt>
<code>p[-2*S:-S]</code> </dt>
<dd>
<p>Number of bytes originally asked for. This is a size_t, big-endian (easier to read in a memory dump).</p> </dd> <dt>
<code>p[-S]</code> </dt>
<dd>
<p>API identifier (ASCII character):</p> <ul class="simple"> <li>
<code>'r'</code> for <a class="reference internal" href="#c.PYMEM_DOMAIN_RAW" title="PYMEM_DOMAIN_RAW"><code>PYMEM_DOMAIN_RAW</code></a>.</li> <li>
<code>'m'</code> for <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code>PYMEM_DOMAIN_MEM</code></a>.</li> <li>
<code>'o'</code> for <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code>PYMEM_DOMAIN_OBJ</code></a>.</li> </ul> </dd> <dt>
<code>p[-S+1:0]</code> </dt>
<dd>
<p>Copies of PYMEM_FORBIDDENBYTE. Used to catch under- writes and reads.</p> </dd> <dt>
<code>p[0:N]</code> </dt>
<dd>
<p>The requested memory, filled with copies of PYMEM_CLEANBYTE, used to catch reference to uninitialized memory. When a realloc-like function is called requesting a larger memory block, the new excess bytes are also filled with PYMEM_CLEANBYTE. When a free-like function is called, these are overwritten with PYMEM_DEADBYTE, to catch reference to freed memory. When a realloc- like function is called requesting a smaller memory block, the excess old bytes are also filled with PYMEM_DEADBYTE.</p> </dd> <dt>
<code>p[N:N+S]</code> </dt>
<dd>
<p>Copies of PYMEM_FORBIDDENBYTE. Used to catch over- writes and reads.</p> </dd> <dt>
<code>p[N+S:N+2*S]</code> </dt>
<dd>
<p>Only used if the <code>PYMEM_DEBUG_SERIALNO</code> macro is defined (not defined by default).</p> <p>A serial number, incremented by 1 on each call to a malloc-like or realloc-like function. Big-endian <code>size_t</code>. If “bad memory” is detected later, the serial number gives an excellent way to set a breakpoint on the next run, to capture the instant at which this block was passed out. The static function bumpserialno() in obmalloc.c is the only place the serial number is incremented, and exists so you can set such a breakpoint easily.</p> </dd> </dl> <p>A realloc-like or free-like function first checks that the PYMEM_FORBIDDENBYTE bytes at each end are intact. If they’ve been altered, diagnostic output is written to stderr, and the program is aborted via Py_FatalError(). The other main failure mode is provoking a memory error when a program reads up one of the special bit patterns and tries to use it as an address. If you get in a debugger then and look at the object, you’re likely to see that it’s entirely filled with PYMEM_DEADBYTE (meaning freed memory is getting used) or PYMEM_CLEANBYTE (meaning uninitialized memory is getting used).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>The <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code>PyMem_SetupDebugHooks()</code></a> function now also works on Python compiled in release mode. On error, the debug hooks now use <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code>tracemalloc</code></a> to get the traceback where a memory block was allocated. The debug hooks now also check if the GIL is held when functions of <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code>PYMEM_DOMAIN_OBJ</code></a> and <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code>PYMEM_DOMAIN_MEM</code></a> domains are called.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Byte patterns <code>0xCB</code> (<code>PYMEM_CLEANBYTE</code>), <code>0xDB</code> (<code>PYMEM_DEADBYTE</code>) and <code>0xFB</code> (<code>PYMEM_FORBIDDENBYTE</code>) have been replaced with <code>0xCD</code>, <code>0xDD</code> and <code>0xFD</code> to use the same values than Windows CRT debug <code>malloc()</code> and <code>free()</code>.</p> </div> </section> <section id="the-pymalloc-allocator"> <span id="pymalloc"></span><h2>The pymalloc allocator</h2> <p>Python has a <em>pymalloc</em> allocator optimized for small objects (smaller or equal to 512 bytes) with a short lifetime. It uses memory mappings called “arenas” with a fixed size of either 256 KiB on 32-bit platforms or 1 MiB on 64-bit platforms. It falls back to <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code>PyMem_RawMalloc()</code></a> and <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code>PyMem_RawRealloc()</code></a> for allocations larger than 512 bytes.</p> <p><em>pymalloc</em> is the <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">default allocator</span></a> of the <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code>PYMEM_DOMAIN_MEM</code></a> (ex: <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code>PyMem_Malloc()</code></a>) and <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code>PYMEM_DOMAIN_OBJ</code></a> (ex: <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code>PyObject_Malloc()</code></a>) domains.</p> <p>The arena allocator uses the following functions:</p> <ul class="simple"> <li>
<code>VirtualAlloc()</code> and <code>VirtualFree()</code> on Windows,</li> <li>
<code>mmap()</code> and <code>munmap()</code> if available,</li> <li>
<code>malloc()</code> and <code>free()</code> otherwise.</li> </ul> <p>This allocator is disabled if Python is configured with the <a class="reference internal" href="../using/configure.html#cmdoption-without-pymalloc"><code>--without-pymalloc</code></a> option. It can also be disabled at runtime using the <span class="target" id="index-5"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code>PYTHONMALLOC</code></a> environment variable (ex: <code>PYTHONMALLOC=malloc</code>).</p> <section id="customize-pymalloc-arena-allocator"> <h3>Customize pymalloc Arena Allocator</h3> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> <dl class="c type"> <dt class="sig sig-object c" id="c.PyObjectArenaAllocator">
<code>type PyObjectArenaAllocator</code> </dt> <dd>
<p>Structure used to describe an arena allocator. The structure has three fields:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Field</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><code>void *ctx</code></p></td> <td><p>user context passed as first argument</p></td> </tr> <tr>
<td><p><code>void* alloc(void *ctx, size_t size)</code></p></td> <td><p>allocate an arena of size bytes</p></td> </tr> <tr>
<td><p><code>void free(void *ctx, void *ptr, size_t size)</code></p></td> <td><p>free an arena</p></td> </tr>  </table> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_GetArenaAllocator">
<code>void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)</code> </dt> <dd>
<p>Get the arena allocator.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_SetArenaAllocator">
<code>void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)</code> </dt> <dd>
<p>Set the arena allocator.</p> </dd>
</dl> </section> </section> <section id="the-mimalloc-allocator"> <span id="mimalloc"></span><h2>The mimalloc allocator</h2> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> <p>Python supports the mimalloc allocator when the underlying platform support is available. mimalloc “is a general purpose allocator with excellent performance characteristics. Initially developed by Daan Leijen for the runtime systems of the Koka and Lean languages.”</p> </section> <section id="tracemalloc-c-api"> <h2>tracemalloc C API</h2> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.7.</span></p> </div> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTraceMalloc_Track">
<code>int PyTraceMalloc_Track(unsigned int domain, uintptr_t ptr, size_t size)</code> </dt> <dd>
<p>Track an allocated memory block in the <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code>tracemalloc</code></a> module.</p> <p>Return <code>0</code> on success, return <code>-1</code> on error (failed to allocate memory to store the trace). Return <code>-2</code> if tracemalloc is disabled.</p> <p>If memory block is already tracked, update the existing trace.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTraceMalloc_Untrack">
<code>int PyTraceMalloc_Untrack(unsigned int domain, uintptr_t ptr)</code> </dt> <dd>
<p>Untrack an allocated memory block in the <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code>tracemalloc</code></a> module. Do nothing if the block was not tracked.</p> <p>Return <code>-2</code> if tracemalloc is disabled, otherwise return <code>0</code>.</p> </dd>
</dl> </section> <section id="examples"> <span id="memoryexamples"></span><h2>Examples</h2> <p>Here is the example from section <a class="reference internal" href="#memoryoverview"><span class="std std-ref">Overview</span></a>, rewritten so that the I/O buffer is allocated from the Python heap by using the first function set:</p> <pre data-language="c">PyObject *res;
char *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */

if (buf == NULL)
    return PyErr_NoMemory();
/* ...Do some I/O operation involving buf... */
res = PyBytes_FromString(buf);
PyMem_Free(buf); /* allocated with PyMem_Malloc */
return res;
</pre> <p>The same code using the type-oriented function set:</p> <pre data-language="c">PyObject *res;
char *buf = PyMem_New(char, BUFSIZ); /* for I/O */

if (buf == NULL)
    return PyErr_NoMemory();
/* ...Do some I/O operation involving buf... */
res = PyBytes_FromString(buf);
PyMem_Del(buf); /* allocated with PyMem_New */
return res;
</pre> <p>Note that in the two examples above, the buffer is always manipulated via functions belonging to the same set. Indeed, it is required to use the same memory API family for a given memory block, so that the risk of mixing different allocators is reduced to a minimum. The following code sequence contains two errors, one of which is labeled as <em>fatal</em> because it mixes two different allocators operating on different heaps.</p> <pre data-language="c">char *buf1 = PyMem_New(char, BUFSIZ);
char *buf2 = (char *) malloc(BUFSIZ);
char *buf3 = (char *) PyMem_Malloc(BUFSIZ);
...
PyMem_Del(buf3);  /* Wrong -- should be PyMem_Free() */
free(buf2);       /* Right -- allocated via malloc() */
free(buf1);       /* Fatal -- should be PyMem_Del()  */
</pre> <p>In addition to the functions aimed at handling raw memory blocks from the Python heap, objects in Python are allocated and released with <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code>PyObject_New</code></a>, <a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code>PyObject_NewVar</code></a> and <a class="reference internal" href="allocation.html#c.PyObject_Del" title="PyObject_Del"><code>PyObject_Del()</code></a>.</p> <p>These will be explained in the next chapter on defining and implementing new object types in C.</p> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/memory.html" class="_attribution-link">https://docs.python.org/3.13/c-api/memory.html</a>
  </p>
</div>
