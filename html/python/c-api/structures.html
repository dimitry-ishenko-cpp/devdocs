 <span id="common-structs"></span><h1>Common Object Structures</h1> <p>There are a large number of structures which are used in the definition of object types for Python. This section describes these structures and how they are used.</p> <section id="base-object-types-and-macros"> <h2>Base object types and macros</h2> <p>All Python objects ultimately share a small number of fields at the beginning of the object’s representation in memory. These are represented by the <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject</code></a> and <a class="reference internal" href="#c.PyVarObject" title="PyVarObject"><code>PyVarObject</code></a> types, which are defined, in turn, by the expansions of some macros also used, whether directly or indirectly, in the definition of all other Python objects. Additional macros can be found under <a class="reference internal" href="refcounting.html#countingrefs"><span class="std std-ref">reference counting</span></a>.</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyObject">
<code>type PyObject</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Limited API</span></a>. (Only some members are part of the stable ABI.)</em><p>All object types are extensions of this type. This is a type which contains the information Python needs to treat a pointer to an object as an object. In a normal “release” build, it contains only the object’s reference count and a pointer to the corresponding type object. Nothing is actually declared to be a <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject</code></a>, but every pointer to a Python object can be cast to a <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>. Access to the members must be done by using the macros <a class="reference internal" href="refcounting.html#c.Py_REFCNT" title="Py_REFCNT"><code>Py_REFCNT</code></a> and <a class="reference internal" href="#c.Py_TYPE" title="Py_TYPE"><code>Py_TYPE</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyVarObject">
<code>type PyVarObject</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Limited API</span></a>. (Only some members are part of the stable ABI.)</em><p>This is an extension of <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject</code></a> that adds the <a class="reference internal" href="typeobj.html#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code>ob_size</code></a> field. This is only used for objects that have some notion of <em>length</em>. This type does not often appear in the Python/C API. Access to the members must be done by using the macros <a class="reference internal" href="refcounting.html#c.Py_REFCNT" title="Py_REFCNT"><code>Py_REFCNT</code></a>, <a class="reference internal" href="#c.Py_TYPE" title="Py_TYPE"><code>Py_TYPE</code></a>, and <a class="reference internal" href="#c.Py_SIZE" title="Py_SIZE"><code>Py_SIZE</code></a>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyObject_HEAD">
<code>PyObject_HEAD</code> </dt> <dd>
<p>This is a macro used when declaring new types which represent objects without a varying length. The PyObject_HEAD macro expands to:</p> <pre data-language="c">PyObject ob_base;
</pre> <p>See documentation of <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject</code></a> above.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyObject_VAR_HEAD">
<code>PyObject_VAR_HEAD</code> </dt> <dd>
<p>This is a macro used when declaring new types which represent objects with a length that varies from instance to instance. The PyObject_VAR_HEAD macro expands to:</p> <pre data-language="c">PyVarObject ob_base;
</pre> <p>See documentation of <a class="reference internal" href="#c.PyVarObject" title="PyVarObject"><code>PyVarObject</code></a> above.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_Is">
<code>int Py_Is(PyObject *x, PyObject *y)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Test if the <em>x</em> object is the <em>y</em> object, the same as <code>x is y</code> in Python.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_IsNone">
<code>int Py_IsNone(PyObject *x)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Test if an object is the <code>None</code> singleton, the same as <code>x is None</code> in Python.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_IsTrue">
<code>int Py_IsTrue(PyObject *x)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Test if an object is the <code>True</code> singleton, the same as <code>x is True</code> in Python.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_IsFalse">
<code>int Py_IsFalse(PyObject *x)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Test if an object is the <code>False</code> singleton, the same as <code>x is False</code> in Python.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_TYPE">
<code>PyTypeObject *Py_TYPE(PyObject *o)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><p>Get the type of the Python object <em>o</em>.</p> <p>Return a <a class="reference internal" href="../glossary.html#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a>.</p> <p>Use the <a class="reference internal" href="#c.Py_SET_TYPE" title="Py_SET_TYPE"><code>Py_SET_TYPE()</code></a> function to set an object type.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><a class="reference internal" href="#c.Py_TYPE" title="Py_TYPE"><code>Py_TYPE()</code></a> is changed to an inline static function. The parameter type is no longer <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_IS_TYPE">
<code>int Py_IS_TYPE(PyObject *o, PyTypeObject *type)</code> </dt> <dd>
<p>Return non-zero if the object <em>o</em> type is <em>type</em>. Return zero otherwise. Equivalent to: <code>Py_TYPE(o) == type</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_SET_TYPE">
<code>void Py_SET_TYPE(PyObject *o, PyTypeObject *type)</code> </dt> <dd>
<p>Set the object <em>o</em> type to <em>type</em>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_SIZE">
<code>Py_ssize_t Py_SIZE(PyVarObject *o)</code> </dt> <dd>
<p>Get the size of the Python object <em>o</em>.</p> <p>Use the <a class="reference internal" href="#c.Py_SET_SIZE" title="Py_SET_SIZE"><code>Py_SET_SIZE()</code></a> function to set an object size.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><a class="reference internal" href="#c.Py_SIZE" title="Py_SIZE"><code>Py_SIZE()</code></a> is changed to an inline static function. The parameter type is no longer <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><a class="reference internal" href="#c.PyVarObject" title="PyVarObject"><span class="n">PyVarObject</span></a><span class="p">*</span></span>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_SET_SIZE">
<code>void Py_SET_SIZE(PyVarObject *o, Py_ssize_t size)</code> </dt> <dd>
<p>Set the object <em>o</em> size to <em>size</em>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyObject_HEAD_INIT">
<code>PyObject_HEAD_INIT(type)</code> </dt> <dd>
<p>This is a macro which expands to initialization values for a new <a class="reference internal" href="#c.PyObject" title="PyObject"><code>PyObject</code></a> type. This macro expands to:</p> <pre data-language="c">_PyObject_EXTRA_INIT
1, type,
</pre> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyVarObject_HEAD_INIT">
<code>PyVarObject_HEAD_INIT(type, size)</code> </dt> <dd>
<p>This is a macro which expands to initialization values for a new <a class="reference internal" href="#c.PyVarObject" title="PyVarObject"><code>PyVarObject</code></a> type, including the <a class="reference internal" href="typeobj.html#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code>ob_size</code></a> field. This macro expands to:</p> <pre data-language="c">_PyObject_EXTRA_INIT
1, type, size,
</pre> </dd>
</dl> </section> <section id="implementing-functions-and-methods"> <h2>Implementing functions and methods</h2> <dl class="c type"> <dt class="sig sig-object c" id="c.PyCFunction">
<code>type PyCFunction</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Type of the functions used to implement most Python callables in C. Functions of this type take two <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> parameters and return one such value. If the return value is <code>NULL</code>, an exception shall have been set. If not <code>NULL</code>, the return value is interpreted as the return value of the function as exposed in Python. The function must return a new reference.</p> <p>The function signature is:</p> <pre data-language="c">PyObject *PyCFunction(PyObject *self,
                      PyObject *args);
</pre> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyCFunctionWithKeywords">
<code>type PyCFunctionWithKeywords</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Type of the functions used to implement Python callables in C with signature <a class="reference internal" href="#meth-varargs-meth-keywords"><span class="std std-ref">METH_VARARGS | METH_KEYWORDS</span></a>. The function signature is:</p> <pre data-language="c">PyObject *PyCFunctionWithKeywords(PyObject *self,
                                  PyObject *args,
                                  PyObject *kwargs);
</pre> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyCFunctionFast">
<code>type PyCFunctionFast</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Type of the functions used to implement Python callables in C with signature <a class="reference internal" href="#c.METH_FASTCALL" title="METH_FASTCALL"><code>METH_FASTCALL</code></a>. The function signature is:</p> <pre data-language="c">PyObject *PyCFunctionFast(PyObject *self,
                          PyObject *const *args,
                          Py_ssize_t nargs);
</pre> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyCFunctionFastWithKeywords">
<code>type PyCFunctionFastWithKeywords</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Type of the functions used to implement Python callables in C with signature <a class="reference internal" href="#meth-fastcall-meth-keywords"><span class="std std-ref">METH_FASTCALL | METH_KEYWORDS</span></a>. The function signature is:</p> <pre data-language="c">PyObject *PyCFunctionFastWithKeywords(PyObject *self,
                                      PyObject *const *args,
                                      Py_ssize_t nargs,
                                      PyObject *kwnames);
</pre> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyCMethod">
<code>type PyCMethod</code> </dt> <dd>
<p>Type of the functions used to implement Python callables in C with signature <a class="reference internal" href="#meth-method-meth-fastcall-meth-keywords"><span class="std std-ref">METH_METHOD | METH_FASTCALL | METH_KEYWORDS</span></a>. The function signature is:</p> <pre data-language="c">PyObject *PyCMethod(PyObject *self,
                    PyTypeObject *defining_class,
                    PyObject *const *args,
                    Py_ssize_t nargs,
                    PyObject *kwnames)
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyMethodDef">
<code>type PyMethodDef</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> (including all members).</em><p>Structure used to describe a method of an extension type. This structure has four fields:</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMethodDef.ml_name">
<code>const char *ml_name</code> </dt> <dd>
<p>Name of the method.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMethodDef.ml_meth">
<code>PyCFunction ml_meth</code> </dt> <dd>
<p>Pointer to the C implementation.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMethodDef.ml_flags">
<code>int ml_flags</code> </dt> <dd>
<p>Flags bits indicating how the call should be constructed.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMethodDef.ml_doc">
<code>const char *ml_doc</code> </dt> <dd>
<p>Points to the contents of the docstring.</p> </dd>
</dl> </dd>
</dl> <p>The <a class="reference internal" href="#c.PyMethodDef.ml_meth" title="PyMethodDef.ml_meth"><code>ml_meth</code></a> is a C function pointer. The functions may be of different types, but they always return <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>. If the function is not of the <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code>PyCFunction</code></a>, the compiler will require a cast in the method table. Even though <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code>PyCFunction</code></a> defines the first parameter as <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>, it is common that the method implementation uses the specific C type of the <em>self</em> object.</p> <p>The <a class="reference internal" href="#c.PyMethodDef.ml_flags" title="PyMethodDef.ml_flags"><code>ml_flags</code></a> field is a bitfield which can include the following flags. The individual flags indicate either a calling convention or a binding convention.</p> <p>There are these calling conventions:</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.METH_VARARGS">
<code>METH_VARARGS</code> </dt> <dd>
<p>This is the typical calling convention, where the methods have the type <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code>PyCFunction</code></a>. The function expects two <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> values. The first one is the <em>self</em> object for methods; for module functions, it is the module object. The second parameter (often called <em>args</em>) is a tuple object representing all arguments. This parameter is typically processed using <a class="reference internal" href="arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> or <a class="reference internal" href="arg.html#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code>PyArg_UnpackTuple()</code></a>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.METH_KEYWORDS">
<code>METH_KEYWORDS</code> </dt> <dd>
<p>Can only be used in certain combinations with other flags: <a class="reference internal" href="#meth-varargs-meth-keywords"><span class="std std-ref">METH_VARARGS | METH_KEYWORDS</span></a>, <a class="reference internal" href="#meth-fastcall-meth-keywords"><span class="std std-ref">METH_FASTCALL | METH_KEYWORDS</span></a> and <a class="reference internal" href="#meth-method-meth-fastcall-meth-keywords"><span class="std std-ref">METH_METHOD | METH_FASTCALL | METH_KEYWORDS</span></a>.</p> </dd>
</dl> <dl class="simple" id="meth-varargs-meth-keywords"> <dt><span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.METH_VARARGS" title="METH_VARARGS"><span class="n">METH_VARARGS</span></a><span class="w"> </span><span class="o">|</span><span class="w"> </span><a class="reference internal" href="#c.METH_KEYWORDS" title="METH_KEYWORDS"><span class="n">METH_KEYWORDS</span></a></span></dt>
<dd>
<p>Methods with these flags must be of type <a class="reference internal" href="#c.PyCFunctionWithKeywords" title="PyCFunctionWithKeywords"><code>PyCFunctionWithKeywords</code></a>. The function expects three parameters: <em>self</em>, <em>args</em>, <em>kwargs</em> where <em>kwargs</em> is a dictionary of all the keyword arguments or possibly <code>NULL</code> if there are no keyword arguments. The parameters are typically processed using <a class="reference internal" href="arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code>PyArg_ParseTupleAndKeywords()</code></a>.</p> </dd> </dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.METH_FASTCALL">
<code>METH_FASTCALL</code> </dt> <dd>
<p>Fast calling convention supporting only positional arguments. The methods have the type <a class="reference internal" href="#c.PyCFunctionFast" title="PyCFunctionFast"><code>PyCFunctionFast</code></a>. The first parameter is <em>self</em>, the second parameter is a C array of <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> values indicating the arguments and the third parameter is the number of arguments (the length of the array).</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.7.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span><code>METH_FASTCALL</code> is now part of the <a class="reference internal" href="stable.html#stable-abi"><span class="std std-ref">stable ABI</span></a>.</p> </div> </dd>
</dl> <dl id="meth-fastcall-meth-keywords"> <dt><span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.METH_FASTCALL" title="METH_FASTCALL"><span class="n">METH_FASTCALL</span></a><span class="w"> </span><span class="o">|</span><span class="w"> </span><a class="reference internal" href="#c.METH_KEYWORDS" title="METH_KEYWORDS"><span class="n">METH_KEYWORDS</span></a></span></dt>
<dd>
<p>Extension of <a class="reference internal" href="#c.METH_FASTCALL" title="METH_FASTCALL"><code>METH_FASTCALL</code></a> supporting also keyword arguments, with methods of type <a class="reference internal" href="#c.PyCFunctionFastWithKeywords" title="PyCFunctionFastWithKeywords"><code>PyCFunctionFastWithKeywords</code></a>. Keyword arguments are passed the same way as in the <a class="reference internal" href="call.html#vectorcall"><span class="std std-ref">vectorcall protocol</span></a>: there is an additional fourth <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> parameter which is a tuple representing the names of the keyword arguments (which are guaranteed to be strings) or possibly <code>NULL</code> if there are no keywords. The values of the keyword arguments are stored in the <em>args</em> array, after the positional arguments.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.7.</span></p> </div> </dd> </dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.METH_METHOD">
<code>METH_METHOD</code> </dt> <dd>
<p>Can only be used in the combination with other flags: <a class="reference internal" href="#meth-method-meth-fastcall-meth-keywords"><span class="std std-ref">METH_METHOD | METH_FASTCALL | METH_KEYWORDS</span></a>.</p> </dd>
</dl> <dl id="meth-method-meth-fastcall-meth-keywords"> <dt><span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.METH_METHOD" title="METH_METHOD"><span class="n">METH_METHOD</span></a><span class="w"> </span><span class="o">|</span><span class="w"> </span><a class="reference internal" href="#c.METH_FASTCALL" title="METH_FASTCALL"><span class="n">METH_FASTCALL</span></a><span class="w"> </span><span class="o">|</span><span class="w"> </span><a class="reference internal" href="#c.METH_KEYWORDS" title="METH_KEYWORDS"><span class="n">METH_KEYWORDS</span></a></span></dt>
<dd>
<p>Extension of <a class="reference internal" href="#meth-fastcall-meth-keywords"><span class="std std-ref">METH_FASTCALL | METH_KEYWORDS</span></a> supporting the <em>defining class</em>, that is, the class that contains the method in question. The defining class might be a superclass of <code>Py_TYPE(self)</code>.</p> <p>The method needs to be of type <a class="reference internal" href="#c.PyCMethod" title="PyCMethod"><code>PyCMethod</code></a>, the same as for <code>METH_FASTCALL | METH_KEYWORDS</code> with <code>defining_class</code> argument added after <code>self</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd> </dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.METH_NOARGS">
<code>METH_NOARGS</code> </dt> <dd>
<p>Methods without parameters don’t need to check whether arguments are given if they are listed with the <a class="reference internal" href="#c.METH_NOARGS" title="METH_NOARGS"><code>METH_NOARGS</code></a> flag. They need to be of type <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code>PyCFunction</code></a>. The first parameter is typically named <em>self</em> and will hold a reference to the module or object instance. In all cases the second parameter will be <code>NULL</code>.</p> <p>The function must have 2 parameters. Since the second parameter is unused, <a class="reference internal" href="intro.html#c.Py_UNUSED" title="Py_UNUSED"><code>Py_UNUSED</code></a> can be used to prevent a compiler warning.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.METH_O">
<code>METH_O</code> </dt> <dd>
<p>Methods with a single object argument can be listed with the <a class="reference internal" href="#c.METH_O" title="METH_O"><code>METH_O</code></a> flag, instead of invoking <a class="reference internal" href="arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> with a <code>"O"</code> argument. They have the type <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code>PyCFunction</code></a>, with the <em>self</em> parameter, and a <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> parameter representing the single argument.</p> </dd>
</dl> <p>These two constants are not used to indicate the calling convention but the binding when use with methods of classes. These may not be used for functions defined for modules. At most one of these flags may be set for any given method.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.METH_CLASS">
<code>METH_CLASS</code> </dt> <dd>
<p id="index-0">The method will be passed the type object as the first parameter rather than an instance of the type. This is used to create <em>class methods</em>, similar to what is created when using the <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code>classmethod()</code></a> built-in function.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.METH_STATIC">
<code>METH_STATIC</code> </dt> <dd>
<p id="index-1">The method will be passed <code>NULL</code> as the first parameter rather than an instance of the type. This is used to create <em>static methods</em>, similar to what is created when using the <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code>staticmethod()</code></a> built-in function.</p> </dd>
</dl> <p>One other constant controls whether a method is loaded in place of another definition with the same method name.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.METH_COEXIST">
<code>METH_COEXIST</code> </dt> <dd>
<p>The method will be loaded in place of existing definitions. Without <em>METH_COEXIST</em>, the default is to skip repeated definitions. Since slot wrappers are loaded before the method table, the existence of a <em>sq_contains</em> slot, for example, would generate a wrapped method named <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code>__contains__()</code></a> and preclude the loading of a corresponding PyCFunction with the same name. With the flag defined, the PyCFunction will be loaded in place of the wrapper object and will co-exist with the slot. This is helpful because calls to PyCFunctions are optimized more than wrapper object calls.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCMethod_New">
<code>PyObject *PyCMethod_New(PyMethodDef *ml, PyObject *self, PyObject *module, PyTypeObject *cls)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.9.</em><p>Turn <em>ml</em> into a Python <a class="reference internal" href="../glossary.html#term-callable"><span class="xref std std-term">callable</span></a> object. The caller must ensure that <em>ml</em> outlives the <a class="reference internal" href="../glossary.html#term-callable"><span class="xref std std-term">callable</span></a>. Typically, <em>ml</em> is defined as a static variable.</p> <p>The <em>self</em> parameter will be passed as the <em>self</em> argument to the C function in <code>ml-&gt;ml_meth</code> when invoked. <em>self</em> can be <code>NULL</code>.</p> <p>The <a class="reference internal" href="../glossary.html#term-callable"><span class="xref std std-term">callable</span></a> object’s <code>__module__</code> attribute can be set from the given <em>module</em> argument. <em>module</em> should be a Python string, which will be used as name of the module the function is defined in. If unavailable, it can be set to <a class="reference internal" href="../library/constants.html#None" title="None"><code>None</code></a> or <code>NULL</code>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="../reference/datamodel.html#function.__module__" title="function.__module__"><code>function.__module__</code></a></p> </div> <p>The <em>cls</em> parameter will be passed as the <em>defining_class</em> argument to the C function. Must be set if <a class="reference internal" href="#c.METH_METHOD" title="METH_METHOD"><code>METH_METHOD</code></a> is set on <code>ml-&gt;ml_flags</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCFunction_NewEx">
<code>PyObject *PyCFunction_NewEx(PyMethodDef *ml, PyObject *self, PyObject *module)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Equivalent to <code>PyCMethod_New(ml, self, module, NULL)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCFunction_New">
<code>PyObject *PyCFunction_New(PyMethodDef *ml, PyObject *self)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.4.</em><p>Equivalent to <code>PyCMethod_New(ml, self, NULL, NULL)</code>.</p> </dd>
</dl> </section> <section id="accessing-attributes-of-extension-types"> <h2>Accessing attributes of extension types</h2> <dl class="c type"> <dt class="sig sig-object c" id="c.PyMemberDef">
<code>type PyMemberDef</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> (including all members).</em><p>Structure which describes an attribute of a type which corresponds to a C struct member. When defining a class, put a NULL-terminated array of these structures in the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code>tp_members</code></a> slot.</p> <p>Its fields are, in order:</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMemberDef.name">
<code>const char *name</code> </dt> <dd>
<p>Name of the member. A NULL value marks the end of a <code>PyMemberDef[]</code> array.</p> <p>The string should be static, no copy is made of it.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMemberDef.type">
<code>int type</code> </dt> <dd>
<p>The type of the member in the C struct. See <a class="reference internal" href="#pymemberdef-types"><span class="std std-ref">Member types</span></a> for the possible values.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMemberDef.offset">
<code>Py_ssize_t offset</code> </dt> <dd>
<p>The offset in bytes that the member is located on the type’s object struct.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMemberDef.flags">
<code>int flags</code> </dt> <dd>
<p>Zero or more of the <a class="reference internal" href="#pymemberdef-flags"><span class="std std-ref">Member flags</span></a>, combined using bitwise OR.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMemberDef.doc">
<code>const char *doc</code> </dt> <dd>
<p>The docstring, or NULL. The string should be static, no copy is made of it. Typically, it is defined using <a class="reference internal" href="intro.html#c.PyDoc_STR" title="PyDoc_STR"><code>PyDoc_STR</code></a>.</p> </dd>
</dl> <p>By default (when <a class="reference internal" href="#c.PyMemberDef.flags" title="PyMemberDef.flags"><code>flags</code></a> is <code>0</code>), members allow both read and write access. Use the <a class="reference internal" href="#c.Py_READONLY" title="Py_READONLY"><code>Py_READONLY</code></a> flag for read-only access. Certain types, like <a class="reference internal" href="#c.Py_T_STRING" title="Py_T_STRING"><code>Py_T_STRING</code></a>, imply <a class="reference internal" href="#c.Py_READONLY" title="Py_READONLY"><code>Py_READONLY</code></a>. Only <a class="reference internal" href="#c.Py_T_OBJECT_EX" title="Py_T_OBJECT_EX"><code>Py_T_OBJECT_EX</code></a> (and legacy <a class="reference internal" href="#c.T_OBJECT" title="T_OBJECT"><code>T_OBJECT</code></a>) members can be deleted.</p> <p id="pymemberdef-offsets">For heap-allocated types (created using <a class="reference internal" href="type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code>PyType_FromSpec()</code></a> or similar), <code>PyMemberDef</code> may contain a definition for the special member <code>"__vectorcalloffset__"</code>, corresponding to <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code>tp_vectorcall_offset</code></a> in type objects. These must be defined with <code>Py_T_PYSSIZET</code> and <code>Py_READONLY</code>, for example:</p> <pre data-language="c">static PyMemberDef spam_type_members[] = {
    {"__vectorcalloffset__", Py_T_PYSSIZET,
     offsetof(Spam_object, vectorcall), Py_READONLY},
    {NULL}  /* Sentinel */
};
</pre> <p>(You may need to <code>#include &lt;stddef.h&gt;</code> for <code>offsetof()</code>.)</p> <p>The legacy offsets <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code>tp_dictoffset</code></a> and <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code>tp_weaklistoffset</code></a> can be defined similarly using <code>"__dictoffset__"</code> and <code>"__weaklistoffset__"</code> members, but extensions are strongly encouraged to use <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code>Py_TPFLAGS_MANAGED_DICT</code></a> and <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code>Py_TPFLAGS_MANAGED_WEAKREF</code></a> instead.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span><code>PyMemberDef</code> is always available. Previously, it required including <code>"structmember.h"</code>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMember_GetOne">
<code>PyObject *PyMember_GetOne(const char *obj_addr, struct PyMemberDef *m)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Get an attribute belonging to the object at address <em>obj_addr</em>. The attribute is described by <code>PyMemberDef</code> <em>m</em>. Returns <code>NULL</code> on error.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span><code>PyMember_GetOne</code> is always available. Previously, it required including <code>"structmember.h"</code>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMember_SetOne">
<code>int PyMember_SetOne(char *obj_addr, struct PyMemberDef *m, PyObject *o)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Set an attribute belonging to the object at address <em>obj_addr</em> to object <em>o</em>. The attribute to set is described by <code>PyMemberDef</code> <em>m</em>. Returns <code>0</code> if successful and a negative value on failure.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span><code>PyMember_SetOne</code> is always available. Previously, it required including <code>"structmember.h"</code>.</p> </div> </dd>
</dl> <section id="member-flags"> <span id="pymemberdef-flags"></span><h3>Member flags</h3> <p>The following flags can be used with <a class="reference internal" href="#c.PyMemberDef.flags" title="PyMemberDef.flags"><code>PyMemberDef.flags</code></a>:</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_READONLY">
<code>Py_READONLY</code> </dt> <dd>
<p>Not writable.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_AUDIT_READ">
<code>Py_AUDIT_READ</code> </dt> <dd>
<p>Emit an <code>object.__getattr__</code> <a class="reference internal" href="../library/audit_events.html#audit-events"><span class="std std-ref">audit event</span></a> before reading.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_RELATIVE_OFFSET">
<code>Py_RELATIVE_OFFSET</code> </dt> <dd>
<p>Indicates that the <a class="reference internal" href="#c.PyMemberDef.offset" title="PyMemberDef.offset"><code>offset</code></a> of this <code>PyMemberDef</code> entry indicates an offset from the subclass-specific data, rather than from <code>PyObject</code>.</p> <p>Can only be used as part of <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code>Py_tp_members</code></a> <a class="reference internal" href="type.html#c.PyType_Slot" title="PyType_Slot"><code>slot</code></a> when creating a class using negative <a class="reference internal" href="type.html#c.PyType_Spec.basicsize" title="PyType_Spec.basicsize"><code>basicsize</code></a>. It is mandatory in that case.</p> <p>This flag is only used in <a class="reference internal" href="type.html#c.PyType_Slot" title="PyType_Slot"><code>PyType_Slot</code></a>. When setting <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code>tp_members</code></a> during class creation, Python clears it and sets <a class="reference internal" href="#c.PyMemberDef.offset" title="PyMemberDef.offset"><code>PyMemberDef.offset</code></a> to the offset from the <code>PyObject</code> struct.</p> </dd>
</dl> <div class="versionchanged" id="index-2"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <code>RESTRICTED</code>, <code>READ_RESTRICTED</code> and <code>WRITE_RESTRICTED</code> macros available with <code>#include "structmember.h"</code> are deprecated. <code>READ_RESTRICTED</code> and <code>RESTRICTED</code> are equivalent to <a class="reference internal" href="#c.Py_AUDIT_READ" title="Py_AUDIT_READ"><code>Py_AUDIT_READ</code></a>; <code>WRITE_RESTRICTED</code> does nothing.</p> </div> <div class="versionchanged" id="index-3"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The <code>READONLY</code> macro was renamed to <a class="reference internal" href="#c.Py_READONLY" title="Py_READONLY"><code>Py_READONLY</code></a>. The <code>PY_AUDIT_READ</code> macro was renamed with the <code>Py_</code> prefix. The new names are now always available. Previously, these required <code>#include "structmember.h"</code>. The header is still available and it provides the old names.</p> </div> </section> <section id="member-types"> <span id="pymemberdef-types"></span><h3>Member types</h3> <p><a class="reference internal" href="#c.PyMemberDef.type" title="PyMemberDef.type"><code>PyMemberDef.type</code></a> can be one of the following macros corresponding to various C types. When the member is accessed in Python, it will be converted to the equivalent Python type. When it is set from Python, it will be converted back to the C type. If that is not possible, an exception such as <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> or <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised.</p> <p>Unless marked (D), attributes defined this way cannot be deleted using e.g. <a class="reference internal" href="../reference/simple_stmts.html#del"><code>del</code></a> or <a class="reference internal" href="../library/functions.html#delattr" title="delattr"><code>delattr()</code></a>.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Macro name</p></th> <th class="head"><p>C type</p></th> <th class="head"><p>Python type</p></th> </tr> </thead>  <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_BYTE">
<code>Py_T_BYTE</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_SHORT">
<code>Py_T_SHORT</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">short</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_INT">
<code>Py_T_INT</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">int</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_LONG">
<code>Py_T_LONG</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">long</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_LONGLONG">
<code>Py_T_LONGLONG</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_UBYTE">
<code>Py_T_UBYTE</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_UINT">
<code>Py_T_UINT</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_USHORT">
<code>Py_T_USHORT</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_ULONG">
<code>Py_T_ULONG</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_ULONGLONG">
<code>Py_T_ULONGLONG</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_PYSSIZET">
<code>Py_T_PYSSIZET</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n">Py_ssize_t</span></a></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_FLOAT">
<code>Py_T_FLOAT</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">float</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#float" title="float"><code>float</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_DOUBLE">
<code>Py_T_DOUBLE</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">double</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#float" title="float"><code>float</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_BOOL">
<code>Py_T_BOOL</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span></span> (written as 0 or 1)</p></td> <td><p><a class="reference internal" href="../library/functions.html#bool" title="bool"><code>bool</code></a></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_STRING">
<code>Py_T_STRING</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> (*)</p></td> <td><p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> (RO)</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_STRING_INPLACE">
<code>Py_T_STRING_INPLACE</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="p">]</span></span> (*)</p></td> <td><p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> (RO)</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_CHAR">
<code>Py_T_CHAR</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span></span> (0-127)</p></td> <td><p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> (**)</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_T_OBJECT_EX">
<code>Py_T_OBJECT_EX</code> </dt> <dd></dd>
</dl> </td> <td><p><span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span></p></td> <td><p><a class="reference internal" href="../library/functions.html#object" title="object"><code>object</code></a> (D)</p></td> </tr>  </table>  <p>(*): Zero-terminated, UTF8-encoded C string. With <code>Py_T_STRING</code> the C representation is a pointer; with <code>Py_T_STRING_INPLACE</code> the string is stored directly in the structure.</p> <p>(**): String of length 1. Only ASCII is accepted.</p> <p>(RO): Implies <a class="reference internal" href="#c.Py_READONLY" title="Py_READONLY"><code>Py_READONLY</code></a>.</p> <p>(D): Can be deleted, in which case the pointer is set to <code>NULL</code>. Reading a <code>NULL</code> pointer raises <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code>AttributeError</code></a>.</p>  <div class="versionadded" id="index-4"> <p><span class="versionmodified added">Added in version 3.12: </span>In previous versions, the macros were only available with <code>#include "structmember.h"</code> and were named without the <code>Py_</code> prefix (e.g. as <code>T_INT</code>). The header is still available and contains the old names, along with the following deprecated types:</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.T_OBJECT">
<code>T_OBJECT</code> </dt> <dd>
<p>Like <code>Py_T_OBJECT_EX</code>, but <code>NULL</code> is converted to <code>None</code>. This results in surprising behavior in Python: deleting the attribute effectively sets it to <code>None</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.T_NONE">
<code>T_NONE</code> </dt> <dd>
<p>Always <code>None</code>. Must be used with <a class="reference internal" href="#c.Py_READONLY" title="Py_READONLY"><code>Py_READONLY</code></a>.</p> </dd>
</dl> </div> </section> <section id="defining-getters-and-setters"> <h3>Defining Getters and Setters</h3> <dl class="c type"> <dt class="sig sig-object c" id="c.PyGetSetDef">
<code>type PyGetSetDef</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> (including all members).</em><p>Structure to define property-like access for a type. See also description of the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code>PyTypeObject.tp_getset</code></a> slot.</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyGetSetDef.name">
<code>const char *name</code> </dt> <dd>
<p>attribute name</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyGetSetDef.get">
<code>getter get</code> </dt> <dd>
<p>C function to get the attribute.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyGetSetDef.set">
<code>setter set</code> </dt> <dd>
<p>Optional C function to set or delete the attribute. If <code>NULL</code>, the attribute is read-only.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyGetSetDef.doc">
<code>const char *doc</code> </dt> <dd>
<p>optional docstring</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyGetSetDef.closure">
<code>void *closure</code> </dt> <dd>
<p>Optional user data pointer, providing additional data for getter and setter.</p> </dd>
</dl> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.getter">
<code>typedef PyObject *(*getter)(PyObject*, void*)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>The <code>get</code> function takes one <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> parameter (the instance) and a user data pointer (the associated <code>closure</code>):</p> <p>It should return a new reference on success or <code>NULL</code> with a set exception on failure.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.setter">
<code>typedef int (*setter)(PyObject*, PyObject*, void*)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p><code>set</code> functions take two <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> parameters (the instance and the value to be set) and a user data pointer (the associated <code>closure</code>):</p> <p>In case the attribute should be deleted the second parameter is <code>NULL</code>. Should return <code>0</code> on success or <code>-1</code> with a set exception on failure.</p> </dd>
</dl> </section> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/structures.html" class="_attribution-link">https://docs.python.org/3.13/c-api/structures.html</a>
  </p>
</div>
