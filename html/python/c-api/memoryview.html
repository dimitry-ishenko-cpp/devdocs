 <span id="id1"></span><h1>MemoryView objects</h1> <p>A <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a> object exposes the C level <a class="reference internal" href="buffer.html#bufferobjects"><span class="std std-ref">buffer interface</span></a> as a Python object which can then be passed around like any other object.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMemoryView_FromObject">
<code>PyObject *PyMemoryView_FromObject(PyObject *obj)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a memoryview object from an object that provides the buffer interface. If <em>obj</em> supports writable buffer exports, the memoryview object will be read/write, otherwise it may be either read-only or read/write at the discretion of the exporter.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMemoryView_FromMemory">
<code>PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Create a memoryview object using <em>mem</em> as the underlying buffer. <em>flags</em> can be one of <code>PyBUF_READ</code> or <code>PyBUF_WRITE</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMemoryView_FromBuffer">
<code>PyObject *PyMemoryView_FromBuffer(const Py_buffer *view)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Create a memoryview object wrapping the given buffer structure <em>view</em>. For simple byte buffers, <a class="reference internal" href="#c.PyMemoryView_FromMemory" title="PyMemoryView_FromMemory"><code>PyMemoryView_FromMemory()</code></a> is the preferred function.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMemoryView_GetContiguous">
<code>PyObject *PyMemoryView_GetContiguous(PyObject *obj, int buffertype, char order)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a memoryview object to a <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> chunk of memory (in either ‘C’ or ‘F’ortran <em>order</em>) from an object that defines the buffer interface. If memory is contiguous, the memoryview object points to the original memory. Otherwise, a copy is made and the memoryview points to a new bytes object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMemoryView_Check">
<code>int PyMemoryView_Check(PyObject *obj)</code> </dt> <dd>
<p>Return true if the object <em>obj</em> is a memoryview object. It is not currently allowed to create subclasses of <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a>. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMemoryView_GET_BUFFER">
<code>Py_buffer *PyMemoryView_GET_BUFFER(PyObject *mview)</code> </dt> <dd>
<p>Return a pointer to the memoryview’s private copy of the exporter’s buffer. <em>mview</em> <strong>must</strong> be a memoryview instance; this macro doesn’t check its type, you must do it yourself or you will risk crashes.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyMemoryView_GET_BASE">
<code>PyObject *PyMemoryView_GET_BASE(PyObject *mview)</code> </dt> <dd>
<p>Return either a pointer to the exporting object that the memoryview is based on or <code>NULL</code> if the memoryview has been created by one of the functions <a class="reference internal" href="#c.PyMemoryView_FromMemory" title="PyMemoryView_FromMemory"><code>PyMemoryView_FromMemory()</code></a> or <a class="reference internal" href="#c.PyMemoryView_FromBuffer" title="PyMemoryView_FromBuffer"><code>PyMemoryView_FromBuffer()</code></a>. <em>mview</em> <strong>must</strong> be a memoryview instance.</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/c-api/memoryview.html" class="_attribution-link">https://docs.python.org/3.12/c-api/memoryview.html</a>
  </p>
</div>
