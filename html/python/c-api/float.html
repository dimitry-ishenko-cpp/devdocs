 <span id="floatobjects"></span><h1>Floating-Point Objects</h1> <dl class="c type" id="index-0"> <dt class="sig sig-object c" id="c.PyFloatObject">
<code>type PyFloatObject</code> </dt> <dd>
<p>This subtype of <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> represents a Python floating-point object.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyFloat_Type">
<code>PyTypeObject PyFloat_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This instance of <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> represents the Python floating-point type. This is the same object as <a class="reference internal" href="../library/functions.html#float" title="float"><code>float</code></a> in the Python layer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_Check">
<code>int PyFloat_Check(PyObject *p)</code> </dt> <dd>
<p>Return true if its argument is a <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code>PyFloatObject</code></a> or a subtype of <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code>PyFloatObject</code></a>. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_CheckExact">
<code>int PyFloat_CheckExact(PyObject *p)</code> </dt> <dd>
<p>Return true if its argument is a <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code>PyFloatObject</code></a>, but not a subtype of <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code>PyFloatObject</code></a>. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_FromString">
<code>PyObject *PyFloat_FromString(PyObject *str)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code>PyFloatObject</code></a> object based on the string value in <em>str</em>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_FromDouble">
<code>PyObject *PyFloat_FromDouble(double v)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code>PyFloatObject</code></a> object from <em>v</em>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_AsDouble">
<code>double PyFloat_AsDouble(PyObject *pyfloat)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> representation of the contents of <em>pyfloat</em>. If <em>pyfloat</em> is not a Python floating-point object but has a <a class="reference internal" href="../reference/datamodel.html#object.__float__" title="object.__float__"><code>__float__()</code></a> method, this method will first be called to convert <em>pyfloat</em> into a float. If <code>__float__()</code> is not defined then it falls back to <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a>. This method returns <code>-1.0</code> upon failure, so one should call <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to check for errors.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_AS_DOUBLE">
<code>double PyFloat_AS_DOUBLE(PyObject *pyfloat)</code> </dt> <dd>
<p>Return a C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> representation of the contents of <em>pyfloat</em>, but without error checking.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_GetInfo">
<code>PyObject *PyFloat_GetInfo(void)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a structseq instance which contains information about the precision, minimum and maximum values of a float. It’s a thin wrapper around the header file <code>float.h</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_GetMax">
<code>double PyFloat_GetMax()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the maximum representable finite float <em>DBL_MAX</em> as C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_GetMin">
<code>double PyFloat_GetMin()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the minimum normalized positive float <em>DBL_MIN</em> as C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span>.</p> </dd>
</dl> <section id="pack-and-unpack-functions"> <h2>Pack and Unpack functions</h2> <p>The pack and unpack functions provide an efficient platform-independent way to store floating-point values as byte strings. The Pack routines produce a bytes string from a C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span>, and the Unpack routines produce a C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> from such a bytes string. The suffix (2, 4 or 8) specifies the number of bytes in the bytes string.</p> <p>On platforms that appear to use IEEE 754 formats these functions work by copying bits. On other platforms, the 2-byte format is identical to the IEEE 754 binary16 half-precision format, the 4-byte format (32-bit) is identical to the IEEE 754 binary32 single precision format, and the 8-byte format to the IEEE 754 binary64 double precision format, although the packing of INFs and NaNs (if such things exist on the platform) isn’t handled correctly, and attempting to unpack a bytes string containing an IEEE INF or NaN will raise an exception.</p> <p>On non-IEEE platforms with more precision, or larger dynamic range, than IEEE 754 supports, not all values can be packed; on non-IEEE platforms with less precision, or smaller dynamic range, not all values can be unpacked. What happens in such cases is partly accidental (alas).</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.11.</span></p> </div> <section id="pack-functions"> <h3>Pack functions</h3> <p>The pack routines write 2, 4 or 8 bytes, starting at <em>p</em>. <em>le</em> is an <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> argument, non-zero if you want the bytes string in little-endian format (exponent last, at <code>p+1</code>, <code>p+3</code>, or <code>p+6</code> <code>p+7</code>), zero if you want big-endian format (exponent first, at <em>p</em>). The <code>PY_BIG_ENDIAN</code> constant can be used to use the native endian: it is equal to <code>1</code> on big endian processor, or <code>0</code> on little endian processor.</p> <p>Return value: <code>0</code> if all is OK, <code>-1</code> if error (and an exception is set, most likely <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>).</p> <p>There are two problems on non-IEEE platforms:</p> <ul class="simple"> <li>What this does is undefined if <em>x</em> is a NaN or infinity.</li> <li>
<code>-0.0</code> and <code>+0.0</code> produce the same bytes string.</li> </ul> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_Pack2">
<code>int PyFloat_Pack2(double x, unsigned char *p, int le)</code> </dt> <dd>
<p>Pack a C double as the IEEE 754 binary16 half-precision format.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_Pack4">
<code>int PyFloat_Pack4(double x, unsigned char *p, int le)</code> </dt> <dd>
<p>Pack a C double as the IEEE 754 binary32 single precision format.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_Pack8">
<code>int PyFloat_Pack8(double x, unsigned char *p, int le)</code> </dt> <dd>
<p>Pack a C double as the IEEE 754 binary64 double precision format.</p> </dd>
</dl> </section> <section id="unpack-functions"> <h3>Unpack functions</h3> <p>The unpack routines read 2, 4 or 8 bytes, starting at <em>p</em>. <em>le</em> is an <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> argument, non-zero if the bytes string is in little-endian format (exponent last, at <code>p+1</code>, <code>p+3</code> or <code>p+6</code> and <code>p+7</code>), zero if big-endian (exponent first, at <em>p</em>). The <code>PY_BIG_ENDIAN</code> constant can be used to use the native endian: it is equal to <code>1</code> on big endian processor, or <code>0</code> on little endian processor.</p> <p>Return value: The unpacked double. On error, this is <code>-1.0</code> and <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> is true (and an exception is set, most likely <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>).</p> <p>Note that on a non-IEEE platform this will refuse to unpack a bytes string that represents a NaN or infinity.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_Unpack2">
<code>double PyFloat_Unpack2(const unsigned char *p, int le)</code> </dt> <dd>
<p>Unpack the IEEE 754 binary16 half-precision format as a C double.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_Unpack4">
<code>double PyFloat_Unpack4(const unsigned char *p, int le)</code> </dt> <dd>
<p>Unpack the IEEE 754 binary32 single precision format as a C double.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyFloat_Unpack8">
<code>double PyFloat_Unpack8(const unsigned char *p, int le)</code> </dt> <dd>
<p>Unpack the IEEE 754 binary64 double precision format as a C double.</p> </dd>
</dl> </section> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/float.html" class="_attribution-link">https://docs.python.org/3.13/c-api/float.html</a>
  </p>
</div>
