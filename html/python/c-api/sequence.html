 <span id="sequence"></span><h1>Sequence Protocol</h1> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Check">
<code>int PySequence_Check(PyObject *o)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return <code>1</code> if the object provides the sequence protocol, and <code>0</code> otherwise. Note that it returns <code>1</code> for Python classes with a <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> method, unless they are <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code>dict</code></a> subclasses, since in general it is impossible to determine what type of keys the class supports. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Size">
<code>Py_ssize_t PySequence_Size(PyObject *o)</code> </dt> <dt class="sig sig-object c" id="c.PySequence_Length">
<code>Py_ssize_t PySequence_Length(PyObject *o)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-0">Returns the number of objects in sequence <em>o</em> on success, and <code>-1</code> on failure. This is equivalent to the Python expression <code>len(o)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Concat">
<code>PyObject *PySequence_Concat(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the concatenation of <em>o1</em> and <em>o2</em> on success, and <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 + o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Repeat">
<code>PyObject *PySequence_Repeat(PyObject *o, Py_ssize_t count)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the result of repeating sequence object <em>o</em> <em>count</em> times, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o * count</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_InPlaceConcat">
<code>PyObject *PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the concatenation of <em>o1</em> and <em>o2</em> on success, and <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python expression <code>o1 += o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_InPlaceRepeat">
<code>PyObject *PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the result of repeating sequence object <em>o</em> <em>count</em> times, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o</em> supports it. This is the equivalent of the Python expression <code>o *= count</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_GetItem">
<code>PyObject *PySequence_GetItem(PyObject *o, Py_ssize_t i)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the <em>i</em>th element of <em>o</em>, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o[i]</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_GetSlice">
<code>PyObject *PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the slice of sequence object <em>o</em> between <em>i1</em> and <em>i2</em>, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o[i1:i2]</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_SetItem">
<code>int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Assign object <em>v</em> to the <em>i</em>th element of <em>o</em>. Raise an exception and return <code>-1</code> on failure; return <code>0</code> on success. This is the equivalent of the Python statement <code>o[i] = v</code>. This function <em>does not</em> steal a reference to <em>v</em>.</p> <p>If <em>v</em> is <code>NULL</code>, the element is deleted, but this feature is deprecated in favour of using <a class="reference internal" href="#c.PySequence_DelItem" title="PySequence_DelItem"><code>PySequence_DelItem()</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_DelItem">
<code>int PySequence_DelItem(PyObject *o, Py_ssize_t i)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Delete the <em>i</em>th element of object <em>o</em>. Returns <code>-1</code> on failure. This is the equivalent of the Python statement <code>del o[i]</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_SetSlice">
<code>int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2, PyObject *v)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Assign the sequence object <em>v</em> to the slice in sequence object <em>o</em> from <em>i1</em> to <em>i2</em>. This is the equivalent of the Python statement <code>o[i1:i2] = v</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_DelSlice">
<code>int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Delete the slice in sequence object <em>o</em> from <em>i1</em> to <em>i2</em>. Returns <code>-1</code> on failure. This is the equivalent of the Python statement <code>del o[i1:i2]</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Count">
<code>Py_ssize_t PySequence_Count(PyObject *o, PyObject *value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the number of occurrences of <em>value</em> in <em>o</em>, that is, return the number of keys for which <code>o[key] == value</code>. On failure, return <code>-1</code>. This is equivalent to the Python expression <code>o.count(value)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Contains">
<code>int PySequence_Contains(PyObject *o, PyObject *value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Determine if <em>o</em> contains <em>value</em>. If an item in <em>o</em> is equal to <em>value</em>, return <code>1</code>, otherwise return <code>0</code>. On error, return <code>-1</code>. This is equivalent to the Python expression <code>value in o</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Index">
<code>Py_ssize_t PySequence_Index(PyObject *o, PyObject *value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the first index <em>i</em> for which <code>o[i] == value</code>. On error, return <code>-1</code>. This is equivalent to the Python expression <code>o.index(value)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_List">
<code>PyObject *PySequence_List(PyObject *o)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a list object with the same contents as the sequence or iterable <em>o</em>, or <code>NULL</code> on failure. The returned list is guaranteed to be new. This is equivalent to the Python expression <code>list(o)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Tuple">
<code>PyObject *PySequence_Tuple(PyObject *o)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-1">Return a tuple object with the same contents as the sequence or iterable <em>o</em>, or <code>NULL</code> on failure. If <em>o</em> is a tuple, a new reference will be returned, otherwise a tuple will be constructed with the appropriate contents. This is equivalent to the Python expression <code>tuple(o)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Fast">
<code>PyObject *PySequence_Fast(PyObject *o, const char *m)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the sequence or iterable <em>o</em> as an object usable by the other <code>PySequence_Fast*</code> family of functions. If the object is not a sequence or iterable, raises <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> with <em>m</em> as the message text. Returns <code>NULL</code> on failure.</p> <p>The <code>PySequence_Fast*</code> functions are thus named because they assume <em>o</em> is a <a class="reference internal" href="tuple.html#c.PyTupleObject" title="PyTupleObject"><code>PyTupleObject</code></a> or a <a class="reference internal" href="list.html#c.PyListObject" title="PyListObject"><code>PyListObject</code></a> and access the data fields of <em>o</em> directly.</p> <p>As a CPython implementation detail, if <em>o</em> is already a sequence or list, it will be returned.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Fast_GET_SIZE">
<code>Py_ssize_t PySequence_Fast_GET_SIZE(PyObject *o)</code> </dt> <dd>
<p>Returns the length of <em>o</em>, assuming that <em>o</em> was returned by <a class="reference internal" href="#c.PySequence_Fast" title="PySequence_Fast"><code>PySequence_Fast()</code></a> and that <em>o</em> is not <code>NULL</code>. The size can also be retrieved by calling <a class="reference internal" href="#c.PySequence_Size" title="PySequence_Size"><code>PySequence_Size()</code></a> on <em>o</em>, but <a class="reference internal" href="#c.PySequence_Fast_GET_SIZE" title="PySequence_Fast_GET_SIZE"><code>PySequence_Fast_GET_SIZE()</code></a> is faster because it can assume <em>o</em> is a list or tuple.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Fast_GET_ITEM">
<code>PyObject *PySequence_Fast_GET_ITEM(PyObject *o, Py_ssize_t i)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><p>Return the <em>i</em>th element of <em>o</em>, assuming that <em>o</em> was returned by <a class="reference internal" href="#c.PySequence_Fast" title="PySequence_Fast"><code>PySequence_Fast()</code></a>, <em>o</em> is not <code>NULL</code>, and that <em>i</em> is within bounds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_Fast_ITEMS">
<code>PyObject **PySequence_Fast_ITEMS(PyObject *o)</code> </dt> <dd>
<p>Return the underlying array of PyObject pointers. Assumes that <em>o</em> was returned by <a class="reference internal" href="#c.PySequence_Fast" title="PySequence_Fast"><code>PySequence_Fast()</code></a> and <em>o</em> is not <code>NULL</code>.</p> <p>Note, if a list gets resized, the reallocation may relocate the items array. So, only use the underlying array pointer in contexts where the sequence cannot change.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySequence_ITEM">
<code>PyObject *PySequence_ITEM(PyObject *o, Py_ssize_t i)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><p>Return the <em>i</em>th element of <em>o</em> or <code>NULL</code> on failure. Faster form of <a class="reference internal" href="#c.PySequence_GetItem" title="PySequence_GetItem"><code>PySequence_GetItem()</code></a> but without checking that <a class="reference internal" href="#c.PySequence_Check" title="PySequence_Check"><code>PySequence_Check()</code></a> on <em>o</em> is true and without adjustment for negative indices.</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/sequence.html" class="_attribution-link">https://docs.python.org/3.13/c-api/sequence.html</a>
  </p>
</div>
