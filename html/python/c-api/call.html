 <span id="call"></span><h1>Call Protocol</h1> <p>CPython supports two different calling protocols: <em>tp_call</em> and vectorcall.</p> <section id="the-tp-call-protocol"> <h2>The <em>tp_call</em> Protocol</h2> <p>Instances of classes that set <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a> are callable. The signature of the slot is:</p> <pre data-language="c">PyObject *tp_call(PyObject *callable, PyObject *args, PyObject *kwargs);
</pre> <p>A call is made using a tuple for the positional arguments and a dict for the keyword arguments, similarly to <code>callable(*args, **kwargs)</code> in Python code. <em>args</em> must be non-NULL (use an empty tuple if there are no arguments) but <em>kwargs</em> may be <em>NULL</em> if there are no keyword arguments.</p> <p>This convention is not only used by <em>tp_call</em>: <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> and <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a> also pass arguments this way.</p> <p>To call an object, use <a class="reference internal" href="#c.PyObject_Call" title="PyObject_Call"><code>PyObject_Call()</code></a> or another <a class="reference internal" href="#capi-call"><span class="std std-ref">call API</span></a>.</p> </section> <section id="the-vectorcall-protocol"> <span id="vectorcall"></span><h2>The Vectorcall Protocol</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> <p>The vectorcall protocol was introduced in <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0590/"><strong>PEP 590</strong></a> as an additional protocol for making calls more efficient.</p> <p>As rule of thumb, CPython will prefer the vectorcall for internal calls if the callable supports it. However, this is not a hard rule. Additionally, some third-party extensions use <em>tp_call</em> directly (rather than using <a class="reference internal" href="#c.PyObject_Call" title="PyObject_Call"><code>PyObject_Call()</code></a>). Therefore, a class supporting vectorcall must also implement <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a>. Moreover, the callable must behave the same regardless of which protocol is used. The recommended way to achieve this is by setting <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a> to <a class="reference internal" href="#c.PyVectorcall_Call" title="PyVectorcall_Call"><code>PyVectorcall_Call()</code></a>. This bears repeating:</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>A class supporting vectorcall <strong>must</strong> also implement <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a> with the same semantics.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code>Py_TPFLAGS_HAVE_VECTORCALL</code></a> flag is now removed from a class when the class’s <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code>__call__()</code></a> method is reassigned. (This internally sets <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a> only, and thus may make it behave differently than the vectorcall function.) In earlier Python versions, vectorcall should only be used with <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_IMMUTABLETYPE" title="Py_TPFLAGS_IMMUTABLETYPE"><code>immutable</code></a> or static types.</p> </div> <p>A class should not implement vectorcall if that would be slower than <em>tp_call</em>. For example, if the callee needs to convert the arguments to an args tuple and kwargs dict anyway, then there is no point in implementing vectorcall.</p> <p>Classes can implement the vectorcall protocol by enabling the <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code>Py_TPFLAGS_HAVE_VECTORCALL</code></a> flag and setting <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code>tp_vectorcall_offset</code></a> to the offset inside the object structure where a <em>vectorcallfunc</em> appears. This is a pointer to a function with the following signature:</p> <dl class="c type"> <dt class="sig sig-object c" id="c.vectorcallfunc">
<code>typedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em></dd>
</dl> <ul class="simple"> <li>
<em>callable</em> is the object being called.</li> <li>
<dl class="simple"> <dt>
<em>args</em> is a C array consisting of the positional arguments followed by the</dt>
<dd>
<p>values of the keyword arguments. This can be <em>NULL</em> if there are no arguments.</p> </dd> </dl> </li> <li>
<dl class="simple"> <dt>
<em>nargsf</em> is the number of positional arguments plus possibly the</dt>
<dd>
<p><a class="reference internal" href="#c.PY_VECTORCALL_ARGUMENTS_OFFSET" title="PY_VECTORCALL_ARGUMENTS_OFFSET"><code>PY_VECTORCALL_ARGUMENTS_OFFSET</code></a> flag. To get the actual number of positional arguments from <em>nargsf</em>, use <a class="reference internal" href="#c.PyVectorcall_NARGS" title="PyVectorcall_NARGS"><code>PyVectorcall_NARGS()</code></a>.</p> </dd> </dl> </li> <li>
<dl class="simple"> <dt>
<em>kwnames</em> is a tuple containing the names of the keyword arguments;</dt>
<dd>
<p>in other words, the keys of the kwargs dict. These names must be strings (instances of <code>str</code> or a subclass) and they must be unique. If there are no keyword arguments, then <em>kwnames</em> can instead be <em>NULL</em>.</p> </dd> </dl> </li> </ul> <dl class="c macro"> <dt class="sig sig-object c" id="c.PY_VECTORCALL_ARGUMENTS_OFFSET">
<code>PY_VECTORCALL_ARGUMENTS_OFFSET</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>If this flag is set in a vectorcall <em>nargsf</em> argument, the callee is allowed to temporarily change <code>args[-1]</code>. In other words, <em>args</em> points to argument 1 (not 0) in the allocated vector. The callee must restore the value of <code>args[-1]</code> before returning.</p> <p>For <a class="reference internal" href="#c.PyObject_VectorcallMethod" title="PyObject_VectorcallMethod"><code>PyObject_VectorcallMethod()</code></a>, this flag means instead that <code>args[0]</code> may be changed.</p> <p>Whenever they can do so cheaply (without additional allocation), callers are encouraged to use <a class="reference internal" href="#c.PY_VECTORCALL_ARGUMENTS_OFFSET" title="PY_VECTORCALL_ARGUMENTS_OFFSET"><code>PY_VECTORCALL_ARGUMENTS_OFFSET</code></a>. Doing so will allow callables such as bound methods to make their onward calls (which include a prepended <em>self</em> argument) very efficiently.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> <p>To call an object that implements vectorcall, use a <a class="reference internal" href="#capi-call"><span class="std std-ref">call API</span></a> function as with any other callable. <a class="reference internal" href="#c.PyObject_Vectorcall" title="PyObject_Vectorcall"><code>PyObject_Vectorcall()</code></a> will usually be most efficient.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In CPython 3.8, the vectorcall API and related functions were available provisionally under names with a leading underscore: <code>_PyObject_Vectorcall</code>, <code>_Py_TPFLAGS_HAVE_VECTORCALL</code>, <code>_PyObject_VectorcallMethod</code>, <code>_PyVectorcall_Function</code>, <code>_PyObject_CallOneArg</code>, <code>_PyObject_CallMethodNoArgs</code>, <code>_PyObject_CallMethodOneArg</code>. Additionally, <code>PyObject_VectorcallDict</code> was available as <code>_PyObject_FastCallDict</code>. The old names are still defined as aliases of the new, non-underscored names.</p> </div> <section id="recursion-control"> <h3>Recursion Control</h3> <p>When using <em>tp_call</em>, callees do not need to worry about <a class="reference internal" href="exceptions.html#recursion"><span class="std std-ref">recursion</span></a>: CPython uses <a class="reference internal" href="exceptions.html#c.Py_EnterRecursiveCall" title="Py_EnterRecursiveCall"><code>Py_EnterRecursiveCall()</code></a> and <a class="reference internal" href="exceptions.html#c.Py_LeaveRecursiveCall" title="Py_LeaveRecursiveCall"><code>Py_LeaveRecursiveCall()</code></a> for calls made using <em>tp_call</em>.</p> <p>For efficiency, this is not the case for calls done using vectorcall: the callee should use <em>Py_EnterRecursiveCall</em> and <em>Py_LeaveRecursiveCall</em> if needed.</p> </section> <section id="vectorcall-support-api"> <h3>Vectorcall Support API</h3> <dl class="c function"> <dt class="sig sig-object c" id="c.PyVectorcall_NARGS">
<code>Py_ssize_t PyVectorcall_NARGS(size_t nargsf)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>Given a vectorcall <em>nargsf</em> argument, return the actual number of arguments. Currently equivalent to:</p> <pre data-language="c">(Py_ssize_t)(nargsf &amp; ~PY_VECTORCALL_ARGUMENTS_OFFSET)
</pre> <p>However, the function <code>PyVectorcall_NARGS</code> should be used to allow for future extensions.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyVectorcall_Function">
<code>vectorcallfunc PyVectorcall_Function(PyObject *op)</code> </dt> <dd>
<p>If <em>op</em> does not support the vectorcall protocol (either because the type does not or because the specific instance does not), return <em>NULL</em>. Otherwise, return the vectorcall function pointer stored in <em>op</em>. This function never raises an exception.</p> <p>This is mostly useful to check whether or not <em>op</em> supports vectorcall, which can be done by checking <code>PyVectorcall_Function(op) != NULL</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyVectorcall_Call">
<code>PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>Call <em>callable</em>’s <a class="reference internal" href="#c.vectorcallfunc" title="vectorcallfunc"><code>vectorcallfunc</code></a> with positional and keyword arguments given in a tuple and dict, respectively.</p> <p>This is a specialized function, intended to be put in the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a> slot or be used in an implementation of <code>tp_call</code>. It does not check the <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code>Py_TPFLAGS_HAVE_VECTORCALL</code></a> flag and it does not fall back to <code>tp_call</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> </section> </section> <section id="object-calling-api"> <span id="capi-call"></span><h2>Object Calling API</h2> <p>Various functions are available for calling a Python object. Each converts its arguments to a convention supported by the called object – either <em>tp_call</em> or vectorcall. In order to do as little conversion as possible, pick one that best fits the format of data you have available.</p> <p>The following table summarizes the available functions; please see individual documentation for details.</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Function</p></th> <th class="head"><p>callable</p></th> <th class="head"><p>args</p></th> <th class="head"><p>kwargs</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#c.PyObject_Call" title="PyObject_Call"><code>PyObject_Call()</code></a></p></td> <td><p><code>PyObject *</code></p></td> <td><p>tuple</p></td> <td><p>dict/<code>NULL</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_CallNoArgs" title="PyObject_CallNoArgs"><code>PyObject_CallNoArgs()</code></a></p></td> <td><p><code>PyObject *</code></p></td> <td><p>—</p></td> <td><p>—</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_CallOneArg" title="PyObject_CallOneArg"><code>PyObject_CallOneArg()</code></a></p></td> <td><p><code>PyObject *</code></p></td> <td><p>1 object</p></td> <td><p>—</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_CallObject" title="PyObject_CallObject"><code>PyObject_CallObject()</code></a></p></td> <td><p><code>PyObject *</code></p></td> <td><p>tuple/<code>NULL</code></p></td> <td><p>—</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_CallFunction" title="PyObject_CallFunction"><code>PyObject_CallFunction()</code></a></p></td> <td><p><code>PyObject *</code></p></td> <td><p>format</p></td> <td><p>—</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_CallMethod" title="PyObject_CallMethod"><code>PyObject_CallMethod()</code></a></p></td> <td><p>obj + <code>char*</code></p></td> <td><p>format</p></td> <td><p>—</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_CallFunctionObjArgs" title="PyObject_CallFunctionObjArgs"><code>PyObject_CallFunctionObjArgs()</code></a></p></td> <td><p><code>PyObject *</code></p></td> <td><p>variadic</p></td> <td><p>—</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_CallMethodObjArgs" title="PyObject_CallMethodObjArgs"><code>PyObject_CallMethodObjArgs()</code></a></p></td> <td><p>obj + name</p></td> <td><p>variadic</p></td> <td><p>—</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_CallMethodNoArgs" title="PyObject_CallMethodNoArgs"><code>PyObject_CallMethodNoArgs()</code></a></p></td> <td><p>obj + name</p></td> <td><p>—</p></td> <td><p>—</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_CallMethodOneArg" title="PyObject_CallMethodOneArg"><code>PyObject_CallMethodOneArg()</code></a></p></td> <td><p>obj + name</p></td> <td><p>1 object</p></td> <td><p>—</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_Vectorcall" title="PyObject_Vectorcall"><code>PyObject_Vectorcall()</code></a></p></td> <td><p><code>PyObject *</code></p></td> <td><p>vectorcall</p></td> <td><p>vectorcall</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_VectorcallDict" title="PyObject_VectorcallDict"><code>PyObject_VectorcallDict()</code></a></p></td> <td><p><code>PyObject *</code></p></td> <td><p>vectorcall</p></td> <td><p>dict/<code>NULL</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyObject_VectorcallMethod" title="PyObject_VectorcallMethod"><code>PyObject_VectorcallMethod()</code></a></p></td> <td><p>arg + name</p></td> <td><p>vectorcall</p></td> <td><p>vectorcall</p></td> </tr>  </table> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_Call">
<code>PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Call a callable Python object <em>callable</em>, with arguments given by the tuple <em>args</em>, and named arguments given by the dictionary <em>kwargs</em>.</p> <p><em>args</em> must not be <em>NULL</em>; use an empty tuple if no arguments are needed. If no named arguments are needed, <em>kwargs</em> can be <em>NULL</em>.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <p>This is the equivalent of the Python expression: <code>callable(*args, **kwargs)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CallNoArgs">
<code>PyObject *PyObject_CallNoArgs(PyObject *callable)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Call a callable Python object <em>callable</em> without any arguments. It is the most efficient way to call a callable Python object without any argument.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CallOneArg">
<code>PyObject *PyObject_CallOneArg(PyObject *callable, PyObject *arg)</code> </dt> <dd>
<p>Call a callable Python object <em>callable</em> with exactly 1 positional argument <em>arg</em> and no keyword arguments.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CallObject">
<code>PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Call a callable Python object <em>callable</em>, with arguments given by the tuple <em>args</em>. If no arguments are needed, then <em>args</em> can be <em>NULL</em>.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <p>This is the equivalent of the Python expression: <code>callable(*args)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CallFunction">
<code>PyObject *PyObject_CallFunction(PyObject *callable, const char *format, ...)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Call a callable Python object <em>callable</em>, with a variable number of C arguments. The C arguments are described using a <a class="reference internal" href="arg.html#c.Py_BuildValue" title="Py_BuildValue"><code>Py_BuildValue()</code></a> style format string. The format can be <em>NULL</em>, indicating that no arguments are provided.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <p>This is the equivalent of the Python expression: <code>callable(*args)</code>.</p> <p>Note that if you only pass <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> args, <a class="reference internal" href="#c.PyObject_CallFunctionObjArgs" title="PyObject_CallFunctionObjArgs"><code>PyObject_CallFunctionObjArgs()</code></a> is a faster alternative.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The type of <em>format</em> was changed from <code>char *</code>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CallMethod">
<code>PyObject *PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Call the method named <em>name</em> of object <em>obj</em> with a variable number of C arguments. The C arguments are described by a <a class="reference internal" href="arg.html#c.Py_BuildValue" title="Py_BuildValue"><code>Py_BuildValue()</code></a> format string that should produce a tuple.</p> <p>The format can be <em>NULL</em>, indicating that no arguments are provided.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <p>This is the equivalent of the Python expression: <code>obj.name(arg1, arg2, ...)</code>.</p> <p>Note that if you only pass <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> args, <a class="reference internal" href="#c.PyObject_CallMethodObjArgs" title="PyObject_CallMethodObjArgs"><code>PyObject_CallMethodObjArgs()</code></a> is a faster alternative.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The types of <em>name</em> and <em>format</em> were changed from <code>char *</code>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CallFunctionObjArgs">
<code>PyObject *PyObject_CallFunctionObjArgs(PyObject *callable, ...)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Call a callable Python object <em>callable</em>, with a variable number of <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> arguments. The arguments are provided as a variable number of parameters followed by <em>NULL</em>.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <p>This is the equivalent of the Python expression: <code>callable(arg1, arg2, ...)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CallMethodObjArgs">
<code>PyObject *PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Call a method of the Python object <em>obj</em>, where the name of the method is given as a Python string object in <em>name</em>. It is called with a variable number of <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> arguments. The arguments are provided as a variable number of parameters followed by <em>NULL</em>.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CallMethodNoArgs">
<code>PyObject *PyObject_CallMethodNoArgs(PyObject *obj, PyObject *name)</code> </dt> <dd>
<p>Call a method of the Python object <em>obj</em> without arguments, where the name of the method is given as a Python string object in <em>name</em>.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CallMethodOneArg">
<code>PyObject *PyObject_CallMethodOneArg(PyObject *obj, PyObject *name, PyObject *arg)</code> </dt> <dd>
<p>Call a method of the Python object <em>obj</em> with a single positional argument <em>arg</em>, where the name of the method is given as a Python string object in <em>name</em>.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_Vectorcall">
<code>PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>Call a callable Python object <em>callable</em>. The arguments are the same as for <a class="reference internal" href="#c.vectorcallfunc" title="vectorcallfunc"><code>vectorcallfunc</code></a>. If <em>callable</em> supports <a class="reference internal" href="#vectorcall">vectorcall</a>, this directly calls the vectorcall function stored in <em>callable</em>.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_VectorcallDict">
<code>PyObject *PyObject_VectorcallDict(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwdict)</code> </dt> <dd>
<p>Call <em>callable</em> with positional arguments passed exactly as in the <a class="reference internal" href="#vectorcall">vectorcall</a> protocol, but with keyword arguments passed as a dictionary <em>kwdict</em>. The <em>args</em> array contains only the positional arguments.</p> <p>Regardless of which protocol is used internally, a conversion of arguments needs to be done. Therefore, this function should only be used if the caller already has a dictionary ready to use for the keyword arguments, but not a tuple for the positional arguments.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_VectorcallMethod">
<code>PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>Call a method using the vectorcall calling convention. The name of the method is given as a Python string <em>name</em>. The object whose method is called is <em>args[0]</em>, and the <em>args</em> array starting at <em>args[1]</em> represents the arguments of the call. There must be at least one positional argument. <em>nargsf</em> is the number of positional arguments including <em>args[0]</em>, plus <a class="reference internal" href="#c.PY_VECTORCALL_ARGUMENTS_OFFSET" title="PY_VECTORCALL_ARGUMENTS_OFFSET"><code>PY_VECTORCALL_ARGUMENTS_OFFSET</code></a> if the value of <code>args[0]</code> may temporarily be changed. Keyword arguments can be passed just like in <a class="reference internal" href="#c.PyObject_Vectorcall" title="PyObject_Vectorcall"><code>PyObject_Vectorcall()</code></a>.</p> <p>If the object has the <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_METHOD_DESCRIPTOR" title="Py_TPFLAGS_METHOD_DESCRIPTOR"><code>Py_TPFLAGS_METHOD_DESCRIPTOR</code></a> feature, this will call the unbound method object with the full <em>args</em> vector as arguments.</p> <p>Return the result of the call on success, or raise an exception and return <em>NULL</em> on failure.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> </section> <section id="call-support-api"> <h2>Call Support API</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCallable_Check">
<code>int PyCallable_Check(PyObject *o)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Determine if the object <em>o</em> is callable. Return <code>1</code> if the object is callable and <code>0</code> otherwise. This function always succeeds.</p> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/c-api/call.html" class="_attribution-link">https://docs.python.org/3.12/c-api/call.html</a>
  </p>
</div>
