 <span id="importing"></span><h1>Importing Modules</h1> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ImportModule">
<code>PyObject *PyImport_ImportModule(const char *name)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-0">This is a wrapper around <a class="reference internal" href="#c.PyImport_Import" title="PyImport_Import"><code>PyImport_Import()</code></a> which takes a <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> as an argument instead of a <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ImportModuleNoBlock">
<code>PyObject *PyImport_ImportModuleNoBlock(const char *name)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This function is a deprecated alias of <a class="reference internal" href="#c.PyImport_ImportModule" title="PyImport_ImportModule"><code>PyImport_ImportModule()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>This function used to fail immediately when the import lock was held by another thread. In Python 3.3 though, the locking scheme switched to per-module locks for most purposes, so this function’s special behaviour isn’t needed anymore.</p> </div> <div class="deprecated-removed"> <p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>Use <a class="reference internal" href="#c.PyImport_ImportModule" title="PyImport_ImportModule"><code>PyImport_ImportModule()</code></a> instead.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ImportModuleEx">
<code>PyObject *PyImport_ImportModuleEx(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><p id="index-1">Import a module. This is best described by referring to the built-in Python function <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code>__import__()</code></a>.</p> <p>The return value is a new reference to the imported module or top-level package, or <code>NULL</code> with an exception set on failure. Like for <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code>__import__()</code></a>, the return value when a submodule of a package was requested is normally the top-level package, unless a non-empty <em>fromlist</em> was given.</p> <p>Failing imports remove incomplete module objects, like with <a class="reference internal" href="#c.PyImport_ImportModule" title="PyImport_ImportModule"><code>PyImport_ImportModule()</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ImportModuleLevelObject">
<code>PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Import a module. This is best described by referring to the built-in Python function <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code>__import__()</code></a>, as the standard <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code>__import__()</code></a> function calls this function directly.</p> <p>The return value is a new reference to the imported module or top-level package, or <code>NULL</code> with an exception set on failure. Like for <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code>__import__()</code></a>, the return value when a submodule of a package was requested is normally the top-level package, unless a non-empty <em>fromlist</em> was given.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ImportModuleLevel">
<code>PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Similar to <a class="reference internal" href="#c.PyImport_ImportModuleLevelObject" title="PyImport_ImportModuleLevelObject"><code>PyImport_ImportModuleLevelObject()</code></a>, but the name is a UTF-8 encoded string instead of a Unicode object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Negative values for <em>level</em> are no longer accepted.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_Import">
<code>PyObject *PyImport_Import(PyObject *name)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is a higher-level interface that calls the current “import hook function” (with an explicit <em>level</em> of 0, meaning absolute import). It invokes the <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code>__import__()</code></a> function from the <code>__builtins__</code> of the current globals. This means that the import is done using whatever import hooks are installed in the current environment.</p> <p>This function always uses absolute imports.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ReloadModule">
<code>PyObject *PyImport_ReloadModule(PyObject *m)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Reload a module. Return a new reference to the reloaded module, or <code>NULL</code> with an exception set on failure (the module still exists in this case).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_AddModuleRef">
<code>PyObject *PyImport_AddModuleRef(const char *name)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Return the module object corresponding to a module name.</p> <p>The <em>name</em> argument may be of the form <code>package.module</code>. First check the modules dictionary if there’s one there, and if not, create a new one and insert it in the modules dictionary.</p> <p>Return a <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to the module on success. Return <code>NULL</code> with an exception set on failure.</p> <p>The module name <em>name</em> is decoded from UTF-8.</p> <p>This function does not load or import the module; if the module wasn’t already loaded, you will get an empty module object. Use <a class="reference internal" href="#c.PyImport_ImportModule" title="PyImport_ImportModule"><code>PyImport_ImportModule()</code></a> or one of its variants to import a module. Package structures implied by a dotted name for <em>name</em> are not created if not already present.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_AddModuleObject">
<code>PyObject *PyImport_AddModuleObject(PyObject *name)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Similar to <a class="reference internal" href="#c.PyImport_AddModuleRef" title="PyImport_AddModuleRef"><code>PyImport_AddModuleRef()</code></a>, but return a <a class="reference internal" href="../glossary.html#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a> and <em>name</em> is a Python <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> object.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_AddModule">
<code>PyObject *PyImport_AddModule(const char *name)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Similar to <a class="reference internal" href="#c.PyImport_AddModuleRef" title="PyImport_AddModuleRef"><code>PyImport_AddModuleRef()</code></a>, but return a <a class="reference internal" href="../glossary.html#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ExecCodeModule">
<code>PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-2">Given a module name (possibly of the form <code>package.module</code>) and a code object read from a Python bytecode file or obtained from the built-in function <a class="reference internal" href="../library/functions.html#compile" title="compile"><code>compile()</code></a>, load the module. Return a new reference to the module object, or <code>NULL</code> with an exception set if an error occurred. <em>name</em> is removed from <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code>sys.modules</code></a> in error cases, even if <em>name</em> was already in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code>sys.modules</code></a> on entry to <a class="reference internal" href="#c.PyImport_ExecCodeModule" title="PyImport_ExecCodeModule"><code>PyImport_ExecCodeModule()</code></a>. Leaving incompletely initialized modules in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code>sys.modules</code></a> is dangerous, as imports of such modules have no way to know that the module object is an unknown (and probably damaged with respect to the module author’s intents) state.</p> <p>The module’s <a class="reference internal" href="../reference/datamodel.html#module.__spec__" title="module.__spec__"><code>__spec__</code></a> and <a class="reference internal" href="../reference/datamodel.html#module.__loader__" title="module.__loader__"><code>__loader__</code></a> will be set, if not set already, with the appropriate values. The spec’s loader will be set to the module’s <code>__loader__</code> (if set) and to an instance of <a class="reference internal" href="../library/importlib.html#importlib.machinery.SourceFileLoader" title="importlib.machinery.SourceFileLoader"><code>SourceFileLoader</code></a> otherwise.</p> <p>The module’s <a class="reference internal" href="../reference/datamodel.html#module.__file__" title="module.__file__"><code>__file__</code></a> attribute will be set to the code object’s <a class="reference internal" href="../reference/datamodel.html#codeobject.co_filename" title="codeobject.co_filename"><code>co_filename</code></a>. If applicable, <a class="reference internal" href="../reference/datamodel.html#module.__cached__" title="module.__cached__"><code>__cached__</code></a> will also be set.</p> <p>This function will reload the module if it was already imported. See <a class="reference internal" href="#c.PyImport_ReloadModule" title="PyImport_ReloadModule"><code>PyImport_ReloadModule()</code></a> for the intended way to reload a module.</p> <p>If <em>name</em> points to a dotted name of the form <code>package.module</code>, any package structures not already created will still not be created.</p> <p>See also <a class="reference internal" href="#c.PyImport_ExecCodeModuleEx" title="PyImport_ExecCodeModuleEx"><code>PyImport_ExecCodeModuleEx()</code></a> and <a class="reference internal" href="#c.PyImport_ExecCodeModuleWithPathnames" title="PyImport_ExecCodeModuleWithPathnames"><code>PyImport_ExecCodeModuleWithPathnames()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The setting of <a class="reference internal" href="../reference/datamodel.html#module.__cached__" title="module.__cached__"><code>__cached__</code></a> and <a class="reference internal" href="../reference/datamodel.html#module.__loader__" title="module.__loader__"><code>__loader__</code></a> is deprecated. See <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code>ModuleSpec</code></a> for alternatives.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ExecCodeModuleEx">
<code>PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Like <a class="reference internal" href="#c.PyImport_ExecCodeModule" title="PyImport_ExecCodeModule"><code>PyImport_ExecCodeModule()</code></a>, but the <a class="reference internal" href="../reference/datamodel.html#module.__file__" title="module.__file__"><code>__file__</code></a> attribute of the module object is set to <em>pathname</em> if it is non-<code>NULL</code>.</p> <p>See also <a class="reference internal" href="#c.PyImport_ExecCodeModuleWithPathnames" title="PyImport_ExecCodeModuleWithPathnames"><code>PyImport_ExecCodeModuleWithPathnames()</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ExecCodeModuleObject">
<code>PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Like <a class="reference internal" href="#c.PyImport_ExecCodeModuleEx" title="PyImport_ExecCodeModuleEx"><code>PyImport_ExecCodeModuleEx()</code></a>, but the <a class="reference internal" href="../reference/datamodel.html#module.__cached__" title="module.__cached__"><code>__cached__</code></a> attribute of the module object is set to <em>cpathname</em> if it is non-<code>NULL</code>. Of the three functions, this is the preferred one to use.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Setting <a class="reference internal" href="../reference/datamodel.html#module.__cached__" title="module.__cached__"><code>__cached__</code></a> is deprecated. See <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code>ModuleSpec</code></a> for alternatives.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ExecCodeModuleWithPathnames">
<code>PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Like <a class="reference internal" href="#c.PyImport_ExecCodeModuleObject" title="PyImport_ExecCodeModuleObject"><code>PyImport_ExecCodeModuleObject()</code></a>, but <em>name</em>, <em>pathname</em> and <em>cpathname</em> are UTF-8 encoded strings. Attempts are also made to figure out what the value for <em>pathname</em> should be from <em>cpathname</em> if the former is set to <code>NULL</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Uses <code>imp.source_from_cache()</code> in calculating the source path if only the bytecode path is provided.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>No longer uses the removed <code>imp</code> module.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_GetMagicNumber">
<code>long PyImport_GetMagicNumber()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the magic number for Python bytecode files (a.k.a. <code>.pyc</code> file). The magic number should be present in the first four bytes of the bytecode file, in little-endian byte order. Returns <code>-1</code> on error.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Return value of <code>-1</code> upon failure.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_GetMagicTag">
<code>const char *PyImport_GetMagicTag()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the magic tag string for <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a> format Python bytecode file names. Keep in mind that the value at <code>sys.implementation.cache_tag</code> is authoritative and should be used instead of this function.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_GetModuleDict">
<code>PyObject *PyImport_GetModuleDict()</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the dictionary used for the module administration (a.k.a. <code>sys.modules</code>). Note that this is a per-interpreter variable.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_GetModule">
<code>PyObject *PyImport_GetModule(PyObject *name)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.8.</em><p>Return the already imported module with the given name. If the module has not been imported yet then returns <code>NULL</code> but does not set an error. Returns <code>NULL</code> and sets an error if the lookup failed.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.7.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_GetImporter">
<code>PyObject *PyImport_GetImporter(PyObject *path)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a finder object for a <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code>sys.path</code></a>/<code>pkg.__path__</code> item <em>path</em>, possibly by fetching it from the <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code>sys.path_importer_cache</code></a> dict. If it wasn’t yet cached, traverse <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code>sys.path_hooks</code></a> until a hook is found that can handle the path item. Return <code>None</code> if no hook could; this tells our caller that the <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> could not find a finder for this path item. Cache the result in <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code>sys.path_importer_cache</code></a>. Return a new reference to the finder object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ImportFrozenModuleObject">
<code>int PyImport_ImportFrozenModuleObject(PyObject *name)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Load a frozen module named <em>name</em>. Return <code>1</code> for success, <code>0</code> if the module is not found, and <code>-1</code> with an exception set if the initialization failed. To access the imported module on a successful load, use <a class="reference internal" href="#c.PyImport_ImportModule" title="PyImport_ImportModule"><code>PyImport_ImportModule()</code></a>. (Note the misnomer — this function would reload the module if it was already imported.)</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The <code>__file__</code> attribute is no longer set on the module.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ImportFrozenModule">
<code>int PyImport_ImportFrozenModule(const char *name)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Similar to <a class="reference internal" href="#c.PyImport_ImportFrozenModuleObject" title="PyImport_ImportFrozenModuleObject"><code>PyImport_ImportFrozenModuleObject()</code></a>, but the name is a UTF-8 encoded string instead of a Unicode object.</p> </dd>
</dl> <dl class="c struct"> <dt class="sig sig-object c" id="c._frozen">
<code>struct _frozen</code> </dt> <dd>
<p id="index-4">This is the structure type definition for frozen module descriptors, as generated by the <strong class="program">freeze</strong> utility (see <code>Tools/freeze/</code> in the Python source distribution). Its definition, found in <code>Include/import.h</code>, is:</p> <pre data-language="c">struct _frozen {
    const char *name;
    const unsigned char *code;
    int size;
    bool is_package;
};
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>The new <code>is_package</code> field indicates whether the module is a package or not. This replaces setting the <code>size</code> field to a negative value.</p> </div> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyImport_FrozenModules">
<code>const struct _frozen *PyImport_FrozenModules</code> </dt> <dd>
<p>This pointer is initialized to point to an array of <a class="reference internal" href="#c._frozen" title="_frozen"><code>_frozen</code></a> records, terminated by one whose members are all <code>NULL</code> or zero. When a frozen module is imported, it is searched in this table. Third-party code could play tricks with this to provide a dynamically created collection of frozen modules.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_AppendInittab">
<code>int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Add a single module to the existing table of built-in modules. This is a convenience wrapper around <a class="reference internal" href="#c.PyImport_ExtendInittab" title="PyImport_ExtendInittab"><code>PyImport_ExtendInittab()</code></a>, returning <code>-1</code> if the table could not be extended. The new module can be imported by the name <em>name</em>, and uses the function <em>initfunc</em> as the initialization function called on the first attempted import. This should be called before <a class="reference internal" href="init.html#c.Py_Initialize" title="Py_Initialize"><code>Py_Initialize()</code></a>.</p> </dd>
</dl> <dl class="c struct"> <dt class="sig sig-object c" id="c._inittab">
<code>struct _inittab</code> </dt> <dd>
<p>Structure describing a single entry in the list of built-in modules. Programs which embed Python may use an array of these structures in conjunction with <a class="reference internal" href="#c.PyImport_ExtendInittab" title="PyImport_ExtendInittab"><code>PyImport_ExtendInittab()</code></a> to provide additional built-in modules. The structure consists of two members:</p> <dl class="c member"> <dt class="sig sig-object c" id="c._inittab.name">
<code>const char *name</code> </dt> <dd>
<p>The module name, as an ASCII encoded string.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c._inittab.initfunc">
<code>PyObject *(*initfunc)(void)</code> </dt> <dd>
<p>Initialization function for a module built into the interpreter.</p> </dd>
</dl> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyImport_ExtendInittab">
<code>int PyImport_ExtendInittab(struct _inittab *newtab)</code> </dt> <dd>
<p>Add a collection of modules to the table of built-in modules. The <em>newtab</em> array must end with a sentinel entry which contains <code>NULL</code> for the <a class="reference internal" href="#c._inittab.name" title="_inittab.name"><code>name</code></a> field; failure to provide the sentinel value can result in a memory fault. Returns <code>0</code> on success or <code>-1</code> if insufficient memory could be allocated to extend the internal table. In the event of failure, no modules are added to the internal table. This must be called before <a class="reference internal" href="init.html#c.Py_Initialize" title="Py_Initialize"><code>Py_Initialize()</code></a>.</p> <p>If Python is initialized multiple times, <a class="reference internal" href="#c.PyImport_AppendInittab" title="PyImport_AppendInittab"><code>PyImport_AppendInittab()</code></a> or <a class="reference internal" href="#c.PyImport_ExtendInittab" title="PyImport_ExtendInittab"><code>PyImport_ExtendInittab()</code></a> must be called before each Python initialization.</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/import.html" class="_attribution-link">https://docs.python.org/3.13/c-api/import.html</a>
  </p>
</div>
