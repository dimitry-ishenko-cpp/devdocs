 <span id="longobjects"></span><h1>Integer Objects</h1> <p id="index-0">All integers are implemented as “long” integer objects of arbitrary size.</p> <p>On error, most <code>PyLong_As*</code> APIs return <code>(return type)-1</code> which cannot be distinguished from a number. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyLongObject">
<code>type PyLongObject</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Limited API</span></a> (as an opaque struct).</em><p>This subtype of <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> represents a Python integer object.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyLong_Type">
<code>PyTypeObject PyLong_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This instance of <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> represents the Python integer type. This is the same object as <a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a> in the Python layer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_Check">
<code>int PyLong_Check(PyObject *p)</code> </dt> <dd>
<p>Return true if its argument is a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> or a subtype of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_CheckExact">
<code>int PyLong_CheckExact(PyObject *p)</code> </dt> <dd>
<p>Return true if its argument is a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, but not a subtype of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromLong">
<code>PyObject *PyLong_FromLong(long v)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from <em>v</em>, or <code>NULL</code> on failure.</p> <p>The current implementation keeps an array of integer objects for all integers between <code>-5</code> and <code>256</code>. When you create an int in that range you actually just get back a reference to the existing object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromUnsignedLong">
<code>PyObject *PyLong_FromUnsignedLong(unsigned long v)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from a C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromSsize_t">
<code>PyObject *PyLong_FromSsize_t(Py_ssize_t v)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from a C <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromSize_t">
<code>PyObject *PyLong_FromSize_t(size_t v)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from a C <code>size_t</code>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromLongLong">
<code>PyObject *PyLong_FromLongLong(long long v)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from a C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromUnsignedLongLong">
<code>PyObject *PyLong_FromUnsignedLongLong(unsigned long long v)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from a C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromDouble">
<code>PyObject *PyLong_FromDouble(double v)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> object from the integer part of <em>v</em>, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromString">
<code>PyObject *PyLong_FromString(const char *str, char **pend, int base)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> based on the string value in <em>str</em>, which is interpreted according to the radix in <em>base</em>, or <code>NULL</code> on failure. If <em>pend</em> is non-<code>NULL</code>, <em>*pend</em> will point to the end of <em>str</em> on success or to the first character that could not be processed on error. If <em>base</em> is <code>0</code>, <em>str</em> is interpreted using the <a class="reference internal" href="../reference/lexical_analysis.html#integers"><span class="std std-ref">Integer literals</span></a> definition; in this case, leading zeros in a non-zero decimal number raises a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>. If <em>base</em> is not <code>0</code>, it must be between <code>2</code> and <code>36</code>, inclusive. Leading and trailing whitespace and single underscores after a base specifier and between digits are ignored. If there are no digits or <em>str</em> is not NULL-terminated following the digits and trailing whitespace, <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> will be raised.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>Python methods <a class="reference internal" href="../library/stdtypes.html#int.to_bytes" title="int.to_bytes"><code>int.to_bytes()</code></a> and <a class="reference internal" href="../library/stdtypes.html#int.from_bytes" title="int.from_bytes"><code>int.from_bytes()</code></a> to convert a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a> to/from an array of bytes in base <code>256</code>. You can call those from C using <a class="reference internal" href="call.html#c.PyObject_CallMethod" title="PyObject_CallMethod"><code>PyObject_CallMethod()</code></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromUnicodeObject">
<code>PyObject *PyLong_FromUnicodeObject(PyObject *u, int base)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><p>Convert a sequence of Unicode digits in the string <em>u</em> to a Python integer value.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromVoidPtr">
<code>PyObject *PyLong_FromVoidPtr(void *p)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Python integer from the pointer <em>p</em>. The pointer value can be retrieved from the resulting value using <a class="reference internal" href="#c.PyLong_AsVoidPtr" title="PyLong_AsVoidPtr"><code>PyLong_AsVoidPtr()</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromNativeBytes">
<code>PyObject *PyLong_FromNativeBytes(const void *buffer, size_t n_bytes, int flags)</code> </dt> <dd>
<p>Create a Python integer from the value contained in the first <em>n_bytes</em> of <em>buffer</em>, interpreted as a two’s-complement signed number.</p> <p><em>flags</em> are as for <a class="reference internal" href="#c.PyLong_AsNativeBytes" title="PyLong_AsNativeBytes"><code>PyLong_AsNativeBytes()</code></a>. Passing <code>-1</code> will select the native endian that CPython was compiled with and assume that the most-significant bit is a sign bit. Passing <code>Py_ASNATIVEBYTES_UNSIGNED_BUFFER</code> will produce the same result as calling <a class="reference internal" href="#c.PyLong_FromUnsignedNativeBytes" title="PyLong_FromUnsignedNativeBytes"><code>PyLong_FromUnsignedNativeBytes()</code></a>. Other flags are ignored.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_FromUnsignedNativeBytes">
<code>PyObject *PyLong_FromUnsignedNativeBytes(const void *buffer, size_t n_bytes, int flags)</code> </dt> <dd>
<p>Create a Python integer from the value contained in the first <em>n_bytes</em> of <em>buffer</em>, interpreted as an unsigned number.</p> <p><em>flags</em> are as for <a class="reference internal" href="#c.PyLong_AsNativeBytes" title="PyLong_AsNativeBytes"><code>PyLong_AsNativeBytes()</code></a>. Passing <code>-1</code> will select the native endian that CPython was compiled with and assume that the most-significant bit is not a sign bit. Flags other than endian are ignored.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsLong">
<code>long PyLong_AsLong(PyObject *obj)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-1">Return a C <span class="c-expr sig sig-inline c"><span class="kt">long</span></span> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>obj</em> is out of range for a <span class="c-expr sig sig-inline c"><span class="kt">long</span></span>.</p> <p>Returns <code>-1</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>This function will no longer use <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code>__int__()</code></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsInt">
<code>int PyLong_AsInt(PyObject *obj)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Similar to <a class="reference internal" href="#c.PyLong_AsLong" title="PyLong_AsLong"><code>PyLong_AsLong()</code></a>, but store the result in a C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> instead of a C <span class="c-expr sig sig-inline c"><span class="kt">long</span></span>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsLongAndOverflow">
<code>long PyLong_AsLongAndOverflow(PyObject *obj, int *overflow)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a C <span class="c-expr sig sig-inline c"><span class="kt">long</span></span> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>If the value of <em>obj</em> is greater than <code>LONG_MAX</code> or less than <code>LONG_MIN</code>, set <em>*overflow</em> to <code>1</code> or <code>-1</code>, respectively, and return <code>-1</code>; otherwise, set <em>*overflow</em> to <code>0</code>. If any other exception occurs set <em>*overflow</em> to <code>0</code> and return <code>-1</code> as usual.</p> <p>Returns <code>-1</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>This function will no longer use <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code>__int__()</code></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsLongLong">
<code>long long PyLong_AsLongLong(PyObject *obj)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-2">Return a C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>obj</em> is out of range for a <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>.</p> <p>Returns <code>-1</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>This function will no longer use <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code>__int__()</code></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsLongLongAndOverflow">
<code>long long PyLong_AsLongLongAndOverflow(PyObject *obj, int *overflow)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>If the value of <em>obj</em> is greater than <code>LLONG_MAX</code> or less than <code>LLONG_MIN</code>, set <em>*overflow</em> to <code>1</code> or <code>-1</code>, respectively, and return <code>-1</code>; otherwise, set <em>*overflow</em> to <code>0</code>. If any other exception occurs set <em>*overflow</em> to <code>0</code> and return <code>-1</code> as usual.</p> <p>Returns <code>-1</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>This function will no longer use <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code>__int__()</code></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsSsize_t">
<code>Py_ssize_t PyLong_AsSsize_t(PyObject *pylong)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-3">Return a C <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a> representation of <em>pylong</em>. <em>pylong</em> must be an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>pylong</em> is out of range for a <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a>.</p> <p>Returns <code>-1</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsUnsignedLong">
<code>unsigned long PyLong_AsUnsignedLong(PyObject *pylong)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-4">Return a C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span> representation of <em>pylong</em>. <em>pylong</em> must be an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>pylong</em> is out of range for a <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span>.</p> <p>Returns <code>(unsigned long)-1</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsSize_t">
<code>size_t PyLong_AsSize_t(PyObject *pylong)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-5">Return a C <code>size_t</code> representation of <em>pylong</em>. <em>pylong</em> must be an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>pylong</em> is out of range for a <code>size_t</code>.</p> <p>Returns <code>(size_t)-1</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsUnsignedLongLong">
<code>unsigned long long PyLong_AsUnsignedLongLong(PyObject *pylong)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-6">Return a C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> representation of <em>pylong</em>. <em>pylong</em> must be an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>pylong</em> is out of range for an <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>.</p> <p>Returns <code>(unsigned long long)-1</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.1: </span>A negative <em>pylong</em> now raises <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>, not <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsUnsignedLongMask">
<code>unsigned long PyLong_AsUnsignedLongMask(PyObject *obj)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>If the value of <em>obj</em> is out of range for an <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span>, return the reduction of that value modulo <code>ULONG_MAX + 1</code>.</p> <p>Returns <code>(unsigned long)-1</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>This function will no longer use <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code>__int__()</code></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsUnsignedLongLongMask">
<code>unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *obj)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> representation of <em>obj</em>. If <em>obj</em> is not an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>, first call its <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> method (if present) to convert it to a <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>If the value of <em>obj</em> is out of range for an <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>, return the reduction of that value modulo <code>ULLONG_MAX + 1</code>.</p> <p>Returns <code>(unsigned long long)-1</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> if available.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>This function will no longer use <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code>__int__()</code></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsDouble">
<code>double PyLong_AsDouble(PyObject *pylong)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> representation of <em>pylong</em>. <em>pylong</em> must be an instance of <a class="reference internal" href="#c.PyLongObject" title="PyLongObject"><code>PyLongObject</code></a>.</p> <p>Raise <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a> if the value of <em>pylong</em> is out of range for a <span class="c-expr sig sig-inline c"><span class="kt">double</span></span>.</p> <p>Returns <code>-1.0</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsVoidPtr">
<code>void *PyLong_AsVoidPtr(PyObject *pylong)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Convert a Python integer <em>pylong</em> to a C <span class="c-expr sig sig-inline c"><span class="kt">void</span></span> pointer. If <em>pylong</em> cannot be converted, an <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a> will be raised. This is only assured to produce a usable <span class="c-expr sig sig-inline c"><span class="kt">void</span></span> pointer for values created with <a class="reference internal" href="#c.PyLong_FromVoidPtr" title="PyLong_FromVoidPtr"><code>PyLong_FromVoidPtr()</code></a>.</p> <p>Returns <code>NULL</code> on error. Use <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to disambiguate.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_AsNativeBytes">
<code>Py_ssize_t PyLong_AsNativeBytes(PyObject *pylong, void *buffer, Py_ssize_t n_bytes, int flags)</code> </dt> <dd>
<p>Copy the Python integer value <em>pylong</em> to a native <em>buffer</em> of size <em>n_bytes</em>. The <em>flags</em> can be set to <code>-1</code> to behave similarly to a C cast, or to values documented below to control the behavior.</p> <p>Returns <code>-1</code> with an exception raised on error. This may happen if <em>pylong</em> cannot be interpreted as an integer, or if <em>pylong</em> was negative and the <code>Py_ASNATIVEBYTES_REJECT_NEGATIVE</code> flag was set.</p> <p>Otherwise, returns the number of bytes required to store the value. If this is equal to or less than <em>n_bytes</em>, the entire value was copied. All <em>n_bytes</em> of the buffer are written: large buffers are padded with zeroes.</p> <p>If the returned value is greater than than <em>n_bytes</em>, the value was truncated: as many of the lowest bits of the value as could fit are written, and the higher bits are ignored. This matches the typical behavior of a C-style downcast.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Overflow is not considered an error. If the returned value is larger than <em>n_bytes</em>, most significant bits were discarded.</p> </div> <p><code>0</code> will never be returned.</p> <p>Values are always copied as two’s-complement.</p> <p>Usage example:</p> <pre data-language="c">int32_t value;
Py_ssize_t bytes = PyLong_AsNativeBytes(pylong, &amp;value, sizeof(value), -1);
if (bytes &lt; 0) {
    // Failed. A Python exception was set with the reason.
    return NULL;
}
else if (bytes &lt;= (Py_ssize_t)sizeof(value)) {
    // Success!
}
else {
    // Overflow occurred, but 'value' contains the truncated
    // lowest bits of pylong.
}
</pre> <p>Passing zero to <em>n_bytes</em> will return the size of a buffer that would be large enough to hold the value. This may be larger than technically necessary, but not unreasonably so. If <em>n_bytes=0</em>, <em>buffer</em> may be <code>NULL</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Passing <em>n_bytes=0</em> to this function is not an accurate way to determine the bit length of the value.</p> </div> <p>To get at the entire Python value of an unknown size, the function can be called twice: first to determine the buffer size, then to fill it:</p> <pre data-language="c">// Ask how much space we need.
Py_ssize_t expected = PyLong_AsNativeBytes(pylong, NULL, 0, -1);
if (expected &lt; 0) {
    // Failed. A Python exception was set with the reason.
    return NULL;
}
assert(expected != 0);  // Impossible per the API definition.
uint8_t *bignum = malloc(expected);
if (!bignum) {
    PyErr_SetString(PyExc_MemoryError, "bignum malloc failed.");
    return NULL;
}
// Safely get the entire value.
Py_ssize_t bytes = PyLong_AsNativeBytes(pylong, bignum, expected, -1);
if (bytes &lt; 0) {  // Exception has been set.
    free(bignum);
    return NULL;
}
else if (bytes &gt; expected) {  // This should not be possible.
    PyErr_SetString(PyExc_RuntimeError,
        "Unexpected bignum truncation after a size check.");
    free(bignum);
    return NULL;
}
// The expected success given the above pre-check.
// ... use bignum ...
free(bignum);
</pre> <p><em>flags</em> is either <code>-1</code> (<code>Py_ASNATIVEBYTES_DEFAULTS</code>) to select defaults that behave most like a C cast, or a combintation of the other flags in the table below. Note that <code>-1</code> cannot be combined with other flags.</p> <p>Currently, <code>-1</code> corresponds to <code>Py_ASNATIVEBYTES_NATIVE_ENDIAN | Py_ASNATIVEBYTES_UNSIGNED_BUFFER</code>.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Flag</p></th> <th class="head"><p>Value</p></th> </tr> </thead>  <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyLong_AsNativeBytes.Py_ASNATIVEBYTES_DEFAULTS">
<code>Py_ASNATIVEBYTES_DEFAULTS</code> </dt> <dd></dd>
</dl> </td> <td><p><code>-1</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyLong_AsNativeBytes.Py_ASNATIVEBYTES_BIG_ENDIAN">
<code>Py_ASNATIVEBYTES_BIG_ENDIAN</code> </dt> <dd></dd>
</dl> </td> <td><p><code>0</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyLong_AsNativeBytes.Py_ASNATIVEBYTES_LITTLE_ENDIAN">
<code>Py_ASNATIVEBYTES_LITTLE_ENDIAN</code> </dt> <dd></dd>
</dl> </td> <td><p><code>1</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyLong_AsNativeBytes.Py_ASNATIVEBYTES_NATIVE_ENDIAN">
<code>Py_ASNATIVEBYTES_NATIVE_ENDIAN</code> </dt> <dd></dd>
</dl> </td> <td><p><code>3</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyLong_AsNativeBytes.Py_ASNATIVEBYTES_UNSIGNED_BUFFER">
<code>Py_ASNATIVEBYTES_UNSIGNED_BUFFER</code> </dt> <dd></dd>
</dl> </td> <td><p><code>4</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyLong_AsNativeBytes.Py_ASNATIVEBYTES_REJECT_NEGATIVE">
<code>Py_ASNATIVEBYTES_REJECT_NEGATIVE</code> </dt> <dd></dd>
</dl> </td> <td><p><code>8</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyLong_AsNativeBytes.Py_ASNATIVEBYTES_ALLOW_INDEX">
<code>Py_ASNATIVEBYTES_ALLOW_INDEX</code> </dt> <dd></dd>
</dl> </td> <td><p><code>16</code></p></td> </tr>  </table> <p>Specifying <code>Py_ASNATIVEBYTES_NATIVE_ENDIAN</code> will override any other endian flags. Passing <code>2</code> is reserved.</p> <p>By default, sufficient buffer will be requested to include a sign bit. For example, when converting 128 with <em>n_bytes=1</em>, the function will return 2 (or more) in order to store a zero sign bit.</p> <p>If <code>Py_ASNATIVEBYTES_UNSIGNED_BUFFER</code> is specified, a zero sign bit will be omitted from size calculations. This allows, for example, 128 to fit in a single-byte buffer. If the destination buffer is later treated as signed, a positive input value may become negative. Note that the flag does not affect handling of negative values: for those, space for a sign bit is always requested.</p> <p>Specifying <code>Py_ASNATIVEBYTES_REJECT_NEGATIVE</code> causes an exception to be set if <em>pylong</em> is negative. Without this flag, negative values will be copied provided there is enough space for at least one sign bit, regardless of whether <code>Py_ASNATIVEBYTES_UNSIGNED_BUFFER</code> was specified.</p> <p>If <code>Py_ASNATIVEBYTES_ALLOW_INDEX</code> is specified and a non-integer value is passed, its <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> method will be called first. This may result in Python code executing and other threads being allowed to run, which could cause changes to other objects or values in use. When <em>flags</em> is <code>-1</code>, this option is not set, and non-integer values will raise <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>With the default <em>flags</em> (<code>-1</code>, or <em>UNSIGNED_BUFFER</em> without <em>REJECT_NEGATIVE</em>), multiple Python integers can map to a single value without overflow. For example, both <code>255</code> and <code>-1</code> fit a single-byte buffer and set all its bits. This matches typical C cast behavior.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyLong_GetInfo">
<code>PyObject *PyLong_GetInfo(void)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>On success, return a read only <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>, that holds information about Python’s internal representation of integers. See <a class="reference internal" href="../library/sys.html#sys.int_info" title="sys.int_info"><code>sys.int_info</code></a> for description of individual fields.</p> <p>On failure, return <code>NULL</code> with an exception set.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.1.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnstable_Long_IsCompact">
<code>int PyUnstable_Long_IsCompact(const PyLongObject *op)</code> </dt> <dd>
<div class="unstable-c-api warning admonition"> <em>This is <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable API</span></a>. It may change without warning in minor releases.</em>
</div> <p>Return 1 if <em>op</em> is compact, 0 otherwise.</p> <p>This function makes it possible for performance-critical code to implement a “fast path” for small integers. For compact values use <a class="reference internal" href="#c.PyUnstable_Long_CompactValue" title="PyUnstable_Long_CompactValue"><code>PyUnstable_Long_CompactValue()</code></a>; for others fall back to a <a class="reference internal" href="#c.PyLong_AsSize_t" title="PyLong_AsSize_t"><code>PyLong_As*</code></a> function or <a class="reference internal" href="#c.PyLong_AsNativeBytes" title="PyLong_AsNativeBytes"><code>PyLong_AsNativeBytes()</code></a>.</p> <p>The speedup is expected to be negligible for most users.</p> <p>Exactly what values are considered compact is an implementation detail and is subject to change.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnstable_Long_CompactValue">
<code>Py_ssize_t PyUnstable_Long_CompactValue(const PyLongObject *op)</code> </dt> <dd>
<div class="unstable-c-api warning admonition"> <em>This is <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable API</span></a>. It may change without warning in minor releases.</em>
</div> <p>If <em>op</em> is compact, as determined by <a class="reference internal" href="#c.PyUnstable_Long_IsCompact" title="PyUnstable_Long_IsCompact"><code>PyUnstable_Long_IsCompact()</code></a>, return its value.</p> <p>Otherwise, the return value is undefined.</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/long.html" class="_attribution-link">https://docs.python.org/3.13/c-api/long.html</a>
  </p>
</div>
