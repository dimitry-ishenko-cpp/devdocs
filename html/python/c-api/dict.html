 <span id="dictobjects"></span><h1>Dictionary Objects</h1> <dl class="c type" id="index-0"> <dt class="sig sig-object c" id="c.PyDictObject">
<code>type PyDictObject</code> </dt> <dd>
<p>This subtype of <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> represents a Python dictionary object.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyDict_Type">
<code>PyTypeObject PyDict_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This instance of <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> represents the Python dictionary type. This is the same object as <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code>dict</code></a> in the Python layer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Check">
<code>int PyDict_Check(PyObject *p)</code> </dt> <dd>
<p>Return true if <em>p</em> is a dict object or an instance of a subtype of the dict type. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_CheckExact">
<code>int PyDict_CheckExact(PyObject *p)</code> </dt> <dd>
<p>Return true if <em>p</em> is a dict object, but not an instance of a subtype of the dict type. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_New">
<code>PyObject *PyDict_New()</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new empty dictionary, or <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDictProxy_New">
<code>PyObject *PyDictProxy_New(PyObject *mapping)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a <a class="reference internal" href="../library/types.html#types.MappingProxyType" title="types.MappingProxyType"><code>types.MappingProxyType</code></a> object for a mapping which enforces read-only behavior. This is normally used to create a view to prevent modification of the dictionary for non-dynamic class types.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Clear">
<code>void PyDict_Clear(PyObject *p)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Empty an existing dictionary of all key-value pairs.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Contains">
<code>int PyDict_Contains(PyObject *p, PyObject *key)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Determine if dictionary <em>p</em> contains <em>key</em>. If an item in <em>p</em> is matches <em>key</em>, return <code>1</code>, otherwise return <code>0</code>. On error, return <code>-1</code>. This is equivalent to the Python expression <code>key in p</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_ContainsString">
<code>int PyDict_ContainsString(PyObject *p, const char *key)</code> </dt> <dd>
<p>This is the same as <a class="reference internal" href="#c.PyDict_Contains" title="PyDict_Contains"><code>PyDict_Contains()</code></a>, but <em>key</em> is specified as a <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> UTF-8 encoded bytes string, rather than a <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Copy">
<code>PyObject *PyDict_Copy(PyObject *p)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new dictionary that contains the same key-value pairs as <em>p</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_SetItem">
<code>int PyDict_SetItem(PyObject *p, PyObject *key, PyObject *val)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Insert <em>val</em> into the dictionary <em>p</em> with a key of <em>key</em>. <em>key</em> must be <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>; if it isn’t, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> will be raised. Return <code>0</code> on success or <code>-1</code> on failure. This function <em>does not</em> steal a reference to <em>val</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_SetItemString">
<code>int PyDict_SetItemString(PyObject *p, const char *key, PyObject *val)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is the same as <a class="reference internal" href="#c.PyDict_SetItem" title="PyDict_SetItem"><code>PyDict_SetItem()</code></a>, but <em>key</em> is specified as a <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> UTF-8 encoded bytes string, rather than a <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_DelItem">
<code>int PyDict_DelItem(PyObject *p, PyObject *key)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Remove the entry in dictionary <em>p</em> with key <em>key</em>. <em>key</em> must be <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>; if it isn’t, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> is raised. If <em>key</em> is not in the dictionary, <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> is raised. Return <code>0</code> on success or <code>-1</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_DelItemString">
<code>int PyDict_DelItemString(PyObject *p, const char *key)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is the same as <a class="reference internal" href="#c.PyDict_DelItem" title="PyDict_DelItem"><code>PyDict_DelItem()</code></a>, but <em>key</em> is specified as a <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> UTF-8 encoded bytes string, rather than a <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_GetItemRef">
<code>int PyDict_GetItemRef(PyObject *p, PyObject *key, PyObject **result)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Return a new <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to the object from dictionary <em>p</em> which has a key <em>key</em>:</p> <ul class="simple"> <li>If the key is present, set <em>*result</em> to a new <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to the value and return <code>1</code>.</li> <li>If the key is missing, set <em>*result</em> to <code>NULL</code> and return <code>0</code>.</li> <li>On error, raise an exception and return <code>-1</code>.</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> <p>See also the <a class="reference internal" href="object.html#c.PyObject_GetItem" title="PyObject_GetItem"><code>PyObject_GetItem()</code></a> function.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_GetItem">
<code>PyObject *PyDict_GetItem(PyObject *p, PyObject *key)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a <a class="reference internal" href="../glossary.html#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a> to the object from dictionary <em>p</em> which has a key <em>key</em>. Return <code>NULL</code> if the key <em>key</em> is missing <em>without</em> setting an exception.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Exceptions that occur while this calls <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code>__eq__()</code></a> methods are silently ignored. Prefer the <a class="reference internal" href="#c.PyDict_GetItemWithError" title="PyDict_GetItemWithError"><code>PyDict_GetItemWithError()</code></a> function instead.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>Calling this API without <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> held had been allowed for historical reason. It is no longer allowed.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_GetItemWithError">
<code>PyObject *PyDict_GetItemWithError(PyObject *p, PyObject *key)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Variant of <a class="reference internal" href="#c.PyDict_GetItem" title="PyDict_GetItem"><code>PyDict_GetItem()</code></a> that does not suppress exceptions. Return <code>NULL</code> <strong>with</strong> an exception set if an exception occurred. Return <code>NULL</code> <strong>without</strong> an exception set if the key wasn’t present.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_GetItemString">
<code>PyObject *PyDict_GetItemString(PyObject *p, const char *key)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is the same as <a class="reference internal" href="#c.PyDict_GetItem" title="PyDict_GetItem"><code>PyDict_GetItem()</code></a>, but <em>key</em> is specified as a <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> UTF-8 encoded bytes string, rather than a <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Exceptions that occur while this calls <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code>__eq__()</code></a> methods or while creating the temporary <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> object are silently ignored. Prefer using the <a class="reference internal" href="#c.PyDict_GetItemWithError" title="PyDict_GetItemWithError"><code>PyDict_GetItemWithError()</code></a> function with your own <a class="reference internal" href="unicode.html#c.PyUnicode_FromString" title="PyUnicode_FromString"><code>PyUnicode_FromString()</code></a> <em>key</em> instead.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_GetItemStringRef">
<code>int PyDict_GetItemStringRef(PyObject *p, const char *key, PyObject **result)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Similar than <a class="reference internal" href="#c.PyDict_GetItemRef" title="PyDict_GetItemRef"><code>PyDict_GetItemRef()</code></a>, but <em>key</em> is specified as a <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> UTF-8 encoded bytes string, rather than a <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_SetDefault">
<code>PyObject *PyDict_SetDefault(PyObject *p, PyObject *key, PyObject *defaultobj)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><p>This is the same as the Python-level <a class="reference internal" href="../library/stdtypes.html#dict.setdefault" title="dict.setdefault"><code>dict.setdefault()</code></a>. If present, it returns the value corresponding to <em>key</em> from the dictionary <em>p</em>. If the key is not in the dict, it is inserted with value <em>defaultobj</em> and <em>defaultobj</em> is returned. This function evaluates the hash function of <em>key</em> only once, instead of evaluating it independently for the lookup and the insertion.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_SetDefaultRef">
<code>int PyDict_SetDefaultRef(PyObject *p, PyObject *key, PyObject *default_value, PyObject **result)</code> </dt> <dd>
<p>Inserts <em>default_value</em> into the dictionary <em>p</em> with a key of <em>key</em> if the key is not already present in the dictionary. If <em>result</em> is not <code>NULL</code>, then <em>*result</em> is set to a <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to either <em>default_value</em>, if the key was not present, or the existing value, if <em>key</em> was already present in the dictionary. Returns <code>1</code> if the key was present and <em>default_value</em> was not inserted, or <code>0</code> if the key was not present and <em>default_value</em> was inserted. On failure, returns <code>-1</code>, sets an exception, and sets <code>*result</code> to <code>NULL</code>.</p> <p>For clarity: if you have a strong reference to <em>default_value</em> before calling this function, then after it returns, you hold a strong reference to both <em>default_value</em> and <em>*result</em> (if it’s not <code>NULL</code>). These may refer to the same object: in that case you hold two separate references to it.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Pop">
<code>int PyDict_Pop(PyObject *p, PyObject *key, PyObject **result)</code> </dt> <dd>
<p>Remove <em>key</em> from dictionary <em>p</em> and optionally return the removed value. Do not raise <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> if the key missing.</p> <ul class="simple"> <li>If the key is present, set <em>*result</em> to a new reference to the removed value if <em>result</em> is not <code>NULL</code>, and return <code>1</code>.</li> <li>If the key is missing, set <em>*result</em> to <code>NULL</code> if <em>result</em> is not <code>NULL</code>, and return <code>0</code>.</li> <li>On error, raise an exception and return <code>-1</code>.</li> </ul> <p>This is similar to <a class="reference internal" href="../library/stdtypes.html#dict.pop" title="dict.pop"><code>dict.pop()</code></a>, but without the default value and not raising <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> if the key missing.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_PopString">
<code>int PyDict_PopString(PyObject *p, const char *key, PyObject **result)</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#c.PyDict_Pop" title="PyDict_Pop"><code>PyDict_Pop()</code></a>, but <em>key</em> is specified as a <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> UTF-8 encoded bytes string, rather than a <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Items">
<code>PyObject *PyDict_Items(PyObject *p)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a <a class="reference internal" href="list.html#c.PyListObject" title="PyListObject"><code>PyListObject</code></a> containing all the items from the dictionary.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Keys">
<code>PyObject *PyDict_Keys(PyObject *p)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a <a class="reference internal" href="list.html#c.PyListObject" title="PyListObject"><code>PyListObject</code></a> containing all the keys from the dictionary.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Values">
<code>PyObject *PyDict_Values(PyObject *p)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a <a class="reference internal" href="list.html#c.PyListObject" title="PyListObject"><code>PyListObject</code></a> containing all the values from the dictionary <em>p</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Size">
<code>Py_ssize_t PyDict_Size(PyObject *p)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-1">Return the number of items in the dictionary. This is equivalent to <code>len(p)</code> on a dictionary.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Next">
<code>int PyDict_Next(PyObject *p, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Iterate over all key-value pairs in the dictionary <em>p</em>. The <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a> referred to by <em>ppos</em> must be initialized to <code>0</code> prior to the first call to this function to start the iteration; the function returns true for each pair in the dictionary, and false once all pairs have been reported. The parameters <em>pkey</em> and <em>pvalue</em> should either point to <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> variables that will be filled in with each key and value, respectively, or may be <code>NULL</code>. Any references returned through them are borrowed. <em>ppos</em> should not be altered during iteration. Its value represents offsets within the internal dictionary structure, and since the structure is sparse, the offsets are not consecutive.</p> <p>For example:</p> <pre data-language="c">PyObject *key, *value;
Py_ssize_t pos = 0;

while (PyDict_Next(self-&gt;dict, &amp;pos, &amp;key, &amp;value)) {
    /* do something interesting with the values... */
    ...
}
</pre> <p>The dictionary <em>p</em> should not be mutated during iteration. It is safe to modify the values of the keys as you iterate over the dictionary, but only so long as the set of keys does not change. For example:</p> <pre data-language="c">PyObject *key, *value;
Py_ssize_t pos = 0;

while (PyDict_Next(self-&gt;dict, &amp;pos, &amp;key, &amp;value)) {
    long i = PyLong_AsLong(value);
    if (i == -1 &amp;&amp; PyErr_Occurred()) {
        return -1;
    }
    PyObject *o = PyLong_FromLong(i + 1);
    if (o == NULL)
        return -1;
    if (PyDict_SetItem(self-&gt;dict, key, o) &lt; 0) {
        Py_DECREF(o);
        return -1;
    }
    Py_DECREF(o);
}
</pre> <p>The function is not thread-safe in the <a class="reference internal" href="../glossary.html#term-free-threading"><span class="xref std std-term">free-threaded</span></a> build without external synchronization. You can use <a class="reference internal" href="init.html#c.Py_BEGIN_CRITICAL_SECTION" title="Py_BEGIN_CRITICAL_SECTION"><code>Py_BEGIN_CRITICAL_SECTION</code></a> to lock the dictionary while iterating over it:</p> <pre data-language="c">Py_BEGIN_CRITICAL_SECTION(self-&gt;dict);
while (PyDict_Next(self-&gt;dict, &amp;pos, &amp;key, &amp;value)) {
    ...
}
Py_END_CRITICAL_SECTION();
</pre> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Merge">
<code>int PyDict_Merge(PyObject *a, PyObject *b, int override)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Iterate over mapping object <em>b</em> adding key-value pairs to dictionary <em>a</em>. <em>b</em> may be a dictionary, or any object supporting <a class="reference internal" href="mapping.html#c.PyMapping_Keys" title="PyMapping_Keys"><code>PyMapping_Keys()</code></a> and <a class="reference internal" href="object.html#c.PyObject_GetItem" title="PyObject_GetItem"><code>PyObject_GetItem()</code></a>. If <em>override</em> is true, existing pairs in <em>a</em> will be replaced if a matching key is found in <em>b</em>, otherwise pairs will only be added if there is not a matching key in <em>a</em>. Return <code>0</code> on success or <code>-1</code> if an exception was raised.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Update">
<code>int PyDict_Update(PyObject *a, PyObject *b)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is the same as <code>PyDict_Merge(a, b, 1)</code> in C, and is similar to <code>a.update(b)</code> in Python except that <a class="reference internal" href="#c.PyDict_Update" title="PyDict_Update"><code>PyDict_Update()</code></a> doesn’t fall back to the iterating over a sequence of key value pairs if the second argument has no “keys” attribute. Return <code>0</code> on success or <code>-1</code> if an exception was raised.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_MergeFromSeq2">
<code>int PyDict_MergeFromSeq2(PyObject *a, PyObject *seq2, int override)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Update or merge into dictionary <em>a</em>, from the key-value pairs in <em>seq2</em>. <em>seq2</em> must be an iterable object producing iterable objects of length 2, viewed as key-value pairs. In case of duplicate keys, the last wins if <em>override</em> is true, else the first wins. Return <code>0</code> on success or <code>-1</code> if an exception was raised. Equivalent Python (except for the return value):</p> <pre data-language="c">def PyDict_MergeFromSeq2(a, seq2, override):
    for key, value in seq2:
        if override or key not in a:
            a[key] = value
</pre> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_AddWatcher">
<code>int PyDict_AddWatcher(PyDict_WatchCallback callback)</code> </dt> <dd>
<p>Register <em>callback</em> as a dictionary watcher. Return a non-negative integer id which must be passed to future calls to <a class="reference internal" href="#c.PyDict_Watch" title="PyDict_Watch"><code>PyDict_Watch()</code></a>. In case of error (e.g. no more watcher IDs available), return <code>-1</code> and set an exception.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_ClearWatcher">
<code>int PyDict_ClearWatcher(int watcher_id)</code> </dt> <dd>
<p>Clear watcher identified by <em>watcher_id</em> previously returned from <a class="reference internal" href="#c.PyDict_AddWatcher" title="PyDict_AddWatcher"><code>PyDict_AddWatcher()</code></a>. Return <code>0</code> on success, <code>-1</code> on error (e.g. if the given <em>watcher_id</em> was never registered.)</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Watch">
<code>int PyDict_Watch(int watcher_id, PyObject *dict)</code> </dt> <dd>
<p>Mark dictionary <em>dict</em> as watched. The callback granted <em>watcher_id</em> by <a class="reference internal" href="#c.PyDict_AddWatcher" title="PyDict_AddWatcher"><code>PyDict_AddWatcher()</code></a> will be called when <em>dict</em> is modified or deallocated. Return <code>0</code> on success or <code>-1</code> on error.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyDict_Unwatch">
<code>int PyDict_Unwatch(int watcher_id, PyObject *dict)</code> </dt> <dd>
<p>Mark dictionary <em>dict</em> as no longer watched. The callback granted <em>watcher_id</em> by <a class="reference internal" href="#c.PyDict_AddWatcher" title="PyDict_AddWatcher"><code>PyDict_AddWatcher()</code></a> will no longer be called when <em>dict</em> is modified or deallocated. The dict must previously have been watched by this watcher. Return <code>0</code> on success or <code>-1</code> on error.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyDict_WatchEvent">
<code>type PyDict_WatchEvent</code> </dt> <dd>
<p>Enumeration of possible dictionary watcher events: <code>PyDict_EVENT_ADDED</code>, <code>PyDict_EVENT_MODIFIED</code>, <code>PyDict_EVENT_DELETED</code>, <code>PyDict_EVENT_CLONED</code>, <code>PyDict_EVENT_CLEARED</code>, or <code>PyDict_EVENT_DEALLOCATED</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyDict_WatchCallback">
<code>typedef int (*PyDict_WatchCallback)(PyDict_WatchEvent event, PyObject *dict, PyObject *key, PyObject *new_value)</code> </dt> <dd>
<p>Type of a dict watcher callback function.</p> <p>If <em>event</em> is <code>PyDict_EVENT_CLEARED</code> or <code>PyDict_EVENT_DEALLOCATED</code>, both <em>key</em> and <em>new_value</em> will be <code>NULL</code>. If <em>event</em> is <code>PyDict_EVENT_ADDED</code> or <code>PyDict_EVENT_MODIFIED</code>, <em>new_value</em> will be the new value for <em>key</em>. If <em>event</em> is <code>PyDict_EVENT_DELETED</code>, <em>key</em> is being deleted from the dictionary and <em>new_value</em> will be <code>NULL</code>.</p> <p><code>PyDict_EVENT_CLONED</code> occurs when <em>dict</em> was previously empty and another dict is merged into it. To maintain efficiency of this operation, per-key <code>PyDict_EVENT_ADDED</code> events are not issued in this case; instead a single <code>PyDict_EVENT_CLONED</code> is issued, and <em>key</em> will be the source dictionary.</p> <p>The callback may inspect but must not modify <em>dict</em>; doing so could have unpredictable effects, including infinite recursion. Do not trigger Python code execution in the callback, as it could modify the dict as a side effect.</p> <p>If <em>event</em> is <code>PyDict_EVENT_DEALLOCATED</code>, taking a new reference in the callback to the about-to-be-destroyed dictionary will resurrect it and prevent it from being freed at this time. When the resurrected object is destroyed later, any watcher callbacks active at that time will be called again.</p> <p>Callbacks occur before the notified modification to <em>dict</em> takes place, so the prior state of <em>dict</em> can be inspected.</p> <p>If the callback sets an exception, it must return <code>-1</code>; this exception will be printed as an unraisable exception using <a class="reference internal" href="exceptions.html#c.PyErr_WriteUnraisable" title="PyErr_WriteUnraisable"><code>PyErr_WriteUnraisable()</code></a>. Otherwise it should return <code>0</code>.</p> <p>There may already be a pending exception set on entry to the callback. In this case, the callback should return <code>0</code> with the same exception still set. This means the callback may not call any other API that can set an exception unless it saves and clears the exception state first, and restores it before returning.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/dict.html" class="_attribution-link">https://docs.python.org/3.13/c-api/dict.html</a>
  </p>
</div>
