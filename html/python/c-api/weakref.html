 <span id="weakrefobjects"></span><h1>Weak Reference Objects</h1> <p>Python supports <em>weak references</em> as first-class objects. There are two specific object types which directly implement weak references. The first is a simple reference object, and the second acts as a proxy for the original object as much as it can.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyWeakref_Check">
<code>int PyWeakref_Check(PyObject *ob)</code> </dt> <dd>
<p>Return non-zero if <em>ob</em> is either a reference or proxy object. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyWeakref_CheckRef">
<code>int PyWeakref_CheckRef(PyObject *ob)</code> </dt> <dd>
<p>Return non-zero if <em>ob</em> is a reference object. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyWeakref_CheckProxy">
<code>int PyWeakref_CheckProxy(PyObject *ob)</code> </dt> <dd>
<p>Return non-zero if <em>ob</em> is a proxy object. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyWeakref_NewRef">
<code>PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a weak reference object for the object <em>ob</em>. This will always return a new reference, but is not guaranteed to create a new object; an existing reference object may be returned. The second parameter, <em>callback</em>, can be a callable object that receives notification when <em>ob</em> is garbage collected; it should accept a single parameter, which will be the weak reference object itself. <em>callback</em> may also be <code>None</code> or <code>NULL</code>. If <em>ob</em> is not a weakly referenceable object, or if <em>callback</em> is not callable, <code>None</code>, or <code>NULL</code>, this will return <code>NULL</code> and raise <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyWeakref_NewProxy">
<code>PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a weak reference proxy object for the object <em>ob</em>. This will always return a new reference, but is not guaranteed to create a new object; an existing proxy object may be returned. The second parameter, <em>callback</em>, can be a callable object that receives notification when <em>ob</em> is garbage collected; it should accept a single parameter, which will be the weak reference object itself. <em>callback</em> may also be <code>None</code> or <code>NULL</code>. If <em>ob</em> is not a weakly referenceable object, or if <em>callback</em> is not callable, <code>None</code>, or <code>NULL</code>, this will return <code>NULL</code> and raise <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyWeakref_GetRef">
<code>int PyWeakref_GetRef(PyObject *ref, PyObject **pobj)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Get a <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to the referenced object from a weak reference, <em>ref</em>, into <em>*pobj</em>.</p> <ul class="simple"> <li>On success, set <em>*pobj</em> to a new <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to the referenced object and return 1.</li> <li>If the reference is dead, set <em>*pobj</em> to <code>NULL</code> and return 0.</li> <li>On error, raise an exception and return -1.</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyWeakref_GetObject">
<code>PyObject *PyWeakref_GetObject(PyObject *ref)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a <a class="reference internal" href="../glossary.html#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a> to the referenced object from a weak reference, <em>ref</em>. If the referent is no longer live, returns <code>Py_None</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function returns a <a class="reference internal" href="../glossary.html#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a> to the referenced object. This means that you should always call <a class="reference internal" href="refcounting.html#c.Py_INCREF" title="Py_INCREF"><code>Py_INCREF()</code></a> on the object except when it cannot be destroyed before the last usage of the borrowed reference.</p> </div> <div class="deprecated-removed"> <p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>Use <a class="reference internal" href="#c.PyWeakref_GetRef" title="PyWeakref_GetRef"><code>PyWeakref_GetRef()</code></a> instead.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyWeakref_GET_OBJECT">
<code>PyObject *PyWeakref_GET_OBJECT(PyObject *ref)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><p>Similar to <a class="reference internal" href="#c.PyWeakref_GetObject" title="PyWeakref_GetObject"><code>PyWeakref_GetObject()</code></a>, but does no error checking.</p> <div class="deprecated-removed"> <p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>Use <a class="reference internal" href="#c.PyWeakref_GetRef" title="PyWeakref_GetRef"><code>PyWeakref_GetRef()</code></a> instead.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_ClearWeakRefs">
<code>void PyObject_ClearWeakRefs(PyObject *object)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This function is called by the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a> handler to clear weak references.</p> <p>This iterates through the weak references for <em>object</em> and calls callbacks for those references which have one. It returns when all callbacks have been attempted.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnstable_Object_ClearWeakRefsNoCallbacks">
<code>void PyUnstable_Object_ClearWeakRefsNoCallbacks(PyObject *object)</code> </dt> <dd>
<div class="unstable-c-api warning admonition"> <em>This is <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable API</span></a>. It may change without warning in minor releases.</em>
</div> <p>Clears the weakrefs for <em>object</em> without calling the callbacks.</p> <p>This function is called by the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a> handler for types with finalizers (i.e., <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code>__del__()</code></a>). The handler for those objects first calls <a class="reference internal" href="#c.PyObject_ClearWeakRefs" title="PyObject_ClearWeakRefs"><code>PyObject_ClearWeakRefs()</code></a> to clear weakrefs and call their callbacks, then the finalizer, and finally this function to clear any weakrefs that may have been created by the finalizer.</p> <p>In most circumstances, itâ€™s more appropriate to use <a class="reference internal" href="#c.PyObject_ClearWeakRefs" title="PyObject_ClearWeakRefs"><code>PyObject_ClearWeakRefs()</code></a> to clear weakrefs instead of this function.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/weakref.html" class="_attribution-link">https://docs.python.org/3.13/c-api/weakref.html</a>
  </p>
</div>
