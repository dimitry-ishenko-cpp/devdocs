 <span id="bufferobjects"></span><span id="index-0"></span><h1>Buffer Protocol</h1> <p>Certain objects available in Python wrap access to an underlying memory array or <em>buffer</em>. Such objects include the built-in <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> and <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a>, and some extension types like <a class="reference internal" href="../library/array.html#array.array" title="array.array"><code>array.array</code></a>. Third-party libraries may define their own types for special purposes, such as image processing or numeric analysis.</p> <p>While each of these types have their own semantics, they share the common characteristic of being backed by a possibly large memory buffer. It is then desirable, in some situations, to access that buffer directly and without intermediate copying.</p> <p>Python provides such a facility at the C level in the form of the <a class="reference internal" href="#bufferobjects"><span class="std std-ref">buffer protocol</span></a>. This protocol has two sides:</p> <ul class="simple" id="index-1"> <li>on the producer side, a type can export a “buffer interface” which allows objects of that type to expose information about their underlying buffer. This interface is described in the section <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">Buffer Object Structures</span></a>;</li> <li>on the consumer side, several means are available to obtain a pointer to the raw underlying data of an object (for example a method parameter).</li> </ul> <p>Simple objects such as <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> and <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> expose their underlying buffer in byte-oriented form. Other forms are possible; for example, the elements exposed by an <a class="reference internal" href="../library/array.html#array.array" title="array.array"><code>array.array</code></a> can be multi-byte values.</p> <p>An example consumer of the buffer interface is the <a class="reference internal" href="../library/io.html#io.BufferedIOBase.write" title="io.BufferedIOBase.write"><code>write()</code></a> method of file objects: any object that can export a series of bytes through the buffer interface can be written to a file. While <code>write()</code> only needs read-only access to the internal contents of the object passed to it, other methods such as <a class="reference internal" href="../library/io.html#io.BufferedIOBase.readinto" title="io.BufferedIOBase.readinto"><code>readinto()</code></a> need write access to the contents of their argument. The buffer interface allows objects to selectively allow or reject exporting of read-write and read-only buffers.</p> <p>There are two ways for a consumer of the buffer interface to acquire a buffer over a target object:</p> <ul class="simple"> <li>call <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code>PyObject_GetBuffer()</code></a> with the right parameters;</li> <li>call <a class="reference internal" href="arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> (or one of its siblings) with one of the <code>y*</code>, <code>w*</code> or <code>s*</code> <a class="reference internal" href="arg.html#arg-parsing"><span class="std std-ref">format codes</span></a>.</li> </ul> <p>In both cases, <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code>PyBuffer_Release()</code></a> must be called when the buffer isn’t needed anymore. Failure to do so could lead to various issues such as resource leaks.</p> <section id="buffer-structure"> <span id="id1"></span><h2>Buffer structure</h2> <p>Buffer structures (or simply “buffers”) are useful as a way to expose the binary data from another object to the Python programmer. They can also be used as a zero-copy slicing mechanism. Using their ability to reference a block of memory, it is possible to expose any data to the Python programmer quite easily. The memory could be a large, constant array in a C extension, it could be a raw block of memory for manipulation before passing to an operating system library, or it could be used to pass around structured data in its native, in-memory format.</p> <p>Contrary to most data types exposed by the Python interpreter, buffers are not <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> pointers but rather simple C structures. This allows them to be created and copied very simply. When a generic wrapper around a buffer is needed, a <a class="reference internal" href="memoryview.html#memoryview-objects"><span class="std std-ref">memoryview</span></a> object can be created.</p> <p>For short instructions how to write an exporting object, see <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">Buffer Object Structures</span></a>. For obtaining a buffer, see <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code>PyObject_GetBuffer()</code></a>.</p> <dl class="c type"> <dt class="sig sig-object c" id="c.Py_buffer">
<code>type Py_buffer</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> (including all members) since version 3.11.</em><dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.buf">
<code>void *buf</code> </dt> <dd>
<p>A pointer to the start of the logical structure described by the buffer fields. This can be any location within the underlying physical memory block of the exporter. For example, with negative <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code>strides</code></a> the value may point to the end of the memory block.</p> <p>For <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> arrays, the value points to the beginning of the memory block.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.obj">
<code>PyObject *obj</code> </dt> <dd>
<p>A new reference to the exporting object. The reference is owned by the consumer and automatically released (i.e. reference count decremented) and set to <code>NULL</code> by <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code>PyBuffer_Release()</code></a>. The field is the equivalent of the return value of any standard C-API function.</p> <p>As a special case, for <em>temporary</em> buffers that are wrapped by <a class="reference internal" href="memoryview.html#c.PyMemoryView_FromBuffer" title="PyMemoryView_FromBuffer"><code>PyMemoryView_FromBuffer()</code></a> or <a class="reference internal" href="#c.PyBuffer_FillInfo" title="PyBuffer_FillInfo"><code>PyBuffer_FillInfo()</code></a> this field is <code>NULL</code>. In general, exporting objects MUST NOT use this scheme.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.len">
<code>Py_ssize_t len</code> </dt> <dd>
<p><code>product(shape) * itemsize</code>. For contiguous arrays, this is the length of the underlying memory block. For non-contiguous arrays, it is the length that the logical structure would have if it were copied to a contiguous representation.</p> <p>Accessing <code>((char *)buf)[0] up to ((char *)buf)[len-1]</code> is only valid if the buffer has been obtained by a request that guarantees contiguity. In most cases such a request will be <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code>PyBUF_SIMPLE</code></a> or <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code>PyBUF_WRITABLE</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.readonly">
<code>int readonly</code> </dt> <dd>
<p>An indicator of whether the buffer is read-only. This field is controlled by the <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code>PyBUF_WRITABLE</code></a> flag.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.itemsize">
<code>Py_ssize_t itemsize</code> </dt> <dd>
<p>Item size in bytes of a single element. Same as the value of <a class="reference internal" href="../library/struct.html#struct.calcsize" title="struct.calcsize"><code>struct.calcsize()</code></a> called on non-<code>NULL</code> <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code>format</code></a> values.</p> <p>Important exception: If a consumer requests a buffer without the <a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code>PyBUF_FORMAT</code></a> flag, <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code>format</code></a> will be set to <code>NULL</code>, but <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code>itemsize</code></a> still has the value for the original format.</p> <p>If <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code>shape</code></a> is present, the equality <code>product(shape) * itemsize == len</code> still holds and the consumer can use <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code>itemsize</code></a> to navigate the buffer.</p> <p>If <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code>shape</code></a> is <code>NULL</code> as a result of a <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code>PyBUF_SIMPLE</code></a> or a <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code>PyBUF_WRITABLE</code></a> request, the consumer must disregard <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code>itemsize</code></a> and assume <code>itemsize == 1</code>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.format">
<code>char *format</code> </dt> <dd>
<p>A <em>NULL</em> terminated string in <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> module style syntax describing the contents of a single item. If this is <code>NULL</code>, <code>"B"</code> (unsigned bytes) is assumed.</p> <p>This field is controlled by the <a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code>PyBUF_FORMAT</code></a> flag.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.ndim">
<code>int ndim</code> </dt> <dd>
<p>The number of dimensions the memory represents as an n-dimensional array. If it is <code>0</code>, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code>buf</code></a> points to a single item representing a scalar. In this case, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code>shape</code></a>, <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code>strides</code></a> and <a class="reference internal" href="#c.Py_buffer.suboffsets" title="Py_buffer.suboffsets"><code>suboffsets</code></a> MUST be <code>NULL</code>. The maximum number of dimensions is given by <a class="reference internal" href="#c.PyBUF_MAX_NDIM" title="PyBUF_MAX_NDIM"><code>PyBUF_MAX_NDIM</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.shape">
<code>Py_ssize_t *shape</code> </dt> <dd>
<p>An array of <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a> of length <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code>ndim</code></a> indicating the shape of the memory as an n-dimensional array. Note that <code>shape[0] * ... * shape[ndim-1] * itemsize</code> MUST be equal to <a class="reference internal" href="#c.Py_buffer.len" title="Py_buffer.len"><code>len</code></a>.</p> <p>Shape values are restricted to <code>shape[n] &gt;= 0</code>. The case <code>shape[n] == 0</code> requires special attention. See <a class="reference internal" href="#complex-arrays">complex arrays</a> for further information.</p> <p>The shape array is read-only for the consumer.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.strides">
<code>Py_ssize_t *strides</code> </dt> <dd>
<p>An array of <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a> of length <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code>ndim</code></a> giving the number of bytes to skip to get to a new element in each dimension.</p> <p>Stride values can be any integer. For regular arrays, strides are usually positive, but a consumer MUST be able to handle the case <code>strides[n] &lt;= 0</code>. See <a class="reference internal" href="#complex-arrays">complex arrays</a> for further information.</p> <p>The strides array is read-only for the consumer.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.suboffsets">
<code>Py_ssize_t *suboffsets</code> </dt> <dd>
<p>An array of <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a> of length <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code>ndim</code></a>. If <code>suboffsets[n] &gt;= 0</code>, the values stored along the nth dimension are pointers and the suboffset value dictates how many bytes to add to each pointer after de-referencing. A suboffset value that is negative indicates that no de-referencing should occur (striding in a contiguous memory block).</p> <p>If all suboffsets are negative (i.e. no de-referencing is needed), then this field must be <code>NULL</code> (the default value).</p> <p>This type of array representation is used by the Python Imaging Library (PIL). See <a class="reference internal" href="#complex-arrays">complex arrays</a> for further information how to access elements of such an array.</p> <p>The suboffsets array is read-only for the consumer.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.Py_buffer.internal">
<code>void *internal</code> </dt> <dd>
<p>This is for use internally by the exporting object. For example, this might be re-cast as an integer by the exporter and used to store flags about whether or not the shape, strides, and suboffsets arrays must be freed when the buffer is released. The consumer MUST NOT alter this value.</p> </dd>
</dl> </dd>
</dl> <p>Constants:</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_MAX_NDIM">
<code>PyBUF_MAX_NDIM</code> </dt> <dd>
<p>The maximum number of dimensions the memory represents. Exporters MUST respect this limit, consumers of multi-dimensional buffers SHOULD be able to handle up to <code>PyBUF_MAX_NDIM</code> dimensions. Currently set to 64.</p> </dd>
</dl> </section> <section id="buffer-request-types"> <span id="id2"></span><h2>Buffer request types</h2> <p>Buffers are usually obtained by sending a buffer request to an exporting object via <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code>PyObject_GetBuffer()</code></a>. Since the complexity of the logical structure of the memory can vary drastically, the consumer uses the <em>flags</em> argument to specify the exact buffer type it can handle.</p> <p>All <a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><code>Py_buffer</code></a> fields are unambiguously defined by the request type.</p> <section id="request-independent-fields"> <h3>request-independent fields</h3> <p>The following fields are not influenced by <em>flags</em> and must always be filled in with the correct values: <a class="reference internal" href="#c.Py_buffer.obj" title="Py_buffer.obj"><code>obj</code></a>, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code>buf</code></a>, <a class="reference internal" href="#c.Py_buffer.len" title="Py_buffer.len"><code>len</code></a>, <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code>itemsize</code></a>, <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code>ndim</code></a>.</p> </section> <section id="readonly-format"> <h3>readonly, format</h3>  <dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_WRITABLE">
<code>PyBUF_WRITABLE</code> </dt> <dd>
<p>Controls the <a class="reference internal" href="#c.Py_buffer.readonly" title="Py_buffer.readonly"><code>readonly</code></a> field. If set, the exporter MUST provide a writable buffer or else report failure. Otherwise, the exporter MAY provide either a read-only or writable buffer, but the choice MUST be consistent for all consumers.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_FORMAT">
<code>PyBUF_FORMAT</code> </dt> <dd>
<p>Controls the <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code>format</code></a> field. If set, this field MUST be filled in correctly. Otherwise, this field MUST be <code>NULL</code>.</p> </dd>
</dl>  <p><a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code>PyBUF_WRITABLE</code></a> can be |’d to any of the flags in the next section. Since <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code>PyBUF_SIMPLE</code></a> is defined as 0, <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code>PyBUF_WRITABLE</code></a> can be used as a stand-alone flag to request a simple writable buffer.</p> <p><a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code>PyBUF_FORMAT</code></a> can be |’d to any of the flags except <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code>PyBUF_SIMPLE</code></a>. The latter already implies format <code>B</code> (unsigned bytes).</p> </section> <section id="shape-strides-suboffsets"> <h3>shape, strides, suboffsets</h3> <p>The flags that control the logical structure of the memory are listed in decreasing order of complexity. Note that each flag contains all bits of the flags below it.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Request</p></th> <th class="head"><p>shape</p></th> <th class="head"><p>strides</p></th> <th class="head"><p>suboffsets</p></th> </tr> </thead>  <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_INDIRECT">
<code>PyBUF_INDIRECT</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>if needed</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_STRIDES">
<code>PyBUF_STRIDES</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>NULL</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_ND">
<code>PyBUF_ND</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>NULL</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_SIMPLE">
<code>PyBUF_SIMPLE</code> </dt> <dd></dd>
</dl> </td> <td><p>NULL</p></td> <td><p>NULL</p></td> <td><p>NULL</p></td> </tr>  </table> </section> <section id="contiguity-requests"> <span id="index-2"></span><h3>contiguity requests</h3> <p>C or Fortran <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguity</span></a> can be explicitly requested, with and without stride information. Without stride information, the buffer must be C-contiguous.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Request</p></th> <th class="head"><p>shape</p></th> <th class="head"><p>strides</p></th> <th class="head"><p>suboffsets</p></th> <th class="head"><p>contig</p></th> </tr> </thead>  <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_C_CONTIGUOUS">
<code>PyBUF_C_CONTIGUOUS</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>C</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_F_CONTIGUOUS">
<code>PyBUF_F_CONTIGUOUS</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>F</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_ANY_CONTIGUOUS">
<code>PyBUF_ANY_CONTIGUOUS</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>C or F</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyBUF_ND" title="PyBUF_ND"><code>PyBUF_ND</code></a></p></td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>NULL</p></td> <td><p>C</p></td> </tr>  </table> </section> <section id="compound-requests"> <h3>compound requests</h3> <p>All possible requests are fully defined by some combination of the flags in the previous section. For convenience, the buffer protocol provides frequently used combinations as single flags.</p> <p>In the following table <em>U</em> stands for undefined contiguity. The consumer would have to call <a class="reference internal" href="#c.PyBuffer_IsContiguous" title="PyBuffer_IsContiguous"><code>PyBuffer_IsContiguous()</code></a> to determine contiguity.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Request</p></th> <th class="head"><p>shape</p></th> <th class="head"><p>strides</p></th> <th class="head"><p>suboffsets</p></th> <th class="head"><p>contig</p></th> <th class="head"><p>readonly</p></th> <th class="head"><p>format</p></th> </tr> </thead>  <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_FULL">
<code>PyBUF_FULL</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>if needed</p></td> <td><p>U</p></td> <td><p>0</p></td> <td><p>yes</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_FULL_RO">
<code>PyBUF_FULL_RO</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>if needed</p></td> <td><p>U</p></td> <td><p>1 or 0</p></td> <td><p>yes</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_RECORDS">
<code>PyBUF_RECORDS</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>U</p></td> <td><p>0</p></td> <td><p>yes</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_RECORDS_RO">
<code>PyBUF_RECORDS_RO</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>U</p></td> <td><p>1 or 0</p></td> <td><p>yes</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_STRIDED">
<code>PyBUF_STRIDED</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>U</p></td> <td><p>0</p></td> <td><p>NULL</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_STRIDED_RO">
<code>PyBUF_STRIDED_RO</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>U</p></td> <td><p>1 or 0</p></td> <td><p>NULL</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_CONTIG">
<code>PyBUF_CONTIG</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>NULL</p></td> <td><p>C</p></td> <td><p>0</p></td> <td><p>NULL</p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyBUF_CONTIG_RO">
<code>PyBUF_CONTIG_RO</code> </dt> <dd></dd>
</dl> </td> <td><p>yes</p></td> <td><p>NULL</p></td> <td><p>NULL</p></td> <td><p>C</p></td> <td><p>1 or 0</p></td> <td><p>NULL</p></td> </tr>  </table> </section> </section> <section id="complex-arrays"> <h2>Complex arrays</h2> <section id="numpy-style-shape-and-strides"> <h3>NumPy-style: shape and strides</h3> <p>The logical structure of NumPy-style arrays is defined by <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code>itemsize</code></a>, <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code>ndim</code></a>, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code>shape</code></a> and <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code>strides</code></a>.</p> <p>If <code>ndim == 0</code>, the memory location pointed to by <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code>buf</code></a> is interpreted as a scalar of size <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code>itemsize</code></a>. In that case, both <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code>shape</code></a> and <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code>strides</code></a> are <code>NULL</code>.</p> <p>If <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code>strides</code></a> is <code>NULL</code>, the array is interpreted as a standard n-dimensional C-array. Otherwise, the consumer must access an n-dimensional array as follows:</p> <pre data-language="c">ptr = (char *)buf + indices[0] * strides[0] + ... + indices[n-1] * strides[n-1];
item = *((typeof(item) *)ptr);
</pre> <p>As noted above, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code>buf</code></a> can point to any location within the actual memory block. An exporter can check the validity of a buffer with this function:</p> <pre data-language="python">def verify_structure(memlen, itemsize, ndim, shape, strides, offset):
    """Verify that the parameters represent a valid array within
       the bounds of the allocated memory:
           char *mem: start of the physical memory block
           memlen: length of the physical memory block
           offset: (char *)buf - mem
    """
    if offset % itemsize:
        return False
    if offset &lt; 0 or offset+itemsize &gt; memlen:
        return False
    if any(v % itemsize for v in strides):
        return False

    if ndim &lt;= 0:
        return ndim == 0 and not shape and not strides
    if 0 in shape:
        return True

    imin = sum(strides[j]*(shape[j]-1) for j in range(ndim)
               if strides[j] &lt;= 0)
    imax = sum(strides[j]*(shape[j]-1) for j in range(ndim)
               if strides[j] &gt; 0)

    return 0 &lt;= offset+imin and offset+imax+itemsize &lt;= memlen
</pre> </section> <section id="pil-style-shape-strides-and-suboffsets"> <h3>PIL-style: shape, strides and suboffsets</h3> <p>In addition to the regular items, PIL-style arrays can contain pointers that must be followed in order to get to the next element in a dimension. For example, the regular three-dimensional C-array <code>char v[2][2][3]</code> can also be viewed as an array of 2 pointers to 2 two-dimensional arrays: <code>char (*v[2])[2][3]</code>. In suboffsets representation, those two pointers can be embedded at the start of <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code>buf</code></a>, pointing to two <code>char x[2][3]</code> arrays that can be located anywhere in memory.</p> <p>Here is a function that returns a pointer to the element in an N-D array pointed to by an N-dimensional index when there are both non-<code>NULL</code> strides and suboffsets:</p> <pre data-language="c">void *get_item_pointer(int ndim, void *buf, Py_ssize_t *strides,
                       Py_ssize_t *suboffsets, Py_ssize_t *indices) {
    char *pointer = (char*)buf;
    int i;
    for (i = 0; i &lt; ndim; i++) {
        pointer += strides[i] * indices[i];
        if (suboffsets[i] &gt;=0 ) {
            pointer = *((char**)pointer) + suboffsets[i];
        }
    }
    return (void*)pointer;
}
</pre> </section> </section> <section id="buffer-related-functions"> <h2>Buffer-related functions</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CheckBuffer">
<code>int PyObject_CheckBuffer(PyObject *obj)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Return <code>1</code> if <em>obj</em> supports the buffer interface otherwise <code>0</code>. When <code>1</code> is returned, it doesn’t guarantee that <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code>PyObject_GetBuffer()</code></a> will succeed. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_GetBuffer">
<code>int PyObject_GetBuffer(PyObject *exporter, Py_buffer *view, int flags)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Send a request to <em>exporter</em> to fill in <em>view</em> as specified by <em>flags</em>. If the exporter cannot provide a buffer of the exact type, it MUST raise <a class="reference internal" href="../library/exceptions.html#BufferError" title="BufferError"><code>BufferError</code></a>, set <code>view-&gt;obj</code> to <code>NULL</code> and return <code>-1</code>.</p> <p>On success, fill in <em>view</em>, set <code>view-&gt;obj</code> to a new reference to <em>exporter</em> and return 0. In the case of chained buffer providers that redirect requests to a single object, <code>view-&gt;obj</code> MAY refer to this object instead of <em>exporter</em> (See <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">Buffer Object Structures</span></a>).</p> <p>Successful calls to <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code>PyObject_GetBuffer()</code></a> must be paired with calls to <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code>PyBuffer_Release()</code></a>, similar to <code>malloc()</code> and <code>free()</code>. Thus, after the consumer is done with the buffer, <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code>PyBuffer_Release()</code></a> must be called exactly once.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBuffer_Release">
<code>void PyBuffer_Release(Py_buffer *view)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Release the buffer <em>view</em> and release the <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> (i.e. decrement the reference count) to the view’s supporting object, <code>view-&gt;obj</code>. This function MUST be called when the buffer is no longer being used, otherwise reference leaks may occur.</p> <p>It is an error to call this function on a buffer that was not obtained via <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code>PyObject_GetBuffer()</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBuffer_SizeFromFormat">
<code>Py_ssize_t PyBuffer_SizeFromFormat(const char *format)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Return the implied <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code>itemsize</code></a> from <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code>format</code></a>. On error, raise an exception and return -1.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBuffer_IsContiguous">
<code>int PyBuffer_IsContiguous(const Py_buffer *view, char order)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Return <code>1</code> if the memory defined by the <em>view</em> is C-style (<em>order</em> is <code>'C'</code>) or Fortran-style (<em>order</em> is <code>'F'</code>) <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> or either one (<em>order</em> is <code>'A'</code>). Return <code>0</code> otherwise. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBuffer_GetPointer">
<code>void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Get the memory area pointed to by the <em>indices</em> inside the given <em>view</em>. <em>indices</em> must point to an array of <code>view-&gt;ndim</code> indices.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBuffer_FromContiguous">
<code>int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char fort)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Copy contiguous <em>len</em> bytes from <em>buf</em> to <em>view</em>. <em>fort</em> can be <code>'C'</code> or <code>'F'</code> (for C-style or Fortran-style ordering). <code>0</code> is returned on success, <code>-1</code> on error.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBuffer_ToContiguous">
<code>int PyBuffer_ToContiguous(void *buf, const Py_buffer *src, Py_ssize_t len, char order)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Copy <em>len</em> bytes from <em>src</em> to its contiguous representation in <em>buf</em>. <em>order</em> can be <code>'C'</code> or <code>'F'</code> or <code>'A'</code> (for C-style or Fortran-style ordering or either one). <code>0</code> is returned on success, <code>-1</code> on error.</p> <p>This function fails if <em>len</em> != <em>src-&gt;len</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_CopyData">
<code>int PyObject_CopyData(PyObject *dest, PyObject *src)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Copy data from <em>src</em> to <em>dest</em> buffer. Can convert between C-style and or Fortran-style buffers.</p> <p><code>0</code> is returned on success, <code>-1</code> on error.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBuffer_FillContiguousStrides">
<code>void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char order)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Fill the <em>strides</em> array with byte-strides of a <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> (C-style if <em>order</em> is <code>'C'</code> or Fortran-style if <em>order</em> is <code>'F'</code>) array of the given shape with the given number of bytes per element.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBuffer_FillInfo">
<code>int PyBuffer_FillInfo(Py_buffer *view, PyObject *exporter, void *buf, Py_ssize_t len, int readonly, int flags)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Handle buffer requests for an exporter that wants to expose <em>buf</em> of size <em>len</em> with writability set according to <em>readonly</em>. <em>buf</em> is interpreted as a sequence of unsigned bytes.</p> <p>The <em>flags</em> argument indicates the request type. This function always fills in <em>view</em> as specified by flags, unless <em>buf</em> has been designated as read-only and <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code>PyBUF_WRITABLE</code></a> is set in <em>flags</em>.</p> <p>On success, set <code>view-&gt;obj</code> to a new reference to <em>exporter</em> and return 0. Otherwise, raise <a class="reference internal" href="../library/exceptions.html#BufferError" title="BufferError"><code>BufferError</code></a>, set <code>view-&gt;obj</code> to <code>NULL</code> and return <code>-1</code>;</p> <p>If this function is used as part of a <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">getbufferproc</span></a>, <em>exporter</em> MUST be set to the exporting object and <em>flags</em> must be passed unmodified. Otherwise, <em>exporter</em> MUST be <code>NULL</code>.</p> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/buffer.html" class="_attribution-link">https://docs.python.org/3.13/c-api/buffer.html</a>
  </p>
</div>
