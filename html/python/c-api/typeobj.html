 <span id="type-structs"></span><h1>Type Objects</h1> <p>Perhaps one of the most important structures of the Python object system is the structure that defines a new type: the <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> structure. Type objects can be handled using any of the <code>PyObject_*</code> or <code>PyType_*</code> functions, but do not offer much that’s interesting to most Python applications. These objects are fundamental to how objects behave, so they are very important to the interpreter itself and to any extension module that implements new types.</p> <p>Type objects are fairly large compared to most of the standard types. The reason for the size is that each type object stores a large number of values, mostly C function pointers, each of which implements a small part of the type’s functionality. The fields of the type object are examined in detail in this section. The fields will be described in the order in which they occur in the structure.</p> <p>In addition to the following quick reference, the <a class="reference internal" href="#typedef-examples"><span class="std std-ref">Examples</span></a> section provides at-a-glance insight into the meaning and use of <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a>.</p> <section id="quick-reference"> <h2>Quick Reference</h2> <section id="tp-slots"> <span id="tp-slots-table"></span><h3>“tp slots”</h3> <table class="docutils align-default">  <thead> <tr>
<th class="head" rowspan="2"><p>PyTypeObject Slot <a class="footnote-reference brackets" href="#slots" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></th> <th class="head" rowspan="2"><p><a class="reference internal" href="#slot-typedefs-table"><span class="std std-ref">Type</span></a></p></th> <th class="head" rowspan="2"><p>special methods/attrs</p></th> <th class="head" colspan="4"><p>Info <a class="footnote-reference brackets" href="#cols" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></th> </tr> <tr>
<th class="head"><p>O</p></th> <th class="head"><p>T</p></th> <th class="head"><p>D</p></th> <th class="head"><p>I</p></th> </tr> </thead>  <tr>
<td><p>&lt;R&gt; <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code>tp_name</code></a></p></td> <td><p>const char *</p></td> <td><p>__name__</p></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a></p></td> <td><p><a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a></p></td> <td></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a></p></td> <td><p><a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a></p></td> <td></td> <td></td> <td><p>X</p></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a></p></td> <td><p><a class="reference internal" href="#c.destructor" title="destructor"><code>destructor</code></a></p></td> <td></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code>tp_vectorcall_offset</code></a></p></td> <td><p><a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a></p></td> <td></td> <td></td> <td><p>X</p></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code>tp_getattr</code></a>)</p></td> <td><p><a class="reference internal" href="#c.getattrfunc" title="getattrfunc"><code>getattrfunc</code></a></p></td> <td><p>__getattribute__, __getattr__</p></td> <td></td> <td></td> <td></td> <td><p>G</p></td> </tr> <tr>
<td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code>tp_setattr</code></a>)</p></td> <td><p><a class="reference internal" href="#c.setattrfunc" title="setattrfunc"><code>setattrfunc</code></a></p></td> <td><p>__setattr__, __delattr__</p></td> <td></td> <td></td> <td></td> <td><p>G</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_async" title="PyTypeObject.tp_as_async"><code>tp_as_async</code></a></p></td> <td><p><a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods"><code>PyAsyncMethods</code></a> *</p></td> <td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">sub-slots</span></a></p></td> <td></td> <td></td> <td></td> <td><p>%</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code>tp_repr</code></a></p></td> <td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code>reprfunc</code></a></p></td> <td><p>__repr__</p></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code>tp_as_number</code></a></p></td> <td><p><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><code>PyNumberMethods</code></a> *</p></td> <td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">sub-slots</span></a></p></td> <td></td> <td></td> <td></td> <td><p>%</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code>tp_as_sequence</code></a></p></td> <td><p><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><code>PySequenceMethods</code></a> *</p></td> <td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">sub-slots</span></a></p></td> <td></td> <td></td> <td></td> <td><p>%</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code>tp_as_mapping</code></a></p></td> <td><p><a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods"><code>PyMappingMethods</code></a> *</p></td> <td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">sub-slots</span></a></p></td> <td></td> <td></td> <td></td> <td><p>%</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code>tp_hash</code></a></p></td> <td><p><a class="reference internal" href="#c.hashfunc" title="hashfunc"><code>hashfunc</code></a></p></td> <td><p>__hash__</p></td> <td><p>X</p></td> <td></td> <td></td> <td><p>G</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a></p></td> <td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code>ternaryfunc</code></a></p></td> <td><p>__call__</p></td> <td></td> <td><p>X</p></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code>tp_str</code></a></p></td> <td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code>reprfunc</code></a></p></td> <td><p>__str__</p></td> <td><p>X</p></td> <td></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code>tp_getattro</code></a></p></td> <td><p><a class="reference internal" href="#c.getattrofunc" title="getattrofunc"><code>getattrofunc</code></a></p></td> <td><p>__getattribute__, __getattr__</p></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td><p>G</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a></p></td> <td><p><a class="reference internal" href="#c.setattrofunc" title="setattrofunc"><code>setattrofunc</code></a></p></td> <td><p>__setattr__, __delattr__</p></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td><p>G</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code>tp_as_buffer</code></a></p></td> <td><p><a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs"><code>PyBufferProcs</code></a> *</p></td> <td></td> <td></td> <td></td> <td></td> <td><p>%</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a></p></td> <td><p>unsigned long</p></td> <td></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td><p>?</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_doc" title="PyTypeObject.tp_doc"><code>tp_doc</code></a></p></td> <td><p>const char *</p></td> <td><p>__doc__</p></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a></p></td> <td><p><a class="reference internal" href="gcsupport.html#c.traverseproc" title="traverseproc"><code>traverseproc</code></a></p></td> <td></td> <td></td> <td><p>X</p></td> <td></td> <td><p>G</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a></p></td> <td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code>inquiry</code></a></p></td> <td></td> <td></td> <td><p>X</p></td> <td></td> <td><p>G</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a></p></td> <td><p><a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc"><code>richcmpfunc</code></a></p></td> <td><p>__lt__, __le__, __eq__, __ne__, __gt__, __ge__</p></td> <td><p>X</p></td> <td></td> <td></td> <td><p>G</p></td> </tr> <tr>
<td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code>tp_weaklistoffset</code></a>)</p></td> <td><p><a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a></p></td> <td></td> <td></td> <td><p>X</p></td> <td></td> <td><p>?</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code>tp_iter</code></a></p></td> <td><p><a class="reference internal" href="#c.getiterfunc" title="getiterfunc"><code>getiterfunc</code></a></p></td> <td><p>__iter__</p></td> <td></td> <td></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code>tp_iternext</code></a></p></td> <td><p><a class="reference internal" href="#c.iternextfunc" title="iternextfunc"><code>iternextfunc</code></a></p></td> <td><p>__next__</p></td> <td></td> <td></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code>tp_methods</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef"><code>PyMethodDef</code></a> []</p></td> <td></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code>tp_members</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyMemberDef" title="PyMemberDef"><code>PyMemberDef</code></a> []</p></td> <td></td> <td></td> <td><p>X</p></td> <td></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code>tp_getset</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyGetSetDef" title="PyGetSetDef"><code>PyGetSetDef</code></a> []</p></td> <td></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code>tp_base</code></a></p></td> <td><p><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> *</p></td> <td><p>__base__</p></td> <td></td> <td></td> <td><p>X</p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code>tp_dict</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td><p>__dict__</p></td> <td></td> <td></td> <td><p>?</p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code>tp_descr_get</code></a></p></td> <td><p><a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc"><code>descrgetfunc</code></a></p></td> <td><p>__get__</p></td> <td></td> <td></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_descr_set" title="PyTypeObject.tp_descr_set"><code>tp_descr_set</code></a></p></td> <td><p><a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc"><code>descrsetfunc</code></a></p></td> <td><p>__set__, __delete__</p></td> <td></td> <td></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code>tp_dictoffset</code></a>)</p></td> <td><p><a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a></p></td> <td></td> <td></td> <td><p>X</p></td> <td></td> <td><p>?</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a></p></td> <td><p><a class="reference internal" href="#c.initproc" title="initproc"><code>initproc</code></a></p></td> <td><p>__init__</p></td> <td><p>X</p></td> <td><p>X</p></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code>tp_alloc</code></a></p></td> <td><p><a class="reference internal" href="#c.allocfunc" title="allocfunc"><code>allocfunc</code></a></p></td> <td></td> <td><p>X</p></td> <td></td> <td><p>?</p></td> <td><p>?</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a></p></td> <td><p><a class="reference internal" href="#c.newfunc" title="newfunc"><code>newfunc</code></a></p></td> <td><p>__new__</p></td> <td><p>X</p></td> <td><p>X</p></td> <td><p>?</p></td> <td><p>?</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code>tp_free</code></a></p></td> <td><p><a class="reference internal" href="#c.freefunc" title="freefunc"><code>freefunc</code></a></p></td> <td></td> <td><p>X</p></td> <td><p>X</p></td> <td><p>?</p></td> <td><p>?</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_is_gc" title="PyTypeObject.tp_is_gc"><code>tp_is_gc</code></a></p></td> <td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code>inquiry</code></a></p></td> <td></td> <td></td> <td><p>X</p></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p>&lt;<a class="reference internal" href="#c.PyTypeObject.tp_bases" title="PyTypeObject.tp_bases"><code>tp_bases</code></a>&gt;</p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td><p>__bases__</p></td> <td></td> <td></td> <td><p>~</p></td> <td></td> </tr> <tr>
<td><p>&lt;<a class="reference internal" href="#c.PyTypeObject.tp_mro" title="PyTypeObject.tp_mro"><code>tp_mro</code></a>&gt;</p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td><p>__mro__</p></td> <td></td> <td></td> <td><p>~</p></td> <td></td> </tr> <tr>
<td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_cache" title="PyTypeObject.tp_cache"><code>tp_cache</code></a>]</p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td></td> <td></td> <td></td> <td colspan="2"></td> </tr> <tr>
<td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_subclasses" title="PyTypeObject.tp_subclasses"><code>tp_subclasses</code></a>]</p></td> <td><p>void *</p></td> <td><p>__subclasses__</p></td> <td></td> <td></td> <td colspan="2"></td> </tr> <tr>
<td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code>tp_weaklist</code></a>]</p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td></td> <td></td> <td></td> <td colspan="2"></td> </tr> <tr>
<td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_del" title="PyTypeObject.tp_del"><code>tp_del</code></a>)</p></td> <td><p><a class="reference internal" href="#c.destructor" title="destructor"><code>destructor</code></a></p></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr>
<td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_version_tag" title="PyTypeObject.tp_version_tag"><code>tp_version_tag</code></a>]</p></td> <td><p>unsigned int</p></td> <td></td> <td></td> <td></td> <td colspan="2"></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code>tp_finalize</code></a></p></td> <td><p><a class="reference internal" href="#c.destructor" title="destructor"><code>destructor</code></a></p></td> <td><p>__del__</p></td> <td></td> <td></td> <td></td> <td><p>X</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyTypeObject.tp_vectorcall" title="PyTypeObject.tp_vectorcall"><code>tp_vectorcall</code></a></p></td> <td><p><a class="reference internal" href="call.html#c.vectorcallfunc" title="vectorcallfunc"><code>vectorcallfunc</code></a></p></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr>
<td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_watched" title="PyTypeObject.tp_watched"><code>tp_watched</code></a>]</p></td> <td><p>unsigned char</p></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr>  </table> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="slots" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span> <p><strong>()</strong>: A slot name in parentheses indicates it is (effectively) deprecated.</p> <p><strong>&lt;&gt;</strong>: Names in angle brackets should be initially set to <code>NULL</code> and treated as read-only.</p> <p><strong>[]</strong>: Names in square brackets are for internal use only.</p> <p><strong>&lt;R&gt;</strong> (as a prefix) means the field is required (must be non-<code>NULL</code>).</p> </aside> <aside class="footnote brackets" id="cols" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span> <p>Columns:</p> <p><strong>“O”</strong>: set on <code>PyBaseObject_Type</code></p> <p><strong>“T”</strong>: set on <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code>PyType_Type</code></a></p> <p><strong>“D”</strong>: default (if slot is set to <code>NULL</code>)</p> <pre data-language="none">X - PyType_Ready sets this value if it is NULL
~ - PyType_Ready always sets this value (it should be NULL)
? - PyType_Ready may set this value depending on other slots

Also see the inheritance column ("I").
</pre> <p><strong>“I”</strong>: inheritance</p> <pre data-language="none">X - type slot is inherited via *PyType_Ready* if defined with a *NULL* value
% - the slots of the sub-struct are inherited individually
G - inherited, but only in combination with other slots; see the slot's description
? - it's complicated; see the slot's description
</pre> <p>Note that some slots are effectively inherited through the normal attribute lookup chain.</p> </aside> </aside> </section> <section id="sub-slots"> <span id="id3"></span><h3>sub-slots</h3> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Slot</p></th> <th class="head"><p><a class="reference internal" href="#slot-typedefs-table"><span class="std std-ref">Type</span></a></p></th> <th class="head"><p>special methods</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#c.PyAsyncMethods.am_await" title="PyAsyncMethods.am_await"><code>am_await</code></a></p></td> <td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td><p>__await__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyAsyncMethods.am_aiter" title="PyAsyncMethods.am_aiter"><code>am_aiter</code></a></p></td> <td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td><p>__aiter__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyAsyncMethods.am_anext" title="PyAsyncMethods.am_anext"><code>am_anext</code></a></p></td> <td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td><p>__anext__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyAsyncMethods.am_send" title="PyAsyncMethods.am_send"><code>am_send</code></a></p></td> <td><p><a class="reference internal" href="#c.sendfunc" title="sendfunc"><code>sendfunc</code></a></p></td> <td></td> </tr> <tr>
<td colspan="3"></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code>nb_add</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__add__ __radd__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_add" title="PyNumberMethods.nb_inplace_add"><code>nb_inplace_add</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__iadd__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_subtract" title="PyNumberMethods.nb_subtract"><code>nb_subtract</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__sub__ __rsub__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_subtract" title="PyNumberMethods.nb_inplace_subtract"><code>nb_inplace_subtract</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__isub__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_multiply" title="PyNumberMethods.nb_multiply"><code>nb_multiply</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__mul__ __rmul__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_multiply" title="PyNumberMethods.nb_inplace_multiply"><code>nb_inplace_multiply</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__imul__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_remainder" title="PyNumberMethods.nb_remainder"><code>nb_remainder</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__mod__ __rmod__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_remainder" title="PyNumberMethods.nb_inplace_remainder"><code>nb_inplace_remainder</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__imod__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_divmod" title="PyNumberMethods.nb_divmod"><code>nb_divmod</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__divmod__ __rdivmod__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_power" title="PyNumberMethods.nb_power"><code>nb_power</code></a></p></td> <td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code>ternaryfunc</code></a></p></td> <td><p>__pow__ __rpow__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_power" title="PyNumberMethods.nb_inplace_power"><code>nb_inplace_power</code></a></p></td> <td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code>ternaryfunc</code></a></p></td> <td><p>__ipow__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_negative" title="PyNumberMethods.nb_negative"><code>nb_negative</code></a></p></td> <td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td><p>__neg__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_positive" title="PyNumberMethods.nb_positive"><code>nb_positive</code></a></p></td> <td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td><p>__pos__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_absolute" title="PyNumberMethods.nb_absolute"><code>nb_absolute</code></a></p></td> <td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td><p>__abs__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_bool" title="PyNumberMethods.nb_bool"><code>nb_bool</code></a></p></td> <td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code>inquiry</code></a></p></td> <td><p>__bool__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_invert" title="PyNumberMethods.nb_invert"><code>nb_invert</code></a></p></td> <td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td><p>__invert__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_lshift" title="PyNumberMethods.nb_lshift"><code>nb_lshift</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__lshift__ __rlshift__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_lshift" title="PyNumberMethods.nb_inplace_lshift"><code>nb_inplace_lshift</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__ilshift__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_rshift" title="PyNumberMethods.nb_rshift"><code>nb_rshift</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__rshift__ __rrshift__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_rshift" title="PyNumberMethods.nb_inplace_rshift"><code>nb_inplace_rshift</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__irshift__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_and" title="PyNumberMethods.nb_and"><code>nb_and</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__and__ __rand__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_and" title="PyNumberMethods.nb_inplace_and"><code>nb_inplace_and</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__iand__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_xor" title="PyNumberMethods.nb_xor"><code>nb_xor</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__xor__ __rxor__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_xor" title="PyNumberMethods.nb_inplace_xor"><code>nb_inplace_xor</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__ixor__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_or" title="PyNumberMethods.nb_or"><code>nb_or</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__or__ __ror__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_or" title="PyNumberMethods.nb_inplace_or"><code>nb_inplace_or</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__ior__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_int" title="PyNumberMethods.nb_int"><code>nb_int</code></a></p></td> <td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td><p>__int__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_reserved" title="PyNumberMethods.nb_reserved"><code>nb_reserved</code></a></p></td> <td><p>void *</p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_float" title="PyNumberMethods.nb_float"><code>nb_float</code></a></p></td> <td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td><p>__float__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_floor_divide" title="PyNumberMethods.nb_floor_divide"><code>nb_floor_divide</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__floordiv__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_floor_divide" title="PyNumberMethods.nb_inplace_floor_divide"><code>nb_inplace_floor_divide</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__ifloordiv__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_true_divide" title="PyNumberMethods.nb_true_divide"><code>nb_true_divide</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__truediv__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_true_divide" title="PyNumberMethods.nb_inplace_true_divide"><code>nb_inplace_true_divide</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__itruediv__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_index" title="PyNumberMethods.nb_index"><code>nb_index</code></a></p></td> <td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td><p>__index__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_matrix_multiply" title="PyNumberMethods.nb_matrix_multiply"><code>nb_matrix_multiply</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__matmul__ __rmatmul__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_matrix_multiply" title="PyNumberMethods.nb_inplace_matrix_multiply"><code>nb_inplace_matrix_multiply</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__imatmul__</p></td> </tr> <tr>
<td colspan="3"></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyMappingMethods.mp_length" title="PyMappingMethods.mp_length"><code>mp_length</code></a></p></td> <td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code>lenfunc</code></a></p></td> <td><p>__len__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyMappingMethods.mp_subscript" title="PyMappingMethods.mp_subscript"><code>mp_subscript</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__getitem__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyMappingMethods.mp_ass_subscript" title="PyMappingMethods.mp_ass_subscript"><code>mp_ass_subscript</code></a></p></td> <td><p><a class="reference internal" href="#c.objobjargproc" title="objobjargproc"><code>objobjargproc</code></a></p></td> <td><p>__setitem__, __delitem__</p></td> </tr> <tr>
<td colspan="3"></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PySequenceMethods.sq_length" title="PySequenceMethods.sq_length"><code>sq_length</code></a></p></td> <td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code>lenfunc</code></a></p></td> <td><p>__len__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PySequenceMethods.sq_concat" title="PySequenceMethods.sq_concat"><code>sq_concat</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__add__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PySequenceMethods.sq_repeat" title="PySequenceMethods.sq_repeat"><code>sq_repeat</code></a></p></td> <td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code>ssizeargfunc</code></a></p></td> <td><p>__mul__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PySequenceMethods.sq_item" title="PySequenceMethods.sq_item"><code>sq_item</code></a></p></td> <td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code>ssizeargfunc</code></a></p></td> <td><p>__getitem__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PySequenceMethods.sq_ass_item" title="PySequenceMethods.sq_ass_item"><code>sq_ass_item</code></a></p></td> <td><p><a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc"><code>ssizeobjargproc</code></a></p></td> <td><p>__setitem__ __delitem__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PySequenceMethods.sq_contains" title="PySequenceMethods.sq_contains"><code>sq_contains</code></a></p></td> <td><p><a class="reference internal" href="#c.objobjproc" title="objobjproc"><code>objobjproc</code></a></p></td> <td><p>__contains__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PySequenceMethods.sq_inplace_concat" title="PySequenceMethods.sq_inplace_concat"><code>sq_inplace_concat</code></a></p></td> <td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td><p>__iadd__</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PySequenceMethods.sq_inplace_repeat" title="PySequenceMethods.sq_inplace_repeat"><code>sq_inplace_repeat</code></a></p></td> <td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code>ssizeargfunc</code></a></p></td> <td><p>__imul__</p></td> </tr> <tr>
<td colspan="3"></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyBufferProcs.bf_getbuffer" title="PyBufferProcs.bf_getbuffer"><code>bf_getbuffer</code></a></p></td> <td><p><a class="reference internal" href="#c.getbufferproc" title="getbufferproc"><code>getbufferproc()</code></a></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code>bf_releasebuffer</code></a></p></td> <td><p><a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc"><code>releasebufferproc()</code></a></p></td> <td></td> </tr>  </table> </section> <section id="slot-typedefs"> <span id="slot-typedefs-table"></span><h3>slot typedefs</h3> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>typedef</p></th> <th class="head"><p>Parameter Types</p></th> <th class="head"><p>Return Type</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#c.allocfunc" title="allocfunc"><code>allocfunc</code></a></p></td> <td> </td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.destructor" title="destructor"><code>destructor</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td><p>void</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.freefunc" title="freefunc"><code>freefunc</code></a></p></td> <td><p>void *</p></td> <td><p>void</p></td> </tr> <tr>
<td><p><a class="reference internal" href="gcsupport.html#c.traverseproc" title="traverseproc"><code>traverseproc</code></a></p></td> <td> </td> <td><p>int</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.newfunc" title="newfunc"><code>newfunc</code></a></p></td> <td> </td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.initproc" title="initproc"><code>initproc</code></a></p></td> <td> </td> <td><p>int</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code>reprfunc</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.getattrfunc" title="getattrfunc"><code>getattrfunc</code></a></p></td> <td> </td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.setattrfunc" title="setattrfunc"><code>setattrfunc</code></a></p></td> <td> </td> <td><p>int</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.getattrofunc" title="getattrofunc"><code>getattrofunc</code></a></p></td> <td> </td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.setattrofunc" title="setattrofunc"><code>setattrofunc</code></a></p></td> <td> </td> <td><p>int</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc"><code>descrgetfunc</code></a></p></td> <td> </td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc"><code>descrsetfunc</code></a></p></td> <td> </td> <td><p>int</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.hashfunc" title="hashfunc"><code>hashfunc</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td><p>Py_hash_t</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc"><code>richcmpfunc</code></a></p></td> <td> </td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.getiterfunc" title="getiterfunc"><code>getiterfunc</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.iternextfunc" title="iternextfunc"><code>iternextfunc</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code>lenfunc</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td><p><a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.getbufferproc" title="getbufferproc"><code>getbufferproc</code></a></p></td> <td> </td> <td><p>int</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc"><code>releasebufferproc</code></a></p></td> <td> </td> <td><p>void</p></td> </tr> <tr>
<td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code>inquiry</code></a></p></td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> <td><p>int</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code>unaryfunc</code></a></p></td> <td> </td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code>binaryfunc</code></a></p></td> <td> </td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code>ternaryfunc</code></a></p></td> <td> </td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code>ssizeargfunc</code></a></p></td> <td> </td> <td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> *</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc"><code>ssizeobjargproc</code></a></p></td> <td> </td> <td><p>int</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.objobjproc" title="objobjproc"><code>objobjproc</code></a></p></td> <td> </td> <td><p>int</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#c.objobjargproc" title="objobjargproc"><code>objobjargproc</code></a></p></td> <td> </td> <td><p>int</p></td> </tr>  </table> <p>See <a class="reference internal" href="#id6"><span class="std std-ref">Slot Type typedefs</span></a> below for more detail.</p> </section> </section> <section id="pytypeobject-definition"> <h2>PyTypeObject Definition</h2> <p>The structure definition for <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> can be found in <code>Include/object.h</code>. For convenience of reference, this repeats the definition found there:</p> <pre data-language="c">typedef struct _typeobject {
    PyObject_VAR_HEAD
    const char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */
    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

    /* Methods to implement standard operations */

    destructor tp_dealloc;
    Py_ssize_t tp_vectorcall_offset;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)
                                    or tp_reserved (Python 3) */
    reprfunc tp_repr;

    /* Method suites for standard classes */

    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;

    /* More standard operations (here for binary compatibility) */

    hashfunc tp_hash;
    ternaryfunc tp_call;
    reprfunc tp_str;
    getattrofunc tp_getattro;
    setattrofunc tp_setattro;

    /* Functions to access object as input/output buffer */
    PyBufferProcs *tp_as_buffer;

    /* Flags to define presence of optional/expanded features */
    unsigned long tp_flags;

    const char *tp_doc; /* Documentation string */

    /* Assigned meaning in release 2.0 */
    /* call function for all accessible objects */
    traverseproc tp_traverse;

    /* delete references to contained objects */
    inquiry tp_clear;

    /* Assigned meaning in release 2.1 */
    /* rich comparisons */
    richcmpfunc tp_richcompare;

    /* weak reference enabler */
    Py_ssize_t tp_weaklistoffset;

    /* Iterators */
    getiterfunc tp_iter;
    iternextfunc tp_iternext;

    /* Attribute descriptor and subclassing stuff */
    struct PyMethodDef *tp_methods;
    struct PyMemberDef *tp_members;
    struct PyGetSetDef *tp_getset;
    // Strong reference on a heap type, borrowed reference on a static type
    struct _typeobject *tp_base;
    PyObject *tp_dict;
    descrgetfunc tp_descr_get;
    descrsetfunc tp_descr_set;
    Py_ssize_t tp_dictoffset;
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    freefunc tp_free; /* Low-level free-memory routine */
    inquiry tp_is_gc; /* For PyObject_IS_GC */
    PyObject *tp_bases;
    PyObject *tp_mro; /* method resolution order */
    PyObject *tp_cache;
    PyObject *tp_subclasses;
    PyObject *tp_weaklist;
    destructor tp_del;

    /* Type attribute cache version tag. Added in version 2.6 */
    unsigned int tp_version_tag;

    destructor tp_finalize;
    vectorcallfunc tp_vectorcall;

    /* bitset of which type-watchers care about this type */
    unsigned char tp_watched;
} PyTypeObject;
</pre> </section> <section id="pyobject-slots"> <h2>PyObject Slots</h2> <p>The type object structure extends the <a class="reference internal" href="structures.html#c.PyVarObject" title="PyVarObject"><code>PyVarObject</code></a> structure. The <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code>ob_size</code></a> field is used for dynamic types (created by <code>type_new()</code>, usually called from a class statement). Note that <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code>PyType_Type</code></a> (the metatype) initializes <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a>, which means that its instances (i.e. type objects) <em>must</em> have the <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code>ob_size</code></a> field.</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyObject.ob_refcnt">
<code>Py_ssize_t PyObject.ob_refcnt</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is the type object’s reference count, initialized to <code>1</code> by the <code>PyObject_HEAD_INIT</code> macro. Note that for <a class="reference internal" href="#static-types"><span class="std std-ref">statically allocated type objects</span></a>, the type’s instances (objects whose <a class="reference internal" href="#c.PyObject.ob_type" title="PyObject.ob_type"><code>ob_type</code></a> points back to the type) do <em>not</em> count as references. But for <a class="reference internal" href="#heap-types"><span class="std std-ref">dynamically allocated type objects</span></a>, the instances <em>do</em> count as references.</p> <p><strong>Inheritance:</strong></p> <p>This field is not inherited by subtypes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyObject.ob_type">
<code>PyTypeObject *PyObject.ob_type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is the type’s type, in other words its metatype. It is initialized by the argument to the <code>PyObject_HEAD_INIT</code> macro, and its value should normally be <code>&amp;PyType_Type</code>. However, for dynamically loadable extension modules that must be usable on Windows (at least), the compiler complains that this is not a valid initializer. Therefore, the convention is to pass <code>NULL</code> to the <code>PyObject_HEAD_INIT</code> macro and to initialize this field explicitly at the start of the module’s initialization function, before doing anything else. This is typically done like this:</p> <pre data-language="c">Foo_Type.ob_type = &amp;PyType_Type;
</pre> <p>This should be done before any instances of the type are created. <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> checks if <a class="reference internal" href="#c.PyObject.ob_type" title="PyObject.ob_type"><code>ob_type</code></a> is <code>NULL</code>, and if so, initializes it to the <a class="reference internal" href="#c.PyObject.ob_type" title="PyObject.ob_type"><code>ob_type</code></a> field of the base class. <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> will not change this field if it is non-zero.</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> </dd>
</dl> </section> <section id="pyvarobject-slots"> <h2>PyVarObject Slots</h2> <dl class="c member"> <dt class="sig sig-object c" id="c.PyVarObject.ob_size">
<code>Py_ssize_t PyVarObject.ob_size</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>For <a class="reference internal" href="#static-types"><span class="std std-ref">statically allocated type objects</span></a>, this should be initialized to zero. For <a class="reference internal" href="#heap-types"><span class="std std-ref">dynamically allocated type objects</span></a>, this field has a special internal meaning.</p> <p><strong>Inheritance:</strong></p> <p>This field is not inherited by subtypes.</p> </dd>
</dl> </section> <section id="pytypeobject-slots"> <h2>PyTypeObject Slots</h2> <p>Each slot has a section describing inheritance. If <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> may set a value when the field is set to <code>NULL</code> then there will also be a “Default” section. (Note that many fields set on <code>PyBaseObject_Type</code> and <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code>PyType_Type</code></a> effectively act as defaults.)</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_name">
<code>const char *PyTypeObject.tp_name</code> </dt> <dd>
<p>Pointer to a NUL-terminated string containing the name of the type. For types that are accessible as module globals, the string should be the full module name, followed by a dot, followed by the type name; for built-in types, it should be just the type name. If the module is a submodule of a package, the full package name is part of the full module name. For example, a type named <code>T</code> defined in module <code>M</code> in subpackage <code>Q</code> in package <code>P</code> should have the <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code>tp_name</code></a> initializer <code>"P.Q.M.T"</code>.</p> <p>For <a class="reference internal" href="#heap-types"><span class="std std-ref">dynamically allocated type objects</span></a>, this should just be the type name, and the module name explicitly stored in the type dict as the value for key <code>'__module__'</code>.</p> <p>For <a class="reference internal" href="#static-types"><span class="std std-ref">statically allocated type objects</span></a>, the <em>tp_name</em> field should contain a dot. Everything before the last dot is made accessible as the <a class="reference internal" href="../reference/datamodel.html#type.__module__" title="type.__module__"><code>__module__</code></a> attribute, and everything after the last dot is made accessible as the <a class="reference internal" href="../reference/datamodel.html#type.__name__" title="type.__name__"><code>__name__</code></a> attribute.</p> <p>If no dot is present, the entire <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code>tp_name</code></a> field is made accessible as the <a class="reference internal" href="../reference/datamodel.html#type.__name__" title="type.__name__"><code>__name__</code></a> attribute, and the <a class="reference internal" href="../reference/datamodel.html#type.__module__" title="type.__module__"><code>__module__</code></a> attribute is undefined (unless explicitly set in the dictionary, as explained above). This means your type will be impossible to pickle. Additionally, it will not be listed in module documentations created with pydoc.</p> <p>This field must not be <code>NULL</code>. It is the only required field in <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject()</code></a> (other than potentially <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a>).</p> <p><strong>Inheritance:</strong></p> <p>This field is not inherited by subtypes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_basicsize">
<code>Py_ssize_t PyTypeObject.tp_basicsize</code> </dt> <dt class="sig sig-object c" id="c.PyTypeObject.tp_itemsize">
<code>Py_ssize_t PyTypeObject.tp_itemsize</code> </dt> <dd>
<p>These fields allow calculating the size in bytes of instances of the type.</p> <p>There are two kinds of types: types with fixed-length instances have a zero <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a> field, types with variable-length instances have a non-zero <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a> field. For a type with fixed-length instances, all instances have the same size, given in <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a>.</p> <p>For a type with variable-length instances, the instances must have an <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code>ob_size</code></a> field, and the instance size is <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a> plus N times <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a>, where N is the “length” of the object. The value of N is typically stored in the instance’s <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code>ob_size</code></a> field. There are exceptions: for example, ints use a negative <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code>ob_size</code></a> to indicate a negative number, and N is <code>abs(ob_size)</code> there. Also, the presence of an <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code>ob_size</code></a> field in the instance layout doesn’t mean that the instance structure is variable-length (for example, the structure for the list type has fixed-length instances, yet those instances have a meaningful <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code>ob_size</code></a> field).</p> <p>The basic size includes the fields in the instance declared by the macro <a class="reference internal" href="structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code>PyObject_HEAD</code></a> or <a class="reference internal" href="structures.html#c.PyObject_VAR_HEAD" title="PyObject_VAR_HEAD"><code>PyObject_VAR_HEAD</code></a> (whichever is used to declare the instance struct) and this in turn includes the <code>_ob_prev</code> and <code>_ob_next</code> fields if they are present. This means that the only correct way to get an initializer for the <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a> is to use the <code>sizeof</code> operator on the struct used to declare the instance layout. The basic size does not include the GC header size.</p> <p>A note about alignment: if the variable items require a particular alignment, this should be taken care of by the value of <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a>. Example: suppose a type implements an array of <code>double</code>. <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a> is <code>sizeof(double)</code>. It is the programmer’s responsibility that <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a> is a multiple of <code>sizeof(double)</code> (assuming this is the alignment requirement for <code>double</code>).</p> <p>For any type with variable-length instances, this field must not be <code>NULL</code>.</p> <p><strong>Inheritance:</strong></p> <p>These fields are inherited separately by subtypes. If the base type has a non-zero <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a>, it is generally not safe to set <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a> to a different non-zero value in a subtype (though this depends on the implementation of the base type).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_dealloc">
<code>destructor PyTypeObject.tp_dealloc</code> </dt> <dd>
<p>A pointer to the instance destructor function. This function must be defined unless the type guarantees that its instances will never be deallocated (as is the case for the singletons <code>None</code> and <code>Ellipsis</code>). The function signature is:</p> <pre data-language="c">void tp_dealloc(PyObject *self);
</pre> <p>The destructor function is called by the <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> and <a class="reference internal" href="refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code>Py_XDECREF()</code></a> macros when the new reference count is zero. At this point, the instance is still in existence, but there are no references to it. The destructor function should free all references which the instance owns, free all memory buffers owned by the instance (using the freeing function corresponding to the allocation function used to allocate the buffer), and call the type’s <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code>tp_free</code></a> function. If the type is not subtypable (doesn’t have the <a class="reference internal" href="#c.Py_TPFLAGS_BASETYPE" title="Py_TPFLAGS_BASETYPE"><code>Py_TPFLAGS_BASETYPE</code></a> flag bit set), it is permissible to call the object deallocator directly instead of via <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code>tp_free</code></a>. The object deallocator should be the one used to allocate the instance; this is normally <a class="reference internal" href="allocation.html#c.PyObject_Del" title="PyObject_Del"><code>PyObject_Del()</code></a> if the instance was allocated using <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code>PyObject_New</code></a> or <a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code>PyObject_NewVar</code></a>, or <a class="reference internal" href="gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code>PyObject_GC_Del()</code></a> if the instance was allocated using <a class="reference internal" href="gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code>PyObject_GC_New</code></a> or <a class="reference internal" href="gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code>PyObject_GC_NewVar</code></a>.</p> <p>If the type supports garbage collection (has the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit set), the destructor should call <a class="reference internal" href="gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code>PyObject_GC_UnTrack()</code></a> before clearing any member fields.</p> <pre data-language="c">static void foo_dealloc(foo_object *self) {
    PyObject_GC_UnTrack(self);
    Py_CLEAR(self-&gt;ref);
    Py_TYPE(self)-&gt;tp_free((PyObject *)self);
}
</pre> <p>Finally, if the type is heap allocated (<a class="reference internal" href="#c.Py_TPFLAGS_HEAPTYPE" title="Py_TPFLAGS_HEAPTYPE"><code>Py_TPFLAGS_HEAPTYPE</code></a>), the deallocator should release the owned reference to its type object (via <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a>) after calling the type deallocator. In order to avoid dangling pointers, the recommended way to achieve this is:</p> <pre data-language="c">static void foo_dealloc(foo_object *self) {
    PyTypeObject *tp = Py_TYPE(self);
    // free references and buffers here
    tp-&gt;tp_free(self);
    Py_DECREF(tp);
}
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>In a garbage collected Python, <code>tp_dealloc</code> may be called from any Python thread, not just the thread which created the object (if the object becomes part of a refcount cycle, that cycle might be collected by a garbage collection on any thread). This is not a problem for Python API calls, since the thread on which <code>tp_dealloc</code> is called will own the Global Interpreter Lock (GIL). However, if the object being destroyed in turn destroys objects from some other C or C++ library, care should be taken to ensure that destroying those objects on the thread which called <code>tp_dealloc</code> will not violate any assumptions of the library.</p> </div> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_vectorcall_offset">
<code>Py_ssize_t PyTypeObject.tp_vectorcall_offset</code> </dt> <dd>
<p>An optional offset to a per-instance function that implements calling the object using the <a class="reference internal" href="call.html#vectorcall"><span class="std std-ref">vectorcall protocol</span></a>, a more efficient alternative of the simpler <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a>.</p> <p>This field is only used if the flag <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code>Py_TPFLAGS_HAVE_VECTORCALL</code></a> is set. If so, this must be a positive integer containing the offset in the instance of a <a class="reference internal" href="call.html#c.vectorcallfunc" title="vectorcallfunc"><code>vectorcallfunc</code></a> pointer.</p> <p>The <em>vectorcallfunc</em> pointer may be <code>NULL</code>, in which case the instance behaves as if <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code>Py_TPFLAGS_HAVE_VECTORCALL</code></a> was not set: calling the instance falls back to <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a>.</p> <p>Any class that sets <code>Py_TPFLAGS_HAVE_VECTORCALL</code> must also set <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a> and make sure its behaviour is consistent with the <em>vectorcallfunc</em> function. This can be done by setting <em>tp_call</em> to <a class="reference internal" href="call.html#c.PyVectorcall_Call" title="PyVectorcall_Call"><code>PyVectorcall_Call()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Before version 3.8, this slot was named <code>tp_print</code>. In Python 2.x, it was used for printing to a file. In Python 3.0 to 3.7, it was unused.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Before version 3.12, it was not recommended for <a class="reference internal" href="#heap-types"><span class="std std-ref">mutable heap types</span></a> to implement the vectorcall protocol. When a user sets <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code>__call__</code></a> in Python code, only <em>tp_call</em> is updated, likely making it inconsistent with the vectorcall function. Since 3.12, setting <code>__call__</code> will disable vectorcall optimization by clearing the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code>Py_TPFLAGS_HAVE_VECTORCALL</code></a> flag.</p> </div> <p><strong>Inheritance:</strong></p> <p>This field is always inherited. However, the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code>Py_TPFLAGS_HAVE_VECTORCALL</code></a> flag is not always inherited. If it’s not set, then the subclass won’t use <a class="reference internal" href="call.html#vectorcall"><span class="std std-ref">vectorcall</span></a>, except when <a class="reference internal" href="call.html#c.PyVectorcall_Call" title="PyVectorcall_Call"><code>PyVectorcall_Call()</code></a> is explicitly called.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_getattr">
<code>getattrfunc PyTypeObject.tp_getattr</code> </dt> <dd>
<p>An optional pointer to the get-attribute-string function.</p> <p>This field is deprecated. When it is defined, it should point to a function that acts the same as the <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code>tp_getattro</code></a> function, but taking a C string instead of a Python string object to give the attribute name.</p> <p><strong>Inheritance:</strong></p> <p>Group: <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code>tp_getattr</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code>tp_getattro</code></a></p> <p>This field is inherited by subtypes together with <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code>tp_getattro</code></a>: a subtype inherits both <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code>tp_getattr</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code>tp_getattro</code></a> from its base type when the subtype’s <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code>tp_getattr</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code>tp_getattro</code></a> are both <code>NULL</code>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_setattr">
<code>setattrfunc PyTypeObject.tp_setattr</code> </dt> <dd>
<p>An optional pointer to the function for setting and deleting attributes.</p> <p>This field is deprecated. When it is defined, it should point to a function that acts the same as the <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a> function, but taking a C string instead of a Python string object to give the attribute name.</p> <p><strong>Inheritance:</strong></p> <p>Group: <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code>tp_setattr</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a></p> <p>This field is inherited by subtypes together with <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a>: a subtype inherits both <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code>tp_setattr</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a> from its base type when the subtype’s <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code>tp_setattr</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a> are both <code>NULL</code>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_as_async">
<code>PyAsyncMethods *PyTypeObject.tp_as_async</code> </dt> <dd>
<p>Pointer to an additional structure that contains fields relevant only to objects which implement <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> and <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> protocols at the C-level. See <a class="reference internal" href="#async-structs"><span class="std std-ref">Async Object Structures</span></a> for details.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5: </span>Formerly known as <code>tp_compare</code> and <code>tp_reserved</code>.</p> </div> <p><strong>Inheritance:</strong></p> <p>The <a class="reference internal" href="#c.PyTypeObject.tp_as_async" title="PyTypeObject.tp_as_async"><code>tp_as_async</code></a> field is not inherited, but the contained fields are inherited individually.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_repr">
<code>reprfunc PyTypeObject.tp_repr</code> </dt> <dd>
<p id="index-0">An optional pointer to a function that implements the built-in function <a class="reference internal" href="../library/functions.html#repr" title="repr"><code>repr()</code></a>.</p> <p>The signature is the same as for <a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code>PyObject_Repr()</code></a>:</p> <pre data-language="c">PyObject *tp_repr(PyObject *self);
</pre> <p>The function must return a string or a Unicode object. Ideally, this function should return a string that, when passed to <a class="reference internal" href="../library/functions.html#eval" title="eval"><code>eval()</code></a>, given a suitable environment, returns an object with the same value. If this is not feasible, it should return a string starting with <code>'&lt;'</code> and ending with <code>'&gt;'</code> from which both the type and the value of the object can be deduced.</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> <p><strong>Default:</strong></p> <p>When this field is not set, a string of the form <code>&lt;%s object at %p&gt;</code> is returned, where <code>%s</code> is replaced by the type name, and <code>%p</code> by the object’s memory address.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_as_number">
<code>PyNumberMethods *PyTypeObject.tp_as_number</code> </dt> <dd>
<p>Pointer to an additional structure that contains fields relevant only to objects which implement the number protocol. These fields are documented in <a class="reference internal" href="#number-structs"><span class="std std-ref">Number Object Structures</span></a>.</p> <p><strong>Inheritance:</strong></p> <p>The <a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code>tp_as_number</code></a> field is not inherited, but the contained fields are inherited individually.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_as_sequence">
<code>PySequenceMethods *PyTypeObject.tp_as_sequence</code> </dt> <dd>
<p>Pointer to an additional structure that contains fields relevant only to objects which implement the sequence protocol. These fields are documented in <a class="reference internal" href="#sequence-structs"><span class="std std-ref">Sequence Object Structures</span></a>.</p> <p><strong>Inheritance:</strong></p> <p>The <a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code>tp_as_sequence</code></a> field is not inherited, but the contained fields are inherited individually.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_as_mapping">
<code>PyMappingMethods *PyTypeObject.tp_as_mapping</code> </dt> <dd>
<p>Pointer to an additional structure that contains fields relevant only to objects which implement the mapping protocol. These fields are documented in <a class="reference internal" href="#mapping-structs"><span class="std std-ref">Mapping Object Structures</span></a>.</p> <p><strong>Inheritance:</strong></p> <p>The <a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code>tp_as_mapping</code></a> field is not inherited, but the contained fields are inherited individually.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_hash">
<code>hashfunc PyTypeObject.tp_hash</code> </dt> <dd>
<p id="index-1">An optional pointer to a function that implements the built-in function <a class="reference internal" href="../library/functions.html#hash" title="hash"><code>hash()</code></a>.</p> <p>The signature is the same as for <a class="reference internal" href="object.html#c.PyObject_Hash" title="PyObject_Hash"><code>PyObject_Hash()</code></a>:</p> <pre data-language="c">Py_hash_t tp_hash(PyObject *);
</pre> <p>The value <code>-1</code> should not be returned as a normal return value; when an error occurs during the computation of the hash value, the function should set an exception and return <code>-1</code>.</p> <p>When this field is not set (<em>and</em> <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a> is not set), an attempt to take the hash of the object raises <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>. This is the same as setting it to <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code>PyObject_HashNotImplemented()</code></a>.</p> <p>This field can be set explicitly to <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code>PyObject_HashNotImplemented()</code></a> to block inheritance of the hash method from a parent type. This is interpreted as the equivalent of <code>__hash__ = None</code> at the Python level, causing <code>isinstance(o, collections.Hashable)</code> to correctly return <code>False</code>. Note that the converse is also true - setting <code>__hash__ = None</code> on a class at the Python level will result in the <code>tp_hash</code> slot being set to <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code>PyObject_HashNotImplemented()</code></a>.</p> <p><strong>Inheritance:</strong></p> <p>Group: <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code>tp_hash</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a></p> <p>This field is inherited by subtypes together with <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a>: a subtype inherits both of <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code>tp_hash</code></a>, when the subtype’s <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code>tp_hash</code></a> are both <code>NULL</code>.</p> <p><strong>Default:</strong></p> <p><code>PyBaseObject_Type</code> uses <a class="reference internal" href="hash.html#c.PyObject_GenericHash" title="PyObject_GenericHash"><code>PyObject_GenericHash()</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_call">
<code>ternaryfunc PyTypeObject.tp_call</code> </dt> <dd>
<p>An optional pointer to a function that implements calling the object. This should be <code>NULL</code> if the object is not callable. The signature is the same as for <a class="reference internal" href="call.html#c.PyObject_Call" title="PyObject_Call"><code>PyObject_Call()</code></a>:</p> <pre data-language="c">PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);
</pre> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_str">
<code>reprfunc PyTypeObject.tp_str</code> </dt> <dd>
<p>An optional pointer to a function that implements the built-in operation <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str()</code></a>. (Note that <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> is a type now, and <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str()</code></a> calls the constructor for that type. This constructor calls <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code>PyObject_Str()</code></a> to do the actual work, and <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code>PyObject_Str()</code></a> will call this handler.)</p> <p>The signature is the same as for <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code>PyObject_Str()</code></a>:</p> <pre data-language="c">PyObject *tp_str(PyObject *self);
</pre> <p>The function must return a string or a Unicode object. It should be a “friendly” string representation of the object, as this is the representation that will be used, among other things, by the <a class="reference internal" href="../library/functions.html#print" title="print"><code>print()</code></a> function.</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> <p><strong>Default:</strong></p> <p>When this field is not set, <a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code>PyObject_Repr()</code></a> is called to return a string representation.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_getattro">
<code>getattrofunc PyTypeObject.tp_getattro</code> </dt> <dd>
<p>An optional pointer to the get-attribute function.</p> <p>The signature is the same as for <a class="reference internal" href="object.html#c.PyObject_GetAttr" title="PyObject_GetAttr"><code>PyObject_GetAttr()</code></a>:</p> <pre data-language="c">PyObject *tp_getattro(PyObject *self, PyObject *attr);
</pre> <p>It is usually convenient to set this field to <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code>PyObject_GenericGetAttr()</code></a>, which implements the normal way of looking for object attributes.</p> <p><strong>Inheritance:</strong></p> <p>Group: <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code>tp_getattr</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code>tp_getattro</code></a></p> <p>This field is inherited by subtypes together with <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code>tp_getattr</code></a>: a subtype inherits both <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code>tp_getattr</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code>tp_getattro</code></a> from its base type when the subtype’s <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code>tp_getattr</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code>tp_getattro</code></a> are both <code>NULL</code>.</p> <p><strong>Default:</strong></p> <p><code>PyBaseObject_Type</code> uses <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code>PyObject_GenericGetAttr()</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_setattro">
<code>setattrofunc PyTypeObject.tp_setattro</code> </dt> <dd>
<p>An optional pointer to the function for setting and deleting attributes.</p> <p>The signature is the same as for <a class="reference internal" href="object.html#c.PyObject_SetAttr" title="PyObject_SetAttr"><code>PyObject_SetAttr()</code></a>:</p> <pre data-language="c">int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);
</pre> <p>In addition, setting <em>value</em> to <code>NULL</code> to delete an attribute must be supported. It is usually convenient to set this field to <a class="reference internal" href="object.html#c.PyObject_GenericSetAttr" title="PyObject_GenericSetAttr"><code>PyObject_GenericSetAttr()</code></a>, which implements the normal way of setting object attributes.</p> <p><strong>Inheritance:</strong></p> <p>Group: <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code>tp_setattr</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a></p> <p>This field is inherited by subtypes together with <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code>tp_setattr</code></a>: a subtype inherits both <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code>tp_setattr</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a> from its base type when the subtype’s <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code>tp_setattr</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a> are both <code>NULL</code>.</p> <p><strong>Default:</strong></p> <p><code>PyBaseObject_Type</code> uses <a class="reference internal" href="object.html#c.PyObject_GenericSetAttr" title="PyObject_GenericSetAttr"><code>PyObject_GenericSetAttr()</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_as_buffer">
<code>PyBufferProcs *PyTypeObject.tp_as_buffer</code> </dt> <dd>
<p>Pointer to an additional structure that contains fields relevant only to objects which implement the buffer interface. These fields are documented in <a class="reference internal" href="#buffer-structs"><span class="std std-ref">Buffer Object Structures</span></a>.</p> <p><strong>Inheritance:</strong></p> <p>The <a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code>tp_as_buffer</code></a> field is not inherited, but the contained fields are inherited individually.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_flags">
<code>unsigned long PyTypeObject.tp_flags</code> </dt> <dd>
<p>This field is a bit mask of various flags. Some flags indicate variant semantics for certain situations; others are used to indicate that certain fields in the type object (or in the extension structures referenced via <a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code>tp_as_number</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code>tp_as_sequence</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code>tp_as_mapping</code></a>, and <a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code>tp_as_buffer</code></a>) that were historically not always present are valid; if such a flag bit is clear, the type fields it guards must not be accessed and must be considered to have a zero or <code>NULL</code> value instead.</p> <p><strong>Inheritance:</strong></p> <p>Inheritance of this field is complicated. Most flag bits are inherited individually, i.e. if the base type has a flag bit set, the subtype inherits this flag bit. The flag bits that pertain to extension structures are strictly inherited if the extension structure is inherited, i.e. the base type’s value of the flag bit is copied into the subtype together with a pointer to the extension structure. The <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit is inherited together with the <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> fields, i.e. if the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit is clear in the subtype and the <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> fields in the subtype exist and have <code>NULL</code> values. .. XXX are most flag bits <em>really</em> inherited individually?</p> <p><strong>Default:</strong></p> <p><code>PyBaseObject_Type</code> uses <code>Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE</code>.</p> <p><strong>Bit Masks:</strong></p> <p>The following bit masks are currently defined; these can be ORed together using the <code>|</code> operator to form the value of the <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> field. The macro <a class="reference internal" href="type.html#c.PyType_HasFeature" title="PyType_HasFeature"><code>PyType_HasFeature()</code></a> takes a type and a flags value, <em>tp</em> and <em>f</em>, and checks whether <code>tp-&gt;tp_flags &amp; f</code> is non-zero.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_HEAPTYPE">
<code>Py_TPFLAGS_HEAPTYPE</code> </dt> <dd>
<p>This bit is set when the type object itself is allocated on the heap, for example, types created dynamically using <a class="reference internal" href="type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code>PyType_FromSpec()</code></a>. In this case, the <a class="reference internal" href="#c.PyObject.ob_type" title="PyObject.ob_type"><code>ob_type</code></a> field of its instances is considered a reference to the type, and the type object is INCREF’ed when a new instance is created, and DECREF’ed when an instance is destroyed (this does not apply to instances of subtypes; only the type referenced by the instance’s ob_type gets INCREF’ed or DECREF’ed). Heap types should also <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">support garbage collection</span></a> as they can form a reference cycle with their own module object.</p> <p><strong>Inheritance:</strong></p> <p>???</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_BASETYPE">
<code>Py_TPFLAGS_BASETYPE</code> </dt> <dd>
<p>This bit is set when the type can be used as the base type of another type. If this bit is clear, the type cannot be subtyped (similar to a “final” class in Java).</p> <p><strong>Inheritance:</strong></p> <p>???</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_READY">
<code>Py_TPFLAGS_READY</code> </dt> <dd>
<p>This bit is set when the type object has been fully initialized by <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a>.</p> <p><strong>Inheritance:</strong></p> <p>???</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_READYING">
<code>Py_TPFLAGS_READYING</code> </dt> <dd>
<p>This bit is set while <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> is in the process of initializing the type object.</p> <p><strong>Inheritance:</strong></p> <p>???</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_HAVE_GC">
<code>Py_TPFLAGS_HAVE_GC</code> </dt> <dd>
<p>This bit is set when the object supports garbage collection. If this bit is set, instances must be created using <a class="reference internal" href="gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code>PyObject_GC_New</code></a> and destroyed using <a class="reference internal" href="gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code>PyObject_GC_Del()</code></a>. More information in section <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">Supporting Cyclic Garbage Collection</span></a>. This bit also implies that the GC-related fields <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> are present in the type object.</p> <p><strong>Inheritance:</strong></p> <p>Group: <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a></p> <p>The <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit is inherited together with the <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> fields, i.e. if the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit is clear in the subtype and the <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> fields in the subtype exist and have <code>NULL</code> values.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_DEFAULT">
<code>Py_TPFLAGS_DEFAULT</code> </dt> <dd>
<p>This is a bitmask of all the bits that pertain to the existence of certain fields in the type object and its extension structures. Currently, it includes the following bits: <code>Py_TPFLAGS_HAVE_STACKLESS_EXTENSION</code>.</p> <p><strong>Inheritance:</strong></p> <p>???</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_METHOD_DESCRIPTOR">
<code>Py_TPFLAGS_METHOD_DESCRIPTOR</code> </dt> <dd>
<p>This bit indicates that objects behave like unbound methods.</p> <p>If this flag is set for <code>type(meth)</code>, then:</p> <ul class="simple"> <li>
<code>meth.__get__(obj, cls)(*args, **kwds)</code> (with <code>obj</code> not None) must be equivalent to <code>meth(obj, *args, **kwds)</code>.</li> <li>
<code>meth.__get__(None, cls)(*args, **kwds)</code> must be equivalent to <code>meth(*args, **kwds)</code>.</li> </ul> <p>This flag enables an optimization for typical method calls like <code>obj.meth()</code>: it avoids creating a temporary “bound method” object for <code>obj.meth</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> <p><strong>Inheritance:</strong></p> <p>This flag is never inherited by types without the <a class="reference internal" href="#c.Py_TPFLAGS_IMMUTABLETYPE" title="Py_TPFLAGS_IMMUTABLETYPE"><code>Py_TPFLAGS_IMMUTABLETYPE</code></a> flag set. For extension types, it is inherited whenever <a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code>tp_descr_get</code></a> is inherited.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_MANAGED_DICT">
<code>Py_TPFLAGS_MANAGED_DICT</code> </dt> <dd>
<p>This bit indicates that instances of the class have a <code>~object.__dict__</code> attribute, and that the space for the dictionary is managed by the VM.</p> <p>If this flag is set, <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> should also be set.</p> <p>The type traverse function must call <a class="reference internal" href="object.html#c.PyObject_VisitManagedDict" title="PyObject_VisitManagedDict"><code>PyObject_VisitManagedDict()</code></a> and its clear function must call <a class="reference internal" href="object.html#c.PyObject_ClearManagedDict" title="PyObject_ClearManagedDict"><code>PyObject_ClearManagedDict()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> <p><strong>Inheritance:</strong></p> <p>This flag is inherited unless the <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code>tp_dictoffset</code></a> field is set in a superclass.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_MANAGED_WEAKREF">
<code>Py_TPFLAGS_MANAGED_WEAKREF</code> </dt> <dd>
<p>This bit indicates that instances of the class should be weakly referenceable.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> <p><strong>Inheritance:</strong></p> <p>This flag is inherited unless the <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code>tp_weaklistoffset</code></a> field is set in a superclass.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_ITEMS_AT_END">
<code>Py_TPFLAGS_ITEMS_AT_END</code> </dt> <dd>
<p>Only usable with variable-size types, i.e. ones with non-zero <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a>.</p> <p>Indicates that the variable-sized portion of an instance of this type is at the end of the instance’s memory area, at an offset of <code>Py_TYPE(obj)-&gt;tp_basicsize</code> (which may be different in each subclass).</p> <p>When setting this flag, be sure that all superclasses either use this memory layout, or are not variable-sized. Python does not check this.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> <p><strong>Inheritance:</strong></p> <p>This flag is inherited.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_LONG_SUBCLASS">
<code>Py_TPFLAGS_LONG_SUBCLASS</code> </dt> <dd></dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_LIST_SUBCLASS">
<code>Py_TPFLAGS_LIST_SUBCLASS</code> </dt> <dd></dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_TUPLE_SUBCLASS">
<code>Py_TPFLAGS_TUPLE_SUBCLASS</code> </dt> <dd></dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_BYTES_SUBCLASS">
<code>Py_TPFLAGS_BYTES_SUBCLASS</code> </dt> <dd></dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_UNICODE_SUBCLASS">
<code>Py_TPFLAGS_UNICODE_SUBCLASS</code> </dt> <dd></dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_DICT_SUBCLASS">
<code>Py_TPFLAGS_DICT_SUBCLASS</code> </dt> <dd></dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_BASE_EXC_SUBCLASS">
<code>Py_TPFLAGS_BASE_EXC_SUBCLASS</code> </dt> <dd></dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_TYPE_SUBCLASS">
<code>Py_TPFLAGS_TYPE_SUBCLASS</code> </dt> <dd>
<p>These flags are used by functions such as <a class="reference internal" href="long.html#c.PyLong_Check" title="PyLong_Check"><code>PyLong_Check()</code></a> to quickly determine if a type is a subclass of a built-in type; such specific checks are faster than a generic check, like <a class="reference internal" href="object.html#c.PyObject_IsInstance" title="PyObject_IsInstance"><code>PyObject_IsInstance()</code></a>. Custom types that inherit from built-ins should have their <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> set appropriately, or the code that interacts with such types will behave differently depending on what kind of check is used.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_HAVE_FINALIZE">
<code>Py_TPFLAGS_HAVE_FINALIZE</code> </dt> <dd>
<p>This bit is set when the <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code>tp_finalize</code></a> slot is present in the type structure.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.8: </span>This flag isn’t necessary anymore, as the interpreter assumes the <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code>tp_finalize</code></a> slot is always present in the type structure.</p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_HAVE_VECTORCALL">
<code>Py_TPFLAGS_HAVE_VECTORCALL</code> </dt> <dd>
<p>This bit is set when the class implements the <a class="reference internal" href="call.html#vectorcall"><span class="std std-ref">vectorcall protocol</span></a>. See <a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code>tp_vectorcall_offset</code></a> for details.</p> <p><strong>Inheritance:</strong></p> <p>This bit is inherited if <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code>tp_call</code></a> is also inherited.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>This flag is now removed from a class when the class’s <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code>__call__()</code></a> method is reassigned.</p> <p>This flag can now be inherited by mutable classes.</p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_IMMUTABLETYPE">
<code>Py_TPFLAGS_IMMUTABLETYPE</code> </dt> <dd>
<p>This bit is set for type objects that are immutable: type attributes cannot be set nor deleted.</p> <p><a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> automatically applies this flag to <a class="reference internal" href="#static-types"><span class="std std-ref">static types</span></a>.</p> <p><strong>Inheritance:</strong></p> <p>This flag is not inherited.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_DISALLOW_INSTANTIATION">
<code>Py_TPFLAGS_DISALLOW_INSTANTIATION</code> </dt> <dd>
<p>Disallow creating instances of the type: set <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> to NULL and don’t create the <code>__new__</code> key in the type dictionary.</p> <p>The flag must be set before creating the type, not after. For example, it must be set before <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> is called on the type.</p> <p>The flag is set automatically on <a class="reference internal" href="#static-types"><span class="std std-ref">static types</span></a> if <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code>tp_base</code></a> is NULL or <code>&amp;PyBaseObject_Type</code> and <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> is NULL.</p> <p><strong>Inheritance:</strong></p> <p>This flag is not inherited. However, subclasses will not be instantiable unless they provide a non-NULL <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> (which is only possible via the C API).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>To disallow instantiating a class directly but allow instantiating its subclasses (e.g. for an <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>), do not use this flag. Instead, make <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> only succeed for subclasses.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_MAPPING">
<code>Py_TPFLAGS_MAPPING</code> </dt> <dd>
<p>This bit indicates that instances of the class may match mapping patterns when used as the subject of a <a class="reference internal" href="../reference/compound_stmts.html#match"><code>match</code></a> block. It is automatically set when registering or subclassing <a class="reference internal" href="../library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code>collections.abc.Mapping</code></a>, and unset when registering <a class="reference internal" href="../library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code>collections.abc.Sequence</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#c.Py_TPFLAGS_MAPPING" title="Py_TPFLAGS_MAPPING"><code>Py_TPFLAGS_MAPPING</code></a> and <a class="reference internal" href="#c.Py_TPFLAGS_SEQUENCE" title="Py_TPFLAGS_SEQUENCE"><code>Py_TPFLAGS_SEQUENCE</code></a> are mutually exclusive; it is an error to enable both flags simultaneously.</p> </div> <p><strong>Inheritance:</strong></p> <p>This flag is inherited by types that do not already set <a class="reference internal" href="#c.Py_TPFLAGS_SEQUENCE" title="Py_TPFLAGS_SEQUENCE"><code>Py_TPFLAGS_SEQUENCE</code></a>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0634/"><strong>PEP 634</strong></a> – Structural Pattern Matching: Specification</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_SEQUENCE">
<code>Py_TPFLAGS_SEQUENCE</code> </dt> <dd>
<p>This bit indicates that instances of the class may match sequence patterns when used as the subject of a <a class="reference internal" href="../reference/compound_stmts.html#match"><code>match</code></a> block. It is automatically set when registering or subclassing <a class="reference internal" href="../library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code>collections.abc.Sequence</code></a>, and unset when registering <a class="reference internal" href="../library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code>collections.abc.Mapping</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#c.Py_TPFLAGS_MAPPING" title="Py_TPFLAGS_MAPPING"><code>Py_TPFLAGS_MAPPING</code></a> and <a class="reference internal" href="#c.Py_TPFLAGS_SEQUENCE" title="Py_TPFLAGS_SEQUENCE"><code>Py_TPFLAGS_SEQUENCE</code></a> are mutually exclusive; it is an error to enable both flags simultaneously.</p> </div> <p><strong>Inheritance:</strong></p> <p>This flag is inherited by types that do not already set <a class="reference internal" href="#c.Py_TPFLAGS_MAPPING" title="Py_TPFLAGS_MAPPING"><code>Py_TPFLAGS_MAPPING</code></a>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0634/"><strong>PEP 634</strong></a> – Structural Pattern Matching: Specification</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_TPFLAGS_VALID_VERSION_TAG">
<code>Py_TPFLAGS_VALID_VERSION_TAG</code> </dt> <dd>
<p>Internal. Do not set or unset this flag. To indicate that a class has changed call <a class="reference internal" href="type.html#c.PyType_Modified" title="PyType_Modified"><code>PyType_Modified()</code></a></p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This flag is present in header files, but is not be used. It will be removed in a future version of CPython</p> </div> </dd>
</dl> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_doc">
<code>const char *PyTypeObject.tp_doc</code> </dt> <dd>
<p>An optional pointer to a NUL-terminated C string giving the docstring for this type object. This is exposed as the <a class="reference internal" href="../reference/datamodel.html#type.__doc__" title="type.__doc__"><code>__doc__</code></a> attribute on the type and instances of the type.</p> <p><strong>Inheritance:</strong></p> <p>This field is <em>not</em> inherited by subtypes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_traverse">
<code>traverseproc PyTypeObject.tp_traverse</code> </dt> <dd>
<p>An optional pointer to a traversal function for the garbage collector. This is only used if the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit is set. The signature is:</p> <pre data-language="c">int tp_traverse(PyObject *self, visitproc visit, void *arg);
</pre> <p>More information about Python’s garbage collection scheme can be found in section <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">Supporting Cyclic Garbage Collection</span></a>.</p> <p>The <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> pointer is used by the garbage collector to detect reference cycles. A typical implementation of a <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> function simply calls <a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code>Py_VISIT()</code></a> on each of the instance’s members that are Python objects that the instance owns. For example, this is function <code>local_traverse()</code> from the <code>_thread</code> extension module:</p> <pre data-language="c">static int
local_traverse(localobject *self, visitproc visit, void *arg)
{
    Py_VISIT(self-&gt;args);
    Py_VISIT(self-&gt;kw);
    Py_VISIT(self-&gt;dict);
    return 0;
}
</pre> <p>Note that <a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code>Py_VISIT()</code></a> is called only on those members that can participate in reference cycles. Although there is also a <code>self-&gt;key</code> member, it can only be <code>NULL</code> or a Python string and therefore cannot be part of a reference cycle.</p> <p>On the other hand, even if you know a member can never be part of a cycle, as a debugging aid you may want to visit it anyway just so the <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code>gc</code></a> module’s <a class="reference internal" href="../library/gc.html#gc.get_referents" title="gc.get_referents"><code>get_referents()</code></a> function will include it.</p> <p>Heap types (<a class="reference internal" href="#c.Py_TPFLAGS_HEAPTYPE" title="Py_TPFLAGS_HEAPTYPE"><code>Py_TPFLAGS_HEAPTYPE</code></a>) must visit their type with:</p> <pre data-language="c">Py_VISIT(Py_TYPE(self));
</pre> <p>It is only needed since Python 3.9. To support Python 3.8 and older, this line must be conditional:</p> <pre data-language="c">#if PY_VERSION_HEX &gt;= 0x03090000
    Py_VISIT(Py_TYPE(self));
#endif
</pre> <p>If the <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code>Py_TPFLAGS_MANAGED_DICT</code></a> bit is set in the <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> field, the traverse function must call <a class="reference internal" href="object.html#c.PyObject_VisitManagedDict" title="PyObject_VisitManagedDict"><code>PyObject_VisitManagedDict()</code></a> like this:</p> <pre data-language="c">PyObject_VisitManagedDict((PyObject*)self, visit, arg);
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>When implementing <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a>, only the members that the instance <em>owns</em> (by having <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong references</span></a> to them) must be visited. For instance, if an object supports weak references via the <a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code>tp_weaklist</code></a> slot, the pointer supporting the linked list (what <em>tp_weaklist</em> points to) must <strong>not</strong> be visited as the instance does not directly own the weak references to itself (the weakreference list is there to support the weak reference machinery, but the instance has no strong reference to the elements inside it, as they are allowed to be removed even if the instance is still alive).</p> </div> <p>Note that <a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code>Py_VISIT()</code></a> requires the <em>visit</em> and <em>arg</em> parameters to <code>local_traverse()</code> to have these specific names; don’t name them just anything.</p> <p>Instances of <a class="reference internal" href="#heap-types"><span class="std std-ref">heap-allocated types</span></a> hold a reference to their type. Their traversal function must therefore either visit <a class="reference internal" href="structures.html#c.Py_TYPE" title="Py_TYPE"><code>Py_TYPE(self)</code></a>, or delegate this responsibility by calling <code>tp_traverse</code> of another heap-allocated type (such as a heap-allocated superclass). If they do not, the type object may not be garbage-collected.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>Heap-allocated types are expected to visit <code>Py_TYPE(self)</code> in <code>tp_traverse</code>. In earlier versions of Python, due to <a class="reference external" href="https://bugs.python.org/issue40217">bug 40217</a>, doing this may lead to crashes in subclasses.</p> </div> <p><strong>Inheritance:</strong></p> <p>Group: <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a></p> <p>This field is inherited by subtypes together with <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> and the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit: the flag bit, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a>, and <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> are all inherited from the base type if they are all zero in the subtype.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_clear">
<code>inquiry PyTypeObject.tp_clear</code> </dt> <dd>
<p>An optional pointer to a clear function for the garbage collector. This is only used if the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit is set. The signature is:</p> <pre data-language="c">int tp_clear(PyObject *);
</pre> <p>The <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> member function is used to break reference cycles in cyclic garbage detected by the garbage collector. Taken together, all <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> functions in the system must combine to break all reference cycles. This is subtle, and if in any doubt supply a <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> function. For example, the tuple type does not implement a <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> function, because it’s possible to prove that no reference cycle can be composed entirely of tuples. Therefore the <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> functions of other types must be sufficient to break any cycle containing a tuple. This isn’t immediately obvious, and there’s rarely a good reason to avoid implementing <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a>.</p> <p>Implementations of <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> should drop the instance’s references to those of its members that may be Python objects, and set its pointers to those members to <code>NULL</code>, as in the following example:</p> <pre data-language="c">static int
local_clear(localobject *self)
{
    Py_CLEAR(self-&gt;key);
    Py_CLEAR(self-&gt;args);
    Py_CLEAR(self-&gt;kw);
    Py_CLEAR(self-&gt;dict);
    return 0;
}
</pre> <p>The <a class="reference internal" href="refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code>Py_CLEAR()</code></a> macro should be used, because clearing references is delicate: the reference to the contained object must not be released (via <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a>) until after the pointer to the contained object is set to <code>NULL</code>. This is because releasing the reference may cause the contained object to become trash, triggering a chain of reclamation activity that may include invoking arbitrary Python code (due to finalizers, or weakref callbacks, associated with the contained object). If it’s possible for such code to reference <em>self</em> again, it’s important that the pointer to the contained object be <code>NULL</code> at that time, so that <em>self</em> knows the contained object can no longer be used. The <a class="reference internal" href="refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code>Py_CLEAR()</code></a> macro performs the operations in a safe order.</p> <p>If the <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code>Py_TPFLAGS_MANAGED_DICT</code></a> bit is set in the <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> field, the traverse function must call <a class="reference internal" href="object.html#c.PyObject_ClearManagedDict" title="PyObject_ClearManagedDict"><code>PyObject_ClearManagedDict()</code></a> like this:</p> <pre data-language="c">PyObject_ClearManagedDict((PyObject*)self);
</pre> <p>Note that <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> is not <em>always</em> called before an instance is deallocated. For example, when reference counting is enough to determine that an object is no longer used, the cyclic garbage collector is not involved and <a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a> is called directly.</p> <p>Because the goal of <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> functions is to break reference cycles, it’s not necessary to clear contained objects like Python strings or Python integers, which can’t participate in reference cycles. On the other hand, it may be convenient to clear all contained Python objects, and write the type’s <a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a> function to invoke <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a>.</p> <p>More information about Python’s garbage collection scheme can be found in section <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">Supporting Cyclic Garbage Collection</span></a>.</p> <p><strong>Inheritance:</strong></p> <p>Group: <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a></p> <p>This field is inherited by subtypes together with <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> and the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit: the flag bit, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a>, and <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> are all inherited from the base type if they are all zero in the subtype.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_richcompare">
<code>richcmpfunc PyTypeObject.tp_richcompare</code> </dt> <dd>
<p>An optional pointer to the rich comparison function, whose signature is:</p> <pre data-language="c">PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);
</pre> <p>The first parameter is guaranteed to be an instance of the type that is defined by <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a>.</p> <p>The function should return the result of the comparison (usually <code>Py_True</code> or <code>Py_False</code>). If the comparison is undefined, it must return <code>Py_NotImplemented</code>, if another error occurred it must return <code>NULL</code> and set an exception condition.</p> <p>The following constants are defined to be used as the third argument for <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a> and for <a class="reference internal" href="object.html#c.PyObject_RichCompare" title="PyObject_RichCompare"><code>PyObject_RichCompare()</code></a>:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Constant</p></th> <th class="head"><p>Comparison</p></th> </tr> </thead>  <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_LT">
<code>Py_LT</code> </dt> <dd></dd>
</dl> </td> <td><p><code>&lt;</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_LE">
<code>Py_LE</code> </dt> <dd></dd>
</dl> </td> <td><p><code>&lt;=</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_EQ">
<code>Py_EQ</code> </dt> <dd></dd>
</dl> </td> <td><p><code>==</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_NE">
<code>Py_NE</code> </dt> <dd></dd>
</dl> </td> <td><p><code>!=</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_GT">
<code>Py_GT</code> </dt> <dd></dd>
</dl> </td> <td><p><code>&gt;</code></p></td> </tr> <tr>
<td>
<dl class="c macro"> <dt class="sig sig-object c" id="c.Py_GE">
<code>Py_GE</code> </dt> <dd></dd>
</dl> </td> <td><p><code>&gt;=</code></p></td> </tr>  </table> <p>The following macro is defined to ease writing rich comparison functions:</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_RETURN_RICHCOMPARE">
<code>Py_RETURN_RICHCOMPARE(VAL_A, VAL_B, op)</code> </dt> <dd>
<p>Return <code>Py_True</code> or <code>Py_False</code> from the function, depending on the result of a comparison. VAL_A and VAL_B must be orderable by C comparison operators (for example, they may be C ints or floats). The third argument specifies the requested operation, as for <a class="reference internal" href="object.html#c.PyObject_RichCompare" title="PyObject_RichCompare"><code>PyObject_RichCompare()</code></a>.</p> <p>The returned value is a new <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a>.</p> <p>On error, sets an exception and returns <code>NULL</code> from the function.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.7.</span></p> </div> </dd>
</dl> <p><strong>Inheritance:</strong></p> <p>Group: <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code>tp_hash</code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a></p> <p>This field is inherited by subtypes together with <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code>tp_hash</code></a>: a subtype inherits <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code>tp_hash</code></a> when the subtype’s <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a> and <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code>tp_hash</code></a> are both <code>NULL</code>.</p> <p><strong>Default:</strong></p> <p><code>PyBaseObject_Type</code> provides a <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a> implementation, which may be inherited. However, if only <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code>tp_hash</code></a> is defined, not even the inherited function is used and instances of the type will not be able to participate in any comparisons.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_weaklistoffset">
<code>Py_ssize_t PyTypeObject.tp_weaklistoffset</code> </dt> <dd>
<p>While this field is still supported, <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code>Py_TPFLAGS_MANAGED_WEAKREF</code></a> should be used instead, if at all possible.</p> <p>If the instances of this type are weakly referenceable, this field is greater than zero and contains the offset in the instance structure of the weak reference list head (ignoring the GC header, if present); this offset is used by <a class="reference internal" href="weakref.html#c.PyObject_ClearWeakRefs" title="PyObject_ClearWeakRefs"><code>PyObject_ClearWeakRefs()</code></a> and the <code>PyWeakref_*</code> functions. The instance structure needs to include a field of type <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> which is initialized to <code>NULL</code>.</p> <p>Do not confuse this field with <a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code>tp_weaklist</code></a>; that is the list head for weak references to the type object itself.</p> <p>It is an error to set both the <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code>Py_TPFLAGS_MANAGED_WEAKREF</code></a> bit and <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code>tp_weaklistoffset</code></a>.</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes, but see the rules listed below. A subtype may override this offset; this means that the subtype uses a different weak reference list head than the base type. Since the list head is always found via <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code>tp_weaklistoffset</code></a>, this should not be a problem.</p> <p><strong>Default:</strong></p> <p>If the <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code>Py_TPFLAGS_MANAGED_WEAKREF</code></a> bit is set in the <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> field, then <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code>tp_weaklistoffset</code></a> will be set to a negative value, to indicate that it is unsafe to use this field.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_iter">
<code>getiterfunc PyTypeObject.tp_iter</code> </dt> <dd>
<p>An optional pointer to a function that returns an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> for the object. Its presence normally signals that the instances of this type are <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> (although sequences may be iterable without this function).</p> <p>This function has the same signature as <a class="reference internal" href="object.html#c.PyObject_GetIter" title="PyObject_GetIter"><code>PyObject_GetIter()</code></a>:</p> <pre data-language="c">PyObject *tp_iter(PyObject *self);
</pre> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_iternext">
<code>iternextfunc PyTypeObject.tp_iternext</code> </dt> <dd>
<p>An optional pointer to a function that returns the next item in an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>. The signature is:</p> <pre data-language="c">PyObject *tp_iternext(PyObject *self);
</pre> <p>When the iterator is exhausted, it must return <code>NULL</code>; a <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a> exception may or may not be set. When another error occurs, it must return <code>NULL</code> too. Its presence signals that the instances of this type are iterators.</p> <p>Iterator types should also define the <a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code>tp_iter</code></a> function, and that function should return the iterator instance itself (not a new iterator instance).</p> <p>This function has the same signature as <a class="reference internal" href="iter.html#c.PyIter_Next" title="PyIter_Next"><code>PyIter_Next()</code></a>.</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_methods">
<code>struct PyMethodDef *PyTypeObject.tp_methods</code> </dt> <dd>
<p>An optional pointer to a static <code>NULL</code>-terminated array of <a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef"><code>PyMethodDef</code></a> structures, declaring regular methods of this type.</p> <p>For each entry in the array, an entry is added to the type’s dictionary (see <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code>tp_dict</code></a> below) containing a method descriptor.</p> <p><strong>Inheritance:</strong></p> <p>This field is not inherited by subtypes (methods are inherited through a different mechanism).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_members">
<code>struct PyMemberDef *PyTypeObject.tp_members</code> </dt> <dd>
<p>An optional pointer to a static <code>NULL</code>-terminated array of <a class="reference internal" href="structures.html#c.PyMemberDef" title="PyMemberDef"><code>PyMemberDef</code></a> structures, declaring regular data members (fields or slots) of instances of this type.</p> <p>For each entry in the array, an entry is added to the type’s dictionary (see <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code>tp_dict</code></a> below) containing a member descriptor.</p> <p><strong>Inheritance:</strong></p> <p>This field is not inherited by subtypes (members are inherited through a different mechanism).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_getset">
<code>struct PyGetSetDef *PyTypeObject.tp_getset</code> </dt> <dd>
<p>An optional pointer to a static <code>NULL</code>-terminated array of <a class="reference internal" href="structures.html#c.PyGetSetDef" title="PyGetSetDef"><code>PyGetSetDef</code></a> structures, declaring computed attributes of instances of this type.</p> <p>For each entry in the array, an entry is added to the type’s dictionary (see <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code>tp_dict</code></a> below) containing a getset descriptor.</p> <p><strong>Inheritance:</strong></p> <p>This field is not inherited by subtypes (computed attributes are inherited through a different mechanism).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_base">
<code>PyTypeObject *PyTypeObject.tp_base</code> </dt> <dd>
<p>An optional pointer to a base type from which type properties are inherited. At this level, only single inheritance is supported; multiple inheritance require dynamically creating a type object by calling the metatype.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Slot initialization is subject to the rules of initializing globals. C99 requires the initializers to be “address constants”. Function designators like <a class="reference internal" href="type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code>PyType_GenericNew()</code></a>, with implicit conversion to a pointer, are valid C99 address constants.</p> <p>However, the unary ‘&amp;’ operator applied to a non-static variable like <code>PyBaseObject_Type</code> is not required to produce an address constant. Compilers may support this (gcc does), MSVC does not. Both compilers are strictly standard conforming in this particular behavior.</p> <p>Consequently, <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code>tp_base</code></a> should be set in the extension module’s init function.</p> </div> <p><strong>Inheritance:</strong></p> <p>This field is not inherited by subtypes (obviously).</p> <p><strong>Default:</strong></p> <p>This field defaults to <code>&amp;PyBaseObject_Type</code> (which to Python programmers is known as the type <a class="reference internal" href="../library/functions.html#object" title="object"><code>object</code></a>).</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_dict">
<code>PyObject *PyTypeObject.tp_dict</code> </dt> <dd>
<p>The type’s dictionary is stored here by <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a>.</p> <p>This field should normally be initialized to <code>NULL</code> before PyType_Ready is called; it may also be initialized to a dictionary containing initial attributes for the type. Once <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> has initialized the type, extra attributes for the type may be added to this dictionary only if they don’t correspond to overloaded operations (like <a class="reference internal" href="../reference/datamodel.html#object.__add__" title="object.__add__"><code>__add__()</code></a>). Once initialization for the type has finished, this field should be treated as read-only.</p> <p>Some types may not store their dictionary in this slot. Use <a class="reference internal" href="type.html#c.PyType_GetDict" title="PyType_GetDict"><code>PyType_GetDict()</code></a> to retrieve the dictionary for an arbitrary type.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Internals detail: For static builtin types, this is always <code>NULL</code>. Instead, the dict for such types is stored on <code>PyInterpreterState</code>. Use <a class="reference internal" href="type.html#c.PyType_GetDict" title="PyType_GetDict"><code>PyType_GetDict()</code></a> to get the dict for an arbitrary type.</p> </div> <p><strong>Inheritance:</strong></p> <p>This field is not inherited by subtypes (though the attributes defined in here are inherited through a different mechanism).</p> <p><strong>Default:</strong></p> <p>If this field is <code>NULL</code>, <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> will assign a new dictionary to it.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>It is not safe to use <a class="reference internal" href="dict.html#c.PyDict_SetItem" title="PyDict_SetItem"><code>PyDict_SetItem()</code></a> on or otherwise modify <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code>tp_dict</code></a> with the dictionary C-API.</p> </div> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_descr_get">
<code>descrgetfunc PyTypeObject.tp_descr_get</code> </dt> <dd>
<p>An optional pointer to a “descriptor get” function.</p> <p>The function signature is:</p> <pre data-language="c">PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);
</pre> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_descr_set">
<code>descrsetfunc PyTypeObject.tp_descr_set</code> </dt> <dd>
<p>An optional pointer to a function for setting and deleting a descriptor’s value.</p> <p>The function signature is:</p> <pre data-language="c">int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);
</pre> <p>The <em>value</em> argument is set to <code>NULL</code> to delete the value.</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_dictoffset">
<code>Py_ssize_t PyTypeObject.tp_dictoffset</code> </dt> <dd>
<p>While this field is still supported, <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code>Py_TPFLAGS_MANAGED_DICT</code></a> should be used instead, if at all possible.</p> <p>If the instances of this type have a dictionary containing instance variables, this field is non-zero and contains the offset in the instances of the type of the instance variable dictionary; this offset is used by <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code>PyObject_GenericGetAttr()</code></a>.</p> <p>Do not confuse this field with <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code>tp_dict</code></a>; that is the dictionary for attributes of the type object itself.</p> <p>The value specifies the offset of the dictionary from the start of the instance structure.</p> <p>The <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code>tp_dictoffset</code></a> should be regarded as write-only. To get the pointer to the dictionary call <a class="reference internal" href="object.html#c.PyObject_GenericGetDict" title="PyObject_GenericGetDict"><code>PyObject_GenericGetDict()</code></a>. Calling <a class="reference internal" href="object.html#c.PyObject_GenericGetDict" title="PyObject_GenericGetDict"><code>PyObject_GenericGetDict()</code></a> may need to allocate memory for the dictionary, so it is may be more efficient to call <a class="reference internal" href="object.html#c.PyObject_GetAttr" title="PyObject_GetAttr"><code>PyObject_GetAttr()</code></a> when accessing an attribute on the object.</p> <p>It is an error to set both the <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code>Py_TPFLAGS_MANAGED_WEAKREF</code></a> bit and <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code>tp_dictoffset</code></a>.</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes. A subtype should not override this offset; doing so could be unsafe, if C code tries to access the dictionary at the previous offset. To properly support inheritance, use <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code>Py_TPFLAGS_MANAGED_DICT</code></a>.</p> <p><strong>Default:</strong></p> <p>This slot has no default. For <a class="reference internal" href="#static-types"><span class="std std-ref">static types</span></a>, if the field is <code>NULL</code> then no <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> gets created for instances.</p> <p>If the <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code>Py_TPFLAGS_MANAGED_DICT</code></a> bit is set in the <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> field, then <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code>tp_dictoffset</code></a> will be set to <code>-1</code>, to indicate that it is unsafe to use this field.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_init">
<code>initproc PyTypeObject.tp_init</code> </dt> <dd>
<p>An optional pointer to an instance initialization function.</p> <p>This function corresponds to the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> method of classes. Like <code>__init__()</code>, it is possible to create an instance without calling <code>__init__()</code>, and it is possible to reinitialize an instance by calling its <code>__init__()</code> method again.</p> <p>The function signature is:</p> <pre data-language="c">int tp_init(PyObject *self, PyObject *args, PyObject *kwds);
</pre> <p>The self argument is the instance to be initialized; the <em>args</em> and <em>kwds</em> arguments represent positional and keyword arguments of the call to <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a>.</p> <p>The <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a> function, if not <code>NULL</code>, is called when an instance is created normally by calling its type, after the type’s <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> function has returned an instance of the type. If the <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> function returns an instance of some other type that is not a subtype of the original type, no <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a> function is called; if <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> returns an instance of a subtype of the original type, the subtype’s <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a> is called.</p> <p>Returns <code>0</code> on success, <code>-1</code> and sets an exception on error.</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> <p><strong>Default:</strong></p> <p>For <a class="reference internal" href="#static-types"><span class="std std-ref">static types</span></a> this field does not have a default.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_alloc">
<code>allocfunc PyTypeObject.tp_alloc</code> </dt> <dd>
<p>An optional pointer to an instance allocation function.</p> <p>The function signature is:</p> <pre data-language="c">PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);
</pre> <p><strong>Inheritance:</strong></p> <p>This field is inherited by static subtypes, but not by dynamic subtypes (subtypes created by a class statement).</p> <p><strong>Default:</strong></p> <p>For dynamic subtypes, this field is always set to <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code>PyType_GenericAlloc()</code></a>, to force a standard heap allocation strategy.</p> <p>For static subtypes, <code>PyBaseObject_Type</code> uses <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code>PyType_GenericAlloc()</code></a>. That is the recommended value for all statically defined types.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_new">
<code>newfunc PyTypeObject.tp_new</code> </dt> <dd>
<p>An optional pointer to an instance creation function.</p> <p>The function signature is:</p> <pre data-language="c">PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);
</pre> <p>The <em>subtype</em> argument is the type of the object being created; the <em>args</em> and <em>kwds</em> arguments represent positional and keyword arguments of the call to the type. Note that <em>subtype</em> doesn’t have to equal the type whose <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> function is called; it may be a subtype of that type (but not an unrelated type).</p> <p>The <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> function should call <code>subtype-&gt;tp_alloc(subtype, nitems)</code> to allocate space for the object, and then do only as much further initialization as is absolutely necessary. Initialization that can safely be ignored or repeated should be placed in the <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a> handler. A good rule of thumb is that for immutable types, all initialization should take place in <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a>, while for mutable types, most initialization should be deferred to <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a>.</p> <p>Set the <a class="reference internal" href="#c.Py_TPFLAGS_DISALLOW_INSTANTIATION" title="Py_TPFLAGS_DISALLOW_INSTANTIATION"><code>Py_TPFLAGS_DISALLOW_INSTANTIATION</code></a> flag to disallow creating instances of the type in Python.</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes, except it is not inherited by <a class="reference internal" href="#static-types"><span class="std std-ref">static types</span></a> whose <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code>tp_base</code></a> is <code>NULL</code> or <code>&amp;PyBaseObject_Type</code>.</p> <p><strong>Default:</strong></p> <p>For <a class="reference internal" href="#static-types"><span class="std std-ref">static types</span></a> this field has no default. This means if the slot is defined as <code>NULL</code>, the type cannot be called to create new instances; presumably there is some other way to create instances, like a factory function.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_free">
<code>freefunc PyTypeObject.tp_free</code> </dt> <dd>
<p>An optional pointer to an instance deallocation function. Its signature is:</p> <pre data-language="c">void tp_free(void *self);
</pre> <p>An initializer that is compatible with this signature is <a class="reference internal" href="memory.html#c.PyObject_Free" title="PyObject_Free"><code>PyObject_Free()</code></a>.</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by static subtypes, but not by dynamic subtypes (subtypes created by a class statement)</p> <p><strong>Default:</strong></p> <p>In dynamic subtypes, this field is set to a deallocator suitable to match <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code>PyType_GenericAlloc()</code></a> and the value of the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit.</p> <p>For static subtypes, <code>PyBaseObject_Type</code> uses <a class="reference internal" href="allocation.html#c.PyObject_Del" title="PyObject_Del"><code>PyObject_Del()</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_is_gc">
<code>inquiry PyTypeObject.tp_is_gc</code> </dt> <dd>
<p>An optional pointer to a function called by the garbage collector.</p> <p>The garbage collector needs to know whether a particular object is collectible or not. Normally, it is sufficient to look at the object’s type’s <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> field, and check the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag bit. But some types have a mixture of statically and dynamically allocated instances, and the statically allocated instances are not collectible. Such types should define this function; it should return <code>1</code> for a collectible instance, and <code>0</code> for a non-collectible instance. The signature is:</p> <pre data-language="c">int tp_is_gc(PyObject *self);
</pre> <p>(The only example of this are types themselves. The metatype, <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code>PyType_Type</code></a>, defines this function to distinguish between statically and <a class="reference internal" href="#heap-types"><span class="std std-ref">dynamically allocated types</span></a>.)</p> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> <p><strong>Default:</strong></p> <p>This slot has no default. If this field is <code>NULL</code>, <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> is used as the functional equivalent.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_bases">
<code>PyObject *PyTypeObject.tp_bases</code> </dt> <dd>
<p>Tuple of base types.</p> <p>This field should be set to <code>NULL</code> and treated as read-only. Python will fill it in when the type is <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>initialized</code></a>.</p> <p>For dynamically created classes, the <code>Py_tp_bases</code> <a class="reference internal" href="type.html#c.PyType_Slot" title="PyType_Slot"><code>slot</code></a> can be used instead of the <em>bases</em> argument of <a class="reference internal" href="type.html#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code>PyType_FromSpecWithBases()</code></a>. The argument form is preferred.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Multiple inheritance does not work well for statically defined types. If you set <code>tp_bases</code> to a tuple, Python will not raise an error, but some slots will only be inherited from the first base.</p> </div> <p><strong>Inheritance:</strong></p> <p>This field is not inherited.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_mro">
<code>PyObject *PyTypeObject.tp_mro</code> </dt> <dd>
<p>Tuple containing the expanded set of base types, starting with the type itself and ending with <a class="reference internal" href="../library/functions.html#object" title="object"><code>object</code></a>, in Method Resolution Order.</p> <p>This field should be set to <code>NULL</code> and treated as read-only. Python will fill it in when the type is <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>initialized</code></a>.</p> <p><strong>Inheritance:</strong></p> <p>This field is not inherited; it is calculated fresh by <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_cache">
<code>PyObject *PyTypeObject.tp_cache</code> </dt> <dd>
<p>Unused. Internal use only.</p> <p><strong>Inheritance:</strong></p> <p>This field is not inherited.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_subclasses">
<code>void *PyTypeObject.tp_subclasses</code> </dt> <dd>
<p>A collection of subclasses. Internal use only. May be an invalid pointer.</p> <p>To get a list of subclasses, call the Python method <a class="reference internal" href="../reference/datamodel.html#type.__subclasses__" title="type.__subclasses__"><code>__subclasses__()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>For some types, this field does not hold a valid <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>. The type was changed to <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> to indicate this.</p> </div> <p><strong>Inheritance:</strong></p> <p>This field is not inherited.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_weaklist">
<code>PyObject *PyTypeObject.tp_weaklist</code> </dt> <dd>
<p>Weak reference list head, for weak references to this type object. Not inherited. Internal use only.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Internals detail: For the static builtin types this is always <code>NULL</code>, even if weakrefs are added. Instead, the weakrefs for each are stored on <code>PyInterpreterState</code>. Use the public C-API or the internal <code>_PyObject_GET_WEAKREFS_LISTPTR()</code> macro to avoid the distinction.</p> </div> <p><strong>Inheritance:</strong></p> <p>This field is not inherited.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_del">
<code>destructor PyTypeObject.tp_del</code> </dt> <dd>
<p>This field is deprecated. Use <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code>tp_finalize</code></a> instead.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_version_tag">
<code>unsigned int PyTypeObject.tp_version_tag</code> </dt> <dd>
<p>Used to index into the method cache. Internal use only.</p> <p><strong>Inheritance:</strong></p> <p>This field is not inherited.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_finalize">
<code>destructor PyTypeObject.tp_finalize</code> </dt> <dd>
<p>An optional pointer to an instance finalization function. Its signature is:</p> <pre data-language="c">void tp_finalize(PyObject *self);
</pre> <p>If <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code>tp_finalize</code></a> is set, the interpreter calls it once when finalizing an instance. It is called either from the garbage collector (if the instance is part of an isolated reference cycle) or just before the object is deallocated. Either way, it is guaranteed to be called before attempting to break reference cycles, ensuring that it finds the object in a sane state.</p> <p><a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code>tp_finalize</code></a> should not mutate the current exception status; therefore, a recommended way to write a non-trivial finalizer is:</p> <pre data-language="c">static void
local_finalize(PyObject *self)
{
    PyObject *error_type, *error_value, *error_traceback;

    /* Save the current exception, if any. */
    PyErr_Fetch(&amp;error_type, &amp;error_value, &amp;error_traceback);

    /* ... */

    /* Restore the saved exception. */
    PyErr_Restore(error_type, error_value, error_traceback);
}
</pre> <p><strong>Inheritance:</strong></p> <p>This field is inherited by subtypes.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Before version 3.8 it was necessary to set the <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_FINALIZE" title="Py_TPFLAGS_HAVE_FINALIZE"><code>Py_TPFLAGS_HAVE_FINALIZE</code></a> flags bit in order for this field to be used. This is no longer required.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>“Safe object finalization” (<span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0442/"><strong>PEP 442</strong></a>)</p> </div> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_vectorcall">
<code>vectorcallfunc PyTypeObject.tp_vectorcall</code> </dt> <dd>
<p>Vectorcall function to use for calls of this type object. In other words, it is used to implement <a class="reference internal" href="call.html#vectorcall"><span class="std std-ref">vectorcall</span></a> for <code>type.__call__</code>. If <code>tp_vectorcall</code> is <code>NULL</code>, the default call implementation using <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> is used.</p> <p><strong>Inheritance:</strong></p> <p>This field is never inherited.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9: </span>(the field exists since 3.8 but it’s only used since 3.9)</p> </div> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyTypeObject.tp_watched">
<code>unsigned char PyTypeObject.tp_watched</code> </dt> <dd>
<p>Internal. Do not use.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> </section> <section id="static-types"> <span id="id4"></span><h2>Static Types</h2> <p>Traditionally, types defined in C code are <em>static</em>, that is, a static <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> structure is defined directly in code and initialized using <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a>.</p> <p>This results in types that are limited relative to types defined in Python:</p> <ul class="simple"> <li>Static types are limited to one base, i.e. they cannot use multiple inheritance.</li> <li>Static type objects (but not necessarily their instances) are immutable. It is not possible to add or modify the type object’s attributes from Python.</li> <li>Static type objects are shared across <a class="reference internal" href="init.html#sub-interpreter-support"><span class="std std-ref">sub-interpreters</span></a>, so they should not include any subinterpreter-specific state.</li> </ul> <p>Also, since <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> is only part of the <a class="reference internal" href="stable.html#limited-c-api"><span class="std std-ref">Limited API</span></a> as an opaque struct, any extension modules using static types must be compiled for a specific Python minor version.</p> </section> <section id="heap-types"> <span id="id5"></span><h2>Heap Types</h2> <p>An alternative to <a class="reference internal" href="#static-types"><span class="std std-ref">static types</span></a> is <em>heap-allocated types</em>, or <em>heap types</em> for short, which correspond closely to classes created by Python’s <code>class</code> statement. Heap types have the <a class="reference internal" href="#c.Py_TPFLAGS_HEAPTYPE" title="Py_TPFLAGS_HEAPTYPE"><code>Py_TPFLAGS_HEAPTYPE</code></a> flag set.</p> <p>This is done by filling a <a class="reference internal" href="type.html#c.PyType_Spec" title="PyType_Spec"><code>PyType_Spec</code></a> structure and calling <a class="reference internal" href="type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code>PyType_FromSpec()</code></a>, <a class="reference internal" href="type.html#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code>PyType_FromSpecWithBases()</code></a>, <a class="reference internal" href="type.html#c.PyType_FromModuleAndSpec" title="PyType_FromModuleAndSpec"><code>PyType_FromModuleAndSpec()</code></a>, or <a class="reference internal" href="type.html#c.PyType_FromMetaclass" title="PyType_FromMetaclass"><code>PyType_FromMetaclass()</code></a>.</p> </section> <section id="number-object-structures"> <span id="number-structs"></span><h2>Number Object Structures</h2> <dl class="c type"> <dt class="sig sig-object c" id="c.PyNumberMethods">
<code>type PyNumberMethods</code> </dt> <dd>
<p>This structure holds pointers to the functions which an object uses to implement the number protocol. Each function is used by the function of similar name documented in the <a class="reference internal" href="number.html#number"><span class="std std-ref">Number Protocol</span></a> section.</p> <p>Here is the structure definition:</p> <pre data-language="c">typedef struct {
     binaryfunc nb_add;
     binaryfunc nb_subtract;
     binaryfunc nb_multiply;
     binaryfunc nb_remainder;
     binaryfunc nb_divmod;
     ternaryfunc nb_power;
     unaryfunc nb_negative;
     unaryfunc nb_positive;
     unaryfunc nb_absolute;
     inquiry nb_bool;
     unaryfunc nb_invert;
     binaryfunc nb_lshift;
     binaryfunc nb_rshift;
     binaryfunc nb_and;
     binaryfunc nb_xor;
     binaryfunc nb_or;
     unaryfunc nb_int;
     void *nb_reserved;
     unaryfunc nb_float;

     binaryfunc nb_inplace_add;
     binaryfunc nb_inplace_subtract;
     binaryfunc nb_inplace_multiply;
     binaryfunc nb_inplace_remainder;
     ternaryfunc nb_inplace_power;
     binaryfunc nb_inplace_lshift;
     binaryfunc nb_inplace_rshift;
     binaryfunc nb_inplace_and;
     binaryfunc nb_inplace_xor;
     binaryfunc nb_inplace_or;

     binaryfunc nb_floor_divide;
     binaryfunc nb_true_divide;
     binaryfunc nb_inplace_floor_divide;
     binaryfunc nb_inplace_true_divide;

     unaryfunc nb_index;

     binaryfunc nb_matrix_multiply;
     binaryfunc nb_inplace_matrix_multiply;
} PyNumberMethods;
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Binary and ternary functions must check the type of all their operands, and implement the necessary conversions (at least one of the operands is an instance of the defined type). If the operation is not defined for the given operands, binary and ternary functions must return <code>Py_NotImplemented</code>, if another error occurred they must return <code>NULL</code> and set an exception.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="#c.PyNumberMethods.nb_reserved" title="PyNumberMethods.nb_reserved"><code>nb_reserved</code></a> field should always be <code>NULL</code>. It was previously called <code>nb_long</code>, and was renamed in Python 3.0.1.</p> </div> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_add">
<code>binaryfunc PyNumberMethods.nb_add</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_subtract">
<code>binaryfunc PyNumberMethods.nb_subtract</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_multiply">
<code>binaryfunc PyNumberMethods.nb_multiply</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_remainder">
<code>binaryfunc PyNumberMethods.nb_remainder</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_divmod">
<code>binaryfunc PyNumberMethods.nb_divmod</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_power">
<code>ternaryfunc PyNumberMethods.nb_power</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_negative">
<code>unaryfunc PyNumberMethods.nb_negative</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_positive">
<code>unaryfunc PyNumberMethods.nb_positive</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_absolute">
<code>unaryfunc PyNumberMethods.nb_absolute</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_bool">
<code>inquiry PyNumberMethods.nb_bool</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_invert">
<code>unaryfunc PyNumberMethods.nb_invert</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_lshift">
<code>binaryfunc PyNumberMethods.nb_lshift</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_rshift">
<code>binaryfunc PyNumberMethods.nb_rshift</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_and">
<code>binaryfunc PyNumberMethods.nb_and</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_xor">
<code>binaryfunc PyNumberMethods.nb_xor</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_or">
<code>binaryfunc PyNumberMethods.nb_or</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_int">
<code>unaryfunc PyNumberMethods.nb_int</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_reserved">
<code>void *PyNumberMethods.nb_reserved</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_float">
<code>unaryfunc PyNumberMethods.nb_float</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_add">
<code>binaryfunc PyNumberMethods.nb_inplace_add</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_subtract">
<code>binaryfunc PyNumberMethods.nb_inplace_subtract</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_multiply">
<code>binaryfunc PyNumberMethods.nb_inplace_multiply</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_remainder">
<code>binaryfunc PyNumberMethods.nb_inplace_remainder</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_power">
<code>ternaryfunc PyNumberMethods.nb_inplace_power</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_lshift">
<code>binaryfunc PyNumberMethods.nb_inplace_lshift</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_rshift">
<code>binaryfunc PyNumberMethods.nb_inplace_rshift</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_and">
<code>binaryfunc PyNumberMethods.nb_inplace_and</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_xor">
<code>binaryfunc PyNumberMethods.nb_inplace_xor</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_or">
<code>binaryfunc PyNumberMethods.nb_inplace_or</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_floor_divide">
<code>binaryfunc PyNumberMethods.nb_floor_divide</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_true_divide">
<code>binaryfunc PyNumberMethods.nb_true_divide</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_floor_divide">
<code>binaryfunc PyNumberMethods.nb_inplace_floor_divide</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_true_divide">
<code>binaryfunc PyNumberMethods.nb_inplace_true_divide</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_index">
<code>unaryfunc PyNumberMethods.nb_index</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_matrix_multiply">
<code>binaryfunc PyNumberMethods.nb_matrix_multiply</code> </dt> <dd></dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_matrix_multiply">
<code>binaryfunc PyNumberMethods.nb_inplace_matrix_multiply</code> </dt> <dd></dd>
</dl> </section> <section id="mapping-object-structures"> <span id="mapping-structs"></span><h2>Mapping Object Structures</h2> <dl class="c type"> <dt class="sig sig-object c" id="c.PyMappingMethods">
<code>type PyMappingMethods</code> </dt> <dd>
<p>This structure holds pointers to the functions which an object uses to implement the mapping protocol. It has three members:</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMappingMethods.mp_length">
<code>lenfunc PyMappingMethods.mp_length</code> </dt> <dd>
<p>This function is used by <a class="reference internal" href="mapping.html#c.PyMapping_Size" title="PyMapping_Size"><code>PyMapping_Size()</code></a> and <a class="reference internal" href="object.html#c.PyObject_Size" title="PyObject_Size"><code>PyObject_Size()</code></a>, and has the same signature. This slot may be set to <code>NULL</code> if the object has no defined length.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMappingMethods.mp_subscript">
<code>binaryfunc PyMappingMethods.mp_subscript</code> </dt> <dd>
<p>This function is used by <a class="reference internal" href="object.html#c.PyObject_GetItem" title="PyObject_GetItem"><code>PyObject_GetItem()</code></a> and <a class="reference internal" href="sequence.html#c.PySequence_GetSlice" title="PySequence_GetSlice"><code>PySequence_GetSlice()</code></a>, and has the same signature as <code>PyObject_GetItem()</code>. This slot must be filled for the <a class="reference internal" href="mapping.html#c.PyMapping_Check" title="PyMapping_Check"><code>PyMapping_Check()</code></a> function to return <code>1</code>, it can be <code>NULL</code> otherwise.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyMappingMethods.mp_ass_subscript">
<code>objobjargproc PyMappingMethods.mp_ass_subscript</code> </dt> <dd>
<p>This function is used by <a class="reference internal" href="object.html#c.PyObject_SetItem" title="PyObject_SetItem"><code>PyObject_SetItem()</code></a>, <a class="reference internal" href="object.html#c.PyObject_DelItem" title="PyObject_DelItem"><code>PyObject_DelItem()</code></a>, <a class="reference internal" href="sequence.html#c.PySequence_SetSlice" title="PySequence_SetSlice"><code>PySequence_SetSlice()</code></a> and <a class="reference internal" href="sequence.html#c.PySequence_DelSlice" title="PySequence_DelSlice"><code>PySequence_DelSlice()</code></a>. It has the same signature as <code>PyObject_SetItem()</code>, but <em>v</em> can also be set to <code>NULL</code> to delete an item. If this slot is <code>NULL</code>, the object does not support item assignment and deletion.</p> </dd>
</dl> </section> <section id="sequence-object-structures"> <span id="sequence-structs"></span><h2>Sequence Object Structures</h2> <dl class="c type"> <dt class="sig sig-object c" id="c.PySequenceMethods">
<code>type PySequenceMethods</code> </dt> <dd>
<p>This structure holds pointers to the functions which an object uses to implement the sequence protocol.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PySequenceMethods.sq_length">
<code>lenfunc PySequenceMethods.sq_length</code> </dt> <dd>
<p>This function is used by <a class="reference internal" href="sequence.html#c.PySequence_Size" title="PySequence_Size"><code>PySequence_Size()</code></a> and <a class="reference internal" href="object.html#c.PyObject_Size" title="PyObject_Size"><code>PyObject_Size()</code></a>, and has the same signature. It is also used for handling negative indices via the <a class="reference internal" href="#c.PySequenceMethods.sq_item" title="PySequenceMethods.sq_item"><code>sq_item</code></a> and the <a class="reference internal" href="#c.PySequenceMethods.sq_ass_item" title="PySequenceMethods.sq_ass_item"><code>sq_ass_item</code></a> slots.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PySequenceMethods.sq_concat">
<code>binaryfunc PySequenceMethods.sq_concat</code> </dt> <dd>
<p>This function is used by <a class="reference internal" href="sequence.html#c.PySequence_Concat" title="PySequence_Concat"><code>PySequence_Concat()</code></a> and has the same signature. It is also used by the <code>+</code> operator, after trying the numeric addition via the <a class="reference internal" href="#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code>nb_add</code></a> slot.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PySequenceMethods.sq_repeat">
<code>ssizeargfunc PySequenceMethods.sq_repeat</code> </dt> <dd>
<p>This function is used by <a class="reference internal" href="sequence.html#c.PySequence_Repeat" title="PySequence_Repeat"><code>PySequence_Repeat()</code></a> and has the same signature. It is also used by the <code>*</code> operator, after trying numeric multiplication via the <a class="reference internal" href="#c.PyNumberMethods.nb_multiply" title="PyNumberMethods.nb_multiply"><code>nb_multiply</code></a> slot.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PySequenceMethods.sq_item">
<code>ssizeargfunc PySequenceMethods.sq_item</code> </dt> <dd>
<p>This function is used by <a class="reference internal" href="sequence.html#c.PySequence_GetItem" title="PySequence_GetItem"><code>PySequence_GetItem()</code></a> and has the same signature. It is also used by <a class="reference internal" href="object.html#c.PyObject_GetItem" title="PyObject_GetItem"><code>PyObject_GetItem()</code></a>, after trying the subscription via the <a class="reference internal" href="#c.PyMappingMethods.mp_subscript" title="PyMappingMethods.mp_subscript"><code>mp_subscript</code></a> slot. This slot must be filled for the <a class="reference internal" href="sequence.html#c.PySequence_Check" title="PySequence_Check"><code>PySequence_Check()</code></a> function to return <code>1</code>, it can be <code>NULL</code> otherwise.</p> <p>Negative indexes are handled as follows: if the <a class="reference internal" href="#c.PySequenceMethods.sq_length" title="PySequenceMethods.sq_length"><code>sq_length</code></a> slot is filled, it is called and the sequence length is used to compute a positive index which is passed to <a class="reference internal" href="#c.PySequenceMethods.sq_item" title="PySequenceMethods.sq_item"><code>sq_item</code></a>. If <code>sq_length</code> is <code>NULL</code>, the index is passed as is to the function.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PySequenceMethods.sq_ass_item">
<code>ssizeobjargproc PySequenceMethods.sq_ass_item</code> </dt> <dd>
<p>This function is used by <a class="reference internal" href="sequence.html#c.PySequence_SetItem" title="PySequence_SetItem"><code>PySequence_SetItem()</code></a> and has the same signature. It is also used by <a class="reference internal" href="object.html#c.PyObject_SetItem" title="PyObject_SetItem"><code>PyObject_SetItem()</code></a> and <a class="reference internal" href="object.html#c.PyObject_DelItem" title="PyObject_DelItem"><code>PyObject_DelItem()</code></a>, after trying the item assignment and deletion via the <a class="reference internal" href="#c.PyMappingMethods.mp_ass_subscript" title="PyMappingMethods.mp_ass_subscript"><code>mp_ass_subscript</code></a> slot. This slot may be left to <code>NULL</code> if the object does not support item assignment and deletion.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PySequenceMethods.sq_contains">
<code>objobjproc PySequenceMethods.sq_contains</code> </dt> <dd>
<p>This function may be used by <a class="reference internal" href="sequence.html#c.PySequence_Contains" title="PySequence_Contains"><code>PySequence_Contains()</code></a> and has the same signature. This slot may be left to <code>NULL</code>, in this case <code>PySequence_Contains()</code> simply traverses the sequence until it finds a match.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PySequenceMethods.sq_inplace_concat">
<code>binaryfunc PySequenceMethods.sq_inplace_concat</code> </dt> <dd>
<p>This function is used by <a class="reference internal" href="sequence.html#c.PySequence_InPlaceConcat" title="PySequence_InPlaceConcat"><code>PySequence_InPlaceConcat()</code></a> and has the same signature. It should modify its first operand, and return it. This slot may be left to <code>NULL</code>, in this case <code>PySequence_InPlaceConcat()</code> will fall back to <a class="reference internal" href="sequence.html#c.PySequence_Concat" title="PySequence_Concat"><code>PySequence_Concat()</code></a>. It is also used by the augmented assignment <code>+=</code>, after trying numeric in-place addition via the <a class="reference internal" href="#c.PyNumberMethods.nb_inplace_add" title="PyNumberMethods.nb_inplace_add"><code>nb_inplace_add</code></a> slot.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PySequenceMethods.sq_inplace_repeat">
<code>ssizeargfunc PySequenceMethods.sq_inplace_repeat</code> </dt> <dd>
<p>This function is used by <a class="reference internal" href="sequence.html#c.PySequence_InPlaceRepeat" title="PySequence_InPlaceRepeat"><code>PySequence_InPlaceRepeat()</code></a> and has the same signature. It should modify its first operand, and return it. This slot may be left to <code>NULL</code>, in this case <code>PySequence_InPlaceRepeat()</code> will fall back to <a class="reference internal" href="sequence.html#c.PySequence_Repeat" title="PySequence_Repeat"><code>PySequence_Repeat()</code></a>. It is also used by the augmented assignment <code>*=</code>, after trying numeric in-place multiplication via the <a class="reference internal" href="#c.PyNumberMethods.nb_inplace_multiply" title="PyNumberMethods.nb_inplace_multiply"><code>nb_inplace_multiply</code></a> slot.</p> </dd>
</dl> </section> <section id="buffer-object-structures"> <span id="buffer-structs"></span><h2>Buffer Object Structures</h2> <dl class="c type"> <dt class="sig sig-object c" id="c.PyBufferProcs">
<code>type PyBufferProcs</code> </dt> <dd>
<p>This structure holds pointers to the functions required by the <a class="reference internal" href="buffer.html#bufferobjects"><span class="std std-ref">Buffer protocol</span></a>. The protocol defines how an exporter object can expose its internal data to consumer objects.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyBufferProcs.bf_getbuffer">
<code>getbufferproc PyBufferProcs.bf_getbuffer</code> </dt> <dd>
<p>The signature of this function is:</p> <pre data-language="c">int (PyObject *exporter, Py_buffer *view, int flags);
</pre> <p>Handle a request to <em>exporter</em> to fill in <em>view</em> as specified by <em>flags</em>. Except for point (3), an implementation of this function MUST take these steps:</p> <ol class="arabic simple"> <li>Check if the request can be met. If not, raise <a class="reference internal" href="../library/exceptions.html#BufferError" title="BufferError"><code>BufferError</code></a>, set <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span> to <code>NULL</code> and return <code>-1</code>.</li> <li>Fill in the requested fields.</li> <li>Increment an internal counter for the number of exports.</li> <li>Set <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span> to <em>exporter</em> and increment <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span>.</li> <li>Return <code>0</code>.</li> </ol> <p>If <em>exporter</em> is part of a chain or tree of buffer providers, two main schemes can be used:</p> <ul class="simple"> <li>Re-export: Each member of the tree acts as the exporting object and sets <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span> to a new reference to itself.</li> <li>Redirect: The buffer request is redirected to the root object of the tree. Here, <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span> will be a new reference to the root object.</li> </ul> <p>The individual fields of <em>view</em> are described in section <a class="reference internal" href="buffer.html#buffer-structure"><span class="std std-ref">Buffer structure</span></a>, the rules how an exporter must react to specific requests are in section <a class="reference internal" href="buffer.html#buffer-request-types"><span class="std std-ref">Buffer request types</span></a>.</p> <p>All memory pointed to in the <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code>Py_buffer</code></a> structure belongs to the exporter and must remain valid until there are no consumers left. <a class="reference internal" href="buffer.html#c.Py_buffer.format" title="Py_buffer.format"><code>format</code></a>, <a class="reference internal" href="buffer.html#c.Py_buffer.shape" title="Py_buffer.shape"><code>shape</code></a>, <a class="reference internal" href="buffer.html#c.Py_buffer.strides" title="Py_buffer.strides"><code>strides</code></a>, <a class="reference internal" href="buffer.html#c.Py_buffer.suboffsets" title="Py_buffer.suboffsets"><code>suboffsets</code></a> and <a class="reference internal" href="buffer.html#c.Py_buffer.internal" title="Py_buffer.internal"><code>internal</code></a> are read-only for the consumer.</p> <p><a class="reference internal" href="buffer.html#c.PyBuffer_FillInfo" title="PyBuffer_FillInfo"><code>PyBuffer_FillInfo()</code></a> provides an easy way of exposing a simple bytes buffer while dealing correctly with all request types.</p> <p><a class="reference internal" href="buffer.html#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code>PyObject_GetBuffer()</code></a> is the interface for the consumer that wraps this function.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyBufferProcs.bf_releasebuffer">
<code>releasebufferproc PyBufferProcs.bf_releasebuffer</code> </dt> <dd>
<p>The signature of this function is:</p> <pre data-language="c">void (PyObject *exporter, Py_buffer *view);
</pre> <p>Handle a request to release the resources of the buffer. If no resources need to be released, <a class="reference internal" href="#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code>PyBufferProcs.bf_releasebuffer</code></a> may be <code>NULL</code>. Otherwise, a standard implementation of this function will take these optional steps:</p> <ol class="arabic simple"> <li>Decrement an internal counter for the number of exports.</li> <li>If the counter is <code>0</code>, free all memory associated with <em>view</em>.</li> </ol> <p>The exporter MUST use the <a class="reference internal" href="buffer.html#c.Py_buffer.internal" title="Py_buffer.internal"><code>internal</code></a> field to keep track of buffer-specific resources. This field is guaranteed to remain constant, while a consumer MAY pass a copy of the original buffer as the <em>view</em> argument.</p> <p>This function MUST NOT decrement <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span>, since that is done automatically in <a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code>PyBuffer_Release()</code></a> (this scheme is useful for breaking reference cycles).</p> <p><a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code>PyBuffer_Release()</code></a> is the interface for the consumer that wraps this function.</p> </dd>
</dl> </section> <section id="async-object-structures"> <span id="async-structs"></span><h2>Async Object Structures</h2> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> <dl class="c type"> <dt class="sig sig-object c" id="c.PyAsyncMethods">
<code>type PyAsyncMethods</code> </dt> <dd>
<p>This structure holds pointers to the functions required to implement <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> and <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> objects.</p> <p>Here is the structure definition:</p> <pre data-language="c">typedef struct {
    unaryfunc am_await;
    unaryfunc am_aiter;
    unaryfunc am_anext;
    sendfunc am_send;
} PyAsyncMethods;
</pre> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyAsyncMethods.am_await">
<code>unaryfunc PyAsyncMethods.am_await</code> </dt> <dd>
<p>The signature of this function is:</p> <pre data-language="c">PyObject *am_await(PyObject *self);
</pre> <p>The returned object must be an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>, i.e. <a class="reference internal" href="iter.html#c.PyIter_Check" title="PyIter_Check"><code>PyIter_Check()</code></a> must return <code>1</code> for it.</p> <p>This slot may be set to <code>NULL</code> if an object is not an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyAsyncMethods.am_aiter">
<code>unaryfunc PyAsyncMethods.am_aiter</code> </dt> <dd>
<p>The signature of this function is:</p> <pre data-language="c">PyObject *am_aiter(PyObject *self);
</pre> <p>Must return an <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> object. See <a class="reference internal" href="../reference/datamodel.html#object.__anext__" title="object.__anext__"><code>__anext__()</code></a> for details.</p> <p>This slot may be set to <code>NULL</code> if an object does not implement asynchronous iteration protocol.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyAsyncMethods.am_anext">
<code>unaryfunc PyAsyncMethods.am_anext</code> </dt> <dd>
<p>The signature of this function is:</p> <pre data-language="c">PyObject *am_anext(PyObject *self);
</pre> <p>Must return an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object. See <a class="reference internal" href="../reference/datamodel.html#object.__anext__" title="object.__anext__"><code>__anext__()</code></a> for details. This slot may be set to <code>NULL</code>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyAsyncMethods.am_send">
<code>sendfunc PyAsyncMethods.am_send</code> </dt> <dd>
<p>The signature of this function is:</p> <pre data-language="c">PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);
</pre> <p>See <a class="reference internal" href="iter.html#c.PyIter_Send" title="PyIter_Send"><code>PyIter_Send()</code></a> for details. This slot may be set to <code>NULL</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> </section> <section id="slot-type-typedefs"> <span id="id6"></span><h2>Slot Type typedefs</h2> <dl class="c type"> <dt class="sig sig-object c" id="c.allocfunc">
<code>typedef PyObject *(*allocfunc)(PyTypeObject *cls, Py_ssize_t nitems)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>The purpose of this function is to separate memory allocation from memory initialization. It should return a pointer to a block of memory of adequate length for the instance, suitably aligned, and initialized to zeros, but with <a class="reference internal" href="#c.PyObject.ob_refcnt" title="PyObject.ob_refcnt"><code>ob_refcnt</code></a> set to <code>1</code> and <a class="reference internal" href="#c.PyObject.ob_type" title="PyObject.ob_type"><code>ob_type</code></a> set to the type argument. If the type’s <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a> is non-zero, the object’s <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code>ob_size</code></a> field should be initialized to <em>nitems</em> and the length of the allocated memory block should be <code>tp_basicsize + nitems*tp_itemsize</code>, rounded up to a multiple of <code>sizeof(void*)</code>; otherwise, <em>nitems</em> is not used and the length of the block should be <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a>.</p> <p>This function should not do any other instance initialization, not even to allocate additional memory; that should be done by <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.destructor">
<code>typedef void (*destructor)(PyObject*)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em></dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.freefunc">
<code>typedef void (*freefunc)(void*)</code> </dt> <dd>
<p>See <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code>tp_free</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.newfunc">
<code>typedef PyObject *(*newfunc)(PyObject*, PyObject*, PyObject*)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>See <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.initproc">
<code>typedef int (*initproc)(PyObject*, PyObject*, PyObject*)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>See <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.reprfunc">
<code>typedef PyObject *(*reprfunc)(PyObject*)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>See <a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code>tp_repr</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.getattrfunc">
<code>typedef PyObject *(*getattrfunc)(PyObject *self, char *attr)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the value of the named attribute for the object.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.setattrfunc">
<code>typedef int (*setattrfunc)(PyObject *self, char *attr, PyObject *value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Set the value of the named attribute for the object. The value argument is set to <code>NULL</code> to delete the attribute.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.getattrofunc">
<code>typedef PyObject *(*getattrofunc)(PyObject *self, PyObject *attr)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the value of the named attribute for the object.</p> <p>See <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code>tp_getattro</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.setattrofunc">
<code>typedef int (*setattrofunc)(PyObject *self, PyObject *attr, PyObject *value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Set the value of the named attribute for the object. The value argument is set to <code>NULL</code> to delete the attribute.</p> <p>See <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code>tp_setattro</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.descrgetfunc">
<code>typedef PyObject *(*descrgetfunc)(PyObject*, PyObject*, PyObject*)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>See <a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code>tp_descr_get</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.descrsetfunc">
<code>typedef int (*descrsetfunc)(PyObject*, PyObject*, PyObject*)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>See <a class="reference internal" href="#c.PyTypeObject.tp_descr_set" title="PyTypeObject.tp_descr_set"><code>tp_descr_set</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.hashfunc">
<code>typedef Py_hash_t (*hashfunc)(PyObject*)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>See <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code>tp_hash</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.richcmpfunc">
<code>typedef PyObject *(*richcmpfunc)(PyObject*, PyObject*, int)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>See <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code>tp_richcompare</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.getiterfunc">
<code>typedef PyObject *(*getiterfunc)(PyObject*)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>See <a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code>tp_iter</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.iternextfunc">
<code>typedef PyObject *(*iternextfunc)(PyObject*)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>See <a class="reference internal" href="#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code>tp_iternext</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.lenfunc">
<code>typedef Py_ssize_t (*lenfunc)(PyObject*)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em></dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.getbufferproc">
<code>typedef int (*getbufferproc)(PyObject*, Py_buffer*, int)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em></dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.releasebufferproc">
<code>typedef void (*releasebufferproc)(PyObject*, Py_buffer*)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em></dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.unaryfunc">
<code>typedef PyObject *(*unaryfunc)(PyObject*)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em></dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.binaryfunc">
<code>typedef PyObject *(*binaryfunc)(PyObject*, PyObject*)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em></dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.sendfunc">
<code>typedef PySendResult (*sendfunc)(PyObject*, PyObject*, PyObject**)</code> </dt> <dd>
<p>See <a class="reference internal" href="#c.PyAsyncMethods.am_send" title="PyAsyncMethods.am_send"><code>am_send</code></a>.</p> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.ternaryfunc">
<code>typedef PyObject *(*ternaryfunc)(PyObject*, PyObject*, PyObject*)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em></dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.ssizeargfunc">
<code>typedef PyObject *(*ssizeargfunc)(PyObject*, Py_ssize_t)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em></dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.ssizeobjargproc">
<code>typedef int (*ssizeobjargproc)(PyObject*, Py_ssize_t, PyObject*)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em></dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.objobjproc">
<code>typedef int (*objobjproc)(PyObject*, PyObject*)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em></dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.objobjargproc">
<code>typedef int (*objobjargproc)(PyObject*, PyObject*, PyObject*)</code> </dt> <dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em></dd>
</dl> </section> <section id="examples"> <span id="typedef-examples"></span><h2>Examples</h2> <p>The following are simple examples of Python type definitions. They include common usage you may encounter. Some demonstrate tricky corner cases. For more examples, practical info, and a tutorial, see <a class="reference internal" href="../extending/newtypes_tutorial.html#defining-new-types"><span class="std std-ref">Defining Extension Types: Tutorial</span></a> and <a class="reference internal" href="../extending/newtypes.html#new-types-topics"><span class="std std-ref">Defining Extension Types: Assorted Topics</span></a>.</p> <p>A basic <a class="reference internal" href="#static-types"><span class="std std-ref">static type</span></a>:</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
    const char *data;
} MyObject;

static PyTypeObject MyObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "mymod.MyObject",
    .tp_basicsize = sizeof(MyObject),
    .tp_doc = PyDoc_STR("My objects"),
    .tp_new = myobj_new,
    .tp_dealloc = (destructor)myobj_dealloc,
    .tp_repr = (reprfunc)myobj_repr,
};
</pre> <p>You may also find older code (especially in the CPython code base) with a more verbose initializer:</p> <pre data-language="c">static PyTypeObject MyObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "mymod.MyObject",               /* tp_name */
    sizeof(MyObject),               /* tp_basicsize */
    0,                              /* tp_itemsize */
    (destructor)myobj_dealloc,      /* tp_dealloc */
    0,                              /* tp_vectorcall_offset */
    0,                              /* tp_getattr */
    0,                              /* tp_setattr */
    0,                              /* tp_as_async */
    (reprfunc)myobj_repr,           /* tp_repr */
    0,                              /* tp_as_number */
    0,                              /* tp_as_sequence */
    0,                              /* tp_as_mapping */
    0,                              /* tp_hash */
    0,                              /* tp_call */
    0,                              /* tp_str */
    0,                              /* tp_getattro */
    0,                              /* tp_setattro */
    0,                              /* tp_as_buffer */
    0,                              /* tp_flags */
    PyDoc_STR("My objects"),        /* tp_doc */
    0,                              /* tp_traverse */
    0,                              /* tp_clear */
    0,                              /* tp_richcompare */
    0,                              /* tp_weaklistoffset */
    0,                              /* tp_iter */
    0,                              /* tp_iternext */
    0,                              /* tp_methods */
    0,                              /* tp_members */
    0,                              /* tp_getset */
    0,                              /* tp_base */
    0,                              /* tp_dict */
    0,                              /* tp_descr_get */
    0,                              /* tp_descr_set */
    0,                              /* tp_dictoffset */
    0,                              /* tp_init */
    0,                              /* tp_alloc */
    myobj_new,                      /* tp_new */
};
</pre> <p>A type that supports weakrefs, instance dicts, and hashing:</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
    const char *data;
} MyObject;

static PyTypeObject MyObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "mymod.MyObject",
    .tp_basicsize = sizeof(MyObject),
    .tp_doc = PyDoc_STR("My objects"),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |
         Py_TPFLAGS_MANAGED_WEAKREF,
    .tp_new = myobj_new,
    .tp_traverse = (traverseproc)myobj_traverse,
    .tp_clear = (inquiry)myobj_clear,
    .tp_alloc = PyType_GenericNew,
    .tp_dealloc = (destructor)myobj_dealloc,
    .tp_repr = (reprfunc)myobj_repr,
    .tp_hash = (hashfunc)myobj_hash,
    .tp_richcompare = PyBaseObject_Type.tp_richcompare,
};
</pre> <p>A str subclass that cannot be subclassed and cannot be called to create instances (e.g. uses a separate factory func) using <a class="reference internal" href="#c.Py_TPFLAGS_DISALLOW_INSTANTIATION" title="Py_TPFLAGS_DISALLOW_INSTANTIATION"><code>Py_TPFLAGS_DISALLOW_INSTANTIATION</code></a> flag:</p> <pre data-language="c">typedef struct {
    PyUnicodeObject raw;
    char *extra;
} MyStr;

static PyTypeObject MyStr_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "mymod.MyStr",
    .tp_basicsize = sizeof(MyStr),
    .tp_base = NULL,  // set to &amp;PyUnicode_Type in module init
    .tp_doc = PyDoc_STR("my custom str"),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,
    .tp_repr = (reprfunc)myobj_repr,
};
</pre> <p>The simplest <a class="reference internal" href="#static-types"><span class="std std-ref">static type</span></a> with fixed-length instances:</p> <pre data-language="c">typedef struct {
    PyObject_HEAD
} MyObject;

static PyTypeObject MyObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "mymod.MyObject",
};
</pre> <p>The simplest <a class="reference internal" href="#static-types"><span class="std std-ref">static type</span></a> with variable-length instances:</p> <pre data-language="c">typedef struct {
    PyObject_VAR_HEAD
    const char *data[1];
} MyObject;

static PyTypeObject MyObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "mymod.MyObject",
    .tp_basicsize = sizeof(MyObject) - sizeof(char *),
    .tp_itemsize = sizeof(char *),
};
</pre> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/typeobj.html" class="_attribution-link">https://docs.python.org/3.13/c-api/typeobj.html</a>
  </p>
</div>
