 <span id="number"></span><h1>Number Protocol</h1> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Check">
<code>int PyNumber_Check(PyObject *o)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns <code>1</code> if the object <em>o</em> provides numeric protocols, and false otherwise. This function always succeeds.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Returns <code>1</code> if <em>o</em> is an index integer.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Add">
<code>PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the result of adding <em>o1</em> and <em>o2</em>, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 + o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Subtract">
<code>PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the result of subtracting <em>o2</em> from <em>o1</em>, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 - o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Multiply">
<code>PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the result of multiplying <em>o1</em> and <em>o2</em>, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 * o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_MatrixMultiply">
<code>PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Returns the result of matrix multiplication on <em>o1</em> and <em>o2</em>, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 @ o2</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_FloorDivide">
<code>PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the floor of <em>o1</em> divided by <em>o2</em>, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 // o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_TrueDivide">
<code>PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a reasonable approximation for the mathematical value of <em>o1</em> divided by <em>o2</em>, or <code>NULL</code> on failure. The return value is “approximate” because binary floating-point numbers are approximate; it is not possible to represent all real numbers in base two. This function can return a floating-point value when passed two integers. This is the equivalent of the Python expression <code>o1 / o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Remainder">
<code>PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the remainder of dividing <em>o1</em> by <em>o2</em>, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 % o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Divmod">
<code>PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-0">See the built-in function <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code>divmod()</code></a>. Returns <code>NULL</code> on failure. This is the equivalent of the Python expression <code>divmod(o1, o2)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Power">
<code>PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-1">See the built-in function <a class="reference internal" href="../library/functions.html#pow" title="pow"><code>pow()</code></a>. Returns <code>NULL</code> on failure. This is the equivalent of the Python expression <code>pow(o1, o2, o3)</code>, where <em>o3</em> is optional. If <em>o3</em> is to be ignored, pass <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code>Py_None</code></a> in its place (passing <code>NULL</code> for <em>o3</em> would cause an illegal memory access).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Negative">
<code>PyObject *PyNumber_Negative(PyObject *o)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the negation of <em>o</em> on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>-o</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Positive">
<code>PyObject *PyNumber_Positive(PyObject *o)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns <em>o</em> on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>+o</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Absolute">
<code>PyObject *PyNumber_Absolute(PyObject *o)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-2">Returns the absolute value of <em>o</em>, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>abs(o)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Invert">
<code>PyObject *PyNumber_Invert(PyObject *o)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the bitwise negation of <em>o</em> on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>~o</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Lshift">
<code>PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the result of left shifting <em>o1</em> by <em>o2</em> on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 &lt;&lt; o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Rshift">
<code>PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the result of right shifting <em>o1</em> by <em>o2</em> on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 &gt;&gt; o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_And">
<code>PyObject *PyNumber_And(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the “bitwise and” of <em>o1</em> and <em>o2</em> on success and <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 &amp; o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Xor">
<code>PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the “bitwise exclusive or” of <em>o1</em> by <em>o2</em> on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 ^ o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Or">
<code>PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the “bitwise or” of <em>o1</em> and <em>o2</em> on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>o1 | o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceAdd">
<code>PyObject *PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the result of adding <em>o1</em> and <em>o2</em>, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 += o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceSubtract">
<code>PyObject *PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the result of subtracting <em>o2</em> from <em>o1</em>, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 -= o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceMultiply">
<code>PyObject *PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the result of multiplying <em>o1</em> and <em>o2</em>, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 *= o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceMatrixMultiply">
<code>PyObject *PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Returns the result of matrix multiplication on <em>o1</em> and <em>o2</em>, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 @= o2</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceFloorDivide">
<code>PyObject *PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the mathematical floor of dividing <em>o1</em> by <em>o2</em>, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 //= o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceTrueDivide">
<code>PyObject *PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a reasonable approximation for the mathematical value of <em>o1</em> divided by <em>o2</em>, or <code>NULL</code> on failure. The return value is “approximate” because binary floating-point numbers are approximate; it is not possible to represent all real numbers in base two. This function can return a floating-point value when passed two integers. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 /= o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceRemainder">
<code>PyObject *PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the remainder of dividing <em>o1</em> by <em>o2</em>, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 %= o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlacePower">
<code>PyObject *PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-3">See the built-in function <a class="reference internal" href="../library/functions.html#pow" title="pow"><code>pow()</code></a>. Returns <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 **= o2</code> when o3 is <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code>Py_None</code></a>, or an in-place variant of <code>pow(o1, o2, o3)</code> otherwise. If <em>o3</em> is to be ignored, pass <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code>Py_None</code></a> in its place (passing <code>NULL</code> for <em>o3</em> would cause an illegal memory access).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceLshift">
<code>PyObject *PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the result of left shifting <em>o1</em> by <em>o2</em> on success, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 &lt;&lt;= o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceRshift">
<code>PyObject *PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the result of right shifting <em>o1</em> by <em>o2</em> on success, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 &gt;&gt;= o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceAnd">
<code>PyObject *PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the “bitwise and” of <em>o1</em> and <em>o2</em> on success and <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 &amp;= o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceXor">
<code>PyObject *PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the “bitwise exclusive or” of <em>o1</em> by <em>o2</em> on success, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 ^= o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_InPlaceOr">
<code>PyObject *PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the “bitwise or” of <em>o1</em> and <em>o2</em> on success, or <code>NULL</code> on failure. The operation is done <em>in-place</em> when <em>o1</em> supports it. This is the equivalent of the Python statement <code>o1 |= o2</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Long">
<code>PyObject *PyNumber_Long(PyObject *o)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-4">Returns the <em>o</em> converted to an integer object on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>int(o)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Float">
<code>PyObject *PyNumber_Float(PyObject *o)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-5">Returns the <em>o</em> converted to a float object on success, or <code>NULL</code> on failure. This is the equivalent of the Python expression <code>float(o)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_Index">
<code>PyObject *PyNumber_Index(PyObject *o)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the <em>o</em> converted to a Python int on success or <code>NULL</code> with a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> exception raised on failure.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The result always has exact type <a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a>. Previously, the result could have been an instance of a subclass of <code>int</code>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_ToBase">
<code>PyObject *PyNumber_ToBase(PyObject *n, int base)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the integer <em>n</em> converted to base <em>base</em> as a string. The <em>base</em> argument must be one of 2, 8, 10, or 16. For base 2, 8, or 16, the returned string is prefixed with a base marker of <code>'0b'</code>, <code>'0o'</code>, or <code>'0x'</code>, respectively. If <em>n</em> is not a Python int, it is converted with <a class="reference internal" href="#c.PyNumber_Index" title="PyNumber_Index"><code>PyNumber_Index()</code></a> first.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyNumber_AsSsize_t">
<code>Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns <em>o</em> converted to a <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a> value if <em>o</em> can be interpreted as an integer. If the call fails, an exception is raised and <code>-1</code> is returned.</p> <p>If <em>o</em> can be converted to a Python int but the attempt to convert to a <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a> value would raise an <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>, then the <em>exc</em> argument is the type of exception that will be raised (usually <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a> or <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>). If <em>exc</em> is <code>NULL</code>, then the exception is cleared and the value is clipped to <code>PY_SSIZE_T_MIN</code> for a negative integer or <code>PY_SSIZE_T_MAX</code> for a positive integer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyIndex_Check">
<code>int PyIndex_Check(PyObject *o)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.8.</em><p>Returns <code>1</code> if <em>o</em> is an index integer (has the <code>nb_index</code> slot of the <code>tp_as_number</code> structure filled in), and <code>0</code> otherwise. This function always succeeds.</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/number.html" class="_attribution-link">https://docs.python.org/3.13/c-api/number.html</a>
  </p>
</div>
