 <span id="moduleobjects"></span><h1>Module Objects</h1> <dl class="c var" id="index-0"> <dt class="sig sig-object c" id="c.PyModule_Type">
<code>PyTypeObject PyModule_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-1">This instance of <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> represents the Python module type. This is exposed to Python programs as <code>types.ModuleType</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_Check">
<code>int PyModule_Check(PyObject *p)</code> </dt> <dd>
<p>Return true if <em>p</em> is a module object, or a subtype of a module object. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_CheckExact">
<code>int PyModule_CheckExact(PyObject *p)</code> </dt> <dd>
<p>Return true if <em>p</em> is a module object, but not a subtype of <a class="reference internal" href="#c.PyModule_Type" title="PyModule_Type"><code>PyModule_Type</code></a>. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_NewObject">
<code>PyObject *PyModule_NewObject(PyObject *name)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p id="index-2">Return a new module object with <a class="reference internal" href="../reference/datamodel.html#module.__name__" title="module.__name__"><code>module.__name__</code></a> set to <em>name</em>. The module’s <code>__name__</code>, <a class="reference internal" href="../reference/datamodel.html#module.__doc__" title="module.__doc__"><code>__doc__</code></a>, <a class="reference internal" href="../reference/datamodel.html#module.__package__" title="module.__package__"><code>__package__</code></a> and <a class="reference internal" href="../reference/datamodel.html#module.__loader__" title="module.__loader__"><code>__loader__</code></a> attributes are filled in (all but <code>__name__</code> are set to <code>None</code>). The caller is responsible for setting a <a class="reference internal" href="../reference/datamodel.html#module.__file__" title="module.__file__"><code>__file__</code></a> attribute.</p> <p>Return <code>NULL</code> with an exception set on error.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span><a class="reference internal" href="../reference/datamodel.html#module.__package__" title="module.__package__"><code>__package__</code></a> and <a class="reference internal" href="../reference/datamodel.html#module.__loader__" title="module.__loader__"><code>__loader__</code></a> are now set to <code>None</code>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_New">
<code>PyObject *PyModule_New(const char *name)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Similar to <a class="reference internal" href="#c.PyModule_NewObject" title="PyModule_NewObject"><code>PyModule_NewObject()</code></a>, but the name is a UTF-8 encoded string instead of a Unicode object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_GetDict">
<code>PyObject *PyModule_GetDict(PyObject *module)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-3">Return the dictionary object that implements <em>module</em>’s namespace; this object is the same as the <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> attribute of the module object. If <em>module</em> is not a module object (or a subtype of a module object), <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code>SystemError</code></a> is raised and <code>NULL</code> is returned.</p> <p>It is recommended extensions use other <code>PyModule_*</code> and <code>PyObject_*</code> functions rather than directly manipulate a module’s <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_GetNameObject">
<code>PyObject *PyModule_GetNameObject(PyObject *module)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p id="index-4">Return <em>module</em>’s <a class="reference internal" href="../reference/datamodel.html#module.__name__" title="module.__name__"><code>__name__</code></a> value. If the module does not provide one, or if it is not a string, <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code>SystemError</code></a> is raised and <code>NULL</code> is returned.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_GetName">
<code>const char *PyModule_GetName(PyObject *module)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Similar to <a class="reference internal" href="#c.PyModule_GetNameObject" title="PyModule_GetNameObject"><code>PyModule_GetNameObject()</code></a> but return the name encoded to <code>'utf-8'</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_GetState">
<code>void *PyModule_GetState(PyObject *module)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the “state” of the module, that is, a pointer to the block of memory allocated at module creation time, or <code>NULL</code>. See <a class="reference internal" href="#c.PyModuleDef.m_size" title="PyModuleDef.m_size"><code>PyModuleDef.m_size</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_GetDef">
<code>PyModuleDef *PyModule_GetDef(PyObject *module)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a pointer to the <a class="reference internal" href="#c.PyModuleDef" title="PyModuleDef"><code>PyModuleDef</code></a> struct from which the module was created, or <code>NULL</code> if the module wasn’t created from a definition.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_GetFilenameObject">
<code>PyObject *PyModule_GetFilenameObject(PyObject *module)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-5">Return the name of the file from which <em>module</em> was loaded using <em>module</em>’s <a class="reference internal" href="../reference/datamodel.html#module.__file__" title="module.__file__"><code>__file__</code></a> attribute. If this is not defined, or if it is not a string, raise <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code>SystemError</code></a> and return <code>NULL</code>; otherwise return a reference to a Unicode object.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_GetFilename">
<code>const char *PyModule_GetFilename(PyObject *module)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Similar to <a class="reference internal" href="#c.PyModule_GetFilenameObject" title="PyModule_GetFilenameObject"><code>PyModule_GetFilenameObject()</code></a> but return the filename encoded to ‘utf-8’.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.2: </span><a class="reference internal" href="#c.PyModule_GetFilename" title="PyModule_GetFilename"><code>PyModule_GetFilename()</code></a> raises <a class="reference internal" href="../library/exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code>UnicodeEncodeError</code></a> on unencodable filenames, use <a class="reference internal" href="#c.PyModule_GetFilenameObject" title="PyModule_GetFilenameObject"><code>PyModule_GetFilenameObject()</code></a> instead.</p> </div> </dd>
</dl> <section id="initializing-c-modules"> <span id="initializing-modules"></span><h2>Initializing C modules</h2> <p>Modules objects are usually created from extension modules (shared libraries which export an initialization function), or compiled-in modules (where the initialization function is added using <a class="reference internal" href="import.html#c.PyImport_AppendInittab" title="PyImport_AppendInittab"><code>PyImport_AppendInittab()</code></a>). See <a class="reference internal" href="../extending/building.html#building"><span class="std std-ref">Building C and C++ Extensions</span></a> or <a class="reference internal" href="../extending/embedding.html#extending-with-embedding"><span class="std std-ref">Extending Embedded Python</span></a> for details.</p> <p>The initialization function can either pass a module definition instance to <a class="reference internal" href="#c.PyModule_Create" title="PyModule_Create"><code>PyModule_Create()</code></a>, and return the resulting module object, or request “multi-phase initialization” by returning the definition struct itself.</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyModuleDef">
<code>type PyModuleDef</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> (including all members).</em><p>The module definition struct, which holds all information needed to create a module object. There is usually only one statically initialized variable of this type for each module.</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef.m_base">
<code>PyModuleDef_Base m_base</code> </dt> <dd>
<p>Always initialize this member to <code>PyModuleDef_HEAD_INIT</code>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef.m_name">
<code>const char *m_name</code> </dt> <dd>
<p>Name for the new module.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef.m_doc">
<code>const char *m_doc</code> </dt> <dd>
<p>Docstring for the module; usually a docstring variable created with <a class="reference internal" href="intro.html#c.PyDoc_STRVAR" title="PyDoc_STRVAR"><code>PyDoc_STRVAR</code></a> is used.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef.m_size">
<code>Py_ssize_t m_size</code> </dt> <dd>
<p>Module state may be kept in a per-module memory area that can be retrieved with <a class="reference internal" href="#c.PyModule_GetState" title="PyModule_GetState"><code>PyModule_GetState()</code></a>, rather than in static globals. This makes modules safe for use in multiple sub-interpreters.</p> <p>This memory area is allocated based on <em>m_size</em> on module creation, and freed when the module object is deallocated, after the <a class="reference internal" href="#c.PyModuleDef.m_free" title="PyModuleDef.m_free"><code>m_free</code></a> function has been called, if present.</p> <p>Setting <code>m_size</code> to <code>-1</code> means that the module does not support sub-interpreters, because it has global state.</p> <p>Setting it to a non-negative value means that the module can be re-initialized and specifies the additional amount of memory it requires for its state. Non-negative <code>m_size</code> is required for multi-phase initialization.</p> <p>See <span class="target" id="index-6"></span><a class="pep reference external" href="https://peps.python.org/pep-3121/"><strong>PEP 3121</strong></a> for more details.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef.m_methods">
<code>PyMethodDef *m_methods</code> </dt> <dd>
<p>A pointer to a table of module-level functions, described by <a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef"><code>PyMethodDef</code></a> values. Can be <code>NULL</code> if no functions are present.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef.m_slots">
<code>PyModuleDef_Slot *m_slots</code> </dt> <dd>
<p>An array of slot definitions for multi-phase initialization, terminated by a <code>{0, NULL}</code> entry. When using single-phase initialization, <em>m_slots</em> must be <code>NULL</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Prior to version 3.5, this member was always set to <code>NULL</code>, and was defined as:</p>  <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef.m_slots.m_reload">
<code>inquiry m_reload</code> </dt> <dd></dd>
</dl>  </div> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef.m_traverse">
<code>traverseproc m_traverse</code> </dt> <dd>
<p>A traversal function to call during GC traversal of the module object, or <code>NULL</code> if not needed.</p> <p>This function is not called if the module state was requested but is not allocated yet. This is the case immediately after the module is created and before the module is executed (<a class="reference internal" href="#c.Py_mod_exec" title="Py_mod_exec"><code>Py_mod_exec</code></a> function). More precisely, this function is not called if <a class="reference internal" href="#c.PyModuleDef.m_size" title="PyModuleDef.m_size"><code>m_size</code></a> is greater than 0 and the module state (as returned by <a class="reference internal" href="#c.PyModule_GetState" title="PyModule_GetState"><code>PyModule_GetState()</code></a>) is <code>NULL</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>No longer called before the module state is allocated.</p> </div> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef.m_clear">
<code>inquiry m_clear</code> </dt> <dd>
<p>A clear function to call during GC clearing of the module object, or <code>NULL</code> if not needed.</p> <p>This function is not called if the module state was requested but is not allocated yet. This is the case immediately after the module is created and before the module is executed (<a class="reference internal" href="#c.Py_mod_exec" title="Py_mod_exec"><code>Py_mod_exec</code></a> function). More precisely, this function is not called if <a class="reference internal" href="#c.PyModuleDef.m_size" title="PyModuleDef.m_size"><code>m_size</code></a> is greater than 0 and the module state (as returned by <a class="reference internal" href="#c.PyModule_GetState" title="PyModule_GetState"><code>PyModule_GetState()</code></a>) is <code>NULL</code>.</p> <p>Like <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>PyTypeObject.tp_clear</code></a>, this function is not <em>always</em> called before a module is deallocated. For example, when reference counting is enough to determine that an object is no longer used, the cyclic garbage collector is not involved and <a class="reference internal" href="#c.PyModuleDef.m_free" title="PyModuleDef.m_free"><code>m_free</code></a> is called directly.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>No longer called before the module state is allocated.</p> </div> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef.m_free">
<code>freefunc m_free</code> </dt> <dd>
<p>A function to call during deallocation of the module object, or <code>NULL</code> if not needed.</p> <p>This function is not called if the module state was requested but is not allocated yet. This is the case immediately after the module is created and before the module is executed (<a class="reference internal" href="#c.Py_mod_exec" title="Py_mod_exec"><code>Py_mod_exec</code></a> function). More precisely, this function is not called if <a class="reference internal" href="#c.PyModuleDef.m_size" title="PyModuleDef.m_size"><code>m_size</code></a> is greater than 0 and the module state (as returned by <a class="reference internal" href="#c.PyModule_GetState" title="PyModule_GetState"><code>PyModule_GetState()</code></a>) is <code>NULL</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>No longer called before the module state is allocated.</p> </div> </dd>
</dl> </dd>
</dl> <section id="single-phase-initialization"> <h3>Single-phase initialization</h3> <p>The module initialization function may create and return the module object directly. This is referred to as “single-phase initialization”, and uses one of the following two module creation functions:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_Create">
<code>PyObject *PyModule_Create(PyModuleDef *def)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><p>Create a new module object, given the definition in <em>def</em>. This behaves like <a class="reference internal" href="#c.PyModule_Create2" title="PyModule_Create2"><code>PyModule_Create2()</code></a> with <em>module_api_version</em> set to <code>PYTHON_API_VERSION</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_Create2">
<code>PyObject *PyModule_Create2(PyModuleDef *def, int module_api_version)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a new module object, given the definition in <em>def</em>, assuming the API version <em>module_api_version</em>. If that version does not match the version of the running interpreter, a <a class="reference internal" href="../library/exceptions.html#RuntimeWarning" title="RuntimeWarning"><code>RuntimeWarning</code></a> is emitted.</p> <p>Return <code>NULL</code> with an exception set on error.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Most uses of this function should be using <a class="reference internal" href="#c.PyModule_Create" title="PyModule_Create"><code>PyModule_Create()</code></a> instead; only use this if you are sure you need it.</p> </div> </dd>
</dl> <p>Before it is returned from in the initialization function, the resulting module object is typically populated using functions like <a class="reference internal" href="#c.PyModule_AddObjectRef" title="PyModule_AddObjectRef"><code>PyModule_AddObjectRef()</code></a>.</p> </section> <section id="multi-phase-initialization"> <span id="id1"></span><h3>Multi-phase initialization</h3> <p>An alternate way to specify extensions is to request “multi-phase initialization”. Extension modules created this way behave more like Python modules: the initialization is split between the <em>creation phase</em>, when the module object is created, and the <em>execution phase</em>, when it is populated. The distinction is similar to the <code>__new__()</code> and <code>__init__()</code> methods of classes.</p> <p>Unlike modules created using single-phase initialization, these modules are not singletons: if the <em>sys.modules</em> entry is removed and the module is re-imported, a new module object is created, and the old module is subject to normal garbage collection – as with Python modules. By default, multiple modules created from the same definition should be independent: changes to one should not affect the others. This means that all state should be specific to the module object (using e.g. using <a class="reference internal" href="#c.PyModule_GetState" title="PyModule_GetState"><code>PyModule_GetState()</code></a>), or its contents (such as the module’s <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> or individual classes created with <a class="reference internal" href="type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code>PyType_FromSpec()</code></a>).</p> <p>All modules created using multi-phase initialization are expected to support <a class="reference internal" href="init.html#sub-interpreter-support"><span class="std std-ref">sub-interpreters</span></a>. Making sure multiple modules are independent is typically enough to achieve this.</p> <p>To request multi-phase initialization, the initialization function (PyInit_modulename) returns a <a class="reference internal" href="#c.PyModuleDef" title="PyModuleDef"><code>PyModuleDef</code></a> instance with non-empty <a class="reference internal" href="#c.PyModuleDef.m_slots" title="PyModuleDef.m_slots"><code>m_slots</code></a>. Before it is returned, the <code>PyModuleDef</code> instance must be initialized with the following function:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModuleDef_Init">
<code>PyObject *PyModuleDef_Init(PyModuleDef *def)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.5.</em><p>Ensures a module definition is a properly initialized Python object that correctly reports its type and reference count.</p> <p>Returns <em>def</em> cast to <code>PyObject*</code>, or <code>NULL</code> if an error occurred.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <p>The <em>m_slots</em> member of the module definition must point to an array of <code>PyModuleDef_Slot</code> structures:</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyModuleDef_Slot">
<code>type PyModuleDef_Slot</code> </dt> <dd>
<dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef_Slot.slot">
<code>int slot</code> </dt> <dd>
<p>A slot ID, chosen from the available values explained below.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyModuleDef_Slot.value">
<code>void *value</code> </dt> <dd>
<p>Value of the slot, whose meaning depends on the slot ID.</p> </dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <p>The <em>m_slots</em> array must be terminated by a slot with id 0.</p> <p>The available slot types are:</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_mod_create">
<code>Py_mod_create</code> </dt> <dd>
<p>Specifies a function that is called to create the module object itself. The <em>value</em> pointer of this slot must point to a function of the signature:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_mod_create.create_module">
<code>PyObject *create_module(PyObject *spec, PyModuleDef *def)</code> </dt> <dd></dd>
</dl> <p>The function receives a <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code>ModuleSpec</code></a> instance, as defined in <span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a>, and the module definition. It should return a new module object, or set an error and return <code>NULL</code>.</p> <p>This function should be kept minimal. In particular, it should not call arbitrary Python code, as trying to import the same module again may result in an infinite loop.</p> <p>Multiple <code>Py_mod_create</code> slots may not be specified in one module definition.</p> <p>If <code>Py_mod_create</code> is not specified, the import machinery will create a normal module object using <a class="reference internal" href="#c.PyModule_New" title="PyModule_New"><code>PyModule_New()</code></a>. The name is taken from <em>spec</em>, not the definition, to allow extension modules to dynamically adjust to their place in the module hierarchy and be imported under different names through symlinks, all while sharing a single module definition.</p> <p>There is no requirement for the returned object to be an instance of <a class="reference internal" href="#c.PyModule_Type" title="PyModule_Type"><code>PyModule_Type</code></a>. Any type can be used, as long as it supports setting and getting import-related attributes. However, only <code>PyModule_Type</code> instances may be returned if the <code>PyModuleDef</code> has non-<code>NULL</code> <code>m_traverse</code>, <code>m_clear</code>, <code>m_free</code>; non-zero <code>m_size</code>; or slots other than <code>Py_mod_create</code>.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_mod_exec">
<code>Py_mod_exec</code> </dt> <dd>
<p>Specifies a function that is called to <em>execute</em> the module. This is equivalent to executing the code of a Python module: typically, this function adds classes and constants to the module. The signature of the function is:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_mod_exec.exec_module">
<code>int exec_module(PyObject *module)</code> </dt> <dd></dd>
</dl> <p>If multiple <code>Py_mod_exec</code> slots are specified, they are processed in the order they appear in the <em>m_slots</em> array.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_mod_multiple_interpreters">
<code>Py_mod_multiple_interpreters</code> </dt> <dd>
<p>Specifies one of the following values:</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED">
<code>Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED</code> </dt> <dd>
<p>The module does not support being imported in subinterpreters.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED">
<code>Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED</code> </dt> <dd>
<p>The module supports being imported in subinterpreters, but only when they share the main interpreter’s GIL. (See <a class="reference internal" href="../howto/isolating-extensions.html#isolating-extensions-howto"><span class="std std-ref">Isolating Extension Modules</span></a>.)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_MOD_PER_INTERPRETER_GIL_SUPPORTED">
<code>Py_MOD_PER_INTERPRETER_GIL_SUPPORTED</code> </dt> <dd>
<p>The module supports being imported in subinterpreters, even when they have their own GIL. (See <a class="reference internal" href="../howto/isolating-extensions.html#isolating-extensions-howto"><span class="std std-ref">Isolating Extension Modules</span></a>.)</p> </dd>
</dl> <p>This slot determines whether or not importing this module in a subinterpreter will fail.</p> <p>Multiple <code>Py_mod_multiple_interpreters</code> slots may not be specified in one module definition.</p> <p>If <code>Py_mod_multiple_interpreters</code> is not specified, the import machinery defaults to <code>Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_mod_gil">
<code>Py_mod_gil</code> </dt> <dd>
<p>Specifies one of the following values:</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_MOD_GIL_USED">
<code>Py_MOD_GIL_USED</code> </dt> <dd>
<p>The module depends on the presence of the global interpreter lock (GIL), and may access global state without synchronization.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.Py_MOD_GIL_NOT_USED">
<code>Py_MOD_GIL_NOT_USED</code> </dt> <dd>
<p>The module is safe to run without an active GIL.</p> </dd>
</dl> <p>This slot is ignored by Python builds not configured with <a class="reference internal" href="../using/configure.html#cmdoption-disable-gil"><code>--disable-gil</code></a>. Otherwise, it determines whether or not importing this module will cause the GIL to be automatically enabled. See <a class="reference internal" href="https://docs.python.org/3.13/whatsnew/3.13.html#whatsnew313-free-threaded-cpython"><span class="std std-ref">Free-threaded CPython</span></a> for more detail.</p> <p>Multiple <code>Py_mod_gil</code> slots may not be specified in one module definition.</p> <p>If <code>Py_mod_gil</code> is not specified, the import machinery defaults to <code>Py_MOD_GIL_USED</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <p>See <span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a> for more details on multi-phase initialization.</p> </section> <section id="low-level-module-creation-functions"> <h3>Low-level module creation functions</h3> <p>The following functions are called under the hood when using multi-phase initialization. They can be used directly, for example when creating module objects dynamically. Note that both <code>PyModule_FromDefAndSpec</code> and <code>PyModule_ExecDef</code> must be called to fully initialize a module.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_FromDefAndSpec">
<code>PyObject *PyModule_FromDefAndSpec(PyModuleDef *def, PyObject *spec)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><p>Create a new module object, given the definition in <em>def</em> and the ModuleSpec <em>spec</em>. This behaves like <a class="reference internal" href="#c.PyModule_FromDefAndSpec2" title="PyModule_FromDefAndSpec2"><code>PyModule_FromDefAndSpec2()</code></a> with <em>module_api_version</em> set to <code>PYTHON_API_VERSION</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_FromDefAndSpec2">
<code>PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Create a new module object, given the definition in <em>def</em> and the ModuleSpec <em>spec</em>, assuming the API version <em>module_api_version</em>. If that version does not match the version of the running interpreter, a <a class="reference internal" href="../library/exceptions.html#RuntimeWarning" title="RuntimeWarning"><code>RuntimeWarning</code></a> is emitted.</p> <p>Return <code>NULL</code> with an exception set on error.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Most uses of this function should be using <a class="reference internal" href="#c.PyModule_FromDefAndSpec" title="PyModule_FromDefAndSpec"><code>PyModule_FromDefAndSpec()</code></a> instead; only use this if you are sure you need it.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_ExecDef">
<code>int PyModule_ExecDef(PyObject *module, PyModuleDef *def)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Process any execution slots (<a class="reference internal" href="#c.Py_mod_exec" title="Py_mod_exec"><code>Py_mod_exec</code></a>) given in <em>def</em>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_SetDocString">
<code>int PyModule_SetDocString(PyObject *module, const char *docstring)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Set the docstring for <em>module</em> to <em>docstring</em>. This function is called automatically when creating a module from <code>PyModuleDef</code>, using either <code>PyModule_Create</code> or <code>PyModule_FromDefAndSpec</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_AddFunctions">
<code>int PyModule_AddFunctions(PyObject *module, PyMethodDef *functions)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Add the functions from the <code>NULL</code> terminated <em>functions</em> array to <em>module</em>. Refer to the <a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef"><code>PyMethodDef</code></a> documentation for details on individual entries (due to the lack of a shared module namespace, module level “functions” implemented in C typically receive the module as their first parameter, making them similar to instance methods on Python classes). This function is called automatically when creating a module from <code>PyModuleDef</code>, using either <code>PyModule_Create</code> or <code>PyModule_FromDefAndSpec</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> </section> <section id="support-functions"> <h3>Support functions</h3> <p>The module initialization function (if using single phase initialization) or a function called from a module execution slot (if using multi-phase initialization), can use the following functions to help initialize the module state:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_AddObjectRef">
<code>int PyModule_AddObjectRef(PyObject *module, const char *name, PyObject *value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Add an object to <em>module</em> as <em>name</em>. This is a convenience function which can be used from the module’s initialization function.</p> <p>On success, return <code>0</code>. On error, raise an exception and return <code>-1</code>.</p> <p>Return <code>-1</code> if <em>value</em> is <code>NULL</code>. It must be called with an exception raised in this case.</p> <p>Example usage:</p> <pre data-language="c">static int
add_spam(PyObject *module, int value)
{
    PyObject *obj = PyLong_FromLong(value);
    if (obj == NULL) {
        return -1;
    }
    int res = PyModule_AddObjectRef(module, "spam", obj);
    Py_DECREF(obj);
    return res;
 }
</pre> <p>The example can also be written without checking explicitly if <em>obj</em> is <code>NULL</code>:</p> <pre data-language="c">static int
add_spam(PyObject *module, int value)
{
    PyObject *obj = PyLong_FromLong(value);
    int res = PyModule_AddObjectRef(module, "spam", obj);
    Py_XDECREF(obj);
    return res;
 }
</pre> <p>Note that <code>Py_XDECREF()</code> should be used instead of <code>Py_DECREF()</code> in this case, since <em>obj</em> can be <code>NULL</code>.</p> <p>The number of different <em>name</em> strings passed to this function should be kept small, usually by only using statically allocated strings as <em>name</em>. For names that aren’t known at compile time, prefer calling <a class="reference internal" href="unicode.html#c.PyUnicode_FromString" title="PyUnicode_FromString"><code>PyUnicode_FromString()</code></a> and <a class="reference internal" href="object.html#c.PyObject_SetAttr" title="PyObject_SetAttr"><code>PyObject_SetAttr()</code></a> directly. For more details, see <a class="reference internal" href="unicode.html#c.PyUnicode_InternFromString" title="PyUnicode_InternFromString"><code>PyUnicode_InternFromString()</code></a>, which may be used internally to create a key object.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_Add">
<code>int PyModule_Add(PyObject *module, const char *name, PyObject *value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Similar to <a class="reference internal" href="#c.PyModule_AddObjectRef" title="PyModule_AddObjectRef"><code>PyModule_AddObjectRef()</code></a>, but “steals” a reference to <em>value</em>. It can be called with a result of function that returns a new reference without bothering to check its result or even saving it to a variable.</p> <p>Example usage:</p> <pre data-language="c">if (PyModule_Add(module, "spam", PyBytes_FromString(value)) &lt; 0) {
    goto error;
}
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_AddObject">
<code>int PyModule_AddObject(PyObject *module, const char *name, PyObject *value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Similar to <a class="reference internal" href="#c.PyModule_AddObjectRef" title="PyModule_AddObjectRef"><code>PyModule_AddObjectRef()</code></a>, but steals a reference to <em>value</em> on success (if it returns <code>0</code>).</p> <p>The new <a class="reference internal" href="#c.PyModule_Add" title="PyModule_Add"><code>PyModule_Add()</code></a> or <a class="reference internal" href="#c.PyModule_AddObjectRef" title="PyModule_AddObjectRef"><code>PyModule_AddObjectRef()</code></a> functions are recommended, since it is easy to introduce reference leaks by misusing the <a class="reference internal" href="#c.PyModule_AddObject" title="PyModule_AddObject"><code>PyModule_AddObject()</code></a> function.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Unlike other functions that steal references, <code>PyModule_AddObject()</code> only releases the reference to <em>value</em> <strong>on success</strong>.</p> <p>This means that its return value must be checked, and calling code must <a class="reference internal" href="refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code>Py_XDECREF()</code></a> <em>value</em> manually on error.</p> </div> <p>Example usage:</p> <pre data-language="c">PyObject *obj = PyBytes_FromString(value);
if (PyModule_AddObject(module, "spam", obj) &lt; 0) {
    // If 'obj' is not NULL and PyModule_AddObject() failed,
    // 'obj' strong reference must be deleted with Py_XDECREF().
    // If 'obj' is NULL, Py_XDECREF() does nothing.
    Py_XDECREF(obj);
    goto error;
}
// PyModule_AddObject() stole a reference to obj:
// Py_XDECREF(obj) is not needed here.
</pre> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.13: </span><a class="reference internal" href="#c.PyModule_AddObject" title="PyModule_AddObject"><code>PyModule_AddObject()</code></a> is <a class="reference internal" href="../glossary.html#term-soft-deprecated"><span class="xref std std-term">soft deprecated</span></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_AddIntConstant">
<code>int PyModule_AddIntConstant(PyObject *module, const char *name, long value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Add an integer constant to <em>module</em> as <em>name</em>. This convenience function can be used from the module’s initialization function. Return <code>-1</code> with an exception set on error, <code>0</code> on success.</p> <p>This is a convenience function that calls <a class="reference internal" href="long.html#c.PyLong_FromLong" title="PyLong_FromLong"><code>PyLong_FromLong()</code></a> and <a class="reference internal" href="#c.PyModule_AddObjectRef" title="PyModule_AddObjectRef"><code>PyModule_AddObjectRef()</code></a>; see their documentation for details.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_AddStringConstant">
<code>int PyModule_AddStringConstant(PyObject *module, const char *name, const char *value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Add a string constant to <em>module</em> as <em>name</em>. This convenience function can be used from the module’s initialization function. The string <em>value</em> must be <code>NULL</code>-terminated. Return <code>-1</code> with an exception set on error, <code>0</code> on success.</p> <p>This is a convenience function that calls <a class="reference internal" href="unicode.html#c.PyUnicode_InternFromString" title="PyUnicode_InternFromString"><code>PyUnicode_InternFromString()</code></a> and <a class="reference internal" href="#c.PyModule_AddObjectRef" title="PyModule_AddObjectRef"><code>PyModule_AddObjectRef()</code></a>; see their documentation for details.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyModule_AddIntMacro">
<code>PyModule_AddIntMacro(module, macro)</code> </dt> <dd>
<p>Add an int constant to <em>module</em>. The name and the value are taken from <em>macro</em>. For example <code>PyModule_AddIntMacro(module, AF_INET)</code> adds the int constant <em>AF_INET</em> with the value of <em>AF_INET</em> to <em>module</em>. Return <code>-1</code> with an exception set on error, <code>0</code> on success.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyModule_AddStringMacro">
<code>PyModule_AddStringMacro(module, macro)</code> </dt> <dd>
<p>Add a string constant to <em>module</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyModule_AddType">
<code>int PyModule_AddType(PyObject *module, PyTypeObject *type)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Add a type object to <em>module</em>. The type object is finalized by calling internally <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a>. The name of the type object is taken from the last component of <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code>tp_name</code></a> after dot. Return <code>-1</code> with an exception set on error, <code>0</code> on success.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnstable_Module_SetGIL">
<code>int PyUnstable_Module_SetGIL(PyObject *module, void *gil)</code> </dt> <dd>
<div class="unstable-c-api warning admonition"> <em>This is <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable API</span></a>. It may change without warning in minor releases.</em>
</div> <p>Indicate that <em>module</em> does or does not support running without the global interpreter lock (GIL), using one of the values from <a class="reference internal" href="#c.Py_mod_gil" title="Py_mod_gil"><code>Py_mod_gil</code></a>. It must be called during <em>module</em>’s initialization function. If this function is not called during module initialization, the import machinery assumes the module does not support running without the GIL. This function is only available in Python builds configured with <a class="reference internal" href="../using/configure.html#cmdoption-disable-gil"><code>--disable-gil</code></a>. Return <code>-1</code> with an exception set on error, <code>0</code> on success.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> </section> </section> <section id="module-lookup"> <h2>Module lookup</h2> <p>Single-phase initialization creates singleton modules that can be looked up in the context of the current interpreter. This allows the module object to be retrieved later with only a reference to the module definition.</p> <p>These functions will not work on modules created using multi-phase initialization, since multiple such modules can be created from a single definition.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyState_FindModule">
<code>PyObject *PyState_FindModule(PyModuleDef *def)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Returns the module object that was created from <em>def</em> for the current interpreter. This method requires that the module object has been attached to the interpreter state with <a class="reference internal" href="#c.PyState_AddModule" title="PyState_AddModule"><code>PyState_AddModule()</code></a> beforehand. In case the corresponding module object is not found or has not been attached to the interpreter state yet, it returns <code>NULL</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyState_AddModule">
<code>int PyState_AddModule(PyObject *module, PyModuleDef *def)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.3.</em><p>Attaches the module object passed to the function to the interpreter state. This allows the module object to be accessible via <a class="reference internal" href="#c.PyState_FindModule" title="PyState_FindModule"><code>PyState_FindModule()</code></a>.</p> <p>Only effective on modules created using single-phase initialization.</p> <p>Python calls <code>PyState_AddModule</code> automatically after importing a module, so it is unnecessary (but harmless) to call it from module initialization code. An explicit call is needed only if the module’s own init code subsequently calls <code>PyState_FindModule</code>. The function is mainly intended for implementing alternative import mechanisms (either by calling it directly, or by referring to its implementation for details of the required state updates).</p> <p>The caller must hold the GIL.</p> <p>Return <code>-1</code> with an exception set on error, <code>0</code> on success.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyState_RemoveModule">
<code>int PyState_RemoveModule(PyModuleDef *def)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.3.</em><p>Removes the module object created from <em>def</em> from the interpreter state. Return <code>-1</code> with an exception set on error, <code>0</code> on success.</p> <p>The caller must hold the GIL.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/module.html" class="_attribution-link">https://docs.python.org/3.13/c-api/module.html</a>
  </p>
</div>
