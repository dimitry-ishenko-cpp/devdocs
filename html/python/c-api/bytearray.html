 <span id="bytearrayobjects"></span><h1>Byte Array Objects</h1> <span class="target" id="index-0"></span><dl class="c type"> <dt class="sig sig-object c" id="c.PyByteArrayObject">
<code>type PyByteArrayObject</code> </dt> <dd>
<p>This subtype of <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> represents a Python bytearray object.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyByteArray_Type">
<code>PyTypeObject PyByteArray_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This instance of <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> represents the Python bytearray type; it is the same object as <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> in the Python layer.</p> </dd>
</dl> <section id="type-check-macros"> <h2>Type check macros</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyByteArray_Check">
<code>int PyByteArray_Check(PyObject *o)</code> </dt> <dd>
<p>Return true if the object <em>o</em> is a bytearray object or an instance of a subtype of the bytearray type. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyByteArray_CheckExact">
<code>int PyByteArray_CheckExact(PyObject *o)</code> </dt> <dd>
<p>Return true if the object <em>o</em> is a bytearray object, but not an instance of a subtype of the bytearray type. This function always succeeds.</p> </dd>
</dl> </section> <section id="direct-api-functions"> <h2>Direct API functions</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyByteArray_FromObject">
<code>PyObject *PyByteArray_FromObject(PyObject *o)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new bytearray object from any object, <em>o</em>, that implements the <a class="reference internal" href="buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyByteArray_FromStringAndSize">
<code>PyObject *PyByteArray_FromStringAndSize(const char *string, Py_ssize_t len)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a new bytearray object from <em>string</em> and its length, <em>len</em>. On failure, <code>NULL</code> is returned.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyByteArray_Concat">
<code>PyObject *PyByteArray_Concat(PyObject *a, PyObject *b)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Concat bytearrays <em>a</em> and <em>b</em> and return a new bytearray with the result.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyByteArray_Size">
<code>Py_ssize_t PyByteArray_Size(PyObject *bytearray)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the size of <em>bytearray</em> after checking for a <code>NULL</code> pointer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyByteArray_AsString">
<code>char *PyByteArray_AsString(PyObject *bytearray)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the contents of <em>bytearray</em> as a char array after checking for a <code>NULL</code> pointer. The returned array always has an extra null byte appended.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyByteArray_Resize">
<code>int PyByteArray_Resize(PyObject *bytearray, Py_ssize_t len)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Resize the internal buffer of <em>bytearray</em> to <em>len</em>.</p> </dd>
</dl> </section> <section id="macros"> <h2>Macros</h2> <p>These macros trade safety for speed and they donâ€™t check pointers.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyByteArray_AS_STRING">
<code>char *PyByteArray_AS_STRING(PyObject *bytearray)</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#c.PyByteArray_AsString" title="PyByteArray_AsString"><code>PyByteArray_AsString()</code></a>, but without error checking.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyByteArray_GET_SIZE">
<code>Py_ssize_t PyByteArray_GET_SIZE(PyObject *bytearray)</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#c.PyByteArray_Size" title="PyByteArray_Size"><code>PyByteArray_Size()</code></a>, but without error checking.</p> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/c-api/bytearray.html" class="_attribution-link">https://docs.python.org/3.12/c-api/bytearray.html</a>
  </p>
</div>
