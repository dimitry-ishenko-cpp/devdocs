 <span id="exceptionhandling"></span><h1>Exception Handling</h1> <p>The functions described in this chapter will let you handle and raise Python exceptions. It is important to understand some of the basics of Python exception handling. It works somewhat like the POSIX <code>errno</code> variable: there is a global indicator (per thread) of the last error that occurred. Most C API functions don’t clear this on success, but will set it to indicate the cause of the error on failure. Most C API functions also return an error indicator, usually <code>NULL</code> if they are supposed to return a pointer, or <code>-1</code> if they return an integer (exception: the <code>PyArg_*</code> functions return <code>1</code> for success and <code>0</code> for failure).</p> <p>Concretely, the error indicator consists of three object pointers: the exception’s type, the exception’s value, and the traceback object. Any of those pointers can be <code>NULL</code> if non-set (although some combinations are forbidden, for example you can’t have a non-<code>NULL</code> traceback if the exception type is <code>NULL</code>).</p> <p>When a function must fail because some function it called failed, it generally doesn’t set the error indicator; the function it called already set it. It is responsible for either handling the error and clearing the exception or returning after cleaning up any resources it holds (such as object references or memory allocations); it should <em>not</em> continue normally if it is not prepared to handle the error. If returning due to an error, it is important to indicate to the caller that an error has been set. If the error is not handled or carefully propagated, additional calls into the Python/C API may not behave as intended and may fail in mysterious ways.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The error indicator is <strong>not</strong> the result of <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a>. The former corresponds to an exception that is not yet caught (and is therefore still propagating), while the latter returns an exception after it is caught (and has therefore stopped propagating).</p> </div> <section id="printing-and-clearing"> <h2>Printing and clearing</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_Clear">
<code>void PyErr_Clear()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Clear the error indicator. If the error indicator is not set, there is no effect.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_PrintEx">
<code>void PyErr_PrintEx(int set_sys_last_vars)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Print a standard traceback to <code>sys.stderr</code> and clear the error indicator. <strong>Unless</strong> the error is a <code>SystemExit</code>, in that case no traceback is printed and the Python process will exit with the error code specified by the <code>SystemExit</code> instance.</p> <p>Call this function <strong>only</strong> when the error indicator is set. Otherwise it will cause a fatal error!</p> <p>If <em>set_sys_last_vars</em> is nonzero, the variable <a class="reference internal" href="../library/sys.html#sys.last_exc" title="sys.last_exc"><code>sys.last_exc</code></a> is set to the printed exception. For backwards compatibility, the deprecated variables <a class="reference internal" href="../library/sys.html#sys.last_type" title="sys.last_type"><code>sys.last_type</code></a>, <a class="reference internal" href="../library/sys.html#sys.last_value" title="sys.last_value"><code>sys.last_value</code></a> and <a class="reference internal" href="../library/sys.html#sys.last_traceback" title="sys.last_traceback"><code>sys.last_traceback</code></a> are also set to the type, value and traceback of this exception, respectively.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The setting of <a class="reference internal" href="../library/sys.html#sys.last_exc" title="sys.last_exc"><code>sys.last_exc</code></a> was added.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_Print">
<code>void PyErr_Print()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Alias for <code>PyErr_PrintEx(1)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_WriteUnraisable">
<code>void PyErr_WriteUnraisable(PyObject *obj)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Call <a class="reference internal" href="../library/sys.html#sys.unraisablehook" title="sys.unraisablehook"><code>sys.unraisablehook()</code></a> using the current exception and <em>obj</em> argument.</p> <p>This utility function prints a warning message to <code>sys.stderr</code> when an exception has been set but it is impossible for the interpreter to actually raise the exception. It is used, for example, when an exception occurs in an <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code>__del__()</code></a> method.</p> <p>The function is called with a single argument <em>obj</em> that identifies the context in which the unraisable exception occurred. If possible, the repr of <em>obj</em> will be printed in the warning message. If <em>obj</em> is <code>NULL</code>, only the traceback is printed.</p> <p>An exception must be set when calling this function.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Print a traceback. Print only traceback if <em>obj</em> is <code>NULL</code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Use <a class="reference internal" href="../library/sys.html#sys.unraisablehook" title="sys.unraisablehook"><code>sys.unraisablehook()</code></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_FormatUnraisable">
<code>void PyErr_FormatUnraisable(const char *format, ...)</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#c.PyErr_WriteUnraisable" title="PyErr_WriteUnraisable"><code>PyErr_WriteUnraisable()</code></a>, but the <em>format</em> and subsequent parameters help format the warning message; they have the same meaning and values as in <a class="reference internal" href="unicode.html#c.PyUnicode_FromFormat" title="PyUnicode_FromFormat"><code>PyUnicode_FromFormat()</code></a>. <code>PyErr_WriteUnraisable(obj)</code> is roughly equivalent to <code>PyErr_FormatUnraisable("Exception ignored in: %R", obj)</code>. If <em>format</em> is <code>NULL</code>, only the traceback is printed.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_DisplayException">
<code>void PyErr_DisplayException(PyObject *exc)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>Print the standard traceback display of <code>exc</code> to <code>sys.stderr</code>, including chained exceptions and notes.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> </section> <section id="raising-exceptions"> <h2>Raising exceptions</h2> <p>These functions help you set the current thread’s error indicator. For convenience, some of these functions will always return a <code>NULL</code> pointer for use in a <code>return</code> statement.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetString">
<code>void PyErr_SetString(PyObject *type, const char *message)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is the most common way to set the error indicator. The first argument specifies the exception type; it is normally one of the standard exceptions, e.g. <code>PyExc_RuntimeError</code>. You need not create a new <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to it (e.g. with <a class="reference internal" href="refcounting.html#c.Py_INCREF" title="Py_INCREF"><code>Py_INCREF()</code></a>). The second argument is an error message; it is decoded from <code>'utf-8'</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetObject">
<code>void PyErr_SetObject(PyObject *type, PyObject *value)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This function is similar to <a class="reference internal" href="#c.PyErr_SetString" title="PyErr_SetString"><code>PyErr_SetString()</code></a> but lets you specify an arbitrary Python object for the “value” of the exception.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_Format">
<code>PyObject *PyErr_Format(PyObject *exception, const char *format, ...)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This function sets the error indicator and returns <code>NULL</code>. <em>exception</em> should be a Python exception class. The <em>format</em> and subsequent parameters help format the error message; they have the same meaning and values as in <a class="reference internal" href="unicode.html#c.PyUnicode_FromFormat" title="PyUnicode_FromFormat"><code>PyUnicode_FromFormat()</code></a>. <em>format</em> is an ASCII-encoded string.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_FormatV">
<code>PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.5.</em><p>Same as <a class="reference internal" href="#c.PyErr_Format" title="PyErr_Format"><code>PyErr_Format()</code></a>, but taking a <code>va_list</code> argument rather than a variable number of arguments.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetNone">
<code>void PyErr_SetNone(PyObject *type)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is a shorthand for <code>PyErr_SetObject(type, Py_None)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_BadArgument">
<code>int PyErr_BadArgument()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is a shorthand for <code>PyErr_SetString(PyExc_TypeError, message)</code>, where <em>message</em> indicates that a built-in operation was invoked with an illegal argument. It is mostly for internal use.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_NoMemory">
<code>PyObject *PyErr_NoMemory()</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is a shorthand for <code>PyErr_SetNone(PyExc_MemoryError)</code>; it returns <code>NULL</code> so an object allocation function can write <code>return PyErr_NoMemory();</code> when it runs out of memory.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetFromErrno">
<code>PyObject *PyErr_SetFromErrno(PyObject *type)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-0">This is a convenience function to raise an exception when a C library function has returned an error and set the C variable <code>errno</code>. It constructs a tuple object whose first item is the integer <code>errno</code> value and whose second item is the corresponding error message (gotten from <code>strerror()</code>), and then calls <code>PyErr_SetObject(type, object)</code>. On Unix, when the <code>errno</code> value is <code>EINTR</code>, indicating an interrupted system call, this calls <a class="reference internal" href="#c.PyErr_CheckSignals" title="PyErr_CheckSignals"><code>PyErr_CheckSignals()</code></a>, and if that set the error indicator, leaves it set to that. The function always returns <code>NULL</code>, so a wrapper function around a system call can write <code>return PyErr_SetFromErrno(type);</code> when the system call returns an error.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetFromErrnoWithFilenameObject">
<code>PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *type, PyObject *filenameObject)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Similar to <a class="reference internal" href="#c.PyErr_SetFromErrno" title="PyErr_SetFromErrno"><code>PyErr_SetFromErrno()</code></a>, with the additional behavior that if <em>filenameObject</em> is not <code>NULL</code>, it is passed to the constructor of <em>type</em> as a third parameter. In the case of <a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> exception, this is used to define the <code>filename</code> attribute of the exception instance.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetFromErrnoWithFilenameObjects">
<code>PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *type, PyObject *filenameObject, PyObject *filenameObject2)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Similar to <a class="reference internal" href="#c.PyErr_SetFromErrnoWithFilenameObject" title="PyErr_SetFromErrnoWithFilenameObject"><code>PyErr_SetFromErrnoWithFilenameObject()</code></a>, but takes a second filename object, for raising errors when a function that takes two filenames fails.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetFromErrnoWithFilename">
<code>PyObject *PyErr_SetFromErrnoWithFilename(PyObject *type, const char *filename)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Similar to <a class="reference internal" href="#c.PyErr_SetFromErrnoWithFilenameObject" title="PyErr_SetFromErrnoWithFilenameObject"><code>PyErr_SetFromErrnoWithFilenameObject()</code></a>, but the filename is given as a C string. <em>filename</em> is decoded from the <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetFromWindowsErr">
<code>PyObject *PyErr_SetFromWindowsErr(int ierr)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> on Windows since version 3.7.</em><p>This is a convenience function to raise <a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code>OSError</code></a>. If called with <em>ierr</em> of <code>0</code>, the error code returned by a call to <code>GetLastError()</code> is used instead. It calls the Win32 function <code>FormatMessage()</code> to retrieve the Windows description of error code given by <em>ierr</em> or <code>GetLastError()</code>, then it constructs a <a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> object with the <a class="reference internal" href="../library/exceptions.html#OSError.winerror" title="OSError.winerror"><code>winerror</code></a> attribute set to the error code, the <a class="reference internal" href="../library/exceptions.html#OSError.strerror" title="OSError.strerror"><code>strerror</code></a> attribute set to the corresponding error message (gotten from <code>FormatMessage()</code>), and then calls <code>PyErr_SetObject(PyExc_OSError,
object)</code>. This function always returns <code>NULL</code>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetExcFromWindowsErr">
<code>PyObject *PyErr_SetExcFromWindowsErr(PyObject *type, int ierr)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> on Windows since version 3.7.</em><p>Similar to <a class="reference internal" href="#c.PyErr_SetFromWindowsErr" title="PyErr_SetFromWindowsErr"><code>PyErr_SetFromWindowsErr()</code></a>, with an additional parameter specifying the exception type to be raised.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetFromWindowsErrWithFilename">
<code>PyObject *PyErr_SetFromWindowsErrWithFilename(int ierr, const char *filename)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> on Windows since version 3.7.</em><p>Similar to <a class="reference internal" href="#c.PyErr_SetFromWindowsErr" title="PyErr_SetFromWindowsErr"><code>PyErr_SetFromWindowsErr()</code></a>, with the additional behavior that if <em>filename</em> is not <code>NULL</code>, it is decoded from the filesystem encoding (<a class="reference internal" href="../library/os.html#os.fsdecode" title="os.fsdecode"><code>os.fsdecode()</code></a>) and passed to the constructor of <a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> as a third parameter to be used to define the <code>filename</code> attribute of the exception instance.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetExcFromWindowsErrWithFilenameObject">
<code>PyObject *PyErr_SetExcFromWindowsErrWithFilenameObject(PyObject *type, int ierr, PyObject *filename)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> on Windows since version 3.7.</em><p>Similar to <a class="reference internal" href="#c.PyErr_SetExcFromWindowsErr" title="PyErr_SetExcFromWindowsErr"><code>PyErr_SetExcFromWindowsErr()</code></a>, with the additional behavior that if <em>filename</em> is not <code>NULL</code>, it is passed to the constructor of <a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> as a third parameter to be used to define the <code>filename</code> attribute of the exception instance.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetExcFromWindowsErrWithFilenameObjects">
<code>PyObject *PyErr_SetExcFromWindowsErrWithFilenameObjects(PyObject *type, int ierr, PyObject *filename, PyObject *filename2)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> on Windows since version 3.7.</em><p>Similar to <a class="reference internal" href="#c.PyErr_SetExcFromWindowsErrWithFilenameObject" title="PyErr_SetExcFromWindowsErrWithFilenameObject"><code>PyErr_SetExcFromWindowsErrWithFilenameObject()</code></a>, but accepts a second filename object.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetExcFromWindowsErrWithFilename">
<code>PyObject *PyErr_SetExcFromWindowsErrWithFilename(PyObject *type, int ierr, const char *filename)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> on Windows since version 3.7.</em><p>Similar to <a class="reference internal" href="#c.PyErr_SetFromWindowsErrWithFilename" title="PyErr_SetFromWindowsErrWithFilename"><code>PyErr_SetFromWindowsErrWithFilename()</code></a>, with an additional parameter specifying the exception type to be raised.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetImportError">
<code>PyObject *PyErr_SetImportError(PyObject *msg, PyObject *name, PyObject *path)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>This is a convenience function to raise <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code>ImportError</code></a>. <em>msg</em> will be set as the exception’s message string. <em>name</em> and <em>path</em>, both of which can be <code>NULL</code>, will be set as the <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code>ImportError</code></a>’s respective <code>name</code> and <code>path</code> attributes.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetImportErrorSubclass">
<code>PyObject *PyErr_SetImportErrorSubclass(PyObject *exception, PyObject *msg, PyObject *name, PyObject *path)</code> </dt> <dd>
<em class="refcount return_null">Return value: Always NULL.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.6.</em><p>Much like <a class="reference internal" href="#c.PyErr_SetImportError" title="PyErr_SetImportError"><code>PyErr_SetImportError()</code></a> but this function allows for specifying a subclass of <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code>ImportError</code></a> to raise.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SyntaxLocationObject">
<code>void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)</code> </dt> <dd>
<p>Set file, line, and offset information for the current exception. If the current exception is not a <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a>, then it sets additional attributes, which make the exception printing subsystem think the exception is a <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SyntaxLocationEx">
<code>void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Like <a class="reference internal" href="#c.PyErr_SyntaxLocationObject" title="PyErr_SyntaxLocationObject"><code>PyErr_SyntaxLocationObject()</code></a>, but <em>filename</em> is a byte string decoded from the <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SyntaxLocation">
<code>void PyErr_SyntaxLocation(const char *filename, int lineno)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Like <a class="reference internal" href="#c.PyErr_SyntaxLocationEx" title="PyErr_SyntaxLocationEx"><code>PyErr_SyntaxLocationEx()</code></a>, but the <em>col_offset</em> parameter is omitted.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_BadInternalCall">
<code>void PyErr_BadInternalCall()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is a shorthand for <code>PyErr_SetString(PyExc_SystemError, message)</code>, where <em>message</em> indicates that an internal operation (e.g. a Python/C API function) was invoked with an illegal argument. It is mostly for internal use.</p> </dd>
</dl> </section> <section id="issuing-warnings"> <h2>Issuing warnings</h2> <p>Use these functions to issue warnings from C code. They mirror similar functions exported by the Python <a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code>warnings</code></a> module. They normally print a warning message to <em>sys.stderr</em>; however, it is also possible that the user has specified that warnings are to be turned into errors, and in that case they will raise an exception. It is also possible that the functions raise an exception because of a problem with the warning machinery. The return value is <code>0</code> if no exception is raised, or <code>-1</code> if an exception is raised. (It is not possible to determine whether a warning message is actually printed, nor what the reason is for the exception; this is intentional.) If an exception is raised, the caller should do its normal exception handling (for example, <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> owned references and return an error value).</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_WarnEx">
<code>int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Issue a warning message. The <em>category</em> argument is a warning category (see below) or <code>NULL</code>; the <em>message</em> argument is a UTF-8 encoded string. <em>stack_level</em> is a positive number giving a number of stack frames; the warning will be issued from the currently executing line of code in that stack frame. A <em>stack_level</em> of 1 is the function calling <a class="reference internal" href="#c.PyErr_WarnEx" title="PyErr_WarnEx"><code>PyErr_WarnEx()</code></a>, 2 is the function above that, and so forth.</p> <p>Warning categories must be subclasses of <code>PyExc_Warning</code>; <code>PyExc_Warning</code> is a subclass of <code>PyExc_Exception</code>; the default warning category is <code>PyExc_RuntimeWarning</code>. The standard Python warning categories are available as global variables whose names are enumerated at <a class="reference internal" href="#standardwarningcategories"><span class="std std-ref">Standard Warning Categories</span></a>.</p> <p>For information about warning control, see the documentation for the <a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code>warnings</code></a> module and the <a class="reference internal" href="../using/cmdline.html#cmdoption-W"><code>-W</code></a> option in the command line documentation. There is no C API for warning control.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_WarnExplicitObject">
<code>int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)</code> </dt> <dd>
<p>Issue a warning message with explicit control over all warning attributes. This is a straightforward wrapper around the Python function <a class="reference internal" href="../library/warnings.html#warnings.warn_explicit" title="warnings.warn_explicit"><code>warnings.warn_explicit()</code></a>; see there for more information. The <em>module</em> and <em>registry</em> arguments may be set to <code>NULL</code> to get the default effect described there.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_WarnExplicit">
<code>int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Similar to <a class="reference internal" href="#c.PyErr_WarnExplicitObject" title="PyErr_WarnExplicitObject"><code>PyErr_WarnExplicitObject()</code></a> except that <em>message</em> and <em>module</em> are UTF-8 encoded strings, and <em>filename</em> is decoded from the <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_WarnFormat">
<code>int PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char *format, ...)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Function similar to <a class="reference internal" href="#c.PyErr_WarnEx" title="PyErr_WarnEx"><code>PyErr_WarnEx()</code></a>, but use <a class="reference internal" href="unicode.html#c.PyUnicode_FromFormat" title="PyUnicode_FromFormat"><code>PyUnicode_FromFormat()</code></a> to format the warning message. <em>format</em> is an ASCII-encoded string.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_ResourceWarning">
<code>int PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const char *format, ...)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.6.</em><p>Function similar to <a class="reference internal" href="#c.PyErr_WarnFormat" title="PyErr_WarnFormat"><code>PyErr_WarnFormat()</code></a>, but <em>category</em> is <a class="reference internal" href="../library/exceptions.html#ResourceWarning" title="ResourceWarning"><code>ResourceWarning</code></a> and it passes <em>source</em> to <code>warnings.WarningMessage</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> </dd>
</dl> </section> <section id="querying-the-error-indicator"> <h2>Querying the error indicator</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_Occurred">
<code>PyObject *PyErr_Occurred()</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Test whether the error indicator is set. If set, return the exception <em>type</em> (the first argument to the last call to one of the <code>PyErr_Set*</code> functions or to <a class="reference internal" href="#c.PyErr_Restore" title="PyErr_Restore"><code>PyErr_Restore()</code></a>). If not set, return <code>NULL</code>. You do not own a reference to the return value, so you do not need to <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> it.</p> <p>The caller must hold the GIL.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Do not compare the return value to a specific exception; use <a class="reference internal" href="#c.PyErr_ExceptionMatches" title="PyErr_ExceptionMatches"><code>PyErr_ExceptionMatches()</code></a> instead, shown below. (The comparison could easily fail since the exception may be an instance instead of a class, in the case of a class exception, or it may be a subclass of the expected exception.)</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_ExceptionMatches">
<code>int PyErr_ExceptionMatches(PyObject *exc)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Equivalent to <code>PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)</code>. This should only be called when an exception is actually set; a memory access violation will occur if no exception has been raised.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_GivenExceptionMatches">
<code>int PyErr_GivenExceptionMatches(PyObject *given, PyObject *exc)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return true if the <em>given</em> exception matches the exception type in <em>exc</em>. If <em>exc</em> is a class object, this also returns true when <em>given</em> is an instance of a subclass. If <em>exc</em> is a tuple, all exception types in the tuple (and recursively in subtuples) are searched for a match.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_GetRaisedException">
<code>PyObject *PyErr_GetRaisedException(void)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>Return the exception currently being raised, clearing the error indicator at the same time. Return <code>NULL</code> if the error indicator is not set.</p> <p>This function is used by code that needs to catch exceptions, or code that needs to save and restore the error indicator temporarily.</p> <p>For example:</p> <pre data-language="c">{
   PyObject *exc = PyErr_GetRaisedException();

   /* ... code that might produce other errors ... */

   PyErr_SetRaisedException(exc);
}
</pre> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="#c.PyErr_GetHandledException" title="PyErr_GetHandledException"><code>PyErr_GetHandledException()</code></a>, to save the exception currently being handled.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetRaisedException">
<code>void PyErr_SetRaisedException(PyObject *exc)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>Set <em>exc</em> as the exception currently being raised, clearing the existing exception if one is set.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This call steals a reference to <em>exc</em>, which must be a valid exception.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_Fetch">
<code>void PyErr_Fetch(PyObject **ptype, PyObject **pvalue, PyObject **ptraceback)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12: </span>Use <a class="reference internal" href="#c.PyErr_GetRaisedException" title="PyErr_GetRaisedException"><code>PyErr_GetRaisedException()</code></a> instead.</p> </div> <p>Retrieve the error indicator into three variables whose addresses are passed. If the error indicator is not set, set all three variables to <code>NULL</code>. If it is set, it will be cleared and you own a reference to each object retrieved. The value and traceback object may be <code>NULL</code> even when the type object is not.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is normally only used by legacy code that needs to catch exceptions or save and restore the error indicator temporarily.</p> <p>For example:</p> <pre data-language="c">{
   PyObject *type, *value, *traceback;
   PyErr_Fetch(&amp;type, &amp;value, &amp;traceback);

   /* ... code that might produce other errors ... */

   PyErr_Restore(type, value, traceback);
}
</pre> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_Restore">
<code>void PyErr_Restore(PyObject *type, PyObject *value, PyObject *traceback)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12: </span>Use <a class="reference internal" href="#c.PyErr_SetRaisedException" title="PyErr_SetRaisedException"><code>PyErr_SetRaisedException()</code></a> instead.</p> </div> <p>Set the error indicator from the three objects, <em>type</em>, <em>value</em>, and <em>traceback</em>, clearing the existing exception if one is set. If the objects are <code>NULL</code>, the error indicator is cleared. Do not pass a <code>NULL</code> type and non-<code>NULL</code> value or traceback. The exception type should be a class. Do not pass an invalid exception type or value. (Violating these rules will cause subtle problems later.) This call takes away a reference to each object: you must own a reference to each object before the call and after the call you no longer own these references. (If you don’t understand this, don’t use this function. I warned you.)</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is normally only used by legacy code that needs to save and restore the error indicator temporarily. Use <a class="reference internal" href="#c.PyErr_Fetch" title="PyErr_Fetch"><code>PyErr_Fetch()</code></a> to save the current error indicator.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_NormalizeException">
<code>void PyErr_NormalizeException(PyObject **exc, PyObject **val, PyObject **tb)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12: </span>Use <a class="reference internal" href="#c.PyErr_GetRaisedException" title="PyErr_GetRaisedException"><code>PyErr_GetRaisedException()</code></a> instead, to avoid any possible de-normalization.</p> </div> <p>Under certain circumstances, the values returned by <a class="reference internal" href="#c.PyErr_Fetch" title="PyErr_Fetch"><code>PyErr_Fetch()</code></a> below can be “unnormalized”, meaning that <code>*exc</code> is a class object but <code>*val</code> is not an instance of the same class. This function can be used to instantiate the class in that case. If the values are already normalized, nothing happens. The delayed normalization is implemented to improve performance.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function <em>does not</em> implicitly set the <a class="reference internal" href="../library/exceptions.html#BaseException.__traceback__" title="BaseException.__traceback__"><code>__traceback__</code></a> attribute on the exception value. If setting the traceback appropriately is desired, the following additional snippet is needed:</p> <pre data-language="c">if (tb != NULL) {
  PyException_SetTraceback(val, tb);
}
</pre> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_GetHandledException">
<code>PyObject *PyErr_GetHandledException(void)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Retrieve the active exception instance, as would be returned by <a class="reference internal" href="../library/sys.html#sys.exception" title="sys.exception"><code>sys.exception()</code></a>. This refers to an exception that was <em>already caught</em>, not to an exception that was freshly raised. Returns a new reference to the exception or <code>NULL</code>. Does not modify the interpreter’s exception state.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is not normally used by code that wants to handle exceptions. Rather, it can be used when code needs to save and restore the exception state temporarily. Use <a class="reference internal" href="#c.PyErr_SetHandledException" title="PyErr_SetHandledException"><code>PyErr_SetHandledException()</code></a> to restore or clear the exception state.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.11.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetHandledException">
<code>void PyErr_SetHandledException(PyObject *exc)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Set the active exception, as known from <code>sys.exception()</code>. This refers to an exception that was <em>already caught</em>, not to an exception that was freshly raised. To clear the exception state, pass <code>NULL</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is not normally used by code that wants to handle exceptions. Rather, it can be used when code needs to save and restore the exception state temporarily. Use <a class="reference internal" href="#c.PyErr_GetHandledException" title="PyErr_GetHandledException"><code>PyErr_GetHandledException()</code></a> to get the exception state.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.11.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_GetExcInfo">
<code>void PyErr_GetExcInfo(PyObject **ptype, PyObject **pvalue, PyObject **ptraceback)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Retrieve the old-style representation of the exception info, as known from <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a>. This refers to an exception that was <em>already caught</em>, not to an exception that was freshly raised. Returns new references for the three objects, any of which may be <code>NULL</code>. Does not modify the exception info state. This function is kept for backwards compatibility. Prefer using <a class="reference internal" href="#c.PyErr_GetHandledException" title="PyErr_GetHandledException"><code>PyErr_GetHandledException()</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is not normally used by code that wants to handle exceptions. Rather, it can be used when code needs to save and restore the exception state temporarily. Use <a class="reference internal" href="#c.PyErr_SetExcInfo" title="PyErr_SetExcInfo"><code>PyErr_SetExcInfo()</code></a> to restore or clear the exception state.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetExcInfo">
<code>void PyErr_SetExcInfo(PyObject *type, PyObject *value, PyObject *traceback)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Set the exception info, as known from <code>sys.exc_info()</code>. This refers to an exception that was <em>already caught</em>, not to an exception that was freshly raised. This function steals the references of the arguments. To clear the exception state, pass <code>NULL</code> for all three arguments. This function is kept for backwards compatibility. Prefer using <a class="reference internal" href="#c.PyErr_SetHandledException" title="PyErr_SetHandledException"><code>PyErr_SetHandledException()</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is not normally used by code that wants to handle exceptions. Rather, it can be used when code needs to save and restore the exception state temporarily. Use <a class="reference internal" href="#c.PyErr_GetExcInfo" title="PyErr_GetExcInfo"><code>PyErr_GetExcInfo()</code></a> to read the exception state.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>The <code>type</code> and <code>traceback</code> arguments are no longer used and can be NULL. The interpreter now derives them from the exception instance (the <code>value</code> argument). The function still steals references of all three arguments.</p> </div> </dd>
</dl> </section> <section id="signal-handling"> <h2>Signal Handling</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_CheckSignals">
<code>int PyErr_CheckSignals()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-1">This function interacts with Python’s signal handling.</p> <p>If the function is called from the main thread and under the main Python interpreter, it checks whether a signal has been sent to the processes and if so, invokes the corresponding signal handler. If the <a class="reference internal" href="../library/signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code>signal</code></a> module is supported, this can invoke a signal handler written in Python.</p> <p>The function attempts to handle all pending signals, and then returns <code>0</code>. However, if a Python signal handler raises an exception, the error indicator is set and the function returns <code>-1</code> immediately (such that other pending signals may not have been handled yet: they will be on the next <a class="reference internal" href="#c.PyErr_CheckSignals" title="PyErr_CheckSignals"><code>PyErr_CheckSignals()</code></a> invocation).</p> <p>If the function is called from a non-main thread, or under a non-main Python interpreter, it does nothing and returns <code>0</code>.</p> <p>This function can be called by long-running C code that wants to be interruptible by user requests (such as by pressing Ctrl-C).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The default Python signal handler for <code>SIGINT</code> raises the <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a> exception.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetInterrupt">
<code>void PyErr_SetInterrupt()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p id="index-2">Simulate the effect of a <code>SIGINT</code> signal arriving. This is equivalent to <code>PyErr_SetInterruptEx(SIGINT)</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is async-signal-safe. It can be called without the <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> and from a C signal handler.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_SetInterruptEx">
<code>int PyErr_SetInterruptEx(int signum)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p id="index-3">Simulate the effect of a signal arriving. The next time <a class="reference internal" href="#c.PyErr_CheckSignals" title="PyErr_CheckSignals"><code>PyErr_CheckSignals()</code></a> is called, the Python signal handler for the given signal number will be called.</p> <p>This function can be called by C code that sets up its own signal handling and wants Python signal handlers to be invoked as expected when an interruption is requested (for example when the user presses Ctrl-C to interrupt an operation).</p> <p>If the given signal isn’t handled by Python (it was set to <a class="reference internal" href="../library/signal.html#signal.SIG_DFL" title="signal.SIG_DFL"><code>signal.SIG_DFL</code></a> or <a class="reference internal" href="../library/signal.html#signal.SIG_IGN" title="signal.SIG_IGN"><code>signal.SIG_IGN</code></a>), it will be ignored.</p> <p>If <em>signum</em> is outside of the allowed range of signal numbers, <code>-1</code> is returned. Otherwise, <code>0</code> is returned. The error indicator is never changed by this function.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is async-signal-safe. It can be called without the <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> and from a C signal handler.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySignal_SetWakeupFd">
<code>int PySignal_SetWakeupFd(int fd)</code> </dt> <dd>
<p>This utility function specifies a file descriptor to which the signal number is written as a single byte whenever a signal is received. <em>fd</em> must be non-blocking. It returns the previous such file descriptor.</p> <p>The value <code>-1</code> disables the feature; this is the initial state. This is equivalent to <a class="reference internal" href="../library/signal.html#signal.set_wakeup_fd" title="signal.set_wakeup_fd"><code>signal.set_wakeup_fd()</code></a> in Python, but without any error checking. <em>fd</em> should be a valid file descriptor. The function should only be called from the main thread.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>On Windows, the function now also supports socket handles.</p> </div> </dd>
</dl> </section> <section id="exception-classes"> <h2>Exception Classes</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_NewException">
<code>PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This utility function creates and returns a new exception class. The <em>name</em> argument must be the name of the new exception, a C string of the form <code>module.classname</code>. The <em>base</em> and <em>dict</em> arguments are normally <code>NULL</code>. This creates a class object derived from <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code>Exception</code></a> (accessible in C as <code>PyExc_Exception</code>).</p> <p>The <a class="reference internal" href="../reference/datamodel.html#type.__module__" title="type.__module__"><code>__module__</code></a> attribute of the new class is set to the first part (up to the last dot) of the <em>name</em> argument, and the class name is set to the last part (after the last dot). The <em>base</em> argument can be used to specify alternate base classes; it can either be only one class or a tuple of classes. The <em>dict</em> argument can be used to specify a dictionary of class variables and methods.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyErr_NewExceptionWithDoc">
<code>PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Same as <a class="reference internal" href="#c.PyErr_NewException" title="PyErr_NewException"><code>PyErr_NewException()</code></a>, except that the new exception class can easily be given a docstring: If <em>doc</em> is non-<code>NULL</code>, it will be used as the docstring for the exception class.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> </section> <section id="exception-objects"> <h2>Exception Objects</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyException_GetTraceback">
<code>PyObject *PyException_GetTraceback(PyObject *ex)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the traceback associated with the exception as a new reference, as accessible from Python through the <a class="reference internal" href="../library/exceptions.html#BaseException.__traceback__" title="BaseException.__traceback__"><code>__traceback__</code></a> attribute. If there is no traceback associated, this returns <code>NULL</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyException_SetTraceback">
<code>int PyException_SetTraceback(PyObject *ex, PyObject *tb)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Set the traceback associated with the exception to <em>tb</em>. Use <code>Py_None</code> to clear it.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyException_GetContext">
<code>PyObject *PyException_GetContext(PyObject *ex)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the context (another exception instance during whose handling <em>ex</em> was raised) associated with the exception as a new reference, as accessible from Python through the <a class="reference internal" href="../library/exceptions.html#BaseException.__context__" title="BaseException.__context__"><code>__context__</code></a> attribute. If there is no context associated, this returns <code>NULL</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyException_SetContext">
<code>void PyException_SetContext(PyObject *ex, PyObject *ctx)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Set the context associated with the exception to <em>ctx</em>. Use <code>NULL</code> to clear it. There is no type check to make sure that <em>ctx</em> is an exception instance. This steals a reference to <em>ctx</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyException_GetCause">
<code>PyObject *PyException_GetCause(PyObject *ex)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the cause (either an exception instance, or <code>None</code>, set by <code>raise ... from ...</code>) associated with the exception as a new reference, as accessible from Python through the <a class="reference internal" href="../library/exceptions.html#BaseException.__cause__" title="BaseException.__cause__"><code>__cause__</code></a> attribute.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyException_SetCause">
<code>void PyException_SetCause(PyObject *ex, PyObject *cause)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Set the cause associated with the exception to <em>cause</em>. Use <code>NULL</code> to clear it. There is no type check to make sure that <em>cause</em> is either an exception instance or <code>None</code>. This steals a reference to <em>cause</em>.</p> <p>The <a class="reference internal" href="../library/exceptions.html#BaseException.__suppress_context__" title="BaseException.__suppress_context__"><code>__suppress_context__</code></a> attribute is implicitly set to <code>True</code> by this function.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyException_GetArgs">
<code>PyObject *PyException_GetArgs(PyObject *ex)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>Return <a class="reference internal" href="../library/exceptions.html#BaseException.args" title="BaseException.args"><code>args</code></a> of exception <em>ex</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyException_SetArgs">
<code>void PyException_SetArgs(PyObject *ex, PyObject *args)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>Set <a class="reference internal" href="../library/exceptions.html#BaseException.args" title="BaseException.args"><code>args</code></a> of exception <em>ex</em> to <em>args</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnstable_Exc_PrepReraiseStar">
<code>PyObject *PyUnstable_Exc_PrepReraiseStar(PyObject *orig, PyObject *excs)</code> </dt> <dd>
<div class="unstable-c-api warning admonition"> <em>This is <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable API</span></a>. It may change without warning in minor releases.</em>
</div> <p>Implement part of the interpreter’s implementation of <code>except*</code>. <em>orig</em> is the original exception that was caught, and <em>excs</em> is the list of the exceptions that need to be raised. This list contains the unhandled part of <em>orig</em>, if any, as well as the exceptions that were raised from the <code>except*</code> clauses (so they have a different traceback from <em>orig</em>) and those that were reraised (and have the same traceback as <em>orig</em>). Return the <a class="reference internal" href="../library/exceptions.html#ExceptionGroup" title="ExceptionGroup"><code>ExceptionGroup</code></a> that needs to be reraised in the end, or <code>None</code> if there is nothing to reraise.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> </section> <section id="unicode-exception-objects"> <span id="unicodeexceptions"></span><h2>Unicode Exception Objects</h2> <p>The following functions are used to create and modify Unicode exceptions from C.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicodeDecodeError_Create">
<code>PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code>UnicodeDecodeError</code></a> object with the attributes <em>encoding</em>, <em>object</em>, <em>length</em>, <em>start</em>, <em>end</em> and <em>reason</em>. <em>encoding</em> and <em>reason</em> are UTF-8 encoded strings.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicodeDecodeError_GetEncoding">
<code>PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *exc)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeEncodeError_GetEncoding">
<code>PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *exc)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the <em>encoding</em> attribute of the given exception object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicodeDecodeError_GetObject">
<code>PyObject *PyUnicodeDecodeError_GetObject(PyObject *exc)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeEncodeError_GetObject">
<code>PyObject *PyUnicodeEncodeError_GetObject(PyObject *exc)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeTranslateError_GetObject">
<code>PyObject *PyUnicodeTranslateError_GetObject(PyObject *exc)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the <em>object</em> attribute of the given exception object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicodeDecodeError_GetStart">
<code>int PyUnicodeDecodeError_GetStart(PyObject *exc, Py_ssize_t *start)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeEncodeError_GetStart">
<code>int PyUnicodeEncodeError_GetStart(PyObject *exc, Py_ssize_t *start)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeTranslateError_GetStart">
<code>int PyUnicodeTranslateError_GetStart(PyObject *exc, Py_ssize_t *start)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Get the <em>start</em> attribute of the given exception object and place it into <em>*start</em>. <em>start</em> must not be <code>NULL</code>. Return <code>0</code> on success, <code>-1</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicodeDecodeError_SetStart">
<code>int PyUnicodeDecodeError_SetStart(PyObject *exc, Py_ssize_t start)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeEncodeError_SetStart">
<code>int PyUnicodeEncodeError_SetStart(PyObject *exc, Py_ssize_t start)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeTranslateError_SetStart">
<code>int PyUnicodeTranslateError_SetStart(PyObject *exc, Py_ssize_t start)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Set the <em>start</em> attribute of the given exception object to <em>start</em>. Return <code>0</code> on success, <code>-1</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicodeDecodeError_GetEnd">
<code>int PyUnicodeDecodeError_GetEnd(PyObject *exc, Py_ssize_t *end)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeEncodeError_GetEnd">
<code>int PyUnicodeEncodeError_GetEnd(PyObject *exc, Py_ssize_t *end)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeTranslateError_GetEnd">
<code>int PyUnicodeTranslateError_GetEnd(PyObject *exc, Py_ssize_t *end)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Get the <em>end</em> attribute of the given exception object and place it into <em>*end</em>. <em>end</em> must not be <code>NULL</code>. Return <code>0</code> on success, <code>-1</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicodeDecodeError_SetEnd">
<code>int PyUnicodeDecodeError_SetEnd(PyObject *exc, Py_ssize_t end)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeEncodeError_SetEnd">
<code>int PyUnicodeEncodeError_SetEnd(PyObject *exc, Py_ssize_t end)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeTranslateError_SetEnd">
<code>int PyUnicodeTranslateError_SetEnd(PyObject *exc, Py_ssize_t end)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Set the <em>end</em> attribute of the given exception object to <em>end</em>. Return <code>0</code> on success, <code>-1</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicodeDecodeError_GetReason">
<code>PyObject *PyUnicodeDecodeError_GetReason(PyObject *exc)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeEncodeError_GetReason">
<code>PyObject *PyUnicodeEncodeError_GetReason(PyObject *exc)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeTranslateError_GetReason">
<code>PyObject *PyUnicodeTranslateError_GetReason(PyObject *exc)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the <em>reason</em> attribute of the given exception object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicodeDecodeError_SetReason">
<code>int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeEncodeError_SetReason">
<code>int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeTranslateError_SetReason">
<code>int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Set the <em>reason</em> attribute of the given exception object to <em>reason</em>. Return <code>0</code> on success, <code>-1</code> on failure.</p> </dd>
</dl> </section> <section id="recursion-control"> <span id="recursion"></span><h2>Recursion Control</h2> <p>These two functions provide a way to perform safe recursive calls at the C level, both in the core and in extension modules. They are needed if the recursive code does not necessarily invoke Python code (which tracks its recursion depth automatically). They are also not needed for <em>tp_call</em> implementations because the <a class="reference internal" href="call.html#call"><span class="std std-ref">call protocol</span></a> takes care of recursion handling.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_EnterRecursiveCall">
<code>int Py_EnterRecursiveCall(const char *where)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.9.</em><p>Marks a point where a recursive C-level call is about to be performed.</p> <p>If <code>USE_STACKCHECK</code> is defined, this function checks if the OS stack overflowed using <a class="reference internal" href="sys.html#c.PyOS_CheckStack" title="PyOS_CheckStack"><code>PyOS_CheckStack()</code></a>. If this is the case, it sets a <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code>MemoryError</code></a> and returns a nonzero value.</p> <p>The function then checks if the recursion limit is reached. If this is the case, a <a class="reference internal" href="../library/exceptions.html#RecursionError" title="RecursionError"><code>RecursionError</code></a> is set and a nonzero value is returned. Otherwise, zero is returned.</p> <p><em>where</em> should be a UTF-8 encoded string such as <code>" in instance check"</code> to be concatenated to the <a class="reference internal" href="../library/exceptions.html#RecursionError" title="RecursionError"><code>RecursionError</code></a> message caused by the recursion depth limit.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>This function is now also available in the <a class="reference internal" href="stable.html#limited-c-api"><span class="std std-ref">limited API</span></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_LeaveRecursiveCall">
<code>void Py_LeaveRecursiveCall(void)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.9.</em><p>Ends a <a class="reference internal" href="#c.Py_EnterRecursiveCall" title="Py_EnterRecursiveCall"><code>Py_EnterRecursiveCall()</code></a>. Must be called once for each <em>successful</em> invocation of <a class="reference internal" href="#c.Py_EnterRecursiveCall" title="Py_EnterRecursiveCall"><code>Py_EnterRecursiveCall()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>This function is now also available in the <a class="reference internal" href="stable.html#limited-c-api"><span class="std std-ref">limited API</span></a>.</p> </div> </dd>
</dl> <p>Properly implementing <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code>tp_repr</code></a> for container types requires special recursion handling. In addition to protecting the stack, <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code>tp_repr</code></a> also needs to track objects to prevent cycles. The following two functions facilitate this functionality. Effectively, these are the C equivalent to <a class="reference internal" href="../library/reprlib.html#reprlib.recursive_repr" title="reprlib.recursive_repr"><code>reprlib.recursive_repr()</code></a>.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_ReprEnter">
<code>int Py_ReprEnter(PyObject *object)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Called at the beginning of the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code>tp_repr</code></a> implementation to detect cycles.</p> <p>If the object has already been processed, the function returns a positive integer. In that case the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code>tp_repr</code></a> implementation should return a string object indicating a cycle. As examples, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code>dict</code></a> objects return <code>{...}</code> and <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code>list</code></a> objects return <code>[...]</code>.</p> <p>The function will return a negative integer if the recursion limit is reached. In that case the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code>tp_repr</code></a> implementation should typically return <code>NULL</code>.</p> <p>Otherwise, the function returns zero and the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code>tp_repr</code></a> implementation can continue normally.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_ReprLeave">
<code>void Py_ReprLeave(PyObject *object)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Ends a <a class="reference internal" href="#c.Py_ReprEnter" title="Py_ReprEnter"><code>Py_ReprEnter()</code></a>. Must be called once for each invocation of <a class="reference internal" href="#c.Py_ReprEnter" title="Py_ReprEnter"><code>Py_ReprEnter()</code></a> that returns zero.</p> </dd>
</dl> </section> <section id="standard-exceptions"> <span id="standardexceptions"></span><h2>Standard Exceptions</h2> <p>All standard Python exceptions are available as global variables whose names are <code>PyExc_</code> followed by the Python exception name. These have the type <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>; they are all class objects. For completeness, here are all the variables:</p> <table class="docutils align-default" id="index-4"> <thead> <tr>
<th class="head"><p>C Name</p></th> <th class="head"><p>Python Name</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p><code>PyExc_BaseException</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code>BaseException</code></a></p></td> <td><p><a class="footnote-reference brackets" href="#id7" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>PyExc_Exception</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code>Exception</code></a></p></td> <td><p><a class="footnote-reference brackets" href="#id7" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>PyExc_ArithmeticError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ArithmeticError" title="ArithmeticError"><code>ArithmeticError</code></a></p></td> <td><p><a class="footnote-reference brackets" href="#id7" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>PyExc_AssertionError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#AssertionError" title="AssertionError"><code>AssertionError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_AttributeError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code>AttributeError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_BlockingIOError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#BlockingIOError" title="BlockingIOError"><code>BlockingIOError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_BrokenPipeError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#BrokenPipeError" title="BrokenPipeError"><code>BrokenPipeError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_BufferError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#BufferError" title="BufferError"><code>BufferError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ChildProcessError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ChildProcessError" title="ChildProcessError"><code>ChildProcessError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ConnectionAbortedError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ConnectionAbortedError" title="ConnectionAbortedError"><code>ConnectionAbortedError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ConnectionError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ConnectionError" title="ConnectionError"><code>ConnectionError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ConnectionRefusedError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ConnectionRefusedError" title="ConnectionRefusedError"><code>ConnectionRefusedError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ConnectionResetError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ConnectionResetError" title="ConnectionResetError"><code>ConnectionResetError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_EOFError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#EOFError" title="EOFError"><code>EOFError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_FileExistsError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_FileNotFoundError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#FileNotFoundError" title="FileNotFoundError"><code>FileNotFoundError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_FloatingPointError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#FloatingPointError" title="FloatingPointError"><code>FloatingPointError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_GeneratorExit</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code>GeneratorExit</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ImportError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code>ImportError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_IndentationError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#IndentationError" title="IndentationError"><code>IndentationError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_IndexError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_InterruptedError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#InterruptedError" title="InterruptedError"><code>InterruptedError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_IsADirectoryError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#IsADirectoryError" title="IsADirectoryError"><code>IsADirectoryError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_KeyError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_KeyboardInterrupt</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_LookupError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code>LookupError</code></a></p></td> <td><p><a class="footnote-reference brackets" href="#id7" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>PyExc_MemoryError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code>MemoryError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ModuleNotFoundError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code>ModuleNotFoundError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_NameError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code>NameError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_NotADirectoryError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#NotADirectoryError" title="NotADirectoryError"><code>NotADirectoryError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_NotImplementedError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_OSError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code>OSError</code></a></p></td> <td><p><a class="footnote-reference brackets" href="#id7" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>PyExc_OverflowError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_PermissionError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#PermissionError" title="PermissionError"><code>PermissionError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ProcessLookupError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ProcessLookupError" title="ProcessLookupError"><code>ProcessLookupError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_PythonFinalizationError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#PythonFinalizationError" title="PythonFinalizationError"><code>PythonFinalizationError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_RecursionError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#RecursionError" title="RecursionError"><code>RecursionError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ReferenceError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ReferenceError" title="ReferenceError"><code>ReferenceError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_RuntimeError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_StopAsyncIteration</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code>StopAsyncIteration</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_StopIteration</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_SyntaxError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_SystemError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code>SystemError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_SystemExit</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code>SystemExit</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_TabError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#TabError" title="TabError"><code>TabError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_TimeoutError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#TimeoutError" title="TimeoutError"><code>TimeoutError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_TypeError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_UnboundLocalError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code>UnboundLocalError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_UnicodeDecodeError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code>UnicodeDecodeError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_UnicodeEncodeError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code>UnicodeEncodeError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_UnicodeError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code>UnicodeError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_UnicodeTranslateError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#UnicodeTranslateError" title="UnicodeTranslateError"><code>UnicodeTranslateError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ValueError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ZeroDivisionError</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code>ZeroDivisionError</code></a></p></td> <td></td> </tr>  </table> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3: </span><code>PyExc_BlockingIOError</code>, <code>PyExc_BrokenPipeError</code>, <code>PyExc_ChildProcessError</code>, <code>PyExc_ConnectionError</code>, <code>PyExc_ConnectionAbortedError</code>, <code>PyExc_ConnectionRefusedError</code>, <code>PyExc_ConnectionResetError</code>, <code>PyExc_FileExistsError</code>, <code>PyExc_FileNotFoundError</code>, <code>PyExc_InterruptedError</code>, <code>PyExc_IsADirectoryError</code>, <code>PyExc_NotADirectoryError</code>, <code>PyExc_PermissionError</code>, <code>PyExc_ProcessLookupError</code> and <code>PyExc_TimeoutError</code> were introduced following <span class="target" id="index-5"></span><a class="pep reference external" href="https://peps.python.org/pep-3151/"><strong>PEP 3151</strong></a>.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5: </span><code>PyExc_StopAsyncIteration</code> and <code>PyExc_RecursionError</code>.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6: </span><code>PyExc_ModuleNotFoundError</code>.</p> </div> <p>These are compatibility aliases to <code>PyExc_OSError</code>:</p> <table class="docutils align-default" id="index-6"> <thead> <tr>
<th class="head"><p>C Name</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p><code>PyExc_EnvironmentError</code></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_IOError</code></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_WindowsError</code></p></td> <td><p><a class="footnote-reference brackets" href="#id8" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>These aliases used to be separate exception types.</p> </div> <p>Notes:</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id7" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>,<a role="doc-backlink" href="#id3">3</a>,<a role="doc-backlink" href="#id4">4</a>,<a role="doc-backlink" href="#id5">5</a>)</span> <p>This is a base class for other standard exceptions.</p> </aside> <aside class="footnote brackets" id="id8" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">2</a><span class="fn-bracket">]</span></span> <p>Only defined on Windows; protect code that uses this by testing that the preprocessor macro <code>MS_WINDOWS</code> is defined.</p> </aside> </aside> </section> <section id="standard-warning-categories"> <span id="standardwarningcategories"></span><h2>Standard Warning Categories</h2> <p>All standard Python warning categories are available as global variables whose names are <code>PyExc_</code> followed by the Python exception name. These have the type <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>; they are all class objects. For completeness, here are all the variables:</p> <table class="docutils align-default" id="index-7"> <thead> <tr>
<th class="head"><p>C Name</p></th> <th class="head"><p>Python Name</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p><code>PyExc_Warning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#Warning" title="Warning"><code>Warning</code></a></p></td> <td><p><a class="footnote-reference brackets" href="#id10" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>PyExc_BytesWarning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#BytesWarning" title="BytesWarning"><code>BytesWarning</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_DeprecationWarning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code>DeprecationWarning</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_FutureWarning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#FutureWarning" title="FutureWarning"><code>FutureWarning</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ImportWarning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code>ImportWarning</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_PendingDeprecationWarning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code>PendingDeprecationWarning</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_ResourceWarning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#ResourceWarning" title="ResourceWarning"><code>ResourceWarning</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_RuntimeWarning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#RuntimeWarning" title="RuntimeWarning"><code>RuntimeWarning</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_SyntaxWarning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#SyntaxWarning" title="SyntaxWarning"><code>SyntaxWarning</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_UnicodeWarning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code>UnicodeWarning</code></a></p></td> <td></td> </tr> <tr>
<td><p><code>PyExc_UserWarning</code></p></td> <td><p><a class="reference internal" href="../library/exceptions.html#UserWarning" title="UserWarning"><code>UserWarning</code></a></p></td> <td></td> </tr>  </table> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2: </span><code>PyExc_ResourceWarning</code>.</p> </div> <p>Notes:</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id10" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">3</a><span class="fn-bracket">]</span></span> <p>This is a base class for other standard warning categories.</p> </aside> </aside> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/exceptions.html" class="_attribution-link">https://docs.python.org/3.13/c-api/exceptions.html</a>
  </p>
</div>
