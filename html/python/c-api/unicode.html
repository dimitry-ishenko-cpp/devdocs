 <span id="unicodeobjects"></span><h1>Unicode Objects and Codecs</h1> <section id="unicode-objects"> <h2>Unicode Objects</h2> <p>Since the implementation of <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0393/"><strong>PEP 393</strong></a> in Python 3.3, Unicode objects internally use a variety of representations, in order to allow handling the complete range of Unicode characters while staying memory efficient. There are special cases for strings where all code points are below 128, 256, or 65536; otherwise, code points must be below 1114112 (which is the full Unicode range).</p> <p>UTF-8 representation is created on demand and cached in the Unicode object.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code>Py_UNICODE</code></a> representation has been removed since Python 3.12 with deprecated APIs. See <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0623/"><strong>PEP 623</strong></a> for more information.</p> </div> <section id="unicode-type"> <h3>Unicode Type</h3> <p>These are the basic Unicode object types used for the Unicode implementation in Python:</p> <dl class="c type"> <dt class="sig sig-object c" id="c.Py_UCS4">
<code>type Py_UCS4</code> </dt> <dt class="sig sig-object c" id="c.Py_UCS2">
<code>type Py_UCS2</code> </dt> <dt class="sig sig-object c" id="c.Py_UCS1">
<code>type Py_UCS1</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>These types are typedefs for unsigned integer types wide enough to contain characters of 32 bits, 16 bits and 8 bits, respectively. When dealing with single Unicode characters, use <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4"><code>Py_UCS4</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.Py_UNICODE">
<code>type Py_UNICODE</code> </dt> <dd>
<p>This is a typedef of <code>wchar_t</code>, which is a 16-bit type or 32-bit type depending on the platform.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>In previous versions, this was a 16-bit type or a 32-bit type depending on whether you selected a “narrow” or “wide” Unicode version of Python at build time.</p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyASCIIObject">
<code>type PyASCIIObject</code> </dt> <dt class="sig sig-object c" id="c.PyCompactUnicodeObject">
<code>type PyCompactUnicodeObject</code> </dt> <dt class="sig sig-object c" id="c.PyUnicodeObject">
<code>type PyUnicodeObject</code> </dt> <dd>
<p>These subtypes of <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> represent a Python Unicode object. In almost all cases, they shouldn’t be used directly, since all API functions that deal with Unicode objects take and return <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> pointers.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyUnicode_Type">
<code>PyTypeObject PyUnicode_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This instance of <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> represents the Python Unicode type. It is exposed to Python code as <code>str</code>.</p> </dd>
</dl> <p>The following APIs are C macros and static inlined functions for fast checks and access to internal read-only data of Unicode objects:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Check">
<code>int PyUnicode_Check(PyObject *obj)</code> </dt> <dd>
<p>Return true if the object <em>obj</em> is a Unicode object or an instance of a Unicode subtype. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_CheckExact">
<code>int PyUnicode_CheckExact(PyObject *obj)</code> </dt> <dd>
<p>Return true if the object <em>obj</em> is a Unicode object, but not an instance of a subtype. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_READY">
<code>int PyUnicode_READY(PyObject *unicode)</code> </dt> <dd>
<p>Returns <code>0</code>. This API is kept only for backward compatibility.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.10: </span>This API does nothing since Python 3.12.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_GET_LENGTH">
<code>Py_ssize_t PyUnicode_GET_LENGTH(PyObject *unicode)</code> </dt> <dd>
<p>Return the length of the Unicode string, in code points. <em>unicode</em> has to be a Unicode object in the “canonical” representation (not checked).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_1BYTE_DATA">
<code>Py_UCS1 *PyUnicode_1BYTE_DATA(PyObject *unicode)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicode_2BYTE_DATA">
<code>Py_UCS2 *PyUnicode_2BYTE_DATA(PyObject *unicode)</code> </dt> <dt class="sig sig-object c" id="c.PyUnicode_4BYTE_DATA">
<code>Py_UCS4 *PyUnicode_4BYTE_DATA(PyObject *unicode)</code> </dt> <dd>
<p>Return a pointer to the canonical representation cast to UCS1, UCS2 or UCS4 integer types for direct character access. No checks are performed if the canonical representation has the correct character size; use <a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code>PyUnicode_KIND()</code></a> to select the right function.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyUnicode_1BYTE_KIND">
<code>PyUnicode_1BYTE_KIND</code> </dt> <dt class="sig sig-object c" id="c.PyUnicode_2BYTE_KIND">
<code>PyUnicode_2BYTE_KIND</code> </dt> <dt class="sig sig-object c" id="c.PyUnicode_4BYTE_KIND">
<code>PyUnicode_4BYTE_KIND</code> </dt> <dd>
<p>Return values of the <a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code>PyUnicode_KIND()</code></a> macro.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span><code>PyUnicode_WCHAR_KIND</code> has been removed.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_KIND">
<code>int PyUnicode_KIND(PyObject *unicode)</code> </dt> <dd>
<p>Return one of the PyUnicode kind constants (see above) that indicate how many bytes per character this Unicode object uses to store its data. <em>unicode</em> has to be a Unicode object in the “canonical” representation (not checked).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DATA">
<code>void *PyUnicode_DATA(PyObject *unicode)</code> </dt> <dd>
<p>Return a void pointer to the raw Unicode buffer. <em>unicode</em> has to be a Unicode object in the “canonical” representation (not checked).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_WRITE">
<code>void PyUnicode_WRITE(int kind, void *data, Py_ssize_t index, Py_UCS4 value)</code> </dt> <dd>
<p>Write into a canonical representation <em>data</em> (as obtained with <a class="reference internal" href="#c.PyUnicode_DATA" title="PyUnicode_DATA"><code>PyUnicode_DATA()</code></a>). This function performs no sanity checks, and is intended for usage in loops. The caller should cache the <em>kind</em> value and <em>data</em> pointer as obtained from other calls. <em>index</em> is the index in the string (starts at 0) and <em>value</em> is the new code point value which should be written to that location.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_READ">
<code>Py_UCS4 PyUnicode_READ(int kind, void *data, Py_ssize_t index)</code> </dt> <dd>
<p>Read a code point from a canonical representation <em>data</em> (as obtained with <a class="reference internal" href="#c.PyUnicode_DATA" title="PyUnicode_DATA"><code>PyUnicode_DATA()</code></a>). No checks or ready calls are performed.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_READ_CHAR">
<code>Py_UCS4 PyUnicode_READ_CHAR(PyObject *unicode, Py_ssize_t index)</code> </dt> <dd>
<p>Read a character from a Unicode object <em>unicode</em>, which must be in the “canonical” representation. This is less efficient than <a class="reference internal" href="#c.PyUnicode_READ" title="PyUnicode_READ"><code>PyUnicode_READ()</code></a> if you do multiple consecutive reads.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_MAX_CHAR_VALUE">
<code>Py_UCS4 PyUnicode_MAX_CHAR_VALUE(PyObject *unicode)</code> </dt> <dd>
<p>Return the maximum code point that is suitable for creating another string based on <em>unicode</em>, which must be in the “canonical” representation. This is always an approximation but more efficient than iterating over the string.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_IsIdentifier">
<code>int PyUnicode_IsIdentifier(PyObject *unicode)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return <code>1</code> if the string is a valid identifier according to the language definition, section <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">Identifiers and keywords</span></a>. Return <code>0</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>The function does not call <a class="reference internal" href="sys.html#c.Py_FatalError" title="Py_FatalError"><code>Py_FatalError()</code></a> anymore if the string is not ready.</p> </div> </dd>
</dl> </section> <section id="unicode-character-properties"> <h3>Unicode Character Properties</h3> <p>Unicode provides many different character properties. The most often needed ones are available through these macros which are mapped to C functions depending on the Python configuration.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISSPACE">
<code>int Py_UNICODE_ISSPACE(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is a whitespace character.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISLOWER">
<code>int Py_UNICODE_ISLOWER(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is a lowercase character.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISUPPER">
<code>int Py_UNICODE_ISUPPER(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is an uppercase character.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISTITLE">
<code>int Py_UNICODE_ISTITLE(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is a titlecase character.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISLINEBREAK">
<code>int Py_UNICODE_ISLINEBREAK(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is a linebreak character.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISDECIMAL">
<code>int Py_UNICODE_ISDECIMAL(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is a decimal character.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISDIGIT">
<code>int Py_UNICODE_ISDIGIT(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is a digit character.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISNUMERIC">
<code>int Py_UNICODE_ISNUMERIC(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is a numeric character.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISALPHA">
<code>int Py_UNICODE_ISALPHA(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is an alphabetic character.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISALNUM">
<code>int Py_UNICODE_ISALNUM(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is an alphanumeric character.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_ISPRINTABLE">
<code>int Py_UNICODE_ISPRINTABLE(Py_UCS4 ch)</code> </dt> <dd>
<p>Return <code>1</code> or <code>0</code> depending on whether <em>ch</em> is a printable character. Nonprintable characters are those characters defined in the Unicode character database as “Other” or “Separator”, excepting the ASCII space (0x20) which is considered printable. (Note that printable characters in this context are those which should not be escaped when <a class="reference internal" href="../library/functions.html#repr" title="repr"><code>repr()</code></a> is invoked on a string. It has no bearing on the handling of strings written to <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><code>sys.stdout</code></a> or <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code>sys.stderr</code></a>.)</p> </dd>
</dl> <p>These APIs can be used for fast direct character conversions:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_TOLOWER">
<code>Py_UCS4 Py_UNICODE_TOLOWER(Py_UCS4 ch)</code> </dt> <dd>
<p>Return the character <em>ch</em> converted to lower case.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.3: </span>This function uses simple case mappings.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_TOUPPER">
<code>Py_UCS4 Py_UNICODE_TOUPPER(Py_UCS4 ch)</code> </dt> <dd>
<p>Return the character <em>ch</em> converted to upper case.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.3: </span>This function uses simple case mappings.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_TOTITLE">
<code>Py_UCS4 Py_UNICODE_TOTITLE(Py_UCS4 ch)</code> </dt> <dd>
<p>Return the character <em>ch</em> converted to title case.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.3: </span>This function uses simple case mappings.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_TODECIMAL">
<code>int Py_UNICODE_TODECIMAL(Py_UCS4 ch)</code> </dt> <dd>
<p>Return the character <em>ch</em> converted to a decimal positive integer. Return <code>-1</code> if this is not possible. This function does not raise exceptions.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_TODIGIT">
<code>int Py_UNICODE_TODIGIT(Py_UCS4 ch)</code> </dt> <dd>
<p>Return the character <em>ch</em> converted to a single digit integer. Return <code>-1</code> if this is not possible. This function does not raise exceptions.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_TONUMERIC">
<code>double Py_UNICODE_TONUMERIC(Py_UCS4 ch)</code> </dt> <dd>
<p>Return the character <em>ch</em> converted to a double. Return <code>-1.0</code> if this is not possible. This function does not raise exceptions.</p> </dd>
</dl> <p>These APIs can be used to work with surrogates:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_IS_SURROGATE">
<code>int Py_UNICODE_IS_SURROGATE(Py_UCS4 ch)</code> </dt> <dd>
<p>Check if <em>ch</em> is a surrogate (<code>0xD800 &lt;= ch &lt;= 0xDFFF</code>).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_IS_HIGH_SURROGATE">
<code>int Py_UNICODE_IS_HIGH_SURROGATE(Py_UCS4 ch)</code> </dt> <dd>
<p>Check if <em>ch</em> is a high surrogate (<code>0xD800 &lt;= ch &lt;= 0xDBFF</code>).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_IS_LOW_SURROGATE">
<code>int Py_UNICODE_IS_LOW_SURROGATE(Py_UCS4 ch)</code> </dt> <dd>
<p>Check if <em>ch</em> is a low surrogate (<code>0xDC00 &lt;= ch &lt;= 0xDFFF</code>).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_UNICODE_JOIN_SURROGATES">
<code>Py_UCS4 Py_UNICODE_JOIN_SURROGATES(Py_UCS4 high, Py_UCS4 low)</code> </dt> <dd>
<p>Join two surrogate characters and return a single <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4"><code>Py_UCS4</code></a> value. <em>high</em> and <em>low</em> are respectively the leading and trailing surrogates in a surrogate pair. <em>high</em> must be in the range [0xD800; 0xDBFF] and <em>low</em> must be in the range [0xDC00; 0xDFFF].</p> </dd>
</dl> </section> <section id="creating-and-accessing-unicode-strings"> <h3>Creating and accessing Unicode strings</h3> <p>To create Unicode objects and access their basic sequence properties, use these APIs:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_New">
<code>PyObject *PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Create a new Unicode object. <em>maxchar</em> should be the true maximum code point to be placed in the string. As an approximation, it can be rounded up to the nearest value in the sequence 127, 255, 65535, 1114111.</p> <p>This is the recommended way to allocate a new Unicode object. Objects created using this function are not resizable.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FromKindAndData">
<code>PyObject *PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Create a new Unicode object with the given <em>kind</em> (possible values are <a class="reference internal" href="#c.PyUnicode_1BYTE_KIND" title="PyUnicode_1BYTE_KIND"><code>PyUnicode_1BYTE_KIND</code></a> etc., as returned by <a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code>PyUnicode_KIND()</code></a>). The <em>buffer</em> must point to an array of <em>size</em> units of 1, 2 or 4 bytes per character, as given by the kind.</p> <p>If necessary, the input <em>buffer</em> is copied and transformed into the canonical representation. For example, if the <em>buffer</em> is a UCS4 string (<a class="reference internal" href="#c.PyUnicode_4BYTE_KIND" title="PyUnicode_4BYTE_KIND"><code>PyUnicode_4BYTE_KIND</code></a>) and it consists only of codepoints in the UCS1 range, it will be transformed into UCS1 (<a class="reference internal" href="#c.PyUnicode_1BYTE_KIND" title="PyUnicode_1BYTE_KIND"><code>PyUnicode_1BYTE_KIND</code></a>).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FromStringAndSize">
<code>PyObject *PyUnicode_FromStringAndSize(const char *str, Py_ssize_t size)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object from the char buffer <em>str</em>. The bytes will be interpreted as being UTF-8 encoded. The buffer is copied into the new object. The return value might be a shared object, i.e. modification of the data is not allowed.</p> <p>This function raises <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code>SystemError</code></a> when:</p> <ul class="simple"> <li>
<em>size</em> &lt; 0,</li> <li>
<em>str</em> is <code>NULL</code> and <em>size</em> &gt; 0</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span><em>str</em> == <code>NULL</code> with <em>size</em> &gt; 0 is not allowed anymore.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FromString">
<code>PyObject *PyUnicode_FromString(const char *str)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object from a UTF-8 encoded null-terminated char buffer <em>str</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FromFormat">
<code>PyObject *PyUnicode_FromFormat(const char *format, ...)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Take a C <code>printf()</code>-style <em>format</em> string and a variable number of arguments, calculate the size of the resulting Python Unicode string and return a string with the values formatted into it. The variable arguments must be C types and must correspond exactly to the format characters in the <em>format</em> ASCII-encoded string.</p> <p>A conversion specifier contains two or more characters and has the following components, which must occur in this order:</p> <ol class="arabic simple"> <li>The <code>'%'</code> character, which marks the start of the specifier.</li> <li>Conversion flags (optional), which affect the result of some conversion types.</li> <li>Minimum field width (optional). If specified as an <code>'*'</code> (asterisk), the actual width is given in the next argument, which must be of type <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>, and the object to convert comes after the minimum field width and optional precision.</li> <li>Precision (optional), given as a <code>'.'</code> (dot) followed by the precision. If specified as <code>'*'</code> (an asterisk), the actual precision is given in the next argument, which must be of type <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>, and the value to convert comes after the precision.</li> <li>Length modifier (optional).</li> <li>Conversion type.</li> </ol> <p>The conversion flag characters are:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Flag</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><code>0</code></p></td> <td><p>The conversion will be zero padded for numeric values.</p></td> </tr> <tr>
<td><p><code>-</code></p></td> <td><p>The converted value is left adjusted (overrides the <code>0</code> flag if both are given).</p></td> </tr>  </table> <p>The length modifiers for following integer conversions (<code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or <code>X</code>) specify the type of the argument (<span class="c-expr sig sig-inline c"><span class="kt">int</span></span> by default):</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Modifier</p></th> <th class="head"><p>Types</p></th> </tr> </thead>  <tr>
<td><p><code>l</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">long</span></span> or <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span></p></td> </tr> <tr>
<td><p><code>ll</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> or <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td> </tr> <tr>
<td><p><code>j</code></p></td> <td><p><code>intmax_t</code> or <code>uintmax_t</code></p></td> </tr> <tr>
<td><p><code>z</code></p></td> <td><p><code>size_t</code> or <code>ssize_t</code></p></td> </tr> <tr>
<td><p><code>t</code></p></td> <td><p><code>ptrdiff_t</code></p></td> </tr>  </table> <p>The length modifier <code>l</code> for following conversions <code>s</code> or <code>V</code> specify that the type of the argument is <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="n">wchar_t</span><span class="p">*</span></span>.</p> <p>The conversion specifiers are:</p> <table class="colwidths-auto docutils align-default"> <thead> <tr>
<th class="head"><p>Conversion Specifier</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Comment</p></th> </tr> </thead>  <tr>
<td><p><code>%</code></p></td> <td><p><em>n/a</em></p></td> <td><p>The literal <code>%</code> character.</p></td> </tr> <tr>
<td><p><code>d</code>, <code>i</code></p></td> <td><p>Specified by the length modifier</p></td> <td><p>The decimal representation of a signed C integer.</p></td> </tr> <tr>
<td><p><code>u</code></p></td> <td><p>Specified by the length modifier</p></td> <td><p>The decimal representation of an unsigned C integer.</p></td> </tr> <tr>
<td><p><code>o</code></p></td> <td><p>Specified by the length modifier</p></td> <td><p>The octal representation of an unsigned C integer.</p></td> </tr> <tr>
<td><p><code>x</code></p></td> <td><p>Specified by the length modifier</p></td> <td><p>The hexadecimal representation of an unsigned C integer (lowercase).</p></td> </tr> <tr>
<td><p><code>X</code></p></td> <td><p>Specified by the length modifier</p></td> <td><p>The hexadecimal representation of an unsigned C integer (uppercase).</p></td> </tr> <tr>
<td><p><code>c</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">int</span></span></p></td> <td><p>A single character.</p></td> </tr> <tr>
<td><p><code>s</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> or <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="n">wchar_t</span><span class="p">*</span></span></p></td> <td><p>A null-terminated C character array.</p></td> </tr> <tr>
<td><p><code>p</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="p">*</span></span></p></td> <td><p>The hex representation of a C pointer. Mostly equivalent to <code>printf("%p")</code> except that it is guaranteed to start with the literal <code>0x</code> regardless of what the platform’s <code>printf</code> yields.</p></td> </tr> <tr>
<td><p><code>A</code></p></td> <td><p><span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span></p></td> <td><p>The result of calling <a class="reference internal" href="../library/functions.html#ascii" title="ascii"><code>ascii()</code></a>.</p></td> </tr> <tr>
<td><p><code>U</code></p></td> <td><p><span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span></p></td> <td><p>A Unicode object.</p></td> </tr> <tr>
<td><p><code>V</code></p></td> <td><p><span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>, <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> or <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="n">wchar_t</span><span class="p">*</span></span></p></td> <td><p>A Unicode object (which may be <code>NULL</code>) and a null-terminated C character array as a second parameter (which will be used, if the first parameter is <code>NULL</code>).</p></td> </tr> <tr>
<td><p><code>S</code></p></td> <td><p><span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span></p></td> <td><p>The result of calling <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code>PyObject_Str()</code></a>.</p></td> </tr> <tr>
<td><p><code>R</code></p></td> <td><p><span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span></p></td> <td><p>The result of calling <a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code>PyObject_Repr()</code></a>.</p></td> </tr>  </table> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The width formatter unit is number of characters rather than bytes. The precision formatter unit is number of bytes or <code>wchar_t</code> items (if the length modifier <code>l</code> is used) for <code>"%s"</code> and <code>"%V"</code> (if the <code>PyObject*</code> argument is <code>NULL</code>), and a number of characters for <code>"%A"</code>, <code>"%U"</code>, <code>"%S"</code>, <code>"%R"</code> and <code>"%V"</code> (if the <code>PyObject*</code> argument is not <code>NULL</code>).</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Unlike to C <code>printf()</code> the <code>0</code> flag has effect even when a precision is given for integer conversions (<code>d</code>, <code>i</code>, <code>u</code>, <code>o</code>, <code>x</code>, or <code>X</code>).</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Support for <code>"%lld"</code> and <code>"%llu"</code> added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Support for <code>"%li"</code>, <code>"%lli"</code> and <code>"%zi"</code> added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Support width and precision formatter for <code>"%s"</code>, <code>"%A"</code>, <code>"%U"</code>, <code>"%V"</code>, <code>"%S"</code>, <code>"%R"</code> added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Support for conversion specifiers <code>o</code> and <code>X</code>. Support for length modifiers <code>j</code> and <code>t</code>. Length modifiers are now applied to all integer conversions. Length modifier <code>l</code> is now applied to conversion specifiers <code>s</code> and <code>V</code>. Support for variable width and precision <code>*</code>. Support for flag <code>-</code>.</p> <p>An unrecognized format character now sets a <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code>SystemError</code></a>. In previous versions it caused all the rest of the format string to be copied as-is to the result string, and any extra arguments discarded.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FromFormatV">
<code>PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Identical to <a class="reference internal" href="#c.PyUnicode_FromFormat" title="PyUnicode_FromFormat"><code>PyUnicode_FromFormat()</code></a> except that it takes exactly two arguments.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FromObject">
<code>PyObject *PyUnicode_FromObject(PyObject *obj)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Copy an instance of a Unicode subtype to a new true Unicode object if necessary. If <em>obj</em> is already a true Unicode object (not a subtype), return a new <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to the object.</p> <p>Objects other than Unicode or its subtypes will cause a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FromEncodedObject">
<code>PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Decode an encoded object <em>obj</em> to a Unicode object.</p> <p><a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a>, <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> and other <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a> are decoded according to the given <em>encoding</em> and using the error handling defined by <em>errors</em>. Both can be <code>NULL</code> to have the interface use the default values (see <a class="reference internal" href="#builtincodecs"><span class="std std-ref">Built-in Codecs</span></a> for details).</p> <p>All other objects, including Unicode objects, cause a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> to be set.</p> <p>The API returns <code>NULL</code> if there was an error. The caller is responsible for decref’ing the returned objects.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_GetLength">
<code>Py_ssize_t PyUnicode_GetLength(PyObject *unicode)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Return the length of the Unicode object, in code points.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_CopyCharacters">
<code>Py_ssize_t PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)</code> </dt> <dd>
<p>Copy characters from one Unicode object into another. This function performs character conversion when necessary and falls back to <code>memcpy()</code> if possible. Returns <code>-1</code> and sets an exception on error, otherwise returns the number of copied characters.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Fill">
<code>Py_ssize_t PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)</code> </dt> <dd>
<p>Fill a string with a character: write <em>fill_char</em> into <code>unicode[start:start+length]</code>.</p> <p>Fail if <em>fill_char</em> is bigger than the string maximum character, or if the string has more than 1 reference.</p> <p>Return the number of written character, or return <code>-1</code> and raise an exception on error.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_WriteChar">
<code>int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Write a character to a string. The string must have been created through <a class="reference internal" href="#c.PyUnicode_New" title="PyUnicode_New"><code>PyUnicode_New()</code></a>. Since Unicode strings are supposed to be immutable, the string must not be shared, or have been hashed yet.</p> <p>This function checks that <em>unicode</em> is a Unicode object, that the index is not out of bounds, and that the object can be modified safely (i.e. that it its reference count is one).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_ReadChar">
<code>Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Read a character from a string. This function checks that <em>unicode</em> is a Unicode object and the index is not out of bounds, in contrast to <a class="reference internal" href="#c.PyUnicode_READ_CHAR" title="PyUnicode_READ_CHAR"><code>PyUnicode_READ_CHAR()</code></a>, which performs no error checking.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Substring">
<code>PyObject *PyUnicode_Substring(PyObject *unicode, Py_ssize_t start, Py_ssize_t end)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Return a substring of <em>unicode</em>, from character index <em>start</em> (included) to character index <em>end</em> (excluded). Negative indices are not supported.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsUCS4">
<code>Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Copy the string <em>unicode</em> into a UCS4 buffer, including a null character, if <em>copy_null</em> is set. Returns <code>NULL</code> and sets an exception on error (in particular, a <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code>SystemError</code></a> if <em>buflen</em> is smaller than the length of <em>unicode</em>). <em>buffer</em> is returned on success.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsUCS4Copy">
<code>Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Copy the string <em>unicode</em> into a new UCS4 buffer that is allocated using <a class="reference internal" href="memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code>PyMem_Malloc()</code></a>. If this fails, <code>NULL</code> is returned with a <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code>MemoryError</code></a> set. The returned buffer always has an extra null code point appended.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> </section> <section id="locale-encoding"> <h3>Locale Encoding</h3> <p>The current locale encoding can be used to decode text from the operating system.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeLocaleAndSize">
<code>PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t length, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Decode a string from UTF-8 on Android and VxWorks, or from the current locale encoding on other platforms. The supported error handlers are <code>"strict"</code> and <code>"surrogateescape"</code> (<span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0383/"><strong>PEP 383</strong></a>). The decoder uses <code>"strict"</code> error handler if <em>errors</em> is <code>NULL</code>. <em>str</em> must end with a null character but cannot contain embedded null characters.</p> <p>Use <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code>PyUnicode_DecodeFSDefaultAndSize()</code></a> to decode a string from the <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p> <p>This function ignores the <a class="reference internal" href="../library/os.html#utf8-mode"><span class="std std-ref">Python UTF-8 Mode</span></a>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code>Py_DecodeLocale()</code></a> function.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>The function now also uses the current locale encoding for the <code>surrogateescape</code> error handler, except on Android. Previously, <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code>Py_DecodeLocale()</code></a> was used for the <code>surrogateescape</code>, and the current locale encoding was used for <code>strict</code>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeLocale">
<code>PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Similar to <a class="reference internal" href="#c.PyUnicode_DecodeLocaleAndSize" title="PyUnicode_DecodeLocaleAndSize"><code>PyUnicode_DecodeLocaleAndSize()</code></a>, but compute the string length using <code>strlen()</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_EncodeLocale">
<code>PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Encode a Unicode object to UTF-8 on Android and VxWorks, or to the current locale encoding on other platforms. The supported error handlers are <code>"strict"</code> and <code>"surrogateescape"</code> (<span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0383/"><strong>PEP 383</strong></a>). The encoder uses <code>"strict"</code> error handler if <em>errors</em> is <code>NULL</code>. Return a <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object. <em>unicode</em> cannot contain embedded null characters.</p> <p>Use <a class="reference internal" href="#c.PyUnicode_EncodeFSDefault" title="PyUnicode_EncodeFSDefault"><code>PyUnicode_EncodeFSDefault()</code></a> to encode a string to the <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p> <p>This function ignores the <a class="reference internal" href="../library/os.html#utf8-mode"><span class="std std-ref">Python UTF-8 Mode</span></a>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code>Py_EncodeLocale()</code></a> function.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>The function now also uses the current locale encoding for the <code>surrogateescape</code> error handler, except on Android. Previously, <a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code>Py_EncodeLocale()</code></a> was used for the <code>surrogateescape</code>, and the current locale encoding was used for <code>strict</code>.</p> </div> </dd>
</dl> </section> <section id="file-system-encoding"> <h3>File System Encoding</h3> <p>Functions encoding to and decoding from the <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a> (<span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0383/"><strong>PEP 383</strong></a> and <span class="target" id="index-5"></span><a class="pep reference external" href="https://peps.python.org/pep-0529/"><strong>PEP 529</strong></a>).</p> <p>To encode file names to <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> during argument parsing, the <code>"O&amp;"</code> converter should be used, passing <a class="reference internal" href="#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code>PyUnicode_FSConverter()</code></a> as the conversion function:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FSConverter">
<code>int PyUnicode_FSConverter(PyObject *obj, void *result)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>ParseTuple converter: encode <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> objects – obtained directly or through the <a class="reference internal" href="../library/os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> interface – to <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> using <a class="reference internal" href="#c.PyUnicode_EncodeFSDefault" title="PyUnicode_EncodeFSDefault"><code>PyUnicode_EncodeFSDefault()</code></a>; <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> objects are output as-is. <em>result</em> must be a <span class="c-expr sig sig-inline c"><a class="reference internal" href="bytes.html#c.PyBytesObject" title="PyBytesObject"><span class="n">PyBytesObject</span></a><span class="p">*</span></span> which must be released when it is no longer used.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.1.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <p>To decode file names to <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> during argument parsing, the <code>"O&amp;"</code> converter should be used, passing <a class="reference internal" href="#c.PyUnicode_FSDecoder" title="PyUnicode_FSDecoder"><code>PyUnicode_FSDecoder()</code></a> as the conversion function:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FSDecoder">
<code>int PyUnicode_FSDecoder(PyObject *obj, void *result)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>ParseTuple converter: decode <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> objects – obtained either directly or indirectly through the <a class="reference internal" href="../library/os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> interface – to <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> using <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code>PyUnicode_DecodeFSDefaultAndSize()</code></a>; <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> objects are output as-is. <em>result</em> must be a <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyUnicodeObject" title="PyUnicodeObject"><span class="n">PyUnicodeObject</span></a><span class="p">*</span></span> which must be released when it is no longer used.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeFSDefaultAndSize">
<code>PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *str, Py_ssize_t size)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Decode a string from the <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p> <p>If you need to decode a string from the current locale encoding, use <a class="reference internal" href="#c.PyUnicode_DecodeLocaleAndSize" title="PyUnicode_DecodeLocaleAndSize"><code>PyUnicode_DecodeLocaleAndSize()</code></a>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code>Py_DecodeLocale()</code></a> function.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>The <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem error handler</span></a> is now used.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeFSDefault">
<code>PyObject *PyUnicode_DecodeFSDefault(const char *str)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Decode a null-terminated string from the <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p> <p>If the string length is known, use <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code>PyUnicode_DecodeFSDefaultAndSize()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>The <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem error handler</span></a> is now used.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_EncodeFSDefault">
<code>PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Encode a Unicode object to the <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>, and return <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a>. Note that the resulting <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object can contain null bytes.</p> <p>If you need to encode a string to the current locale encoding, use <a class="reference internal" href="#c.PyUnicode_EncodeLocale" title="PyUnicode_EncodeLocale"><code>PyUnicode_EncodeLocale()</code></a>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code>Py_EncodeLocale()</code></a> function.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>The <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem error handler</span></a> is now used.</p> </div> </dd>
</dl> </section> <section id="wchar-t-support"> <h3>wchar_t Support</h3> <p><code>wchar_t</code> support for platforms which support it:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FromWideChar">
<code>PyObject *PyUnicode_FromWideChar(const wchar_t *wstr, Py_ssize_t size)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object from the <code>wchar_t</code> buffer <em>wstr</em> of the given <em>size</em>. Passing <code>-1</code> as the <em>size</em> indicates that the function must itself compute the length, using <code>wcslen()</code>. Return <code>NULL</code> on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsWideChar">
<code>Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *wstr, Py_ssize_t size)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Copy the Unicode object contents into the <code>wchar_t</code> buffer <em>wstr</em>. At most <em>size</em> <code>wchar_t</code> characters are copied (excluding a possibly trailing null termination character). Return the number of <code>wchar_t</code> characters copied or <code>-1</code> in case of an error. Note that the resulting <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> string may or may not be null-terminated. It is the responsibility of the caller to make sure that the <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> string is null-terminated in case this is required by the application. Also, note that the <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> string might contain null characters, which would cause the string to be truncated when used with most C functions.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsWideCharString">
<code>wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Convert the Unicode object to a wide character string. The output string always ends with a null character. If <em>size</em> is not <code>NULL</code>, write the number of wide characters (excluding the trailing null termination character) into <em>*size</em>. Note that the resulting <code>wchar_t</code> string might contain null characters, which would cause the string to be truncated when used with most C functions. If <em>size</em> is <code>NULL</code> and the <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> string contains null characters a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised.</p> <p>Returns a buffer allocated by <a class="reference internal" href="memory.html#c.PyMem_New" title="PyMem_New"><code>PyMem_New</code></a> (use <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code>PyMem_Free()</code></a> to free it) on success. On error, returns <code>NULL</code> and <em>*size</em> is undefined. Raises a <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code>MemoryError</code></a> if memory allocation is failed.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Raises a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if <em>size</em> is <code>NULL</code> and the <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> string contains null characters.</p> </div> </dd>
</dl> </section> </section> <section id="built-in-codecs"> <span id="builtincodecs"></span><h2>Built-in Codecs</h2> <p>Python provides a set of built-in codecs which are written in C for speed. All of these codecs are directly usable via the following functions.</p> <p>Many of the following APIs take two arguments encoding and errors, and they have the same semantics as the ones of the built-in <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str()</code></a> string object constructor.</p> <p>Setting encoding to <code>NULL</code> causes the default encoding to be used which is UTF-8. The file system calls should use <a class="reference internal" href="#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code>PyUnicode_FSConverter()</code></a> for encoding file names. This uses the <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a> internally.</p> <p>Error handling is set by errors which may also be set to <code>NULL</code> meaning to use the default handling defined for the codec. Default error handling for all built-in codecs is “strict” (<a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised).</p> <p>The codecs all use a similar interface. Only deviations from the following generic ones are documented for simplicity.</p> <section id="generic-codecs"> <h3>Generic Codecs</h3> <p>These are the generic codec APIs:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Decode">
<code>PyObject *PyUnicode_Decode(const char *str, Py_ssize_t size, const char *encoding, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the encoded string <em>str</em>. <em>encoding</em> and <em>errors</em> have the same meaning as the parameters of the same name in the <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str()</code></a> built-in function. The codec to be used is looked up using the Python codec registry. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsEncodedString">
<code>PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Encode a Unicode object and return the result as Python bytes object. <em>encoding</em> and <em>errors</em> have the same meaning as the parameters of the same name in the Unicode <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code>encode()</code></a> method. The codec to be used is looked up using the Python codec registry. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> </section> <section id="utf-8-codecs"> <h3>UTF-8 Codecs</h3> <p>These are the UTF-8 codec APIs:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeUTF8">
<code>PyObject *PyUnicode_DecodeUTF8(const char *str, Py_ssize_t size, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the UTF-8 encoded string <em>str</em>. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeUTF8Stateful">
<code>PyObject *PyUnicode_DecodeUTF8Stateful(const char *str, Py_ssize_t size, const char *errors, Py_ssize_t *consumed)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>If <em>consumed</em> is <code>NULL</code>, behave like <a class="reference internal" href="#c.PyUnicode_DecodeUTF8" title="PyUnicode_DecodeUTF8"><code>PyUnicode_DecodeUTF8()</code></a>. If <em>consumed</em> is not <code>NULL</code>, trailing incomplete UTF-8 byte sequences will not be treated as an error. Those bytes will not be decoded and the number of bytes that have been decoded will be stored in <em>consumed</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsUTF8String">
<code>PyObject *PyUnicode_AsUTF8String(PyObject *unicode)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Encode a Unicode object using UTF-8 and return the result as Python bytes object. Error handling is “strict”. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsUTF8AndSize">
<code>const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Return a pointer to the UTF-8 encoding of the Unicode object, and store the size of the encoded representation (in bytes) in <em>size</em>. The <em>size</em> argument can be <code>NULL</code>; in this case no size will be stored. The returned buffer always has an extra null byte appended (not included in <em>size</em>), regardless of whether there are any other null code points.</p> <p>In the case of an error, <code>NULL</code> is returned with an exception set and no <em>size</em> is stored.</p> <p>This caches the UTF-8 representation of the string in the Unicode object, and subsequent calls will return a pointer to the same buffer. The caller is not responsible for deallocating the buffer. The buffer is deallocated and pointers to it become invalid when the Unicode object is garbage collected.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>The return type is now <code>const char *</code> rather of <code>char *</code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>This function is a part of the <a class="reference internal" href="stable.html#limited-c-api"><span class="std std-ref">limited API</span></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsUTF8">
<code>const char *PyUnicode_AsUTF8(PyObject *unicode)</code> </dt> <dd>
<p>As <a class="reference internal" href="#c.PyUnicode_AsUTF8AndSize" title="PyUnicode_AsUTF8AndSize"><code>PyUnicode_AsUTF8AndSize()</code></a>, but does not store the size.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>The return type is now <code>const char *</code> rather of <code>char *</code>.</p> </div> </dd>
</dl> </section> <section id="utf-32-codecs"> <h3>UTF-32 Codecs</h3> <p>These are the UTF-32 codec APIs:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeUTF32">
<code>PyObject *PyUnicode_DecodeUTF32(const char *str, Py_ssize_t size, const char *errors, int *byteorder)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Decode <em>size</em> bytes from a UTF-32 encoded buffer string and return the corresponding Unicode object. <em>errors</em> (if non-<code>NULL</code>) defines the error handling. It defaults to “strict”.</p> <p>If <em>byteorder</em> is non-<code>NULL</code>, the decoder starts decoding using the given byte order:</p> <pre data-language="c">*byteorder == -1: little endian
*byteorder == 0:  native order
*byteorder == 1:  big endian
</pre> <p>If <code>*byteorder</code> is zero, and the first four bytes of the input data are a byte order mark (BOM), the decoder switches to this byte order and the BOM is not copied into the resulting Unicode string. If <code>*byteorder</code> is <code>-1</code> or <code>1</code>, any byte order mark is copied to the output.</p> <p>After completion, <em>*byteorder</em> is set to the current byte order at the end of input data.</p> <p>If <em>byteorder</em> is <code>NULL</code>, the codec starts in native order mode.</p> <p>Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeUTF32Stateful">
<code>PyObject *PyUnicode_DecodeUTF32Stateful(const char *str, Py_ssize_t size, const char *errors, int *byteorder, Py_ssize_t *consumed)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>If <em>consumed</em> is <code>NULL</code>, behave like <a class="reference internal" href="#c.PyUnicode_DecodeUTF32" title="PyUnicode_DecodeUTF32"><code>PyUnicode_DecodeUTF32()</code></a>. If <em>consumed</em> is not <code>NULL</code>, <a class="reference internal" href="#c.PyUnicode_DecodeUTF32Stateful" title="PyUnicode_DecodeUTF32Stateful"><code>PyUnicode_DecodeUTF32Stateful()</code></a> will not treat trailing incomplete UTF-32 byte sequences (such as a number of bytes not divisible by four) as an error. Those bytes will not be decoded and the number of bytes that have been decoded will be stored in <em>consumed</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsUTF32String">
<code>PyObject *PyUnicode_AsUTF32String(PyObject *unicode)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a Python byte string using the UTF-32 encoding in native byte order. The string always starts with a BOM mark. Error handling is “strict”. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> </section> <section id="utf-16-codecs"> <h3>UTF-16 Codecs</h3> <p>These are the UTF-16 codec APIs:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeUTF16">
<code>PyObject *PyUnicode_DecodeUTF16(const char *str, Py_ssize_t size, const char *errors, int *byteorder)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Decode <em>size</em> bytes from a UTF-16 encoded buffer string and return the corresponding Unicode object. <em>errors</em> (if non-<code>NULL</code>) defines the error handling. It defaults to “strict”.</p> <p>If <em>byteorder</em> is non-<code>NULL</code>, the decoder starts decoding using the given byte order:</p> <pre data-language="c">*byteorder == -1: little endian
*byteorder == 0:  native order
*byteorder == 1:  big endian
</pre> <p>If <code>*byteorder</code> is zero, and the first two bytes of the input data are a byte order mark (BOM), the decoder switches to this byte order and the BOM is not copied into the resulting Unicode string. If <code>*byteorder</code> is <code>-1</code> or <code>1</code>, any byte order mark is copied to the output (where it will result in either a <code>\ufeff</code> or a <code>\ufffe</code> character).</p> <p>After completion, <code>*byteorder</code> is set to the current byte order at the end of input data.</p> <p>If <em>byteorder</em> is <code>NULL</code>, the codec starts in native order mode.</p> <p>Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeUTF16Stateful">
<code>PyObject *PyUnicode_DecodeUTF16Stateful(const char *str, Py_ssize_t size, const char *errors, int *byteorder, Py_ssize_t *consumed)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>If <em>consumed</em> is <code>NULL</code>, behave like <a class="reference internal" href="#c.PyUnicode_DecodeUTF16" title="PyUnicode_DecodeUTF16"><code>PyUnicode_DecodeUTF16()</code></a>. If <em>consumed</em> is not <code>NULL</code>, <a class="reference internal" href="#c.PyUnicode_DecodeUTF16Stateful" title="PyUnicode_DecodeUTF16Stateful"><code>PyUnicode_DecodeUTF16Stateful()</code></a> will not treat trailing incomplete UTF-16 byte sequences (such as an odd number of bytes or a split surrogate pair) as an error. Those bytes will not be decoded and the number of bytes that have been decoded will be stored in <em>consumed</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsUTF16String">
<code>PyObject *PyUnicode_AsUTF16String(PyObject *unicode)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a Python byte string using the UTF-16 encoding in native byte order. The string always starts with a BOM mark. Error handling is “strict”. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> </section> <section id="utf-7-codecs"> <h3>UTF-7 Codecs</h3> <p>These are the UTF-7 codec APIs:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeUTF7">
<code>PyObject *PyUnicode_DecodeUTF7(const char *str, Py_ssize_t size, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the UTF-7 encoded string <em>str</em>. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeUTF7Stateful">
<code>PyObject *PyUnicode_DecodeUTF7Stateful(const char *str, Py_ssize_t size, const char *errors, Py_ssize_t *consumed)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>If <em>consumed</em> is <code>NULL</code>, behave like <a class="reference internal" href="#c.PyUnicode_DecodeUTF7" title="PyUnicode_DecodeUTF7"><code>PyUnicode_DecodeUTF7()</code></a>. If <em>consumed</em> is not <code>NULL</code>, trailing incomplete UTF-7 base-64 sections will not be treated as an error. Those bytes will not be decoded and the number of bytes that have been decoded will be stored in <em>consumed</em>.</p> </dd>
</dl> </section> <section id="unicode-escape-codecs"> <h3>Unicode-Escape Codecs</h3> <p>These are the “Unicode Escape” codec APIs:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeUnicodeEscape">
<code>PyObject *PyUnicode_DecodeUnicodeEscape(const char *str, Py_ssize_t size, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the Unicode-Escape encoded string <em>str</em>. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsUnicodeEscapeString">
<code>PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Encode a Unicode object using Unicode-Escape and return the result as a bytes object. Error handling is “strict”. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> </section> <section id="raw-unicode-escape-codecs"> <h3>Raw-Unicode-Escape Codecs</h3> <p>These are the “Raw Unicode Escape” codec APIs:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeRawUnicodeEscape">
<code>PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *str, Py_ssize_t size, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the Raw-Unicode-Escape encoded string <em>str</em>. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsRawUnicodeEscapeString">
<code>PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Encode a Unicode object using Raw-Unicode-Escape and return the result as a bytes object. Error handling is “strict”. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> </section> <section id="latin-1-codecs"> <h3>Latin-1 Codecs</h3> <p>These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 Unicode ordinals and only these are accepted by the codecs during encoding.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeLatin1">
<code>PyObject *PyUnicode_DecodeLatin1(const char *str, Py_ssize_t size, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the Latin-1 encoded string <em>str</em>. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsLatin1String">
<code>PyObject *PyUnicode_AsLatin1String(PyObject *unicode)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Encode a Unicode object using Latin-1 and return the result as Python bytes object. Error handling is “strict”. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> </section> <section id="ascii-codecs"> <h3>ASCII Codecs</h3> <p>These are the ASCII codec APIs. Only 7-bit ASCII data is accepted. All other codes generate errors.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeASCII">
<code>PyObject *PyUnicode_DecodeASCII(const char *str, Py_ssize_t size, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the ASCII encoded string <em>str</em>. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsASCIIString">
<code>PyObject *PyUnicode_AsASCIIString(PyObject *unicode)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Encode a Unicode object using ASCII and return the result as Python bytes object. Error handling is “strict”. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> </section> <section id="character-map-codecs"> <h3>Character Map Codecs</h3> <p>This codec is special in that it can be used to implement many different codecs (and this is in fact what was done to obtain most of the standard codecs included in the <code>encodings</code> package). The codec uses mappings to encode and decode characters. The mapping objects provided must support the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> mapping interface; dictionaries and sequences work well.</p> <p>These are the mapping codec APIs:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeCharmap">
<code>PyObject *PyUnicode_DecodeCharmap(const char *str, Py_ssize_t length, PyObject *mapping, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the encoded string <em>str</em> using the given <em>mapping</em> object. Return <code>NULL</code> if an exception was raised by the codec.</p> <p>If <em>mapping</em> is <code>NULL</code>, Latin-1 decoding will be applied. Else <em>mapping</em> must map bytes ordinals (integers in the range from 0 to 255) to Unicode strings, integers (which are then interpreted as Unicode ordinals) or <code>None</code>. Unmapped data bytes – ones which cause a <a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code>LookupError</code></a>, as well as ones which get mapped to <code>None</code>, <code>0xFFFE</code> or <code>'\ufffe'</code>, are treated as undefined mappings and cause an error.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsCharmapString">
<code>PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Encode a Unicode object using the given <em>mapping</em> object and return the result as a bytes object. Error handling is “strict”. Return <code>NULL</code> if an exception was raised by the codec.</p> <p>The <em>mapping</em> object must map Unicode ordinal integers to bytes objects, integers in the range from 0 to 255 or <code>None</code>. Unmapped character ordinals (ones which cause a <a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code>LookupError</code></a>) as well as mapped to <code>None</code> are treated as “undefined mapping” and cause an error.</p> </dd>
</dl> <p>The following codec API is special in that maps Unicode to Unicode.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Translate">
<code>PyObject *PyUnicode_Translate(PyObject *unicode, PyObject *table, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Translate a string by applying a character mapping table to it and return the resulting Unicode object. Return <code>NULL</code> if an exception was raised by the codec.</p> <p>The mapping table must map Unicode ordinal integers to Unicode ordinal integers or <code>None</code> (causing deletion of the character).</p> <p>Mapping tables need only provide the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> interface; dictionaries and sequences work well. Unmapped character ordinals (ones which cause a <a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code>LookupError</code></a>) are left untouched and are copied as-is.</p> <p><em>errors</em> has the usual meaning for codecs. It may be <code>NULL</code> which indicates to use the default error handling.</p> </dd>
</dl> </section> <section id="mbcs-codecs-for-windows"> <h3>MBCS codecs for Windows</h3> <p>These are the MBCS codec APIs. They are currently only available on Windows and use the Win32 MBCS converters to implement the conversions. Note that MBCS (or DBCS) is a class of encodings, not just one. The target encoding is defined by the user settings on the machine running the codec.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeMBCS">
<code>PyObject *PyUnicode_DecodeMBCS(const char *str, Py_ssize_t size, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> on Windows since version 3.7.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the MBCS encoded string <em>str</em>. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_DecodeMBCSStateful">
<code>PyObject *PyUnicode_DecodeMBCSStateful(const char *str, Py_ssize_t size, const char *errors, Py_ssize_t *consumed)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> on Windows since version 3.7.</em><p>If <em>consumed</em> is <code>NULL</code>, behave like <a class="reference internal" href="#c.PyUnicode_DecodeMBCS" title="PyUnicode_DecodeMBCS"><code>PyUnicode_DecodeMBCS()</code></a>. If <em>consumed</em> is not <code>NULL</code>, <a class="reference internal" href="#c.PyUnicode_DecodeMBCSStateful" title="PyUnicode_DecodeMBCSStateful"><code>PyUnicode_DecodeMBCSStateful()</code></a> will not decode trailing lead byte and the number of bytes that have been decoded will be stored in <em>consumed</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_AsMBCSString">
<code>PyObject *PyUnicode_AsMBCSString(PyObject *unicode)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> on Windows since version 3.7.</em><p>Encode a Unicode object using MBCS and return the result as Python bytes object. Error handling is “strict”. Return <code>NULL</code> if an exception was raised by the codec.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_EncodeCodePage">
<code>PyObject *PyUnicode_EncodeCodePage(int code_page, PyObject *unicode, const char *errors)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> on Windows since version 3.7.</em><p>Encode the Unicode object using the specified code page and return a Python bytes object. Return <code>NULL</code> if an exception was raised by the codec. Use <code>CP_ACP</code> code page to get the MBCS encoder.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> </section> <section id="methods-slots"> <h3>Methods &amp; Slots</h3> </section> </section> <section id="methods-and-slot-functions"> <span id="unicodemethodsandslots"></span><h2>Methods and Slot Functions</h2> <p>The following APIs are capable of handling Unicode objects and strings on input (we refer to them as strings in the descriptions) and return Unicode objects or integers as appropriate.</p> <p>They all return <code>NULL</code> or <code>-1</code> if an exception occurs.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Concat">
<code>PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Concat two strings giving a new Unicode string.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Split">
<code>PyObject *PyUnicode_Split(PyObject *unicode, PyObject *sep, Py_ssize_t maxsplit)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Split a string giving a list of Unicode strings. If <em>sep</em> is <code>NULL</code>, splitting will be done at all whitespace substrings. Otherwise, splits occur at the given separator. At most <em>maxsplit</em> splits will be done. If negative, no limit is set. Separators are not included in the resulting list.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Splitlines">
<code>PyObject *PyUnicode_Splitlines(PyObject *unicode, int keepends)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Split a Unicode string at line breaks, returning a list of Unicode strings. CRLF is considered to be one line break. If <em>keepends</em> is <code>0</code>, the Line break characters are not included in the resulting strings.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Join">
<code>PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Join a sequence of strings using the given <em>separator</em> and return the resulting Unicode string.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Tailmatch">
<code>Py_ssize_t PyUnicode_Tailmatch(PyObject *unicode, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return <code>1</code> if <em>substr</em> matches <code>unicode[start:end]</code> at the given tail end (<em>direction</em> == <code>-1</code> means to do a prefix match, <em>direction</em> == <code>1</code> a suffix match), <code>0</code> otherwise. Return <code>-1</code> if an error occurred.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Find">
<code>Py_ssize_t PyUnicode_Find(PyObject *unicode, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the first position of <em>substr</em> in <code>unicode[start:end]</code> using the given <em>direction</em> (<em>direction</em> == <code>1</code> means to do a forward search, <em>direction</em> == <code>-1</code> a backward search). The return value is the index of the first match; a value of <code>-1</code> indicates that no match was found, and <code>-2</code> indicates that an error occurred and an exception has been set.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_FindChar">
<code>Py_ssize_t PyUnicode_FindChar(PyObject *unicode, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p>Return the first position of the character <em>ch</em> in <code>unicode[start:end]</code> using the given <em>direction</em> (<em>direction</em> == <code>1</code> means to do a forward search, <em>direction</em> == <code>-1</code> a backward search). The return value is the index of the first match; a value of <code>-1</code> indicates that no match was found, and <code>-2</code> indicates that an error occurred and an exception has been set.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span><em>start</em> and <em>end</em> are now adjusted to behave like <code>unicode[start:end]</code>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Count">
<code>Py_ssize_t PyUnicode_Count(PyObject *unicode, PyObject *substr, Py_ssize_t start, Py_ssize_t end)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the number of non-overlapping occurrences of <em>substr</em> in <code>unicode[start:end]</code>. Return <code>-1</code> if an error occurred.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Replace">
<code>PyObject *PyUnicode_Replace(PyObject *unicode, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Replace at most <em>maxcount</em> occurrences of <em>substr</em> in <em>unicode</em> with <em>replstr</em> and return the resulting Unicode object. <em>maxcount</em> == <code>-1</code> means replace all occurrences.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Compare">
<code>int PyUnicode_Compare(PyObject *left, PyObject *right)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Compare two strings and return <code>-1</code>, <code>0</code>, <code>1</code> for less than, equal, and greater than, respectively.</p> <p>This function returns <code>-1</code> upon failure, so one should call <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code>PyErr_Occurred()</code></a> to check for errors.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_CompareWithASCIIString">
<code>int PyUnicode_CompareWithASCIIString(PyObject *unicode, const char *string)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Compare a Unicode object, <em>unicode</em>, with <em>string</em> and return <code>-1</code>, <code>0</code>, <code>1</code> for less than, equal, and greater than, respectively. It is best to pass only ASCII-encoded strings, but the function interprets the input string as ISO-8859-1 if it contains non-ASCII characters.</p> <p>This function does not raise exceptions.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_RichCompare">
<code>PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Rich compare two Unicode strings and return one of the following:</p> <ul class="simple"> <li>
<code>NULL</code> in case an exception was raised</li> <li>
<a class="reference internal" href="bool.html#c.Py_True" title="Py_True"><code>Py_True</code></a> or <a class="reference internal" href="bool.html#c.Py_False" title="Py_False"><code>Py_False</code></a> for successful comparisons</li> <li>
<a class="reference internal" href="object.html#c.Py_NotImplemented" title="Py_NotImplemented"><code>Py_NotImplemented</code></a> in case the type combination is unknown</li> </ul> <p>Possible values for <em>op</em> are <a class="reference internal" href="typeobj.html#c.Py_GT" title="Py_GT"><code>Py_GT</code></a>, <a class="reference internal" href="typeobj.html#c.Py_GE" title="Py_GE"><code>Py_GE</code></a>, <a class="reference internal" href="typeobj.html#c.Py_EQ" title="Py_EQ"><code>Py_EQ</code></a>, <a class="reference internal" href="typeobj.html#c.Py_NE" title="Py_NE"><code>Py_NE</code></a>, <a class="reference internal" href="typeobj.html#c.Py_LT" title="Py_LT"><code>Py_LT</code></a>, and <a class="reference internal" href="typeobj.html#c.Py_LE" title="Py_LE"><code>Py_LE</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Format">
<code>PyObject *PyUnicode_Format(PyObject *format, PyObject *args)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new string object from <em>format</em> and <em>args</em>; this is analogous to <code>format % args</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_Contains">
<code>int PyUnicode_Contains(PyObject *unicode, PyObject *substr)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Check whether <em>substr</em> is contained in <em>unicode</em> and return true or false accordingly.</p> <p><em>substr</em> has to coerce to a one element Unicode string. <code>-1</code> is returned if there was an error.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_InternInPlace">
<code>void PyUnicode_InternInPlace(PyObject **p_unicode)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Intern the argument <span class="c-expr sig sig-inline c"><span class="o">*</span><a class="reference internal" href="#c.PyUnicode_InternInPlace" title="p_unicode"><span class="n">p_unicode</span></a></span> in place. The argument must be the address of a pointer variable pointing to a Python Unicode string object. If there is an existing interned string that is the same as <span class="c-expr sig sig-inline c"><span class="o">*</span><a class="reference internal" href="#c.PyUnicode_InternInPlace" title="p_unicode"><span class="n">p_unicode</span></a></span>, it sets <span class="c-expr sig sig-inline c"><span class="o">*</span><a class="reference internal" href="#c.PyUnicode_InternInPlace" title="p_unicode"><span class="n">p_unicode</span></a></span> to it (releasing the reference to the old string object and creating a new <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to the interned string object), otherwise it leaves <span class="c-expr sig sig-inline c"><span class="o">*</span><a class="reference internal" href="#c.PyUnicode_InternInPlace" title="p_unicode"><span class="n">p_unicode</span></a></span> alone and interns it (creating a new <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a>). (Clarification: even though there is a lot of talk about references, think of this function as reference-neutral; you own the object after the call if and only if you owned it before the call.)</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnicode_InternFromString">
<code>PyObject *PyUnicode_InternFromString(const char *str)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>A combination of <a class="reference internal" href="#c.PyUnicode_FromString" title="PyUnicode_FromString"><code>PyUnicode_FromString()</code></a> and <a class="reference internal" href="#c.PyUnicode_InternInPlace" title="PyUnicode_InternInPlace"><code>PyUnicode_InternInPlace()</code></a>, returning either a new Unicode string object that has been interned, or a new (“owned”) reference to an earlier interned string object with the same value.</p> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/c-api/unicode.html" class="_attribution-link">https://docs.python.org/3.12/c-api/unicode.html</a>
  </p>
</div>
