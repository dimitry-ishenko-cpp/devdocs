 <span id="typeobjects"></span><h1>Type Objects</h1> <dl class="c type" id="index-0"> <dt class="sig sig-object c" id="c.PyTypeObject">
<code>type PyTypeObject</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Limited API</span></a> (as an opaque struct).</em><p>The C structure of the objects used to describe built-in types.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyType_Type">
<code>PyTypeObject PyType_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This is the type object for type objects; it is the same object as <a class="reference internal" href="../library/functions.html#type" title="type"><code>type</code></a> in the Python layer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_Check">
<code>int PyType_Check(PyObject *o)</code> </dt> <dd>
<p>Return non-zero if the object <em>o</em> is a type object, including instances of types derived from the standard type object. Return 0 in all other cases. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_CheckExact">
<code>int PyType_CheckExact(PyObject *o)</code> </dt> <dd>
<p>Return non-zero if the object <em>o</em> is a type object, but not a subtype of the standard type object. Return 0 in all other cases. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_ClearCache">
<code>unsigned int PyType_ClearCache()</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Clear the internal lookup cache. Return the current version tag.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GetFlags">
<code>unsigned long PyType_GetFlags(PyTypeObject *type)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> member of <em>type</em>. This function is primarily meant for use with <code>Py_LIMITED_API</code>; the individual flag bits are guaranteed to be stable across Python releases, but access to <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> itself is not part of the <a class="reference internal" href="stable.html#limited-c-api"><span class="std std-ref">limited API</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The return type is now <code>unsigned long</code> rather than <code>long</code>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GetDict">
<code>PyObject *PyType_GetDict(PyTypeObject *type)</code> </dt> <dd>
<p>Return the type object’s internal namespace, which is otherwise only exposed via a read-only proxy (<a class="reference internal" href="../reference/datamodel.html#type.__dict__" title="type.__dict__"><code>cls.__dict__</code></a>). This is a replacement for accessing <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code>tp_dict</code></a> directly. The returned dictionary must be treated as read-only.</p> <p>This function is meant for specific embedding and language-binding cases, where direct access to the dict is necessary and indirect access (e.g. via the proxy or <a class="reference internal" href="object.html#c.PyObject_GetAttr" title="PyObject_GetAttr"><code>PyObject_GetAttr()</code></a>) isn’t adequate.</p> <p>Extension modules should continue to use <code>tp_dict</code>, directly or indirectly, when setting up their own types.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_Modified">
<code>void PyType_Modified(PyTypeObject *type)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Invalidate the internal lookup cache for the type and all of its subtypes. This function must be called after any manual modification of the attributes or base classes of the type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_AddWatcher">
<code>int PyType_AddWatcher(PyType_WatchCallback callback)</code> </dt> <dd>
<p>Register <em>callback</em> as a type watcher. Return a non-negative integer ID which must be passed to future calls to <a class="reference internal" href="#c.PyType_Watch" title="PyType_Watch"><code>PyType_Watch()</code></a>. In case of error (e.g. no more watcher IDs available), return <code>-1</code> and set an exception.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_ClearWatcher">
<code>int PyType_ClearWatcher(int watcher_id)</code> </dt> <dd>
<p>Clear watcher identified by <em>watcher_id</em> (previously returned from <a class="reference internal" href="#c.PyType_AddWatcher" title="PyType_AddWatcher"><code>PyType_AddWatcher()</code></a>). Return <code>0</code> on success, <code>-1</code> on error (e.g. if <em>watcher_id</em> was never registered.)</p> <p>An extension should never call <code>PyType_ClearWatcher</code> with a <em>watcher_id</em> that was not returned to it by a previous call to <a class="reference internal" href="#c.PyType_AddWatcher" title="PyType_AddWatcher"><code>PyType_AddWatcher()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_Watch">
<code>int PyType_Watch(int watcher_id, PyObject *type)</code> </dt> <dd>
<p>Mark <em>type</em> as watched. The callback granted <em>watcher_id</em> by <a class="reference internal" href="#c.PyType_AddWatcher" title="PyType_AddWatcher"><code>PyType_AddWatcher()</code></a> will be called whenever <a class="reference internal" href="#c.PyType_Modified" title="PyType_Modified"><code>PyType_Modified()</code></a> reports a change to <em>type</em>. (The callback may be called only once for a series of consecutive modifications to <em>type</em>, if <code>_PyType_Lookup()</code> is not called on <em>type</em> between the modifications; this is an implementation detail and subject to change.)</p> <p>An extension should never call <code>PyType_Watch</code> with a <em>watcher_id</em> that was not returned to it by a previous call to <a class="reference internal" href="#c.PyType_AddWatcher" title="PyType_AddWatcher"><code>PyType_AddWatcher()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyType_WatchCallback">
<code>typedef int (*PyType_WatchCallback)(PyObject *type)</code> </dt> <dd>
<p>Type of a type-watcher callback function.</p> <p>The callback must not modify <em>type</em> or cause <a class="reference internal" href="#c.PyType_Modified" title="PyType_Modified"><code>PyType_Modified()</code></a> to be called on <em>type</em> or any type in its MRO; violating this rule could cause infinite recursion.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_HasFeature">
<code>int PyType_HasFeature(PyTypeObject *o, int feature)</code> </dt> <dd>
<p>Return non-zero if the type object <em>o</em> sets the feature <em>feature</em>. Type features are denoted by single bit flags.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_IS_GC">
<code>int PyType_IS_GC(PyTypeObject *o)</code> </dt> <dd>
<p>Return true if the type object includes support for the cycle detector; this tests the type flag <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_IsSubtype">
<code>int PyType_IsSubtype(PyTypeObject *a, PyTypeObject *b)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return true if <em>a</em> is a subtype of <em>b</em>.</p> <p>This function only checks for actual subtypes, which means that <a class="reference internal" href="../reference/datamodel.html#type.__subclasscheck__" title="type.__subclasscheck__"><code>__subclasscheck__()</code></a> is not called on <em>b</em>. Call <a class="reference internal" href="object.html#c.PyObject_IsSubclass" title="PyObject_IsSubclass"><code>PyObject_IsSubclass()</code></a> to do the same check that <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code>issubclass()</code></a> would do.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GenericAlloc">
<code>PyObject *PyType_GenericAlloc(PyTypeObject *type, Py_ssize_t nitems)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Generic handler for the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code>tp_alloc</code></a> slot of a type object. Use Python’s default memory allocation mechanism to allocate a new instance and initialize all its contents to <code>NULL</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GenericNew">
<code>PyObject *PyType_GenericNew(PyTypeObject *type, PyObject *args, PyObject *kwds)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Generic handler for the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> slot of a type object. Create a new instance using the type’s <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code>tp_alloc</code></a> slot.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_Ready">
<code>int PyType_Ready(PyTypeObject *type)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Finalize a type object. This should be called on all type objects to finish their initialization. This function is responsible for adding inherited slots from a type’s base class. Return <code>0</code> on success, or return <code>-1</code> and sets an exception on error.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If some of the base classes implements the GC protocol and the provided type does not include the <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> in its flags, then the GC protocol will be automatically implemented from its parents. On the contrary, if the type being created does include <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> in its flags then it <strong>must</strong> implement the GC protocol itself by at least implementing the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handle.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GetName">
<code>PyObject *PyType_GetName(PyTypeObject *type)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Return the type’s name. Equivalent to getting the type’s <a class="reference internal" href="../reference/datamodel.html#type.__name__" title="type.__name__"><code>__name__</code></a> attribute.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.11.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GetQualName">
<code>PyObject *PyType_GetQualName(PyTypeObject *type)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.11.</em><p>Return the type’s qualified name. Equivalent to getting the type’s <a class="reference internal" href="../reference/datamodel.html#type.__qualname__" title="type.__qualname__"><code>__qualname__</code></a> attribute.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.11.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GetFullyQualifiedName">
<code>PyObject *PyType_GetFullyQualifiedName(PyTypeObject *type)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Return the type’s fully qualified name. Equivalent to <code>f"{type.__module__}.{type.__qualname__}"</code>, or <a class="reference internal" href="../reference/datamodel.html#type.__qualname__" title="type.__qualname__"><code>type.__qualname__</code></a> if <a class="reference internal" href="../reference/datamodel.html#type.__module__" title="type.__module__"><code>type.__module__</code></a> is not a string or is equal to <code>"builtins"</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GetModuleName">
<code>PyObject *PyType_GetModuleName(PyTypeObject *type)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Return the type’s module name. Equivalent to getting the <a class="reference internal" href="../reference/datamodel.html#type.__module__" title="type.__module__"><code>type.__module__</code></a> attribute.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GetSlot">
<code>void *PyType_GetSlot(PyTypeObject *type, int slot)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.4.</em><p>Return the function pointer stored in the given slot. If the result is <code>NULL</code>, this indicates that either the slot is <code>NULL</code>, or that the function was called with invalid parameters. Callers will typically cast the result pointer into the appropriate function type.</p> <p>See <a class="reference internal" href="#c.PyType_Slot.slot" title="PyType_Slot.slot"><code>PyType_Slot.slot</code></a> for possible values of the <em>slot</em> argument.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span><a class="reference internal" href="#c.PyType_GetSlot" title="PyType_GetSlot"><code>PyType_GetSlot()</code></a> can now accept all types. Previously, it was limited to <a class="reference internal" href="typeobj.html#heap-types"><span class="std std-ref">heap types</span></a>.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GetModule">
<code>PyObject *PyType_GetModule(PyTypeObject *type)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Return the module object associated with the given type when the type was created using <a class="reference internal" href="#c.PyType_FromModuleAndSpec" title="PyType_FromModuleAndSpec"><code>PyType_FromModuleAndSpec()</code></a>.</p> <p>If no module is associated with the given type, sets <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> and returns <code>NULL</code>.</p> <p>This function is usually used to get the module in which a method is defined. Note that in such a method, <code>PyType_GetModule(Py_TYPE(self))</code> may not return the intended result. <code>Py_TYPE(self)</code> may be a <em>subclass</em> of the intended class, and subclasses are not necessarily defined in the same module as their superclass. See <a class="reference internal" href="structures.html#c.PyCMethod" title="PyCMethod"><code>PyCMethod</code></a> to get the class that defines the method. See <a class="reference internal" href="#c.PyType_GetModuleByDef" title="PyType_GetModuleByDef"><code>PyType_GetModuleByDef()</code></a> for cases when <code>PyCMethod</code> cannot be used.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GetModuleState">
<code>void *PyType_GetModuleState(PyTypeObject *type)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Return the state of the module object associated with the given type. This is a shortcut for calling <a class="reference internal" href="module.html#c.PyModule_GetState" title="PyModule_GetState"><code>PyModule_GetState()</code></a> on the result of <a class="reference internal" href="#c.PyType_GetModule" title="PyType_GetModule"><code>PyType_GetModule()</code></a>.</p> <p>If no module is associated with the given type, sets <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> and returns <code>NULL</code>.</p> <p>If the <em>type</em> has an associated module but its state is <code>NULL</code>, returns <code>NULL</code> without setting an exception.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_GetModuleByDef">
<code>PyObject *PyType_GetModuleByDef(PyTypeObject *type, struct PyModuleDef *def)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p>Find the first superclass whose module was created from the given <a class="reference internal" href="module.html#c.PyModuleDef" title="PyModuleDef"><code>PyModuleDef</code></a> <em>def</em>, and return that module.</p> <p>If no module is found, raises a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> and returns <code>NULL</code>.</p> <p>This function is intended to be used together with <a class="reference internal" href="module.html#c.PyModule_GetState" title="PyModule_GetState"><code>PyModule_GetState()</code></a> to get module state from slot methods (such as <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a> or <a class="reference internal" href="typeobj.html#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code>nb_add</code></a>) and other places where a method’s defining class cannot be passed using the <a class="reference internal" href="structures.html#c.PyCMethod" title="PyCMethod"><code>PyCMethod</code></a> calling convention.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.11.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnstable_Type_AssignVersionTag">
<code>int PyUnstable_Type_AssignVersionTag(PyTypeObject *type)</code> </dt> <dd>
<div class="unstable-c-api warning admonition"> <em>This is <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable API</span></a>. It may change without warning in minor releases.</em>
</div> <p>Attempt to assign a version tag to the given type.</p> <p>Returns 1 if the type already had a valid version tag or a new one was assigned, or 0 if a new tag could not be assigned.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <section id="creating-heap-allocated-types"> <h2>Creating Heap-Allocated Types</h2> <p>The following functions and structs are used to create <a class="reference internal" href="typeobj.html#heap-types"><span class="std std-ref">heap types</span></a>.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_FromMetaclass">
<code>PyObject *PyType_FromMetaclass(PyTypeObject *metaclass, PyObject *module, PyType_Spec *spec, PyObject *bases)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.12.</em><p>Create and return a <a class="reference internal" href="typeobj.html#heap-types"><span class="std std-ref">heap type</span></a> from the <em>spec</em> (see <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HEAPTYPE" title="Py_TPFLAGS_HEAPTYPE"><code>Py_TPFLAGS_HEAPTYPE</code></a>).</p> <p>The metaclass <em>metaclass</em> is used to construct the resulting type object. When <em>metaclass</em> is <code>NULL</code>, the metaclass is derived from <em>bases</em> (or <em>Py_tp_base[s]</em> slots if <em>bases</em> is <code>NULL</code>, see below).</p> <p>Metaclasses that override <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> are not supported, except if <code>tp_new</code> is <code>NULL</code>. (For backwards compatibility, other <code>PyType_From*</code> functions allow such metaclasses. They ignore <code>tp_new</code>, which may result in incomplete initialization. This is deprecated and in Python 3.14+ such metaclasses will not be supported.)</p> <p>The <em>bases</em> argument can be used to specify base classes; it can either be only one class or a tuple of classes. If <em>bases</em> is <code>NULL</code>, the <em>Py_tp_bases</em> slot is used instead. If that also is <code>NULL</code>, the <em>Py_tp_base</em> slot is used instead. If that also is <code>NULL</code>, the new type derives from <a class="reference internal" href="../library/functions.html#object" title="object"><code>object</code></a>.</p> <p>The <em>module</em> argument can be used to record the module in which the new class is defined. It must be a module object or <code>NULL</code>. If not <code>NULL</code>, the module is associated with the new type and can later be retrieved with <a class="reference internal" href="#c.PyType_GetModule" title="PyType_GetModule"><code>PyType_GetModule()</code></a>. The associated module is not inherited by subclasses; it must be specified for each class individually.</p> <p>This function calls <a class="reference internal" href="#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> on the new type.</p> <p>Note that this function does <em>not</em> fully match the behavior of calling <a class="reference internal" href="../library/functions.html#type" title="type"><code>type()</code></a> or using the <a class="reference internal" href="../reference/compound_stmts.html#class"><code>class</code></a> statement. With user-provided base types or metaclasses, prefer <a class="reference internal" href="call.html#capi-call"><span class="std std-ref">calling</span></a> <a class="reference internal" href="../library/functions.html#type" title="type"><code>type</code></a> (or the metaclass) over <code>PyType_From*</code> functions. Specifically:</p> <ul class="simple"> <li>
<a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> is not called on the new class (and it must be set to <code>type.__new__</code>).</li> <li>
<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> is not called on the new class.</li> <li>
<a class="reference internal" href="../reference/datamodel.html#object.__init_subclass__" title="object.__init_subclass__"><code>__init_subclass__()</code></a> is not called on any bases.</li> <li>
<a class="reference internal" href="../reference/datamodel.html#object.__set_name__" title="object.__set_name__"><code>__set_name__()</code></a> is not called on new descriptors.</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_FromModuleAndSpec">
<code>PyObject *PyType_FromModuleAndSpec(PyObject *module, PyType_Spec *spec, PyObject *bases)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Equivalent to <code>PyType_FromMetaclass(NULL, module, spec, bases)</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The function now accepts a single class as the <em>bases</em> argument and <code>NULL</code> as the <code>tp_doc</code> slot.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The function now finds and uses a metaclass corresponding to the provided base classes. Previously, only <a class="reference internal" href="../library/functions.html#type" title="type"><code>type</code></a> instances were returned.</p> <p>The <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> of the metaclass is <em>ignored</em>. which may result in incomplete initialization. Creating classes whose metaclass overrides <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> is deprecated and in Python 3.14+ it will be no longer allowed.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_FromSpecWithBases">
<code>PyObject *PyType_FromSpecWithBases(PyType_Spec *spec, PyObject *bases)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.3.</em><p>Equivalent to <code>PyType_FromMetaclass(NULL, NULL, spec, bases)</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The function now finds and uses a metaclass corresponding to the provided base classes. Previously, only <a class="reference internal" href="../library/functions.html#type" title="type"><code>type</code></a> instances were returned.</p> <p>The <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> of the metaclass is <em>ignored</em>. which may result in incomplete initialization. Creating classes whose metaclass overrides <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> is deprecated and in Python 3.14+ it will be no longer allowed.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyType_FromSpec">
<code>PyObject *PyType_FromSpec(PyType_Spec *spec)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Equivalent to <code>PyType_FromMetaclass(NULL, NULL, spec, NULL)</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The function now finds and uses a metaclass corresponding to the base classes provided in <em>Py_tp_base[s]</em> slots. Previously, only <a class="reference internal" href="../library/functions.html#type" title="type"><code>type</code></a> instances were returned.</p> <p>The <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> of the metaclass is <em>ignored</em>. which may result in incomplete initialization. Creating classes whose metaclass overrides <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> is deprecated and in Python 3.14+ it will be no longer allowed.</p> </div> </dd>
</dl>  <span id="c.PyType_Spec.PyType_Spec.name"></span> <span id="c.PyType_Spec.PyType_Spec.basicsize"></span> <span id="c.PyType_Spec.PyType_Spec.itemsize"></span> <span id="c.PyType_Spec.PyType_Spec.flags"></span> <span id="c.PyType_Spec.PyType_Spec.slots"></span><dl class="c type"> <dt class="sig sig-object c" id="c.PyType_Spec">
<code>type PyType_Spec</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> (including all members).</em><p>Structure defining a type’s behavior.</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyType_Spec.name">
<code>const char *name</code> </dt> <dd>
<p>Name of the type, used to set <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code>PyTypeObject.tp_name</code></a>.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyType_Spec.basicsize">
<code>int basicsize</code> </dt> <dd>
<p>If positive, specifies the size of the instance in bytes. It is used to set <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>PyTypeObject.tp_basicsize</code></a>.</p> <p>If zero, specifies that <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a> should be inherited.</p> <p>If negative, the absolute value specifies how much space instances of the class need <em>in addition</em> to the superclass. Use <a class="reference internal" href="object.html#c.PyObject_GetTypeData" title="PyObject_GetTypeData"><code>PyObject_GetTypeData()</code></a> to get a pointer to subclass-specific memory reserved this way.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Previously, this field could not be negative.</p> </div> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyType_Spec.itemsize">
<code>int itemsize</code> </dt> <dd>
<p>Size of one element of a variable-size type, in bytes. Used to set <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>PyTypeObject.tp_itemsize</code></a>. See <code>tp_itemsize</code> documentation for caveats.</p> <p>If zero, <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a> is inherited. Extending arbitrary variable-sized classes is dangerous, since some types use a fixed offset for variable-sized memory, which can then overlap fixed-sized memory used by a subclass. To help prevent mistakes, inheriting <code>itemsize</code> is only possible in the following situations:</p> <ul class="simple"> <li>The base is not variable-sized (its <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a>).</li> <li>The requested <a class="reference internal" href="#c.PyType_Spec.basicsize" title="PyType_Spec.basicsize"><code>PyType_Spec.basicsize</code></a> is positive, suggesting that the memory layout of the base class is known.</li> <li>The requested <a class="reference internal" href="#c.PyType_Spec.basicsize" title="PyType_Spec.basicsize"><code>PyType_Spec.basicsize</code></a> is zero, suggesting that the subclass does not access the instance’s memory directly.</li> <li>With the <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_ITEMS_AT_END" title="Py_TPFLAGS_ITEMS_AT_END"><code>Py_TPFLAGS_ITEMS_AT_END</code></a> flag.</li> </ul> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyType_Spec.flags">
<code>unsigned int flags</code> </dt> <dd>
<p>Type flags, used to set <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>PyTypeObject.tp_flags</code></a>.</p> <p>If the <code>Py_TPFLAGS_HEAPTYPE</code> flag is not set, <a class="reference internal" href="#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code>PyType_FromSpecWithBases()</code></a> sets it automatically.</p> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyType_Spec.slots">
<code>PyType_Slot *slots</code> </dt> <dd>
<p>Array of <a class="reference internal" href="#c.PyType_Slot" title="PyType_Slot"><code>PyType_Slot</code></a> structures. Terminated by the special slot value <code>{0, NULL}</code>.</p> <p>Each slot ID should be specified at most once.</p> </dd>
</dl> </dd>
</dl>  <span id="c.PyType_Slot.PyType_Slot.slot"></span> <span id="c.PyType_Slot.PyType_Slot.pfunc"></span><dl class="c type"> <dt class="sig sig-object c" id="c.PyType_Slot">
<code>type PyType_Slot</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> (including all members).</em><p>Structure defining optional functionality of a type, containing a slot ID and a value pointer.</p> <dl class="c member"> <dt class="sig sig-object c" id="c.PyType_Slot.slot">
<code>int slot</code> </dt> <dd>
<p>A slot ID.</p> <p>Slot IDs are named like the field names of the structures <a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a>, <a class="reference internal" href="typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code>PyNumberMethods</code></a>, <a class="reference internal" href="typeobj.html#c.PySequenceMethods" title="PySequenceMethods"><code>PySequenceMethods</code></a>, <a class="reference internal" href="typeobj.html#c.PyMappingMethods" title="PyMappingMethods"><code>PyMappingMethods</code></a> and <a class="reference internal" href="typeobj.html#c.PyAsyncMethods" title="PyAsyncMethods"><code>PyAsyncMethods</code></a> with an added <code>Py_</code> prefix. For example, use:</p> <ul class="simple"> <li>
<code>Py_tp_dealloc</code> to set <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>PyTypeObject.tp_dealloc</code></a>
</li> <li>
<code>Py_nb_add</code> to set <a class="reference internal" href="typeobj.html#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code>PyNumberMethods.nb_add</code></a>
</li> <li>
<code>Py_sq_length</code> to set <a class="reference internal" href="typeobj.html#c.PySequenceMethods.sq_length" title="PySequenceMethods.sq_length"><code>PySequenceMethods.sq_length</code></a>
</li> </ul> <p>The following “offset” fields cannot be set using <a class="reference internal" href="#c.PyType_Slot" title="PyType_Slot"><code>PyType_Slot</code></a>:</p> <ul class="simple"> <li>
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code>tp_weaklistoffset</code></a> (use <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code>Py_TPFLAGS_MANAGED_WEAKREF</code></a> instead if possible)</li> <li>
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code>tp_dictoffset</code></a> (use <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code>Py_TPFLAGS_MANAGED_DICT</code></a> instead if possible)</li> <li>
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code>tp_vectorcall_offset</code></a> (use <code>"__vectorcalloffset__"</code> in <a class="reference internal" href="structures.html#pymemberdef-offsets"><span class="std std-ref">PyMemberDef</span></a>)</li> </ul> <p>If it is not possible to switch to a <code>MANAGED</code> flag (for example, for vectorcall or to support Python older than 3.12), specify the offset in <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code>Py_tp_members</code></a>. See <a class="reference internal" href="structures.html#pymemberdef-offsets"><span class="std std-ref">PyMemberDef documentation</span></a> for details.</p> <p>The following fields cannot be set at all when creating a heap type:</p> <ul class="simple"> <li>
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_vectorcall" title="PyTypeObject.tp_vectorcall"><code>tp_vectorcall</code></a> (use <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> and/or <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a>)</li> <li>Internal fields: <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code>tp_dict</code></a>, <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_mro" title="PyTypeObject.tp_mro"><code>tp_mro</code></a>, <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_cache" title="PyTypeObject.tp_cache"><code>tp_cache</code></a>, <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_subclasses" title="PyTypeObject.tp_subclasses"><code>tp_subclasses</code></a>, and <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code>tp_weaklist</code></a>.</li> </ul> <p>Setting <code>Py_tp_bases</code> or <code>Py_tp_base</code> may be problematic on some platforms. To avoid issues, use the <em>bases</em> argument of <a class="reference internal" href="#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code>PyType_FromSpecWithBases()</code></a> instead.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>Slots in <a class="reference internal" href="typeobj.html#c.PyBufferProcs" title="PyBufferProcs"><code>PyBufferProcs</code></a> may be set in the unlimited API.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><a class="reference internal" href="typeobj.html#c.PyBufferProcs.bf_getbuffer" title="PyBufferProcs.bf_getbuffer"><code>bf_getbuffer</code></a> and <a class="reference internal" href="typeobj.html#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code>bf_releasebuffer</code></a> are now available under the <a class="reference internal" href="stable.html#limited-c-api"><span class="std std-ref">limited API</span></a>.</p> </div> </dd>
</dl> <dl class="c member"> <dt class="sig sig-object c" id="c.PyType_Slot.pfunc">
<code>void *pfunc</code> </dt> <dd>
<p>The desired value of the slot. In most cases, this is a pointer to a function.</p> <p>Slots other than <code>Py_tp_doc</code> may not be <code>NULL</code>.</p> </dd>
</dl> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/type.html" class="_attribution-link">https://docs.python.org/3.13/c-api/type.html</a>
  </p>
</div>
