 <span id="id1"></span><h1>Cell Objects</h1> <p>“Cell” objects are used to implement variables referenced by multiple scopes. For each such variable, a cell object is created to store the value; the local variables of each stack frame that references the value contains a reference to the cells from outer scopes which also use that variable. When the value is accessed, the value contained in the cell is used instead of the cell object itself. This de-referencing of the cell object requires support from the generated byte-code; these are not automatically de-referenced when accessed. Cell objects are not likely to be useful elsewhere.</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyCellObject">
<code>type PyCellObject</code> </dt> <dd>
<p>The C structure used for cell objects.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyCell_Type">
<code>PyTypeObject PyCell_Type</code> </dt> <dd>
<p>The type object corresponding to cell objects.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCell_Check">
<code>int PyCell_Check(PyObject *ob)</code> </dt> <dd>
<p>Return true if <em>ob</em> is a cell object; <em>ob</em> must not be <code>NULL</code>. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCell_New">
<code>PyObject *PyCell_New(PyObject *ob)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><p>Create and return a new cell object containing the value <em>ob</em>. The parameter may be <code>NULL</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCell_Get">
<code>PyObject *PyCell_Get(PyObject *cell)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><p>Return the contents of the cell <em>cell</em>, which can be <code>NULL</code>. If <em>cell</em> is not a cell object, returns <code>NULL</code> with an exception set.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCell_GET">
<code>PyObject *PyCell_GET(PyObject *cell)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><p>Return the contents of the cell <em>cell</em>, but without checking that <em>cell</em> is non-<code>NULL</code> and a cell object.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCell_Set">
<code>int PyCell_Set(PyObject *cell, PyObject *value)</code> </dt> <dd>
<p>Set the contents of the cell object <em>cell</em> to <em>value</em>. This releases the reference to any current content of the cell. <em>value</em> may be <code>NULL</code>. <em>cell</em> must be non-<code>NULL</code>.</p> <p>On success, return <code>0</code>. If <em>cell</em> is not a cell object, set an exception and return <code>-1</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCell_SET">
<code>void PyCell_SET(PyObject *cell, PyObject *value)</code> </dt> <dd>
<p>Sets the value of the cell object <em>cell</em> to <em>value</em>. No reference counts are adjusted, and no checks are made for safety; <em>cell</em> must be non-<code>NULL</code> and must be a cell object.</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/cell.html" class="_attribution-link">https://docs.python.org/3.13/c-api/cell.html</a>
  </p>
</div>
