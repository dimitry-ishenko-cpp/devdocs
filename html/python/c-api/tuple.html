 <span id="tupleobjects"></span><h1>Tuple Objects</h1> <dl class="c type" id="index-0"> <dt class="sig sig-object c" id="c.PyTupleObject">
<code>type PyTupleObject</code> </dt> <dd>
<p>This subtype of <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> represents a Python tuple object.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyTuple_Type">
<code>PyTypeObject PyTuple_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This instance of <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> represents the Python tuple type; it is the same object as <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> in the Python layer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_Check">
<code>int PyTuple_Check(PyObject *p)</code> </dt> <dd>
<p>Return true if <em>p</em> is a tuple object or an instance of a subtype of the tuple type. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_CheckExact">
<code>int PyTuple_CheckExact(PyObject *p)</code> </dt> <dd>
<p>Return true if <em>p</em> is a tuple object, but not an instance of a subtype of the tuple type. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_New">
<code>PyObject *PyTuple_New(Py_ssize_t len)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new tuple object of size <em>len</em>, or <code>NULL</code> with an exception set on failure.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_Pack">
<code>PyObject *PyTuple_Pack(Py_ssize_t n, ...)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new tuple object of size <em>n</em>, or <code>NULL</code> with an exception set on failure. The tuple values are initialized to the subsequent <em>n</em> C arguments pointing to Python objects. <code>PyTuple_Pack(2, a, b)</code> is equivalent to <code>Py_BuildValue("(OO)", a, b)</code>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_Size">
<code>Py_ssize_t PyTuple_Size(PyObject *p)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Take a pointer to a tuple object, and return the size of that tuple. On error, return <code>-1</code> and with an exception set.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_GET_SIZE">
<code>Py_ssize_t PyTuple_GET_SIZE(PyObject *p)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#c.PyTuple_Size" title="PyTuple_Size"><code>PyTuple_Size()</code></a>, but without error checking.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_GetItem">
<code>PyObject *PyTuple_GetItem(PyObject *p, Py_ssize_t pos)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the object at position <em>pos</em> in the tuple pointed to by <em>p</em>. If <em>pos</em> is negative or out of bounds, return <code>NULL</code> and set an <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a> exception.</p> <p>The returned reference is borrowed from the tuple <em>p</em> (that is: it is only valid as long as you hold a reference to <em>p</em>). To get a <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a>, use <a class="reference internal" href="refcounting.html#c.Py_NewRef" title="Py_NewRef"><code>Py_NewRef(PyTuple_GetItem(...))</code></a> or <a class="reference internal" href="sequence.html#c.PySequence_GetItem" title="PySequence_GetItem"><code>PySequence_GetItem()</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_GET_ITEM">
<code>PyObject *PyTuple_GET_ITEM(PyObject *p, Py_ssize_t pos)</code> </dt> <dd>
<em class="refcount return_borrowed_ref">Return value: Borrowed reference.</em><p>Like <a class="reference internal" href="#c.PyTuple_GetItem" title="PyTuple_GetItem"><code>PyTuple_GetItem()</code></a>, but does no checking of its arguments.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_GetSlice">
<code>PyObject *PyTuple_GetSlice(PyObject *p, Py_ssize_t low, Py_ssize_t high)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the slice of the tuple pointed to by <em>p</em> between <em>low</em> and <em>high</em>, or <code>NULL</code> with an exception set on failure.</p> <p>This is the equivalent of the Python expression <code>p[low:high]</code>. Indexing from the end of the tuple is not supported.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_SetItem">
<code>int PyTuple_SetItem(PyObject *p, Py_ssize_t pos, PyObject *o)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Insert a reference to object <em>o</em> at position <em>pos</em> of the tuple pointed to by <em>p</em>. Return <code>0</code> on success. If <em>pos</em> is out of bounds, return <code>-1</code> and set an <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a> exception.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function “steals” a reference to <em>o</em> and discards a reference to an item already in the tuple at the affected position.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyTuple_SET_ITEM">
<code>void PyTuple_SET_ITEM(PyObject *p, Py_ssize_t pos, PyObject *o)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#c.PyTuple_SetItem" title="PyTuple_SetItem"><code>PyTuple_SetItem()</code></a>, but does no error checking, and should <em>only</em> be used to fill in brand new tuples.</p> <p>Bounds checking is performed as an assertion if Python is built in <a class="reference internal" href="../using/configure.html#debug-build"><span class="std std-ref">debug mode</span></a> or <a class="reference internal" href="../using/configure.html#cmdoption-with-assertions"><code>with assertions</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function “steals” a reference to <em>o</em>, and, unlike <a class="reference internal" href="#c.PyTuple_SetItem" title="PyTuple_SetItem"><code>PyTuple_SetItem()</code></a>, does <em>not</em> discard a reference to any item that is being replaced; any reference in the tuple at position <em>pos</em> will be leaked.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c._PyTuple_Resize">
<code>int _PyTuple_Resize(PyObject **p, Py_ssize_t newsize)</code> </dt> <dd>
<p>Can be used to resize a tuple. <em>newsize</em> will be the new length of the tuple. Because tuples are <em>supposed</em> to be immutable, this should only be used if there is only one reference to the object. Do <em>not</em> use this if the tuple may already be known to some other part of the code. The tuple will always grow or shrink at the end. Think of this as destroying the old tuple and creating a new one, only more efficiently. Returns <code>0</code> on success. Client code should never assume that the resulting value of <code>*p</code> will be the same as before calling this function. If the object referenced by <code>*p</code> is replaced, the original <code>*p</code> is destroyed. On failure, returns <code>-1</code> and sets <code>*p</code> to <code>NULL</code>, and raises <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code>MemoryError</code></a> or <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code>SystemError</code></a>.</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/tuple.html" class="_attribution-link">https://docs.python.org/3.13/c-api/tuple.html</a>
  </p>
</div>
