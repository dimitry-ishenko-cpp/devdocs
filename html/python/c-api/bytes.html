 <span id="bytesobjects"></span><h1>Bytes Objects</h1> <p>These functions raise <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> when expecting a bytes parameter and called with a non-bytes parameter.</p> <dl class="c type" id="index-0"> <dt class="sig sig-object c" id="c.PyBytesObject">
<code>type PyBytesObject</code> </dt> <dd>
<p>This subtype of <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>PyObject</code></a> represents a Python bytes object.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyBytes_Type">
<code>PyTypeObject PyBytes_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>This instance of <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> represents the Python bytes type; it is the same object as <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> in the Python layer.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_Check">
<code>int PyBytes_Check(PyObject *o)</code> </dt> <dd>
<p>Return true if the object <em>o</em> is a bytes object or an instance of a subtype of the bytes type. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_CheckExact">
<code>int PyBytes_CheckExact(PyObject *o)</code> </dt> <dd>
<p>Return true if the object <em>o</em> is a bytes object, but not an instance of a subtype of the bytes type. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_FromString">
<code>PyObject *PyBytes_FromString(const char *v)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new bytes object with a copy of the string <em>v</em> as value on success, and <code>NULL</code> on failure. The parameter <em>v</em> must not be <code>NULL</code>; it will not be checked.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_FromStringAndSize">
<code>PyObject *PyBytes_FromStringAndSize(const char *v, Py_ssize_t len)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new bytes object with a copy of the string <em>v</em> as value and length <em>len</em> on success, and <code>NULL</code> on failure. If <em>v</em> is <code>NULL</code>, the contents of the bytes object are uninitialized.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_FromFormat">
<code>PyObject *PyBytes_FromFormat(const char *format, ...)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Take a C <code>printf()</code>-style <em>format</em> string and a variable number of arguments, calculate the size of the resulting Python bytes object and return a bytes object with the values formatted into it. The variable arguments must be C types and must correspond exactly to the format characters in the <em>format</em> string. The following format characters are allowed:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Format Characters</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Comment</p></th> </tr> </thead>  <tr>
<td><p><code>%%</code></p></td> <td><p><em>n/a</em></p></td> <td><p>The literal % character.</p></td> </tr> <tr>
<td><p><code>%c</code></p></td> <td><p>int</p></td> <td><p>A single byte, represented as a C int.</p></td> </tr> <tr>
<td><p><code>%d</code></p></td> <td><p>int</p></td> <td><p>Equivalent to <code>printf("%d")</code>. <a class="footnote-reference brackets" href="#id9" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>%u</code></p></td> <td><p>unsigned int</p></td> <td><p>Equivalent to <code>printf("%u")</code>. <a class="footnote-reference brackets" href="#id9" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>%ld</code></p></td> <td><p>long</p></td> <td><p>Equivalent to <code>printf("%ld")</code>. <a class="footnote-reference brackets" href="#id9" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>%lu</code></p></td> <td><p>unsigned long</p></td> <td><p>Equivalent to <code>printf("%lu")</code>. <a class="footnote-reference brackets" href="#id9" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>%zd</code></p></td> <td><p><a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a></p></td> <td><p>Equivalent to <code>printf("%zd")</code>. <a class="footnote-reference brackets" href="#id9" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>%zu</code></p></td> <td><p>size_t</p></td> <td><p>Equivalent to <code>printf("%zu")</code>. <a class="footnote-reference brackets" href="#id9" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>%i</code></p></td> <td><p>int</p></td> <td><p>Equivalent to <code>printf("%i")</code>. <a class="footnote-reference brackets" href="#id9" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>%x</code></p></td> <td><p>int</p></td> <td><p>Equivalent to <code>printf("%x")</code>. <a class="footnote-reference brackets" href="#id9" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><code>%s</code></p></td> <td><p>const char*</p></td> <td><p>A null-terminated C character array.</p></td> </tr> <tr>
<td><p><code>%p</code></p></td> <td><p>const void*</p></td> <td><p>The hex representation of a C pointer. Mostly equivalent to <code>printf("%p")</code> except that it is guaranteed to start with the literal <code>0x</code> regardless of what the platformâ€™s <code>printf</code> yields.</p></td> </tr>  </table> <p>An unrecognized format character causes all the rest of the format string to be copied as-is to the result object, and any extra arguments discarded.</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id9" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>,<a role="doc-backlink" href="#id3">3</a>,<a role="doc-backlink" href="#id4">4</a>,<a role="doc-backlink" href="#id5">5</a>,<a role="doc-backlink" href="#id6">6</a>,<a role="doc-backlink" href="#id7">7</a>,<a role="doc-backlink" href="#id8">8</a>)</span> <p>For integer specifiers (d, u, ld, lu, zd, zu, i, x): the 0-conversion flag has effect even when a precision is given.</p> </aside> </aside> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_FromFormatV">
<code>PyObject *PyBytes_FromFormatV(const char *format, va_list vargs)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Identical to <a class="reference internal" href="#c.PyBytes_FromFormat" title="PyBytes_FromFormat"><code>PyBytes_FromFormat()</code></a> except that it takes exactly two arguments.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_FromObject">
<code>PyObject *PyBytes_FromObject(PyObject *o)</code> </dt> <dd>
<em class="refcount return_new_ref">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the bytes representation of object <em>o</em> that implements the buffer protocol.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_Size">
<code>Py_ssize_t PyBytes_Size(PyObject *o)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the length of the bytes in bytes object <em>o</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_GET_SIZE">
<code>Py_ssize_t PyBytes_GET_SIZE(PyObject *o)</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#c.PyBytes_Size" title="PyBytes_Size"><code>PyBytes_Size()</code></a>, but without error checking.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_AsString">
<code>char *PyBytes_AsString(PyObject *o)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a pointer to the contents of <em>o</em>. The pointer refers to the internal buffer of <em>o</em>, which consists of <code>len(o) + 1</code> bytes. The last byte in the buffer is always null, regardless of whether there are any other null bytes. The data must not be modified in any way, unless the object was just created using <code>PyBytes_FromStringAndSize(NULL, size)</code>. It must not be deallocated. If <em>o</em> is not a bytes object at all, <a class="reference internal" href="#c.PyBytes_AsString" title="PyBytes_AsString"><code>PyBytes_AsString()</code></a> returns <code>NULL</code> and raises <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_AS_STRING">
<code>char *PyBytes_AS_STRING(PyObject *string)</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#c.PyBytes_AsString" title="PyBytes_AsString"><code>PyBytes_AsString()</code></a>, but without error checking.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_AsStringAndSize">
<code>int PyBytes_AsStringAndSize(PyObject *obj, char **buffer, Py_ssize_t *length)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return the null-terminated contents of the object <em>obj</em> through the output variables <em>buffer</em> and <em>length</em>. Returns <code>0</code> on success.</p> <p>If <em>length</em> is <code>NULL</code>, the bytes object may not contain embedded null bytes; if it does, the function returns <code>-1</code> and a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised.</p> <p>The buffer refers to an internal buffer of <em>obj</em>, which includes an additional null byte at the end (not counted in <em>length</em>). The data must not be modified in any way, unless the object was just created using <code>PyBytes_FromStringAndSize(NULL, size)</code>. It must not be deallocated. If <em>obj</em> is not a bytes object at all, <a class="reference internal" href="#c.PyBytes_AsStringAndSize" title="PyBytes_AsStringAndSize"><code>PyBytes_AsStringAndSize()</code></a> returns <code>-1</code> and raises <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Previously, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> was raised when embedded null bytes were encountered in the bytes object.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_Concat">
<code>void PyBytes_Concat(PyObject **bytes, PyObject *newpart)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a new bytes object in <em>*bytes</em> containing the contents of <em>newpart</em> appended to <em>bytes</em>; the caller will own the new reference. The reference to the old value of <em>bytes</em> will be stolen. If the new object cannot be created, the old reference to <em>bytes</em> will still be discarded and the value of <em>*bytes</em> will be set to <code>NULL</code>; the appropriate exception will be set.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyBytes_ConcatAndDel">
<code>void PyBytes_ConcatAndDel(PyObject **bytes, PyObject *newpart)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Create a new bytes object in <em>*bytes</em> containing the contents of <em>newpart</em> appended to <em>bytes</em>. This version releases the <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to <em>newpart</em> (i.e. decrements its reference count).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c._PyBytes_Resize">
<code>int _PyBytes_Resize(PyObject **bytes, Py_ssize_t newsize)</code> </dt> <dd>
<p>Resize a bytes object. <em>newsize</em> will be the new length of the bytes object. You can think of it as creating a new bytes object and destroying the old one, only more efficiently. Pass the address of an existing bytes object as an lvalue (it may be written into), and the new size desired. On success, <em>*bytes</em> holds the resized bytes object and <code>0</code> is returned; the address in <em>*bytes</em> may differ from its input value. If the reallocation fails, the original bytes object at <em>*bytes</em> is deallocated, <em>*bytes</em> is set to <code>NULL</code>, <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code>MemoryError</code></a> is set, and <code>-1</code> is returned.</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/c-api/bytes.html" class="_attribution-link">https://docs.python.org/3.13/c-api/bytes.html</a>
  </p>
</div>
