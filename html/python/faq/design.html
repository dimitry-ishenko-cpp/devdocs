 <h1>Design and History FAQ</h1>   <ul> <li><a class="reference internal" href="#why-does-python-use-indentation-for-grouping-of-statements" id="id3">Why does Python use indentation for grouping of statements?</a></li> <li><a class="reference internal" href="#why-am-i-getting-strange-results-with-simple-arithmetic-operations" id="id4">Why am I getting strange results with simple arithmetic operations?</a></li> <li><a class="reference internal" href="#why-are-floating-point-calculations-so-inaccurate" id="id5">Why are floating-point calculations so inaccurate?</a></li> <li><a class="reference internal" href="#why-are-python-strings-immutable" id="id6">Why are Python strings immutable?</a></li> <li><a class="reference internal" href="#why-must-self-be-used-explicitly-in-method-definitions-and-calls" id="id7">Why must ‘self’ be used explicitly in method definitions and calls?</a></li> <li><a class="reference internal" href="#why-can-t-i-use-an-assignment-in-an-expression" id="id8">Why can’t I use an assignment in an expression?</a></li> <li><a class="reference internal" href="#why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list" id="id9">Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g. len(list))?</a></li> <li><a class="reference internal" href="#why-is-join-a-string-method-instead-of-a-list-or-tuple-method" id="id10">Why is join() a string method instead of a list or tuple method?</a></li> <li><a class="reference internal" href="#how-fast-are-exceptions" id="id11">How fast are exceptions?</a></li> <li><a class="reference internal" href="#why-isn-t-there-a-switch-or-case-statement-in-python" id="id12">Why isn’t there a switch or case statement in Python?</a></li> <li><a class="reference internal" href="#can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation" id="id13">Can’t you emulate threads in the interpreter instead of relying on an OS-specific thread implementation?</a></li> <li><a class="reference internal" href="#why-can-t-lambda-expressions-contain-statements" id="id14">Why can’t lambda expressions contain statements?</a></li> <li><a class="reference internal" href="#can-python-be-compiled-to-machine-code-c-or-some-other-language" id="id15">Can Python be compiled to machine code, C or some other language?</a></li> <li><a class="reference internal" href="#how-does-python-manage-memory" id="id16">How does Python manage memory?</a></li> <li><a class="reference internal" href="#why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme" id="id17">Why doesn’t CPython use a more traditional garbage collection scheme?</a></li> <li><a class="reference internal" href="#why-isn-t-all-memory-freed-when-cpython-exits" id="id18">Why isn’t all memory freed when CPython exits?</a></li> <li><a class="reference internal" href="#why-are-there-separate-tuple-and-list-data-types" id="id19">Why are there separate tuple and list data types?</a></li> <li><a class="reference internal" href="#how-are-lists-implemented-in-cpython" id="id20">How are lists implemented in CPython?</a></li> <li><a class="reference internal" href="#how-are-dictionaries-implemented-in-cpython" id="id21">How are dictionaries implemented in CPython?</a></li> <li><a class="reference internal" href="#why-must-dictionary-keys-be-immutable" id="id22">Why must dictionary keys be immutable?</a></li> <li><a class="reference internal" href="#why-doesn-t-list-sort-return-the-sorted-list" id="id23">Why doesn’t list.sort() return the sorted list?</a></li> <li><a class="reference internal" href="#how-do-you-specify-and-enforce-an-interface-spec-in-python" id="id24">How do you specify and enforce an interface spec in Python?</a></li> <li><a class="reference internal" href="#why-is-there-no-goto" id="id25">Why is there no goto?</a></li> <li><a class="reference internal" href="#why-can-t-raw-strings-r-strings-end-with-a-backslash" id="id26">Why can’t raw strings (r-strings) end with a backslash?</a></li> <li><a class="reference internal" href="#why-doesn-t-python-have-a-with-statement-for-attribute-assignments" id="id27">Why doesn’t Python have a “with” statement for attribute assignments?</a></li> <li><a class="reference internal" href="#why-don-t-generators-support-the-with-statement" id="id28">Why don’t generators support the with statement?</a></li> <li><a class="reference internal" href="#why-are-colons-required-for-the-if-while-def-class-statements" id="id29">Why are colons required for the if/while/def/class statements?</a></li> <li><a class="reference internal" href="#why-does-python-allow-commas-at-the-end-of-lists-and-tuples" id="id30">Why does Python allow commas at the end of lists and tuples?</a></li> </ul>
<ul class="simple">  </ul>  <section id="why-does-python-use-indentation-for-grouping-of-statements"> <h2>Why does Python use indentation for grouping of statements?</h2> <p>Guido van Rossum believes that using indentation for grouping is extremely elegant and contributes a lot to the clarity of the average Python program. Most people learn to love this feature after a while.</p> <p>Since there are no begin/end brackets there cannot be a disagreement between grouping perceived by the parser and the human reader. Occasionally C programmers will encounter a fragment of code like this:</p> <pre data-language="python">if (x &lt;= y)
        x++;
        y--;
z++;
</pre> <p>Only the <code>x++</code> statement is executed if the condition is true, but the indentation leads many to believe otherwise. Even experienced C programmers will sometimes stare at it a long time wondering as to why <code>y</code> is being decremented even for <code>x &gt; y</code>.</p> <p>Because there are no begin/end brackets, Python is much less prone to coding-style conflicts. In C there are many different ways to place the braces. After becoming used to reading and writing code using a particular style, it is normal to feel somewhat uneasy when reading (or being required to write) in a different one.</p> <p>Many coding styles place begin/end brackets on a line by themselves. This makes programs considerably longer and wastes valuable screen space, making it harder to get a good overview of a program. Ideally, a function should fit on one screen (say, 20–30 lines). 20 lines of Python can do a lot more work than 20 lines of C. This is not solely due to the lack of begin/end brackets – the lack of declarations and the high-level data types are also responsible – but the indentation-based syntax certainly helps.</p> </section> <section id="why-am-i-getting-strange-results-with-simple-arithmetic-operations"> <h2>Why am I getting strange results with simple arithmetic operations?</h2> <p>See the next question.</p> </section> <section id="why-are-floating-point-calculations-so-inaccurate"> <h2>Why are floating-point calculations so inaccurate?</h2> <p>Users are often surprised by results like this:</p> <pre data-language="python">&gt;&gt;&gt; 1.2 - 1.0
0.19999999999999996
</pre> <p>and think it is a bug in Python. It’s not. This has little to do with Python, and much more to do with how the underlying platform handles floating-point numbers.</p> <p>The <a class="reference internal" href="../library/functions.html#float" title="float"><code>float</code></a> type in CPython uses a C <code>double</code> for storage. A <a class="reference internal" href="../library/functions.html#float" title="float"><code>float</code></a> object’s value is stored in binary floating-point with a fixed precision (typically 53 bits) and Python uses C operations, which in turn rely on the hardware implementation in the processor, to perform floating-point operations. This means that as far as floating-point operations are concerned, Python behaves like many popular languages including C and Java.</p> <p>Many numbers that can be written easily in decimal notation cannot be expressed exactly in binary floating point. For example, after:</p> <pre data-language="python">&gt;&gt;&gt; x = 1.2
</pre> <p>the value stored for <code>x</code> is a (very good) approximation to the decimal value <code>1.2</code>, but is not exactly equal to it. On a typical machine, the actual stored value is:</p> <pre data-language="python">1.0011001100110011001100110011001100110011001100110011 (binary)
</pre> <p>which is exactly:</p> <pre data-language="python">1.1999999999999999555910790149937383830547332763671875 (decimal)
</pre> <p>The typical precision of 53 bits provides Python floats with 15–16 decimal digits of accuracy.</p> <p>For a fuller explanation, please see the <a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><span class="std std-ref">floating-point arithmetic</span></a> chapter in the Python tutorial.</p> </section> <section id="why-are-python-strings-immutable"> <h2>Why are Python strings immutable?</h2> <p>There are several advantages.</p> <p>One is performance: knowing that a string is immutable means we can allocate space for it at creation time, and the storage requirements are fixed and unchanging. This is also one of the reasons for the distinction between tuples and lists.</p> <p>Another advantage is that strings in Python are considered as “elemental” as numbers. No amount of activity will change the value 8 to anything else, and in Python, no amount of activity will change the string “eight” to anything else.</p> </section> <section id="why-must-self-be-used-explicitly-in-method-definitions-and-calls"> <span id="why-self"></span><h2>Why must ‘self’ be used explicitly in method definitions and calls?</h2> <p>The idea was borrowed from Modula-3. It turns out to be very useful, for a variety of reasons.</p> <p>First, it’s more obvious that you are using a method or instance attribute instead of a local variable. Reading <code>self.x</code> or <code>self.meth()</code> makes it absolutely clear that an instance variable or method is used even if you don’t know the class definition by heart. In C++, you can sort of tell by the lack of a local variable declaration (assuming globals are rare or easily recognizable) – but in Python, there are no local variable declarations, so you’d have to look up the class definition to be sure. Some C++ and Java coding standards call for instance attributes to have an <code>m_</code> prefix, so this explicitness is still useful in those languages, too.</p> <p>Second, it means that no special syntax is necessary if you want to explicitly reference or call the method from a particular class. In C++, if you want to use a method from a base class which is overridden in a derived class, you have to use the <code>::</code> operator – in Python you can write <code>baseclass.methodname(self, &lt;argument list&gt;)</code>. This is particularly useful for <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> methods, and in general in cases where a derived class method wants to extend the base class method of the same name and thus has to call the base class method somehow.</p> <p>Finally, for instance variables it solves a syntactic problem with assignment: since local variables in Python are (by definition!) those variables to which a value is assigned in a function body (and that aren’t explicitly declared global), there has to be some way to tell the interpreter that an assignment was meant to assign to an instance variable instead of to a local variable, and it should preferably be syntactic (for efficiency reasons). C++ does this through declarations, but Python doesn’t have declarations and it would be a pity having to introduce them just for this purpose. Using the explicit <code>self.var</code> solves this nicely. Similarly, for using instance variables, having to write <code>self.var</code> means that references to unqualified names inside a method don’t have to search the instance’s directories. To put it another way, local variables and instance variables live in two different namespaces, and you need to tell Python which namespace to use.</p> </section> <section id="why-can-t-i-use-an-assignment-in-an-expression"> <span id="id1"></span><h2>Why can’t I use an assignment in an expression?</h2> <p>Starting in Python 3.8, you can!</p> <p>Assignment expressions using the walrus operator <code>:=</code> assign a variable in an expression:</p> <pre data-language="python">while chunk := fp.read(200):
   print(chunk)
</pre> <p>See <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a> for more information.</p> </section> <section id="why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list"> <h2>Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g. len(list))?</h2> <p>As Guido said:</p>  <p>(a) For some operations, prefix notation just reads better than postfix – prefix (and infix!) operations have a long tradition in mathematics which likes notations where the visuals help the mathematician thinking about a problem. Compare the easy with which we rewrite a formula like x*(a+b) into x*a + x*b to the clumsiness of doing the same thing using a raw OO notation.</p> <p>(b) When I read code that says len(x) I <em>know</em> that it is asking for the length of something. This tells me two things: the result is an integer, and the argument is some kind of container. To the contrary, when I read x.len(), I have to already know that x is some kind of container implementing an interface or inheriting from a class that has a standard len(). Witness the confusion we occasionally have when a class that is not implementing a mapping has a get() or keys() method, or something that isn’t a file has a write() method.</p> <p class="attribution">—<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-November/004643.html">https://mail.python.org/pipermail/python-3000/2006-November/004643.html</a></p>  </section> <section id="why-is-join-a-string-method-instead-of-a-list-or-tuple-method"> <h2>Why is join() a string method instead of a list or tuple method?</h2> <p>Strings became much more like other standard types starting in Python 1.6, when methods were added which give the same functionality that has always been available using the functions of the string module. Most of these new methods have been widely accepted, but the one which appears to make some programmers feel uncomfortable is:</p> <pre data-language="python">", ".join(['1', '2', '4', '8', '16'])
</pre> <p>which gives the result:</p> <pre data-language="python">"1, 2, 4, 8, 16"
</pre> <p>There are two common arguments against this usage.</p> <p>The first runs along the lines of: “It looks really ugly using a method of a string literal (string constant)”, to which the answer is that it might, but a string literal is just a fixed value. If the methods are to be allowed on names bound to strings there is no logical reason to make them unavailable on literals.</p> <p>The second objection is typically cast as: “I am really telling a sequence to join its members together with a string constant”. Sadly, you aren’t. For some reason there seems to be much less difficulty with having <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code>split()</code></a> as a string method, since in that case it is easy to see that</p> <pre data-language="python">"1, 2, 4, 8, 16".split(", ")
</pre> <p>is an instruction to a string literal to return the substrings delimited by the given separator (or, by default, arbitrary runs of white space).</p> <p><a class="reference internal" href="../library/stdtypes.html#str.join" title="str.join"><code>join()</code></a> is a string method because in using it you are telling the separator string to iterate over a sequence of strings and insert itself between adjacent elements. This method can be used with any argument which obeys the rules for sequence objects, including any new classes you might define yourself. Similar methods exist for bytes and bytearray objects.</p> </section> <section id="how-fast-are-exceptions"> <h2>How fast are exceptions?</h2> <p>A <a class="reference internal" href="../reference/compound_stmts.html#try"><code>try</code></a>/<a class="reference internal" href="../reference/compound_stmts.html#except"><code>except</code></a> block is extremely efficient if no exceptions are raised. Actually catching an exception is expensive. In versions of Python prior to 2.0 it was common to use this idiom:</p> <pre data-language="python">try:
    value = mydict[key]
except KeyError:
    mydict[key] = getvalue(key)
    value = mydict[key]
</pre> <p>This only made sense when you expected the dict to have the key almost all the time. If that wasn’t the case, you coded it like this:</p> <pre data-language="python">if key in mydict:
    value = mydict[key]
else:
    value = mydict[key] = getvalue(key)
</pre> <p>For this specific case, you could also use <code>value = dict.setdefault(key,
getvalue(key))</code>, but only if the <code>getvalue()</code> call is cheap enough because it is evaluated in all cases.</p> </section> <section id="why-isn-t-there-a-switch-or-case-statement-in-python"> <h2>Why isn’t there a switch or case statement in Python?</h2> <p>In general, structured switch statements execute one block of code when an expression has a particular value or set of values. Since Python 3.10 one can easily match literal values, or constants within a namespace, with a <code>match ... case</code> statement. An older alternative is a sequence of <code>if... elif... elif... else</code>.</p> <p>For cases where you need to choose from a very large number of possibilities, you can create a dictionary mapping case values to functions to call. For example:</p> <pre data-language="python">functions = {'a': function_1,
             'b': function_2,
             'c': self.method_1}

func = functions[value]
func()
</pre> <p>For calling methods on objects, you can simplify yet further by using the <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code>getattr()</code></a> built-in to retrieve methods with a particular name:</p> <pre data-language="python">class MyVisitor:
    def visit_a(self):
        ...

    def dispatch(self, value):
        method_name = 'visit_' + str(value)
        method = getattr(self, method_name)
        method()
</pre> <p>It’s suggested that you use a prefix for the method names, such as <code>visit_</code> in this example. Without such a prefix, if values are coming from an untrusted source, an attacker would be able to call any method on your object.</p> <p>Imitating switch with fallthrough, as with C’s switch-case-default, is possible, much harder, and less needed.</p> </section> <section id="can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation"> <h2>Can’t you emulate threads in the interpreter instead of relying on an OS-specific thread implementation?</h2> <p>Answer 1: Unfortunately, the interpreter pushes at least one C stack frame for each Python stack frame. Also, extensions can call back into Python at almost random moments. Therefore, a complete threads implementation requires thread support for C.</p> <p>Answer 2: Fortunately, there is <a class="reference external" href="https://github.com/stackless-dev/stackless/wiki">Stackless Python</a>, which has a completely redesigned interpreter loop that avoids the C stack.</p> </section> <section id="why-can-t-lambda-expressions-contain-statements"> <h2>Why can’t lambda expressions contain statements?</h2> <p>Python lambda expressions cannot contain statements because Python’s syntactic framework can’t handle statements nested inside expressions. However, in Python, this is not a serious problem. Unlike lambda forms in other languages, where they add functionality, Python lambdas are only a shorthand notation if you’re too lazy to define a function.</p> <p>Functions are already first class objects in Python, and can be declared in a local scope. Therefore the only advantage of using a lambda instead of a locally defined function is that you don’t need to invent a name for the function – but that’s just a local variable to which the function object (which is exactly the same type of object that a lambda expression yields) is assigned!</p> </section> <section id="can-python-be-compiled-to-machine-code-c-or-some-other-language"> <h2>Can Python be compiled to machine code, C or some other language?</h2> <p><a class="reference external" href="https://cython.org/">Cython</a> compiles a modified version of Python with optional annotations into C extensions. <a class="reference external" href="https://www.nuitka.net/">Nuitka</a> is an up-and-coming compiler of Python into C++ code, aiming to support the full Python language.</p> </section> <section id="how-does-python-manage-memory"> <h2>How does Python manage memory?</h2> <p>The details of Python memory management depend on the implementation. The standard implementation of Python, <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a>, uses reference counting to detect inaccessible objects, and another mechanism to collect reference cycles, periodically executing a cycle detection algorithm which looks for inaccessible cycles and deletes the objects involved. The <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code>gc</code></a> module provides functions to perform a garbage collection, obtain debugging statistics, and tune the collector’s parameters.</p> <p>Other implementations (such as <a class="reference external" href="https://www.jython.org">Jython</a> or <a class="reference external" href="https://www.pypy.org">PyPy</a>), however, can rely on a different mechanism such as a full-blown garbage collector. This difference can cause some subtle porting problems if your Python code depends on the behavior of the reference counting implementation.</p> <p>In some Python implementations, the following code (which is fine in CPython) will probably run out of file descriptors:</p> <pre data-language="python">for file in very_long_list_of_files:
    f = open(file)
    c = f.read(1)
</pre> <p>Indeed, using CPython’s reference counting and destructor scheme, each new assignment to <code>f</code> closes the previous file. With a traditional GC, however, those file objects will only get collected (and closed) at varying and possibly long intervals.</p> <p>If you want to write code that will work with any Python implementation, you should explicitly close the file or use the <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> statement; this will work regardless of memory management scheme:</p> <pre data-language="python">for file in very_long_list_of_files:
    with open(file) as f:
        c = f.read(1)
</pre> </section> <section id="why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme"> <h2>Why doesn’t CPython use a more traditional garbage collection scheme?</h2> <p>For one thing, this is not a C standard feature and hence it’s not portable. (Yes, we know about the Boehm GC library. It has bits of assembler code for <em>most</em> common platforms, not for all of them, and although it is mostly transparent, it isn’t completely transparent; patches are required to get Python to work with it.)</p> <p>Traditional GC also becomes a problem when Python is embedded into other applications. While in a standalone Python it’s fine to replace the standard <code>malloc()</code> and <code>free()</code> with versions provided by the GC library, an application embedding Python may want to have its <em>own</em> substitute for <code>malloc()</code> and <code>free()</code>, and may not want Python’s. Right now, CPython works with anything that implements <code>malloc()</code> and <code>free()</code> properly.</p> </section> <section id="why-isn-t-all-memory-freed-when-cpython-exits"> <h2>Why isn’t all memory freed when CPython exits?</h2> <p>Objects referenced from the global namespaces of Python modules are not always deallocated when Python exits. This may happen if there are circular references. There are also certain bits of memory that are allocated by the C library that are impossible to free (e.g. a tool like Purify will complain about these). Python is, however, aggressive about cleaning up memory on exit and does try to destroy every single object.</p> <p>If you want to force Python to delete certain things on deallocation use the <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code>atexit</code></a> module to run a function that will force those deletions.</p> </section> <section id="why-are-there-separate-tuple-and-list-data-types"> <h2>Why are there separate tuple and list data types?</h2> <p>Lists and tuples, while similar in many respects, are generally used in fundamentally different ways. Tuples can be thought of as being similar to Pascal <code>records</code> or C <code>structs</code>; they’re small collections of related data which may be of different types which are operated on as a group. For example, a Cartesian coordinate is appropriately represented as a tuple of two or three numbers.</p> <p>Lists, on the other hand, are more like arrays in other languages. They tend to hold a varying number of objects all of which have the same type and which are operated on one-by-one. For example, <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code>os.listdir('.')</code></a> returns a list of strings representing the files in the current directory. Functions which operate on this output would generally not break if you added another file or two to the directory.</p> <p>Tuples are immutable, meaning that once a tuple has been created, you can’t replace any of its elements with a new value. Lists are mutable, meaning that you can always change a list’s elements. Only immutable elements can be used as dictionary keys, and hence only tuples and not lists can be used as keys.</p> </section> <section id="how-are-lists-implemented-in-cpython"> <h2>How are lists implemented in CPython?</h2> <p>CPython’s lists are really variable-length arrays, not Lisp-style linked lists. The implementation uses a contiguous array of references to other objects, and keeps a pointer to this array and the array’s length in a list head structure.</p> <p>This makes indexing a list <code>a[i]</code> an operation whose cost is independent of the size of the list or the value of the index.</p> <p>When items are appended or inserted, the array of references is resized. Some cleverness is applied to improve the performance of appending items repeatedly; when the array must be grown, some extra space is allocated so the next few times don’t require an actual resize.</p> </section> <section id="how-are-dictionaries-implemented-in-cpython"> <h2>How are dictionaries implemented in CPython?</h2> <p>CPython’s dictionaries are implemented as resizable hash tables. Compared to B-trees, this gives better performance for lookup (the most common operation by far) under most circumstances, and the implementation is simpler.</p> <p>Dictionaries work by computing a hash code for each key stored in the dictionary using the <a class="reference internal" href="../library/functions.html#hash" title="hash"><code>hash()</code></a> built-in function. The hash code varies widely depending on the key and a per-process seed; for example, <code>'Python'</code> could hash to <code>-539294296</code> while <code>'python'</code>, a string that differs by a single bit, could hash to <code>1142331976</code>. The hash code is then used to calculate a location in an internal array where the value will be stored. Assuming that you’re storing keys that all have different hash values, this means that dictionaries take constant time – <em>O</em>(1), in Big-O notation – to retrieve a key.</p> </section> <section id="why-must-dictionary-keys-be-immutable"> <h2>Why must dictionary keys be immutable?</h2> <p>The hash table implementation of dictionaries uses a hash value calculated from the key value to find the key. If the key were a mutable object, its value could change, and thus its hash could also change. But since whoever changes the key object can’t tell that it was being used as a dictionary key, it can’t move the entry around in the dictionary. Then, when you try to look up the same object in the dictionary it won’t be found because its hash value is different. If you tried to look up the old value it wouldn’t be found either, because the value of the object found in that hash bin would be different.</p> <p>If you want a dictionary indexed with a list, simply convert the list to a tuple first; the function <code>tuple(L)</code> creates a tuple with the same entries as the list <code>L</code>. Tuples are immutable and can therefore be used as dictionary keys.</p> <p>Some unacceptable solutions that have been proposed:</p> <ul> <li>
<p>Hash lists by their address (object ID). This doesn’t work because if you construct a new list with the same value it won’t be found; e.g.:</p> <pre data-language="python">mydict = {[1, 2]: '12'}
print(mydict[[1, 2]])
</pre> <p>would raise a <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception because the id of the <code>[1, 2]</code> used in the second line differs from that in the first line. In other words, dictionary keys should be compared using <code>==</code>, not using <a class="reference internal" href="../reference/expressions.html#is"><code>is</code></a>.</p> </li> <li>Make a copy when using a list as a key. This doesn’t work because the list, being a mutable object, could contain a reference to itself, and then the copying code would run into an infinite loop.</li> <li>Allow lists as keys but tell the user not to modify them. This would allow a class of hard-to-track bugs in programs when you forgot or modified a list by accident. It also invalidates an important invariant of dictionaries: every value in <code>d.keys()</code> is usable as a key of the dictionary.</li> <li>Mark lists as read-only once they are used as a dictionary key. The problem is that it’s not just the top-level object that could change its value; you could use a tuple containing a list as a key. Entering anything as a key into a dictionary would require marking all objects reachable from there as read-only – and again, self-referential objects could cause an infinite loop.</li> </ul> <p>There is a trick to get around this if you need to, but use it at your own risk: You can wrap a mutable structure inside a class instance which has both a <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code>__eq__()</code></a> and a <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> method. You must then make sure that the hash value for all such wrapper objects that reside in a dictionary (or other hash based structure), remain fixed while the object is in the dictionary (or other structure).</p> <pre data-language="python">class ListWrapper:
    def __init__(self, the_list):
        self.the_list = the_list

    def __eq__(self, other):
        return self.the_list == other.the_list

    def __hash__(self):
        l = self.the_list
        result = 98767 - len(l)*555
        for i, el in enumerate(l):
            try:
                result = result + (hash(el) % 9999999) * 1001 + i
            except Exception:
                result = (result % 7777777) + i * 333
        return result
</pre> <p>Note that the hash computation is complicated by the possibility that some members of the list may be unhashable and also by the possibility of arithmetic overflow.</p> <p>Furthermore it must always be the case that if <code>o1 == o2</code> (ie <code>o1.__eq__(o2)
is True</code>) then <code>hash(o1) == hash(o2)</code> (ie, <code>o1.__hash__() == o2.__hash__()</code>), regardless of whether the object is in a dictionary or not. If you fail to meet these restrictions dictionaries and other hash based structures will misbehave.</p> <p>In the case of <code>ListWrapper</code>, whenever the wrapper object is in a dictionary the wrapped list must not change to avoid anomalies. Don’t do this unless you are prepared to think hard about the requirements and the consequences of not meeting them correctly. Consider yourself warned.</p> </section> <section id="why-doesn-t-list-sort-return-the-sorted-list"> <h2>Why doesn’t list.sort() return the sorted list?</h2> <p>In situations where performance matters, making a copy of the list just to sort it would be wasteful. Therefore, <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code>list.sort()</code></a> sorts the list in place. In order to remind you of that fact, it does not return the sorted list. This way, you won’t be fooled into accidentally overwriting a list when you need a sorted copy but also need to keep the unsorted version around.</p> <p>If you want to return a new list, use the built-in <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code>sorted()</code></a> function instead. This function creates a new list from a provided iterable, sorts it and returns it. For example, here’s how to iterate over the keys of a dictionary in sorted order:</p> <pre data-language="python">for key in sorted(mydict):
    ...  # do whatever with mydict[key]...
</pre> </section> <section id="how-do-you-specify-and-enforce-an-interface-spec-in-python"> <h2>How do you specify and enforce an interface spec in Python?</h2> <p>An interface specification for a module as provided by languages such as C++ and Java describes the prototypes for the methods and functions of the module. Many feel that compile-time enforcement of interface specifications helps in the construction of large programs.</p> <p>Python 2.6 adds an <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code>abc</code></a> module that lets you define Abstract Base Classes (ABCs). You can then use <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> and <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code>issubclass()</code></a> to check whether an instance or a class implements a particular ABC. The <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code>collections.abc</code></a> module defines a set of useful ABCs such as <a class="reference internal" href="../library/collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a>, <a class="reference internal" href="../library/collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code>Container</code></a>, and <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code>MutableMapping</code></a>.</p> <p>For Python, many of the advantages of interface specifications can be obtained by an appropriate test discipline for components.</p> <p>A good test suite for a module can both provide a regression test and serve as a module interface specification and a set of examples. Many Python modules can be run as a script to provide a simple “self test.” Even modules which use complex external interfaces can often be tested in isolation using trivial “stub” emulations of the external interface. The <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code>doctest</code></a> and <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> modules or third-party test frameworks can be used to construct exhaustive test suites that exercise every line of code in a module.</p> <p>An appropriate testing discipline can help build large complex applications in Python as well as having interface specifications would. In fact, it can be better because an interface specification cannot test certain properties of a program. For example, the <code>list.append()</code> method is expected to add new elements to the end of some internal list; an interface specification cannot test that your <code>list.append()</code> implementation will actually do this correctly, but it’s trivial to check this property in a test suite.</p> <p>Writing test suites is very helpful, and you might want to design your code to make it easily tested. One increasingly popular technique, test-driven development, calls for writing parts of the test suite first, before you write any of the actual code. Of course Python allows you to be sloppy and not write test cases at all.</p> </section> <section id="why-is-there-no-goto"> <h2>Why is there no goto?</h2> <p>In the 1970s people realized that unrestricted goto could lead to messy “spaghetti” code that was hard to understand and revise. In a high-level language, it is also unneeded as long as there are ways to branch (in Python, with <a class="reference internal" href="../reference/compound_stmts.html#if"><code>if</code></a> statements and <a class="reference internal" href="../reference/expressions.html#or"><code>or</code></a>, <a class="reference internal" href="../reference/expressions.html#and"><code>and</code></a>, and <a class="reference internal" href="../reference/compound_stmts.html#if"><code>if</code></a>/<a class="reference internal" href="../reference/compound_stmts.html#else"><code>else</code></a> expressions) and loop (with <a class="reference internal" href="../reference/compound_stmts.html#while"><code>while</code></a> and <a class="reference internal" href="../reference/compound_stmts.html#for"><code>for</code></a> statements, possibly containing <a class="reference internal" href="../reference/simple_stmts.html#continue"><code>continue</code></a> and <a class="reference internal" href="../reference/simple_stmts.html#break"><code>break</code></a>).</p> <p>One can also use exceptions to provide a “structured goto” that works even across function calls. Many feel that exceptions can conveniently emulate all reasonable uses of the <code>go</code> or <code>goto</code> constructs of C, Fortran, and other languages. For example:</p> <pre data-language="python">class label(Exception): pass  # declare a label

try:
    ...
    if condition: raise label()  # goto label
    ...
except label:  # where to goto
    pass
...
</pre> <p>This doesn’t allow you to jump into the middle of a loop, but that’s usually considered an abuse of <code>goto</code> anyway. Use sparingly.</p> </section> <section id="why-can-t-raw-strings-r-strings-end-with-a-backslash"> <h2>Why can’t raw strings (r-strings) end with a backslash?</h2> <p>More precisely, they can’t end with an odd number of backslashes: the unpaired backslash at the end escapes the closing quote character, leaving an unterminated string.</p> <p>Raw strings were designed to ease creating input for processors (chiefly regular expression engines) that want to do their own backslash escape processing. Such processors consider an unmatched trailing backslash to be an error anyway, so raw strings disallow that. In return, they allow you to pass on the string quote character by escaping it with a backslash. These rules work well when r-strings are used for their intended purpose.</p> <p>If you’re trying to build Windows pathnames, note that all Windows system calls accept forward slashes too:</p> <pre data-language="python">f = open("/mydir/file.txt")  # works fine!
</pre> <p>If you’re trying to build a pathname for a DOS command, try e.g. one of</p> <pre data-language="python">dir = r"\this\is\my\dos\dir" "\\"
dir = r"\this\is\my\dos\dir\ "[:-1]
dir = "\\this\\is\\my\\dos\\dir\\"
</pre> </section> <section id="why-doesn-t-python-have-a-with-statement-for-attribute-assignments"> <h2>Why doesn’t Python have a “with” statement for attribute assignments?</h2> <p>Python has a <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> statement that wraps the execution of a block, calling code on the entrance and exit from the block. Some languages have a construct that looks like this:</p> <pre data-language="python">with obj:
    a = 1               # equivalent to obj.a = 1
    total = total + 1   # obj.total = obj.total + 1
</pre> <p>In Python, such a construct would be ambiguous.</p> <p>Other languages, such as Object Pascal, Delphi, and C++, use static types, so it’s possible to know, in an unambiguous way, what member is being assigned to. This is the main point of static typing – the compiler <em>always</em> knows the scope of every variable at compile time.</p> <p>Python uses dynamic types. It is impossible to know in advance which attribute will be referenced at runtime. Member attributes may be added or removed from objects on the fly. This makes it impossible to know, from a simple reading, what attribute is being referenced: a local one, a global one, or a member attribute?</p> <p>For instance, take the following incomplete snippet:</p> <pre data-language="python">def foo(a):
    with a:
        print(x)
</pre> <p>The snippet assumes that <code>a</code> must have a member attribute called <code>x</code>. However, there is nothing in Python that tells the interpreter this. What should happen if <code>a</code> is, let us say, an integer? If there is a global variable named <code>x</code>, will it be used inside the <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> block? As you see, the dynamic nature of Python makes such choices much harder.</p> <p>The primary benefit of <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> and similar language features (reduction of code volume) can, however, easily be achieved in Python by assignment. Instead of:</p> <pre data-language="python">function(args).mydict[index][index].a = 21
function(args).mydict[index][index].b = 42
function(args).mydict[index][index].c = 63
</pre> <p>write this:</p> <pre data-language="python">ref = function(args).mydict[index][index]
ref.a = 21
ref.b = 42
ref.c = 63
</pre> <p>This also has the side-effect of increasing execution speed because name bindings are resolved at run-time in Python, and the second version only needs to perform the resolution once.</p> <p>Similar proposals that would introduce syntax to further reduce code volume, such as using a ‘leading dot’, have been rejected in favour of explicitness (see <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2016-May/040070.html">https://mail.python.org/pipermail/python-ideas/2016-May/040070.html</a>).</p> </section> <section id="why-don-t-generators-support-the-with-statement"> <h2>Why don’t generators support the with statement?</h2> <p>For technical reasons, a generator used directly as a context manager would not work correctly. When, as is most common, a generator is used as an iterator run to completion, no closing is needed. When it is, wrap it as <a class="reference internal" href="../library/contextlib.html#contextlib.closing" title="contextlib.closing"><code>contextlib.closing(generator)</code></a> in the <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> statement.</p> </section> <section id="why-are-colons-required-for-the-if-while-def-class-statements"> <h2>Why are colons required for the if/while/def/class statements?</h2> <p>The colon is required primarily to enhance readability (one of the results of the experimental ABC language). Consider this:</p> <pre data-language="python">if a == b
    print(a)
</pre> <p>versus</p> <pre data-language="python">if a == b:
    print(a)
</pre> <p>Notice how the second one is slightly easier to read. Notice further how a colon sets off the example in this FAQ answer; it’s a standard usage in English.</p> <p>Another minor reason is that the colon makes it easier for editors with syntax highlighting; they can look for colons to decide when indentation needs to be increased instead of having to do a more elaborate parsing of the program text.</p> </section> <section id="why-does-python-allow-commas-at-the-end-of-lists-and-tuples"> <h2>Why does Python allow commas at the end of lists and tuples?</h2> <p>Python lets you add a trailing comma at the end of lists, tuples, and dictionaries:</p> <pre data-language="python">[1, 2, 3,]
('a', 'b', 'c',)
d = {
    "A": [1, 5],
    "B": [6, 7],  # last trailing comma is optional but good style
}
</pre> <p>There are several reasons to allow this.</p> <p>When you have a literal value for a list, tuple, or dictionary spread across multiple lines, it’s easier to add more elements because you don’t have to remember to add a comma to the previous line. The lines can also be reordered without creating a syntax error.</p> <p>Accidentally omitting the comma can lead to errors that are hard to diagnose. For example:</p> <pre data-language="python">x = [
  "fee",
  "fie"
  "foo",
  "fum"
]
</pre> <p>This list looks like it has four elements, but it actually contains three: “fee”, “fiefoo” and “fum”. Always adding the comma avoids this source of error.</p> <p>Allowing the trailing comma may also make programmatic code generation easier.</p> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/faq/design.html" class="_attribution-link">https://docs.python.org/3.13/faq/design.html</a>
  </p>
</div>
