 <h1>Programming FAQ</h1>   <ul> <li>
<p><a class="reference internal" href="#general-questions" id="id3">General Questions</a></p> <ul> <li><a class="reference internal" href="#is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc" id="id4">Is there a source code level debugger with breakpoints, single-stepping, etc.?</a></li> <li><a class="reference internal" href="#are-there-tools-to-help-find-bugs-or-perform-static-analysis" id="id5">Are there tools to help find bugs or perform static analysis?</a></li> <li><a class="reference internal" href="#how-can-i-create-a-stand-alone-binary-from-a-python-script" id="id6">How can I create a stand-alone binary from a Python script?</a></li> <li><a class="reference internal" href="#are-there-coding-standards-or-a-style-guide-for-python-programs" id="id7">Are there coding standards or a style guide for Python programs?</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#core-language" id="id8">Core Language</a></p> <ul> <li><a class="reference internal" href="#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" id="id9">Why am I getting an UnboundLocalError when the variable has a value?</a></li> <li><a class="reference internal" href="#what-are-the-rules-for-local-and-global-variables-in-python" id="id10">What are the rules for local and global variables in Python?</a></li> <li><a class="reference internal" href="#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" id="id11">Why do lambdas defined in a loop with different values all return the same result?</a></li> <li><a class="reference internal" href="#how-do-i-share-global-variables-across-modules" id="id12">How do I share global variables across modules?</a></li> <li><a class="reference internal" href="#what-are-the-best-practices-for-using-import-in-a-module" id="id13">What are the “best practices” for using import in a module?</a></li> <li><a class="reference internal" href="#why-are-default-values-shared-between-objects" id="id14">Why are default values shared between objects?</a></li> <li><a class="reference internal" href="#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another" id="id15">How can I pass optional or keyword parameters from one function to another?</a></li> <li><a class="reference internal" href="#what-is-the-difference-between-arguments-and-parameters" id="id16">What is the difference between arguments and parameters?</a></li> <li><a class="reference internal" href="#why-did-changing-list-y-also-change-list-x" id="id17">Why did changing list ‘y’ also change list ‘x’?</a></li> <li><a class="reference internal" href="#how-do-i-write-a-function-with-output-parameters-call-by-reference" id="id18">How do I write a function with output parameters (call by reference)?</a></li> <li><a class="reference internal" href="#how-do-you-make-a-higher-order-function-in-python" id="id19">How do you make a higher order function in Python?</a></li> <li><a class="reference internal" href="#how-do-i-copy-an-object-in-python" id="id20">How do I copy an object in Python?</a></li> <li><a class="reference internal" href="#how-can-i-find-the-methods-or-attributes-of-an-object" id="id21">How can I find the methods or attributes of an object?</a></li> <li><a class="reference internal" href="#how-can-my-code-discover-the-name-of-an-object" id="id22">How can my code discover the name of an object?</a></li> <li><a class="reference internal" href="#what-s-up-with-the-comma-operator-s-precedence" id="id23">What’s up with the comma operator’s precedence?</a></li> <li><a class="reference internal" href="#is-there-an-equivalent-of-c-s-ternary-operator" id="id24">Is there an equivalent of C’s “?:” ternary operator?</a></li> <li><a class="reference internal" href="#is-it-possible-to-write-obfuscated-one-liners-in-python" id="id25">Is it possible to write obfuscated one-liners in Python?</a></li> <li><a class="reference internal" href="#what-does-the-slash-in-the-parameter-list-of-a-function-mean" id="id26">What does the slash(/) in the parameter list of a function mean?</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#numbers-and-strings" id="id27">Numbers and strings</a></p> <ul> <li><a class="reference internal" href="#how-do-i-specify-hexadecimal-and-octal-integers" id="id28">How do I specify hexadecimal and octal integers?</a></li> <li><a class="reference internal" href="#why-does-22-10-return-3" id="id29">Why does -22 // 10 return -3?</a></li> <li><a class="reference internal" href="#how-do-i-get-int-literal-attribute-instead-of-syntaxerror" id="id30">How do I get int literal attribute instead of SyntaxError?</a></li> <li><a class="reference internal" href="#how-do-i-convert-a-string-to-a-number" id="id31">How do I convert a string to a number?</a></li> <li><a class="reference internal" href="#how-do-i-convert-a-number-to-a-string" id="id32">How do I convert a number to a string?</a></li> <li><a class="reference internal" href="#how-do-i-modify-a-string-in-place" id="id33">How do I modify a string in place?</a></li> <li><a class="reference internal" href="#how-do-i-use-strings-to-call-functions-methods" id="id34">How do I use strings to call functions/methods?</a></li> <li><a class="reference internal" href="#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" id="id35">Is there an equivalent to Perl’s chomp() for removing trailing newlines from strings?</a></li> <li><a class="reference internal" href="#is-there-a-scanf-or-sscanf-equivalent" id="id36">Is there a scanf() or sscanf() equivalent?</a></li> <li><a class="reference internal" href="#what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean" id="id37">What does ‘UnicodeDecodeError’ or ‘UnicodeEncodeError’ error mean?</a></li> <li><a class="reference internal" href="#can-i-end-a-raw-string-with-an-odd-number-of-backslashes" id="id38">Can I end a raw string with an odd number of backslashes?</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#performance" id="id39">Performance</a></p> <ul> <li><a class="reference internal" href="#my-program-is-too-slow-how-do-i-speed-it-up" id="id40">My program is too slow. How do I speed it up?</a></li> <li><a class="reference internal" href="#what-is-the-most-efficient-way-to-concatenate-many-strings-together" id="id41">What is the most efficient way to concatenate many strings together?</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#sequences-tuples-lists" id="id42">Sequences (Tuples/Lists)</a></p> <ul> <li><a class="reference internal" href="#how-do-i-convert-between-tuples-and-lists" id="id43">How do I convert between tuples and lists?</a></li> <li><a class="reference internal" href="#what-s-a-negative-index" id="id44">What’s a negative index?</a></li> <li><a class="reference internal" href="#how-do-i-iterate-over-a-sequence-in-reverse-order" id="id45">How do I iterate over a sequence in reverse order?</a></li> <li><a class="reference internal" href="#how-do-you-remove-duplicates-from-a-list" id="id46">How do you remove duplicates from a list?</a></li> <li><a class="reference internal" href="#how-do-you-remove-multiple-items-from-a-list" id="id47">How do you remove multiple items from a list</a></li> <li><a class="reference internal" href="#how-do-you-make-an-array-in-python" id="id48">How do you make an array in Python?</a></li> <li><a class="reference internal" href="#how-do-i-create-a-multidimensional-list" id="id49">How do I create a multidimensional list?</a></li> <li><a class="reference internal" href="#how-do-i-apply-a-method-or-function-to-a-sequence-of-objects" id="id50">How do I apply a method or function to a sequence of objects?</a></li> <li><a class="reference internal" href="#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works" id="id51">Why does a_tuple[i] += [‘item’] raise an exception when the addition works?</a></li> <li><a class="reference internal" href="#i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python" id="id52">I want to do a complicated sort: can you do a Schwartzian Transform in Python?</a></li> <li><a class="reference internal" href="#how-can-i-sort-one-list-by-values-from-another-list" id="id53">How can I sort one list by values from another list?</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#objects" id="id54">Objects</a></p> <ul> <li><a class="reference internal" href="#what-is-a-class" id="id55">What is a class?</a></li> <li><a class="reference internal" href="#what-is-a-method" id="id56">What is a method?</a></li> <li><a class="reference internal" href="#what-is-self" id="id57">What is self?</a></li> <li><a class="reference internal" href="#how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it" id="id58">How do I check if an object is an instance of a given class or of a subclass of it?</a></li> <li><a class="reference internal" href="#what-is-delegation" id="id59">What is delegation?</a></li> <li><a class="reference internal" href="#how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-extends-it" id="id60">How do I call a method defined in a base class from a derived class that extends it?</a></li> <li><a class="reference internal" href="#how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class" id="id61">How can I organize my code to make it easier to change the base class?</a></li> <li><a class="reference internal" href="#how-do-i-create-static-class-data-and-static-class-methods" id="id62">How do I create static class data and static class methods?</a></li> <li><a class="reference internal" href="#how-can-i-overload-constructors-or-methods-in-python" id="id63">How can I overload constructors (or methods) in Python?</a></li> <li><a class="reference internal" href="#i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam" id="id64">I try to use __spam and I get an error about _SomeClassName__spam.</a></li> <li><a class="reference internal" href="#my-class-defines-del-but-it-is-not-called-when-i-delete-the-object" id="id65">My class defines __del__ but it is not called when I delete the object.</a></li> <li><a class="reference internal" href="#how-do-i-get-a-list-of-all-instances-of-a-given-class" id="id66">How do I get a list of all instances of a given class?</a></li> <li><a class="reference internal" href="#why-does-the-result-of-id-appear-to-be-not-unique" id="id67">Why does the result of <code>id()</code> appear to be not unique?</a></li> <li><a class="reference internal" href="#when-can-i-rely-on-identity-tests-with-the-is-operator" id="id68">When can I rely on identity tests with the is operator?</a></li> <li><a class="reference internal" href="#how-can-a-subclass-control-what-data-is-stored-in-an-immutable-instance" id="id69">How can a subclass control what data is stored in an immutable instance?</a></li> <li><a class="reference internal" href="#how-do-i-cache-method-calls" id="id70">How do I cache method calls?</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#modules" id="id71">Modules</a></p> <ul> <li><a class="reference internal" href="#how-do-i-create-a-pyc-file" id="id72">How do I create a .pyc file?</a></li> <li><a class="reference internal" href="#how-do-i-find-the-current-module-name" id="id73">How do I find the current module name?</a></li> <li><a class="reference internal" href="#how-can-i-have-modules-that-mutually-import-each-other" id="id74">How can I have modules that mutually import each other?</a></li> <li><a class="reference internal" href="#import-x-y-z-returns-module-x-how-do-i-get-z" id="id75">__import__(‘x.y.z’) returns &lt;module ‘x’&gt;; how do I get z?</a></li> <li><a class="reference internal" href="#when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen" id="id76">When I edit an imported module and reimport it, the changes don’t show up. Why does this happen?</a></li> </ul> </li> </ul>
<ul class="simple">  </ul>  <section id="general-questions"> <h2>General Questions</h2> <section id="is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc"> <h3>Is there a source code level debugger with breakpoints, single-stepping, etc.?</h3> <p>Yes.</p> <p>Several debuggers for Python are described below, and the built-in function <a class="reference internal" href="../library/functions.html#breakpoint" title="breakpoint"><code>breakpoint()</code></a> allows you to drop into any of them.</p> <p>The pdb module is a simple but adequate console-mode debugger for Python. It is part of the standard Python library, and is <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code>documented in the Library
Reference Manual</code></a>. You can also write your own debugger by using the code for pdb as an example.</p> <p>The IDLE interactive development environment, which is part of the standard Python distribution (normally available as <a class="reference external" href="https://github.com/python/cpython/blob/main/Tools/scripts/idle3">Tools/scripts/idle3</a>), includes a graphical debugger.</p> <p>PythonWin is a Python IDE that includes a GUI debugger based on pdb. The PythonWin debugger colors breakpoints and has quite a few cool features such as debugging non-PythonWin programs. PythonWin is available as part of <a class="reference external" href="https://github.com/mhammond/pywin32">pywin32</a> project and as a part of the <a class="reference external" href="https://www.activestate.com/products/python/">ActivePython</a> distribution.</p> <p><a class="reference external" href="https://eric-ide.python-projects.org/">Eric</a> is an IDE built on PyQt and the Scintilla editing component.</p> <p><a class="reference external" href="https://github.com/rocky/python3-trepan/">trepan3k</a> is a gdb-like debugger.</p> <p><a class="reference external" href="https://code.visualstudio.com/">Visual Studio Code</a> is an IDE with debugging tools that integrates with version-control software.</p> <p>There are a number of commercial Python IDEs that include graphical debuggers. They include:</p> <ul class="simple"> <li><a class="reference external" href="https://wingware.com/">Wing IDE</a></li> <li><a class="reference external" href="https://www.activestate.com/products/komodo-ide/">Komodo IDE</a></li> <li><a class="reference external" href="https://www.jetbrains.com/pycharm/">PyCharm</a></li> </ul> </section> <section id="are-there-tools-to-help-find-bugs-or-perform-static-analysis"> <h3>Are there tools to help find bugs or perform static analysis?</h3> <p>Yes.</p> <p><a class="reference external" href="https://pylint.pycqa.org/en/latest/index.html">Pylint</a> and <a class="reference external" href="https://github.com/PyCQA/pyflakes">Pyflakes</a> do basic checking that will help you catch bugs sooner.</p> <p>Static type checkers such as <a class="reference external" href="https://mypy-lang.org/">Mypy</a>, <a class="reference external" href="https://pyre-check.org/">Pyre</a>, and <a class="reference external" href="https://github.com/google/pytype">Pytype</a> can check type hints in Python source code.</p> </section> <section id="how-can-i-create-a-stand-alone-binary-from-a-python-script"> <span id="faq-create-standalone-binary"></span><h3>How can I create a stand-alone binary from a Python script?</h3> <p>You don’t need the ability to compile Python to C code if all you want is a stand-alone program that users can download and run without having to install the Python distribution first. There are a number of tools that determine the set of modules required by a program and bind these modules together with a Python binary to produce a single executable.</p> <p>One is to use the freeze tool, which is included in the Python source tree as <a class="reference external" href="https://github.com/python/cpython/tree/main/Tools/freeze">Tools/freeze</a>. It converts Python byte code to C arrays; with a C compiler you can embed all your modules into a new program, which is then linked with the standard Python modules.</p> <p>It works by scanning your source recursively for import statements (in both forms) and looking for the modules in the standard Python path as well as in the source directory (for built-in modules). It then turns the bytecode for modules written in Python into C code (array initializers that can be turned into code objects using the marshal module) and creates a custom-made config file that only contains those built-in modules which are actually used in the program. It then compiles the generated C code and links it with the rest of the Python interpreter to form a self-contained binary which acts exactly like your script.</p> <p>The following packages can help with the creation of console and GUI executables:</p> <ul class="simple"> <li>
<a class="reference external" href="https://nuitka.net/">Nuitka</a> (Cross-platform)</li> <li>
<a class="reference external" href="https://pyinstaller.org/">PyInstaller</a> (Cross-platform)</li> <li>
<a class="reference external" href="https://pyoxidizer.readthedocs.io/en/stable/">PyOxidizer</a> (Cross-platform)</li> <li>
<a class="reference external" href="https://marcelotduarte.github.io/cx_Freeze/">cx_Freeze</a> (Cross-platform)</li> <li>
<a class="reference external" href="https://github.com/ronaldoussoren/py2app">py2app</a> (macOS only)</li> <li>
<a class="reference external" href="https://www.py2exe.org/">py2exe</a> (Windows only)</li> </ul> </section> <section id="are-there-coding-standards-or-a-style-guide-for-python-programs"> <h3>Are there coding standards or a style guide for Python programs?</h3> <p>Yes. The coding style required for standard library modules is documented as <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a>.</p> </section> </section> <section id="core-language"> <h2>Core Language</h2> <section id="why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value"> <span id="faq-unboundlocalerror"></span><h3>Why am I getting an UnboundLocalError when the variable has a value?</h3> <p>It can be a surprise to get the <a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code>UnboundLocalError</code></a> in previously working code when it is modified by adding an assignment statement somewhere in the body of a function.</p> <p>This code:</p> <pre data-language="python">&gt;&gt;&gt; x = 10
&gt;&gt;&gt; def bar():
...     print(x)
...
&gt;&gt;&gt; bar()
10
</pre> <p>works, but this code:</p> <pre data-language="python">&gt;&gt;&gt; x = 10
&gt;&gt;&gt; def foo():
...     print(x)
...     x += 1
</pre> <p>results in an <code>UnboundLocalError</code>:</p> <pre data-language="python">&gt;&gt;&gt; foo()
Traceback (most recent call last):
  ...
UnboundLocalError: local variable 'x' referenced before assignment
</pre> <p>This is because when you make an assignment to a variable in a scope, that variable becomes local to that scope and shadows any similarly named variable in the outer scope. Since the last statement in foo assigns a new value to <code>x</code>, the compiler recognizes it as a local variable. Consequently when the earlier <code>print(x)</code> attempts to print the uninitialized local variable and an error results.</p> <p>In the example above you can access the outer scope variable by declaring it global:</p> <pre data-language="python">&gt;&gt;&gt; x = 10
&gt;&gt;&gt; def foobar():
...     global x
...     print(x)
...     x += 1
...
&gt;&gt;&gt; foobar()
10
</pre> <p>This explicit declaration is required in order to remind you that (unlike the superficially analogous situation with class and instance variables) you are actually modifying the value of the variable in the outer scope:</p> <pre data-language="python">&gt;&gt;&gt; print(x)
11
</pre> <p>You can do a similar thing in a nested scope using the <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> keyword:</p> <pre data-language="python">&gt;&gt;&gt; def foo():
...    x = 10
...    def bar():
...        nonlocal x
...        print(x)
...        x += 1
...    bar()
...    print(x)
...
&gt;&gt;&gt; foo()
10
11
</pre> </section> <section id="what-are-the-rules-for-local-and-global-variables-in-python"> <h3>What are the rules for local and global variables in Python?</h3> <p>In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a value anywhere within the function’s body, it’s assumed to be a local unless explicitly declared as global.</p> <p>Though a bit surprising at first, a moment’s consideration explains this. On one hand, requiring <a class="reference internal" href="../reference/simple_stmts.html#global"><code>global</code></a> for assigned variables provides a bar against unintended side-effects. On the other hand, if <code>global</code> was required for all global references, you’d be using <code>global</code> all the time. You’d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the <code>global</code> declaration for identifying side-effects.</p> </section> <section id="why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result"> <h3>Why do lambdas defined in a loop with different values all return the same result?</h3> <p>Assume you use a for loop to define a few different lambdas (or even plain functions), e.g.:</p> <pre data-language="python">&gt;&gt;&gt; squares = []
&gt;&gt;&gt; for x in range(5):
...     squares.append(lambda: x**2)
</pre> <p>This gives you a list that contains 5 lambdas that calculate <code>x**2</code>. You might expect that, when called, they would return, respectively, <code>0</code>, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code>. However, when you actually try you will see that they all return <code>16</code>:</p> <pre data-language="python">&gt;&gt;&gt; squares[2]()
16
&gt;&gt;&gt; squares[4]()
16
</pre> <p>This happens because <code>x</code> is not local to the lambdas, but is defined in the outer scope, and it is accessed when the lambda is called — not when it is defined. At the end of the loop, the value of <code>x</code> is <code>4</code>, so all the functions now return <code>4**2</code>, i.e. <code>16</code>. You can also verify this by changing the value of <code>x</code> and see how the results of the lambdas change:</p> <pre data-language="python">&gt;&gt;&gt; x = 8
&gt;&gt;&gt; squares[2]()
64
</pre> <p>In order to avoid this, you need to save the values in variables local to the lambdas, so that they don’t rely on the value of the global <code>x</code>:</p> <pre data-language="python">&gt;&gt;&gt; squares = []
&gt;&gt;&gt; for x in range(5):
...     squares.append(lambda n=x: n**2)
</pre> <p>Here, <code>n=x</code> creates a new variable <code>n</code> local to the lambda and computed when the lambda is defined so that it has the same value that <code>x</code> had at that point in the loop. This means that the value of <code>n</code> will be <code>0</code> in the first lambda, <code>1</code> in the second, <code>2</code> in the third, and so on. Therefore each lambda will now return the correct result:</p> <pre data-language="python">&gt;&gt;&gt; squares[2]()
4
&gt;&gt;&gt; squares[4]()
16
</pre> <p>Note that this behaviour is not peculiar to lambdas, but applies to regular functions too.</p> </section> <section id="how-do-i-share-global-variables-across-modules"> <h3>How do I share global variables across modules?</h3> <p>The canonical way to share information across modules within a single program is to create a special module (often called config or cfg). Just import the config module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:</p> <p>config.py:</p> <pre data-language="python">x = 0   # Default value of the 'x' configuration setting
</pre> <p>mod.py:</p> <pre data-language="python">import config
config.x = 1
</pre> <p>main.py:</p> <pre data-language="python">import config
import mod
print(config.x)
</pre> <p>Note that using a module is also the basis for implementing the singleton design pattern, for the same reason.</p> </section> <section id="what-are-the-best-practices-for-using-import-in-a-module"> <h3>What are the “best practices” for using import in a module?</h3> <p>In general, don’t use <code>from modulename import *</code>. Doing so clutters the importer’s namespace, and makes it much harder for linters to detect undefined names.</p> <p>Import modules at the top of a file. Doing so makes it clear what other modules your code requires and avoids questions of whether the module name is in scope. Using one import per line makes it easy to add and delete module imports, but using multiple imports per line uses less screen space.</p> <p>It’s good practice if you import modules in the following order:</p> <ol class="arabic simple"> <li>standard library modules – e.g. <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code>sys</code></a>, <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code>os</code></a>, <a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code>argparse</code></a>, <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a>
</li> <li>third-party library modules (anything installed in Python’s site-packages directory) – e.g. <code>dateutil</code>, <code>requests</code>, <code>PIL.Image</code>
</li> <li>locally developed modules</li> </ol> <p>It is sometimes necessary to move imports to a function or class to avoid problems with circular imports. Gordon McMillan says:</p>  <p>Circular imports are fine where both modules use the “import &lt;module&gt;” form of import. They fail when the 2nd module wants to grab a name out of the first (“from module import name”) and the import is at the top level. That’s because names in the 1st are not yet available, because the first module is busy importing the 2nd.</p>  <p>In this case, if the second module is only used in one function, then the import can easily be moved into that function. By the time the import is called, the first module will have finished initializing, and the second module can do its import.</p> <p>It may also be necessary to move imports out of the top level of code if some of the modules are platform-specific. In that case, it may not even be possible to import all of the modules at the top of the file. In this case, importing the correct modules in the corresponding platform-specific code is a good option.</p> <p>Only move imports into a local scope, such as inside a function definition, if it’s necessary to solve a problem such as avoiding a circular import or are trying to reduce the initialization time of a module. This technique is especially helpful if many of the imports are unnecessary depending on how the program executes. You may also want to move imports into a function if the modules are only ever used in that function. Note that loading a module the first time may be expensive because of the one time initialization of the module, but loading a module multiple times is virtually free, costing only a couple of dictionary lookups. Even if the module name has gone out of scope, the module is probably available in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code>sys.modules</code></a>.</p> </section> <section id="why-are-default-values-shared-between-objects"> <h3>Why are default values shared between objects?</h3> <p>This type of bug commonly bites neophyte programmers. Consider this function:</p> <pre data-language="python">def foo(mydict={}):  # Danger: shared reference to one dict for all calls
    ... compute something ...
    mydict[key] = value
    return mydict
</pre> <p>The first time you call this function, <code>mydict</code> contains a single item. The second time, <code>mydict</code> contains two items because when <code>foo()</code> begins executing, <code>mydict</code> starts out with an item already in it.</p> <p>It is often expected that a function call creates new objects for default values. This is not what happens. Default values are created exactly once, when the function is defined. If that object is changed, like the dictionary in this example, subsequent calls to the function will refer to this changed object.</p> <p>By definition, immutable objects such as numbers, strings, tuples, and <code>None</code>, are safe from change. Changes to mutable objects such as dictionaries, lists, and class instances can lead to confusion.</p> <p>Because of this feature, it is good programming practice to not use mutable objects as default values. Instead, use <code>None</code> as the default value and inside the function, check if the parameter is <code>None</code> and create a new list/dictionary/whatever if it is. For example, don’t write:</p> <pre data-language="python">def foo(mydict={}):
    ...
</pre> <p>but:</p> <pre data-language="python">def foo(mydict=None):
    if mydict is None:
        mydict = {}  # create a new dict for local namespace
</pre> <p>This feature can be useful. When you have a function that’s time-consuming to compute, a common technique is to cache the parameters and the resulting value of each call to the function, and return the cached value if the same value is requested again. This is called “memoizing”, and can be implemented like this:</p> <pre data-language="python"># Callers can only provide two parameters and optionally pass _cache by keyword
def expensive(arg1, arg2, *, _cache={}):
    if (arg1, arg2) in _cache:
        return _cache[(arg1, arg2)]

    # Calculate the value
    result = ... expensive computation ...
    _cache[(arg1, arg2)] = result           # Store result in the cache
    return result
</pre> <p>You could use a global variable containing a dictionary instead of the default value; it’s a matter of taste.</p> </section> <section id="how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another"> <h3>How can I pass optional or keyword parameters from one function to another?</h3> <p>Collect the arguments using the <code>*</code> and <code>**</code> specifiers in the function’s parameter list; this gives you the positional arguments as a tuple and the keyword arguments as a dictionary. You can then pass these arguments when calling another function by using <code>*</code> and <code>**</code>:</p> <pre data-language="python">def f(x, *args, **kwargs):
    ...
    kwargs['width'] = '14.3c'
    ...
    g(x, *args, **kwargs)
</pre> </section> <section id="what-is-the-difference-between-arguments-and-parameters"> <span id="faq-argument-vs-parameter"></span><span id="index-1"></span><h3>What is the difference between arguments and parameters?</h3> <p><a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">Parameters</span></a> are defined by the names that appear in a function definition, whereas <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">arguments</span></a> are the values actually passed to a function when calling it. Parameters define what <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">kind of arguments</span></a> a function can accept. For example, given the function definition:</p> <pre data-language="python">def func(foo, bar=None, **kwargs):
    pass
</pre> <p><em>foo</em>, <em>bar</em> and <em>kwargs</em> are parameters of <code>func</code>. However, when calling <code>func</code>, for example:</p> <pre data-language="python">func(42, bar=314, extra=somevar)
</pre> <p>the values <code>42</code>, <code>314</code>, and <code>somevar</code> are arguments.</p> </section> <section id="why-did-changing-list-y-also-change-list-x"> <h3>Why did changing list ‘y’ also change list ‘x’?</h3> <p>If you wrote code like:</p> <pre data-language="python">&gt;&gt;&gt; x = []
&gt;&gt;&gt; y = x
&gt;&gt;&gt; y.append(10)
&gt;&gt;&gt; y
[10]
&gt;&gt;&gt; x
[10]
</pre> <p>you might be wondering why appending an element to <code>y</code> changed <code>x</code> too.</p> <p>There are two factors that produce this result:</p> <ol class="arabic simple"> <li>Variables are simply names that refer to objects. Doing <code>y = x</code> doesn’t create a copy of the list – it creates a new variable <code>y</code> that refers to the same object <code>x</code> refers to. This means that there is only one object (the list), and both <code>x</code> and <code>y</code> refer to it.</li> <li>Lists are <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a>, which means that you can change their content.</li> </ol> <p>After the call to <code>append()</code>, the content of the mutable object has changed from <code>[]</code> to <code>[10]</code>. Since both the variables refer to the same object, using either name accesses the modified value <code>[10]</code>.</p> <p>If we instead assign an immutable object to <code>x</code>:</p> <pre data-language="python">&gt;&gt;&gt; x = 5  # ints are immutable
&gt;&gt;&gt; y = x
&gt;&gt;&gt; x = x + 1  # 5 can't be mutated, we are creating a new object here
&gt;&gt;&gt; x
6
&gt;&gt;&gt; y
5
</pre> <p>we can see that in this case <code>x</code> and <code>y</code> are not equal anymore. This is because integers are <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a>, and when we do <code>x = x + 1</code> we are not mutating the int <code>5</code> by incrementing its value; instead, we are creating a new object (the int <code>6</code>) and assigning it to <code>x</code> (that is, changing which object <code>x</code> refers to). After this assignment we have two objects (the ints <code>6</code> and <code>5</code>) and two variables that refer to them (<code>x</code> now refers to <code>6</code> but <code>y</code> still refers to <code>5</code>).</p> <p>Some operations (for example <code>y.append(10)</code> and <code>y.sort()</code>) mutate the object, whereas superficially similar operations (for example <code>y = y + [10]</code> and <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code>sorted(y)</code></a>) create a new object. In general in Python (and in all cases in the standard library) a method that mutates an object will return <code>None</code> to help avoid getting the two types of operations confused. So if you mistakenly write <code>y.sort()</code> thinking it will give you a sorted copy of <code>y</code>, you’ll instead end up with <code>None</code>, which will likely cause your program to generate an easily diagnosed error.</p> <p>However, there is one class of operations where the same operation sometimes has different behaviors with different types: the augmented assignment operators. For example, <code>+=</code> mutates lists but not tuples or ints (<code>a_list
+= [1, 2, 3]</code> is equivalent to <code>a_list.extend([1, 2, 3])</code> and mutates <code>a_list</code>, whereas <code>some_tuple += (1, 2, 3)</code> and <code>some_int += 1</code> create new objects).</p> <p>In other words:</p> <ul class="simple"> <li>If we have a mutable object (<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code>list</code></a>, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code>dict</code></a>, <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code>set</code></a>, etc.), we can use some specific operations to mutate it and all the variables that refer to it will see the change.</li> <li>If we have an immutable object (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a>, <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a>, etc.), all the variables that refer to it will always see the same value, but operations that transform that value into a new value always return a new object.</li> </ul> <p>If you want to know if two variables refer to the same object or not, you can use the <a class="reference internal" href="../reference/expressions.html#is"><code>is</code></a> operator, or the built-in function <a class="reference internal" href="../library/functions.html#id" title="id"><code>id()</code></a>.</p> </section> <section id="how-do-i-write-a-function-with-output-parameters-call-by-reference"> <h3>How do I write a function with output parameters (call by reference)?</h3> <p>Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there’s no alias between an argument name in the caller and callee, and so no call-by-reference per se. You can achieve the desired effect in a number of ways.</p> <ol class="arabic"> <li>
<p>By returning a tuple of the results:</p> <pre data-language="python">&gt;&gt;&gt; def func1(a, b):
...     a = 'new-value'        # a and b are local names
...     b = b + 1              # assigned to new objects
...     return a, b            # return new values
...
&gt;&gt;&gt; x, y = 'old-value', 99
&gt;&gt;&gt; func1(x, y)
('new-value', 100)
</pre> <p>This is almost always the clearest solution.</p> </li> <li>By using global variables. This isn’t thread-safe, and is not recommended.</li> <li>
<p>By passing a mutable (changeable in-place) object:</p> <pre data-language="python">&gt;&gt;&gt; def func2(a):
...     a[0] = 'new-value'     # 'a' references a mutable list
...     a[1] = a[1] + 1        # changes a shared object
...
&gt;&gt;&gt; args = ['old-value', 99]
&gt;&gt;&gt; func2(args)
&gt;&gt;&gt; args
['new-value', 100]
</pre> </li> <li>
<p>By passing in a dictionary that gets mutated:</p> <pre data-language="python">&gt;&gt;&gt; def func3(args):
...     args['a'] = 'new-value'     # args is a mutable dictionary
...     args['b'] = args['b'] + 1   # change it in-place
...
&gt;&gt;&gt; args = {'a': 'old-value', 'b': 99}
&gt;&gt;&gt; func3(args)
&gt;&gt;&gt; args
{'a': 'new-value', 'b': 100}
</pre> </li> <li>
<p>Or bundle up values in a class instance:</p> <pre data-language="python">&gt;&gt;&gt; class Namespace:
...     def __init__(self, /, **args):
...         for key, value in args.items():
...             setattr(self, key, value)
...
&gt;&gt;&gt; def func4(args):
...     args.a = 'new-value'        # args is a mutable Namespace
...     args.b = args.b + 1         # change object in-place
...
&gt;&gt;&gt; args = Namespace(a='old-value', b=99)
&gt;&gt;&gt; func4(args)
&gt;&gt;&gt; vars(args)
{'a': 'new-value', 'b': 100}
</pre> <p>There’s almost never a good reason to get this complicated.</p> </li> </ol> <p>Your best choice is to return a tuple containing the multiple results.</p> </section> <section id="how-do-you-make-a-higher-order-function-in-python"> <h3>How do you make a higher order function in Python?</h3> <p>You have two choices: you can use nested scopes or you can use callable objects. For example, suppose you wanted to define <code>linear(a,b)</code> which returns a function <code>f(x)</code> that computes the value <code>a*x+b</code>. Using nested scopes:</p> <pre data-language="python">def linear(a, b):
    def result(x):
        return a * x + b
    return result
</pre> <p>Or using a callable object:</p> <pre data-language="python">class linear:

    def __init__(self, a, b):
        self.a, self.b = a, b

    def __call__(self, x):
        return self.a * x + self.b
</pre> <p>In both cases,</p> <pre data-language="python">taxes = linear(0.3, 2)
</pre> <p>gives a callable object where <code>taxes(10e6) == 0.3 * 10e6 + 2</code>.</p> <p>The callable object approach has the disadvantage that it is a bit slower and results in slightly longer code. However, note that a collection of callables can share their signature via inheritance:</p> <pre data-language="python">class exponential(linear):
    # __init__ inherited
    def __call__(self, x):
        return self.a * (x ** self.b)
</pre> <p>Object can encapsulate state for several methods:</p> <pre data-language="python">class counter:

    value = 0

    def set(self, x):
        self.value = x

    def up(self):
        self.value = self.value + 1

    def down(self):
        self.value = self.value - 1

count = counter()
inc, dec, reset = count.up, count.down, count.set
</pre> <p>Here <code>inc()</code>, <code>dec()</code> and <code>reset()</code> act like functions which share the same counting variable.</p> </section> <section id="how-do-i-copy-an-object-in-python"> <h3>How do I copy an object in Python?</h3> <p>In general, try <a class="reference internal" href="../library/copy.html#copy.copy" title="copy.copy"><code>copy.copy()</code></a> or <a class="reference internal" href="../library/copy.html#copy.deepcopy" title="copy.deepcopy"><code>copy.deepcopy()</code></a> for the general case. Not all objects can be copied, but most can.</p> <p>Some objects can be copied more easily. Dictionaries have a <a class="reference internal" href="../library/stdtypes.html#dict.copy" title="dict.copy"><code>copy()</code></a> method:</p> <pre data-language="python">newdict = olddict.copy()
</pre> <p>Sequences can be copied by slicing:</p> <pre data-language="python">new_l = l[:]
</pre> </section> <section id="how-can-i-find-the-methods-or-attributes-of-an-object"> <h3>How can I find the methods or attributes of an object?</h3> <p>For an instance <code>x</code> of a user-defined class, <a class="reference internal" href="../library/functions.html#dir" title="dir"><code>dir(x)</code></a> returns an alphabetized list of the names containing the instance attributes and methods and attributes defined by its class.</p> </section> <section id="how-can-my-code-discover-the-name-of-an-object"> <h3>How can my code discover the name of an object?</h3> <p>Generally speaking, it can’t, because objects don’t really have names. Essentially, assignment always binds a name to a value; the same is true of <code>def</code> and <code>class</code> statements, but in that case the value is a callable. Consider the following code:</p> <pre data-language="python">&gt;&gt;&gt; class A:
...     pass
...
&gt;&gt;&gt; B = A
&gt;&gt;&gt; a = B()
&gt;&gt;&gt; b = a
&gt;&gt;&gt; print(b)
&lt;__main__.A object at 0x16D07CC&gt;
&gt;&gt;&gt; print(a)
&lt;__main__.A object at 0x16D07CC&gt;
</pre> <p>Arguably the class has a name: even though it is bound to two names and invoked through the name <code>B</code> the created instance is still reported as an instance of class <code>A</code>. However, it is impossible to say whether the instance’s name is <code>a</code> or <code>b</code>, since both names are bound to the same value.</p> <p>Generally speaking it should not be necessary for your code to “know the names” of particular values. Unless you are deliberately writing introspective programs, this is usually an indication that a change of approach might be beneficial.</p> <p>In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer to this question:</p>  <p>The same way as you get the name of that cat you found on your porch: the cat (object) itself cannot tell you its name, and it doesn’t really care – so the only way to find out what it’s called is to ask all your neighbours (namespaces) if it’s their cat (object)…</p> <p>….and don’t be surprised if you’ll find that it’s known by many names, or no name at all!</p>  </section> <section id="what-s-up-with-the-comma-operator-s-precedence"> <h3>What’s up with the comma operator’s precedence?</h3> <p>Comma is not an operator in Python. Consider this session:</p> <pre data-language="python">&gt;&gt;&gt; "a" in "b", "a"
(False, 'a')
</pre> <p>Since the comma is not an operator, but a separator between expressions the above is evaluated as if you had entered:</p> <pre data-language="python">("a" in "b"), "a"
</pre> <p>not:</p> <pre data-language="python">"a" in ("b", "a")
</pre> <p>The same is true of the various assignment operators (<code>=</code>, <code>+=</code> etc). They are not truly operators but syntactic delimiters in assignment statements.</p> </section> <section id="is-there-an-equivalent-of-c-s-ternary-operator"> <h3>Is there an equivalent of C’s “?:” ternary operator?</h3> <p>Yes, there is. The syntax is as follows:</p> <pre data-language="python">[on_true] if [expression] else [on_false]

x, y = 50, 25
small = x if x &lt; y else y
</pre> <p>Before this syntax was introduced in Python 2.5, a common idiom was to use logical operators:</p> <pre data-language="python">[expression] and [on_true] or [on_false]
</pre> <p>However, this idiom is unsafe, as it can give wrong results when <em>on_true</em> has a false boolean value. Therefore, it is always better to use the <code>... if ... else ...</code> form.</p> </section> <section id="is-it-possible-to-write-obfuscated-one-liners-in-python"> <h3>Is it possible to write obfuscated one-liners in Python?</h3> <p>Yes. Usually this is done by nesting <a class="reference internal" href="../reference/expressions.html#lambda"><code>lambda</code></a> within <code>lambda</code>. See the following three examples, slightly adapted from Ulf Bartelt:</p> <pre data-language="python">from functools import reduce

# Primes &lt; 1000
print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,
map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))

# First 10 Fibonacci numbers
print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x&gt;1 else 1:
f(x,f), range(10))))

# Mandelbrot set
print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\n'+y,map(lambda y,
Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,
Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,
i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k&lt;=0)or (x*x+y*y
&gt;=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(
64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy
))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))
#    \___ ___/  \___ ___/  |   |   |__ lines on screen
#        V          V      |   |______ columns on screen
#        |          |      |__________ maximum of "iterations"
#        |          |_________________ range on y axis
#        |____________________________ range on x axis
</pre> <p>Don’t try this at home, kids!</p> </section> <section id="what-does-the-slash-in-the-parameter-list-of-a-function-mean"> <span id="faq-positional-only-arguments"></span><h3>What does the slash(/) in the parameter list of a function mean?</h3> <p>A slash in the argument list of a function denotes that the parameters prior to it are positional-only. Positional-only parameters are the ones without an externally usable name. Upon calling a function that accepts positional-only parameters, arguments are mapped to parameters based solely on their position. For example, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code>divmod()</code></a> is a function that accepts positional-only parameters. Its documentation looks like this:</p> <pre data-language="python">&gt;&gt;&gt; help(divmod)
Help on built-in function divmod in module builtins:

divmod(x, y, /)
    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.
</pre> <p>The slash at the end of the parameter list means that both parameters are positional-only. Thus, calling <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code>divmod()</code></a> with keyword arguments would lead to an error:</p> <pre data-language="python">&gt;&gt;&gt; divmod(x=3, y=4)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: divmod() takes no keyword arguments
</pre> </section> </section> <section id="numbers-and-strings"> <h2>Numbers and strings</h2> <section id="how-do-i-specify-hexadecimal-and-octal-integers"> <h3>How do I specify hexadecimal and octal integers?</h3> <p>To specify an octal digit, precede the octal value with a zero, and then a lower or uppercase “o”. For example, to set the variable “a” to the octal value “10” (8 in decimal), type:</p> <pre data-language="python">&gt;&gt;&gt; a = 0o10
&gt;&gt;&gt; a
8
</pre> <p>Hexadecimal is just as easy. Simply precede the hexadecimal number with a zero, and then a lower or uppercase “x”. Hexadecimal digits can be specified in lower or uppercase. For example, in the Python interpreter:</p> <pre data-language="python">&gt;&gt;&gt; a = 0xa5
&gt;&gt;&gt; a
165
&gt;&gt;&gt; b = 0XB2
&gt;&gt;&gt; b
178
</pre> </section> <section id="why-does-22-10-return-3"> <h3>Why does -22 // 10 return -3?</h3> <p>It’s primarily driven by the desire that <code>i % j</code> have the same sign as <code>j</code>. If you want that, and also want:</p> <pre data-language="python">i == (i // j) * j + (i % j)
</pre> <p>then integer division has to return the floor. C also requires that identity to hold, and then compilers that truncate <code>i // j</code> need to make <code>i % j</code> have the same sign as <code>i</code>.</p> <p>There are few real use cases for <code>i % j</code> when <code>j</code> is negative. When <code>j</code> is positive, there are many, and in virtually all of them it’s more useful for <code>i % j</code> to be <code>&gt;= 0</code>. If the clock says 10 now, what did it say 200 hours ago? <code>-190 % 12 == 2</code> is useful; <code>-190 % 12 == -10</code> is a bug waiting to bite.</p> </section> <section id="how-do-i-get-int-literal-attribute-instead-of-syntaxerror"> <h3>How do I get int literal attribute instead of SyntaxError?</h3> <p>Trying to lookup an <code>int</code> literal attribute in the normal manner gives a <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a> because the period is seen as a decimal point:</p> <pre data-language="python">&gt;&gt;&gt; 1.__class__
  File "&lt;stdin&gt;", line 1
  1.__class__
   ^
SyntaxError: invalid decimal literal
</pre> <p>The solution is to separate the literal from the period with either a space or parentheses.</p> <pre data-language="python">&gt;&gt;&gt; 1 .__class__
&lt;class 'int'&gt;
&gt;&gt;&gt; (1).__class__
&lt;class 'int'&gt;
</pre> </section> <section id="how-do-i-convert-a-string-to-a-number"> <h3>How do I convert a string to a number?</h3> <p>For integers, use the built-in <a class="reference internal" href="../library/functions.html#int" title="int"><code>int()</code></a> type constructor, e.g. <code>int('144')
== 144</code>. Similarly, <a class="reference internal" href="../library/functions.html#float" title="float"><code>float()</code></a> converts to floating-point, e.g. <code>float('144') == 144.0</code>.</p> <p>By default, these interpret the number as decimal, so that <code>int('0144') ==
144</code> holds true, and <code>int('0x144')</code> raises <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>. <code>int(string,
base)</code> takes the base to convert from as a second optional argument, so <code>int(
'0x144', 16) == 324</code>. If the base is specified as 0, the number is interpreted using Python’s rules: a leading ‘0o’ indicates octal, and ‘0x’ indicates a hex number.</p> <p>Do not use the built-in function <a class="reference internal" href="../library/functions.html#eval" title="eval"><code>eval()</code></a> if all you need is to convert strings to numbers. <a class="reference internal" href="../library/functions.html#eval" title="eval"><code>eval()</code></a> will be significantly slower and it presents a security risk: someone could pass you a Python expression that might have unwanted side effects. For example, someone could pass <code>__import__('os').system("rm -rf $HOME")</code> which would erase your home directory.</p> <p><a class="reference internal" href="../library/functions.html#eval" title="eval"><code>eval()</code></a> also has the effect of interpreting numbers as Python expressions, so that e.g. <code>eval('09')</code> gives a syntax error because Python does not allow leading ‘0’ in a decimal number (except ‘0’).</p> </section> <section id="how-do-i-convert-a-number-to-a-string"> <h3>How do I convert a number to a string?</h3> <p>To convert, e.g., the number <code>144</code> to the string <code>'144'</code>, use the built-in type constructor <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str()</code></a>. If you want a hexadecimal or octal representation, use the built-in functions <a class="reference internal" href="../library/functions.html#hex" title="hex"><code>hex()</code></a> or <a class="reference internal" href="../library/functions.html#oct" title="oct"><code>oct()</code></a>. For fancy formatting, see the <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">f-strings</span></a> and <a class="reference internal" href="../library/string.html#formatstrings"><span class="std std-ref">Format String Syntax</span></a> sections, e.g. <code>"{:04d}".format(144)</code> yields <code>'0144'</code> and <code>"{:.3f}".format(1.0/3.0)</code> yields <code>'0.333'</code>.</p> </section> <section id="how-do-i-modify-a-string-in-place"> <h3>How do I modify a string in place?</h3> <p>You can’t, because strings are immutable. In most situations, you should simply construct a new string from the various parts you want to assemble it from. However, if you need an object with the ability to modify in-place unicode data, try using an <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code>io.StringIO</code></a> object or the <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code>array</code></a> module:</p> <pre data-language="python">&gt;&gt;&gt; import io
&gt;&gt;&gt; s = "Hello, world"
&gt;&gt;&gt; sio = io.StringIO(s)
&gt;&gt;&gt; sio.getvalue()
'Hello, world'
&gt;&gt;&gt; sio.seek(7)
7
&gt;&gt;&gt; sio.write("there!")
6
&gt;&gt;&gt; sio.getvalue()
'Hello, there!'

&gt;&gt;&gt; import array
&gt;&gt;&gt; a = array.array('u', s)
&gt;&gt;&gt; print(a)
array('u', 'Hello, world')
&gt;&gt;&gt; a[0] = 'y'
&gt;&gt;&gt; print(a)
array('u', 'yello, world')
&gt;&gt;&gt; a.tounicode()
'yello, world'
</pre> </section> <section id="how-do-i-use-strings-to-call-functions-methods"> <h3>How do I use strings to call functions/methods?</h3> <p>There are various techniques.</p> <ul> <li>
<p>The best is to use a dictionary that maps strings to functions. The primary advantage of this technique is that the strings do not need to match the names of the functions. This is also the primary technique used to emulate a case construct:</p> <pre data-language="python">def a():
    pass

def b():
    pass

dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs

dispatch[get_input()]()  # Note trailing parens to call function
</pre> </li> <li>
<p>Use the built-in function <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code>getattr()</code></a>:</p> <pre data-language="python">import foo
getattr(foo, 'bar')()
</pre> <p>Note that <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code>getattr()</code></a> works on any object, including classes, class instances, modules, and so on.</p> <p>This is used in several places in the standard library, like this:</p> <pre data-language="python">class Foo:
    def do_foo(self):
        ...

    def do_bar(self):
        ...

f = getattr(foo_instance, 'do_' + opname)
f()
</pre> </li> <li>
<p>Use <a class="reference internal" href="../library/functions.html#locals" title="locals"><code>locals()</code></a> to resolve the function name:</p> <pre data-language="python">def myFunc():
    print("hello")

fname = "myFunc"

f = locals()[fname]
f()
</pre> </li> </ul> </section> <section id="is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings"> <h3>Is there an equivalent to Perl’s chomp() for removing trailing newlines from strings?</h3> <p>You can use <code>S.rstrip("\r\n")</code> to remove all occurrences of any line terminator from the end of the string <code>S</code> without removing other trailing whitespace. If the string <code>S</code> represents more than one line, with several empty lines at the end, the line terminators for all the blank lines will be removed:</p> <pre data-language="python">&gt;&gt;&gt; lines = ("line 1 \r\n"
...          "\r\n"
...          "\r\n")
&gt;&gt;&gt; lines.rstrip("\n\r")
'line 1 '
</pre> <p>Since this is typically only desired when reading text one line at a time, using <code>S.rstrip()</code> this way works well.</p> </section> <section id="is-there-a-scanf-or-sscanf-equivalent"> <h3>Is there a scanf() or sscanf() equivalent?</h3> <p>Not as such.</p> <p>For simple input parsing, the easiest approach is usually to split the line into whitespace-delimited words using the <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code>split()</code></a> method of string objects and then convert decimal strings to numeric values using <a class="reference internal" href="../library/functions.html#int" title="int"><code>int()</code></a> or <a class="reference internal" href="../library/functions.html#float" title="float"><code>float()</code></a>. <code>split()</code> supports an optional “sep” parameter which is useful if the line uses something other than whitespace as a separator.</p> <p>For more complicated input parsing, regular expressions are more powerful than C’s <code>sscanf</code> and better suited for the task.</p> </section> <section id="what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean"> <h3>What does ‘UnicodeDecodeError’ or ‘UnicodeEncodeError’ error mean?</h3> <p>See the <a class="reference internal" href="../howto/unicode.html#unicode-howto"><span class="std std-ref">Unicode HOWTO</span></a>.</p> </section> <section id="can-i-end-a-raw-string-with-an-odd-number-of-backslashes"> <span id="faq-programming-raw-string-backslash"></span><h3>Can I end a raw string with an odd number of backslashes?</h3> <p>A raw string ending with an odd number of backslashes will escape the string’s quote:</p> <pre data-language="python">&gt;&gt;&gt; r'C:\this\will\not\work\'
  File "&lt;stdin&gt;", line 1
    r'C:\this\will\not\work\'
         ^
SyntaxError: unterminated string literal (detected at line 1)
</pre> <p>There are several workarounds for this. One is to use regular strings and double the backslashes:</p> <pre data-language="python">&gt;&gt;&gt; 'C:\\this\\will\\work\\'
'C:\\this\\will\\work\\'
</pre> <p>Another is to concatenate a regular string containing an escaped backslash to the raw string:</p> <pre data-language="python">&gt;&gt;&gt; r'C:\this\will\work' '\\'
'C:\\this\\will\\work\\'
</pre> <p>It is also possible to use <a class="reference internal" href="../library/os.path.html#os.path.join" title="os.path.join"><code>os.path.join()</code></a> to append a backslash on Windows:</p> <pre data-language="python">&gt;&gt;&gt; os.path.join(r'C:\this\will\work', '')
'C:\\this\\will\\work\\'
</pre> <p>Note that while a backslash will “escape” a quote for the purposes of determining where the raw string ends, no escaping occurs when interpreting the value of the raw string. That is, the backslash remains present in the value of the raw string:</p> <pre data-language="python">&gt;&gt;&gt; r'backslash\'preserved'
"backslash\\'preserved"
</pre> <p>Also see the specification in the <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">language reference</span></a>.</p> </section> </section> <section id="performance"> <h2>Performance</h2> <section id="my-program-is-too-slow-how-do-i-speed-it-up"> <h3>My program is too slow. How do I speed it up?</h3> <p>That’s a tough one, in general. First, here are a list of things to remember before diving further:</p> <ul class="simple"> <li>Performance characteristics vary across Python implementations. This FAQ focuses on <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a>.</li> <li>Behaviour can vary across operating systems, especially when talking about I/O or multi-threading.</li> <li>You should always find the hot spots in your program <em>before</em> attempting to optimize any code (see the <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code>profile</code></a> module).</li> <li>Writing benchmark scripts will allow you to iterate quickly when searching for improvements (see the <a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code>timeit</code></a> module).</li> <li>It is highly recommended to have good code coverage (through unit testing or any other technique) before potentially introducing regressions hidden in sophisticated optimizations.</li> </ul> <p>That being said, there are many tricks to speed up Python code. Here are some general principles which go a long way towards reaching acceptable performance levels:</p> <ul class="simple"> <li>Making your algorithms faster (or changing to faster ones) can yield much larger benefits than trying to sprinkle micro-optimization tricks all over your code.</li> <li>Use the right data structures. Study documentation for the <a class="reference internal" href="../library/stdtypes.html#bltin-types"><span class="std std-ref">Built-in Types</span></a> and the <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code>collections</code></a> module.</li> <li>When the standard library provides a primitive for doing something, it is likely (although not guaranteed) to be faster than any alternative you may come up with. This is doubly true for primitives written in C, such as builtins and some extension types. For example, be sure to use either the <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code>list.sort()</code></a> built-in method or the related <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code>sorted()</code></a> function to do sorting (and see the <a class="reference internal" href="../howto/sorting.html#sortinghowto"><span class="std std-ref">Sorting HOW TO</span></a> for examples of moderately advanced usage).</li> <li>Abstractions tend to create indirections and force the interpreter to work more. If the levels of indirection outweigh the amount of useful work done, your program will be slower. You should avoid excessive abstraction, especially under the form of tiny functions or methods (which are also often detrimental to readability).</li> </ul> <p>If you have reached the limit of what pure Python can allow, there are tools to take you further away. For example, <a class="reference external" href="https://cython.org">Cython</a> can compile a slightly modified version of Python code into a C extension, and can be used on many different platforms. Cython can take advantage of compilation (and optional type annotations) to make your code significantly faster than when interpreted. If you are confident in your C programming skills, you can also <a class="reference internal" href="../extending/index.html#extending-index"><span class="std std-ref">write a C extension module</span></a> yourself.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The wiki page devoted to <a class="reference external" href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips">performance tips</a>.</p> </div> </section> <section id="what-is-the-most-efficient-way-to-concatenate-many-strings-together"> <span id="efficient-string-concatenation"></span><h3>What is the most efficient way to concatenate many strings together?</h3> <p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> and <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> objects are immutable, therefore concatenating many strings together is inefficient as each concatenation creates a new object. In the general case, the total runtime cost is quadratic in the total string length.</p> <p>To accumulate many <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> objects, the recommended idiom is to place them into a list and call <a class="reference internal" href="../library/stdtypes.html#str.join" title="str.join"><code>str.join()</code></a> at the end:</p> <pre data-language="python">chunks = []
for s in my_strings:
    chunks.append(s)
result = ''.join(chunks)
</pre> <p>(another reasonably efficient idiom is to use <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code>io.StringIO</code></a>)</p> <p>To accumulate many <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> objects, the recommended idiom is to extend a <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> object using in-place concatenation (the <code>+=</code> operator):</p> <pre data-language="python">result = bytearray()
for b in my_bytes_objects:
    result += b
</pre> </section> </section> <section id="sequences-tuples-lists"> <h2>Sequences (Tuples/Lists)</h2> <section id="how-do-i-convert-between-tuples-and-lists"> <h3>How do I convert between tuples and lists?</h3> <p>The type constructor <code>tuple(seq)</code> converts any sequence (actually, any iterable) into a tuple with the same items in the same order.</p> <p>For example, <code>tuple([1, 2, 3])</code> yields <code>(1, 2, 3)</code> and <code>tuple('abc')</code> yields <code>('a', 'b', 'c')</code>. If the argument is a tuple, it does not make a copy but returns the same object, so it is cheap to call <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code>tuple()</code></a> when you aren’t sure that an object is already a tuple.</p> <p>The type constructor <code>list(seq)</code> converts any sequence or iterable into a list with the same items in the same order. For example, <code>list((1, 2, 3))</code> yields <code>[1, 2, 3]</code> and <code>list('abc')</code> yields <code>['a', 'b', 'c']</code>. If the argument is a list, it makes a copy just like <code>seq[:]</code> would.</p> </section> <section id="what-s-a-negative-index"> <h3>What’s a negative index?</h3> <p>Python sequences are indexed with positive numbers and negative numbers. For positive numbers 0 is the first index 1 is the second index and so forth. For negative indices -1 is the last index and -2 is the penultimate (next to last) index and so forth. Think of <code>seq[-n]</code> as the same as <code>seq[len(seq)-n]</code>.</p> <p>Using negative indices can be very convenient. For example <code>S[:-1]</code> is all of the string except for its last character, which is useful for removing the trailing newline from a string.</p> </section> <section id="how-do-i-iterate-over-a-sequence-in-reverse-order"> <h3>How do I iterate over a sequence in reverse order?</h3> <p>Use the <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code>reversed()</code></a> built-in function:</p> <pre data-language="python">for x in reversed(sequence):
    ...  # do something with x ...
</pre> <p>This won’t touch your original sequence, but build a new copy with reversed order to iterate over.</p> </section> <section id="how-do-you-remove-duplicates-from-a-list"> <h3>How do you remove duplicates from a list?</h3> <p>See the Python Cookbook for a long discussion of many ways to do this:</p>  <p><a class="reference external" href="https://code.activestate.com/recipes/52560/">https://code.activestate.com/recipes/52560/</a></p>  <p>If you don’t mind reordering the list, sort it and then scan from the end of the list, deleting duplicates as you go:</p> <pre data-language="python">if mylist:
    mylist.sort()
    last = mylist[-1]
    for i in range(len(mylist)-2, -1, -1):
        if last == mylist[i]:
            del mylist[i]
        else:
            last = mylist[i]
</pre> <p>If all elements of the list may be used as set keys (i.e. they are all <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) this is often faster</p> <pre data-language="python">mylist = list(set(mylist))
</pre> <p>This converts the list into a set, thereby removing duplicates, and then back into a list.</p> </section> <section id="how-do-you-remove-multiple-items-from-a-list"> <h3>How do you remove multiple items from a list</h3> <p>As with removing duplicates, explicitly iterating in reverse with a delete condition is one possibility. However, it is easier and faster to use slice replacement with an implicit or explicit forward iteration. Here are three variations.:</p> <pre data-language="python">mylist[:] = filter(keep_function, mylist)
mylist[:] = (x for x in mylist if keep_condition)
mylist[:] = [x for x in mylist if keep_condition]
</pre> <p>The list comprehension may be fastest.</p> </section> <section id="how-do-you-make-an-array-in-python"> <h3>How do you make an array in Python?</h3> <p>Use a list:</p> <pre data-language="python">["this", 1, "is", "an", "array"]
</pre> <p>Lists are equivalent to C or Pascal arrays in their time complexity; the primary difference is that a Python list can contain objects of many different types.</p> <p>The <code>array</code> module also provides methods for creating arrays of fixed types with compact representations, but they are slower to index than lists. Also note that <a class="reference external" href="https://numpy.org/">NumPy</a> and other third party packages define array-like structures with various characteristics as well.</p> <p>To get Lisp-style linked lists, you can emulate <em>cons cells</em> using tuples:</p> <pre data-language="python">lisp_list = ("like",  ("this",  ("example", None) ) )
</pre> <p>If mutability is desired, you could use lists instead of tuples. Here the analogue of a Lisp <em>car</em> is <code>lisp_list[0]</code> and the analogue of <em>cdr</em> is <code>lisp_list[1]</code>. Only do this if you’re sure you really need to, because it’s usually a lot slower than using Python lists.</p> </section> <section id="how-do-i-create-a-multidimensional-list"> <span id="faq-multidimensional-list"></span><h3>How do I create a multidimensional list?</h3> <p>You probably tried to make a multidimensional array like this:</p> <pre data-language="python">&gt;&gt;&gt; A = [[None] * 2] * 3
</pre> <p>This looks correct if you print it:</p> <pre data-language="pycon3">&gt;&gt;&gt; A
[[None, None], [None, None], [None, None]]
</pre> <p>But when you assign a value, it shows up in multiple places:</p> <pre data-language="pycon3">&gt;&gt;&gt; A[0][0] = 5
&gt;&gt;&gt; A
[[5, None], [5, None], [5, None]]
</pre> <p>The reason is that replicating a list with <code>*</code> doesn’t create copies, it only creates references to the existing objects. The <code>*3</code> creates a list containing 3 references to the same list of length two. Changes to one row will show in all rows, which is almost certainly not what you want.</p> <p>The suggested approach is to create a list of the desired length first and then fill in each element with a newly created list:</p> <pre data-language="python">A = [None] * 3
for i in range(3):
    A[i] = [None] * 2
</pre> <p>This generates a list containing 3 different lists of length two. You can also use a list comprehension:</p> <pre data-language="python">w, h = 2, 3
A = [[None] * w for i in range(h)]
</pre> <p>Or, you can use an extension that provides a matrix datatype; <a class="reference external" href="https://numpy.org/">NumPy</a> is the best known.</p> </section> <section id="how-do-i-apply-a-method-or-function-to-a-sequence-of-objects"> <h3>How do I apply a method or function to a sequence of objects?</h3> <p>To call a method or function and accumulate the return values is a list, a <a class="reference internal" href="../glossary.html#term-list-comprehension"><span class="xref std std-term">list comprehension</span></a> is an elegant solution:</p> <pre data-language="python">result = [obj.method() for obj in mylist]

result = [function(obj) for obj in mylist]
</pre> <p>To just run the method or function without saving the return values, a plain <a class="reference internal" href="../reference/compound_stmts.html#for"><code>for</code></a> loop will suffice:</p> <pre data-language="python">for obj in mylist:
    obj.method()

for obj in mylist:
    function(obj)
</pre> </section> <section id="why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works"> <span id="faq-augmented-assignment-tuple-error"></span><h3>Why does a_tuple[i] += [‘item’] raise an exception when the addition works?</h3> <p>This is because of a combination of the fact that augmented assignment operators are <em>assignment</em> operators, and the difference between mutable and immutable objects in Python.</p> <p>This discussion applies in general when augmented assignment operators are applied to elements of a tuple that point to mutable objects, but we’ll use a <code>list</code> and <code>+=</code> as our exemplar.</p> <p>If you wrote:</p> <pre data-language="python">&gt;&gt;&gt; a_tuple = (1, 2)
&gt;&gt;&gt; a_tuple[0] += 1
Traceback (most recent call last):
   ...
TypeError: 'tuple' object does not support item assignment
</pre> <p>The reason for the exception should be immediately clear: <code>1</code> is added to the object <code>a_tuple[0]</code> points to (<code>1</code>), producing the result object, <code>2</code>, but when we attempt to assign the result of the computation, <code>2</code>, to element <code>0</code> of the tuple, we get an error because we can’t change what an element of a tuple points to.</p> <p>Under the covers, what this augmented assignment statement is doing is approximately this:</p> <pre data-language="python">&gt;&gt;&gt; result = a_tuple[0] + 1
&gt;&gt;&gt; a_tuple[0] = result
Traceback (most recent call last):
  ...
TypeError: 'tuple' object does not support item assignment
</pre> <p>It is the assignment part of the operation that produces the error, since a tuple is immutable.</p> <p>When you write something like:</p> <pre data-language="python">&gt;&gt;&gt; a_tuple = (['foo'], 'bar')
&gt;&gt;&gt; a_tuple[0] += ['item']
Traceback (most recent call last):
  ...
TypeError: 'tuple' object does not support item assignment
</pre> <p>The exception is a bit more surprising, and even more surprising is the fact that even though there was an error, the append worked:</p> <pre data-language="python">&gt;&gt;&gt; a_tuple[0]
['foo', 'item']
</pre> <p>To see why this happens, you need to know that (a) if an object implements an <a class="reference internal" href="../reference/datamodel.html#object.__iadd__" title="object.__iadd__"><code>__iadd__()</code></a> magic method, it gets called when the <code>+=</code> augmented assignment is executed, and its return value is what gets used in the assignment statement; and (b) for lists, <code>__iadd__()</code> is equivalent to calling <code>extend()</code> on the list and returning the list. That’s why we say that for lists, <code>+=</code> is a “shorthand” for <code>list.extend()</code>:</p> <pre data-language="python">&gt;&gt;&gt; a_list = []
&gt;&gt;&gt; a_list += [1]
&gt;&gt;&gt; a_list
[1]
</pre> <p>This is equivalent to:</p> <pre data-language="python">&gt;&gt;&gt; result = a_list.__iadd__([1])
&gt;&gt;&gt; a_list = result
</pre> <p>The object pointed to by a_list has been mutated, and the pointer to the mutated object is assigned back to <code>a_list</code>. The end result of the assignment is a no-op, since it is a pointer to the same object that <code>a_list</code> was previously pointing to, but the assignment still happens.</p> <p>Thus, in our tuple example what is happening is equivalent to:</p> <pre data-language="python">&gt;&gt;&gt; result = a_tuple[0].__iadd__(['item'])
&gt;&gt;&gt; a_tuple[0] = result
Traceback (most recent call last):
  ...
TypeError: 'tuple' object does not support item assignment
</pre> <p>The <code>__iadd__()</code> succeeds, and thus the list is extended, but even though <code>result</code> points to the same object that <code>a_tuple[0]</code> already points to, that final assignment still results in an error, because tuples are immutable.</p> </section> <section id="i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python"> <h3>I want to do a complicated sort: can you do a Schwartzian Transform in Python?</h3> <p>The technique, attributed to Randal Schwartz of the Perl community, sorts the elements of a list by a metric which maps each element to its “sort value”. In Python, use the <code>key</code> argument for the <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code>list.sort()</code></a> method:</p> <pre data-language="python">Isorted = L[:]
Isorted.sort(key=lambda s: int(s[10:15]))
</pre> </section> <section id="how-can-i-sort-one-list-by-values-from-another-list"> <h3>How can I sort one list by values from another list?</h3> <p>Merge them into an iterator of tuples, sort the resulting list, and then pick out the element you want.</p> <pre data-language="python">&gt;&gt;&gt; list1 = ["what", "I'm", "sorting", "by"]
&gt;&gt;&gt; list2 = ["something", "else", "to", "sort"]
&gt;&gt;&gt; pairs = zip(list1, list2)
&gt;&gt;&gt; pairs = sorted(pairs)
&gt;&gt;&gt; pairs
[("I'm", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]
&gt;&gt;&gt; result = [x[1] for x in pairs]
&gt;&gt;&gt; result
['else', 'sort', 'to', 'something']
</pre> </section> </section> <section id="objects"> <h2>Objects</h2> <section id="what-is-a-class"> <h3>What is a class?</h3> <p>A class is the particular object type created by executing a class statement. Class objects are used as templates to create instance objects, which embody both the data (attributes) and code (methods) specific to a datatype.</p> <p>A class can be based on one or more other classes, called its base class(es). It then inherits the attributes and methods of its base classes. This allows an object model to be successively refined by inheritance. You might have a generic <code>Mailbox</code> class that provides basic accessor methods for a mailbox, and subclasses such as <code>MboxMailbox</code>, <code>MaildirMailbox</code>, <code>OutlookMailbox</code> that handle various specific mailbox formats.</p> </section> <section id="what-is-a-method"> <h3>What is a method?</h3> <p>A method is a function on some object <code>x</code> that you normally call as <code>x.name(arguments...)</code>. Methods are defined as functions inside the class definition:</p> <pre data-language="python">class C:
    def meth(self, arg):
        return arg * 2 + self.attribute
</pre> </section> <section id="what-is-self"> <h3>What is self?</h3> <p>Self is merely a conventional name for the first argument of a method. A method defined as <code>meth(self, a, b, c)</code> should be called as <code>x.meth(a, b, c)</code> for some instance <code>x</code> of the class in which the definition occurs; the called method will think it is called as <code>meth(x, a, b, c)</code>.</p> <p>See also <a class="reference internal" href="design.html#why-self"><span class="std std-ref">Why must ‘self’ be used explicitly in method definitions and calls?</span></a>.</p> </section> <section id="how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it"> <h3>How do I check if an object is an instance of a given class or of a subclass of it?</h3> <p>Use the built-in function <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code>isinstance(obj, cls)</code></a>. You can check if an object is an instance of any of a number of classes by providing a tuple instead of a single class, e.g. <code>isinstance(obj, (class1, class2, ...))</code>, and can also check whether an object is one of Python’s built-in types, e.g. <code>isinstance(obj, str)</code> or <code>isinstance(obj, (int, float, complex))</code>.</p> <p>Note that <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> also checks for virtual inheritance from an <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>. So, the test will return <code>True</code> for a registered class even if hasn’t directly or indirectly inherited from it. To test for “true inheritance”, scan the <a class="reference internal" href="../glossary.html#term-MRO"><span class="xref std std-term">MRO</span></a> of the class:</p> <pre data-language="python">from collections.abc import Mapping

class P:
     pass

class C(P):
    pass

Mapping.register(P)
</pre> <pre data-language="pycon3">&gt;&gt;&gt; c = C()
&gt;&gt;&gt; isinstance(c, C)        # direct
True
&gt;&gt;&gt; isinstance(c, P)        # indirect
True
&gt;&gt;&gt; isinstance(c, Mapping)  # virtual
True

# Actual inheritance chain
&gt;&gt;&gt; type(c).__mro__
(&lt;class 'C'&gt;, &lt;class 'P'&gt;, &lt;class 'object'&gt;)

# Test for "true inheritance"
&gt;&gt;&gt; Mapping in type(c).__mro__
False
</pre> <p>Note that most programs do not use <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> on user-defined classes very often. If you are developing the classes yourself, a more proper object-oriented style is to define methods on the classes that encapsulate a particular behaviour, instead of checking the object’s class and doing a different thing based on what class it is. For example, if you have a function that does something:</p> <pre data-language="python">def search(obj):
    if isinstance(obj, Mailbox):
        ...  # code to search a mailbox
    elif isinstance(obj, Document):
        ...  # code to search a document
    elif ...
</pre> <p>A better approach is to define a <code>search()</code> method on all the classes and just call it:</p> <pre data-language="python">class Mailbox:
    def search(self):
        ...  # code to search a mailbox

class Document:
    def search(self):
        ...  # code to search a document

obj.search()
</pre> </section> <section id="what-is-delegation"> <h3>What is delegation?</h3> <p>Delegation is an object oriented technique (also called a design pattern). Let’s say you have an object <code>x</code> and want to change the behaviour of just one of its methods. You can create a new class that provides a new implementation of the method you’re interested in changing and delegates all other methods to the corresponding method of <code>x</code>.</p> <p>Python programmers can easily implement delegation. For example, the following class implements a class that behaves like a file but converts all written data to uppercase:</p> <pre data-language="python">class UpperOut:

    def __init__(self, outfile):
        self._outfile = outfile

    def write(self, s):
        self._outfile.write(s.upper())

    def __getattr__(self, name):
        return getattr(self._outfile, name)
</pre> <p>Here the <code>UpperOut</code> class redefines the <code>write()</code> method to convert the argument string to uppercase before calling the underlying <code>self._outfile.write()</code> method. All other methods are delegated to the underlying <code>self._outfile</code> object. The delegation is accomplished via the <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code>__getattr__()</code></a> method; consult <a class="reference internal" href="../reference/datamodel.html#attribute-access"><span class="std std-ref">the language reference</span></a> for more information about controlling attribute access.</p> <p>Note that for more general cases delegation can get trickier. When attributes must be set as well as retrieved, the class must define a <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code>__setattr__()</code></a> method too, and it must do so carefully. The basic implementation of <code>__setattr__()</code> is roughly equivalent to the following:</p> <pre data-language="python">class X:
    ...
    def __setattr__(self, name, value):
        self.__dict__[name] = value
    ...
</pre> <p>Most <code>__setattr__()</code> implementations must modify <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code>self.__dict__</code></a> to store local state for self without causing an infinite recursion.</p> </section> <section id="how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-extends-it"> <h3>How do I call a method defined in a base class from a derived class that extends it?</h3> <p>Use the built-in <a class="reference internal" href="../library/functions.html#super" title="super"><code>super()</code></a> function:</p> <pre data-language="python">class Derived(Base):
    def meth(self):
        super().meth()  # calls Base.meth
</pre> <p>In the example, <a class="reference internal" href="../library/functions.html#super" title="super"><code>super()</code></a> will automatically determine the instance from which it was called (the <code>self</code> value), look up the <a class="reference internal" href="../glossary.html#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a> (MRO) with <code>type(self).__mro__</code>, and return the next in line after <code>Derived</code> in the MRO: <code>Base</code>.</p> </section> <section id="how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class"> <h3>How can I organize my code to make it easier to change the base class?</h3> <p>You could assign the base class to an alias and derive from the alias. Then all you have to change is the value assigned to the alias. Incidentally, this trick is also handy if you want to decide dynamically (e.g. depending on availability of resources) which base class to use. Example:</p> <pre data-language="python">class Base:
    ...

BaseAlias = Base

class Derived(BaseAlias):
    ...
</pre> </section> <section id="how-do-i-create-static-class-data-and-static-class-methods"> <h3>How do I create static class data and static class methods?</h3> <p>Both static data and static methods (in the sense of C++ or Java) are supported in Python.</p> <p>For static data, simply define a class attribute. To assign a new value to the attribute, you have to explicitly use the class name in the assignment:</p> <pre data-language="python">class C:
    count = 0   # number of times C.__init__ called

    def __init__(self):
        C.count = C.count + 1

    def getcount(self):
        return C.count  # or return self.count
</pre> <p><code>c.count</code> also refers to <code>C.count</code> for any <code>c</code> such that <code>isinstance(c,
C)</code> holds, unless overridden by <code>c</code> itself or by some class on the base-class search path from <code>c.__class__</code> back to <code>C</code>.</p> <p>Caution: within a method of C, an assignment like <code>self.count = 42</code> creates a new and unrelated instance named “count” in <code>self</code>’s own dict. Rebinding of a class-static data name must always specify the class whether inside a method or not:</p> <pre data-language="python">C.count = 314
</pre> <p>Static methods are possible:</p> <pre data-language="python">class C:
    @staticmethod
    def static(arg1, arg2, arg3):
        # No 'self' parameter!
        ...
</pre> <p>However, a far more straightforward way to get the effect of a static method is via a simple module-level function:</p> <pre data-language="python">def getcount():
    return C.count
</pre> <p>If your code is structured so as to define one class (or tightly related class hierarchy) per module, this supplies the desired encapsulation.</p> </section> <section id="how-can-i-overload-constructors-or-methods-in-python"> <h3>How can I overload constructors (or methods) in Python?</h3> <p>This answer actually applies to all methods, but the question usually comes up first in the context of constructors.</p> <p>In C++ you’d write</p> <pre data-language="c">class C {
    C() { cout &lt;&lt; "No arguments\n"; }
    C(int i) { cout &lt;&lt; "Argument is " &lt;&lt; i &lt;&lt; "\n"; }
}
</pre> <p>In Python you have to write a single constructor that catches all cases using default arguments. For example:</p> <pre data-language="python">class C:
    def __init__(self, i=None):
        if i is None:
            print("No arguments")
        else:
            print("Argument is", i)
</pre> <p>This is not entirely equivalent, but close enough in practice.</p> <p>You could also try a variable-length argument list, e.g.</p> <pre data-language="python">def __init__(self, *args):
    ...
</pre> <p>The same approach works for all method definitions.</p> </section> <section id="i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam"> <h3>I try to use __spam and I get an error about _SomeClassName__spam.</h3> <p>Variable names with double leading underscores are “mangled” to provide a simple but effective way to define class private variables. Any identifier of the form <code>__spam</code> (at least two leading underscores, at most one trailing underscore) is textually replaced with <code>_classname__spam</code>, where <code>classname</code> is the current class name with any leading underscores stripped.</p> <p>This doesn’t guarantee privacy: an outside user can still deliberately access the “_classname__spam” attribute, and private values are visible in the object’s <code>__dict__</code>. Many Python programmers never bother to use private variable names at all.</p> </section> <section id="my-class-defines-del-but-it-is-not-called-when-i-delete-the-object"> <h3>My class defines __del__ but it is not called when I delete the object.</h3> <p>There are several possible reasons for this.</p> <p>The <a class="reference internal" href="../reference/simple_stmts.html#del"><code>del</code></a> statement does not necessarily call <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code>__del__()</code></a> – it simply decrements the object’s reference count, and if this reaches zero <code>__del__()</code> is called.</p> <p>If your data structures contain circular links (e.g. a tree where each child has a parent reference and each parent has a list of children) the reference counts will never go back to zero. Once in a while Python runs an algorithm to detect such cycles, but the garbage collector might run some time after the last reference to your data structure vanishes, so your <code>__del__()</code> method may be called at an inconvenient and random time. This is inconvenient if you’re trying to reproduce a problem. Worse, the order in which object’s <code>__del__()</code> methods are executed is arbitrary. You can run <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code>gc.collect()</code></a> to force a collection, but there <em>are</em> pathological cases where objects will never be collected.</p> <p>Despite the cycle collector, it’s still a good idea to define an explicit <code>close()</code> method on objects to be called whenever you’re done with them. The <code>close()</code> method can then remove attributes that refer to subobjects. Don’t call <code>__del__()</code> directly – <code>__del__()</code> should call <code>close()</code> and <code>close()</code> should make sure that it can be called more than once for the same object.</p> <p>Another way to avoid cyclical references is to use the <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code>weakref</code></a> module, which allows you to point to objects without incrementing their reference count. Tree data structures, for instance, should use weak references for their parent and sibling references (if they need them!).</p> <p>Finally, if your <code>__del__()</code> method raises an exception, a warning message is printed to <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code>sys.stderr</code></a>.</p> </section> <section id="how-do-i-get-a-list-of-all-instances-of-a-given-class"> <h3>How do I get a list of all instances of a given class?</h3> <p>Python does not keep track of all instances of a class (or of a built-in type). You can program the class’s constructor to keep track of all instances by keeping a list of weak references to each instance.</p> </section> <section id="why-does-the-result-of-id-appear-to-be-not-unique"> <h3>Why does the result of <code>id()</code> appear to be not unique?</h3> <p>The <a class="reference internal" href="../library/functions.html#id" title="id"><code>id()</code></a> builtin returns an integer that is guaranteed to be unique during the lifetime of the object. Since in CPython, this is the object’s memory address, it happens frequently that after an object is deleted from memory, the next freshly created object is allocated at the same position in memory. This is illustrated by this example:</p> <pre data-language="python">&gt;&gt;&gt; id(1000) 
13901272
&gt;&gt;&gt; id(2000) 
13901272
</pre> <p>The two ids belong to different integer objects that are created before, and deleted immediately after execution of the <code>id()</code> call. To be sure that objects whose id you want to examine are still alive, create another reference to the object:</p> <pre data-language="python">&gt;&gt;&gt; a = 1000; b = 2000
&gt;&gt;&gt; id(a) 
13901272
&gt;&gt;&gt; id(b) 
13891296
</pre> </section> <section id="when-can-i-rely-on-identity-tests-with-the-is-operator"> <h3>When can I rely on identity tests with the is operator?</h3> <p>The <code>is</code> operator tests for object identity. The test <code>a is b</code> is equivalent to <code>id(a) == id(b)</code>.</p> <p>The most important property of an identity test is that an object is always identical to itself, <code>a is a</code> always returns <code>True</code>. Identity tests are usually faster than equality tests. And unlike equality tests, identity tests are guaranteed to return a boolean <code>True</code> or <code>False</code>.</p> <p>However, identity tests can <em>only</em> be substituted for equality tests when object identity is assured. Generally, there are three circumstances where identity is guaranteed:</p> <p>1) Assignments create new names but do not change object identity. After the assignment <code>new = old</code>, it is guaranteed that <code>new is old</code>.</p> <p>2) Putting an object in a container that stores object references does not change object identity. After the list assignment <code>s[0] = x</code>, it is guaranteed that <code>s[0] is x</code>.</p> <p>3) If an object is a singleton, it means that only one instance of that object can exist. After the assignments <code>a = None</code> and <code>b = None</code>, it is guaranteed that <code>a is b</code> because <code>None</code> is a singleton.</p> <p>In most other circumstances, identity tests are inadvisable and equality tests are preferred. In particular, identity tests should not be used to check constants such as <a class="reference internal" href="../library/functions.html#int" title="int"><code>int</code></a> and <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code>str</code></a> which aren’t guaranteed to be singletons:</p> <pre data-language="python">&gt;&gt;&gt; a = 1000
&gt;&gt;&gt; b = 500
&gt;&gt;&gt; c = b + 500
&gt;&gt;&gt; a is c
False

&gt;&gt;&gt; a = 'Python'
&gt;&gt;&gt; b = 'Py'
&gt;&gt;&gt; c = b + 'thon'
&gt;&gt;&gt; a is c
False
</pre> <p>Likewise, new instances of mutable containers are never identical:</p> <pre data-language="python">&gt;&gt;&gt; a = []
&gt;&gt;&gt; b = []
&gt;&gt;&gt; a is b
False
</pre> <p>In the standard library code, you will see several common patterns for correctly using identity tests:</p> <p>1) As recommended by <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a>, an identity test is the preferred way to check for <code>None</code>. This reads like plain English in code and avoids confusion with other objects that may have boolean values that evaluate to false.</p> <p>2) Detecting optional arguments can be tricky when <code>None</code> is a valid input value. In those situations, you can create a singleton sentinel object guaranteed to be distinct from other objects. For example, here is how to implement a method that behaves like <a class="reference internal" href="../library/stdtypes.html#dict.pop" title="dict.pop"><code>dict.pop()</code></a>:</p> <pre data-language="python">_sentinel = object()

def pop(self, key, default=_sentinel):
    if key in self:
        value = self[key]
        del self[key]
        return value
    if default is _sentinel:
        raise KeyError(key)
    return default
</pre> <p>3) Container implementations sometimes need to augment equality tests with identity tests. This prevents the code from being confused by objects such as <code>float('NaN')</code> that are not equal to themselves.</p> <p>For example, here is the implementation of <code>collections.abc.Sequence.__contains__()</code>:</p> <pre data-language="python">def __contains__(self, value):
    for v in self:
        if v is value or v == value:
            return True
    return False
</pre> </section> <section id="how-can-a-subclass-control-what-data-is-stored-in-an-immutable-instance"> <h3>How can a subclass control what data is stored in an immutable instance?</h3> <p>When subclassing an immutable type, override the <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> method instead of the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> method. The latter only runs <em>after</em> an instance is created, which is too late to alter data in an immutable instance.</p> <p>All of these immutable classes have a different signature than their parent class:</p> <pre data-language="python">from datetime import date

class FirstOfMonthDate(date):
    "Always choose the first day of the month"
    def __new__(cls, year, month, day):
        return super().__new__(cls, year, month, 1)

class NamedInt(int):
    "Allow text names for some numbers"
    xlat = {'zero': 0, 'one': 1, 'ten': 10}
    def __new__(cls, value):
        value = cls.xlat.get(value, value)
        return super().__new__(cls, value)

class TitleStr(str):
    "Convert str to name suitable for a URL path"
    def __new__(cls, s):
        s = s.lower().replace(' ', '-')
        s = ''.join([c for c in s if c.isalnum() or c == '-'])
        return super().__new__(cls, s)
</pre> <p>The classes can be used like this:</p> <pre data-language="pycon3">&gt;&gt;&gt; FirstOfMonthDate(2012, 2, 14)
FirstOfMonthDate(2012, 2, 1)
&gt;&gt;&gt; NamedInt('ten')
10
&gt;&gt;&gt; NamedInt(20)
20
&gt;&gt;&gt; TitleStr('Blog: Why Python Rocks')
'blog-why-python-rocks'
</pre> </section> <section id="how-do-i-cache-method-calls"> <span id="faq-cache-method-calls"></span><h3>How do I cache method calls?</h3> <p>The two principal tools for caching methods are <a class="reference internal" href="../library/functools.html#functools.cached_property" title="functools.cached_property"><code>functools.cached_property()</code></a> and <a class="reference internal" href="../library/functools.html#functools.lru_cache" title="functools.lru_cache"><code>functools.lru_cache()</code></a>. The former stores results at the instance level and the latter at the class level.</p> <p>The <em>cached_property</em> approach only works with methods that do not take any arguments. It does not create a reference to the instance. The cached method result will be kept only as long as the instance is alive.</p> <p>The advantage is that when an instance is no longer used, the cached method result will be released right away. The disadvantage is that if instances accumulate, so too will the accumulated method results. They can grow without bound.</p> <p>The <em>lru_cache</em> approach works with methods that have <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> arguments. It creates a reference to the instance unless special efforts are made to pass in weak references.</p> <p>The advantage of the least recently used algorithm is that the cache is bounded by the specified <em>maxsize</em>. The disadvantage is that instances are kept alive until they age out of the cache or until the cache is cleared.</p> <p>This example shows the various techniques:</p> <pre data-language="python">class Weather:
    "Lookup weather information on a government website"

    def __init__(self, station_id):
        self._station_id = station_id
        # The _station_id is private and immutable

    def current_temperature(self):
        "Latest hourly observation"
        # Do not cache this because old results
        # can be out of date.

    @cached_property
    def location(self):
        "Return the longitude/latitude coordinates of the station"
        # Result only depends on the station_id

    @lru_cache(maxsize=20)
    def historic_rainfall(self, date, units='mm'):
        "Rainfall on a given date"
        # Depends on the station_id, date, and units.
</pre> <p>The above example assumes that the <em>station_id</em> never changes. If the relevant instance attributes are mutable, the <em>cached_property</em> approach can’t be made to work because it cannot detect changes to the attributes.</p> <p>To make the <em>lru_cache</em> approach work when the <em>station_id</em> is mutable, the class needs to define the <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code>__eq__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> methods so that the cache can detect relevant attribute updates:</p> <pre data-language="python">class Weather:
    "Example with a mutable station identifier"

    def __init__(self, station_id):
        self.station_id = station_id

    def change_station(self, station_id):
        self.station_id = station_id

    def __eq__(self, other):
        return self.station_id == other.station_id

    def __hash__(self):
        return hash(self.station_id)

    @lru_cache(maxsize=20)
    def historic_rainfall(self, date, units='cm'):
        'Rainfall on a given date'
        # Depends on the station_id, date, and units.
</pre> </section> </section> <section id="modules"> <h2>Modules</h2> <section id="how-do-i-create-a-pyc-file"> <h3>How do I create a .pyc file?</h3> <p>When a module is imported for the first time (or when the source file has changed since the current compiled file was created) a <code>.pyc</code> file containing the compiled code should be created in a <code>__pycache__</code> subdirectory of the directory containing the <code>.py</code> file. The <code>.pyc</code> file will have a filename that starts with the same name as the <code>.py</code> file, and ends with <code>.pyc</code>, with a middle component that depends on the particular <code>python</code> binary that created it. (See <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a> for details.)</p> <p>One reason that a <code>.pyc</code> file may not be created is a permissions problem with the directory containing the source file, meaning that the <code>__pycache__</code> subdirectory cannot be created. This can happen, for example, if you develop as one user but run as another, such as if you are testing with a web server.</p> <p>Unless the <span class="target" id="index-4"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code>PYTHONDONTWRITEBYTECODE</code></a> environment variable is set, creation of a .pyc file is automatic if you’re importing a module and Python has the ability (permissions, free space, etc…) to create a <code>__pycache__</code> subdirectory and write the compiled module to that subdirectory.</p> <p>Running Python on a top level script is not considered an import and no <code>.pyc</code> will be created. For example, if you have a top-level module <code>foo.py</code> that imports another module <code>xyz.py</code>, when you run <code>foo</code> (by typing <code>python foo.py</code> as a shell command), a <code>.pyc</code> will be created for <code>xyz</code> because <code>xyz</code> is imported, but no <code>.pyc</code> file will be created for <code>foo</code> since <code>foo.py</code> isn’t being imported.</p> <p>If you need to create a <code>.pyc</code> file for <code>foo</code> – that is, to create a <code>.pyc</code> file for a module that is not imported – you can, using the <a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code>py_compile</code></a> and <a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code>compileall</code></a> modules.</p> <p>The <a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code>py_compile</code></a> module can manually compile any module. One way is to use the <code>compile()</code> function in that module interactively:</p> <pre data-language="python">&gt;&gt;&gt; import py_compile
&gt;&gt;&gt; py_compile.compile('foo.py')                 
</pre> <p>This will write the <code>.pyc</code> to a <code>__pycache__</code> subdirectory in the same location as <code>foo.py</code> (or you can override that with the optional parameter <code>cfile</code>).</p> <p>You can also automatically compile all files in a directory or directories using the <a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code>compileall</code></a> module. You can do it from the shell prompt by running <code>compileall.py</code> and providing the path of a directory containing Python files to compile:</p> <pre data-language="python">python -m compileall .
</pre> </section> <section id="how-do-i-find-the-current-module-name"> <h3>How do I find the current module name?</h3> <p>A module can find out its own module name by looking at the predefined global variable <code>__name__</code>. If this has the value <code>'__main__'</code>, the program is running as a script. Many modules that are usually used by importing them also provide a command-line interface or a self-test, and only execute this code after checking <code>__name__</code>:</p> <pre data-language="python">def main():
    print('Running test...')
    ...

if __name__ == '__main__':
    main()
</pre> </section> <section id="how-can-i-have-modules-that-mutually-import-each-other"> <h3>How can I have modules that mutually import each other?</h3> <p>Suppose you have the following modules:</p> <p><code>foo.py</code>:</p> <pre data-language="python">from bar import bar_var
foo_var = 1
</pre> <p><code>bar.py</code>:</p> <pre data-language="python">from foo import foo_var
bar_var = 2
</pre> <p>The problem is that the interpreter will perform the following steps:</p> <ul class="simple"> <li>main imports <code>foo</code>
</li> <li>Empty globals for <code>foo</code> are created</li> <li>
<code>foo</code> is compiled and starts executing</li> <li>
<code>foo</code> imports <code>bar</code>
</li> <li>Empty globals for <code>bar</code> are created</li> <li>
<code>bar</code> is compiled and starts executing</li> <li>
<code>bar</code> imports <code>foo</code> (which is a no-op since there already is a module named <code>foo</code>)</li> <li>The import mechanism tries to read <code>foo_var</code> from <code>foo</code> globals, to set <code>bar.foo_var = foo.foo_var</code>
</li> </ul> <p>The last step fails, because Python isn’t done with interpreting <code>foo</code> yet and the global symbol dictionary for <code>foo</code> is still empty.</p> <p>The same thing happens when you use <code>import foo</code>, and then try to access <code>foo.foo_var</code> in global code.</p> <p>There are (at least) three possible workarounds for this problem.</p> <p>Guido van Rossum recommends avoiding all uses of <code>from &lt;module&gt; import ...</code>, and placing all code inside functions. Initializations of global variables and class variables should use constants or built-in functions only. This means everything from an imported module is referenced as <code>&lt;module&gt;.&lt;name&gt;</code>.</p> <p>Jim Roskind suggests performing steps in the following order in each module:</p> <ul class="simple"> <li>exports (globals, functions, and classes that don’t need imported base classes)</li> <li>
<code>import</code> statements</li> <li>active code (including globals that are initialized from imported values).</li> </ul> <p>Van Rossum doesn’t like this approach much because the imports appear in a strange place, but it does work.</p> <p>Matthias Urlichs recommends restructuring your code so that the recursive import is not necessary in the first place.</p> <p>These solutions are not mutually exclusive.</p> </section> <section id="import-x-y-z-returns-module-x-how-do-i-get-z"> <h3>__import__(‘x.y.z’) returns &lt;module ‘x’&gt;; how do I get z?</h3> <p>Consider using the convenience function <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code>import_module()</code></a> from <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> instead:</p> <pre data-language="python">z = importlib.import_module('x.y.z')
</pre> </section> <section id="when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen"> <h3>When I edit an imported module and reimport it, the changes don’t show up. Why does this happen?</h3> <p>For reasons of efficiency as well as consistency, Python only reads the module file on the first time a module is imported. If it didn’t, in a program consisting of many modules where each one imports the same basic module, the basic module would be parsed and re-parsed many times. To force re-reading of a changed module, do this:</p> <pre data-language="python">import importlib
import modname
importlib.reload(modname)
</pre> <p>Warning: this technique is not 100% fool-proof. In particular, modules containing statements like</p> <pre data-language="python">from modname import some_objects
</pre> <p>will continue to work with the old version of the imported objects. If the module contains class definitions, existing class instances will <em>not</em> be updated to use the new class definition. This can result in the following paradoxical behaviour:</p> <pre data-language="python">&gt;&gt;&gt; import importlib
&gt;&gt;&gt; import cls
&gt;&gt;&gt; c = cls.C()                # Create an instance of C
&gt;&gt;&gt; importlib.reload(cls)
&lt;module 'cls' from 'cls.py'&gt;
&gt;&gt;&gt; isinstance(c, cls.C)       # isinstance is false?!?
False
</pre> <p>The nature of the problem is made clear if you print out the “identity” of the class objects:</p> <pre data-language="python">&gt;&gt;&gt; hex(id(c.__class__))
'0x7352a0'
&gt;&gt;&gt; hex(id(cls.C))
'0x4198d0'
</pre> </section> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/faq/programming.html" class="_attribution-link">https://docs.python.org/3.12/faq/programming.html</a>
  </p>
</div>
