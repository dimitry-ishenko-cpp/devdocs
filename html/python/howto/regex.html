 <span id="regex-howto"></span><h1>Regular Expression HOWTO</h1> <dl class="field-list simple"> <dt class="field-odd">Author<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>A.M. Kuchling &lt;<a class="reference external" href="mailto:amk%40amk.ca.html">amk<span>@</span>amk<span>.</span>ca</a>&gt;</p> </dd> </dl> <aside class="topic"> <p class="topic-title">Abstract</p> <p>This document is an introductory tutorial to using regular expressions in Python with the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> module. It provides a gentler introduction than the corresponding section in the Library Reference.</p> </aside> <section id="introduction"> <h2>Introduction</h2> <p>Regular expressions (called REs, or regexes, or regex patterns) are essentially a tiny, highly specialized programming language embedded inside Python and made available through the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> module. Using this little language, you specify the rules for the set of possible strings that you want to match; this set might contain English sentences, or e-mail addresses, or TeX commands, or anything you like. You can then ask questions such as “Does this string match the pattern?”, or “Is there a match for the pattern anywhere in this string?”. You can also use REs to modify a string or to split it apart in various ways.</p> <p>Regular expression patterns are compiled into a series of bytecodes which are then executed by a matching engine written in C. For advanced use, it may be necessary to pay careful attention to how the engine will execute a given RE, and write the RE in a certain way in order to produce bytecode that runs faster. Optimization isn’t covered in this document, because it requires that you have a good understanding of the matching engine’s internals.</p> <p>The regular expression language is relatively small and restricted, so not all possible string processing tasks can be done using regular expressions. There are also tasks that <em>can</em> be done with regular expressions, but the expressions turn out to be very complicated. In these cases, you may be better off writing Python code to do the processing; while Python code will be slower than an elaborate regular expression, it will also probably be more understandable.</p> </section> <section id="simple-patterns"> <h2>Simple Patterns</h2> <p>We’ll start by learning about the simplest possible regular expressions. Since regular expressions are used to operate on strings, we’ll begin with the most common task: matching characters.</p> <p>For a detailed explanation of the computer science underlying regular expressions (deterministic and non-deterministic finite automata), you can refer to almost any textbook on writing compilers.</p> <section id="matching-characters"> <h3>Matching Characters</h3> <p>Most letters and characters will simply match themselves. For example, the regular expression <code>test</code> will match the string <code>test</code> exactly. (You can enable a case-insensitive mode that would let this RE match <code>Test</code> or <code>TEST</code> as well; more about this later.)</p> <p>There are exceptions to this rule; some characters are special <em class="dfn">metacharacters</em>, and don’t match themselves. Instead, they signal that some out-of-the-ordinary thing should be matched, or they affect other portions of the RE by repeating them or changing their meaning. Much of this document is devoted to discussing various metacharacters and what they do.</p> <p>Here’s a complete list of the metacharacters; their meanings will be discussed in the rest of this HOWTO.</p> <pre data-language="none">. ^ $ * + ? { } [ ] \ | ( )
</pre> <p>The first metacharacters we’ll look at are <code>[</code> and <code>]</code>. They’re used for specifying a character class, which is a set of characters that you wish to match. Characters can be listed individually, or a range of characters can be indicated by giving two characters and separating them by a <code>'-'</code>. For example, <code>[abc]</code> will match any of the characters <code>a</code>, <code>b</code>, or <code>c</code>; this is the same as <code>[a-c]</code>, which uses a range to express the same set of characters. If you wanted to match only lowercase letters, your RE would be <code>[a-z]</code>.</p> <p>Metacharacters (except <code>\</code>) are not active inside classes. For example, <code>[akm$]</code> will match any of the characters <code>'a'</code>, <code>'k'</code>, <code>'m'</code>, or <code>'$'</code>; <code>'$'</code> is usually a metacharacter, but inside a character class it’s stripped of its special nature.</p> <p>You can match the characters not listed within the class by <em class="dfn">complementing</em> the set. This is indicated by including a <code>'^'</code> as the first character of the class. For example, <code>[^5]</code> will match any character except <code>'5'</code>. If the caret appears elsewhere in a character class, it does not have special meaning. For example: <code>[5^]</code> will match either a <code>'5'</code> or a <code>'^'</code>.</p> <p>Perhaps the most important metacharacter is the backslash, <code>\</code>. As in Python string literals, the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns; for example, if you need to match a <code>[</code> or <code>\</code>, you can precede them with a backslash to remove their special meaning: <code>\[</code> or <code>\\</code>.</p> <p>Some of the special sequences beginning with <code>'\'</code> represent predefined sets of characters that are often useful, such as the set of digits, the set of letters, or the set of anything that isn’t whitespace.</p> <p>Let’s take an example: <code>\w</code> matches any alphanumeric character. If the regex pattern is expressed in bytes, this is equivalent to the class <code>[a-zA-Z0-9_]</code>. If the regex pattern is a string, <code>\w</code> will match all the characters marked as letters in the Unicode database provided by the <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code>unicodedata</code></a> module. You can use the more restricted definition of <code>\w</code> in a string pattern by supplying the <a class="reference internal" href="../library/re.html#re.ASCII" title="re.ASCII"><code>re.ASCII</code></a> flag when compiling the regular expression.</p> <p>The following list of special sequences isn’t complete. For a complete list of sequences and expanded class definitions for Unicode string patterns, see the last part of <a class="reference internal" href="../library/re.html#re-syntax"><span class="std std-ref">Regular Expression Syntax</span></a> in the Standard Library reference. In general, the Unicode versions match any character that’s in the appropriate category in the Unicode database.</p> <dl class="simple"> <dt>
<code>\d</code> </dt>
<dd>
<p>Matches any decimal digit; this is equivalent to the class <code>[0-9]</code>.</p> </dd> <dt>
<code>\D</code> </dt>
<dd>
<p>Matches any non-digit character; this is equivalent to the class <code>[^0-9]</code>.</p> </dd> <dt>
<code>\s</code> </dt>
<dd>
<p>Matches any whitespace character; this is equivalent to the class <code>[
\t\n\r\f\v]</code>.</p> </dd> <dt>
<code>\S</code> </dt>
<dd>
<p>Matches any non-whitespace character; this is equivalent to the class <code>[^
\t\n\r\f\v]</code>.</p> </dd> <dt>
<code>\w</code> </dt>
<dd>
<p>Matches any alphanumeric character; this is equivalent to the class <code>[a-zA-Z0-9_]</code>.</p> </dd> <dt>
<code>\W</code> </dt>
<dd>
<p>Matches any non-alphanumeric character; this is equivalent to the class <code>[^a-zA-Z0-9_]</code>.</p> </dd> </dl> <p>These sequences can be included inside a character class. For example, <code>[\s,.]</code> is a character class that will match any whitespace character, or <code>','</code> or <code>'.'</code>.</p> <p>The final metacharacter in this section is <code>.</code>. It matches anything except a newline character, and there’s an alternate mode (<a class="reference internal" href="../library/re.html#re.DOTALL" title="re.DOTALL"><code>re.DOTALL</code></a>) where it will match even a newline. <code>.</code> is often used where you want to match “any character”.</p> </section> <section id="repeating-things"> <h3>Repeating Things</h3> <p>Being able to match varying sets of characters is the first thing regular expressions can do that isn’t already possible with the methods available on strings. However, if that was the only additional capability of regexes, they wouldn’t be much of an advance. Another capability is that you can specify that portions of the RE must be repeated a certain number of times.</p> <p>The first metacharacter for repeating things that we’ll look at is <code>*</code>. <code>*</code> doesn’t match the literal character <code>'*'</code>; instead, it specifies that the previous character can be matched zero or more times, instead of exactly once.</p> <p>For example, <code>ca*t</code> will match <code>'ct'</code> (0 <code>'a'</code> characters), <code>'cat'</code> (1 <code>'a'</code>), <code>'caaat'</code> (3 <code>'a'</code> characters), and so forth.</p> <p>Repetitions such as <code>*</code> are <em class="dfn">greedy</em>; when repeating a RE, the matching engine will try to repeat it as many times as possible. If later portions of the pattern don’t match, the matching engine will then back up and try again with fewer repetitions.</p> <p>A step-by-step example will make this more obvious. Let’s consider the expression <code>a[bcd]*b</code>. This matches the letter <code>'a'</code>, zero or more letters from the class <code>[bcd]</code>, and finally ends with a <code>'b'</code>. Now imagine matching this RE against the string <code>'abcbd'</code>.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Step</p></th> <th class="head"><p>Matched</p></th> <th class="head"><p>Explanation</p></th> </tr> </thead>  <tr>
<td><p>1</p></td> <td><p><code>a</code></p></td> <td><p>The <code>a</code> in the RE matches.</p></td> </tr> <tr>
<td><p>2</p></td> <td><p><code>abcbd</code></p></td> <td><p>The engine matches <code>[bcd]*</code>, going as far as it can, which is to the end of the string.</p></td> </tr> <tr>
<td><p>3</p></td> <td><p><em>Failure</em></p></td> <td><p>The engine tries to match <code>b</code>, but the current position is at the end of the string, so it fails.</p></td> </tr> <tr>
<td><p>4</p></td> <td><p><code>abcb</code></p></td> <td><p>Back up, so that <code>[bcd]*</code> matches one less character.</p></td> </tr> <tr>
<td><p>5</p></td> <td><p><em>Failure</em></p></td> <td><p>Try <code>b</code> again, but the current position is at the last character, which is a <code>'d'</code>.</p></td> </tr> <tr>
<td><p>6</p></td> <td><p><code>abc</code></p></td> <td><p>Back up again, so that <code>[bcd]*</code> is only matching <code>bc</code>.</p></td> </tr> <tr>
<td><p>6</p></td> <td><p><code>abcb</code></p></td> <td><p>Try <code>b</code> again. This time the character at the current position is <code>'b'</code>, so it succeeds.</p></td> </tr>  </table> <p>The end of the RE has now been reached, and it has matched <code>'abcb'</code>. This demonstrates how the matching engine goes as far as it can at first, and if no match is found it will then progressively back up and retry the rest of the RE again and again. It will back up until it has tried zero matches for <code>[bcd]*</code>, and if that subsequently fails, the engine will conclude that the string doesn’t match the RE at all.</p> <p>Another repeating metacharacter is <code>+</code>, which matches one or more times. Pay careful attention to the difference between <code>*</code> and <code>+</code>; <code>*</code> matches <em>zero</em> or more times, so whatever’s being repeated may not be present at all, while <code>+</code> requires at least <em>one</em> occurrence. To use a similar example, <code>ca+t</code> will match <code>'cat'</code> (1 <code>'a'</code>), <code>'caaat'</code> (3 <code>'a'</code>s), but won’t match <code>'ct'</code>.</p> <p>There are two more repeating operators or quantifiers. The question mark character, <code>?</code>, matches either once or zero times; you can think of it as marking something as being optional. For example, <code>home-?brew</code> matches either <code>'homebrew'</code> or <code>'home-brew'</code>.</p> <p>The most complicated quantifier is <code>{m,n}</code>, where <em>m</em> and <em>n</em> are decimal integers. This quantifier means there must be at least <em>m</em> repetitions, and at most <em>n</em>. For example, <code>a/{1,3}b</code> will match <code>'a/b'</code>, <code>'a//b'</code>, and <code>'a///b'</code>. It won’t match <code>'ab'</code>, which has no slashes, or <code>'a////b'</code>, which has four.</p> <p>You can omit either <em>m</em> or <em>n</em>; in that case, a reasonable value is assumed for the missing value. Omitting <em>m</em> is interpreted as a lower limit of 0, while omitting <em>n</em> results in an upper bound of infinity.</p> <p>The simplest case <code>{m}</code> matches the preceding item exactly <em>m</em> times. For example, <code>a/{2}b</code> will only match <code>'a//b'</code>.</p> <p>Readers of a reductionist bent may notice that the three other quantifiers can all be expressed using this notation. <code>{0,}</code> is the same as <code>*</code>, <code>{1,}</code> is equivalent to <code>+</code>, and <code>{0,1}</code> is the same as <code>?</code>. It’s better to use <code>*</code>, <code>+</code>, or <code>?</code> when you can, simply because they’re shorter and easier to read.</p> </section> </section> <section id="using-regular-expressions"> <h2>Using Regular Expressions</h2> <p>Now that we’ve looked at some simple regular expressions, how do we actually use them in Python? The <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> module provides an interface to the regular expression engine, allowing you to compile REs into objects and then perform matches with them.</p> <section id="compiling-regular-expressions"> <h3>Compiling Regular Expressions</h3> <p>Regular expressions are compiled into pattern objects, which have methods for various operations such as searching for pattern matches or performing string substitutions.</p> <pre data-language="python">&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile('ab*')
&gt;&gt;&gt; p
re.compile('ab*')
</pre> <p><a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code>re.compile()</code></a> also accepts an optional <em>flags</em> argument, used to enable various special features and syntax variations. We’ll go over the available settings later, but for now a single example will do:</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile('ab*', re.IGNORECASE)
</pre> <p>The RE is passed to <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code>re.compile()</code></a> as a string. REs are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them. (There are applications that don’t need REs at all, so there’s no need to bloat the language specification by including them.) Instead, the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> module is simply a C extension module included with Python, just like the <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code>socket</code></a> or <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code>zlib</code></a> modules.</p> <p>Putting REs in strings keeps the Python language simpler, but has one disadvantage which is the topic of the next section.</p> </section> <section id="the-backslash-plague"> <span id="id1"></span><h3>The Backslash Plague</h3> <p>As stated earlier, regular expressions use the backslash character (<code>'\'</code>) to indicate special forms or to allow special characters to be used without invoking their special meaning. This conflicts with Python’s usage of the same character for the same purpose in string literals.</p> <p>Let’s say you want to write a RE that matches the string <code>\section</code>, which might be found in a LaTeX file. To figure out what to write in the program code, start with the desired string to be matched. Next, you must escape any backslashes and other metacharacters by preceding them with a backslash, resulting in the string <code>\\section</code>. The resulting string that must be passed to <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code>re.compile()</code></a> must be <code>\\section</code>. However, to express this as a Python string literal, both backslashes must be escaped <em>again</em>.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Characters</p></th> <th class="head"><p>Stage</p></th> </tr> </thead>  <tr>
<td><p><code>\section</code></p></td> <td><p>Text string to be matched</p></td> </tr> <tr>
<td><p><code>\\section</code></p></td> <td><p>Escaped backslash for <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code>re.compile()</code></a></p></td> </tr> <tr>
<td><p><code>"\\\\section"</code></p></td> <td><p>Escaped backslashes for a string literal</p></td> </tr>  </table> <p>In short, to match a literal backslash, one has to write <code>'\\\\'</code> as the RE string, because the regular expression must be <code>\\</code>, and each backslash must be expressed as <code>\\</code> inside a regular Python string literal. In REs that feature backslashes repeatedly, this leads to lots of repeated backslashes and makes the resulting strings difficult to understand.</p> <p>The solution is to use Python’s raw string notation for regular expressions; backslashes are not handled in any special way in a string literal prefixed with <code>'r'</code>, so <code>r"\n"</code> is a two-character string containing <code>'\'</code> and <code>'n'</code>, while <code>"\n"</code> is a one-character string containing a newline. Regular expressions will often be written in Python code using this raw string notation.</p> <p>In addition, special escape sequences that are valid in regular expressions, but not valid as Python string literals, now result in a <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code>DeprecationWarning</code></a> and will eventually become a <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a>, which means the sequences will be invalid if raw string notation or escaping the backslashes isn’t used.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Regular String</p></th> <th class="head"><p>Raw string</p></th> </tr> </thead>  <tr>
<td><p><code>"ab*"</code></p></td> <td><p><code>r"ab*"</code></p></td> </tr> <tr>
<td><p><code>"\\\\section"</code></p></td> <td><p><code>r"\\section"</code></p></td> </tr> <tr>
<td><p><code>"\\w+\\s+\\1"</code></p></td> <td><p><code>r"\w+\s+\1"</code></p></td> </tr>  </table> </section> <section id="performing-matches"> <h3>Performing Matches</h3> <p>Once you have an object representing a compiled regular expression, what do you do with it? Pattern objects have several methods and attributes. Only the most significant ones will be covered here; consult the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> docs for a complete listing.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Method/Attribute</p></th> <th class="head"><p>Purpose</p></th> </tr> </thead>  <tr>
<td><p><code>match()</code></p></td> <td><p>Determine if the RE matches at the beginning of the string.</p></td> </tr> <tr>
<td><p><code>search()</code></p></td> <td><p>Scan through a string, looking for any location where this RE matches.</p></td> </tr> <tr>
<td><p><code>findall()</code></p></td> <td><p>Find all substrings where the RE matches, and returns them as a list.</p></td> </tr> <tr>
<td><p><code>finditer()</code></p></td> <td><p>Find all substrings where the RE matches, and returns them as an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>.</p></td> </tr>  </table> <p><a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code>match()</code></a> and <a class="reference internal" href="../library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> return <code>None</code> if no match can be found. If they’re successful, a <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> instance is returned, containing information about the match: where it starts and ends, the substring it matched, and more.</p> <p>You can learn about this by interactively experimenting with the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> module.</p> <p>This HOWTO uses the standard Python interpreter for its examples. First, run the Python interpreter, import the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> module, and compile a RE:</p> <pre data-language="python">&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile('[a-z]+')
&gt;&gt;&gt; p
re.compile('[a-z]+')
</pre> <p>Now, you can try matching various strings against the RE <code>[a-z]+</code>. An empty string shouldn’t match at all, since <code>+</code> means ‘one or more repetitions’. <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code>match()</code></a> should return <code>None</code> in this case, which will cause the interpreter to print no output. You can explicitly print the result of <code>match()</code> to make this clear.</p> <pre data-language="python">&gt;&gt;&gt; p.match("")
&gt;&gt;&gt; print(p.match(""))
None
</pre> <p>Now, let’s try it on a string that it should match, such as <code>tempo</code>. In this case, <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code>match()</code></a> will return a <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a>, so you should store the result in a variable for later use.</p> <pre data-language="python">&gt;&gt;&gt; m = p.match('tempo')
&gt;&gt;&gt; m
&lt;re.Match object; span=(0, 5), match='tempo'&gt;
</pre> <p>Now you can query the <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> for information about the matching string. Match object instances also have several methods and attributes; the most important ones are:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Method/Attribute</p></th> <th class="head"><p>Purpose</p></th> </tr> </thead>  <tr>
<td><p><code>group()</code></p></td> <td><p>Return the string matched by the RE</p></td> </tr> <tr>
<td><p><code>start()</code></p></td> <td><p>Return the starting position of the match</p></td> </tr> <tr>
<td><p><code>end()</code></p></td> <td><p>Return the ending position of the match</p></td> </tr> <tr>
<td><p><code>span()</code></p></td> <td><p>Return a tuple containing the (start, end) positions of the match</p></td> </tr>  </table> <p>Trying these methods will soon clarify their meaning:</p> <pre data-language="python">&gt;&gt;&gt; m.group()
'tempo'
&gt;&gt;&gt; m.start(), m.end()
(0, 5)
&gt;&gt;&gt; m.span()
(0, 5)
</pre> <p><a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code>group()</code></a> returns the substring that was matched by the RE. <a class="reference internal" href="../library/re.html#re.Match.start" title="re.Match.start"><code>start()</code></a> and <a class="reference internal" href="../library/re.html#re.Match.end" title="re.Match.end"><code>end()</code></a> return the starting and ending index of the match. <a class="reference internal" href="../library/re.html#re.Match.span" title="re.Match.span"><code>span()</code></a> returns both start and end indexes in a single tuple. Since the <a class="reference internal" href="../library/re.html#re.Pattern.match" title="re.Pattern.match"><code>match()</code></a> method only checks if the RE matches at the start of a string, <code>start()</code> will always be zero. However, the <a class="reference internal" href="../library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> method of patterns scans through the string, so the match may not start at zero in that case.</p> <pre data-language="python">&gt;&gt;&gt; print(p.match('::: message'))
None
&gt;&gt;&gt; m = p.search('::: message'); print(m)
&lt;re.Match object; span=(4, 11), match='message'&gt;
&gt;&gt;&gt; m.group()
'message'
&gt;&gt;&gt; m.span()
(4, 11)
</pre> <p>In actual programs, the most common style is to store the <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> in a variable, and then check if it was <code>None</code>. This usually looks like:</p> <pre data-language="python">p = re.compile( ... )
m = p.match( 'string goes here' )
if m:
    print('Match found: ', m.group())
else:
    print('No match')
</pre> <p>Two pattern methods return all of the matches for a pattern. <a class="reference internal" href="../library/re.html#re.Pattern.findall" title="re.Pattern.findall"><code>findall()</code></a> returns a list of matching strings:</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile(r'\d+')
&gt;&gt;&gt; p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
['12', '11', '10']
</pre> <p>The <code>r</code> prefix, making the literal a raw string literal, is needed in this example because escape sequences in a normal “cooked” string literal that are not recognized by Python, as opposed to regular expressions, now result in a <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code>DeprecationWarning</code></a> and will eventually become a <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a>. See <a class="reference internal" href="#the-backslash-plague"><span class="std std-ref">The Backslash Plague</span></a>.</p> <p><a class="reference internal" href="../library/re.html#re.Pattern.findall" title="re.Pattern.findall"><code>findall()</code></a> has to create the entire list before it can be returned as the result. The <a class="reference internal" href="../library/re.html#re.Pattern.finditer" title="re.Pattern.finditer"><code>finditer()</code></a> method returns a sequence of <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> instances as an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>:</p> <pre data-language="python">&gt;&gt;&gt; iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')
&gt;&gt;&gt; iterator  
&lt;callable_iterator object at 0x...&gt;
&gt;&gt;&gt; for match in iterator:
...     print(match.span())
...
(0, 2)
(22, 24)
(29, 31)
</pre> </section> <section id="module-level-functions"> <h3>Module-Level Functions</h3> <p>You don’t have to create a pattern object and call its methods; the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> module also provides top-level functions called <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code>match()</code></a>, <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code>search()</code></a>, <a class="reference internal" href="../library/re.html#re.findall" title="re.findall"><code>findall()</code></a>, <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code>sub()</code></a>, and so forth. These functions take the same arguments as the corresponding pattern method with the RE string added as the first argument, and still return either <code>None</code> or a <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> instance.</p> <pre data-language="python">&gt;&gt;&gt; print(re.match(r'From\s+', 'Fromage amk'))
None
&gt;&gt;&gt; re.match(r'From\s+', 'From amk Thu May 14 19:12:10 1998')  
&lt;re.Match object; span=(0, 5), match='From '&gt;
</pre> <p>Under the hood, these functions simply create a pattern object for you and call the appropriate method on it. They also store the compiled object in a cache, so future calls using the same RE won’t need to parse the pattern again and again.</p> <p>Should you use these module-level functions, or should you get the pattern and call its methods yourself? If you’re accessing a regex within a loop, pre-compiling it will save a few function calls. Outside of loops, there’s not much difference thanks to the internal cache.</p> </section> <section id="compilation-flags"> <h3>Compilation Flags</h3> <p>Compilation flags let you modify some aspects of how regular expressions work. Flags are available in the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> module under two names, a long name such as <a class="reference internal" href="../library/re.html#re.IGNORECASE" title="re.IGNORECASE"><code>IGNORECASE</code></a> and a short, one-letter form such as <a class="reference internal" href="../library/re.html#re.I" title="re.I"><code>I</code></a>. (If you’re familiar with Perl’s pattern modifiers, the one-letter forms use the same letters; the short form of <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code>re.VERBOSE</code></a> is <a class="reference internal" href="../library/re.html#re.X" title="re.X"><code>re.X</code></a>, for example.) Multiple flags can be specified by bitwise OR-ing them; <code>re.I | re.M</code> sets both the <a class="reference internal" href="../library/re.html#re.I" title="re.I"><code>I</code></a> and <a class="reference internal" href="../library/re.html#re.M" title="re.M"><code>M</code></a> flags, for example.</p> <p>Here’s a table of the available flags, followed by a more detailed explanation of each one.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Flag</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="../library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a>, <a class="reference internal" href="../library/re.html#re.A" title="re.A"><code>A</code></a></p></td> <td><p>Makes several escapes like <code>\w</code>, <code>\b</code>, <code>\s</code> and <code>\d</code> match only on ASCII characters with the respective property.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../library/re.html#re.DOTALL" title="re.DOTALL"><code>DOTALL</code></a>, <a class="reference internal" href="../library/re.html#re.S" title="re.S"><code>S</code></a></p></td> <td><p>Make <code>.</code> match any character, including newlines.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../library/re.html#re.IGNORECASE" title="re.IGNORECASE"><code>IGNORECASE</code></a>, <a class="reference internal" href="../library/re.html#re.I" title="re.I"><code>I</code></a></p></td> <td><p>Do case-insensitive matches.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../library/re.html#re.LOCALE" title="re.LOCALE"><code>LOCALE</code></a>, <a class="reference internal" href="../library/re.html#re.L" title="re.L"><code>L</code></a></p></td> <td><p>Do a locale-aware match.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../library/re.html#re.MULTILINE" title="re.MULTILINE"><code>MULTILINE</code></a>, <a class="reference internal" href="../library/re.html#re.M" title="re.M"><code>M</code></a></p></td> <td><p>Multi-line matching, affecting <code>^</code> and <code>$</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code>VERBOSE</code></a>, <a class="reference internal" href="../library/re.html#re.X" title="re.X"><code>X</code></a> (for ‘extended’)</p></td> <td><p>Enable verbose REs, which can be organized more cleanly and understandably.</p></td> </tr>  </table> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">I</span>
</dt> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">IGNORECASE</span>
</dt> <dd>
<p>Perform case-insensitive matching; character class and literal strings will match letters by ignoring case. For example, <code>[A-Z]</code> will match lowercase letters, too. Full Unicode matching also works unless the <a class="reference internal" href="../library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> flag is used to disable non-ASCII matches. When the Unicode patterns <code>[a-z]</code> or <code>[A-Z]</code> are used in combination with the <a class="reference internal" href="../library/re.html#re.IGNORECASE" title="re.IGNORECASE"><code>IGNORECASE</code></a> flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). <code>Spam</code> will match <code>'Spam'</code>, <code>'spam'</code>, <code>'spAM'</code>, or <code>'ſpam'</code> (the latter is matched only in Unicode mode). This lowercasing doesn’t take the current locale into account; it will if you also set the <a class="reference internal" href="../library/re.html#re.LOCALE" title="re.LOCALE"><code>LOCALE</code></a> flag.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">L</span>
</dt> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">LOCALE</span>
</dt> <dd>
<p>Make <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> and case-insensitive matching dependent on the current locale instead of the Unicode database.</p> <p>Locales are a feature of the C library intended to help in writing programs that take account of language differences. For example, if you’re processing encoded French text, you’d want to be able to write <code>\w+</code> to match words, but <code>\w</code> only matches the character class <code>[A-Za-z]</code> in bytes patterns; it won’t match bytes corresponding to <code>é</code> or <code>ç</code>. If your system is configured properly and a French locale is selected, certain C functions will tell the program that the byte corresponding to <code>é</code> should also be considered a letter. Setting the <a class="reference internal" href="../library/re.html#re.LOCALE" title="re.LOCALE"><code>LOCALE</code></a> flag when compiling a regular expression will cause the resulting compiled object to use these C functions for <code>\w</code>; this is slower, but also enables <code>\w+</code> to match French words as you’d expect. The use of this flag is discouraged in Python 3 as the locale mechanism is very unreliable, it only handles one “culture” at a time, and it only works with 8-bit locales. Unicode matching is already enabled by default in Python 3 for Unicode (str) patterns, and it is able to handle different locales/languages.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">M</span>
</dt> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">MULTILINE</span>
</dt> <dd>
<p>(<code>^</code> and <code>$</code> haven’t been explained yet; they’ll be introduced in section <a class="reference internal" href="#more-metacharacters"><span class="std std-ref">More Metacharacters</span></a>.)</p> <p>Usually <code>^</code> matches only at the beginning of the string, and <code>$</code> matches only at the end of the string and immediately before the newline (if any) at the end of the string. When this flag is specified, <code>^</code> matches at the beginning of the string and at the beginning of each line within the string, immediately following each newline. Similarly, the <code>$</code> metacharacter matches either at the end of the string and at the end of each line (immediately preceding each newline).</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">S</span>
</dt> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">DOTALL</span>
</dt> <dd>
<p>Makes the <code>'.'</code> special character match any character at all, including a newline; without this flag, <code>'.'</code> will match anything <em>except</em> a newline.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">A</span>
</dt> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">ASCII</span>
</dt> <dd>
<p>Make <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\s</code> and <code>\S</code> perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode patterns, and is ignored for byte patterns.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">X</span>
</dt> <dt class="sig sig-object py"> <span class="sig-prename descclassname">re.</span><span class="sig-name descname">VERBOSE</span>
</dt> <dd>
<p>This flag allows you to write regular expressions that are more readable by granting you more flexibility in how you can format them. When this flag has been specified, whitespace within the RE string is ignored, except when the whitespace is in a character class or preceded by an unescaped backslash; this lets you organize and indent the RE more clearly. This flag also lets you put comments within a RE that will be ignored by the engine; comments are marked by a <code>'#'</code> that’s neither in a character class or preceded by an unescaped backslash.</p> <p>For example, here’s a RE that uses <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code>re.VERBOSE</code></a>; see how much easier it is to read?</p> <pre data-language="python">charref = re.compile(r"""
 &amp;[#]                # Start of a numeric entity reference
 (
     0[0-7]+         # Octal form
   | [0-9]+          # Decimal form
   | x[0-9a-fA-F]+   # Hexadecimal form
 )
 ;                   # Trailing semicolon
""", re.VERBOSE)
</pre> <p>Without the verbose setting, the RE would look like this:</p> <pre data-language="python">charref = re.compile("&amp;#(0[0-7]+"
                     "|[0-9]+"
                     "|x[0-9a-fA-F]+);")
</pre> <p>In the above example, Python’s automatic concatenation of string literals has been used to break up the RE into smaller pieces, but it’s still more difficult to understand than the version using <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code>re.VERBOSE</code></a>.</p> </dd>
</dl> </section> </section> <section id="more-pattern-power"> <h2>More Pattern Power</h2> <p>So far we’ve only covered a part of the features of regular expressions. In this section, we’ll cover some new metacharacters, and how to use groups to retrieve portions of the text that was matched.</p> <section id="more-metacharacters"> <span id="id2"></span><h3>More Metacharacters</h3> <p>There are some metacharacters that we haven’t covered yet. Most of them will be covered in this section.</p> <p>Some of the remaining metacharacters to be discussed are <em class="dfn">zero-width assertions</em>. They don’t cause the engine to advance through the string; instead, they consume no characters at all, and simply succeed or fail. For example, <code>\b</code> is an assertion that the current position is located at a word boundary; the position isn’t changed by the <code>\b</code> at all. This means that zero-width assertions should never be repeated, because if they match once at a given location, they can obviously be matched an infinite number of times.</p> <dl> <dt>
<code>|</code> </dt>
<dd>
<p>Alternation, or the “or” operator. If <em>A</em> and <em>B</em> are regular expressions, <code>A|B</code> will match any string that matches either <em>A</em> or <em>B</em>. <code>|</code> has very low precedence in order to make it work reasonably when you’re alternating multi-character strings. <code>Crow|Servo</code> will match either <code>'Crow'</code> or <code>'Servo'</code>, not <code>'Cro'</code>, a <code>'w'</code> or an <code>'S'</code>, and <code>'ervo'</code>.</p> <p>To match a literal <code>'|'</code>, use <code>\|</code>, or enclose it inside a character class, as in <code>[|]</code>.</p> </dd> <dt>
<code>^</code> </dt>
<dd>
<p>Matches at the beginning of lines. Unless the <a class="reference internal" href="../library/re.html#re.MULTILINE" title="re.MULTILINE"><code>MULTILINE</code></a> flag has been set, this will only match at the beginning of the string. In <a class="reference internal" href="../library/re.html#re.MULTILINE" title="re.MULTILINE"><code>MULTILINE</code></a> mode, this also matches immediately after each newline within the string.</p> <p>For example, if you wish to match the word <code>From</code> only at the beginning of a line, the RE to use is <code>^From</code>.</p> <pre data-language="python">&gt;&gt;&gt; print(re.search('^From', 'From Here to Eternity'))  
&lt;re.Match object; span=(0, 4), match='From'&gt;
&gt;&gt;&gt; print(re.search('^From', 'Reciting From Memory'))
None
</pre> <p>To match a literal <code>'^'</code>, use <code>\^</code>.</p> </dd> <dt>
<code>$</code> </dt>
<dd>
<p>Matches at the end of a line, which is defined as either the end of the string, or any location followed by a newline character.</p> <pre data-language="python">&gt;&gt;&gt; print(re.search('}$', '{block}'))  
&lt;re.Match object; span=(6, 7), match='}'&gt;
&gt;&gt;&gt; print(re.search('}$', '{block} '))
None
&gt;&gt;&gt; print(re.search('}$', '{block}\n'))  
&lt;re.Match object; span=(6, 7), match='}'&gt;
</pre> <p>To match a literal <code>'$'</code>, use <code>\$</code> or enclose it inside a character class, as in <code>[$]</code>.</p> </dd> <dt>
<code>\A</code> </dt>
<dd>
<p>Matches only at the start of the string. When not in <a class="reference internal" href="../library/re.html#re.MULTILINE" title="re.MULTILINE"><code>MULTILINE</code></a> mode, <code>\A</code> and <code>^</code> are effectively the same. In <a class="reference internal" href="../library/re.html#re.MULTILINE" title="re.MULTILINE"><code>MULTILINE</code></a> mode, they’re different: <code>\A</code> still matches only at the beginning of the string, but <code>^</code> may match at any location inside the string that follows a newline character.</p> </dd> <dt>
<code>\Z</code> </dt>
<dd>
<p>Matches only at the end of the string.</p> </dd> <dt>
<code>\b</code> </dt>
<dd>
<p>Word boundary. This is a zero-width assertion that matches only at the beginning or end of a word. A word is defined as a sequence of alphanumeric characters, so the end of a word is indicated by whitespace or a non-alphanumeric character.</p> <p>The following example matches <code>class</code> only when it’s a complete word; it won’t match when it’s contained inside another word.</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile(r'\bclass\b')
&gt;&gt;&gt; print(p.search('no class at all'))
&lt;re.Match object; span=(3, 8), match='class'&gt;
&gt;&gt;&gt; print(p.search('the declassified algorithm'))
None
&gt;&gt;&gt; print(p.search('one subclass is'))
None
</pre> <p>There are two subtleties you should remember when using this special sequence. First, this is the worst collision between Python’s string literals and regular expression sequences. In Python’s string literals, <code>\b</code> is the backspace character, ASCII value 8. If you’re not using raw strings, then Python will convert the <code>\b</code> to a backspace, and your RE won’t match as you expect it to. The following example looks the same as our previous RE, but omits the <code>'r'</code> in front of the RE string.</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile('\bclass\b')
&gt;&gt;&gt; print(p.search('no class at all'))
None
&gt;&gt;&gt; print(p.search('\b' + 'class' + '\b'))
&lt;re.Match object; span=(0, 7), match='\x08class\x08'&gt;
</pre> <p>Second, inside a character class, where there’s no use for this assertion, <code>\b</code> represents the backspace character, for compatibility with Python’s string literals.</p> </dd> <dt>
<code>\B</code> </dt>
<dd>
<p>Another zero-width assertion, this is the opposite of <code>\b</code>, only matching when the current position is not at a word boundary.</p> </dd> </dl> </section> <section id="grouping"> <h3>Grouping</h3> <p>Frequently you need to obtain more information than just whether the RE matched or not. Regular expressions are often used to dissect strings by writing a RE divided into several subgroups which match different components of interest. For example, an RFC-822 header line is divided into a header name and a value, separated by a <code>':'</code>, like this:</p> <pre data-language="none">From: author@example.com
User-Agent: Thunderbird 1.5.0.9 (X11/20061227)
MIME-Version: 1.0
To: editor@example.com
</pre> <p>This can be handled by writing a regular expression which matches an entire header line, and has one group which matches the header name, and another group which matches the header’s value.</p> <p>Groups are marked by the <code>'('</code>, <code>')'</code> metacharacters. <code>'('</code> and <code>')'</code> have much the same meaning as they do in mathematical expressions; they group together the expressions contained inside them, and you can repeat the contents of a group with a quantifier, such as <code>*</code>, <code>+</code>, <code>?</code>, or <code>{m,n}</code>. For example, <code>(ab)*</code> will match zero or more repetitions of <code>ab</code>.</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile('(ab)*')
&gt;&gt;&gt; print(p.match('ababababab').span())
(0, 10)
</pre> <p>Groups indicated with <code>'('</code>, <code>')'</code> also capture the starting and ending index of the text that they match; this can be retrieved by passing an argument to <a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code>group()</code></a>, <a class="reference internal" href="../library/re.html#re.Match.start" title="re.Match.start"><code>start()</code></a>, <a class="reference internal" href="../library/re.html#re.Match.end" title="re.Match.end"><code>end()</code></a>, and <a class="reference internal" href="../library/re.html#re.Match.span" title="re.Match.span"><code>span()</code></a>. Groups are numbered starting with 0. Group 0 is always present; it’s the whole RE, so <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> methods all have group 0 as their default argument. Later we’ll see how to express groups that don’t capture the span of text that they match.</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile('(a)b')
&gt;&gt;&gt; m = p.match('ab')
&gt;&gt;&gt; m.group()
'ab'
&gt;&gt;&gt; m.group(0)
'ab'
</pre> <p>Subgroups are numbered from left to right, from 1 upward. Groups can be nested; to determine the number, just count the opening parenthesis characters, going from left to right.</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile('(a(b)c)d')
&gt;&gt;&gt; m = p.match('abcd')
&gt;&gt;&gt; m.group(0)
'abcd'
&gt;&gt;&gt; m.group(1)
'abc'
&gt;&gt;&gt; m.group(2)
'b'
</pre> <p><a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code>group()</code></a> can be passed multiple group numbers at a time, in which case it will return a tuple containing the corresponding values for those groups.</p> <pre data-language="python">&gt;&gt;&gt; m.group(2,1,2)
('b', 'abc', 'b')
</pre> <p>The <a class="reference internal" href="../library/re.html#re.Match.groups" title="re.Match.groups"><code>groups()</code></a> method returns a tuple containing the strings for all the subgroups, from 1 up to however many there are.</p> <pre data-language="python">&gt;&gt;&gt; m.groups()
('abc', 'b')
</pre> <p>Backreferences in a pattern allow you to specify that the contents of an earlier capturing group must also be found at the current location in the string. For example, <code>\1</code> will succeed if the exact contents of group 1 can be found at the current position, and fails otherwise. Remember that Python’s string literals also use a backslash followed by numbers to allow including arbitrary characters in a string, so be sure to use a raw string when incorporating backreferences in a RE.</p> <p>For example, the following RE detects doubled words in a string.</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile(r'\b(\w+)\s+\1\b')
&gt;&gt;&gt; p.search('Paris in the the spring').group()
'the the'
</pre> <p>Backreferences like this aren’t often useful for just searching through a string — there are few text formats which repeat data in this way — but you’ll soon find out that they’re <em>very</em> useful when performing string substitutions.</p> </section> <section id="non-capturing-and-named-groups"> <h3>Non-capturing and Named Groups</h3> <p>Elaborate REs may use many groups, both to capture substrings of interest, and to group and structure the RE itself. In complex REs, it becomes difficult to keep track of the group numbers. There are two features which help with this problem. Both of them use a common syntax for regular expression extensions, so we’ll look at that first.</p> <p>Perl 5 is well known for its powerful additions to standard regular expressions. For these new features the Perl developers couldn’t choose new single-keystroke metacharacters or new special sequences beginning with <code>\</code> without making Perl’s regular expressions confusingly different from standard REs. If they chose <code>&amp;</code> as a new metacharacter, for example, old expressions would be assuming that <code>&amp;</code> was a regular character and wouldn’t have escaped it by writing <code>\&amp;</code> or <code>[&amp;]</code>.</p> <p>The solution chosen by the Perl developers was to use <code>(?...)</code> as the extension syntax. <code>?</code> immediately after a parenthesis was a syntax error because the <code>?</code> would have nothing to repeat, so this didn’t introduce any compatibility problems. The characters immediately after the <code>?</code> indicate what extension is being used, so <code>(?=foo)</code> is one thing (a positive lookahead assertion) and <code>(?:foo)</code> is something else (a non-capturing group containing the subexpression <code>foo</code>).</p> <p>Python supports several of Perl’s extensions and adds an extension syntax to Perl’s extension syntax. If the first character after the question mark is a <code>P</code>, you know that it’s an extension that’s specific to Python.</p> <p>Now that we’ve looked at the general extension syntax, we can return to the features that simplify working with groups in complex REs.</p> <p>Sometimes you’ll want to use a group to denote a part of a regular expression, but aren’t interested in retrieving the group’s contents. You can make this fact explicit by using a non-capturing group: <code>(?:...)</code>, where you can replace the <code>...</code> with any other regular expression.</p> <pre data-language="python">&gt;&gt;&gt; m = re.match("([abc])+", "abc")
&gt;&gt;&gt; m.groups()
('c',)
&gt;&gt;&gt; m = re.match("(?:[abc])+", "abc")
&gt;&gt;&gt; m.groups()
()
</pre> <p>Except for the fact that you can’t retrieve the contents of what the group matched, a non-capturing group behaves exactly the same as a capturing group; you can put anything inside it, repeat it with a repetition metacharacter such as <code>*</code>, and nest it within other groups (capturing or non-capturing). <code>(?:...)</code> is particularly useful when modifying an existing pattern, since you can add new groups without changing how all the other groups are numbered. It should be mentioned that there’s no performance difference in searching between capturing and non-capturing groups; neither form is any faster than the other.</p> <p>A more significant feature is named groups: instead of referring to them by numbers, groups can be referenced by a name.</p> <p>The syntax for a named group is one of the Python-specific extensions: <code>(?P&lt;name&gt;...)</code>. <em>name</em> is, obviously, the name of the group. Named groups behave exactly like capturing groups, and additionally associate a name with a group. The <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> methods that deal with capturing groups all accept either integers that refer to the group by number or strings that contain the desired group’s name. Named groups are still given numbers, so you can retrieve information about a group in two ways:</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile(r'(?P&lt;word&gt;\b\w+\b)')
&gt;&gt;&gt; m = p.search( '(((( Lots of punctuation )))' )
&gt;&gt;&gt; m.group('word')
'Lots'
&gt;&gt;&gt; m.group(1)
'Lots'
</pre> <p>Additionally, you can retrieve named groups as a dictionary with <a class="reference internal" href="../library/re.html#re.Match.groupdict" title="re.Match.groupdict"><code>groupdict()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; m = re.match(r'(?P&lt;first&gt;\w+) (?P&lt;last&gt;\w+)', 'Jane Doe')
&gt;&gt;&gt; m.groupdict()
{'first': 'Jane', 'last': 'Doe'}
</pre> <p>Named groups are handy because they let you use easily remembered names, instead of having to remember numbers. Here’s an example RE from the <a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code>imaplib</code></a> module:</p> <pre data-language="python">InternalDate = re.compile(r'INTERNALDATE "'
        r'(?P&lt;day&gt;[ 123][0-9])-(?P&lt;mon&gt;[A-Z][a-z][a-z])-'
        r'(?P&lt;year&gt;[0-9][0-9][0-9][0-9])'
        r' (?P&lt;hour&gt;[0-9][0-9]):(?P&lt;min&gt;[0-9][0-9]):(?P&lt;sec&gt;[0-9][0-9])'
        r' (?P&lt;zonen&gt;[-+])(?P&lt;zoneh&gt;[0-9][0-9])(?P&lt;zonem&gt;[0-9][0-9])'
        r'"')
</pre> <p>It’s obviously much easier to retrieve <code>m.group('zonem')</code>, instead of having to remember to retrieve group 9.</p> <p>The syntax for backreferences in an expression such as <code>(...)\1</code> refers to the number of the group. There’s naturally a variant that uses the group name instead of the number. This is another Python extension: <code>(?P=name)</code> indicates that the contents of the group called <em>name</em> should again be matched at the current point. The regular expression for finding doubled words, <code>\b(\w+)\s+\1\b</code> can also be written as <code>\b(?P&lt;word&gt;\w+)\s+(?P=word)\b</code>:</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile(r'\b(?P&lt;word&gt;\w+)\s+(?P=word)\b')
&gt;&gt;&gt; p.search('Paris in the the spring').group()
'the the'
</pre> </section> <section id="lookahead-assertions"> <h3>Lookahead Assertions</h3> <p>Another zero-width assertion is the lookahead assertion. Lookahead assertions are available in both positive and negative form, and look like this:</p> <dl class="simple"> <dt>
<code>(?=...)</code> </dt>
<dd>
<p>Positive lookahead assertion. This succeeds if the contained regular expression, represented here by <code>...</code>, successfully matches at the current location, and fails otherwise. But, once the contained expression has been tried, the matching engine doesn’t advance at all; the rest of the pattern is tried right where the assertion started.</p> </dd> <dt>
<code>(?!...)</code> </dt>
<dd>
<p>Negative lookahead assertion. This is the opposite of the positive assertion; it succeeds if the contained expression <em>doesn’t</em> match at the current position in the string.</p> </dd> </dl> <p>To make this concrete, let’s look at a case where a lookahead is useful. Consider a simple pattern to match a filename and split it apart into a base name and an extension, separated by a <code>.</code>. For example, in <code>news.rc</code>, <code>news</code> is the base name, and <code>rc</code> is the filename’s extension.</p> <p>The pattern to match this is quite simple:</p> <p><code>.*[.].*$</code></p> <p>Notice that the <code>.</code> needs to be treated specially because it’s a metacharacter, so it’s inside a character class to only match that specific character. Also notice the trailing <code>$</code>; this is added to ensure that all the rest of the string must be included in the extension. This regular expression matches <code>foo.bar</code> and <code>autoexec.bat</code> and <code>sendmail.cf</code> and <code>printers.conf</code>.</p> <p>Now, consider complicating the problem a bit; what if you want to match filenames where the extension is not <code>bat</code>? Some incorrect attempts:</p> <p><code>.*[.][^b].*$</code> The first attempt above tries to exclude <code>bat</code> by requiring that the first character of the extension is not a <code>b</code>. This is wrong, because the pattern also doesn’t match <code>foo.bar</code>.</p> <p><code>.*[.]([^b]..|.[^a].|..[^t])$</code></p> <p>The expression gets messier when you try to patch up the first solution by requiring one of the following cases to match: the first character of the extension isn’t <code>b</code>; the second character isn’t <code>a</code>; or the third character isn’t <code>t</code>. This accepts <code>foo.bar</code> and rejects <code>autoexec.bat</code>, but it requires a three-letter extension and won’t accept a filename with a two-letter extension such as <code>sendmail.cf</code>. We’ll complicate the pattern again in an effort to fix it.</p> <p><code>.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$</code></p> <p>In the third attempt, the second and third letters are all made optional in order to allow matching extensions shorter than three characters, such as <code>sendmail.cf</code>.</p> <p>The pattern’s getting really complicated now, which makes it hard to read and understand. Worse, if the problem changes and you want to exclude both <code>bat</code> and <code>exe</code> as extensions, the pattern would get even more complicated and confusing.</p> <p>A negative lookahead cuts through all this confusion:</p> <p><code>.*[.](?!bat$)[^.]*$</code> The negative lookahead means: if the expression <code>bat</code> doesn’t match at this point, try the rest of the pattern; if <code>bat$</code> does match, the whole pattern will fail. The trailing <code>$</code> is required to ensure that something like <code>sample.batch</code>, where the extension only starts with <code>bat</code>, will be allowed. The <code>[^.]*</code> makes sure that the pattern works when there are multiple dots in the filename.</p> <p>Excluding another filename extension is now easy; simply add it as an alternative inside the assertion. The following pattern excludes filenames that end in either <code>bat</code> or <code>exe</code>:</p> <p><code>.*[.](?!bat$|exe$)[^.]*$</code></p> </section> </section> <section id="modifying-strings"> <h2>Modifying Strings</h2> <p>Up to this point, we’ve simply performed searches against a static string. Regular expressions are also commonly used to modify strings in various ways, using the following pattern methods:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Method/Attribute</p></th> <th class="head"><p>Purpose</p></th> </tr> </thead>  <tr>
<td><p><code>split()</code></p></td> <td><p>Split the string into a list, splitting it wherever the RE matches</p></td> </tr> <tr>
<td><p><code>sub()</code></p></td> <td><p>Find all substrings where the RE matches, and replace them with a different string</p></td> </tr> <tr>
<td><p><code>subn()</code></p></td> <td><p>Does the same thing as <code>sub()</code>, but returns the new string and the number of replacements</p></td> </tr>  </table> <section id="splitting-strings"> <h3>Splitting Strings</h3> <p>The <a class="reference internal" href="../library/re.html#re.Pattern.split" title="re.Pattern.split"><code>split()</code></a> method of a pattern splits a string apart wherever the RE matches, returning a list of the pieces. It’s similar to the <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code>split()</code></a> method of strings but provides much more generality in the delimiters that you can split by; string <code>split()</code> only supports splitting by whitespace or by a fixed string. As you’d expect, there’s a module-level <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code>re.split()</code></a> function, too.</p> <dl class="py method"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">.</span><span class="sig-name descname">split</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">string</span></em><span class="optional">[</span>, <em class="sig-param"><span class="n">maxsplit=0</span></em><span class="optional">]</span><span class="sig-paren">)</span>
</dt> <dd>
<p>Split <em>string</em> by the matches of the regular expression. If capturing parentheses are used in the RE, then their contents will also be returned as part of the resulting list. If <em>maxsplit</em> is nonzero, at most <em>maxsplit</em> splits are performed.</p> </dd>
</dl> <p>You can limit the number of splits made, by passing a value for <em>maxsplit</em>. When <em>maxsplit</em> is nonzero, at most <em>maxsplit</em> splits will be made, and the remainder of the string is returned as the final element of the list. In the following example, the delimiter is any sequence of non-alphanumeric characters.</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile(r'\W+')
&gt;&gt;&gt; p.split('This is a test, short and sweet, of split().')
['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']
&gt;&gt;&gt; p.split('This is a test, short and sweet, of split().', 3)
['This', 'is', 'a', 'test, short and sweet, of split().']
</pre> <p>Sometimes you’re not only interested in what the text between delimiters is, but also need to know what the delimiter was. If capturing parentheses are used in the RE, then their values are also returned as part of the list. Compare the following calls:</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile(r'\W+')
&gt;&gt;&gt; p2 = re.compile(r'(\W+)')
&gt;&gt;&gt; p.split('This... is a test.')
['This', 'is', 'a', 'test', '']
&gt;&gt;&gt; p2.split('This... is a test.')
['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']
</pre> <p>The module-level function <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code>re.split()</code></a> adds the RE to be used as the first argument, but is otherwise the same.</p> <pre data-language="python">&gt;&gt;&gt; re.split(r'[\W]+', 'Words, words, words.')
['Words', 'words', 'words', '']
&gt;&gt;&gt; re.split(r'([\W]+)', 'Words, words, words.')
['Words', ', ', 'words', ', ', 'words', '.', '']
&gt;&gt;&gt; re.split(r'[\W]+', 'Words, words, words.', 1)
['Words', 'words, words.']
</pre> </section> <section id="search-and-replace"> <h3>Search and Replace</h3> <p>Another common task is to find all the matches for a pattern, and replace them with a different string. The <a class="reference internal" href="../library/re.html#re.Pattern.sub" title="re.Pattern.sub"><code>sub()</code></a> method takes a replacement value, which can be either a string or a function, and the string to be processed.</p> <dl class="py method"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">.</span><span class="sig-name descname">sub</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">replacement</span></em>, <em class="sig-param"><span class="n">string</span></em><span class="optional">[</span>, <em class="sig-param"><span class="n">count=0</span></em><span class="optional">]</span><span class="sig-paren">)</span>
</dt> <dd>
<p>Returns the string obtained by replacing the leftmost non-overlapping occurrences of the RE in <em>string</em> by the replacement <em>replacement</em>. If the pattern isn’t found, <em>string</em> is returned unchanged.</p> <p>The optional argument <em>count</em> is the maximum number of pattern occurrences to be replaced; <em>count</em> must be a non-negative integer. The default value of 0 means to replace all occurrences.</p> </dd>
</dl> <p>Here’s a simple example of using the <a class="reference internal" href="../library/re.html#re.Pattern.sub" title="re.Pattern.sub"><code>sub()</code></a> method. It replaces colour names with the word <code>colour</code>:</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile('(blue|white|red)')
&gt;&gt;&gt; p.sub('colour', 'blue socks and red shoes')
'colour socks and colour shoes'
&gt;&gt;&gt; p.sub('colour', 'blue socks and red shoes', count=1)
'colour socks and red shoes'
</pre> <p>The <a class="reference internal" href="../library/re.html#re.Pattern.subn" title="re.Pattern.subn"><code>subn()</code></a> method does the same work, but returns a 2-tuple containing the new string value and the number of replacements that were performed:</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile('(blue|white|red)')
&gt;&gt;&gt; p.subn('colour', 'blue socks and red shoes')
('colour socks and colour shoes', 2)
&gt;&gt;&gt; p.subn('colour', 'no colours at all')
('no colours at all', 0)
</pre> <p>Empty matches are replaced only when they’re not adjacent to a previous empty match.</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile('x*')
&gt;&gt;&gt; p.sub('-', 'abxd')
'-a-b--d-'
</pre> <p>If <em>replacement</em> is a string, any backslash escapes in it are processed. That is, <code>\n</code> is converted to a single newline character, <code>\r</code> is converted to a carriage return, and so forth. Unknown escapes such as <code>\&amp;</code> are left alone. Backreferences, such as <code>\6</code>, are replaced with the substring matched by the corresponding group in the RE. This lets you incorporate portions of the original text in the resulting replacement string.</p> <p>This example matches the word <code>section</code> followed by a string enclosed in <code>{</code>, <code>}</code>, and changes <code>section</code> to <code>subsection</code>:</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)
&gt;&gt;&gt; p.sub(r'subsection{\1}','section{First} section{second}')
'subsection{First} subsection{second}'
</pre> <p>There’s also a syntax for referring to named groups as defined by the <code>(?P&lt;name&gt;...)</code> syntax. <code>\g&lt;name&gt;</code> will use the substring matched by the group named <code>name</code>, and <code>\g&lt;number&gt;</code> uses the corresponding group number. <code>\g&lt;2&gt;</code> is therefore equivalent to <code>\2</code>, but isn’t ambiguous in a replacement string such as <code>\g&lt;2&gt;0</code>. (<code>\20</code> would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character <code>'0'</code>.) The following substitutions are all equivalent, but use all three variations of the replacement string.</p> <pre data-language="python">&gt;&gt;&gt; p = re.compile('section{ (?P&lt;name&gt; [^}]* ) }', re.VERBOSE)
&gt;&gt;&gt; p.sub(r'subsection{\1}','section{First}')
'subsection{First}'
&gt;&gt;&gt; p.sub(r'subsection{\g&lt;1&gt;}','section{First}')
'subsection{First}'
&gt;&gt;&gt; p.sub(r'subsection{\g&lt;name&gt;}','section{First}')
'subsection{First}'
</pre> <p><em>replacement</em> can also be a function, which gives you even more control. If <em>replacement</em> is a function, the function is called for every non-overlapping occurrence of <em>pattern</em>. On each call, the function is passed a <a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">match object</span></a> argument for the match and can use this information to compute the desired replacement string and return it.</p> <p>In the following example, the replacement function translates decimals into hexadecimal:</p> <pre data-language="python">&gt;&gt;&gt; def hexrepl(match):
...     "Return the hex string for a decimal number"
...     value = int(match.group())
...     return hex(value)
...
&gt;&gt;&gt; p = re.compile(r'\d+')
&gt;&gt;&gt; p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')
'Call 0xffd2 for printing, 0xc000 for user code.'
</pre> <p>When using the module-level <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code>re.sub()</code></a> function, the pattern is passed as the first argument. The pattern may be provided as an object or as a string; if you need to specify regular expression flags, you must either use a pattern object as the first parameter, or use embedded modifiers in the pattern string, e.g. <code>sub("(?i)b+", "x", "bbbb BBBB")</code> returns <code>'x x'</code>.</p> </section> </section> <section id="common-problems"> <h2>Common Problems</h2> <p>Regular expressions are a powerful tool for some applications, but in some ways their behaviour isn’t intuitive and at times they don’t behave the way you may expect them to. This section will point out some of the most common pitfalls.</p> <section id="use-string-methods"> <h3>Use String Methods</h3> <p>Sometimes using the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> module is a mistake. If you’re matching a fixed string, or a single character class, and you’re not using any <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> features such as the <a class="reference internal" href="../library/re.html#re.IGNORECASE" title="re.IGNORECASE"><code>IGNORECASE</code></a> flag, then the full power of regular expressions may not be required. Strings have several methods for performing operations with fixed strings and they’re usually much faster, because the implementation is a single small C loop that’s been optimized for the purpose, instead of the large, more generalized regular expression engine.</p> <p>One example might be replacing a single fixed string with another one; for example, you might replace <code>word</code> with <code>deed</code>. <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code>re.sub()</code></a> seems like the function to use for this, but consider the <a class="reference internal" href="../library/stdtypes.html#str.replace" title="str.replace"><code>replace()</code></a> method. Note that <code>replace()</code> will also replace <code>word</code> inside words, turning <code>swordfish</code> into <code>sdeedfish</code>, but the naive RE <code>word</code> would have done that, too. (To avoid performing the substitution on parts of words, the pattern would have to be <code>\bword\b</code>, in order to require that <code>word</code> have a word boundary on either side. This takes the job beyond <code>replace()</code>’s abilities.)</p> <p>Another common task is deleting every occurrence of a single character from a string or replacing it with another single character. You might do this with something like <code>re.sub('\n', ' ', S)</code>, but <a class="reference internal" href="../library/stdtypes.html#str.translate" title="str.translate"><code>translate()</code></a> is capable of doing both tasks and will be faster than any regular expression operation can be.</p> <p>In short, before turning to the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> module, consider whether your problem can be solved with a faster and simpler string method.</p> </section> <section id="match-versus-search"> <h3>match() versus search()</h3> <p>The <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code>match()</code></a> function only checks if the RE matches at the beginning of the string while <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code>search()</code></a> will scan forward through the string for a match. It’s important to keep this distinction in mind. Remember, <code>match()</code> will only report a successful match which will start at 0; if the match wouldn’t start at zero, <code>match()</code> will <em>not</em> report it.</p> <pre data-language="python">&gt;&gt;&gt; print(re.match('super', 'superstition').span())
(0, 5)
&gt;&gt;&gt; print(re.match('super', 'insuperable'))
None
</pre> <p>On the other hand, <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code>search()</code></a> will scan forward through the string, reporting the first match it finds.</p> <pre data-language="python">&gt;&gt;&gt; print(re.search('super', 'superstition').span())
(0, 5)
&gt;&gt;&gt; print(re.search('super', 'insuperable').span())
(2, 7)
</pre> <p>Sometimes you’ll be tempted to keep using <a class="reference internal" href="../library/re.html#re.match" title="re.match"><code>re.match()</code></a>, and just add <code>.*</code> to the front of your RE. Resist this temptation and use <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code>re.search()</code></a> instead. The regular expression compiler does some analysis of REs in order to speed up the process of looking for a match. One such analysis figures out what the first character of a match must be; for example, a pattern starting with <code>Crow</code> must match starting with a <code>'C'</code>. The analysis lets the engine quickly scan through the string looking for the starting character, only trying the full match if a <code>'C'</code> is found.</p> <p>Adding <code>.*</code> defeats this optimization, requiring scanning to the end of the string and then backtracking to find a match for the rest of the RE. Use <a class="reference internal" href="../library/re.html#re.search" title="re.search"><code>re.search()</code></a> instead.</p> </section> <section id="greedy-versus-non-greedy"> <h3>Greedy versus Non-Greedy</h3> <p>When repeating a regular expression, as in <code>a*</code>, the resulting action is to consume as much of the pattern as possible. This fact often bites you when you’re trying to match a pair of balanced delimiters, such as the angle brackets surrounding an HTML tag. The naive pattern for matching a single HTML tag doesn’t work because of the greedy nature of <code>.*</code>.</p> <pre data-language="python">&gt;&gt;&gt; s = '&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;'
&gt;&gt;&gt; len(s)
32
&gt;&gt;&gt; print(re.match('&lt;.*&gt;', s).span())
(0, 32)
&gt;&gt;&gt; print(re.match('&lt;.*&gt;', s).group())
&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;
</pre> <p>The RE matches the <code>'&lt;'</code> in <code>'&lt;html&gt;'</code>, and the <code>.*</code> consumes the rest of the string. There’s still more left in the RE, though, and the <code>&gt;</code> can’t match at the end of the string, so the regular expression engine has to backtrack character by character until it finds a match for the <code>&gt;</code>. The final match extends from the <code>'&lt;'</code> in <code>'&lt;html&gt;'</code> to the <code>'&gt;'</code> in <code>'&lt;/title&gt;'</code>, which isn’t what you want.</p> <p>In this case, the solution is to use the non-greedy quantifiers <code>*?</code>, <code>+?</code>, <code>??</code>, or <code>{m,n}?</code>, which match as <em>little</em> text as possible. In the above example, the <code>'&gt;'</code> is tried immediately after the first <code>'&lt;'</code> matches, and when it fails, the engine advances a character at a time, retrying the <code>'&gt;'</code> at every step. This produces just the right result:</p> <pre data-language="python">&gt;&gt;&gt; print(re.match('&lt;.*?&gt;', s).group())
&lt;html&gt;
</pre> <p>(Note that parsing HTML or XML with regular expressions is painful. Quick-and-dirty patterns will handle common cases, but HTML and XML have special cases that will break the obvious regular expression; by the time you’ve written a regular expression that handles all of the possible cases, the patterns will be <em>very</em> complicated. Use an HTML or XML parser module for such tasks.)</p> </section> <section id="using-re-verbose"> <h3>Using re.VERBOSE</h3> <p>By now you’ve probably noticed that regular expressions are a very compact notation, but they’re not terribly readable. REs of moderate complexity can become lengthy collections of backslashes, parentheses, and metacharacters, making them difficult to read and understand.</p> <p>For such REs, specifying the <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code>re.VERBOSE</code></a> flag when compiling the regular expression can be helpful, because it allows you to format the regular expression more clearly.</p> <p>The <code>re.VERBOSE</code> flag has several effects. Whitespace in the regular expression that <em>isn’t</em> inside a character class is ignored. This means that an expression such as <code>dog | cat</code> is equivalent to the less readable <code>dog|cat</code>, but <code>[a b]</code> will still match the characters <code>'a'</code>, <code>'b'</code>, or a space. In addition, you can also put comments inside a RE; comments extend from a <code>#</code> character to the next newline. When used with triple-quoted strings, this enables REs to be formatted more neatly:</p> <pre data-language="python">pat = re.compile(r"""
 \s*                 # Skip leading whitespace
 (?P&lt;header&gt;[^:]+)   # Header name
 \s* :               # Whitespace, and a colon
 (?P&lt;value&gt;.*?)      # The header's value -- *? used to
                     # lose the following trailing whitespace
 \s*$                # Trailing whitespace to end-of-line
""", re.VERBOSE)
</pre> <p>This is far more readable than:</p> <pre data-language="python">pat = re.compile(r"\s*(?P&lt;header&gt;[^:]+)\s*:(?P&lt;value&gt;.*?)\s*$")
</pre> </section> </section> <section id="feedback"> <h2>Feedback</h2> <p>Regular expressions are a complicated topic. Did this document help you understand them? Were there parts that were unclear, or Problems you encountered that weren’t covered here? If so, please send suggestions for improvements to the author.</p> <p>The most complete book on regular expressions is almost certainly Jeffrey Friedl’s Mastering Regular Expressions, published by O’Reilly. Unfortunately, it exclusively concentrates on Perl and Java’s flavours of regular expressions, and doesn’t contain any Python material at all, so it won’t be useful as a reference for programming in Python. (The first edition covered Python’s now-removed <code>regex</code> module, which won’t help you much.) Consider checking it out from your library.</p> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/howto/regex.html" class="_attribution-link">https://docs.python.org/3.13/howto/regex.html</a>
  </p>
</div>
