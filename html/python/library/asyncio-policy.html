 <span id="asyncio-policies"></span><h1>Policies</h1> <p>An event loop policy is a global object used to get and set the current <a class="reference internal" href="asyncio-eventloop.html#asyncio-event-loop"><span class="std std-ref">event loop</span></a>, as well as create new event loops. The default policy can be <a class="reference internal" href="#asyncio-policy-get-set"><span class="std std-ref">replaced</span></a> with <a class="reference internal" href="#asyncio-policy-builtin"><span class="std std-ref">built-in alternatives</span></a> to use different event loop implementations, or substituted by a <a class="reference internal" href="#asyncio-custom-policies"><span class="std std-ref">custom policy</span></a> that can override these behaviors.</p> <p>The <a class="reference internal" href="#asyncio-policy-objects"><span class="std std-ref">policy object</span></a> gets and sets a separate event loop per <em>context</em>. This is per-thread by default, though custom policies could define <em>context</em> differently.</p> <p>Custom event loop policies can control the behavior of <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_event_loop" title="asyncio.get_event_loop"><code>get_event_loop()</code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.set_event_loop" title="asyncio.set_event_loop"><code>set_event_loop()</code></a>, and <a class="reference internal" href="asyncio-eventloop.html#asyncio.new_event_loop" title="asyncio.new_event_loop"><code>new_event_loop()</code></a>.</p> <p>Policy objects should implement the APIs defined in the <a class="reference internal" href="#asyncio.AbstractEventLoopPolicy" title="asyncio.AbstractEventLoopPolicy"><code>AbstractEventLoopPolicy</code></a> abstract base class.</p> <section id="getting-and-setting-the-policy"> <span id="asyncio-policy-get-set"></span><h2>Getting and Setting the Policy</h2> <p>The following functions can be used to get and set the policy for the current process:</p> <dl class="py function"> <dt class="sig sig-object py" id="asyncio.get_event_loop_policy">
<code>asyncio.get_event_loop_policy()</code> </dt> <dd>
<p>Return the current process-wide policy.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="asyncio.set_event_loop_policy">
<code>asyncio.set_event_loop_policy(policy)</code> </dt> <dd>
<p>Set the current process-wide policy to <em>policy</em>.</p> <p>If <em>policy</em> is set to <code>None</code>, the default policy is restored.</p> </dd>
</dl> </section> <section id="policy-objects"> <span id="asyncio-policy-objects"></span><h2>Policy Objects</h2> <p>The abstract event loop policy base class is defined as follows:</p> <dl class="py class"> <dt class="sig sig-object py" id="asyncio.AbstractEventLoopPolicy">
<code>class asyncio.AbstractEventLoopPolicy</code> </dt> <dd>
<p>An abstract base class for asyncio policies.</p> <dl class="py method"> <dt class="sig sig-object py" id="asyncio.AbstractEventLoopPolicy.get_event_loop">
<code>get_event_loop()</code> </dt> <dd>
<p>Get the event loop for the current context.</p> <p>Return an event loop object implementing the <a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code>AbstractEventLoop</code></a> interface.</p> <p>This method should never return <code>None</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="asyncio.AbstractEventLoopPolicy.set_event_loop">
<code>set_event_loop(loop)</code> </dt> <dd>
<p>Set the event loop for the current context to <em>loop</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="asyncio.AbstractEventLoopPolicy.new_event_loop">
<code>new_event_loop()</code> </dt> <dd>
<p>Create and return a new event loop object.</p> <p>This method should never return <code>None</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="asyncio.AbstractEventLoopPolicy.get_child_watcher">
<code>get_child_watcher()</code> </dt> <dd>
<p>Get a child process watcher object.</p> <p>Return a watcher object implementing the <a class="reference internal" href="#asyncio.AbstractChildWatcher" title="asyncio.AbstractChildWatcher"><code>AbstractChildWatcher</code></a> interface.</p> <p>This function is Unix specific.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="asyncio.AbstractEventLoopPolicy.set_child_watcher">
<code>set_child_watcher(watcher)</code> </dt> <dd>
<p>Set the current child process watcher to <em>watcher</em>.</p> <p>This function is Unix specific.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12.</span></p> </div> </dd>
</dl> </dd>
</dl> <p id="asyncio-policy-builtin">asyncio ships with the following built-in policies:</p> <dl class="py class"> <dt class="sig sig-object py" id="asyncio.DefaultEventLoopPolicy">
<code>class asyncio.DefaultEventLoopPolicy</code> </dt> <dd>
<p>The default asyncio policy. Uses <a class="reference internal" href="asyncio-eventloop.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code>SelectorEventLoop</code></a> on Unix and <a class="reference internal" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code>ProactorEventLoop</code></a> on Windows.</p> <p>There is no need to install the default policy manually. asyncio is configured to use the default policy automatically.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>On Windows, <a class="reference internal" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code>ProactorEventLoop</code></a> is now used by default.</p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12: </span>The <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_event_loop" title="asyncio.get_event_loop"><code>get_event_loop()</code></a> method of the default asyncio policy now emits a <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code>DeprecationWarning</code></a> if there is no current event loop set and it decides to create one. In some future Python release this will become an error.</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="asyncio.WindowsSelectorEventLoopPolicy">
<code>class asyncio.WindowsSelectorEventLoopPolicy</code> </dt> <dd>
<p>An alternative event loop policy that uses the <a class="reference internal" href="asyncio-eventloop.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code>SelectorEventLoop</code></a> event loop implementation.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.12/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="asyncio.WindowsProactorEventLoopPolicy">
<code>class asyncio.WindowsProactorEventLoopPolicy</code> </dt> <dd>
<p>An alternative event loop policy that uses the <a class="reference internal" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code>ProactorEventLoop</code></a> event loop implementation.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.12/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> </dd>
</dl> </section> <section id="process-watchers"> <span id="asyncio-watchers"></span><h2>Process Watchers</h2> <p>A process watcher allows customization of how an event loop monitors child processes on Unix. Specifically, the event loop needs to know when a child process has exited.</p> <p>In asyncio, child processes are created with <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_exec" title="asyncio.create_subprocess_exec"><code>create_subprocess_exec()</code></a> and <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code>loop.subprocess_exec()</code></a> functions.</p> <p>asyncio defines the <a class="reference internal" href="#asyncio.AbstractChildWatcher" title="asyncio.AbstractChildWatcher"><code>AbstractChildWatcher</code></a> abstract base class, which child watchers should implement, and has four different implementations: <a class="reference internal" href="#asyncio.ThreadedChildWatcher" title="asyncio.ThreadedChildWatcher"><code>ThreadedChildWatcher</code></a> (configured to be used by default), <a class="reference internal" href="#asyncio.MultiLoopChildWatcher" title="asyncio.MultiLoopChildWatcher"><code>MultiLoopChildWatcher</code></a>, <a class="reference internal" href="#asyncio.SafeChildWatcher" title="asyncio.SafeChildWatcher"><code>SafeChildWatcher</code></a>, and <a class="reference internal" href="#asyncio.FastChildWatcher" title="asyncio.FastChildWatcher"><code>FastChildWatcher</code></a>.</p> <p>See also the <a class="reference internal" href="asyncio-subprocess.html#asyncio-subprocess-threads"><span class="std std-ref">Subprocess and Threads</span></a> section.</p> <p>The following two functions can be used to customize the child process watcher implementation used by the asyncio event loop:</p> <dl class="py function"> <dt class="sig sig-object py" id="asyncio.get_child_watcher">
<code>asyncio.get_child_watcher()</code> </dt> <dd>
<p>Return the current child watcher for the current policy.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="asyncio.set_child_watcher">
<code>asyncio.set_child_watcher(watcher)</code> </dt> <dd>
<p>Set the current child watcher to <em>watcher</em> for the current policy. <em>watcher</em> must implement methods defined in the <a class="reference internal" href="#asyncio.AbstractChildWatcher" title="asyncio.AbstractChildWatcher"><code>AbstractChildWatcher</code></a> base class.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12.</span></p> </div> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Third-party event loops implementations might not support custom child watchers. For such event loops, using <a class="reference internal" href="#asyncio.set_child_watcher" title="asyncio.set_child_watcher"><code>set_child_watcher()</code></a> might be prohibited or have no effect.</p> </div> <dl class="py class"> <dt class="sig sig-object py" id="asyncio.AbstractChildWatcher">
<code>class asyncio.AbstractChildWatcher</code> </dt> <dd>
<dl class="py method"> <dt class="sig sig-object py" id="asyncio.AbstractChildWatcher.add_child_handler">
<code>add_child_handler(pid, callback, *args)</code> </dt> <dd>
<p>Register a new child handler.</p> <p>Arrange for <code>callback(pid, returncode, *args)</code> to be called when a process with PID equal to <em>pid</em> terminates. Specifying another callback for the same process replaces the previous handler.</p> <p>The <em>callback</em> callable must be thread-safe.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="asyncio.AbstractChildWatcher.remove_child_handler">
<code>remove_child_handler(pid)</code> </dt> <dd>
<p>Removes the handler for process with PID equal to <em>pid</em>.</p> <p>The function returns <code>True</code> if the handler was successfully removed, <code>False</code> if there was nothing to remove.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="asyncio.AbstractChildWatcher.attach_loop">
<code>attach_loop(loop)</code> </dt> <dd>
<p>Attach the watcher to an event loop.</p> <p>If the watcher was previously attached to an event loop, then it is first detached before attaching to the new loop.</p> <p>Note: loop may be <code>None</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="asyncio.AbstractChildWatcher.is_active">
<code>is_active()</code> </dt> <dd>
<p>Return <code>True</code> if the watcher is ready to use.</p> <p>Spawning a subprocess with <em>inactive</em> current child watcher raises <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="asyncio.AbstractChildWatcher.close">
<code>close()</code> </dt> <dd>
<p>Close the watcher.</p> <p>This method has to be called to ensure that underlying resources are cleaned-up.</p> </dd>
</dl> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="asyncio.ThreadedChildWatcher">
<code>class asyncio.ThreadedChildWatcher</code> </dt> <dd>
<p>This implementation starts a new waiting thread for every subprocess spawn.</p> <p>It works reliably even when the asyncio event loop is run in a non-main OS thread.</p> <p>There is no noticeable overhead when handling a big number of children (<em>O(1)</em> each time a child terminates), but starting a thread per process requires extra memory.</p> <p>This watcher is used by default.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="asyncio.MultiLoopChildWatcher">
<code>class asyncio.MultiLoopChildWatcher</code> </dt> <dd>
<p>This implementation registers a <code>SIGCHLD</code> signal handler on instantiation. That can break third-party code that installs a custom handler for <code>SIGCHLD</code> signal.</p> <p>The watcher avoids disrupting other code spawning processes by polling every process explicitly on a <code>SIGCHLD</code> signal.</p> <p>There is no limitation for running subprocesses from different threads once the watcher is installed.</p> <p>The solution is safe but it has a significant overhead when handling a big number of processes (<em>O(n)</em> each time a <code>SIGCHLD</code> is received).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="asyncio.SafeChildWatcher">
<code>class asyncio.SafeChildWatcher</code> </dt> <dd>
<p>This implementation uses active event loop from the main thread to handle <code>SIGCHLD</code> signal. If the main thread has no running event loop another thread cannot spawn a subprocess (<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised).</p> <p>The watcher avoids disrupting other code spawning processes by polling every process explicitly on a <code>SIGCHLD</code> signal.</p> <p>This solution is as safe as <a class="reference internal" href="#asyncio.MultiLoopChildWatcher" title="asyncio.MultiLoopChildWatcher"><code>MultiLoopChildWatcher</code></a> and has the same <em>O(N)</em> complexity but requires a running event loop in the main thread to work.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="asyncio.FastChildWatcher">
<code>class asyncio.FastChildWatcher</code> </dt> <dd>
<p>This implementation reaps every terminated processes by calling <code>os.waitpid(-1)</code> directly, possibly breaking other code spawning processes and waiting for their termination.</p> <p>There is no noticeable overhead when handling a big number of children (<em>O(1)</em> each time a child terminates).</p> <p>This solution requires a running event loop in the main thread to work, as <a class="reference internal" href="#asyncio.SafeChildWatcher" title="asyncio.SafeChildWatcher"><code>SafeChildWatcher</code></a>.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.12.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="asyncio.PidfdChildWatcher">
<code>class asyncio.PidfdChildWatcher</code> </dt> <dd>
<p>This implementation polls process file descriptors (pidfds) to await child process termination. In some respects, <a class="reference internal" href="#asyncio.PidfdChildWatcher" title="asyncio.PidfdChildWatcher"><code>PidfdChildWatcher</code></a> is a “Goldilocks” child watcher implementation. It doesn’t require signals or threads, doesn’t interfere with any processes launched outside the event loop, and scales linearly with the number of subprocesses launched by the event loop. The main disadvantage is that pidfds are specific to Linux, and only work on recent (5.3+) kernels.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> </section> <section id="custom-policies"> <span id="asyncio-custom-policies"></span><h2>Custom Policies</h2> <p>To implement a new event loop policy, it is recommended to subclass <a class="reference internal" href="#asyncio.DefaultEventLoopPolicy" title="asyncio.DefaultEventLoopPolicy"><code>DefaultEventLoopPolicy</code></a> and override the methods for which custom behavior is wanted, e.g.:</p> <pre data-language="python">class MyEventLoopPolicy(asyncio.DefaultEventLoopPolicy):

    def get_event_loop(self):
        """Get the event loop.

        This may be None or an instance of EventLoop.
        """
        loop = super().get_event_loop()
        # Do something with loop ...
        return loop

asyncio.set_event_loop_policy(MyEventLoopPolicy())
</pre> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/asyncio-policy.html" class="_attribution-link">https://docs.python.org/3.12/library/asyncio-policy.html</a>
  </p>
</div>
