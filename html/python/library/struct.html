 <h1>struct — Interpret bytes as packed binary data</h1> <p id="module-struct"><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/struct.py">Lib/struct.py</a></p>  <p>This module converts between Python values and C structs represented as Python <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> objects. Compact <a class="reference internal" href="#struct-format-strings"><span class="std std-ref">format strings</span></a> describe the intended conversions to/from Python values. The module’s functions and objects can be used for two largely distinct applications, data exchange with external sources (files or network connections), or data transfer between the Python application and the C layer.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When no prefix character is given, native mode is the default. It packs or unpacks data based on the platform and compiler on which the Python interpreter was built. The result of packing a given C struct includes pad bytes which maintain proper alignment for the C types involved; similarly, alignment is taken into account when unpacking. In contrast, when communicating data between external sources, the programmer is responsible for defining byte ordering and padding between elements. See <a class="reference internal" href="#struct-alignment"><span class="std std-ref">Byte Order, Size, and Alignment</span></a> for details.</p> </div> <p>Several <a class="reference internal" href="#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> functions (and methods of <a class="reference internal" href="#struct.Struct" title="struct.Struct"><code>Struct</code></a>) take a <em>buffer</em> argument. This refers to objects that implement the <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">Buffer Protocol</span></a> and provide either a readable or read-writable buffer. The most common types used for that purpose are <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> and <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a>, but many other types that can be viewed as an array of bytes implement the buffer protocol, so that they can be read/filled without additional copying from a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object.</p> <section id="functions-and-exceptions"> <h2>Functions and Exceptions</h2> <p>The module defines the following exception and functions:</p> <dl class="py exception"> <dt class="sig sig-object py" id="struct.error">
<code>exception struct.error</code> </dt> <dd>
<p>Exception raised on various occasions; argument is a string describing what is wrong.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="struct.pack">
<code>struct.pack(format, v1, v2, ...)</code> </dt> <dd>
<p>Return a bytes object containing the values <em>v1</em>, <em>v2</em>, … packed according to the format string <em>format</em>. The arguments must match the values required by the format exactly.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="struct.pack_into">
<code>struct.pack_into(format, buffer, offset, v1, v2, ...)</code> </dt> <dd>
<p>Pack the values <em>v1</em>, <em>v2</em>, … according to the format string <em>format</em> and write the packed bytes into the writable buffer <em>buffer</em> starting at position <em>offset</em>. Note that <em>offset</em> is a required argument.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="struct.unpack">
<code>struct.unpack(format, buffer)</code> </dt> <dd>
<p>Unpack from the buffer <em>buffer</em> (presumably packed by <code>pack(format, ...)</code>) according to the format string <em>format</em>. The result is a tuple even if it contains exactly one item. The buffer’s size in bytes must match the size required by the format, as reflected by <a class="reference internal" href="#struct.calcsize" title="struct.calcsize"><code>calcsize()</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="struct.unpack_from">
<code>struct.unpack_from(format, /, buffer, offset=0)</code> </dt> <dd>
<p>Unpack from <em>buffer</em> starting at position <em>offset</em>, according to the format string <em>format</em>. The result is a tuple even if it contains exactly one item. The buffer’s size in bytes, starting at position <em>offset</em>, must be at least the size required by the format, as reflected by <a class="reference internal" href="#struct.calcsize" title="struct.calcsize"><code>calcsize()</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="struct.iter_unpack">
<code>struct.iter_unpack(format, buffer)</code> </dt> <dd>
<p>Iteratively unpack from the buffer <em>buffer</em> according to the format string <em>format</em>. This function returns an iterator which will read equally sized chunks from the buffer until all its contents have been consumed. The buffer’s size in bytes must be a multiple of the size required by the format, as reflected by <a class="reference internal" href="#struct.calcsize" title="struct.calcsize"><code>calcsize()</code></a>.</p> <p>Each iteration yields a tuple as specified by the format string.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="struct.calcsize">
<code>struct.calcsize(format)</code> </dt> <dd>
<p>Return the size of the struct (and hence of the bytes object produced by <code>pack(format, ...)</code>) corresponding to the format string <em>format</em>.</p> </dd>
</dl> </section> <section id="format-strings"> <span id="struct-format-strings"></span><h2>Format Strings</h2> <p>Format strings describe the data layout when packing and unpacking data. They are built up from <a class="reference internal" href="#format-characters"><span class="std std-ref">format characters</span></a>, which specify the type of data being packed/unpacked. In addition, special characters control the <a class="reference internal" href="#struct-alignment"><span class="std std-ref">byte order, size and alignment</span></a>. Each format string consists of an optional prefix character which describes the overall properties of the data and one or more format characters which describe the actual data values and padding.</p> <section id="byte-order-size-and-alignment"> <span id="struct-alignment"></span><h3>Byte Order, Size, and Alignment</h3> <p>By default, C types are represented in the machine’s native format and byte order, and properly aligned by skipping pad bytes if necessary (according to the rules used by the C compiler). This behavior is chosen so that the bytes of a packed struct correspond exactly to the memory layout of the corresponding C struct. Whether to use native byte ordering and padding or standard formats depends on the application.</p> <p id="index-1">Alternatively, the first character of the format string can be used to indicate the byte order, size and alignment of the packed data, according to the following table:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Character</p></th> <th class="head"><p>Byte order</p></th> <th class="head"><p>Size</p></th> <th class="head"><p>Alignment</p></th> </tr> </thead>  <tr>
<td><p><code>@</code></p></td> <td><p>native</p></td> <td><p>native</p></td> <td><p>native</p></td> </tr> <tr>
<td><p><code>=</code></p></td> <td><p>native</p></td> <td><p>standard</p></td> <td><p>none</p></td> </tr> <tr>
<td><p><code>&lt;</code></p></td> <td><p>little-endian</p></td> <td><p>standard</p></td> <td><p>none</p></td> </tr> <tr>
<td><p><code>&gt;</code></p></td> <td><p>big-endian</p></td> <td><p>standard</p></td> <td><p>none</p></td> </tr> <tr>
<td><p><code>!</code></p></td> <td><p>network (= big-endian)</p></td> <td><p>standard</p></td> <td><p>none</p></td> </tr>  </table> <p>If the first character is not one of these, <code>'@'</code> is assumed.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The number 1023 (<code>0x3ff</code> in hexadecimal) has the following byte representations:</p> <ul class="simple"> <li>
<code>03 ff</code> in big-endian (<code>&gt;</code>)</li> <li>
<code>ff 03</code> in little-endian (<code>&lt;</code>)</li> </ul> <p>Python example:</p> <pre data-language="python">&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack('&gt;h', 1023)
b'\x03\xff'
&gt;&gt;&gt; struct.pack('&lt;h', 1023)
b'\xff\x03'
</pre> </div> <p>Native byte order is big-endian or little-endian, depending on the host system. For example, Intel x86, AMD64 (x86-64), and Apple M1 are little-endian; IBM z and many legacy architectures are big-endian. Use <a class="reference internal" href="sys.html#sys.byteorder" title="sys.byteorder"><code>sys.byteorder</code></a> to check the endianness of your system.</p> <p>Native size and alignment are determined using the C compiler’s <code>sizeof</code> expression. This is always combined with native byte order.</p> <p>Standard size depends only on the format character; see the table in the <a class="reference internal" href="#format-characters"><span class="std std-ref">Format Characters</span></a> section.</p> <p>Note the difference between <code>'@'</code> and <code>'='</code>: both use native byte order, but the size and alignment of the latter is standardized.</p> <p>The form <code>'!'</code> represents the network byte order which is always big-endian as defined in <a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc1700">IETF RFC 1700</a>.</p> <p>There is no way to indicate non-native byte order (force byte-swapping); use the appropriate choice of <code>'&lt;'</code> or <code>'&gt;'</code>.</p> <p>Notes:</p> <ol class="arabic simple"> <li>Padding is only automatically added between successive structure members. No padding is added at the beginning or the end of the encoded struct.</li> <li>No padding is added when using non-native size and alignment, e.g. with ‘&lt;’, ‘&gt;’, ‘=’, and ‘!’.</li> <li>To align the end of a structure to the alignment requirement of a particular type, end the format with the code for that type with a repeat count of zero. See <a class="reference internal" href="#struct-examples"><span class="std std-ref">Examples</span></a>.</li> </ol> </section> <section id="format-characters"> <span id="id1"></span><h3>Format Characters</h3> <p>Format characters have the following meaning; the conversion between C and Python values should be obvious given their types. The ‘Standard size’ column refers to the size of the packed value in bytes when using standard size; that is, when the format string starts with one of <code>'&lt;'</code>, <code>'&gt;'</code>, <code>'!'</code> or <code>'='</code>. When using native size, the size of the packed value is platform-dependent.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Format</p></th> <th class="head"><p>C Type</p></th> <th class="head"><p>Python type</p></th> <th class="head"><p>Standard size</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p><code>x</code></p></td> <td><p>pad byte</p></td> <td><p>no value</p></td> <td></td> <td><p>(7)</p></td> </tr> <tr>
<td><p><code>c</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span></span></p></td> <td><p>bytes of length 1</p></td> <td><p>1</p></td> <td></td> </tr> <tr>
<td><p><code>b</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span></span></p></td> <td><p>integer</p></td> <td><p>1</p></td> <td><p>(1), (2)</p></td> </tr> <tr>
<td><p><code>B</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span></p></td> <td><p>integer</p></td> <td><p>1</p></td> <td><p>(2)</p></td> </tr> <tr>
<td><p><code>?</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span></p></td> <td><p>bool</p></td> <td><p>1</p></td> <td><p>(1)</p></td> </tr> <tr>
<td><p><code>h</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">short</span></span></p></td> <td><p>integer</p></td> <td><p>2</p></td> <td><p>(2)</p></td> </tr> <tr>
<td><p><code>H</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span></span></p></td> <td><p>integer</p></td> <td><p>2</p></td> <td><p>(2)</p></td> </tr> <tr>
<td><p><code>i</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">int</span></span></p></td> <td><p>integer</p></td> <td><p>4</p></td> <td><p>(2)</p></td> </tr> <tr>
<td><p><code>I</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span></p></td> <td><p>integer</p></td> <td><p>4</p></td> <td><p>(2)</p></td> </tr> <tr>
<td><p><code>l</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">long</span></span></p></td> <td><p>integer</p></td> <td><p>4</p></td> <td><p>(2)</p></td> </tr> <tr>
<td><p><code>L</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span></p></td> <td><p>integer</p></td> <td><p>4</p></td> <td><p>(2)</p></td> </tr> <tr>
<td><p><code>q</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td> <td><p>integer</p></td> <td><p>8</p></td> <td><p>(2)</p></td> </tr> <tr>
<td><p><code>Q</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td> <td><p>integer</p></td> <td><p>8</p></td> <td><p>(2)</p></td> </tr> <tr>
<td><p><code>n</code></p></td> <td><p><code>ssize_t</code></p></td> <td><p>integer</p></td> <td></td> <td><p>(3)</p></td> </tr> <tr>
<td><p><code>N</code></p></td> <td><p><code>size_t</code></p></td> <td><p>integer</p></td> <td></td> <td><p>(3)</p></td> </tr> <tr>
<td><p><code>e</code></p></td> <td><p>(6)</p></td> <td><p>float</p></td> <td><p>2</p></td> <td><p>(4)</p></td> </tr> <tr>
<td><p><code>f</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">float</span></span></p></td> <td><p>float</p></td> <td><p>4</p></td> <td><p>(4)</p></td> </tr> <tr>
<td><p><code>d</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">double</span></span></p></td> <td><p>float</p></td> <td><p>8</p></td> <td><p>(4)</p></td> </tr> <tr>
<td><p><code>s</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">[</span><span class="p">]</span></span></p></td> <td><p>bytes</p></td> <td></td> <td><p>(9)</p></td> </tr> <tr>
<td><p><code>p</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">[</span><span class="p">]</span></span></p></td> <td><p>bytes</p></td> <td></td> <td><p>(8)</p></td> </tr> <tr>
<td><p><code>P</code></p></td> <td><p><span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span></p></td> <td><p>integer</p></td> <td></td> <td><p>(5)</p></td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added support for the <code>'n'</code> and <code>'N'</code> formats.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Added support for the <code>'e'</code> format.</p> </div> <p>Notes:</p> <ol class="arabic"> <li>The <code>'?'</code> conversion code corresponds to the <span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span> type defined by C99. If this type is not available, it is simulated using a <span class="c-expr sig sig-inline c"><span class="kt">char</span></span>. In standard mode, it is always represented by one byte. </li> <li>
<p>When attempting to pack a non-integer using any of the integer conversion codes, if the non-integer has a <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> method then that method is called to convert the argument to an integer before packing.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Added use of the <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> method for non-integers.</p> </div> </li> <li>The <code>'n'</code> and <code>'N'</code> conversion codes are only available for the native size (selected as the default or with the <code>'@'</code> byte order character). For the standard size, you can use whichever of the other integer formats fits your application.</li> <li>For the <code>'f'</code>, <code>'d'</code> and <code>'e'</code> conversion codes, the packed representation uses the IEEE 754 binary32, binary64 or binary16 format (for <code>'f'</code>, <code>'d'</code> or <code>'e'</code> respectively), regardless of the floating-point format used by the platform.</li> <li>The <code>'P'</code> format character is only available for the native byte ordering (selected as the default or with the <code>'@'</code> byte order character). The byte order character <code>'='</code> chooses to use little- or big-endian ordering based on the host system. The struct module does not interpret this as native ordering, so the <code>'P'</code> format is not available.</li> <li>The IEEE 754 binary16 “half precision” type was introduced in the 2008 revision of the <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_754-2008_revision">IEEE 754 standard</a>. It has a sign bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), and can represent numbers between approximately <code>6.1e-05</code> and <code>6.5e+04</code> at full precision. This type is not widely supported by C compilers: on a typical machine, an unsigned short can be used for storage, but not for math operations. See the Wikipedia page on the <a class="reference external" href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">half-precision floating-point format</a> for more information.</li> <li>When packing, <code>'x'</code> inserts one NUL byte.</li> <li>The <code>'p'</code> format character encodes a “Pascal string”, meaning a short variable-length string stored in a <em>fixed number of bytes</em>, given by the count. The first byte stored is the length of the string, or 255, whichever is smaller. The bytes of the string follow. If the string passed in to <a class="reference internal" href="#struct.pack" title="struct.pack"><code>pack()</code></a> is too long (longer than the count minus 1), only the leading <code>count-1</code> bytes of the string are stored. If the string is shorter than <code>count-1</code>, it is padded with null bytes so that exactly count bytes in all are used. Note that for <a class="reference internal" href="#struct.unpack" title="struct.unpack"><code>unpack()</code></a>, the <code>'p'</code> format character consumes <code>count</code> bytes, but that the string returned can never contain more than 255 bytes.</li> <li>For the <code>'s'</code> format character, the count is interpreted as the length of the bytes, not a repeat count like for the other format characters; for example, <code>'10s'</code> means a single 10-byte string mapping to or from a single Python byte string, while <code>'10c'</code> means 10 separate one byte character elements (e.g., <code>cccccccccc</code>) mapping to or from ten different Python byte objects. (See <a class="reference internal" href="#struct-examples"><span class="std std-ref">Examples</span></a> for a concrete demonstration of the difference.) If a count is not given, it defaults to 1. For packing, the string is truncated or padded with null bytes as appropriate to make it fit. For unpacking, the resulting bytes object always has exactly the specified number of bytes. As a special case, <code>'0s'</code> means a single, empty string (while <code>'0c'</code> means 0 characters).</li> </ol> <p>A format character may be preceded by an integral repeat count. For example, the format string <code>'4h'</code> means exactly the same as <code>'hhhh'</code>.</p> <p>Whitespace characters between formats are ignored; a count and its format must not contain whitespace though.</p> <p>When packing a value <code>x</code> using one of the integer formats (<code>'b'</code>, <code>'B'</code>, <code>'h'</code>, <code>'H'</code>, <code>'i'</code>, <code>'I'</code>, <code>'l'</code>, <code>'L'</code>, <code>'q'</code>, <code>'Q'</code>), if <code>x</code> is outside the valid range for that format then <a class="reference internal" href="#struct.error" title="struct.error"><code>struct.error</code></a> is raised.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.1: </span>Previously, some of the integer formats wrapped out-of-range values and raised <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code>DeprecationWarning</code></a> instead of <a class="reference internal" href="#struct.error" title="struct.error"><code>struct.error</code></a>.</p> </div> <p id="index-3">For the <code>'?'</code> format character, the return value is either <a class="reference internal" href="constants.html#True" title="True"><code>True</code></a> or <a class="reference internal" href="constants.html#False" title="False"><code>False</code></a>. When packing, the truth value of the argument object is used. Either 0 or 1 in the native or standard bool representation will be packed, and any non-zero value will be <code>True</code> when unpacking.</p> </section> <section id="examples"> <span id="struct-examples"></span><h3>Examples</h3> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Native byte order examples (designated by the <code>'@'</code> format prefix or lack of any prefix character) may not match what the reader’s machine produces as that depends on the platform and compiler.</p> </div> <p>Pack and unpack integers of three different sizes, using big endian ordering:</p> <pre data-language="python">&gt;&gt;&gt; from struct import *
&gt;&gt;&gt; pack("&gt;bhl", 1, 2, 3)
b'\x01\x00\x02\x00\x00\x00\x03'
&gt;&gt;&gt; unpack('&gt;bhl', b'\x01\x00\x02\x00\x00\x00\x03')
(1, 2, 3)
&gt;&gt;&gt; calcsize('&gt;bhl')
7
</pre> <p>Attempt to pack an integer which is too large for the defined field:</p> <pre data-language="python">&gt;&gt;&gt; pack("&gt;h", 99999)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
struct.error: 'h' format requires -32768 &lt;= number &lt;= 32767
</pre> <p>Demonstrate the difference between <code>'s'</code> and <code>'c'</code> format characters:</p> <pre data-language="python">&gt;&gt;&gt; pack("@ccc", b'1', b'2', b'3')
b'123'
&gt;&gt;&gt; pack("@3s", b'123')
b'123'
</pre> <p>Unpacked fields can be named by assigning them to variables or by wrapping the result in a named tuple:</p> <pre data-language="python">&gt;&gt;&gt; record = b'raymond   \x32\x12\x08\x01\x08'
&gt;&gt;&gt; name, serialnum, school, gradelevel = unpack('&lt;10sHHb', record)

&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Student = namedtuple('Student', 'name serialnum school gradelevel')
&gt;&gt;&gt; Student._make(unpack('&lt;10sHHb', record))
Student(name=b'raymond   ', serialnum=4658, school=264, gradelevel=8)
</pre> <p>The ordering of format characters may have an impact on size in native mode since padding is implicit. In standard mode, the user is responsible for inserting any desired padding. Note in the first <code>pack</code> call below that three NUL bytes were added after the packed <code>'#'</code> to align the following integer on a four-byte boundary. In this example, the output was produced on a little endian machine:</p> <pre data-language="python">&gt;&gt;&gt; pack('@ci', b'#', 0x12131415)
b'#\x00\x00\x00\x15\x14\x13\x12'
&gt;&gt;&gt; pack('@ic', 0x12131415, b'#')
b'\x15\x14\x13\x12#'
&gt;&gt;&gt; calcsize('@ci')
8
&gt;&gt;&gt; calcsize('@ic')
5
</pre> <p>The following format <code>'llh0l'</code> results in two pad bytes being added at the end, assuming the platform’s longs are aligned on 4-byte boundaries:</p> <pre data-language="python">&gt;&gt;&gt; pack('@llh0l', 1, 2, 3)
b'\x00\x00\x00\x01\x00\x00\x00\x02\x00\x03\x00\x00'
</pre> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code>array</code></a>
</dt>
<dd>
<p>Packed binary storage of homogeneous data.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="json.html#module-json" title="json: Encode and decode the JSON format."><code>json</code></a>
</dt>
<dd>
<p>JSON encoder and decoder.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a>
</dt>
<dd>
<p>Python object serialization.</p> </dd> </dl> </div> </section> </section> <section id="applications"> <span id="id2"></span><h2>Applications</h2> <p>Two main applications for the <a class="reference internal" href="#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> module exist, data interchange between Python and C code within an application or another application compiled using the same compiler (<a class="reference internal" href="#struct-native-formats"><span class="std std-ref">native formats</span></a>), and data interchange between applications using agreed upon data layout (<a class="reference internal" href="#struct-standard-formats"><span class="std std-ref">standard formats</span></a>). Generally speaking, the format strings constructed for these two domains are distinct.</p> <section id="native-formats"> <span id="struct-native-formats"></span><h3>Native Formats</h3> <p>When constructing format strings which mimic native layouts, the compiler and machine architecture determine byte ordering and padding. In such cases, the <code>@</code> format character should be used to specify native byte ordering and data sizes. Internal pad bytes are normally inserted automatically. It is possible that a zero-repeat format code will be needed at the end of a format string to round up to the correct byte boundary for proper alignment of consecutive chunks of data.</p> <p>Consider these two simple examples (on a 64-bit, little-endian machine):</p> <pre data-language="python">&gt;&gt;&gt; calcsize('@lhl')
24
&gt;&gt;&gt; calcsize('@llh')
18
</pre> <p>Data is not padded to an 8-byte boundary at the end of the second format string without the use of extra padding. A zero-repeat format code solves that problem:</p> <pre data-language="python">&gt;&gt;&gt; calcsize('@llh0l')
24
</pre> <p>The <code>'x'</code> format code can be used to specify the repeat, but for native formats it is better to use a zero-repeat format like <code>'0l'</code>.</p> <p>By default, native byte ordering and alignment is used, but it is better to be explicit and use the <code>'@'</code> prefix character.</p> </section> <section id="standard-formats"> <span id="struct-standard-formats"></span><h3>Standard Formats</h3> <p>When exchanging data beyond your process such as networking or storage, be precise. Specify the exact byte order, size, and alignment. Do not assume they match the native order of a particular machine. For example, network byte order is big-endian, while many popular CPUs are little-endian. By defining this explicitly, the user need not care about the specifics of the platform their code is running on. The first character should typically be <code>&lt;</code> or <code>&gt;</code> (or <code>!</code>). Padding is the responsibility of the programmer. The zero-repeat format character won’t work. Instead, the user must explicitly add <code>'x'</code> pad bytes where needed. Revisiting the examples from the previous section, we have:</p> <pre data-language="python">&gt;&gt;&gt; calcsize('&lt;qh6xq')
24
&gt;&gt;&gt; pack('&lt;qh6xq', 1, 2, 3) == pack('@lhl', 1, 2, 3)
True
&gt;&gt;&gt; calcsize('@llh')
18
&gt;&gt;&gt; pack('@llh', 1, 2, 3) == pack('&lt;qqh', 1, 2, 3)
True
&gt;&gt;&gt; calcsize('&lt;qqh6x')
24
&gt;&gt;&gt; calcsize('@llh0l')
24
&gt;&gt;&gt; pack('@llh0l', 1, 2, 3) == pack('&lt;qqh6x', 1, 2, 3)
True
</pre> <p>The above results (executed on a 64-bit machine) aren’t guaranteed to match when executed on different machines. For example, the examples below were executed on a 32-bit machine:</p> <pre data-language="python">&gt;&gt;&gt; calcsize('&lt;qqh6x')
24
&gt;&gt;&gt; calcsize('@llh0l')
12
&gt;&gt;&gt; pack('@llh0l', 1, 2, 3) == pack('&lt;qqh6x', 1, 2, 3)
False
</pre> </section> </section> <section id="classes"> <span id="struct-objects"></span><h2>Classes</h2> <p>The <a class="reference internal" href="#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> module also defines the following type:</p> <dl class="py class"> <dt class="sig sig-object py" id="struct.Struct">
<code>class struct.Struct(format)</code> </dt> <dd>
<p>Return a new Struct object which writes and reads binary data according to the format string <em>format</em>. Creating a <code>Struct</code> object once and calling its methods is more efficient than calling module-level functions with the same format since the format string is only compiled once.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The compiled versions of the most recent format strings passed to the module-level functions are cached, so programs that use only a few format strings needn’t worry about reusing a single <a class="reference internal" href="#struct.Struct" title="struct.Struct"><code>Struct</code></a> instance.</p> </div> <p>Compiled Struct objects support the following methods and attributes:</p> <dl class="py method"> <dt class="sig sig-object py" id="struct.Struct.pack">
<code>pack(v1, v2, ...)</code> </dt> <dd>
<p>Identical to the <a class="reference internal" href="#struct.pack" title="struct.pack"><code>pack()</code></a> function, using the compiled format. (<code>len(result)</code> will equal <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code>size</code></a>.)</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="struct.Struct.pack_into">
<code>pack_into(buffer, offset, v1, v2, ...)</code> </dt> <dd>
<p>Identical to the <a class="reference internal" href="#struct.pack_into" title="struct.pack_into"><code>pack_into()</code></a> function, using the compiled format.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="struct.Struct.unpack">
<code>unpack(buffer)</code> </dt> <dd>
<p>Identical to the <a class="reference internal" href="#struct.unpack" title="struct.unpack"><code>unpack()</code></a> function, using the compiled format. The buffer’s size in bytes must equal <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code>size</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="struct.Struct.unpack_from">
<code>unpack_from(buffer, offset=0)</code> </dt> <dd>
<p>Identical to the <a class="reference internal" href="#struct.unpack_from" title="struct.unpack_from"><code>unpack_from()</code></a> function, using the compiled format. The buffer’s size in bytes, starting at position <em>offset</em>, must be at least <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code>size</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="struct.Struct.iter_unpack">
<code>iter_unpack(buffer)</code> </dt> <dd>
<p>Identical to the <a class="reference internal" href="#struct.iter_unpack" title="struct.iter_unpack"><code>iter_unpack()</code></a> function, using the compiled format. The buffer’s size in bytes must be a multiple of <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code>size</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="struct.Struct.format">
<code>format</code> </dt> <dd>
<p>The format string used to construct this Struct object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>The format string type is now <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> instead of <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="struct.Struct.size">
<code>size</code> </dt> <dd>
<p>The calculated size of the struct (and hence of the bytes object produced by the <a class="reference internal" href="#struct.pack" title="struct.pack"><code>pack()</code></a> method) corresponding to <a class="reference internal" href="functions.html#format" title="format"><code>format</code></a>.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The <em>repr()</em> of structs has changed. It is now:</p> <pre data-language="python">&gt;&gt;&gt; Struct('i')
Struct('i')
</pre> </div> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/struct.html" class="_attribution-link">https://docs.python.org/3.13/library/struct.html</a>
  </p>
</div>
