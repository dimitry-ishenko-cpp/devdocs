 <span id="pkgutil-package-extension-utility"></span><h1>pkgutil — Package extension utility</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/pkgutil.py">Lib/pkgutil.py</a></p>  <p>This module provides utilities for the import system, in particular package support.</p> <dl class="py class"> <dt class="sig sig-object py" id="pkgutil.ModuleInfo">
<code>class pkgutil.ModuleInfo(module_finder, name, ispkg)</code> </dt> <dd>
<p>A namedtuple that holds a brief summary of a module’s info.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="pkgutil.extend_path">
<code>pkgutil.extend_path(path, name)</code> </dt> <dd>
<p>Extend the search path for the modules which comprise a package. Intended use is to place the following code in a package’s <code>__init__.py</code>:</p> <pre data-language="python">from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)
</pre> <p>For each directory on <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code>sys.path</code></a> that has a subdirectory that matches the package name, add the subdirectory to the package’s <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code>__path__</code></a>. This is useful if one wants to distribute different parts of a single logical package as multiple directories.</p> <p>It also looks for <code>*.pkg</code> files beginning where <code>*</code> matches the <em>name</em> argument. This feature is similar to <code>*.pth</code> files (see the <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code>site</code></a> module for more information), except that it doesn’t special-case lines starting with <code>import</code>. A <code>*.pkg</code> file is trusted at face value: apart from skipping blank lines and ignoring comments, all entries found in a <code>*.pkg</code> file are added to the path, regardless of whether they exist on the filesystem (this is a feature).</p> <p>If the input path is not a list (as is the case for frozen packages) it is returned unchanged. The input path is not modified; an extended copy is returned. Items are only appended to the copy at the end.</p> <p>It is assumed that <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code>sys.path</code></a> is a sequence. Items of <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code>sys.path</code></a> that are not strings referring to existing directories are ignored. Unicode items on <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code>sys.path</code></a> that cause errors when used as filenames may cause this function to raise an exception (in line with <a class="reference internal" href="os.path.html#os.path.isdir" title="os.path.isdir"><code>os.path.isdir()</code></a> behavior).</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="pkgutil.find_loader">
<code>pkgutil.find_loader(fullname)</code> </dt> <dd>
<p>Retrieve a module <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> for the given <em>fullname</em>.</p> <p>This is a backwards compatibility wrapper around <a class="reference internal" href="importlib.html#importlib.util.find_spec" title="importlib.util.find_spec"><code>importlib.util.find_spec()</code></a> that converts most failures to <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code>ImportError</code></a> and only returns the loader rather than the full <a class="reference internal" href="importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code>importlib.machinery.ModuleSpec</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> import emulation.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Updated to be based on <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a></p> </div> <div class="deprecated-removed"> <p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.14: </span>Use <a class="reference internal" href="importlib.html#importlib.util.find_spec" title="importlib.util.find_spec"><code>importlib.util.find_spec()</code></a> instead.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="pkgutil.get_importer">
<code>pkgutil.get_importer(path_item)</code> </dt> <dd>
<p>Retrieve a <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> for the given <em>path_item</em>.</p> <p>The returned finder is cached in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code>sys.path_importer_cache</code></a> if it was newly created by a path hook.</p> <p>The cache (or part of it) can be cleared manually if a rescan of <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code>sys.path_hooks</code></a> is necessary.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> import emulation.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="pkgutil.get_loader">
<code>pkgutil.get_loader(module_or_name)</code> </dt> <dd>
<p>Get a <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> object for <em>module_or_name</em>.</p> <p>If the module or package is accessible via the normal import mechanism, a wrapper around the relevant part of that machinery is returned. Returns <code>None</code> if the module cannot be found or imported. If the named module is not already imported, its containing package (if any) is imported, in order to establish the package <code>__path__</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> import emulation.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Updated to be based on <span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a></p> </div> <div class="deprecated-removed"> <p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.14: </span>Use <a class="reference internal" href="importlib.html#importlib.util.find_spec" title="importlib.util.find_spec"><code>importlib.util.find_spec()</code></a> instead.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="pkgutil.iter_importers">
<code>pkgutil.iter_importers(fullname='')</code> </dt> <dd>
<p>Yield <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> objects for the given module name.</p> <p>If fullname contains a <code>'.'</code>, the finders will be for the package containing fullname, otherwise they will be all registered top level finders (i.e. those on both <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code>sys.meta_path</code></a> and <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code>sys.path_hooks</code></a>).</p> <p>If the named module is in a package, that package is imported as a side effect of invoking this function.</p> <p>If no module name is specified, all top level finders are produced.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <span class="target" id="index-5"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> import emulation.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="pkgutil.iter_modules">
<code>pkgutil.iter_modules(path=None, prefix='')</code> </dt> <dd>
<p>Yields <a class="reference internal" href="#pkgutil.ModuleInfo" title="pkgutil.ModuleInfo"><code>ModuleInfo</code></a> for all submodules on <em>path</em>, or, if <em>path</em> is <code>None</code>, all top-level modules on <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code>sys.path</code></a>.</p> <p><em>path</em> should be either <code>None</code> or a list of paths to look for modules in.</p> <p><em>prefix</em> is a string to output on the front of every module name on output.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only works for a <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> which defines an <code>iter_modules()</code> method. This interface is non-standard, so the module also provides implementations for <a class="reference internal" href="importlib.html#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code>importlib.machinery.FileFinder</code></a> and <a class="reference internal" href="zipimport.html#zipimport.zipimporter" title="zipimport.zipimporter"><code>zipimport.zipimporter</code></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <span class="target" id="index-6"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> import emulation.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="pkgutil.walk_packages">
<code>pkgutil.walk_packages(path=None, prefix='', onerror=None)</code> </dt> <dd>
<p>Yields <a class="reference internal" href="#pkgutil.ModuleInfo" title="pkgutil.ModuleInfo"><code>ModuleInfo</code></a> for all modules recursively on <em>path</em>, or, if <em>path</em> is <code>None</code>, all accessible modules.</p> <p><em>path</em> should be either <code>None</code> or a list of paths to look for modules in.</p> <p><em>prefix</em> is a string to output on the front of every module name on output.</p> <p>Note that this function must import all <em>packages</em> (<em>not</em> all modules!) on the given <em>path</em>, in order to access the <code>__path__</code> attribute to find submodules.</p> <p><em>onerror</em> is a function which gets called with one argument (the name of the package which was being imported) if any exception occurs while trying to import a package. If no <em>onerror</em> function is supplied, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code>ImportError</code></a>s are caught and ignored, while all other exceptions are propagated, terminating the search.</p> <p>Examples:</p> <pre data-language="python"># list all modules python can access
walk_packages()

# list all submodules of ctypes
walk_packages(ctypes.__path__, ctypes.__name__ + '.')
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only works for a <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> which defines an <code>iter_modules()</code> method. This interface is non-standard, so the module also provides implementations for <a class="reference internal" href="importlib.html#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code>importlib.machinery.FileFinder</code></a> and <a class="reference internal" href="zipimport.html#zipimport.zipimporter" title="zipimport.zipimporter"><code>zipimport.zipimporter</code></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> import emulation.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="pkgutil.get_data">
<code>pkgutil.get_data(package, resource)</code> </dt> <dd>
<p>Get a resource from a package.</p> <p>This is a wrapper for the <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> <a class="reference internal" href="importlib.html#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code>get_data</code></a> API. The <em>package</em> argument should be the name of a package, in standard module format (<code>foo.bar</code>). The <em>resource</em> argument should be in the form of a relative filename, using <code>/</code> as the path separator. The parent directory name <code>..</code> is not allowed, and nor is a rooted name (starting with a <code>/</code>).</p> <p>The function returns a binary string that is the contents of the specified resource.</p> <p>For packages located in the filesystem, which have already been imported, this is the rough equivalent of:</p> <pre data-language="python">d = os.path.dirname(sys.modules[package].__file__)
data = open(os.path.join(d, resource), 'rb').read()
</pre> <p>If the package cannot be located or loaded, or it uses a <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> which does not support <a class="reference internal" href="importlib.html#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code>get_data</code></a>, then <code>None</code> is returned. In particular, the <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> for <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">namespace packages</span></a> does not support <a class="reference internal" href="importlib.html#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code>get_data</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="pkgutil.resolve_name">
<code>pkgutil.resolve_name(name)</code> </dt> <dd>
<p>Resolve a name to an object.</p> <p>This functionality is used in numerous places in the standard library (see <a class="reference external" href="https://bugs.python.org/issue?@action=redirect&amp;bpo=12915">bpo-12915</a>) - and equivalent functionality is also in widely used third-party packages such as setuptools, Django and Pyramid.</p> <p>It is expected that <em>name</em> will be a string in one of the following formats, where W is shorthand for a valid Python identifier and dot stands for a literal period in these pseudo-regexes:</p> <ul class="simple"> <li><code>W(.W)*</code></li> <li><code>W(.W)*:(W(.W)*)?</code></li> </ul> <p>The first form is intended for backward compatibility only. It assumes that some part of the dotted name is a package, and the rest is an object somewhere within that package, possibly nested inside other objects. Because the place where the package stops and the object hierarchy starts can’t be inferred by inspection, repeated attempts to import must be done with this form.</p> <p>In the second form, the caller makes the division point clear through the provision of a single colon: the dotted name to the left of the colon is a package to be imported, and the dotted name to the right is the object hierarchy within that package. Only one import is needed in this form. If it ends with the colon, then a module object is returned.</p> <p>The function will return an object (which might be a module), or raise one of the following exceptions:</p> <p><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> – if <em>name</em> isn’t in a recognised format.</p> <p><a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code>ImportError</code></a> – if an import failed when it shouldn’t have.</p> <p><a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code>AttributeError</code></a> – If a failure occurred when traversing the object hierarchy within the imported package to get to the desired object.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/pkgutil.html" class="_attribution-link">https://docs.python.org/3.13/library/pkgutil.html</a>
  </p>
</div>
