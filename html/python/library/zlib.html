 <span id="zlib-compression-compatible-with-gzip"></span><h1>zlib — Compression compatible with gzip</h1>  <p>For applications that require data compression, the functions in this module allow compression and decompression, using the zlib library. The zlib library has its own home page at <a class="reference external" href="https://www.zlib.net">https://www.zlib.net</a>. There are known incompatibilities between the Python module and versions of the zlib library earlier than 1.1.3; 1.1.3 has a <a class="reference external" href="https://zlib.net/zlib_faq.html#faq33">security vulnerability</a>, so we recommend using 1.1.4 or later.</p> <p>zlib’s functions have many options and often need to be used in a particular order. This documentation doesn’t attempt to cover all of the permutations; consult the zlib manual at <a class="reference external" href="http://www.zlib.net/manual.html">http://www.zlib.net/manual.html</a> for authoritative information.</p> <p>For reading and writing <code>.gz</code> files see the <a class="reference internal" href="gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code>gzip</code></a> module.</p> <p>The available exception and functions in this module are:</p> <dl class="py exception"> <dt class="sig sig-object py" id="zlib.error">
<code>exception zlib.error</code> </dt> <dd>
<p>Exception raised on compression and decompression errors.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="zlib.adler32">
<code>zlib.adler32(data[, value])</code> </dt> <dd>
<p>Computes an Adler-32 checksum of <em>data</em>. (An Adler-32 checksum is almost as reliable as a CRC32 but can be computed much more quickly.) The result is an unsigned 32-bit integer. If <em>value</em> is present, it is used as the starting value of the checksum; otherwise, a default value of 1 is used. Passing in <em>value</em> allows computing a running checksum over the concatenation of several inputs. The algorithm is not cryptographically strong, and should not be used for authentication or digital signatures. Since the algorithm is designed for use as a checksum algorithm, it is not suitable for use as a general hash algorithm.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.0: </span>The result is always unsigned.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="zlib.compress">
<code>zlib.compress(data, /, level=- 1, wbits=MAX_WBITS)</code> </dt> <dd>
<p>Compresses the bytes in <em>data</em>, returning a bytes object containing compressed data. <em>level</em> is an integer from <code>0</code> to <code>9</code> or <code>-1</code> controlling the level of compression; <code>1</code> (Z_BEST_SPEED) is fastest and produces the least compression, <code>9</code> (Z_BEST_COMPRESSION) is slowest and produces the most. <code>0</code> (Z_NO_COMPRESSION) is no compression. The default value is <code>-1</code> (Z_DEFAULT_COMPRESSION). Z_DEFAULT_COMPRESSION represents a default compromise between speed and compression (currently equivalent to level 6).</p> <p id="compress-wbits">The <em>wbits</em> argument controls the size of the history buffer (or the “window size”) used when compressing data, and whether a header and trailer is included in the output. It can take several ranges of values, defaulting to <code>15</code> (MAX_WBITS):</p> <ul class="simple"> <li>+9 to +15: The base-two logarithm of the window size, which therefore ranges between 512 and 32768. Larger values produce better compression at the expense of greater memory usage. The resulting output will include a zlib-specific header and trailer.</li> <li>−9 to −15: Uses the absolute value of <em>wbits</em> as the window size logarithm, while producing a raw output stream with no header or trailing checksum.</li> <li>+25 to +31 = 16 + (9 to 15): Uses the low 4 bits of the value as the window size logarithm, while including a basic <strong class="program">gzip</strong> header and trailing checksum in the output.</li> </ul> <p>Raises the <a class="reference internal" href="#zlib.error" title="zlib.error"><code>error</code></a> exception if any error occurs.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>level</em> can now be used as a keyword parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>The <em>wbits</em> parameter is now available to set window bits and compression type.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="zlib.compressobj">
<code>zlib.compressobj(level=-1, method=DEFLATED, wbits=MAX_WBITS, memLevel=DEF_MEM_LEVEL, strategy=Z_DEFAULT_STRATEGY[, zdict])</code> </dt> <dd>
<p>Returns a compression object, to be used for compressing data streams that won’t fit into memory at once.</p> <p><em>level</em> is the compression level – an integer from <code>0</code> to <code>9</code> or <code>-1</code>. A value of <code>1</code> (Z_BEST_SPEED) is fastest and produces the least compression, while a value of <code>9</code> (Z_BEST_COMPRESSION) is slowest and produces the most. <code>0</code> (Z_NO_COMPRESSION) is no compression. The default value is <code>-1</code> (Z_DEFAULT_COMPRESSION). Z_DEFAULT_COMPRESSION represents a default compromise between speed and compression (currently equivalent to level 6).</p> <p><em>method</em> is the compression algorithm. Currently, the only supported value is <code>DEFLATED</code>.</p> <p>The <em>wbits</em> parameter controls the size of the history buffer (or the “window size”), and what header and trailer format will be used. It has the same meaning as <a class="reference external" href="#compress-wbits">described for compress()</a>.</p> <p>The <em>memLevel</em> argument controls the amount of memory used for the internal compression state. Valid values range from <code>1</code> to <code>9</code>. Higher values use more memory, but are faster and produce smaller output.</p> <p><em>strategy</em> is used to tune the compression algorithm. Possible values are <code>Z_DEFAULT_STRATEGY</code>, <code>Z_FILTERED</code>, <code>Z_HUFFMAN_ONLY</code>, <code>Z_RLE</code> (zlib 1.2.0.1) and <code>Z_FIXED</code> (zlib 1.2.2.2).</p> <p><em>zdict</em> is a predefined compression dictionary. This is a sequence of bytes (such as a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object) containing subsequences that are expected to occur frequently in the data that is to be compressed. Those subsequences that are expected to be most common should come at the end of the dictionary.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added the <em>zdict</em> parameter and keyword argument support.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="zlib.crc32">
<code>zlib.crc32(data[, value])</code> </dt> <dd>
<p id="index-0">Computes a CRC (Cyclic Redundancy Check) checksum of <em>data</em>. The result is an unsigned 32-bit integer. If <em>value</em> is present, it is used as the starting value of the checksum; otherwise, a default value of 0 is used. Passing in <em>value</em> allows computing a running checksum over the concatenation of several inputs. The algorithm is not cryptographically strong, and should not be used for authentication or digital signatures. Since the algorithm is designed for use as a checksum algorithm, it is not suitable for use as a general hash algorithm.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.0: </span>The result is always unsigned.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="zlib.decompress">
<code>zlib.decompress(data, /, wbits=MAX_WBITS, bufsize=DEF_BUF_SIZE)</code> </dt> <dd>
<p>Decompresses the bytes in <em>data</em>, returning a bytes object containing the uncompressed data. The <em>wbits</em> parameter depends on the format of <em>data</em>, and is discussed further below. If <em>bufsize</em> is given, it is used as the initial size of the output buffer. Raises the <a class="reference internal" href="#zlib.error" title="zlib.error"><code>error</code></a> exception if any error occurs.</p> <p id="decompress-wbits">The <em>wbits</em> parameter controls the size of the history buffer (or “window size”), and what header and trailer format is expected. It is similar to the parameter for <a class="reference internal" href="#zlib.compressobj" title="zlib.compressobj"><code>compressobj()</code></a>, but accepts more ranges of values:</p> <ul class="simple"> <li>+8 to +15: The base-two logarithm of the window size. The input must include a zlib header and trailer.</li> <li>0: Automatically determine the window size from the zlib header. Only supported since zlib 1.2.3.5.</li> <li>−8 to −15: Uses the absolute value of <em>wbits</em> as the window size logarithm. The input must be a raw stream with no header or trailer.</li> <li>+24 to +31 = 16 + (8 to 15): Uses the low 4 bits of the value as the window size logarithm. The input must include a gzip header and trailer.</li> <li>+40 to +47 = 32 + (8 to 15): Uses the low 4 bits of the value as the window size logarithm, and automatically accepts either the zlib or gzip format.</li> </ul> <p>When decompressing a stream, the window size must not be smaller than the size originally used to compress the stream; using a too-small value may result in an <a class="reference internal" href="#zlib.error" title="zlib.error"><code>error</code></a> exception. The default <em>wbits</em> value corresponds to the largest window size and requires a zlib header and trailer to be included.</p> <p><em>bufsize</em> is the initial size of the buffer used to hold decompressed data. If more space is required, the buffer size will be increased as needed, so you don’t have to get this value exactly right; tuning it will only save a few calls to <code>malloc()</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>wbits</em> and <em>bufsize</em> can be used as keyword arguments.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="zlib.decompressobj">
<code>zlib.decompressobj(wbits=MAX_WBITS[, zdict])</code> </dt> <dd>
<p>Returns a decompression object, to be used for decompressing data streams that won’t fit into memory at once.</p> <p>The <em>wbits</em> parameter controls the size of the history buffer (or the “window size”), and what header and trailer format is expected. It has the same meaning as <a class="reference external" href="#decompress-wbits">described for decompress()</a>.</p> <p>The <em>zdict</em> parameter specifies a predefined compression dictionary. If provided, this must be the same dictionary as was used by the compressor that produced the data that is to be decompressed.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If <em>zdict</em> is a mutable object (such as a <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a>), you must not modify its contents between the call to <a class="reference internal" href="#zlib.decompressobj" title="zlib.decompressobj"><code>decompressobj()</code></a> and the first call to the decompressor’s <code>decompress()</code> method.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added the <em>zdict</em> parameter.</p> </div> </dd>
</dl> <p>Compression objects support the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="zlib.Compress.compress">
<code>Compress.compress(data)</code> </dt> <dd>
<p>Compress <em>data</em>, returning a bytes object containing compressed data for at least part of the data in <em>data</em>. This data should be concatenated to the output produced by any preceding calls to the <a class="reference internal" href="#zlib.compress" title="zlib.compress"><code>compress()</code></a> method. Some input may be kept in internal buffers for later processing.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="zlib.Compress.flush">
<code>Compress.flush([mode])</code> </dt> <dd>
<p>All pending input is processed, and a bytes object containing the remaining compressed output is returned. <em>mode</em> can be selected from the constants <code>Z_NO_FLUSH</code>, <code>Z_PARTIAL_FLUSH</code>, <code>Z_SYNC_FLUSH</code>, <code>Z_FULL_FLUSH</code>, <code>Z_BLOCK</code> (zlib 1.2.3.4), or <code>Z_FINISH</code>, defaulting to <code>Z_FINISH</code>. Except <code>Z_FINISH</code>, all constants allow compressing further bytestrings of data, while <code>Z_FINISH</code> finishes the compressed stream and prevents compressing any more data. After calling <a class="reference internal" href="#zlib.Compress.flush" title="zlib.Compress.flush"><code>flush()</code></a> with <em>mode</em> set to <code>Z_FINISH</code>, the <a class="reference internal" href="#zlib.compress" title="zlib.compress"><code>compress()</code></a> method cannot be called again; the only realistic action is to delete the object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="zlib.Compress.copy">
<code>Compress.copy()</code> </dt> <dd>
<p>Returns a copy of the compression object. This can be used to efficiently compress a set of data that share a common initial prefix.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added <a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code>copy.copy()</code></a> and <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code>copy.deepcopy()</code></a> support to compression objects.</p> </div> <p>Decompression objects support the following methods and attributes:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="zlib.Decompress.unused_data">
<code>Decompress.unused_data</code> </dt> <dd>
<p>A bytes object which contains any bytes past the end of the compressed data. That is, this remains <code>b""</code> until the last byte that contains compression data is available. If the whole bytestring turned out to contain compressed data, this is <code>b""</code>, an empty bytes object.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="zlib.Decompress.unconsumed_tail">
<code>Decompress.unconsumed_tail</code> </dt> <dd>
<p>A bytes object that contains any data that was not consumed by the last <a class="reference internal" href="#zlib.decompress" title="zlib.decompress"><code>decompress()</code></a> call because it exceeded the limit for the uncompressed data buffer. This data has not yet been seen by the zlib machinery, so you must feed it (possibly with further data concatenated to it) back to a subsequent <a class="reference internal" href="#zlib.decompress" title="zlib.decompress"><code>decompress()</code></a> method call in order to get correct output.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="zlib.Decompress.eof">
<code>Decompress.eof</code> </dt> <dd>
<p>A boolean indicating whether the end of the compressed data stream has been reached.</p> <p>This makes it possible to distinguish between a properly formed compressed stream, and an incomplete or truncated one.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="zlib.Decompress.decompress">
<code>Decompress.decompress(data, max_length=0)</code> </dt> <dd>
<p>Decompress <em>data</em>, returning a bytes object containing the uncompressed data corresponding to at least part of the data in <em>string</em>. This data should be concatenated to the output produced by any preceding calls to the <a class="reference internal" href="#zlib.decompress" title="zlib.decompress"><code>decompress()</code></a> method. Some of the input data may be preserved in internal buffers for later processing.</p> <p>If the optional parameter <em>max_length</em> is non-zero then the return value will be no longer than <em>max_length</em>. This may mean that not all of the compressed input can be processed; and unconsumed data will be stored in the attribute <a class="reference internal" href="#zlib.Decompress.unconsumed_tail" title="zlib.Decompress.unconsumed_tail"><code>unconsumed_tail</code></a>. This bytestring must be passed to a subsequent call to <a class="reference internal" href="#zlib.decompress" title="zlib.decompress"><code>decompress()</code></a> if decompression is to continue. If <em>max_length</em> is zero then the whole input is decompressed, and <a class="reference internal" href="#zlib.Decompress.unconsumed_tail" title="zlib.Decompress.unconsumed_tail"><code>unconsumed_tail</code></a> is empty.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>max_length</em> can be used as a keyword argument.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="zlib.Decompress.flush">
<code>Decompress.flush([length])</code> </dt> <dd>
<p>All pending input is processed, and a bytes object containing the remaining uncompressed output is returned. After calling <a class="reference internal" href="#zlib.Decompress.flush" title="zlib.Decompress.flush"><code>flush()</code></a>, the <a class="reference internal" href="#zlib.decompress" title="zlib.decompress"><code>decompress()</code></a> method cannot be called again; the only realistic action is to delete the object.</p> <p>The optional parameter <em>length</em> sets the initial size of the output buffer.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="zlib.Decompress.copy">
<code>Decompress.copy()</code> </dt> <dd>
<p>Returns a copy of the decompression object. This can be used to save the state of the decompressor midway through the data stream in order to speed up random seeks into the stream at a future point.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added <a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code>copy.copy()</code></a> and <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code>copy.deepcopy()</code></a> support to decompression objects.</p> </div> <p>Information about the version of the zlib library in use is available through the following constants:</p> <dl class="py data"> <dt class="sig sig-object py" id="zlib.ZLIB_VERSION">
<code>zlib.ZLIB_VERSION</code> </dt> <dd>
<p>The version string of the zlib library that was used for building the module. This may be different from the zlib library actually used at runtime, which is available as <a class="reference internal" href="#zlib.ZLIB_RUNTIME_VERSION" title="zlib.ZLIB_RUNTIME_VERSION"><code>ZLIB_RUNTIME_VERSION</code></a>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="zlib.ZLIB_RUNTIME_VERSION">
<code>zlib.ZLIB_RUNTIME_VERSION</code> </dt> <dd>
<p>The version string of the zlib library actually loaded by the interpreter.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code>gzip</code></a>
</dt>
<dd>
<p>Reading and writing <strong class="program">gzip</strong>-format files.</p> </dd> <dt><a class="reference external" href="http://www.zlib.net">http://www.zlib.net</a></dt>
<dd>
<p>The zlib library home page.</p> </dd> <dt><a class="reference external" href="http://www.zlib.net/manual.html">http://www.zlib.net/manual.html</a></dt>
<dd>
<p>The zlib manual explains the semantics and usage of the library’s many functions.</p> </dd> </dl> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/zlib.html" class="_attribution-link">https://docs.python.org/3.12/library/zlib.html</a>
  </p>
</div>
