 <span id="base64-base16-base32-base64-base85-data-encodings"></span><h1>base64 — Base16, Base32, Base64, Base85 Data Encodings</h1> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/base64.py">Lib/base64.py</a></p>  <p>This module provides functions for encoding binary data to printable ASCII characters and decoding such encodings back to binary data. It provides encoding and decoding functions for the encodings specified in <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4648.html"><strong>RFC 4648</strong></a>, which defines the Base16, Base32, and Base64 algorithms, and for the de-facto standard Ascii85 and Base85 encodings.</p> <p>The <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4648.html"><strong>RFC 4648</strong></a> encodings are suitable for encoding binary data so that it can be safely sent by email, used as parts of URLs, or included as part of an HTTP POST request. The encoding algorithm is not the same as the <strong class="program">uuencode</strong> program.</p> <p>There are two interfaces provided by this module. The modern interface supports encoding <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a> to ASCII <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>, and decoding <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a> or strings containing ASCII to <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>. Both base-64 alphabets defined in <span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4648.html"><strong>RFC 4648</strong></a> (normal, and URL- and filesystem-safe) are supported.</p> <p>The legacy interface does not support decoding from strings, but it does provide functions for encoding and decoding to and from <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file objects</span></a>. It only supports the Base64 standard alphabet, and it adds newlines every 76 characters as per <span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a>. Note that if you are looking for <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> support you probably want to be looking at the <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code>email</code></a> package instead.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>ASCII-only Unicode strings are now accepted by the decoding functions of the modern interface.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Any <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a> are now accepted by all encoding and decoding functions in this module. Ascii85/Base85 support added.</p> </div> <p>The modern interface provides:</p> <dl class="py function"> <dt class="sig sig-object py" id="base64.b64encode">
<code>base64.b64encode(s, altchars=None)</code> </dt> <dd>
<p>Encode the <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>s</em> using Base64 and return the encoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> <p>Optional <em>altchars</em> must be a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> of length 2 which specifies an alternative alphabet for the <code>+</code> and <code>/</code> characters. This allows an application to e.g. generate URL or filesystem safe Base64 strings. The default is <code>None</code>, for which the standard Base64 alphabet is used.</p> <p>May assert or raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if the length of <em>altchars</em> is not 2. Raises a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> if <em>altchars</em> is not a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.b64decode">
<code>base64.b64decode(s, altchars=None, validate=False)</code> </dt> <dd>
<p>Decode the Base64 encoded <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or ASCII string <em>s</em> and return the decoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> <p>Optional <em>altchars</em> must be a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or ASCII string of length 2 which specifies the alternative alphabet used instead of the <code>+</code> and <code>/</code> characters.</p> <p>A <a class="reference internal" href="binascii.html#binascii.Error" title="binascii.Error"><code>binascii.Error</code></a> exception is raised if <em>s</em> is incorrectly padded.</p> <p>If <em>validate</em> is <code>False</code> (the default), characters that are neither in the normal base-64 alphabet nor the alternative alphabet are discarded prior to the padding check. If <em>validate</em> is <code>True</code>, these non-alphabet characters in the input result in a <a class="reference internal" href="binascii.html#binascii.Error" title="binascii.Error"><code>binascii.Error</code></a>.</p> <p>For more information about the strict base64 check, see <a class="reference internal" href="binascii.html#binascii.a2b_base64" title="binascii.a2b_base64"><code>binascii.a2b_base64()</code></a></p> <p>May assert or raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if the length of <em>altchars</em> is not 2.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.standard_b64encode">
<code>base64.standard_b64encode(s)</code> </dt> <dd>
<p>Encode <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>s</em> using the standard Base64 alphabet and return the encoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.standard_b64decode">
<code>base64.standard_b64decode(s)</code> </dt> <dd>
<p>Decode <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or ASCII string <em>s</em> using the standard Base64 alphabet and return the decoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.urlsafe_b64encode">
<code>base64.urlsafe_b64encode(s)</code> </dt> <dd>
<p>Encode <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>s</em> using the URL- and filesystem-safe alphabet, which substitutes <code>-</code> instead of <code>+</code> and <code>_</code> instead of <code>/</code> in the standard Base64 alphabet, and return the encoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>. The result can still contain <code>=</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.urlsafe_b64decode">
<code>base64.urlsafe_b64decode(s)</code> </dt> <dd>
<p>Decode <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or ASCII string <em>s</em> using the URL- and filesystem-safe alphabet, which substitutes <code>-</code> instead of <code>+</code> and <code>_</code> instead of <code>/</code> in the standard Base64 alphabet, and return the decoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.b32encode">
<code>base64.b32encode(s)</code> </dt> <dd>
<p>Encode the <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>s</em> using Base32 and return the encoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.b32decode">
<code>base64.b32decode(s, casefold=False, map01=None)</code> </dt> <dd>
<p>Decode the Base32 encoded <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or ASCII string <em>s</em> and return the decoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> <p>Optional <em>casefold</em> is a flag specifying whether a lowercase alphabet is acceptable as input. For security purposes, the default is <code>False</code>.</p> <p><span class="target" id="index-6"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4648.html"><strong>RFC 4648</strong></a> allows for optional mapping of the digit 0 (zero) to the letter O (oh), and for optional mapping of the digit 1 (one) to either the letter I (eye) or letter L (el). The optional argument <em>map01</em> when not <code>None</code>, specifies which letter the digit 1 should be mapped to (when <em>map01</em> is not <code>None</code>, the digit 0 is always mapped to the letter O). For security purposes the default is <code>None</code>, so that 0 and 1 are not allowed in the input.</p> <p>A <a class="reference internal" href="binascii.html#binascii.Error" title="binascii.Error"><code>binascii.Error</code></a> is raised if <em>s</em> is incorrectly padded or if there are non-alphabet characters present in the input.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.b32hexencode">
<code>base64.b32hexencode(s)</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#base64.b32encode" title="base64.b32encode"><code>b32encode()</code></a> but uses the Extended Hex Alphabet, as defined in <span class="target" id="index-7"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4648.html"><strong>RFC 4648</strong></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.b32hexdecode">
<code>base64.b32hexdecode(s, casefold=False)</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#base64.b32decode" title="base64.b32decode"><code>b32decode()</code></a> but uses the Extended Hex Alphabet, as defined in <span class="target" id="index-8"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4648.html"><strong>RFC 4648</strong></a>.</p> <p>This version does not allow the digit 0 (zero) to the letter O (oh) and digit 1 (one) to either the letter I (eye) or letter L (el) mappings, all these characters are included in the Extended Hex Alphabet and are not interchangeable.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.b16encode">
<code>base64.b16encode(s)</code> </dt> <dd>
<p>Encode the <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>s</em> using Base16 and return the encoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.b16decode">
<code>base64.b16decode(s, casefold=False)</code> </dt> <dd>
<p>Decode the Base16 encoded <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or ASCII string <em>s</em> and return the decoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> <p>Optional <em>casefold</em> is a flag specifying whether a lowercase alphabet is acceptable as input. For security purposes, the default is <code>False</code>.</p> <p>A <a class="reference internal" href="binascii.html#binascii.Error" title="binascii.Error"><code>binascii.Error</code></a> is raised if <em>s</em> is incorrectly padded or if there are non-alphabet characters present in the input.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.a85encode">
<code>base64.a85encode(b, *, foldspaces=False, wrapcol=0, pad=False, adobe=False)</code> </dt> <dd>
<p>Encode the <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>b</em> using Ascii85 and return the encoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> <p><em>foldspaces</em> is an optional flag that uses the special short sequence ‘y’ instead of 4 consecutive spaces (ASCII 0x20) as supported by ‘btoa’. This feature is not supported by the “standard” Ascii85 encoding.</p> <p><em>wrapcol</em> controls whether the output should have newline (<code>b'\n'</code>) characters added to it. If this is non-zero, each output line will be at most this many characters long.</p> <p><em>pad</em> controls whether the input is padded to a multiple of 4 before encoding. Note that the <code>btoa</code> implementation always pads.</p> <p><em>adobe</em> controls whether the encoded byte sequence is framed with <code>&lt;~</code> and <code>~&gt;</code>, which is used by the Adobe implementation.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.a85decode">
<code>base64.a85decode(b, *, foldspaces=False, adobe=False, ignorechars=b' \t\n\r\x0b')</code> </dt> <dd>
<p>Decode the Ascii85 encoded <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or ASCII string <em>b</em> and return the decoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> <p><em>foldspaces</em> is a flag that specifies whether the ‘y’ short sequence should be accepted as shorthand for 4 consecutive spaces (ASCII 0x20). This feature is not supported by the “standard” Ascii85 encoding.</p> <p><em>adobe</em> controls whether the input sequence is in Adobe Ascii85 format (i.e. is framed with &lt;~ and ~&gt;).</p> <p><em>ignorechars</em> should be a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or ASCII string containing characters to ignore from the input. This should only contain whitespace characters, and by default contains all whitespace characters in ASCII.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.b85encode">
<code>base64.b85encode(b, pad=False)</code> </dt> <dd>
<p>Encode the <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>b</em> using base85 (as used in e.g. git-style binary diffs) and return the encoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> <p>If <em>pad</em> is true, the input is padded with <code>b'\0'</code> so its length is a multiple of 4 bytes before encoding.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.b85decode">
<code>base64.b85decode(b)</code> </dt> <dd>
<p>Decode the base85-encoded <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or ASCII string <em>b</em> and return the decoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>. Padding is implicitly removed, if necessary.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </dd>
</dl> <p>The legacy interface:</p> <dl class="py function"> <dt class="sig sig-object py" id="base64.decode">
<code>base64.decode(input, output)</code> </dt> <dd>
<p>Decode the contents of the binary <em>input</em> file and write the resulting binary data to the <em>output</em> file. <em>input</em> and <em>output</em> must be <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file objects</span></a>. <em>input</em> will be read until <code>input.readline()</code> returns an empty bytes object.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.decodebytes">
<code>base64.decodebytes(s)</code> </dt> <dd>
<p>Decode the <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>s</em>, which must contain one or more lines of base64 encoded data, and return the decoded <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.1.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.encode">
<code>base64.encode(input, output)</code> </dt> <dd>
<p>Encode the contents of the binary <em>input</em> file and write the resulting base64 encoded data to the <em>output</em> file. <em>input</em> and <em>output</em> must be <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file objects</span></a>. <em>input</em> will be read until <code>input.read()</code> returns an empty bytes object. <a class="reference internal" href="#base64.encode" title="base64.encode"><code>encode()</code></a> inserts a newline character (<code>b'\n'</code>) after every 76 bytes of the output, as well as ensuring that the output always ends with a newline, as per <span class="target" id="index-9"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> (MIME).</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="base64.encodebytes">
<code>base64.encodebytes(s)</code> </dt> <dd>
<p>Encode the <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> <em>s</em>, which can contain arbitrary binary data, and return <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> containing the base64-encoded data, with newlines (<code>b'\n'</code>) inserted after every 76 bytes of output, and ensuring that there is a trailing newline, as per <span class="target" id="index-10"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> (MIME).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.1.</span></p> </div> </dd>
</dl> <p>An example usage of the module:</p> <pre data-language="python">&gt;&gt;&gt; import base64
&gt;&gt;&gt; encoded = base64.b64encode(b'data to be encoded')
&gt;&gt;&gt; encoded
b'ZGF0YSB0byBiZSBlbmNvZGVk'
&gt;&gt;&gt; data = base64.b64decode(encoded)
&gt;&gt;&gt; data
b'data to be encoded'
</pre> <section id="security-considerations"> <span id="base64-security"></span><h2>Security Considerations</h2> <p>A new security considerations section was added to <span class="target" id="index-11"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4648.html"><strong>RFC 4648</strong></a> (section 12); it’s recommended to review the security section for any code deployed to production.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="binascii.html#module-binascii" title="binascii: Tools for converting between binary and various ASCII-encoded binary representations."><code>binascii</code></a>
</dt>
<dd>
<p>Support module containing ASCII-to-binary and binary-to-ASCII conversions.</p> </dd> <dt>
<span class="target" id="index-12"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1521.html"><strong>RFC 1521</strong></a> - MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies</dt>
<dd>
<p>Section 5.2, “Base64 Content-Transfer-Encoding,” provides the definition of the base64 encoding.</p> </dd> </dl> </div> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/base64.html" class="_attribution-link">https://docs.python.org/3.12/library/base64.html</a>
  </p>
</div>
