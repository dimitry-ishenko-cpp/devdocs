 <span id="dis-disassembler-for-python-bytecode"></span><h1>dis — Disassembler for Python bytecode</h1> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/dis.py">Lib/dis.py</a></p>  <p>The <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> module supports the analysis of CPython <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> by disassembling it. The CPython bytecode which this module takes as an input is defined in the file <code>Include/opcode.h</code> and used by the compiler and the interpreter.</p> <div class="impl-detail compound"> <p class="compound-first"><strong>CPython implementation detail:</strong> Bytecode is an implementation detail of the CPython interpreter. No guarantees are made that bytecode will not be added, removed, or changed between versions of Python. Use of this module should not be considered to work across Python VMs or Python releases.</p> <div class="compound-middle versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Use 2 bytes for each instruction. Previously the number of bytes varied by instruction.</p> </div> <div class="compound-middle versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The argument of jump, exception handling and loop instructions is now the instruction offset rather than the byte offset.</p> </div> <div class="compound-middle versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Some instructions are accompanied by one or more inline cache entries, which take the form of <a class="reference internal" href="#opcode-CACHE"><code>CACHE</code></a> instructions. These instructions are hidden by default, but can be shown by passing <code>show_caches=True</code> to any <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> utility. Furthermore, the interpreter now adapts the bytecode to specialize it for different runtime conditions. The adaptive bytecode can be shown by passing <code>adaptive=True</code>.</p> </div> <div class="compound-last versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The argument of a jump is the offset of the target instruction relative to the instruction that appears immediately after the jump instruction’s <a class="reference internal" href="#opcode-CACHE"><code>CACHE</code></a> entries.</p> <p>As a consequence, the presence of the <a class="reference internal" href="#opcode-CACHE"><code>CACHE</code></a> instructions is transparent for forward jumps but needs to be taken into account when reasoning about backward jumps.</p> </div> </div> <p>Example: Given the function <code>myfunc()</code>:</p> <pre data-language="python">def myfunc(alist):
    return len(alist)
</pre> <p>the following command can be used to display the disassembly of <code>myfunc()</code>:</p> <pre data-language="pycon3">&gt;&gt;&gt; dis.dis(myfunc)
  2           0 RESUME                   0

  3           2 LOAD_GLOBAL              1 (NULL + len)
             12 LOAD_FAST                0 (alist)
             14 CALL                     1
             22 RETURN_VALUE
</pre> <p>(The “2” is a line number).</p> <section id="command-line-interface"> <span id="dis-cli"></span><h2>Command-line interface</h2> <p>The <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> module can be invoked as a script from the command line:</p> <pre data-language="sh">python -m dis [-h] [infile]
</pre> <p>The following options are accepted:</p> <dl class="std cmdoption"> <dt class="sig sig-object std" id="cmdoption-dis-h">
<code>-h, --help</code> </dt> <dd>
<p>Display usage and exit.</p> </dd>
</dl> <p>If <code>infile</code> is specified, its disassembled code will be written to stdout. Otherwise, disassembly is performed on compiled source code recieved from stdin.</p> </section> <section id="bytecode-analysis"> <h2>Bytecode analysis</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> <p>The bytecode analysis API allows pieces of Python code to be wrapped in a <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> object that provides easy access to details of the compiled code.</p> <dl class="py class"> <dt class="sig sig-object py" id="dis.Bytecode">
<code>class dis.Bytecode(x, *, first_line=None, current_offset=None, show_caches=False, adaptive=False)</code> </dt> <dd>
<p>Analyse the bytecode corresponding to a function, generator, asynchronous generator, coroutine, method, string of source code, or a code object (as returned by <a class="reference internal" href="functions.html#compile" title="compile"><code>compile()</code></a>).</p> <p>This is a convenience wrapper around many of the functions listed below, most notably <a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code>get_instructions()</code></a>, as iterating over a <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> instance yields the bytecode operations as <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code>Instruction</code></a> instances.</p> <p>If <em>first_line</em> is not <code>None</code>, it indicates the line number that should be reported for the first source line in the disassembled code. Otherwise, the source line information (if any) is taken directly from the disassembled code object.</p> <p>If <em>current_offset</em> is not <code>None</code>, it refers to an instruction offset in the disassembled code. Setting this means <a class="reference internal" href="#dis.Bytecode.dis" title="dis.Bytecode.dis"><code>dis()</code></a> will display a “current instruction” marker against the specified opcode.</p> <p>If <em>show_caches</em> is <code>True</code>, <a class="reference internal" href="#dis.Bytecode.dis" title="dis.Bytecode.dis"><code>dis()</code></a> will display inline cache entries used by the interpreter to specialize the bytecode.</p> <p>If <em>adaptive</em> is <code>True</code>, <a class="reference internal" href="#dis.Bytecode.dis" title="dis.Bytecode.dis"><code>dis()</code></a> will display specialized bytecode that may be different from the original bytecode.</p> <dl class="py method"> <dt class="sig sig-object py" id="dis.Bytecode.from_traceback">
<code>classmethod from_traceback(tb, *, show_caches=False)</code> </dt> <dd>
<p>Construct a <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> instance from the given traceback, setting <em>current_offset</em> to the instruction responsible for the exception.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Bytecode.codeobj">
<code>codeobj</code> </dt> <dd>
<p>The compiled code object.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Bytecode.first_line">
<code>first_line</code> </dt> <dd>
<p>The first source line of the code object (if available)</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="dis.Bytecode.dis">
<code>dis()</code> </dt> <dd>
<p>Return a formatted view of the bytecode operations (the same as printed by <a class="reference internal" href="#dis.dis" title="dis.dis"><code>dis.dis()</code></a>, but returned as a multi-line string).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="dis.Bytecode.info">
<code>info()</code> </dt> <dd>
<p>Return a formatted multi-line string with detailed information about the code object, like <a class="reference internal" href="#dis.code_info" title="dis.code_info"><code>code_info()</code></a>.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>This can now handle coroutine and asynchronous generator objects.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Added the <em>show_caches</em> and <em>adaptive</em> parameters.</p> </div> </dd>
</dl> <p>Example:</p> <pre data-language="pycon3">&gt;&gt;&gt; bytecode = dis.Bytecode(myfunc)
&gt;&gt;&gt; for instr in bytecode:
...     print(instr.opname)
...
RESUME
LOAD_GLOBAL
LOAD_FAST
CALL
RETURN_VALUE
</pre> </section> <section id="analysis-functions"> <h2>Analysis functions</h2> <p>The <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> module also defines the following analysis functions that convert the input directly to the desired output. They can be useful if only a single operation is being performed, so the intermediate analysis object isn’t useful:</p> <dl class="py function"> <dt class="sig sig-object py" id="dis.code_info">
<code>dis.code_info(x)</code> </dt> <dd>
<p>Return a formatted multi-line string with detailed code object information for the supplied function, generator, asynchronous generator, coroutine, method, source code string or code object.</p> <p>Note that the exact contents of code info strings are highly implementation dependent and they may change arbitrarily across Python VMs or Python releases.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>This can now handle coroutine and asynchronous generator objects.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="dis.show_code">
<code>dis.show_code(x, *, file=None)</code> </dt> <dd>
<p>Print detailed code object information for the supplied function, method, source code string or code object to <em>file</em> (or <code>sys.stdout</code> if <em>file</em> is not specified).</p> <p>This is a convenient shorthand for <code>print(code_info(x), file=file)</code>, intended for interactive exploration at the interpreter prompt.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="dis.dis">
<code>dis.dis(x=None, *, file=None, depth=None, show_caches=False, adaptive=False)</code> </dt> <dd>
<p>Disassemble the <em>x</em> object. <em>x</em> can denote either a module, a class, a method, a function, a generator, an asynchronous generator, a coroutine, a code object, a string of source code or a byte sequence of raw bytecode. For a module, it disassembles all functions. For a class, it disassembles all methods (including class and static methods). For a code object or sequence of raw bytecode, it prints one line per bytecode instruction. It also recursively disassembles nested code objects. These can include generator expressions, nested functions, the bodies of nested classes, and the code objects used for <a class="reference internal" href="../reference/executionmodel.html#annotation-scopes"><span class="std std-ref">annotation scopes</span></a>. Strings are first compiled to code objects with the <a class="reference internal" href="functions.html#compile" title="compile"><code>compile()</code></a> built-in function before being disassembled. If no object is provided, this function disassembles the last traceback.</p> <p>The disassembly is written as text to the supplied <em>file</em> argument if provided and to <code>sys.stdout</code> otherwise.</p> <p>The maximal depth of recursion is limited by <em>depth</em> unless it is <code>None</code>. <code>depth=0</code> means no recursion.</p> <p>If <em>show_caches</em> is <code>True</code>, this function will display inline cache entries used by the interpreter to specialize the bytecode.</p> <p>If <em>adaptive</em> is <code>True</code>, this function will display specialized bytecode that may be different from the original bytecode.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Implemented recursive disassembling and added <em>depth</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>This can now handle coroutine and asynchronous generator objects.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Added the <em>show_caches</em> and <em>adaptive</em> parameters.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="dis.distb">
<code>dis.distb(tb=None, *, file=None, show_caches=False, adaptive=False)</code> </dt> <dd>
<p>Disassemble the top-of-stack function of a traceback, using the last traceback if none was passed. The instruction causing the exception is indicated.</p> <p>The disassembly is written as text to the supplied <em>file</em> argument if provided and to <code>sys.stdout</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Added the <em>show_caches</em> and <em>adaptive</em> parameters.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="dis.disassemble">
<code>dis.disassemble(code, lasti=- 1, *, file=None, show_caches=False, adaptive=False)</code> </dt> <dt class="sig sig-object py" id="dis.disco">
<code>dis.disco(code, lasti=- 1, *, file=None, show_caches=False, adaptive=False)</code> </dt> <dd>
<p>Disassemble a code object, indicating the last instruction if <em>lasti</em> was provided. The output is divided in the following columns:</p> <ol class="arabic simple"> <li>the line number, for the first instruction of each line</li> <li>the current instruction, indicated as <code>--&gt;</code>,</li> <li>a labelled instruction, indicated with <code>&gt;&gt;</code>,</li> <li>the address of the instruction,</li> <li>the operation code name,</li> <li>operation parameters, and</li> <li>interpretation of the parameters in parentheses.</li> </ol> <p>The parameter interpretation recognizes local and global variable names, constant values, branch targets, and compare operators.</p> <p>The disassembly is written as text to the supplied <em>file</em> argument if provided and to <code>sys.stdout</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Added the <em>show_caches</em> and <em>adaptive</em> parameters.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="dis.get_instructions">
<code>dis.get_instructions(x, *, first_line=None, show_caches=False, adaptive=False)</code> </dt> <dd>
<p>Return an iterator over the instructions in the supplied function, method, source code string or code object.</p> <p>The iterator generates a series of <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code>Instruction</code></a> named tuples giving the details of each operation in the supplied code.</p> <p>If <em>first_line</em> is not <code>None</code>, it indicates the line number that should be reported for the first source line in the disassembled code. Otherwise, the source line information (if any) is taken directly from the disassembled code object.</p> <p>The <em>show_caches</em> and <em>adaptive</em> parameters work as they do in <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Added the <em>show_caches</em> and <em>adaptive</em> parameters.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="dis.findlinestarts">
<code>dis.findlinestarts(code)</code> </dt> <dd>
<p>This generator function uses the <a class="reference internal" href="../reference/datamodel.html#codeobject.co_lines" title="codeobject.co_lines"><code>co_lines()</code></a> method of the <a class="reference internal" href="../reference/datamodel.html#code-objects"><span class="std std-ref">code object</span></a> <em>code</em> to find the offsets which are starts of lines in the source code. They are generated as <code>(offset, lineno)</code> pairs.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Line numbers can be decreasing. Before, they were always increasing.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0626/"><strong>PEP 626</strong></a> <a class="reference internal" href="../reference/datamodel.html#codeobject.co_lines" title="codeobject.co_lines"><code>co_lines()</code></a> method is used instead of the <a class="reference internal" href="../reference/datamodel.html#codeobject.co_firstlineno" title="codeobject.co_firstlineno"><code>co_firstlineno</code></a> and <a class="reference internal" href="../reference/datamodel.html#codeobject.co_lnotab" title="codeobject.co_lnotab"><code>co_lnotab</code></a> attributes of the <a class="reference internal" href="../reference/datamodel.html#code-objects"><span class="std std-ref">code object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="dis.findlabels">
<code>dis.findlabels(code)</code> </dt> <dd>
<p>Detect all offsets in the raw compiled bytecode string <em>code</em> which are jump targets, and return a list of these offsets.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="dis.stack_effect">
<code>dis.stack_effect(opcode, oparg=None, *, jump=None)</code> </dt> <dd>
<p>Compute the stack effect of <em>opcode</em> with argument <em>oparg</em>.</p> <p>If the code has a jump target and <em>jump</em> is <code>True</code>, <a class="reference internal" href="#dis.stack_effect" title="dis.stack_effect"><code>stack_effect()</code></a> will return the stack effect of jumping. If <em>jump</em> is <code>False</code>, it will return the stack effect of not jumping. And if <em>jump</em> is <code>None</code> (default), it will return the maximal stack effect of both cases.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added <em>jump</em> parameter.</p> </div> </dd>
</dl> </section> <section id="python-bytecode-instructions"> <span id="bytecodes"></span><h2>Python Bytecode Instructions</h2> <p>The <a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code>get_instructions()</code></a> function and <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> class provide details of bytecode instructions as <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code>Instruction</code></a> instances:</p> <dl class="py class"> <dt class="sig sig-object py" id="dis.Instruction">
<code>class dis.Instruction</code> </dt> <dd>
<p>Details for a bytecode operation</p> <dl class="py data"> <dt class="sig sig-object py" id="dis.Instruction.opcode">
<code>opcode</code> </dt> <dd>
<p>numeric code for operation, corresponding to the opcode values listed below and the bytecode values in the <a class="reference internal" href="#opcode-collections"><span class="std std-ref">Opcode collections</span></a>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Instruction.opname">
<code>opname</code> </dt> <dd>
<p>human readable name for operation</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Instruction.arg">
<code>arg</code> </dt> <dd>
<p>numeric argument to operation (if any), otherwise <code>None</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Instruction.argval">
<code>argval</code> </dt> <dd>
<p>resolved arg value (if any), otherwise <code>None</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Instruction.argrepr">
<code>argrepr</code> </dt> <dd>
<p>human readable description of operation argument (if any), otherwise an empty string.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Instruction.offset">
<code>offset</code> </dt> <dd>
<p>start index of operation within bytecode sequence</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Instruction.starts_line">
<code>starts_line</code> </dt> <dd>
<p>line started by this opcode (if any), otherwise <code>None</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Instruction.is_jump_target">
<code>is_jump_target</code> </dt> <dd>
<p><code>True</code> if other code jumps to here, otherwise <code>False</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Instruction.positions">
<code>positions</code> </dt> <dd>
<p><a class="reference internal" href="#dis.Positions" title="dis.Positions"><code>dis.Positions</code></a> object holding the start and end locations that are covered by this instruction.</p> </dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Field <code>positions</code> is added.</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="dis.Positions">
<code>class dis.Positions</code> </dt> <dd>
<p>In case the information is not available, some fields might be <code>None</code>.</p> <dl class="py data"> <dt class="sig sig-object py" id="dis.Positions.lineno">
<code>lineno</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Positions.end_lineno">
<code>end_lineno</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Positions.col_offset">
<code>col_offset</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.Positions.end_col_offset">
<code>end_col_offset</code> </dt> <dd></dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <p>The Python compiler currently generates the following bytecode instructions.</p> <p><strong>General instructions</strong></p> <p>In the following, We will refer to the interpreter stack as <code>STACK</code> and describe operations on it as if it was a Python list. The top of the stack corresponds to <code>STACK[-1]</code> in this language.</p> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-NOP">
<code>NOP</code> </dt> <dd>
<p>Do nothing code. Used as a placeholder by the bytecode optimizer, and to generate line tracing events.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-POP_TOP">
<code>POP_TOP</code> </dt> <dd>
<p>Removes the top-of-stack item:</p> <pre data-language="python">STACK.pop()
</pre> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-END_FOR">
<code>END_FOR</code> </dt> <dd>
<p>Removes the top two values from the stack. Equivalent to <code>POP_TOP</code>; <code>POP_TOP</code>. Used to clean up at the end of loops, hence the name.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-END_SEND">
<code>END_SEND</code> </dt> <dd>
<p>Implements <code>del STACK[-2]</code>. Used to clean up when a generator exits.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-COPY">
<code>COPY(i)</code> </dt> <dd>
<p>Push the i-th item to the top of the stack without removing it from its original location:</p> <pre data-language="python">assert i &gt; 0
STACK.append(STACK[-i])
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-SWAP">
<code>SWAP(i)</code> </dt> <dd>
<p>Swap the top of the stack with the i-th element:</p> <pre data-language="python">STACK[-i], STACK[-1] = stack[-1], STACK[-i]
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-CACHE">
<code>CACHE</code> </dt> <dd>
<p>Rather than being an actual instruction, this opcode is used to mark extra space for the interpreter to cache useful data directly in the bytecode itself. It is automatically hidden by all <code>dis</code> utilities, but can be viewed with <code>show_caches=True</code>.</p> <p>Logically, this space is part of the preceding instruction. Many opcodes expect to be followed by an exact number of caches, and will instruct the interpreter to skip over them at runtime.</p> <p>Populated caches can look like arbitrary instructions, so great care should be taken when reading or modifying raw, adaptive bytecode containing quickened data.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <p><strong>Unary operations</strong></p> <p>Unary operations take the top of the stack, apply the operation, and push the result back on the stack.</p> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-UNARY_NEGATIVE">
<code>UNARY_NEGATIVE</code> </dt> <dd>
<p>Implements <code>STACK[-1] = -STACK[-1]</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-UNARY_NOT">
<code>UNARY_NOT</code> </dt> <dd>
<p>Implements <code>STACK[-1] = not STACK[-1]</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-UNARY_INVERT">
<code>UNARY_INVERT</code> </dt> <dd>
<p>Implements <code>STACK[-1] = ~STACK[-1]</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-GET_ITER">
<code>GET_ITER</code> </dt> <dd>
<p>Implements <code>STACK[-1] = iter(STACK[-1])</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-GET_YIELD_FROM_ITER">
<code>GET_YIELD_FROM_ITER</code> </dt> <dd>
<p>If <code>STACK[-1]</code> is a <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> or <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> object it is left as is. Otherwise, implements <code>STACK[-1] = iter(STACK[-1])</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <p><strong>Binary and in-place operations</strong></p> <p>Binary operations remove the top two items from the stack (<code>STACK[-1]</code> and <code>STACK[-2]</code>). They perform the operation, then put the result back on the stack.</p> <p>In-place operations are like binary operations, but the operation is done in-place when <code>STACK[-2]</code> supports it, and the resulting <code>STACK[-1]</code> may be (but does not have to be) the original <code>STACK[-2]</code>.</p> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BINARY_OP">
<code>BINARY_OP(op)</code> </dt> <dd>
<p>Implements the binary and in-place operators (depending on the value of <em>op</em>):</p> <pre data-language="python">rhs = STACK.pop()
lhs = STACK.pop()
STACK.append(lhs op rhs)
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BINARY_SUBSCR">
<code>BINARY_SUBSCR</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">key = STACK.pop()
container = STACK.pop()
STACK.append(container[key])
</pre> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-STORE_SUBSCR">
<code>STORE_SUBSCR</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">key = STACK.pop()
container = STACK.pop()
value = STACK.pop()
container[key] = value
</pre> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-DELETE_SUBSCR">
<code>DELETE_SUBSCR</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">key = STACK.pop()
container = STACK.pop()
del container[key]
</pre> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BINARY_SLICE">
<code>BINARY_SLICE</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">end = STACK.pop()
start = STACK.pop()
container = STACK.pop()
STACK.append(container[start:end])
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-STORE_SLICE">
<code>STORE_SLICE</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">end = STACK.pop()
start = STACK.pop()
container = STACK.pop()
values = STACK.pop()
container[start:end] = value
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <p><strong>Coroutine opcodes</strong></p> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-GET_AWAITABLE">
<code>GET_AWAITABLE(where)</code> </dt> <dd>
<p>Implements <code>STACK[-1] = get_awaitable(STACK[-1])</code>, where <code>get_awaitable(o)</code> returns <code>o</code> if <code>o</code> is a coroutine object or a generator object with the <a class="reference internal" href="inspect.html#inspect.CO_ITERABLE_COROUTINE" title="inspect.CO_ITERABLE_COROUTINE"><code>CO_ITERABLE_COROUTINE</code></a> flag, or resolves <code>o.__await__</code>.</p>  <p>If the <code>where</code> operand is nonzero, it indicates where the instruction occurs:</p> <ul class="simple"> <li>
<code>1</code>: After a call to <code>__aenter__</code>
</li> <li>
<code>2</code>: After a call to <code>__aexit__</code>
</li> </ul>  <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Previously, this instruction did not have an oparg.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-GET_AITER">
<code>GET_AITER</code> </dt> <dd>
<p>Implements <code>STACK[-1] = STACK[-1].__aiter__()</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Returning awaitable objects from <code>__aiter__</code> is no longer supported.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-GET_ANEXT">
<code>GET_ANEXT</code> </dt> <dd>
<p>Implement <code>STACK.append(get_awaitable(STACK[-1].__anext__()))</code> to the stack. See <code>GET_AWAITABLE</code> for details about <code>get_awaitable</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-END_ASYNC_FOR">
<code>END_ASYNC_FOR</code> </dt> <dd>
<p>Terminates an <a class="reference internal" href="../reference/compound_stmts.html#async-for"><code>async for</code></a> loop. Handles an exception raised when awaiting a next item. The stack contains the async iterable in <code>STACK[-2]</code> and the raised exception in <code>STACK[-1]</code>. Both are popped. If the exception is not <a class="reference internal" href="exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code>StopAsyncIteration</code></a>, it is re-raised.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Exception representation on the stack now consist of one, not three, items.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-CLEANUP_THROW">
<code>CLEANUP_THROW</code> </dt> <dd>
<p>Handles an exception raised during a <a class="reference internal" href="../reference/expressions.html#generator.throw" title="generator.throw"><code>throw()</code></a> or <a class="reference internal" href="../reference/expressions.html#generator.close" title="generator.close"><code>close()</code></a> call through the current frame. If <code>STACK[-1]</code> is an instance of <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a>, pop three values from the stack and push its <code>value</code> member. Otherwise, re-raise <code>STACK[-1]</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BEFORE_ASYNC_WITH">
<code>BEFORE_ASYNC_WITH</code> </dt> <dd>
<p>Resolves <code>__aenter__</code> and <code>__aexit__</code> from <code>STACK[-1]</code>. Pushes <code>__aexit__</code> and result of <code>__aenter__()</code> to the stack:</p> <pre data-language="python">STACK.extend((__aexit__, __aenter__())
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <p><strong>Miscellaneous opcodes</strong></p> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-SET_ADD">
<code>SET_ADD(i)</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">item = STACK.pop()
set.add(STACK[-i], item)
</pre> <p>Used to implement set comprehensions.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LIST_APPEND">
<code>LIST_APPEND(i)</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">item = STACK.pop()
list.append(STACK[-i], item)
</pre> <p>Used to implement list comprehensions.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-MAP_ADD">
<code>MAP_ADD(i)</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">value = STACK.pop()
key = STACK.pop()
dict.__setitem__(STACK[-i], key, value)
</pre> <p>Used to implement dict comprehensions.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.1.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Map value is <code>STACK[-1]</code> and map key is <code>STACK[-2]</code>. Before, those were reversed.</p> </div> </dd>
</dl> <p>For all of the <a class="reference internal" href="#opcode-SET_ADD"><code>SET_ADD</code></a>, <a class="reference internal" href="#opcode-LIST_APPEND"><code>LIST_APPEND</code></a> and <a class="reference internal" href="#opcode-MAP_ADD"><code>MAP_ADD</code></a> instructions, while the added value or key/value pair is popped off, the container object remains on the stack so that it is available for further iterations of the loop.</p> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-RETURN_VALUE">
<code>RETURN_VALUE</code> </dt> <dd>
<p>Returns with <code>STACK[-1]</code> to the caller of the function.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-RETURN_CONST">
<code>RETURN_CONST(consti)</code> </dt> <dd>
<p>Returns with <code>co_consts[consti]</code> to the caller of the function.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-YIELD_VALUE">
<code>YIELD_VALUE</code> </dt> <dd>
<p>Yields <code>STACK.pop()</code> from a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>oparg set to be the stack depth.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>oparg set to be the exception block depth, for efficient closing of generators.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-SETUP_ANNOTATIONS">
<code>SETUP_ANNOTATIONS</code> </dt> <dd>
<p>Checks whether <code>__annotations__</code> is defined in <code>locals()</code>, if not it is set up to an empty <code>dict</code>. This opcode is only emitted if a class or module body contains <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a> statically.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-POP_EXCEPT">
<code>POP_EXCEPT</code> </dt> <dd>
<p>Pops a value from the stack, which is used to restore the exception state.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Exception representation on the stack now consist of one, not three, items.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-RERAISE">
<code>RERAISE</code> </dt> <dd>
<p>Re-raises the exception currently on top of the stack. If oparg is non-zero, pops an additional value from the stack which is used to set <a class="reference internal" href="../reference/datamodel.html#frame.f_lasti" title="frame.f_lasti"><code>f_lasti</code></a> of the current frame.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Exception representation on the stack now consist of one, not three, items.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-PUSH_EXC_INFO">
<code>PUSH_EXC_INFO</code> </dt> <dd>
<p>Pops a value from the stack. Pushes the current exception to the top of the stack. Pushes the value originally popped back to the stack. Used in exception handlers.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-CHECK_EXC_MATCH">
<code>CHECK_EXC_MATCH</code> </dt> <dd>
<p>Performs exception matching for <code>except</code>. Tests whether the <code>STACK[-2]</code> is an exception matching <code>STACK[-1]</code>. Pops <code>STACK[-1]</code> and pushes the boolean result of the test.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-CHECK_EG_MATCH">
<code>CHECK_EG_MATCH</code> </dt> <dd>
<p>Performs exception matching for <code>except*</code>. Applies <code>split(STACK[-1])</code> on the exception group representing <code>STACK[-2]</code>.</p> <p>In case of a match, pops two items from the stack and pushes the non-matching subgroup (<code>None</code> in case of full match) followed by the matching subgroup. When there is no match, pops one item (the match type) and pushes <code>None</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-WITH_EXCEPT_START">
<code>WITH_EXCEPT_START</code> </dt> <dd>
<p>Calls the function in position 4 on the stack with arguments (type, val, tb) representing the exception at the top of the stack. Used to implement the call <code>context_manager.__exit__(*exc_info())</code> when an exception has occurred in a <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> statement.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>The <code>__exit__</code> function is in position 4 of the stack rather than 7. Exception representation on the stack now consist of one, not three, items.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_ASSERTION_ERROR">
<code>LOAD_ASSERTION_ERROR</code> </dt> <dd>
<p>Pushes <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code>AssertionError</code></a> onto the stack. Used by the <a class="reference internal" href="../reference/simple_stmts.html#assert"><code>assert</code></a> statement.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_BUILD_CLASS">
<code>LOAD_BUILD_CLASS</code> </dt> <dd>
<p>Pushes <code>builtins.__build_class__()</code> onto the stack. It is later called to construct a class.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BEFORE_WITH">
<code>BEFORE_WITH</code> </dt> <dd>
<p>This opcode performs several operations before a with block starts. First, it loads <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code>__exit__()</code></a> from the context manager and pushes it onto the stack for later use by <a class="reference internal" href="#opcode-WITH_EXCEPT_START"><code>WITH_EXCEPT_START</code></a>. Then, <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code>__enter__()</code></a> is called. Finally, the result of calling the <code>__enter__()</code> method is pushed onto the stack.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-GET_LEN">
<code>GET_LEN</code> </dt> <dd>
<p>Perform <code>STACK.append(len(STACK[-1]))</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-MATCH_MAPPING">
<code>MATCH_MAPPING</code> </dt> <dd>
<p>If <code>STACK[-1]</code> is an instance of <a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code>collections.abc.Mapping</code></a> (or, more technically: if it has the <a class="reference internal" href="../c-api/typeobj.html#c.Py_TPFLAGS_MAPPING" title="Py_TPFLAGS_MAPPING"><code>Py_TPFLAGS_MAPPING</code></a> flag set in its <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a>), push <code>True</code> onto the stack. Otherwise, push <code>False</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-MATCH_SEQUENCE">
<code>MATCH_SEQUENCE</code> </dt> <dd>
<p>If <code>STACK[-1]</code> is an instance of <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code>collections.abc.Sequence</code></a> and is <em>not</em> an instance of <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a>/<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>/<a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> (or, more technically: if it has the <a class="reference internal" href="../c-api/typeobj.html#c.Py_TPFLAGS_SEQUENCE" title="Py_TPFLAGS_SEQUENCE"><code>Py_TPFLAGS_SEQUENCE</code></a> flag set in its <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a>), push <code>True</code> onto the stack. Otherwise, push <code>False</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-MATCH_KEYS">
<code>MATCH_KEYS</code> </dt> <dd>
<p><code>STACK[-1]</code> is a tuple of mapping keys, and <code>STACK[-2]</code> is the match subject. If <code>STACK[-2]</code> contains all of the keys in <code>STACK[-1]</code>, push a <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code>tuple</code></a> containing the corresponding values. Otherwise, push <code>None</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Previously, this instruction also pushed a boolean value indicating success (<code>True</code>) or failure (<code>False</code>).</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-STORE_NAME">
<code>STORE_NAME(namei)</code> </dt> <dd>
<p>Implements <code>name = STACK.pop()</code>. <em>namei</em> is the index of <em>name</em> in the attribute <a class="reference internal" href="../reference/datamodel.html#codeobject.co_names" title="codeobject.co_names"><code>co_names</code></a> of the <a class="reference internal" href="../reference/datamodel.html#code-objects"><span class="std std-ref">code object</span></a>. The compiler tries to use <a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a> or <a class="reference internal" href="#opcode-STORE_GLOBAL"><code>STORE_GLOBAL</code></a> if possible.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-DELETE_NAME">
<code>DELETE_NAME(namei)</code> </dt> <dd>
<p>Implements <code>del name</code>, where <em>namei</em> is the index into <a class="reference internal" href="../reference/datamodel.html#codeobject.co_names" title="codeobject.co_names"><code>co_names</code></a> attribute of the <a class="reference internal" href="../reference/datamodel.html#code-objects"><span class="std std-ref">code object</span></a>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-UNPACK_SEQUENCE">
<code>UNPACK_SEQUENCE(count)</code> </dt> <dd>
<p>Unpacks <code>STACK[-1]</code> into <em>count</em> individual values, which are put onto the stack right-to-left. Require there to be exactly <em>count</em> values.:</p> <pre data-language="python">assert(len(STACK[-1]) == count)
STACK.extend(STACK.pop()[:-count-1:-1])
</pre> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-UNPACK_EX">
<code>UNPACK_EX(counts)</code> </dt> <dd>
<p>Implements assignment with a starred target: Unpacks an iterable in <code>STACK[-1]</code> into individual values, where the total number of values can be smaller than the number of items in the iterable: one of the new values will be a list of all leftover items.</p> <p>The number of values before and after the list value is limited to 255.</p> <p>The number of values before the list value is encoded in the argument of the opcode. The number of values after the list if any is encoded using an <code>EXTENDED_ARG</code>. As a consequence, the argument can be seen as a two bytes values where the low byte of <em>counts</em> is the number of values before the list value, the high byte of <em>counts</em> the number of values after it.</p> <p>The extracted values are put onto the stack right-to-left, i.e. <code>a, *b, c = d</code> will be stored after execution as <code>STACK.extend((a, b, c))</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-STORE_ATTR">
<code>STORE_ATTR(namei)</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">obj = STACK.pop()
value = STACK.pop()
obj.name = value
</pre> <p>where <em>namei</em> is the index of name in <a class="reference internal" href="../reference/datamodel.html#codeobject.co_names" title="codeobject.co_names"><code>co_names</code></a> of the <a class="reference internal" href="../reference/datamodel.html#code-objects"><span class="std std-ref">code object</span></a>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-DELETE_ATTR">
<code>DELETE_ATTR(namei)</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">obj = STACK.pop()
del obj.name
</pre> <p>where <em>namei</em> is the index of name into <a class="reference internal" href="../reference/datamodel.html#codeobject.co_names" title="codeobject.co_names"><code>co_names</code></a> of the <a class="reference internal" href="../reference/datamodel.html#code-objects"><span class="std std-ref">code object</span></a>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-STORE_GLOBAL">
<code>STORE_GLOBAL(namei)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-STORE_NAME"><code>STORE_NAME</code></a>, but stores the name as a global.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-DELETE_GLOBAL">
<code>DELETE_GLOBAL(namei)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-DELETE_NAME"><code>DELETE_NAME</code></a>, but deletes a global name.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_CONST">
<code>LOAD_CONST(consti)</code> </dt> <dd>
<p>Pushes <code>co_consts[consti]</code> onto the stack.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_NAME">
<code>LOAD_NAME(namei)</code> </dt> <dd>
<p>Pushes the value associated with <code>co_names[namei]</code> onto the stack. The name is looked up within the locals, then the globals, then the builtins.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_LOCALS">
<code>LOAD_LOCALS</code> </dt> <dd>
<p>Pushes a reference to the locals dictionary onto the stack. This is used to prepare namespace dictionaries for <a class="reference internal" href="#opcode-LOAD_FROM_DICT_OR_DEREF"><code>LOAD_FROM_DICT_OR_DEREF</code></a> and <a class="reference internal" href="#opcode-LOAD_FROM_DICT_OR_GLOBALS"><code>LOAD_FROM_DICT_OR_GLOBALS</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_FROM_DICT_OR_GLOBALS">
<code>LOAD_FROM_DICT_OR_GLOBALS(i)</code> </dt> <dd>
<p>Pops a mapping off the stack and looks up the value for <code>co_names[namei]</code>. If the name is not found there, looks it up in the globals and then the builtins, similar to <a class="reference internal" href="#opcode-LOAD_GLOBAL"><code>LOAD_GLOBAL</code></a>. This is used for loading global variables in <a class="reference internal" href="../reference/executionmodel.html#annotation-scopes"><span class="std std-ref">annotation scopes</span></a> within class bodies.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BUILD_TUPLE">
<code>BUILD_TUPLE(count)</code> </dt> <dd>
<p>Creates a tuple consuming <em>count</em> items from the stack, and pushes the resulting tuple onto the stack.:</p> <pre data-language="python">assert count &gt; 0
STACK, values = STACK[:-count], STACK[-count:]
STACK.append(tuple(values))
</pre> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BUILD_LIST">
<code>BUILD_LIST(count)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-BUILD_TUPLE"><code>BUILD_TUPLE</code></a>, but creates a list.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BUILD_SET">
<code>BUILD_SET(count)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-BUILD_TUPLE"><code>BUILD_TUPLE</code></a>, but creates a set.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BUILD_MAP">
<code>BUILD_MAP(count)</code> </dt> <dd>
<p>Pushes a new dictionary object onto the stack. Pops <code>2 * count</code> items so that the dictionary holds <em>count</em> entries: <code>{..., STACK[-4]: STACK[-3], STACK[-2]: STACK[-1]}</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The dictionary is created from stack items instead of creating an empty dictionary pre-sized to hold <em>count</em> items.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BUILD_CONST_KEY_MAP">
<code>BUILD_CONST_KEY_MAP(count)</code> </dt> <dd>
<p>The version of <a class="reference internal" href="#opcode-BUILD_MAP"><code>BUILD_MAP</code></a> specialized for constant keys. Pops the top element on the stack which contains a tuple of keys, then starting from <code>STACK[-2]</code>, pops <em>count</em> values to form values in the built dictionary.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BUILD_STRING">
<code>BUILD_STRING(count)</code> </dt> <dd>
<p>Concatenates <em>count</em> strings from the stack and pushes the resulting string onto the stack.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LIST_EXTEND">
<code>LIST_EXTEND(i)</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">seq = STACK.pop()
list.extend(STACK[-i], seq)
</pre> <p>Used to build lists.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-SET_UPDATE">
<code>SET_UPDATE(i)</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">seq = STACK.pop()
set.update(STACK[-i], seq)
</pre> <p>Used to build sets.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-DICT_UPDATE">
<code>DICT_UPDATE(i)</code> </dt> <dd>
<p>Implements:</p> <pre data-language="python">map = STACK.pop()
dict.update(STACK[-i], map)
</pre> <p>Used to build dicts.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-DICT_MERGE">
<code>DICT_MERGE(i)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#opcode-DICT_UPDATE"><code>DICT_UPDATE</code></a> but raises an exception for duplicate keys.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_ATTR">
<code>LOAD_ATTR(namei)</code> </dt> <dd>
<p>If the low bit of <code>namei</code> is not set, this replaces <code>STACK[-1]</code> with <code>getattr(STACK[-1], co_names[namei&gt;&gt;1])</code>.</p> <p>If the low bit of <code>namei</code> is set, this will attempt to load a method named <code>co_names[namei&gt;&gt;1]</code> from the <code>STACK[-1]</code> object. <code>STACK[-1]</code> is popped. This bytecode distinguishes two cases: if <code>STACK[-1]</code> has a method with the correct name, the bytecode pushes the unbound method and <code>STACK[-1]</code>. <code>STACK[-1]</code> will be used as the first argument (<code>self</code>) by <a class="reference internal" href="#opcode-CALL"><code>CALL</code></a> when calling the unbound method. Otherwise, <code>NULL</code> and the object returned by the attribute lookup are pushed.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>If the low bit of <code>namei</code> is set, then a <code>NULL</code> or <code>self</code> is pushed to the stack before the attribute or unbound method respectively.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_SUPER_ATTR">
<code>LOAD_SUPER_ATTR(namei)</code> </dt> <dd>
<p>This opcode implements <a class="reference internal" href="functions.html#super" title="super"><code>super()</code></a>, both in its zero-argument and two-argument forms (e.g. <code>super().method()</code>, <code>super().attr</code> and <code>super(cls, self).method()</code>, <code>super(cls, self).attr</code>).</p> <p>It pops three values from the stack (from top of stack down): - <code>self</code>: the first argument to the current method - <code>cls</code>: the class within which the current method was defined - the global <code>super</code></p> <p>With respect to its argument, it works similarly to <a class="reference internal" href="#opcode-LOAD_ATTR"><code>LOAD_ATTR</code></a>, except that <code>namei</code> is shifted left by 2 bits instead of 1.</p> <p>The low bit of <code>namei</code> signals to attempt a method load, as with <a class="reference internal" href="#opcode-LOAD_ATTR"><code>LOAD_ATTR</code></a>, which results in pushing <code>None</code> and the loaded method. When it is unset a single value is pushed to the stack.</p> <p>The second-low bit of <code>namei</code>, if set, means that this was a two-argument call to <a class="reference internal" href="functions.html#super" title="super"><code>super()</code></a> (unset means zero-argument).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-COMPARE_OP">
<code>COMPARE_OP(opname)</code> </dt> <dd>
<p>Performs a Boolean operation. The operation name can be found in <code>cmp_op[opname]</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-IS_OP">
<code>IS_OP(invert)</code> </dt> <dd>
<p>Performs <code>is</code> comparison, or <code>is not</code> if <code>invert</code> is 1.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-CONTAINS_OP">
<code>CONTAINS_OP(invert)</code> </dt> <dd>
<p>Performs <code>in</code> comparison, or <code>not in</code> if <code>invert</code> is 1.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-IMPORT_NAME">
<code>IMPORT_NAME(namei)</code> </dt> <dd>
<p>Imports the module <code>co_names[namei]</code>. <code>STACK[-1]</code> and <code>STACK[-2]</code> are popped and provide the <em>fromlist</em> and <em>level</em> arguments of <a class="reference internal" href="functions.html#import__" title="__import__"><code>__import__()</code></a>. The module object is pushed onto the stack. The current namespace is not affected: for a proper import statement, a subsequent <a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a> instruction modifies the namespace.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-IMPORT_FROM">
<code>IMPORT_FROM(namei)</code> </dt> <dd>
<p>Loads the attribute <code>co_names[namei]</code> from the module found in <code>STACK[-1]</code>. The resulting object is pushed onto the stack, to be subsequently stored by a <a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a> instruction.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-JUMP_FORWARD">
<code>JUMP_FORWARD(delta)</code> </dt> <dd>
<p>Increments bytecode counter by <em>delta</em>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-JUMP_BACKWARD">
<code>JUMP_BACKWARD(delta)</code> </dt> <dd>
<p>Decrements bytecode counter by <em>delta</em>. Checks for interrupts.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-JUMP_BACKWARD_NO_INTERRUPT">
<code>JUMP_BACKWARD_NO_INTERRUPT(delta)</code> </dt> <dd>
<p>Decrements bytecode counter by <em>delta</em>. Does not check for interrupts.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-POP_JUMP_IF_TRUE">
<code>POP_JUMP_IF_TRUE(delta)</code> </dt> <dd>
<p>If <code>STACK[-1]</code> is true, increments the bytecode counter by <em>delta</em>. <code>STACK[-1]</code> is popped.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>The oparg is now a relative delta rather than an absolute target. This opcode is a pseudo-instruction, replaced in final bytecode by the directed versions (forward/backward).</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>This is no longer a pseudo-instruction.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-POP_JUMP_IF_FALSE">
<code>POP_JUMP_IF_FALSE(delta)</code> </dt> <dd>
<p>If <code>STACK[-1]</code> is false, increments the bytecode counter by <em>delta</em>. <code>STACK[-1]</code> is popped.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>The oparg is now a relative delta rather than an absolute target. This opcode is a pseudo-instruction, replaced in final bytecode by the directed versions (forward/backward).</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>This is no longer a pseudo-instruction.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-POP_JUMP_IF_NOT_NONE">
<code>POP_JUMP_IF_NOT_NONE(delta)</code> </dt> <dd>
<p>If <code>STACK[-1]</code> is not <code>None</code>, increments the bytecode counter by <em>delta</em>. <code>STACK[-1]</code> is popped.</p> <p>This opcode is a pseudo-instruction, replaced in final bytecode by the directed versions (forward/backward).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>This is no longer a pseudo-instruction.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-POP_JUMP_IF_NONE">
<code>POP_JUMP_IF_NONE(delta)</code> </dt> <dd>
<p>If <code>STACK[-1]</code> is <code>None</code>, increments the bytecode counter by <em>delta</em>. <code>STACK[-1]</code> is popped.</p> <p>This opcode is a pseudo-instruction, replaced in final bytecode by the directed versions (forward/backward).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>This is no longer a pseudo-instruction.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-FOR_ITER">
<code>FOR_ITER(delta)</code> </dt> <dd>
<p><code>STACK[-1]</code> is an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>. Call its <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> method. If this yields a new value, push it on the stack (leaving the iterator below it). If the iterator indicates it is exhausted then the byte code counter is incremented by <em>delta</em>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Up until 3.11 the iterator was popped when it was exhausted.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_GLOBAL">
<code>LOAD_GLOBAL(namei)</code> </dt> <dd>
<p>Loads the global named <code>co_names[namei&gt;&gt;1]</code> onto the stack.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>If the low bit of <code>namei</code> is set, then a <code>NULL</code> is pushed to the stack before the global variable.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_FAST">
<code>LOAD_FAST(var_num)</code> </dt> <dd>
<p>Pushes a reference to the local <code>co_varnames[var_num]</code> onto the stack.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>This opcode is now only used in situations where the local variable is guaranteed to be initialized. It cannot raise <a class="reference internal" href="exceptions.html#UnboundLocalError" title="UnboundLocalError"><code>UnboundLocalError</code></a>.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_FAST_CHECK">
<code>LOAD_FAST_CHECK(var_num)</code> </dt> <dd>
<p>Pushes a reference to the local <code>co_varnames[var_num]</code> onto the stack, raising an <a class="reference internal" href="exceptions.html#UnboundLocalError" title="UnboundLocalError"><code>UnboundLocalError</code></a> if the local variable has not been initialized.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_FAST_AND_CLEAR">
<code>LOAD_FAST_AND_CLEAR(var_num)</code> </dt> <dd>
<p>Pushes a reference to the local <code>co_varnames[var_num]</code> onto the stack (or pushes <code>NULL</code> onto the stack if the local variable has not been initialized) and sets <code>co_varnames[var_num]</code> to <code>NULL</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-STORE_FAST">
<code>STORE_FAST(var_num)</code> </dt> <dd>
<p>Stores <code>STACK.pop()</code> into the local <code>co_varnames[var_num]</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-DELETE_FAST">
<code>DELETE_FAST(var_num)</code> </dt> <dd>
<p>Deletes local <code>co_varnames[var_num]</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-MAKE_CELL">
<code>MAKE_CELL(i)</code> </dt> <dd>
<p>Creates a new cell in slot <code>i</code>. If that slot is nonempty then that value is stored into the new cell.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_CLOSURE">
<code>LOAD_CLOSURE(i)</code> </dt> <dd>
<p>Pushes a reference to the cell contained in slot <code>i</code> of the “fast locals” storage. The name of the variable is <code>co_fastlocalnames[i]</code>.</p> <p>Note that <code>LOAD_CLOSURE</code> is effectively an alias for <code>LOAD_FAST</code>. It exists to keep bytecode a little more readable.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><code>i</code> is no longer offset by the length of <code>co_varnames</code>.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_DEREF">
<code>LOAD_DEREF(i)</code> </dt> <dd>
<p>Loads the cell contained in slot <code>i</code> of the “fast locals” storage. Pushes a reference to the object the cell contains on the stack.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><code>i</code> is no longer offset by the length of <a class="reference internal" href="../reference/datamodel.html#codeobject.co_varnames" title="codeobject.co_varnames"><code>co_varnames</code></a>.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_FROM_DICT_OR_DEREF">
<code>LOAD_FROM_DICT_OR_DEREF(i)</code> </dt> <dd>
<p>Pops a mapping off the stack and looks up the name associated with slot <code>i</code> of the “fast locals” storage in this mapping. If the name is not found there, loads it from the cell contained in slot <code>i</code>, similar to <a class="reference internal" href="#opcode-LOAD_DEREF"><code>LOAD_DEREF</code></a>. This is used for loading free variables in class bodies (which previously used <code>LOAD_CLASSDEREF</code>) and in <a class="reference internal" href="../reference/executionmodel.html#annotation-scopes"><span class="std std-ref">annotation scopes</span></a> within class bodies.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-STORE_DEREF">
<code>STORE_DEREF(i)</code> </dt> <dd>
<p>Stores <code>STACK.pop()</code> into the cell contained in slot <code>i</code> of the “fast locals” storage.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><code>i</code> is no longer offset by the length of <a class="reference internal" href="../reference/datamodel.html#codeobject.co_varnames" title="codeobject.co_varnames"><code>co_varnames</code></a>.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-DELETE_DEREF">
<code>DELETE_DEREF(i)</code> </dt> <dd>
<p>Empties the cell contained in slot <code>i</code> of the “fast locals” storage. Used by the <a class="reference internal" href="../reference/simple_stmts.html#del"><code>del</code></a> statement.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><code>i</code> is no longer offset by the length of <a class="reference internal" href="../reference/datamodel.html#codeobject.co_varnames" title="codeobject.co_varnames"><code>co_varnames</code></a>.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-COPY_FREE_VARS">
<code>COPY_FREE_VARS(n)</code> </dt> <dd>
<p>Copies the <code>n</code> free variables from the closure into the frame. Removes the need for special code on the caller’s side when calling closures.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-RAISE_VARARGS">
<code>RAISE_VARARGS(argc)</code> </dt> <dd>
<p>Raises an exception using one of the 3 forms of the <code>raise</code> statement, depending on the value of <em>argc</em>:</p> <ul class="simple"> <li>0: <code>raise</code> (re-raise previous exception)</li> <li>1: <code>raise STACK[-1]</code> (raise exception instance or type at <code>STACK[-1]</code>)</li> <li>2: <code>raise STACK[-2] from STACK[-1]</code> (raise exception instance or type at <code>STACK[-2]</code> with <code>__cause__</code> set to <code>STACK[-1]</code>)</li> </ul> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-CALL">
<code>CALL(argc)</code> </dt> <dd>
<p>Calls a callable object with the number of arguments specified by <code>argc</code>, including the named arguments specified by the preceding <a class="reference internal" href="#opcode-KW_NAMES"><code>KW_NAMES</code></a>, if any. On the stack are (in ascending order), either:</p> <ul class="simple"> <li>NULL</li> <li>The callable</li> <li>The positional arguments</li> <li>The named arguments</li> </ul> <p>or:</p> <ul class="simple"> <li>The callable</li> <li><code>self</code></li> <li>The remaining positional arguments</li> <li>The named arguments</li> </ul> <p><code>argc</code> is the total of the positional and named arguments, excluding <code>self</code> when a <code>NULL</code> is not present.</p> <p><code>CALL</code> pops all arguments and the callable object off the stack, calls the callable object with those arguments, and pushes the return value returned by the callable object.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-CALL_FUNCTION_EX">
<code>CALL_FUNCTION_EX(flags)</code> </dt> <dd>
<p>Calls a callable object with variable set of positional and keyword arguments. If the lowest bit of <em>flags</em> is set, the top of the stack contains a mapping object containing additional keyword arguments. Before the callable is called, the mapping object and iterable object are each “unpacked” and their contents passed in as keyword and positional arguments respectively. <code>CALL_FUNCTION_EX</code> pops all arguments and the callable object off the stack, calls the callable object with those arguments, and pushes the return value returned by the callable object.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-PUSH_NULL">
<code>PUSH_NULL</code> </dt> <dd>
<p>Pushes a <code>NULL</code> to the stack. Used in the call sequence to match the <code>NULL</code> pushed by <a class="reference internal" href="#opcode-LOAD_METHOD"><code>LOAD_METHOD</code></a> for non-method calls.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-KW_NAMES">
<code>KW_NAMES(consti)</code> </dt> <dd>
<p>Prefixes <a class="reference internal" href="#opcode-CALL"><code>CALL</code></a>. Stores a reference to <code>co_consts[consti]</code> into an internal variable for use by <a class="reference internal" href="#opcode-CALL"><code>CALL</code></a>. <code>co_consts[consti]</code> must be a tuple of strings.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-MAKE_FUNCTION">
<code>MAKE_FUNCTION(flags)</code> </dt> <dd>
<p>Pushes a new function object on the stack. From bottom to top, the consumed stack must consist of values if the argument carries a specified flag value</p> <ul class="simple"> <li>
<code>0x01</code> a tuple of default values for positional-only and positional-or-keyword parameters in positional order</li> <li>
<code>0x02</code> a dictionary of keyword-only parameters’ default values</li> <li>
<code>0x04</code> a tuple of strings containing parameters’ annotations</li> <li>
<code>0x08</code> a tuple containing cells for free variables, making a closure</li> <li>the code associated with the function (at <code>STACK[-1]</code>)</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>Flag value <code>0x04</code> is a tuple of strings instead of dictionary</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Qualified name at <code>STACK[-1]</code> was removed.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-BUILD_SLICE">
<code>BUILD_SLICE(argc)</code> </dt> <dd>
<p id="index-1">Pushes a slice object on the stack. <em>argc</em> must be 2 or 3. If it is 2, implements:</p> <pre data-language="python">end = STACK.pop()
start = STACK.pop()
STACK.append(slice(start, stop))
</pre> <p>if it is 3, implements:</p> <pre data-language="python">step = STACK.pop()
end = STACK.pop()
start = STACK.pop()
STACK.append(slice(start, end, step))
</pre> <p>See the <a class="reference internal" href="functions.html#slice" title="slice"><code>slice()</code></a> built-in function for more information.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-EXTENDED_ARG">
<code>EXTENDED_ARG(ext)</code> </dt> <dd>
<p>Prefixes any opcode which has an argument too big to fit into the default one byte. <em>ext</em> holds an additional byte which act as higher bits in the argument. For each opcode, at most three prefixal <code>EXTENDED_ARG</code> are allowed, forming an argument from two-byte to four-byte.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-FORMAT_VALUE">
<code>FORMAT_VALUE(flags)</code> </dt> <dd>
<p>Used for implementing formatted literal strings (f-strings). Pops an optional <em>fmt_spec</em> from the stack, then a required <em>value</em>. <em>flags</em> is interpreted as follows:</p> <ul class="simple"> <li>
<code>(flags &amp; 0x03) == 0x00</code>: <em>value</em> is formatted as-is.</li> <li>
<code>(flags &amp; 0x03) == 0x01</code>: call <a class="reference internal" href="stdtypes.html#str" title="str"><code>str()</code></a> on <em>value</em> before formatting it.</li> <li>
<code>(flags &amp; 0x03) == 0x02</code>: call <a class="reference internal" href="functions.html#repr" title="repr"><code>repr()</code></a> on <em>value</em> before formatting it.</li> <li>
<code>(flags &amp; 0x03) == 0x03</code>: call <a class="reference internal" href="functions.html#ascii" title="ascii"><code>ascii()</code></a> on <em>value</em> before formatting it.</li> <li>
<code>(flags &amp; 0x04) == 0x04</code>: pop <em>fmt_spec</em> from the stack and use it, else use an empty <em>fmt_spec</em>.</li> </ul> <p>Formatting is performed using <a class="reference internal" href="../c-api/object.html#c.PyObject_Format" title="PyObject_Format"><code>PyObject_Format()</code></a>. The result is pushed on the stack.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-MATCH_CLASS">
<code>MATCH_CLASS(count)</code> </dt> <dd>
<p><code>STACK[-1]</code> is a tuple of keyword attribute names, <code>STACK[-2]</code> is the class being matched against, and <code>STACK[-3]</code> is the match subject. <em>count</em> is the number of positional sub-patterns.</p> <p>Pop <code>STACK[-1]</code>, <code>STACK[-2]</code>, and <code>STACK[-3]</code>. If <code>STACK[-3]</code> is an instance of <code>STACK[-2]</code> and has the positional and keyword attributes required by <em>count</em> and <code>STACK[-1]</code>, push a tuple of extracted attributes. Otherwise, push <code>None</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Previously, this instruction also pushed a boolean value indicating success (<code>True</code>) or failure (<code>False</code>).</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-RESUME">
<code>RESUME(where)</code> </dt> <dd>
<p>A no-op. Performs internal tracing, debugging and optimization checks.</p> <p>The <code>where</code> operand marks where the <code>RESUME</code> occurs:</p> <ul class="simple"> <li>
<code>0</code> The start of a function, which is neither a generator, coroutine nor an async generator</li> <li>
<code>1</code> After a <code>yield</code> expression</li> <li>
<code>2</code> After a <code>yield from</code> expression</li> <li>
<code>3</code> After an <code>await</code> expression</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-RETURN_GENERATOR">
<code>RETURN_GENERATOR</code> </dt> <dd>
<p>Create a generator, coroutine, or async generator from the current frame. Used as first opcode of in code object for the above mentioned callables. Clear the current frame and return the newly created generator.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-SEND">
<code>SEND(delta)</code> </dt> <dd>
<p>Equivalent to <code>STACK[-1] = STACK[-2].send(STACK[-1])</code>. Used in <code>yield from</code> and <code>await</code> statements.</p> <p>If the call raises <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a>, pop the top value from the stack, push the exception’s <code>value</code> attribute, and increment the bytecode counter by <em>delta</em>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-HAVE_ARGUMENT">
<code>HAVE_ARGUMENT</code> </dt> <dd>
<p>This is not really an opcode. It identifies the dividing line between opcodes in the range [0,255] which don’t use their argument and those that do (<code>&lt; HAVE_ARGUMENT</code> and <code>&gt;= HAVE_ARGUMENT</code>, respectively).</p> <p>If your application uses pseudo instructions, use the <a class="reference internal" href="#dis.hasarg" title="dis.hasarg"><code>hasarg</code></a> collection instead.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Now every instruction has an argument, but opcodes <code>&lt; HAVE_ARGUMENT</code> ignore it. Before, only opcodes <code>&gt;= HAVE_ARGUMENT</code> had an argument.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Pseudo instructions were added to the <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> module, and for them it is not true that comparison with <code>HAVE_ARGUMENT</code> indicates whether they use their arg.</p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-CALL_INTRINSIC_1">
<code>CALL_INTRINSIC_1</code> </dt> <dd>
<p>Calls an intrinsic function with one argument. Passes <code>STACK[-1]</code> as the argument and sets <code>STACK[-1]</code> to the result. Used to implement functionality that is not performance critical.</p> <p>The operand determines which intrinsic function is called:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Operand</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p><code>INTRINSIC_1_INVALID</code></p></td> <td><p>Not valid</p></td> </tr> <tr>
<td><p><code>INTRINSIC_PRINT</code></p></td> <td><p>Prints the argument to standard out. Used in the REPL.</p></td> </tr> <tr>
<td><p><code>INTRINSIC_IMPORT_STAR</code></p></td> <td><p>Performs <code>import *</code> for the named module.</p></td> </tr> <tr>
<td><p><code>INTRINSIC_STOPITERATION_ERROR</code></p></td> <td><p>Extracts the return value from a <code>StopIteration</code> exception.</p></td> </tr> <tr>
<td><p><code>INTRINSIC_ASYNC_GEN_WRAP</code></p></td> <td><p>Wraps an aync generator value</p></td> </tr> <tr>
<td><p><code>INTRINSIC_UNARY_POSITIVE</code></p></td> <td><p>Performs the unary <code>+</code> operation</p></td> </tr> <tr>
<td><p><code>INTRINSIC_LIST_TO_TUPLE</code></p></td> <td><p>Converts a list to a tuple</p></td> </tr> <tr>
<td><p><code>INTRINSIC_TYPEVAR</code></p></td> <td><p>Creates a <a class="reference internal" href="typing.html#typing.TypeVar" title="typing.TypeVar"><code>typing.TypeVar</code></a></p></td> </tr> <tr>
<td><p><code>INTRINSIC_PARAMSPEC</code></p></td> <td><p>Creates a <a class="reference internal" href="typing.html#typing.ParamSpec" title="typing.ParamSpec"><code>typing.ParamSpec</code></a></p></td> </tr> <tr>
<td><p><code>INTRINSIC_TYPEVARTUPLE</code></p></td> <td><p>Creates a <a class="reference internal" href="typing.html#typing.TypeVarTuple" title="typing.TypeVarTuple"><code>typing.TypeVarTuple</code></a></p></td> </tr> <tr>
<td><p><code>INTRINSIC_SUBSCRIPT_GENERIC</code></p></td> <td><p>Returns <a class="reference internal" href="typing.html#typing.Generic" title="typing.Generic"><code>typing.Generic</code></a> subscripted with the argument</p></td> </tr> <tr>
<td><p><code>INTRINSIC_TYPEALIAS</code></p></td> <td><p>Creates a <a class="reference internal" href="typing.html#typing.TypeAliasType" title="typing.TypeAliasType"><code>typing.TypeAliasType</code></a>; used in the <a class="reference internal" href="../reference/simple_stmts.html#type"><code>type</code></a> statement. The argument is a tuple of the type alias’s name, type parameters, and value.</p></td> </tr>  </table> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-CALL_INTRINSIC_2">
<code>CALL_INTRINSIC_2</code> </dt> <dd>
<p>Calls an intrinsic function with two arguments. Used to implement functionality that is not performance critical:</p> <pre data-language="python">arg2 = STACK.pop()
arg1 = STACK.pop()
result = intrinsic2(arg1, arg2)
STACK.push(result)
</pre> <p>The operand determines which intrinsic function is called:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Operand</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p><code>INTRINSIC_2_INVALID</code></p></td> <td><p>Not valid</p></td> </tr> <tr>
<td><p><code>INTRINSIC_PREP_RERAISE_STAR</code></p></td> <td><p>Calculates the <a class="reference internal" href="exceptions.html#ExceptionGroup" title="ExceptionGroup"><code>ExceptionGroup</code></a> to raise from a <code>try-except*</code>.</p></td> </tr> <tr>
<td><p><code>INTRINSIC_TYPEVAR_WITH_BOUND</code></p></td> <td><p>Creates a <a class="reference internal" href="typing.html#typing.TypeVar" title="typing.TypeVar"><code>typing.TypeVar</code></a> with a bound.</p></td> </tr> <tr>
<td><p><code>INTRINSIC_TYPEVAR_WITH_CONSTRAINTS</code></p></td> <td><p>Creates a <a class="reference internal" href="typing.html#typing.TypeVar" title="typing.TypeVar"><code>typing.TypeVar</code></a> with constraints.</p></td> </tr> <tr>
<td><p><code>INTRINSIC_SET_FUNCTION_TYPE_PARAMS</code></p></td> <td><p>Sets the <code>__type_params__</code> attribute of a function.</p></td> </tr>  </table> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <p><strong>Pseudo-instructions</strong></p> <p>These opcodes do not appear in Python bytecode. They are used by the compiler but are replaced by real opcodes or removed before bytecode is generated.</p> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-SETUP_FINALLY">
<code>SETUP_FINALLY(target)</code> </dt> <dd>
<p>Set up an exception handler for the following code block. If an exception occurs, the value stack level is restored to its current state and control is transferred to the exception handler at <code>target</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-SETUP_CLEANUP">
<code>SETUP_CLEANUP(target)</code> </dt> <dd>
<p>Like <code>SETUP_FINALLY</code>, but in case of an exception also pushes the last instruction (<code>lasti</code>) to the stack so that <code>RERAISE</code> can restore it. If an exception occurs, the value stack level and the last instruction on the frame are restored to their current state, and control is transferred to the exception handler at <code>target</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-SETUP_WITH">
<code>SETUP_WITH(target)</code> </dt> <dd>
<p>Like <code>SETUP_CLEANUP</code>, but in case of an exception one more item is popped from the stack before control is transferred to the exception handler at <code>target</code>.</p> <p>This variant is used in <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> and <a class="reference internal" href="../reference/compound_stmts.html#async-with"><code>async with</code></a> constructs, which push the return value of the context manager’s <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code>__enter__()</code></a> or <a class="reference internal" href="../reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code>__aenter__()</code></a> to the stack.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-POP_BLOCK">
<code>POP_BLOCK</code> </dt> <dd>
<p>Marks the end of the code block associated with the last <code>SETUP_FINALLY</code>, <code>SETUP_CLEANUP</code> or <code>SETUP_WITH</code>.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-JUMP">
<code>JUMP</code> </dt> <dd></dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-JUMP_NO_INTERRUPT">
<code>JUMP_NO_INTERRUPT</code> </dt> <dd>
<p>Undirected relative jump instructions which are replaced by their directed (forward/backward) counterparts by the assembler.</p> </dd>
</dl> <dl class="std opcode"> <dt class="sig sig-object std" id="opcode-LOAD_METHOD">
<code>LOAD_METHOD</code> </dt> <dd>
<p>Optimized unbound method lookup. Emitted as a <code>LOAD_ATTR</code> opcode with a flag set in the arg.</p> </dd>
</dl> </section> <section id="opcode-collections"> <span id="id1"></span><h2>Opcode collections</h2> <p>These collections are provided for automatic introspection of bytecode instructions:</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The collections now contain pseudo instructions and instrumented instructions as well. These are opcodes with values <code>&gt;= MIN_PSEUDO_OPCODE</code> and <code>&gt;= MIN_INSTRUMENTED_OPCODE</code>.</p> </div> <dl class="py data"> <dt class="sig sig-object py" id="dis.opname">
<code>dis.opname</code> </dt> <dd>
<p>Sequence of operation names, indexable using the bytecode.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.opmap">
<code>dis.opmap</code> </dt> <dd>
<p>Dictionary mapping operation names to bytecodes.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.cmp_op">
<code>dis.cmp_op</code> </dt> <dd>
<p>Sequence of all compare operation names.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.hasarg">
<code>dis.hasarg</code> </dt> <dd>
<p>Sequence of bytecodes that use their argument.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.hasconst">
<code>dis.hasconst</code> </dt> <dd>
<p>Sequence of bytecodes that access a constant.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.hasfree">
<code>dis.hasfree</code> </dt> <dd>
<p>Sequence of bytecodes that access a free variable. ‘free’ in this context refers to names in the current scope that are referenced by inner scopes or names in outer scopes that are referenced from this scope. It does <em>not</em> include references to global or builtin scopes.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.hasname">
<code>dis.hasname</code> </dt> <dd>
<p>Sequence of bytecodes that access an attribute by name.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.hasjrel">
<code>dis.hasjrel</code> </dt> <dd>
<p>Sequence of bytecodes that have a relative jump target.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.hasjabs">
<code>dis.hasjabs</code> </dt> <dd>
<p>Sequence of bytecodes that have an absolute jump target.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.haslocal">
<code>dis.haslocal</code> </dt> <dd>
<p>Sequence of bytecodes that access a local variable.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.hascompare">
<code>dis.hascompare</code> </dt> <dd>
<p>Sequence of bytecodes of Boolean operations.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="dis.hasexc">
<code>dis.hasexc</code> </dt> <dd>
<p>Sequence of bytecodes that set an exception handler.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/dis.html" class="_attribution-link">https://docs.python.org/3.12/library/dis.html</a>
  </p>
</div>
