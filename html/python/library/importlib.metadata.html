 <span id="importlib-metadata-accessing-package-metadata"></span><span id="using"></span><h1>importlib.metadata – Accessing package metadata</h1> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span><code>importlib.metadata</code> is no longer provisional.</p> </div> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/importlib/metadata/__init__.py">Lib/importlib/metadata/__init__.py</a></p> <p><code>importlib.metadata</code> is a library that provides access to the metadata of an installed <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Distribution-Package">Distribution Package</a>, such as its entry points or its top-level names (<a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Import-Package">Import Package</a>s, modules, if any). Built in part on Python’s import system, this library intends to replace similar functionality in the <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html#entry-points">entry point API</a> and <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html#metadata-api">metadata API</a> of <code>pkg_resources</code>. Along with <a class="reference internal" href="importlib.resources.html#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code>importlib.resources</code></a>, this package can eliminate the need to use the older and less efficient <code>pkg_resources</code> package.</p> <p><code>importlib.metadata</code> operates on third-party <em>distribution packages</em> installed into Python’s <code>site-packages</code> directory via tools such as <a class="extlink-pypi reference external" href="https://pypi.org/project/pip/">pip</a>. Specifically, it works with distributions with discoverable <code>dist-info</code> or <code>egg-info</code> directories, and metadata defined by the <a class="reference external" href="https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata">Core metadata specifications</a>.</p> <div class="admonition important"> <p class="admonition-title">Important</p> <p>These are <em>not</em> necessarily equivalent to or correspond 1:1 with the top-level <em>import package</em> names that can be imported inside Python code. One <em>distribution package</em> can contain multiple <em>import packages</em> (and single modules), and one top-level <em>import package</em> may map to multiple <em>distribution packages</em> if it is a namespace package. You can use <a class="reference internal" href="#package-distributions"><span class="std std-ref">packages_distributions()</span></a> to get a mapping between them.</p> </div> <p>By default, distribution metadata can live on the file system or in zip archives on <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code>sys.path</code></a>. Through an extension mechanism, the metadata can live almost anywhere.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://importlib-metadata.readthedocs.io/">https://importlib-metadata.readthedocs.io/</a></dt>
<dd>
<p>The documentation for <code>importlib_metadata</code>, which supplies a backport of <code>importlib.metadata</code>. This includes an <a class="reference external" href="https://importlib-metadata.readthedocs.io/en/latest/api.html">API reference</a> for this module’s classes and functions, as well as a <a class="reference external" href="https://importlib-metadata.readthedocs.io/en/latest/migration.html">migration guide</a> for existing users of <code>pkg_resources</code>.</p> </dd> </dl> </div> <section id="overview"> <h2>Overview</h2> <p>Let’s say you wanted to get the version string for a <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Distribution-Package">Distribution Package</a> you’ve installed using <code>pip</code>. We start by creating a virtual environment and installing something into it:</p> <pre data-language="shell">$ python -m venv example
$ source example/bin/activate
(example) $ python -m pip install wheel
</pre> <p>You can get the version string for <code>wheel</code> by running the following:</p> <pre data-language="pycon">(example) $ python
&gt;&gt;&gt; from importlib.metadata import version  
&gt;&gt;&gt; version('wheel')  
'0.32.3'
</pre> <p>You can also get a collection of entry points selectable by properties of the EntryPoint (typically ‘group’ or ‘name’), such as <code>console_scripts</code>, <code>distutils.commands</code> and others. Each group contains a collection of <a class="reference internal" href="#entry-points"><span class="std std-ref">EntryPoint</span></a> objects.</p> <p>You can get the <a class="reference internal" href="#metadata"><span class="std std-ref">metadata for a distribution</span></a>:</p> <pre data-language="python">&gt;&gt;&gt; list(metadata('wheel'))  
['Metadata-Version', 'Name', 'Version', 'Summary', 'Home-page', 'Author', 'Author-email', 'Maintainer', 'Maintainer-email', 'License', 'Project-URL', 'Project-URL', 'Project-URL', 'Keywords', 'Platform', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Requires-Python', 'Provides-Extra', 'Requires-Dist', 'Requires-Dist']
</pre> <p>You can also get a <a class="reference internal" href="#version"><span class="std std-ref">distribution’s version number</span></a>, list its <a class="reference internal" href="#files"><span class="std std-ref">constituent files</span></a>, and get a list of the distribution’s <a class="reference internal" href="#requirements"><span class="std std-ref">Distribution requirements</span></a>.</p> <dl class="py exception"> <dt class="sig sig-object py" id="importlib.metadata.PackageNotFoundError">
<code>exception importlib.metadata.PackageNotFoundError</code> </dt> <dd>
<p>Subclass of <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code>ModuleNotFoundError</code></a> raised by several functions in this module when queried for a distribution package which is not installed in the current Python environment.</p> </dd>
</dl> </section> <section id="functional-api"> <h2>Functional API</h2> <p>This package provides the following functionality via its public API.</p> <section id="entry-points"> <span id="id2"></span><h3>Entry points</h3> <dl class="py function"> <dt class="sig sig-object py" id="importlib.metadata.entry_points">
<code>importlib.metadata.entry_points(**select_params)</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#importlib.metadata.EntryPoints" title="importlib.metadata.EntryPoints"><code>EntryPoints</code></a> instance describing entry points for the current environment. Any given keyword parameters are passed to the <code>select()</code> method for comparison to the attributes of the individual entry point definitions.</p> <p>Note: it is not currently possible to query for entry points based on their <code>EntryPoint.dist</code> attribute (as different <code>Distribution</code> instances do not currently compare equal, even if they have the same attributes)</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="importlib.metadata.EntryPoints">
<code>class importlib.metadata.EntryPoints</code> </dt> <dd>
<p>Details of a collection of installed entry points.</p> <p>Also provides a <code>.groups</code> attribute that reports all identified entry point groups, and a <code>.names</code> attribute that reports all identified entry point names.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="importlib.metadata.EntryPoint">
<code>class importlib.metadata.EntryPoint</code> </dt> <dd>
<p>Details of an installed entry point.</p> <p>Each <code>EntryPoint</code> instance has <code>.name</code>, <code>.group</code>, and <code>.value</code> attributes and a <code>.load()</code> method to resolve the value. There are also <code>.module</code>, <code>.attr</code>, and <code>.extras</code> attributes for getting the components of the <code>.value</code> attribute, and <code>.dist</code> for obtaining information regarding the distribution package that provides the entry point.</p> </dd>
</dl> <p>Query all entry points:</p> <pre data-language="python">&gt;&gt;&gt; eps = entry_points()  
</pre> <p>The <code>entry_points()</code> function returns a <code>EntryPoints</code> object, a collection of all <code>EntryPoint</code> objects with <code>names</code> and <code>groups</code> attributes for convenience:</p> <pre data-language="python">&gt;&gt;&gt; sorted(eps.groups)  
['console_scripts', 'distutils.commands', 'distutils.setup_keywords', 'egg_info.writers', 'setuptools.installation']
</pre> <p><code>EntryPoints</code> has a <code>select()</code> method to select entry points matching specific properties. Select entry points in the <code>console_scripts</code> group:</p> <pre data-language="python">&gt;&gt;&gt; scripts = eps.select(group='console_scripts')  
</pre> <p>Equivalently, since <code>entry_points()</code> passes keyword arguments through to select:</p> <pre data-language="python">&gt;&gt;&gt; scripts = entry_points(group='console_scripts')  
</pre> <p>Pick out a specific script named “wheel” (found in the wheel project):</p> <pre data-language="python">&gt;&gt;&gt; 'wheel' in scripts.names  
True
&gt;&gt;&gt; wheel = scripts['wheel']  
</pre> <p>Equivalently, query for that entry point during selection:</p> <pre data-language="python">&gt;&gt;&gt; (wheel,) = entry_points(group='console_scripts', name='wheel')  
&gt;&gt;&gt; (wheel,) = entry_points().select(group='console_scripts', name='wheel')  
</pre> <p>Inspect the resolved entry point:</p> <pre data-language="python">&gt;&gt;&gt; wheel  
EntryPoint(name='wheel', value='wheel.cli:main', group='console_scripts')
&gt;&gt;&gt; wheel.module  
'wheel.cli'
&gt;&gt;&gt; wheel.attr  
'main'
&gt;&gt;&gt; wheel.extras  
[]
&gt;&gt;&gt; main = wheel.load()  
&gt;&gt;&gt; main  
&lt;function main at 0x103528488&gt;
</pre> <p>The <code>group</code> and <code>name</code> are arbitrary values defined by the package author and usually a client will wish to resolve all entry points for a particular group. Read <a class="reference external" href="https://setuptools.pypa.io/en/latest/userguide/entry_point.html">the setuptools docs</a> for more information on entry points, their definition, and usage.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The “selectable” entry points were introduced in <code>importlib_metadata</code> 3.6 and Python 3.10. Prior to those changes, <code>entry_points</code> accepted no parameters and always returned a dictionary of entry points, keyed by group. With <code>importlib_metadata</code> 5.0 and Python 3.12, <code>entry_points</code> always returns an <code>EntryPoints</code> object. See <a class="extlink-pypi reference external" href="https://pypi.org/project/backports.entry_points_selectable/">backports.entry_points_selectable</a> for compatibility options.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span><code>EntryPoint</code> objects no longer present a tuple-like interface (<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a>).</p> </div> </section> <section id="distribution-metadata"> <span id="metadata"></span><h3>Distribution metadata</h3> <dl class="py function"> <dt class="sig sig-object py" id="importlib.metadata.metadata">
<code>importlib.metadata.metadata(distribution_name)</code> </dt> <dd>
<p>Return the distribution metadata corresponding to the named distribution package as a <a class="reference internal" href="#importlib.metadata.PackageMetadata" title="importlib.metadata.PackageMetadata"><code>PackageMetadata</code></a> instance.</p> <p>Raises <a class="reference internal" href="#importlib.metadata.PackageNotFoundError" title="importlib.metadata.PackageNotFoundError"><code>PackageNotFoundError</code></a> if the named distribution package is not installed in the current Python environment.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="importlib.metadata.PackageMetadata">
<code>class importlib.metadata.PackageMetadata</code> </dt> <dd>
<p>A concrete implementation of the <a class="reference external" href="https://importlib-metadata.readthedocs.io/en/latest/api.html#importlib_metadata.PackageMetadata">PackageMetadata protocol</a>.</p> <p>In addition to providing the defined protocol methods and attributes, subscripting the instance is equivalent to calling the <code>get()</code> method.</p> </dd>
</dl> <p>Every <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Distribution-Package">Distribution Package</a> includes some metadata, which you can extract using the <code>metadata()</code> function:</p> <pre data-language="python">&gt;&gt;&gt; wheel_metadata = metadata('wheel')  
</pre> <p>The keys of the returned data structure name the metadata keywords, and the values are returned unparsed from the distribution metadata:</p> <pre data-language="python">&gt;&gt;&gt; wheel_metadata['Requires-Python']  
'&gt;=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'
</pre> <p><a class="reference internal" href="#importlib.metadata.PackageMetadata" title="importlib.metadata.PackageMetadata"><code>PackageMetadata</code></a> also presents a <code>json</code> attribute that returns all the metadata in a JSON-compatible form per <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0566/"><strong>PEP 566</strong></a>:</p> <pre data-language="python">&gt;&gt;&gt; wheel_metadata.json['requires_python']
'&gt;=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'
</pre> <p>The full set of available metadata is not described here. See the PyPA <a class="reference external" href="https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata">Core metadata specification</a> for additional details.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <code>Description</code> is now included in the metadata when presented through the payload. Line continuation characters have been removed.</p> <p>The <code>json</code> attribute was added.</p> </div> </section> <section id="distribution-versions"> <span id="version"></span><h3>Distribution versions</h3> <dl class="py function"> <dt class="sig sig-object py" id="importlib.metadata.version">
<code>importlib.metadata.version(distribution_name)</code> </dt> <dd>
<p>Return the installed distribution package version for the named distribution package.</p> <p>Raises <a class="reference internal" href="#importlib.metadata.PackageNotFoundError" title="importlib.metadata.PackageNotFoundError"><code>PackageNotFoundError</code></a> if the named distribution package is not installed in the current Python environment.</p> </dd>
</dl> <p>The <code>version()</code> function is the quickest way to get a <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Distribution-Package">Distribution Package</a>’s version number, as a string:</p> <pre data-language="python">&gt;&gt;&gt; version('wheel')  
'0.32.3'
</pre> </section> <section id="distribution-files"> <span id="files"></span><h3>Distribution files</h3> <dl class="py function"> <dt class="sig sig-object py" id="importlib.metadata.files">
<code>importlib.metadata.files(distribution_name)</code> </dt> <dd>
<p>Return the full set of files contained within the named distribution package.</p> <p>Raises <a class="reference internal" href="#importlib.metadata.PackageNotFoundError" title="importlib.metadata.PackageNotFoundError"><code>PackageNotFoundError</code></a> if the named distribution package is not installed in the current Python environment.</p> <p>Returns <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a> if the distribution is found but the installation database records reporting the files associated with the distribuion package are missing.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="importlib.metadata.PackagePath">
<code>class importlib.metadata.PackagePath</code> </dt> <dd>
<p>A <a class="reference internal" href="pathlib.html#pathlib.PurePath" title="pathlib.PurePath"><code>pathlib.PurePath</code></a> derived object with additional <code>dist</code>, <code>size</code>, and <code>hash</code> properties corresponding to the distribution package’s installation metadata for that file.</p> </dd>
</dl> <p>The <code>files()</code> function takes a <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Distribution-Package">Distribution Package</a> name and returns all of the files installed by this distribution. Each file is reported as a <a class="reference internal" href="#importlib.metadata.PackagePath" title="importlib.metadata.PackagePath"><code>PackagePath</code></a> instance. For example:</p> <pre data-language="python">&gt;&gt;&gt; util = [p for p in files('wheel') if 'util.py' in str(p)][0]  
&gt;&gt;&gt; util  
PackagePath('wheel/util.py')
&gt;&gt;&gt; util.size  
859
&gt;&gt;&gt; util.dist  
&lt;importlib.metadata._hooks.PathDistribution object at 0x101e0cef0&gt;
&gt;&gt;&gt; util.hash  
&lt;FileHash mode: sha256 value: bYkw5oMccfazVCoYQwKkkemoVyMAFoR34mmKBx8R1NI&gt;
</pre> <p>Once you have the file, you can also read its contents:</p> <pre data-language="python">&gt;&gt;&gt; print(util.read_text())  
import base64
import sys
...
def as_bytes(s):
    if isinstance(s, text_type):
        return s.encode('utf-8')
    return s
</pre> <p>You can also use the <code>locate()</code> method to get the absolute path to the file:</p> <pre data-language="python">&gt;&gt;&gt; util.locate()  
PosixPath('/home/gustav/example/lib/site-packages/wheel/util.py')
</pre> <p>In the case where the metadata file listing files (<code>RECORD</code> or <code>SOURCES.txt</code>) is missing, <code>files()</code> will return <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a>. The caller may wish to wrap calls to <code>files()</code> in <a class="reference external" href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable">always_iterable</a> or otherwise guard against this condition if the target distribution is not known to have the metadata present.</p> </section> <section id="distribution-requirements"> <span id="requirements"></span><h3>Distribution requirements</h3> <dl class="py function"> <dt class="sig sig-object py" id="importlib.metadata.requires">
<code>importlib.metadata.requires(distribution_name)</code> </dt> <dd>
<p>Return the declared dependency specifiers for the named distribution package.</p> <p>Raises <a class="reference internal" href="#importlib.metadata.PackageNotFoundError" title="importlib.metadata.PackageNotFoundError"><code>PackageNotFoundError</code></a> if the named distribution package is not installed in the current Python environment.</p> </dd>
</dl> <p>To get the full set of requirements for a <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Distribution-Package">Distribution Package</a>, use the <code>requires()</code> function:</p> <pre data-language="python">&gt;&gt;&gt; requires('wheel')  
["pytest (&gt;=3.0.0) ; extra == 'test'", "pytest-cov ; extra == 'test'"]
</pre> </section> <section id="mapping-import-to-distribution-packages"> <span id="import-distribution-package-mapping"></span><span id="package-distributions"></span><h3>Mapping import to distribution packages</h3> <dl class="py function"> <dt class="sig sig-object py" id="importlib.metadata.packages_distributions">
<code>importlib.metadata.packages_distributions()</code> </dt> <dd>
<p>Return a mapping from the top level module and import package names found via <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code>sys.meta_path</code></a> to the names of the distribution packages (if any) that provide the corresponding files.</p> <p>To allow for namespace packages (which may have members provided by multiple distribution packages), each top level import name maps to a list of distribution names rather than mapping directly to a single name.</p> </dd>
</dl> <p>A convenience method to resolve the <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Distribution-Package">Distribution Package</a> name (or names, in the case of a namespace package) that provide each importable top-level Python module or <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Import-Package">Import Package</a>:</p> <pre data-language="python">&gt;&gt;&gt; packages_distributions()
{'importlib_metadata': ['importlib-metadata'], 'yaml': ['PyYAML'], 'jaraco': ['jaraco.classes', 'jaraco.functools'], ...}
</pre> <p>Some editable installs, <a class="reference external" href="https://github.com/pypa/packaging-problems/issues/609">do not supply top-level names</a>, and thus this function is not reliable with such installs.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </section> </section> <section id="distributions"> <span id="id9"></span><h2>Distributions</h2> <dl class="py function"> <dt class="sig sig-object py" id="importlib.metadata.distribution">
<code>importlib.metadata.distribution(distribution_name)</code> </dt> <dd>
<p>Return a <a class="reference internal" href="#importlib.metadata.Distribution" title="importlib.metadata.Distribution"><code>Distribution</code></a> instance describing the named distribution package.</p> <p>Raises <a class="reference internal" href="#importlib.metadata.PackageNotFoundError" title="importlib.metadata.PackageNotFoundError"><code>PackageNotFoundError</code></a> if the named distribution package is not installed in the current Python environment.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="importlib.metadata.Distribution">
<code>class importlib.metadata.Distribution</code> </dt> <dd>
<p>Details of an installed distribution package.</p> <p>Note: different <code>Distribution</code> instances do not currently compare equal, even if they relate to the same installed distribution and accordingly have the same attributes.</p> </dd>
</dl> <p>While the module level API described above is the most common and convenient usage, you can get all of that information from the <code>Distribution</code> class. <code>Distribution</code> is an abstract object that represents the metadata for a Python <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Distribution-Package">Distribution Package</a>. You can get the concreate <code>Distribution</code> subclass instance for an installed distribution package by calling the <a class="reference internal" href="#importlib.metadata.distribution" title="importlib.metadata.distribution"><code>distribution()</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from importlib.metadata import distribution  
&gt;&gt;&gt; dist = distribution('wheel')  
&gt;&gt;&gt; type(dist)  
&lt;class 'importlib.metadata.PathDistribution'&gt;
</pre> <p>Thus, an alternative way to get the version number is through the <code>Distribution</code> instance:</p> <pre data-language="python">&gt;&gt;&gt; dist.version  
'0.32.3'
</pre> <p>There are all kinds of additional metadata available on <code>Distribution</code> instances:</p> <pre data-language="python">&gt;&gt;&gt; dist.metadata['Requires-Python']  
'&gt;=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'
&gt;&gt;&gt; dist.metadata['License']  
'MIT'
</pre> <p>For editable packages, an <code>origin</code> property may present <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0610/"><strong>PEP 610</strong></a> metadata:</p> <pre data-language="python">&gt;&gt;&gt; dist.origin.url
'file:///path/to/wheel-0.32.3.editable-py3-none-any.whl'
</pre> <p>The full set of available metadata is not described here. See the PyPA <a class="reference external" href="https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata">Core metadata specification</a> for additional details.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13: </span>The <code>.origin</code> property was added.</p> </div> </section> <section id="distribution-discovery"> <h2>Distribution Discovery</h2> <p>By default, this package provides built-in support for discovery of metadata for file system and zip file <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Distribution-Package">Distribution Package</a>s. This metadata finder search defaults to <code>sys.path</code>, but varies slightly in how it interprets those values from how other import machinery does. In particular:</p> <ul class="simple"> <li>
<code>importlib.metadata</code> does not honor <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> objects on <code>sys.path</code>.</li> <li>
<code>importlib.metadata</code> will incidentally honor <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code>pathlib.Path</code></a> objects on <code>sys.path</code> even though such values will be ignored for imports.</li> </ul> </section> <section id="extending-the-search-algorithm"> <h2>Extending the search algorithm</h2> <p>Because <a class="reference external" href="https://packaging.python.org/en/latest/glossary/#term-Distribution-Package">Distribution Package</a> metadata is not available through <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code>sys.path</code></a> searches, or package loaders directly, the metadata for a distribution is found through import system <a class="reference internal" href="../reference/import.html#finders-and-loaders"><span class="std std-ref">finders</span></a>. To find a distribution package’s metadata, <code>importlib.metadata</code> queries the list of <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finders</span></a> on <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code>sys.meta_path</code></a>.</p> <p>By default <code>importlib.metadata</code> installs a finder for distribution packages found on the file system. This finder doesn’t actually find any <em>distributions</em>, but it can find their metadata.</p> <p>The abstract class <a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code>importlib.abc.MetaPathFinder</code></a> defines the interface expected of finders by Python’s import system. <code>importlib.metadata</code> extends this protocol by looking for an optional <code>find_distributions</code> callable on the finders from <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code>sys.meta_path</code></a> and presents this extended interface as the <code>DistributionFinder</code> abstract base class, which defines this abstract method:</p> <pre data-language="python">@abc.abstractmethod
def find_distributions(context=DistributionFinder.Context()):
    """Return an iterable of all Distribution instances capable of
    loading the metadata for packages for the indicated ``context``.
    """
</pre> <p>The <code>DistributionFinder.Context</code> object provides <code>.path</code> and <code>.name</code> properties indicating the path to search and name to match and may supply other relevant context.</p> <p>What this means in practice is that to support finding distribution package metadata in locations other than the file system, subclass <code>Distribution</code> and implement the abstract methods. Then from a custom finder, return instances of this derived <code>Distribution</code> in the <code>find_distributions()</code> method.</p> <section id="example"> <h3>Example</h3> <p>Consider for example a custom finder that loads Python modules from a database:</p> <pre data-language="python">class DatabaseImporter(importlib.abc.MetaPathFinder):
    def __init__(self, db):
        self.db = db

    def find_spec(self, fullname, target=None) -&gt; ModuleSpec:
        return self.db.spec_from_name(fullname)

sys.meta_path.append(DatabaseImporter(connect_db(...)))
</pre> <p>That importer now presumably provides importable modules from a database, but it provides no metadata or entry points. For this custom importer to provide metadata, it would also need to implement <code>DistributionFinder</code>:</p> <pre data-language="python">from importlib.metadata import DistributionFinder

class DatabaseImporter(DistributionFinder):
    ...

    def find_distributions(self, context=DistributionFinder.Context()):
        query = dict(name=context.name) if context.name else {}
        for dist_record in self.db.query_distributions(query):
            yield DatabaseDistribution(dist_record)
</pre> <p>In this way, <code>query_distributions</code> would return records for each distribution served by the database matching the query. For example, if <code>requests-1.0</code> is in the database, <code>find_distributions</code> would yield a <code>DatabaseDistribution</code> for <code>Context(name='requests')</code> or <code>Context(name=None)</code>.</p> <p>For the sake of simplicity, this example ignores <code>context.path</code>. The <code>path</code> attribute defaults to <code>sys.path</code> and is the set of import paths to be considered in the search. A <code>DatabaseImporter</code> could potentially function without any concern for a search path. Assuming the importer does no partitioning, the “path” would be irrelevant. In order to illustrate the purpose of <code>path</code>, the example would need to illustrate a more complex <code>DatabaseImporter</code> whose behavior varied depending on <code>sys.path</code>/<code>PYTHONPATH</code>. In that case, the <code>find_distributions</code> should honor the <code>context.path</code> and only yield <code>Distribution</code>s pertinent to that path.</p> <p><code>DatabaseDistribution</code>, then, would look something like:</p> <pre data-language="python">class DatabaseDistribution(importlib.metadata.Distribution):
    def __init__(self, record):
        self.record = record

    def read_text(self, filename):
        """
        Read a file like "METADATA" for the current distribution.
        """
        if filename == "METADATA":
            return f"""Name: {self.record.name}
Version: {self.record.version}
"""
        if filename == "entry_points.txt":
            return "\n".join(
              f"""[{ep.group}]\n{ep.name}={ep.value}"""
              for ep in self.record.entry_points)

    def locate_file(self, path):
        raise RuntimeError("This distribution has no file system")
</pre> <p>This basic implementation should provide metadata and entry points for packages served by the <code>DatabaseImporter</code>, assuming that the <code>record</code> supplies suitable <code>.name</code>, <code>.version</code>, and <code>.entry_points</code> attributes.</p> <p>The <code>DatabaseDistribution</code> may also provide other metadata files, like <code>RECORD</code> (required for <code>Distribution.files</code>) or override the implementation of <code>Distribution.files</code>. See the source for more inspiration.</p> </section> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/importlib.metadata.html" class="_attribution-link">https://docs.python.org/3.13/library/importlib.metadata.html</a>
  </p>
</div>
