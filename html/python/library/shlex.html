 <span id="shlex-simple-lexical-analysis"></span><h1>shlex — Simple lexical analysis</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/shlex.py">Lib/shlex.py</a></p>  <p>The <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> class makes it easy to write lexical analyzers for simple syntaxes resembling that of the Unix shell. This will often be useful for writing minilanguages, (for example, in run control files for Python applications) or for parsing quoted strings.</p> <p>The <a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code>shlex</code></a> module defines the following functions:</p> <dl class="py function"> <dt class="sig sig-object py" id="shlex.split">
<code>shlex.split(s, comments=False, posix=True)</code> </dt> <dd>
<p>Split the string <em>s</em> using shell-like syntax. If <em>comments</em> is <a class="reference internal" href="constants.html#False" title="False"><code>False</code></a> (the default), the parsing of comments in the given string will be disabled (setting the <a class="reference internal" href="#shlex.shlex.commenters" title="shlex.shlex.commenters"><code>commenters</code></a> attribute of the <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance to the empty string). This function operates in POSIX mode by default, but uses non-POSIX mode if the <em>posix</em> argument is false.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Passing <code>None</code> for <em>s</em> argument now raises an exception, rather than reading <a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code>sys.stdin</code></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shlex.join">
<code>shlex.join(split_command)</code> </dt> <dd>
<p>Concatenate the tokens of the list <em>split_command</em> and return a string. This function is the inverse of <a class="reference internal" href="#shlex.split" title="shlex.split"><code>split()</code></a>.</p> <pre data-language="python">&gt;&gt;&gt; from shlex import join
&gt;&gt;&gt; print(join(['echo', '-n', 'Multiple words']))
echo -n 'Multiple words'
</pre> <p>The returned value is shell-escaped to protect against injection vulnerabilities (see <a class="reference internal" href="#shlex.quote" title="shlex.quote"><code>quote()</code></a>).</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shlex.quote">
<code>shlex.quote(s)</code> </dt> <dd>
<p>Return a shell-escaped version of the string <em>s</em>. The returned value is a string that can safely be used as one token in a shell command line, for cases where you cannot use a list.</p> <div class="admonition warning" id="shlex-quote-warning"> <p class="admonition-title">Warning</p> <p>The <code>shlex</code> module is <strong>only designed for Unix shells</strong>.</p> <p>The <a class="reference internal" href="#shlex.quote" title="shlex.quote"><code>quote()</code></a> function is not guaranteed to be correct on non-POSIX compliant shells or shells from other operating systems such as Windows. Executing commands quoted by this module on such shells can open up the possibility of a command injection vulnerability.</p> <p>Consider using functions that pass command arguments with lists such as <a class="reference internal" href="subprocess.html#subprocess.run" title="subprocess.run"><code>subprocess.run()</code></a> with <code>shell=False</code>.</p> </div> <p>This idiom would be unsafe:</p> <pre data-language="python">&gt;&gt;&gt; filename = 'somefile; rm -rf ~'
&gt;&gt;&gt; command = 'ls -l {}'.format(filename)
&gt;&gt;&gt; print(command)  # executed by a shell: boom!
ls -l somefile; rm -rf ~
</pre> <p><a class="reference internal" href="#shlex.quote" title="shlex.quote"><code>quote()</code></a> lets you plug the security hole:</p> <pre data-language="python">&gt;&gt;&gt; from shlex import quote
&gt;&gt;&gt; command = 'ls -l {}'.format(quote(filename))
&gt;&gt;&gt; print(command)
ls -l 'somefile; rm -rf ~'
&gt;&gt;&gt; remote_command = 'ssh home {}'.format(quote(command))
&gt;&gt;&gt; print(remote_command)
ssh home 'ls -l '"'"'somefile; rm -rf ~'"'"''
</pre> <p>The quoting is compatible with UNIX shells and with <a class="reference internal" href="#shlex.split" title="shlex.split"><code>split()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; from shlex import split
&gt;&gt;&gt; remote_command = split(remote_command)
&gt;&gt;&gt; remote_command
['ssh', 'home', "ls -l 'somefile; rm -rf ~'"]
&gt;&gt;&gt; command = split(remote_command[-1])
&gt;&gt;&gt; command
['ls', '-l', 'somefile; rm -rf ~']
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <p>The <a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code>shlex</code></a> module defines the following class:</p> <dl class="py class"> <dt class="sig sig-object py" id="shlex.shlex">
<code>class shlex.shlex(instream=None, infile=None, posix=False, punctuation_chars=False)</code> </dt> <dd>
<p>A <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance or subclass instance is a lexical analyzer object. The initialization argument, if present, specifies where to read characters from. It must be a file-/stream-like object with <a class="reference internal" href="io.html#io.TextIOBase.read" title="io.TextIOBase.read"><code>read()</code></a> and <a class="reference internal" href="io.html#io.TextIOBase.readline" title="io.TextIOBase.readline"><code>readline()</code></a> methods, or a string. If no argument is given, input will be taken from <code>sys.stdin</code>. The second optional argument is a filename string, which sets the initial value of the <a class="reference internal" href="#shlex.shlex.infile" title="shlex.shlex.infile"><code>infile</code></a> attribute. If the <em>instream</em> argument is omitted or equal to <code>sys.stdin</code>, this second argument defaults to “stdin”. The <em>posix</em> argument defines the operational mode: when <em>posix</em> is not true (default), the <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance will operate in compatibility mode. When operating in POSIX mode, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> will try to be as close as possible to the POSIX shell parsing rules. The <em>punctuation_chars</em> argument provides a way to make the behaviour even closer to how real shells parse. This can take a number of values: the default value, <code>False</code>, preserves the behaviour seen under Python 3.5 and earlier. If set to <code>True</code>, then parsing of the characters <code>();&lt;&gt;|&amp;</code> is changed: any run of these characters (considered punctuation characters) is returned as a single token. If set to a non-empty string of characters, those characters will be used as the punctuation characters. Any characters in the <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code>wordchars</code></a> attribute that appear in <em>punctuation_chars</em> will be removed from <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code>wordchars</code></a>. See <a class="reference internal" href="#improved-shell-compatibility"><span class="std std-ref">Improved Compatibility with Shells</span></a> for more information. <em>punctuation_chars</em> can be set only upon <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance creation and can’t be modified later.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>The <em>punctuation_chars</em> parameter was added.</p> </div> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="configparser.html#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a>
</dt>
<dd>
<p>Parser for configuration files similar to the Windows <code>.ini</code> files.</p> </dd> </dl> </div> <section id="shlex-objects"> <span id="id1"></span><h2>shlex Objects</h2> <p>A <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance has the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="shlex.shlex.get_token">
<code>shlex.get_token()</code> </dt> <dd>
<p>Return a token. If tokens have been stacked using <a class="reference internal" href="#shlex.shlex.push_token" title="shlex.shlex.push_token"><code>push_token()</code></a>, pop a token off the stack. Otherwise, read one from the input stream. If reading encounters an immediate end-of-file, <a class="reference internal" href="#shlex.shlex.eof" title="shlex.shlex.eof"><code>eof</code></a> is returned (the empty string (<code>''</code>) in non-POSIX mode, and <code>None</code> in POSIX mode).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="shlex.shlex.push_token">
<code>shlex.push_token(str)</code> </dt> <dd>
<p>Push the argument onto the token stack.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="shlex.shlex.read_token">
<code>shlex.read_token()</code> </dt> <dd>
<p>Read a raw token. Ignore the pushback stack, and do not interpret source requests. (This is not ordinarily a useful entry point, and is documented here only for the sake of completeness.)</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="shlex.shlex.sourcehook">
<code>shlex.sourcehook(filename)</code> </dt> <dd>
<p>When <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> detects a source request (see <a class="reference internal" href="#shlex.shlex.source" title="shlex.shlex.source"><code>source</code></a> below) this method is given the following token as argument, and expected to return a tuple consisting of a filename and an open file-like object.</p> <p>Normally, this method first strips any quotes off the argument. If the result is an absolute pathname, or there was no previous source request in effect, or the previous source was a stream (such as <code>sys.stdin</code>), the result is left alone. Otherwise, if the result is a relative pathname, the directory part of the name of the file immediately before it on the source inclusion stack is prepended (this behavior is like the way the C preprocessor handles <code>#include
"file.h"</code>).</p> <p>The result of the manipulations is treated as a filename, and returned as the first component of the tuple, with <a class="reference internal" href="functions.html#open" title="open"><code>open()</code></a> called on it to yield the second component. (Note: this is the reverse of the order of arguments in instance initialization!)</p> <p>This hook is exposed so that you can use it to implement directory search paths, addition of file extensions, and other namespace hacks. There is no corresponding ‘close’ hook, but a shlex instance will call the <a class="reference internal" href="io.html#io.IOBase.close" title="io.IOBase.close"><code>close()</code></a> method of the sourced input stream when it returns EOF.</p> <p>For more explicit control of source stacking, use the <a class="reference internal" href="#shlex.shlex.push_source" title="shlex.shlex.push_source"><code>push_source()</code></a> and <a class="reference internal" href="#shlex.shlex.pop_source" title="shlex.shlex.pop_source"><code>pop_source()</code></a> methods.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="shlex.shlex.push_source">
<code>shlex.push_source(newstream, newfile=None)</code> </dt> <dd>
<p>Push an input source stream onto the input stack. If the filename argument is specified it will later be available for use in error messages. This is the same method used internally by the <a class="reference internal" href="#shlex.shlex.sourcehook" title="shlex.shlex.sourcehook"><code>sourcehook()</code></a> method.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="shlex.shlex.pop_source">
<code>shlex.pop_source()</code> </dt> <dd>
<p>Pop the last-pushed input source from the input stack. This is the same method used internally when the lexer reaches EOF on a stacked input stream.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="shlex.shlex.error_leader">
<code>shlex.error_leader(infile=None, lineno=None)</code> </dt> <dd>
<p>This method generates an error message leader in the format of a Unix C compiler error label; the format is <code>'"%s", line %d: '</code>, where the <code>%s</code> is replaced with the name of the current source file and the <code>%d</code> with the current input line number (the optional arguments can be used to override these).</p> <p>This convenience is provided to encourage <a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code>shlex</code></a> users to generate error messages in the standard, parseable format understood by Emacs and other Unix tools.</p> </dd>
</dl> <p>Instances of <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> subclasses have some public instance variables which either control lexical analysis or can be used for debugging:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.commenters">
<code>shlex.commenters</code> </dt> <dd>
<p>The string of characters that are recognized as comment beginners. All characters from the comment beginner to end of line are ignored. Includes just <code>'#'</code> by default.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.wordchars">
<code>shlex.wordchars</code> </dt> <dd>
<p>The string of characters that will accumulate into multi-character tokens. By default, includes all ASCII alphanumerics and underscore. In POSIX mode, the accented characters in the Latin-1 set are also included. If <a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code>punctuation_chars</code></a> is not empty, the characters <code>~-./*?=</code>, which can appear in filename specifications and command line parameters, will also be included in this attribute, and any characters which appear in <code>punctuation_chars</code> will be removed from <code>wordchars</code> if they are present there. If <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code>whitespace_split</code></a> is set to <code>True</code>, this will have no effect.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.whitespace">
<code>shlex.whitespace</code> </dt> <dd>
<p>Characters that will be considered whitespace and skipped. Whitespace bounds tokens. By default, includes space, tab, linefeed and carriage-return.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.escape">
<code>shlex.escape</code> </dt> <dd>
<p>Characters that will be considered as escape. This will be only used in POSIX mode, and includes just <code>'\'</code> by default.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.quotes">
<code>shlex.quotes</code> </dt> <dd>
<p>Characters that will be considered string quotes. The token accumulates until the same quote is encountered again (thus, different quote types protect each other as in the shell.) By default, includes ASCII single and double quotes.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.escapedquotes">
<code>shlex.escapedquotes</code> </dt> <dd>
<p>Characters in <a class="reference internal" href="#shlex.shlex.quotes" title="shlex.shlex.quotes"><code>quotes</code></a> that will interpret escape characters defined in <a class="reference internal" href="#shlex.shlex.escape" title="shlex.shlex.escape"><code>escape</code></a>. This is only used in POSIX mode, and includes just <code>'"'</code> by default.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.whitespace_split">
<code>shlex.whitespace_split</code> </dt> <dd>
<p>If <code>True</code>, tokens will only be split in whitespaces. This is useful, for example, for parsing command lines with <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a>, getting tokens in a similar way to shell arguments. When used in combination with <a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code>punctuation_chars</code></a>, tokens will be split on whitespace in addition to those characters.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>The <a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code>punctuation_chars</code></a> attribute was made compatible with the <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code>whitespace_split</code></a> attribute.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.infile">
<code>shlex.infile</code> </dt> <dd>
<p>The name of the current input file, as initially set at class instantiation time or stacked by later source requests. It may be useful to examine this when constructing error messages.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.instream">
<code>shlex.instream</code> </dt> <dd>
<p>The input stream from which this <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance is reading characters.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.source">
<code>shlex.source</code> </dt> <dd>
<p>This attribute is <code>None</code> by default. If you assign a string to it, that string will be recognized as a lexical-level inclusion request similar to the <code>source</code> keyword in various shells. That is, the immediately following token will be opened as a filename and input will be taken from that stream until EOF, at which point the <a class="reference internal" href="io.html#io.IOBase.close" title="io.IOBase.close"><code>close()</code></a> method of that stream will be called and the input source will again become the original input stream. Source requests may be stacked any number of levels deep.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.debug">
<code>shlex.debug</code> </dt> <dd>
<p>If this attribute is numeric and <code>1</code> or more, a <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance will print verbose progress output on its behavior. If you need to use this, you can read the module source code to learn the details.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.lineno">
<code>shlex.lineno</code> </dt> <dd>
<p>Source line number (count of newlines seen so far plus one).</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.token">
<code>shlex.token</code> </dt> <dd>
<p>The token buffer. It may be useful to examine this when catching exceptions.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.eof">
<code>shlex.eof</code> </dt> <dd>
<p>Token used to determine end of file. This will be set to the empty string (<code>''</code>), in non-POSIX mode, and to <code>None</code> in POSIX mode.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="shlex.shlex.punctuation_chars">
<code>shlex.punctuation_chars</code> </dt> <dd>
<p>A read-only property. Characters that will be considered punctuation. Runs of punctuation characters will be returned as a single token. However, note that no semantic validity checking will be performed: for example, ‘&gt;&gt;&gt;’ could be returned as a token, even though it may not be recognised as such by shells.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> </dd>
</dl> </section> <section id="parsing-rules"> <span id="shlex-parsing-rules"></span><h2>Parsing Rules</h2> <p>When operating in non-POSIX mode, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> will try to obey to the following rules.</p> <ul class="simple"> <li>Quote characters are not recognized within words (<code>Do"Not"Separate</code> is parsed as the single word <code>Do"Not"Separate</code>);</li> <li>Escape characters are not recognized;</li> <li>Enclosing characters in quotes preserve the literal value of all characters within the quotes;</li> <li>Closing quotes separate words (<code>"Do"Separate</code> is parsed as <code>"Do"</code> and <code>Separate</code>);</li> <li>If <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code>whitespace_split</code></a> is <code>False</code>, any character not declared to be a word character, whitespace, or a quote will be returned as a single-character token. If it is <code>True</code>, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> will only split words in whitespaces;</li> <li>EOF is signaled with an empty string (<code>''</code>);</li> <li>It’s not possible to parse empty strings, even if quoted.</li> </ul> <p>When operating in POSIX mode, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> will try to obey to the following parsing rules.</p> <ul class="simple"> <li>Quotes are stripped out, and do not separate words (<code>"Do"Not"Separate"</code> is parsed as the single word <code>DoNotSeparate</code>);</li> <li>Non-quoted escape characters (e.g. <code>'\'</code>) preserve the literal value of the next character that follows;</li> <li>Enclosing characters in quotes which are not part of <a class="reference internal" href="#shlex.shlex.escapedquotes" title="shlex.shlex.escapedquotes"><code>escapedquotes</code></a> (e.g. <code>"'"</code>) preserve the literal value of all characters within the quotes;</li> <li>Enclosing characters in quotes which are part of <a class="reference internal" href="#shlex.shlex.escapedquotes" title="shlex.shlex.escapedquotes"><code>escapedquotes</code></a> (e.g. <code>'"'</code>) preserves the literal value of all characters within the quotes, with the exception of the characters mentioned in <a class="reference internal" href="#shlex.shlex.escape" title="shlex.shlex.escape"><code>escape</code></a>. The escape characters retain its special meaning only when followed by the quote in use, or the escape character itself. Otherwise the escape character will be considered a normal character.</li> <li>EOF is signaled with a <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a> value;</li> <li>Quoted empty strings (<code>''</code>) are allowed.</li> </ul> </section> <section id="improved-compatibility-with-shells"> <span id="improved-shell-compatibility"></span><h2>Improved Compatibility with Shells</h2> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> <p>The <a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code>shlex</code></a> class provides compatibility with the parsing performed by common Unix shells like <code>bash</code>, <code>dash</code>, and <code>sh</code>. To take advantage of this compatibility, specify the <code>punctuation_chars</code> argument in the constructor. This defaults to <code>False</code>, which preserves pre-3.6 behaviour. However, if it is set to <code>True</code>, then parsing of the characters <code>();&lt;&gt;|&amp;</code> is changed: any run of these characters is returned as a single token. While this is short of a full parser for shells (which would be out of scope for the standard library, given the multiplicity of shells out there), it does allow you to perform processing of command lines more easily than you could otherwise. To illustrate, you can see the difference in the following snippet:</p> <pre data-language="pycon">&gt;&gt;&gt; import shlex
&gt;&gt;&gt; text = "a &amp;&amp; b; c &amp;&amp; d || e; f &gt;'abc'; (def \"ghi\")"
&gt;&gt;&gt; s = shlex.shlex(text, posix=True)
&gt;&gt;&gt; s.whitespace_split = True
&gt;&gt;&gt; list(s)
['a', '&amp;&amp;', 'b;', 'c', '&amp;&amp;', 'd', '||', 'e;', 'f', '&gt;abc;', '(def', 'ghi)']
&gt;&gt;&gt; s = shlex.shlex(text, posix=True, punctuation_chars=True)
&gt;&gt;&gt; s.whitespace_split = True
&gt;&gt;&gt; list(s)
['a', '&amp;&amp;', 'b', ';', 'c', '&amp;&amp;', 'd', '||', 'e', ';', 'f', '&gt;', 'abc', ';',
'(', 'def', 'ghi', ')']
</pre> <p>Of course, tokens will be returned which are not valid for shells, and you’ll need to implement your own error checks on the returned tokens.</p> <p>Instead of passing <code>True</code> as the value for the punctuation_chars parameter, you can pass a string with specific characters, which will be used to determine which characters constitute punctuation. For example:</p> <pre data-language="python">&gt;&gt;&gt; import shlex
&gt;&gt;&gt; s = shlex.shlex("a &amp;&amp; b || c", punctuation_chars="|")
&gt;&gt;&gt; list(s)
['a', '&amp;', '&amp;', 'b', '||', 'c']
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When <code>punctuation_chars</code> is specified, the <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code>wordchars</code></a> attribute is augmented with the characters <code>~-./*?=</code>. That is because these characters can appear in file names (including wildcards) and command-line arguments (e.g. <code>--color=auto</code>). Hence:</p> <pre data-language="python">&gt;&gt;&gt; import shlex
&gt;&gt;&gt; s = shlex.shlex('~/a &amp;&amp; b-c --color=auto || d *.py?',
...                 punctuation_chars=True)
&gt;&gt;&gt; list(s)
['~/a', '&amp;&amp;', 'b-c', '--color=auto', '||', 'd', '*.py?']
</pre> <p>However, to match the shell as closely as possible, it is recommended to always use <code>posix</code> and <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code>whitespace_split</code></a> when using <a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code>punctuation_chars</code></a>, which will negate <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code>wordchars</code></a> entirely.</p> </div> <p>For best effect, <code>punctuation_chars</code> should be set in conjunction with <code>posix=True</code>. (Note that <code>posix=False</code> is the default for <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a>.)</p> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/shlex.html" class="_attribution-link">https://docs.python.org/3.13/library/shlex.html</a>
  </p>
</div>
