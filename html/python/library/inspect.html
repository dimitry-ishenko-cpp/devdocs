 <h1>inspect — Inspect live objects</h1> <p id="module-inspect"><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/inspect.py">Lib/inspect.py</a></p>  <p>The <a class="reference internal" href="#module-inspect" title="inspect: Extract information and source code from live objects."><code>inspect</code></a> module provides several useful functions to help get information about live objects such as modules, classes, methods, functions, tracebacks, frame objects, and code objects. For example, it can help you examine the contents of a class, retrieve the source code of a method, extract and format the argument list for a function, or get all the information you need to display a detailed traceback.</p> <p>There are four main kinds of services provided by this module: type checking, getting source code, inspecting classes and functions, and examining the interpreter stack.</p> <section id="types-and-members"> <span id="inspect-types"></span><h2>Types and members</h2> <p>The <a class="reference internal" href="#inspect.getmembers" title="inspect.getmembers"><code>getmembers()</code></a> function retrieves the members of an object such as a class or module. The functions whose names begin with “is” are mainly provided as convenient choices for the second argument to <a class="reference internal" href="#inspect.getmembers" title="inspect.getmembers"><code>getmembers()</code></a>. They also help you determine when you can expect to find the following special attributes (see <a class="reference internal" href="../reference/datamodel.html#import-mod-attrs"><span class="std std-ref">Import-related attributes on module objects</span></a> for module attributes):</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Type</p></th> <th class="head"><p>Attribute</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>class</p></td> <td><p>__doc__</p></td> <td><p>documentation string</p></td> </tr> <tr>
<td></td> <td><p>__name__</p></td> <td><p>name with which this class was defined</p></td> </tr> <tr>
<td></td> <td><p>__qualname__</p></td> <td><p>qualified name</p></td> </tr> <tr>
<td></td> <td><p>__module__</p></td> <td><p>name of module in which this class was defined</p></td> </tr> <tr>
<td></td> <td><p>__type_params__</p></td> <td><p>A tuple containing the <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameters</span></a> of a generic class</p></td> </tr> <tr>
<td><p>method</p></td> <td><p>__doc__</p></td> <td><p>documentation string</p></td> </tr> <tr>
<td></td> <td><p>__name__</p></td> <td><p>name with which this method was defined</p></td> </tr> <tr>
<td></td> <td><p>__qualname__</p></td> <td><p>qualified name</p></td> </tr> <tr>
<td></td> <td><p>__func__</p></td> <td><p>function object containing implementation of method</p></td> </tr> <tr>
<td></td> <td><p>__self__</p></td> <td><p>instance to which this method is bound, or <code>None</code></p></td> </tr> <tr>
<td></td> <td><p>__module__</p></td> <td><p>name of module in which this method was defined</p></td> </tr> <tr>
<td><p>function</p></td> <td><p>__doc__</p></td> <td><p>documentation string</p></td> </tr> <tr>
<td></td> <td><p>__name__</p></td> <td><p>name with which this function was defined</p></td> </tr> <tr>
<td></td> <td><p>__qualname__</p></td> <td><p>qualified name</p></td> </tr> <tr>
<td></td> <td><p>__code__</p></td> <td><p>code object containing compiled function <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a></p></td> </tr> <tr>
<td></td> <td><p>__defaults__</p></td> <td><p>tuple of any default values for positional or keyword parameters</p></td> </tr> <tr>
<td></td> <td><p>__kwdefaults__</p></td> <td><p>mapping of any default values for keyword-only parameters</p></td> </tr> <tr>
<td></td> <td><p>__globals__</p></td> <td><p>global namespace in which this function was defined</p></td> </tr> <tr>
<td></td> <td><p>__builtins__</p></td> <td><p>builtins namespace</p></td> </tr> <tr>
<td></td> <td><p>__annotations__</p></td> <td><p>mapping of parameters names to annotations; <code>"return"</code> key is reserved for return annotations.</p></td> </tr> <tr>
<td></td> <td><p>__type_params__</p></td> <td><p>A tuple containing the <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameters</span></a> of a generic function</p></td> </tr> <tr>
<td></td> <td><p>__module__</p></td> <td><p>name of module in which this function was defined</p></td> </tr> <tr>
<td><p>traceback</p></td> <td><p>tb_frame</p></td> <td><p>frame object at this level</p></td> </tr> <tr>
<td></td> <td><p>tb_lasti</p></td> <td><p>index of last attempted instruction in bytecode</p></td> </tr> <tr>
<td></td> <td><p>tb_lineno</p></td> <td><p>current line number in Python source code</p></td> </tr> <tr>
<td></td> <td><p>tb_next</p></td> <td><p>next inner traceback object (called by this level)</p></td> </tr> <tr>
<td><p>frame</p></td> <td><p>f_back</p></td> <td><p>next outer frame object (this frame’s caller)</p></td> </tr> <tr>
<td></td> <td><p>f_builtins</p></td> <td><p>builtins namespace seen by this frame</p></td> </tr> <tr>
<td></td> <td><p>f_code</p></td> <td><p>code object being executed in this frame</p></td> </tr> <tr>
<td></td> <td><p>f_globals</p></td> <td><p>global namespace seen by this frame</p></td> </tr> <tr>
<td></td> <td><p>f_lasti</p></td> <td><p>index of last attempted instruction in bytecode</p></td> </tr> <tr>
<td></td> <td><p>f_lineno</p></td> <td><p>current line number in Python source code</p></td> </tr> <tr>
<td></td> <td><p>f_locals</p></td> <td><p>local namespace seen by this frame</p></td> </tr> <tr>
<td></td> <td><p>f_trace</p></td> <td><p>tracing function for this frame, or <code>None</code></p></td> </tr> <tr>
<td><p>code</p></td> <td><p>co_argcount</p></td> <td><p>number of arguments (not including keyword only arguments, * or ** args)</p></td> </tr> <tr>
<td></td> <td><p>co_code</p></td> <td><p>string of raw compiled bytecode</p></td> </tr> <tr>
<td></td> <td><p>co_cellvars</p></td> <td><p>tuple of names of cell variables (referenced by containing scopes)</p></td> </tr> <tr>
<td></td> <td><p>co_consts</p></td> <td><p>tuple of constants used in the bytecode</p></td> </tr> <tr>
<td></td> <td><p>co_filename</p></td> <td><p>name of file in which this code object was created</p></td> </tr> <tr>
<td></td> <td><p>co_firstlineno</p></td> <td><p>number of first line in Python source code</p></td> </tr> <tr>
<td></td> <td><p>co_flags</p></td> <td><p>bitmap of <code>CO_*</code> flags, read more <a class="reference internal" href="#inspect-module-co-flags"><span class="std std-ref">here</span></a></p></td> </tr> <tr>
<td></td> <td><p>co_lnotab</p></td> <td><p>encoded mapping of line numbers to bytecode indices</p></td> </tr> <tr>
<td></td> <td><p>co_freevars</p></td> <td><p>tuple of names of free variables (referenced via a function’s closure)</p></td> </tr> <tr>
<td></td> <td><p>co_posonlyargcount</p></td> <td><p>number of positional only arguments</p></td> </tr> <tr>
<td></td> <td><p>co_kwonlyargcount</p></td> <td><p>number of keyword only arguments (not including ** arg)</p></td> </tr> <tr>
<td></td> <td><p>co_name</p></td> <td><p>name with which this code object was defined</p></td> </tr> <tr>
<td></td> <td><p>co_qualname</p></td> <td><p>fully qualified name with which this code object was defined</p></td> </tr> <tr>
<td></td> <td><p>co_names</p></td> <td><p>tuple of names other than arguments and function locals</p></td> </tr> <tr>
<td></td> <td><p>co_nlocals</p></td> <td><p>number of local variables</p></td> </tr> <tr>
<td></td> <td><p>co_stacksize</p></td> <td><p>virtual machine stack space required</p></td> </tr> <tr>
<td></td> <td><p>co_varnames</p></td> <td><p>tuple of names of arguments and local variables</p></td> </tr> <tr>
<td><p>generator</p></td> <td><p>__name__</p></td> <td><p>name</p></td> </tr> <tr>
<td></td> <td><p>__qualname__</p></td> <td><p>qualified name</p></td> </tr> <tr>
<td></td> <td><p>gi_frame</p></td> <td><p>frame</p></td> </tr> <tr>
<td></td> <td><p>gi_running</p></td> <td><p>is the generator running?</p></td> </tr> <tr>
<td></td> <td><p>gi_code</p></td> <td><p>code</p></td> </tr> <tr>
<td></td> <td><p>gi_yieldfrom</p></td> <td><p>object being iterated by <code>yield from</code>, or <code>None</code></p></td> </tr> <tr>
<td><p>async generator</p></td> <td><p>__name__</p></td> <td><p>name</p></td> </tr> <tr>
<td></td> <td><p>__qualname__</p></td> <td><p>qualified name</p></td> </tr> <tr>
<td></td> <td><p>ag_await</p></td> <td><p>object being awaited on, or <code>None</code></p></td> </tr> <tr>
<td></td> <td><p>ag_frame</p></td> <td><p>frame</p></td> </tr> <tr>
<td></td> <td><p>ag_running</p></td> <td><p>is the generator running?</p></td> </tr> <tr>
<td></td> <td><p>ag_code</p></td> <td><p>code</p></td> </tr> <tr>
<td><p>coroutine</p></td> <td><p>__name__</p></td> <td><p>name</p></td> </tr> <tr>
<td></td> <td><p>__qualname__</p></td> <td><p>qualified name</p></td> </tr> <tr>
<td></td> <td><p>cr_await</p></td> <td><p>object being awaited on, or <code>None</code></p></td> </tr> <tr>
<td></td> <td><p>cr_frame</p></td> <td><p>frame</p></td> </tr> <tr>
<td></td> <td><p>cr_running</p></td> <td><p>is the coroutine running?</p></td> </tr> <tr>
<td></td> <td><p>cr_code</p></td> <td><p>code</p></td> </tr> <tr>
<td></td> <td><p>cr_origin</p></td> <td><p>where coroutine was created, or <code>None</code>. See <a class="reference internal" href="sys.html#sys.set_coroutine_origin_tracking_depth" title="sys.set_coroutine_origin_tracking_depth"><code>sys.set_coroutine_origin_tracking_depth()</code></a></p></td> </tr> <tr>
<td><p>builtin</p></td> <td><p>__doc__</p></td> <td><p>documentation string</p></td> </tr> <tr>
<td></td> <td><p>__name__</p></td> <td><p>original name of this function or method</p></td> </tr> <tr>
<td></td> <td><p>__qualname__</p></td> <td><p>qualified name</p></td> </tr> <tr>
<td></td> <td><p>__self__</p></td> <td><p>instance to which a method is bound, or <code>None</code></p></td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Add <code>__qualname__</code> and <code>gi_yieldfrom</code> attributes to generators.</p> <p>The <code>__name__</code> attribute of generators is now set from the function name, instead of the code name, and it can now be modified.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Add <code>cr_origin</code> attribute to coroutines.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>Add <code>__builtins__</code> attribute to functions.</p> </div> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getmembers">
<code>inspect.getmembers(object[, predicate])</code> </dt> <dd>
<p>Return all the members of an object in a list of <code>(name, value)</code> pairs sorted by name. If the optional <em>predicate</em> argument—which will be called with the <code>value</code> object of each member—is supplied, only members for which the predicate returns a true value are included.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#inspect.getmembers" title="inspect.getmembers"><code>getmembers()</code></a> will only return class attributes defined in the metaclass when the argument is a class and those attributes have been listed in the metaclass’ custom <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code>__dir__()</code></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getmembers_static">
<code>inspect.getmembers_static(object[, predicate])</code> </dt> <dd>
<p>Return all the members of an object in a list of <code>(name, value)</code> pairs sorted by name without triggering dynamic lookup via the descriptor protocol, __getattr__ or __getattribute__. Optionally, only return members that satisfy a given predicate.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#inspect.getmembers_static" title="inspect.getmembers_static"><code>getmembers_static()</code></a> may not be able to retrieve all members that getmembers can fetch (like dynamically created attributes) and may find members that getmembers can’t (like descriptors that raise AttributeError). It can also return descriptor objects instead of instance members in some cases.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.11.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getmodulename">
<code>inspect.getmodulename(path)</code> </dt> <dd>
<p>Return the name of the module named by the file <em>path</em>, without including the names of enclosing packages. The file extension is checked against all of the entries in <a class="reference internal" href="importlib.html#importlib.machinery.all_suffixes" title="importlib.machinery.all_suffixes"><code>importlib.machinery.all_suffixes()</code></a>. If it matches, the final path component is returned with the extension removed. Otherwise, <code>None</code> is returned.</p> <p>Note that this function <em>only</em> returns a meaningful name for actual Python modules - paths that potentially refer to Python packages will still return <code>None</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>The function is based directly on <a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.ismodule">
<code>inspect.ismodule(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a module.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isclass">
<code>inspect.isclass(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a class, whether built-in or created in Python code.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.ismethod">
<code>inspect.ismethod(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a bound method written in Python.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isfunction">
<code>inspect.isfunction(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a Python function, which includes functions created by a <a class="reference internal" href="../glossary.html#term-lambda"><span class="xref std std-term">lambda</span></a> expression.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isgeneratorfunction">
<code>inspect.isgeneratorfunction(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a Python generator function.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Functions wrapped in <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a> now return <code>True</code> if the wrapped function is a Python generator function.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Functions wrapped in <a class="reference internal" href="functools.html#functools.partialmethod" title="functools.partialmethod"><code>functools.partialmethod()</code></a> now return <code>True</code> if the wrapped function is a Python generator function.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isgenerator">
<code>inspect.isgenerator(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a generator.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.iscoroutinefunction">
<code>inspect.iscoroutinefunction(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a> (a function defined with an <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code>async def</code></a> syntax), a <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a> wrapping a <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a>, or a sync function marked with <a class="reference internal" href="#inspect.markcoroutinefunction" title="inspect.markcoroutinefunction"><code>markcoroutinefunction()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Functions wrapped in <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a> now return <code>True</code> if the wrapped function is a <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Sync functions marked with <a class="reference internal" href="#inspect.markcoroutinefunction" title="inspect.markcoroutinefunction"><code>markcoroutinefunction()</code></a> now return <code>True</code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Functions wrapped in <a class="reference internal" href="functools.html#functools.partialmethod" title="functools.partialmethod"><code>functools.partialmethod()</code></a> now return <code>True</code> if the wrapped function is a <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.markcoroutinefunction">
<code>inspect.markcoroutinefunction(func)</code> </dt> <dd>
<p>Decorator to mark a callable as a <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a> if it would not otherwise be detected by <a class="reference internal" href="#inspect.iscoroutinefunction" title="inspect.iscoroutinefunction"><code>iscoroutinefunction()</code></a>.</p> <p>This may be of use for sync functions that return a <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>, if the function is passed to an API that requires <a class="reference internal" href="#inspect.iscoroutinefunction" title="inspect.iscoroutinefunction"><code>iscoroutinefunction()</code></a>.</p> <p>When possible, using an <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code>async def</code></a> function is preferred. Also acceptable is calling the function and testing the return with <a class="reference internal" href="#inspect.iscoroutine" title="inspect.iscoroutine"><code>iscoroutine()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.iscoroutine">
<code>inspect.iscoroutine(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> created by an <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code>async def</code></a> function.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isawaitable">
<code>inspect.isawaitable(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object can be used in <a class="reference internal" href="../reference/expressions.html#await"><code>await</code></a> expression.</p> <p>Can also be used to distinguish generator-based coroutines from regular generators:</p> <pre data-language="python">import types

def gen():
    yield
@types.coroutine
def gen_coro():
    yield

assert not isawaitable(gen())
assert isawaitable(gen_coro())
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isasyncgenfunction">
<code>inspect.isasyncgenfunction(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is an <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> function, for example:</p> <pre data-language="pycon">&gt;&gt;&gt; async def agen():
...     yield 1
...
&gt;&gt;&gt; inspect.isasyncgenfunction(agen)
True
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Functions wrapped in <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a> now return <code>True</code> if the wrapped function is an <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> function.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Functions wrapped in <a class="reference internal" href="functools.html#functools.partialmethod" title="functools.partialmethod"><code>functools.partialmethod()</code></a> now return <code>True</code> if the wrapped function is a <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isasyncgen">
<code>inspect.isasyncgen(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is an <a class="reference internal" href="../glossary.html#term-asynchronous-generator-iterator"><span class="xref std std-term">asynchronous generator iterator</span></a> created by an <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> function.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.istraceback">
<code>inspect.istraceback(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a traceback.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isframe">
<code>inspect.isframe(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a frame.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.iscode">
<code>inspect.iscode(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a code.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isbuiltin">
<code>inspect.isbuiltin(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a built-in function or a bound built-in method.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.ismethodwrapper">
<code>inspect.ismethodwrapper(object)</code> </dt> <dd>
<p>Return <code>True</code> if the type of object is a <a class="reference internal" href="types.html#types.MethodWrapperType" title="types.MethodWrapperType"><code>MethodWrapperType</code></a>.</p> <p>These are instances of <a class="reference internal" href="types.html#types.MethodWrapperType" title="types.MethodWrapperType"><code>MethodWrapperType</code></a>, such as <a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code>__str__()</code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code>__eq__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code>__repr__()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.11.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isroutine">
<code>inspect.isroutine(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a user-defined or built-in function or method.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isabstract">
<code>inspect.isabstract(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is an abstract base class.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.ismethoddescriptor">
<code>inspect.ismethoddescriptor(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a method descriptor, but not if <a class="reference internal" href="#inspect.ismethod" title="inspect.ismethod"><code>ismethod()</code></a>, <a class="reference internal" href="#inspect.isclass" title="inspect.isclass"><code>isclass()</code></a>, <a class="reference internal" href="#inspect.isfunction" title="inspect.isfunction"><code>isfunction()</code></a> or <a class="reference internal" href="#inspect.isbuiltin" title="inspect.isbuiltin"><code>isbuiltin()</code></a> are true.</p> <p>This, for example, is true of <code>int.__add__</code>. An object passing this test has a <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><code>__get__()</code></a> method, but not a <a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><code>__set__()</code></a> method or a <a class="reference internal" href="../reference/datamodel.html#object.__delete__" title="object.__delete__"><code>__delete__()</code></a> method. Beyond that, the set of attributes varies. A <a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code>__name__</code></a> attribute is usually sensible, and <a class="reference internal" href="stdtypes.html#definition.__doc__" title="definition.__doc__"><code>__doc__</code></a> often is.</p> <p>Methods implemented via descriptors that also pass one of the other tests return <code>False</code> from the <a class="reference internal" href="#inspect.ismethoddescriptor" title="inspect.ismethoddescriptor"><code>ismethoddescriptor()</code></a> test, simply because the other tests promise more – you can, e.g., count on having the <a class="reference internal" href="../reference/datamodel.html#method.__func__" title="method.__func__"><code>__func__</code></a> attribute (etc) when an object passes <a class="reference internal" href="#inspect.ismethod" title="inspect.ismethod"><code>ismethod()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>This function no longer incorrectly reports objects with <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><code>__get__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__delete__" title="object.__delete__"><code>__delete__()</code></a>, but not <a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><code>__set__()</code></a>, as being method descriptors (such objects are data descriptors, not method descriptors).</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isdatadescriptor">
<code>inspect.isdatadescriptor(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a data descriptor.</p> <p>Data descriptors have a <a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><code>__set__</code></a> or a <a class="reference internal" href="../reference/datamodel.html#object.__delete__" title="object.__delete__"><code>__delete__</code></a> method. Examples are properties (defined in Python), getsets, and members. The latter two are defined in C and there are more specific tests available for those types, which is robust across Python implementations. Typically, data descriptors will also have <a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code>__name__</code></a> and <code>__doc__</code> attributes (properties, getsets, and members have both of these attributes), but this is not guaranteed.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.isgetsetdescriptor">
<code>inspect.isgetsetdescriptor(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a getset descriptor.</p> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> getsets are attributes defined in extension modules via <a class="reference internal" href="../c-api/structures.html#c.PyGetSetDef" title="PyGetSetDef"><code>PyGetSetDef</code></a> structures. For Python implementations without such types, this method will always return <code>False</code>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.ismemberdescriptor">
<code>inspect.ismemberdescriptor(object)</code> </dt> <dd>
<p>Return <code>True</code> if the object is a member descriptor.</p> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> Member descriptors are attributes defined in extension modules via <a class="reference internal" href="../c-api/structures.html#c.PyMemberDef" title="PyMemberDef"><code>PyMemberDef</code></a> structures. For Python implementations without such types, this method will always return <code>False</code>.</p> </div> </dd>
</dl> </section> <section id="retrieving-source-code"> <span id="inspect-source"></span><h2>Retrieving source code</h2> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getdoc">
<code>inspect.getdoc(object)</code> </dt> <dd>
<p>Get the documentation string for an object, cleaned up with <a class="reference internal" href="#inspect.cleandoc" title="inspect.cleandoc"><code>cleandoc()</code></a>. If the documentation string for an object is not provided and the object is a class, a method, a property or a descriptor, retrieve the documentation string from the inheritance hierarchy. Return <code>None</code> if the documentation string is invalid or missing.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Documentation strings are now inherited if not overridden.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getcomments">
<code>inspect.getcomments(object)</code> </dt> <dd>
<p>Return in a single string any lines of comments immediately preceding the object’s source code (for a class, function, or method), or at the top of the Python source file (if the object is a module). If the object’s source code is unavailable, return <code>None</code>. This could happen if the object has been defined in C or the interactive shell.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getfile">
<code>inspect.getfile(object)</code> </dt> <dd>
<p>Return the name of the (text or binary) file in which an object was defined. This will fail with a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> if the object is a built-in module, class, or function.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getmodule">
<code>inspect.getmodule(object)</code> </dt> <dd>
<p>Try to guess which module an object was defined in. Return <code>None</code> if the module cannot be determined.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getsourcefile">
<code>inspect.getsourcefile(object)</code> </dt> <dd>
<p>Return the name of the Python source file in which an object was defined or <code>None</code> if no way can be identified to get the source. This will fail with a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> if the object is a built-in module, class, or function.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getsourcelines">
<code>inspect.getsourcelines(object)</code> </dt> <dd>
<p>Return a list of source lines and starting line number for an object. The argument may be a module, class, method, function, traceback, frame, or code object. The source code is returned as a list of the lines corresponding to the object and the line number indicates where in the original source file the first line of code was found. An <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> is raised if the source code cannot be retrieved. A <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> is raised if the object is a built-in module, class, or function.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> is raised instead of <a class="reference internal" href="exceptions.html#IOError" title="IOError"><code>IOError</code></a>, now an alias of the former.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getsource">
<code>inspect.getsource(object)</code> </dt> <dd>
<p>Return the text of the source code for an object. The argument may be a module, class, method, function, traceback, frame, or code object. The source code is returned as a single string. An <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> is raised if the source code cannot be retrieved. A <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> is raised if the object is a built-in module, class, or function.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> is raised instead of <a class="reference internal" href="exceptions.html#IOError" title="IOError"><code>IOError</code></a>, now an alias of the former.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.cleandoc">
<code>inspect.cleandoc(doc)</code> </dt> <dd>
<p>Clean up indentation from docstrings that are indented to line up with blocks of code.</p> <p>All leading whitespace is removed from the first line. Any leading whitespace that can be uniformly removed from the second line onwards is removed. Empty lines at the beginning and end are subsequently removed. Also, all tabs are expanded to spaces.</p> </dd>
</dl> </section> <section id="introspecting-callables-with-the-signature-object"> <span id="inspect-signature-object"></span><h2>Introspecting callables with the Signature object</h2> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <p>The <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code>Signature</code></a> object represents the call signature of a callable object and its return annotation. To retrieve a <code>Signature</code> object, use the <code>signature()</code> function.</p> <dl class="py function"> <dt class="sig sig-object py" id="inspect.signature">
<code>inspect.signature(callable, *, follow_wrapped=True, globals=None, locals=None, eval_str=False)</code> </dt> <dd>
<p>Return a <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code>Signature</code></a> object for the given <em>callable</em>:</p> <pre data-language="pycon">&gt;&gt;&gt; from inspect import signature
&gt;&gt;&gt; def foo(a, *, b:int, **kwargs):
...     pass

&gt;&gt;&gt; sig = signature(foo)

&gt;&gt;&gt; str(sig)
'(a, *, b: int, **kwargs)'

&gt;&gt;&gt; str(sig.parameters['b'])
'b: int'

&gt;&gt;&gt; sig.parameters['b'].annotation
&lt;class 'int'&gt;
</pre> <p>Accepts a wide range of Python callables, from plain functions and classes to <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a> objects.</p> <p>For objects defined in modules using stringized annotations (<code>from __future__ import annotations</code>), <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code>signature()</code></a> will attempt to automatically un-stringize the annotations using <a class="reference internal" href="#inspect.get_annotations" title="inspect.get_annotations"><code>get_annotations()</code></a>. The <em>globals</em>, <em>locals</em>, and <em>eval_str</em> parameters are passed into <a class="reference internal" href="#inspect.get_annotations" title="inspect.get_annotations"><code>get_annotations()</code></a> when resolving the annotations; see the documentation for <a class="reference internal" href="#inspect.get_annotations" title="inspect.get_annotations"><code>get_annotations()</code></a> for instructions on how to use these parameters.</p> <p>Raises <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if no signature can be provided, and <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> if that type of object is not supported. Also, if the annotations are stringized, and <em>eval_str</em> is not false, the <code>eval()</code> call(s) to un-stringize the annotations in <a class="reference internal" href="#inspect.get_annotations" title="inspect.get_annotations"><code>get_annotations()</code></a> could potentially raise any kind of exception.</p> <p>A slash(/) in the signature of a function denotes that the parameters prior to it are positional-only. For more info, see <a class="reference internal" href="../faq/programming.html#faq-positional-only-arguments"><span class="std std-ref">the FAQ entry on positional-only parameters</span></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The <em>follow_wrapped</em> parameter was added. Pass <code>False</code> to get a signature of <em>callable</em> specifically (<code>callable.__wrapped__</code> will not be used to unwrap decorated callables.)</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <em>globals</em>, <em>locals</em>, and <em>eval_str</em> parameters were added.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Some callables may not be introspectable in certain implementations of Python. For example, in CPython, some built-in functions defined in C provide no metadata about their arguments.</p> </div> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> If the passed object has a <code>__signature__</code> attribute, we may use it to create the signature. The exact semantics are an implementation detail and are subject to unannounced changes. Consult the source code for current semantics.</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="inspect.Signature">
<code>class inspect.Signature(parameters=None, *, return_annotation=Signature.empty)</code> </dt> <dd>
<p>A <code>Signature</code> object represents the call signature of a function and its return annotation. For each parameter accepted by the function it stores a <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code>Parameter</code></a> object in its <a class="reference internal" href="#inspect.Signature.parameters" title="inspect.Signature.parameters"><code>parameters</code></a> collection.</p> <p>The optional <em>parameters</em> argument is a sequence of <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code>Parameter</code></a> objects, which is validated to check that there are no parameters with duplicate names, and that the parameters are in the right order, i.e. positional-only first, then positional-or-keyword, and that parameters with defaults follow parameters without defaults.</p> <p>The optional <em>return_annotation</em> argument can be an arbitrary Python object. It represents the “return” annotation of the callable.</p> <p><code>Signature</code> objects are <em>immutable</em>. Use <a class="reference internal" href="#inspect.Signature.replace" title="inspect.Signature.replace"><code>Signature.replace()</code></a> or <a class="reference internal" href="copy.html#copy.replace" title="copy.replace"><code>copy.replace()</code></a> to make a modified copy.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span><code>Signature</code> objects are now picklable and <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.</p> </div> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Signature.empty">
<code>empty</code> </dt> <dd>
<p>A special class-level marker to specify absence of a return annotation.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Signature.parameters">
<code>parameters</code> </dt> <dd>
<p>An ordered mapping of parameters’ names to the corresponding <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code>Parameter</code></a> objects. Parameters appear in strict definition order, including keyword-only parameters.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Python only explicitly guaranteed that it preserved the declaration order of keyword-only parameters as of version 3.7, although in practice this order had always been preserved in Python 3.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Signature.return_annotation">
<code>return_annotation</code> </dt> <dd>
<p>The “return” annotation for the callable. If the callable has no “return” annotation, this attribute is set to <a class="reference internal" href="#inspect.Signature.empty" title="inspect.Signature.empty"><code>Signature.empty</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="inspect.Signature.bind">
<code>bind(*args, **kwargs)</code> </dt> <dd>
<p>Create a mapping from positional and keyword arguments to parameters. Returns <a class="reference internal" href="#inspect.BoundArguments" title="inspect.BoundArguments"><code>BoundArguments</code></a> if <code>*args</code> and <code>**kwargs</code> match the signature, or raises a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="inspect.Signature.bind_partial">
<code>bind_partial(*args, **kwargs)</code> </dt> <dd>
<p>Works the same way as <a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code>Signature.bind()</code></a>, but allows the omission of some required arguments (mimics <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a> behavior.) Returns <a class="reference internal" href="#inspect.BoundArguments" title="inspect.BoundArguments"><code>BoundArguments</code></a>, or raises a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> if the passed arguments do not match the signature.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="inspect.Signature.replace">
<code>replace(*[, parameters][, return_annotation])</code> </dt> <dd>
<p>Create a new <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code>Signature</code></a> instance based on the instance <a class="reference internal" href="#inspect.Signature.replace" title="inspect.Signature.replace"><code>replace()</code></a> was invoked on. It is possible to pass different <em>parameters</em> and/or <em>return_annotation</em> to override the corresponding properties of the base signature. To remove <code>return_annotation</code> from the copied <code>Signature</code>, pass in <a class="reference internal" href="#inspect.Signature.empty" title="inspect.Signature.empty"><code>Signature.empty</code></a>.</p> <pre data-language="pycon">&gt;&gt;&gt; def test(a, b):
...     pass
...
&gt;&gt;&gt; sig = signature(test)
&gt;&gt;&gt; new_sig = sig.replace(return_annotation="new return anno")
&gt;&gt;&gt; str(new_sig)
"(a, b) -&gt; 'new return anno'"
</pre> <p><a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code>Signature</code></a> objects are also supported by the generic function <a class="reference internal" href="copy.html#copy.replace" title="copy.replace"><code>copy.replace()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="inspect.Signature.format">
<code>format(*, max_width=None)</code> </dt> <dd>
<p>Create a string representation of the <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code>Signature</code></a> object.</p> <p>If <em>max_width</em> is passed, the method will attempt to fit the signature into lines of at most <em>max_width</em> characters. If the signature is longer than <em>max_width</em>, all parameters will be on separate lines.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="inspect.Signature.from_callable">
<code>classmethod from_callable(obj, *, follow_wrapped=True, globals=None, locals=None, eval_str=False)</code> </dt> <dd>
<p>Return a <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code>Signature</code></a> (or its subclass) object for a given callable <em>obj</em>.</p> <p>This method simplifies subclassing of <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code>Signature</code></a>:</p> <pre data-language="python">class MySignature(Signature):
    pass
sig = MySignature.from_callable(sum)
assert isinstance(sig, MySignature)
</pre> <p>Its behavior is otherwise identical to that of <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code>signature()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <em>globals</em>, <em>locals</em>, and <em>eval_str</em> parameters were added.</p> </div> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="inspect.Parameter">
<code>class inspect.Parameter(name, kind, *, default=Parameter.empty, annotation=Parameter.empty)</code> </dt> <dd>
<p><code>Parameter</code> objects are <em>immutable</em>. Instead of modifying a <code>Parameter</code> object, you can use <a class="reference internal" href="#inspect.Parameter.replace" title="inspect.Parameter.replace"><code>Parameter.replace()</code></a> or <a class="reference internal" href="copy.html#copy.replace" title="copy.replace"><code>copy.replace()</code></a> to create a modified copy.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Parameter objects are now picklable and <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.</p> </div> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Parameter.empty">
<code>empty</code> </dt> <dd>
<p>A special class-level marker to specify absence of default values and annotations.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Parameter.name">
<code>name</code> </dt> <dd>
<p>The name of the parameter as a string. The name must be a valid Python identifier.</p> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> CPython generates implicit parameter names of the form <code>.0</code> on the code objects used to implement comprehensions and generator expressions.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>These parameter names are now exposed by this module as names like <code>implicit0</code>.</p> </div> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Parameter.default">
<code>default</code> </dt> <dd>
<p>The default value for the parameter. If the parameter has no default value, this attribute is set to <a class="reference internal" href="#inspect.Parameter.empty" title="inspect.Parameter.empty"><code>Parameter.empty</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Parameter.annotation">
<code>annotation</code> </dt> <dd>
<p>The annotation for the parameter. If the parameter has no annotation, this attribute is set to <a class="reference internal" href="#inspect.Parameter.empty" title="inspect.Parameter.empty"><code>Parameter.empty</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Parameter.kind">
<code>kind</code> </dt> <dd>
<p>Describes how argument values are bound to the parameter. The possible values are accessible via <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code>Parameter</code></a> (like <code>Parameter.KEYWORD_ONLY</code>), and support comparison and ordering, in the following order:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Name</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><em>POSITIONAL_ONLY</em></p></td> <td><p>Value must be supplied as a positional argument. Positional only parameters are those which appear before a <code>/</code> entry (if present) in a Python function definition.</p></td> </tr> <tr>
<td><p><em>POSITIONAL_OR_KEYWORD</em></p></td> <td><p>Value may be supplied as either a keyword or positional argument (this is the standard binding behaviour for functions implemented in Python.)</p></td> </tr> <tr>
<td><p><em>VAR_POSITIONAL</em></p></td> <td><p>A tuple of positional arguments that aren’t bound to any other parameter. This corresponds to a <code>*args</code> parameter in a Python function definition.</p></td> </tr> <tr>
<td><p><em>KEYWORD_ONLY</em></p></td> <td><p>Value must be supplied as a keyword argument. Keyword only parameters are those which appear after a <code>*</code> or <code>*args</code> entry in a Python function definition.</p></td> </tr> <tr>
<td><p><em>VAR_KEYWORD</em></p></td> <td><p>A dict of keyword arguments that aren’t bound to any other parameter. This corresponds to a <code>**kwargs</code> parameter in a Python function definition.</p></td> </tr>  </table> <p>Example: print all keyword-only arguments without default values:</p> <pre data-language="pycon">&gt;&gt;&gt; def foo(a, b, *, c, d=10):
...     pass

&gt;&gt;&gt; sig = signature(foo)
&gt;&gt;&gt; for param in sig.parameters.values():
...     if (param.kind == param.KEYWORD_ONLY and
...                        param.default is param.empty):
...         print('Parameter:', param)
Parameter: c
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Parameter.kind.description">
<code>kind.description</code> </dt> <dd>
<p>Describes an enum value of <a class="reference internal" href="#inspect.Parameter.kind" title="inspect.Parameter.kind"><code>Parameter.kind</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> <p>Example: print all descriptions of arguments:</p> <pre data-language="pycon">&gt;&gt;&gt; def foo(a, b, *, c, d=10):
...     pass

&gt;&gt;&gt; sig = signature(foo)
&gt;&gt;&gt; for param in sig.parameters.values():
...     print(param.kind.description)
positional or keyword
positional or keyword
keyword-only
keyword-only
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="inspect.Parameter.replace">
<code>replace(*[, name][, kind][, default][, annotation])</code> </dt> <dd>
<p>Create a new <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code>Parameter</code></a> instance based on the instance replaced was invoked on. To override a <code>Parameter</code> attribute, pass the corresponding argument. To remove a default value or/and an annotation from a <code>Parameter</code>, pass <a class="reference internal" href="#inspect.Parameter.empty" title="inspect.Parameter.empty"><code>Parameter.empty</code></a>.</p> <pre data-language="pycon">&gt;&gt;&gt; from inspect import Parameter
&gt;&gt;&gt; param = Parameter('foo', Parameter.KEYWORD_ONLY, default=42)
&gt;&gt;&gt; str(param)
'foo=42'

&gt;&gt;&gt; str(param.replace()) # Will create a shallow copy of 'param'
'foo=42'

&gt;&gt;&gt; str(param.replace(default=Parameter.empty, annotation='spam'))
"foo: 'spam'"
</pre> <p><a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code>Parameter</code></a> objects are also supported by the generic function <a class="reference internal" href="copy.html#copy.replace" title="copy.replace"><code>copy.replace()</code></a>.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>In Python 3.3 <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code>Parameter</code></a> objects were allowed to have <code>name</code> set to <code>None</code> if their <code>kind</code> was set to <code>POSITIONAL_ONLY</code>. This is no longer permitted.</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="inspect.BoundArguments">
<code>class inspect.BoundArguments</code> </dt> <dd>
<p>Result of a <a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code>Signature.bind()</code></a> or <a class="reference internal" href="#inspect.Signature.bind_partial" title="inspect.Signature.bind_partial"><code>Signature.bind_partial()</code></a> call. Holds the mapping of arguments to the function’s parameters.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BoundArguments.arguments">
<code>arguments</code> </dt> <dd>
<p>A mutable mapping of parameters’ names to arguments’ values. Contains only explicitly bound arguments. Changes in <a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code>arguments</code></a> will reflect in <a class="reference internal" href="#inspect.BoundArguments.args" title="inspect.BoundArguments.args"><code>args</code></a> and <a class="reference internal" href="#inspect.BoundArguments.kwargs" title="inspect.BoundArguments.kwargs"><code>kwargs</code></a>.</p> <p>Should be used in conjunction with <a class="reference internal" href="#inspect.Signature.parameters" title="inspect.Signature.parameters"><code>Signature.parameters</code></a> for any argument processing purposes.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Arguments for which <a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code>Signature.bind()</code></a> or <a class="reference internal" href="#inspect.Signature.bind_partial" title="inspect.Signature.bind_partial"><code>Signature.bind_partial()</code></a> relied on a default value are skipped. However, if needed, use <a class="reference internal" href="#inspect.BoundArguments.apply_defaults" title="inspect.BoundArguments.apply_defaults"><code>BoundArguments.apply_defaults()</code></a> to add them.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span><a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code>arguments</code></a> is now of type <a class="reference internal" href="stdtypes.html#dict" title="dict"><code>dict</code></a>. Formerly, it was of type <a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code>collections.OrderedDict</code></a>.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BoundArguments.args">
<code>args</code> </dt> <dd>
<p>A tuple of positional arguments values. Dynamically computed from the <a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code>arguments</code></a> attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BoundArguments.kwargs">
<code>kwargs</code> </dt> <dd>
<p>A dict of keyword arguments values. Dynamically computed from the <a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code>arguments</code></a> attribute. Arguments that can be passed positionally are included in <a class="reference internal" href="#inspect.BoundArguments.args" title="inspect.BoundArguments.args"><code>args</code></a> instead.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BoundArguments.signature">
<code>signature</code> </dt> <dd>
<p>A reference to the parent <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code>Signature</code></a> object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="inspect.BoundArguments.apply_defaults">
<code>apply_defaults()</code> </dt> <dd>
<p>Set default values for missing arguments.</p> <p>For variable-positional arguments (<code>*args</code>) the default is an empty tuple.</p> <p>For variable-keyword arguments (<code>**kwargs</code>) the default is an empty dict.</p> <pre data-language="pycon">&gt;&gt;&gt; def foo(a, b='ham', *args): pass
&gt;&gt;&gt; ba = inspect.signature(foo).bind('spam')
&gt;&gt;&gt; ba.apply_defaults()
&gt;&gt;&gt; ba.arguments
{'a': 'spam', 'b': 'ham', 'args': ()}
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <p>The <a class="reference internal" href="#inspect.BoundArguments.args" title="inspect.BoundArguments.args"><code>args</code></a> and <a class="reference internal" href="#inspect.BoundArguments.kwargs" title="inspect.BoundArguments.kwargs"><code>kwargs</code></a> properties can be used to invoke functions:</p> <pre data-language="python">def test(a, *, b):
    ...

sig = signature(test)
ba = sig.bind(10, b=20)
test(*ba.args, **ba.kwargs)
</pre> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a> - Function Signature Object.</dt>
<dd>
<p>The detailed specification, implementation details and examples.</p> </dd> </dl> </div> </section> <section id="classes-and-functions"> <span id="inspect-classes-functions"></span><h2>Classes and functions</h2> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getclasstree">
<code>inspect.getclasstree(classes, unique=False)</code> </dt> <dd>
<p>Arrange the given list of classes into a hierarchy of nested lists. Where a nested list appears, it contains classes derived from the class whose entry immediately precedes the list. Each entry is a 2-tuple containing a class and a tuple of its base classes. If the <em>unique</em> argument is true, exactly one entry appears in the returned structure for each class in the given list. Otherwise, classes using multiple inheritance and their descendants will appear multiple times.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getfullargspec">
<code>inspect.getfullargspec(func)</code> </dt> <dd>
<p>Get the names and default values of a Python function’s parameters. A <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> is returned:</p> <p><code>FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults,
annotations)</code></p> <p><em>args</em> is a list of the positional parameter names. <em>varargs</em> is the name of the <code>*</code> parameter or <code>None</code> if arbitrary positional arguments are not accepted. <em>varkw</em> is the name of the <code>**</code> parameter or <code>None</code> if arbitrary keyword arguments are not accepted. <em>defaults</em> is an <em>n</em>-tuple of default argument values corresponding to the last <em>n</em> positional parameters, or <code>None</code> if there are no such defaults defined. <em>kwonlyargs</em> is a list of keyword-only parameter names in declaration order. <em>kwonlydefaults</em> is a dictionary mapping parameter names from <em>kwonlyargs</em> to the default values used if no argument is supplied. <em>annotations</em> is a dictionary mapping parameter names to annotations. The special key <code>"return"</code> is used to report the function return value annotation (if any).</p> <p>Note that <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code>signature()</code></a> and <a class="reference internal" href="#inspect-signature-object"><span class="std std-ref">Signature Object</span></a> provide the recommended API for callable introspection, and support additional behaviours (like positional-only arguments) that are sometimes encountered in extension module APIs. This function is retained primarily for use in code that needs to maintain compatibility with the Python 2 <code>inspect</code> module API.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>This function is now based on <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code>signature()</code></a>, but still ignores <code>__wrapped__</code> attributes and includes the already bound first parameter in the signature output for bound methods.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>This method was previously documented as deprecated in favour of <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code>signature()</code></a> in Python 3.5, but that decision has been reversed in order to restore a clearly supported standard interface for single-source Python 2/3 code migrating away from the legacy <code>getargspec()</code> API.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Python only explicitly guaranteed that it preserved the declaration order of keyword-only parameters as of version 3.7, although in practice this order had always been preserved in Python 3.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getargvalues">
<code>inspect.getargvalues(frame)</code> </dt> <dd>
<p>Get information about arguments passed into a particular frame. A <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code>ArgInfo(args, varargs, keywords, locals)</code> is returned. <em>args</em> is a list of the argument names. <em>varargs</em> and <em>keywords</em> are the names of the <code>*</code> and <code>**</code> arguments or <code>None</code>. <em>locals</em> is the locals dictionary of the given frame.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function was inadvertently marked as deprecated in Python 3.5.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.formatargvalues">
<code>inspect.formatargvalues(args[, varargs, varkw, locals, formatarg, formatvarargs, formatvarkw, formatvalue])</code> </dt> <dd>
<p>Format a pretty argument spec from the four values returned by <a class="reference internal" href="#inspect.getargvalues" title="inspect.getargvalues"><code>getargvalues()</code></a>. The format* arguments are the corresponding optional formatting functions that are called to turn names and values into strings.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function was inadvertently marked as deprecated in Python 3.5.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getmro">
<code>inspect.getmro(cls)</code> </dt> <dd>
<p>Return a tuple of class cls’s base classes, including cls, in method resolution order. No class appears more than once in this tuple. Note that the method resolution order depends on cls’s type. Unless a very peculiar user-defined metatype is in use, cls will be the first element of the tuple.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getcallargs">
<code>inspect.getcallargs(func, /, *args, **kwds)</code> </dt> <dd>
<p>Bind the <em>args</em> and <em>kwds</em> to the argument names of the Python function or method <em>func</em>, as if it was called with them. For bound methods, bind also the first argument (typically named <code>self</code>) to the associated instance. A dict is returned, mapping the argument names (including the names of the <code>*</code> and <code>**</code> arguments, if any) to their values from <em>args</em> and <em>kwds</em>. In case of invoking <em>func</em> incorrectly, i.e. whenever <code>func(*args, **kwds)</code> would raise an exception because of incompatible signature, an exception of the same type and the same or similar message is raised. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; from inspect import getcallargs
&gt;&gt;&gt; def f(a, b=1, *pos, **named):
...     pass
...
&gt;&gt;&gt; getcallargs(f, 1, 2, 3) == {'a': 1, 'named': {}, 'b': 2, 'pos': (3,)}
True
&gt;&gt;&gt; getcallargs(f, a=2, x=4) == {'a': 2, 'named': {'x': 4}, 'b': 1, 'pos': ()}
True
&gt;&gt;&gt; getcallargs(f)
Traceback (most recent call last):
...
TypeError: f() missing 1 required positional argument: 'a'
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.5: </span>Use <a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code>Signature.bind()</code></a> and <a class="reference internal" href="#inspect.Signature.bind_partial" title="inspect.Signature.bind_partial"><code>Signature.bind_partial()</code></a> instead.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getclosurevars">
<code>inspect.getclosurevars(func)</code> </dt> <dd>
<p>Get the mapping of external name references in a Python function or method <em>func</em> to their current values. A <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code>ClosureVars(nonlocals, globals, builtins, unbound)</code> is returned. <em>nonlocals</em> maps referenced names to lexical closure variables, <em>globals</em> to the function’s module globals and <em>builtins</em> to the builtins visible from the function body. <em>unbound</em> is the set of names referenced in the function that could not be resolved at all given the current module globals and builtins.</p> <p><a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> is raised if <em>func</em> is not a Python function or method.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.unwrap">
<code>inspect.unwrap(func, *, stop=None)</code> </dt> <dd>
<p>Get the object wrapped by <em>func</em>. It follows the chain of <code>__wrapped__</code> attributes returning the last object in the chain.</p> <p><em>stop</em> is an optional callback accepting an object in the wrapper chain as its sole argument that allows the unwrapping to be terminated early if the callback returns a true value. If the callback never returns a true value, the last object in the chain is returned as usual. For example, <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code>signature()</code></a> uses this to stop unwrapping if any object in the chain has a <code>__signature__</code> attribute defined.</p> <p><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised if a cycle is encountered.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.get_annotations">
<code>inspect.get_annotations(obj, *, globals=None, locals=None, eval_str=False)</code> </dt> <dd>
<p>Compute the annotations dict for an object.</p> <p><code>obj</code> may be a callable, class, or module. Passing in an object of any other type raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.</p> <p>Returns a dict. <code>get_annotations()</code> returns a new dict every time it’s called; calling it twice on the same object will return two different but equivalent dicts.</p> <p>This function handles several details for you:</p> <ul class="simple"> <li>If <code>eval_str</code> is true, values of type <code>str</code> will be un-stringized using <a class="reference internal" href="functions.html#eval" title="eval"><code>eval()</code></a>. This is intended for use with stringized annotations (<code>from __future__ import annotations</code>).</li> <li>If <code>obj</code> doesn’t have an annotations dict, returns an empty dict. (Functions and methods always have an annotations dict; classes, modules, and other types of callables may not.)</li> <li>Ignores inherited annotations on classes. If a class doesn’t have its own annotations dict, returns an empty dict.</li> <li>All accesses to object members and dict values are done using <code>getattr()</code> and <code>dict.get()</code> for safety.</li> <li>Always, always, always returns a freshly created dict.</li> </ul> <p><code>eval_str</code> controls whether or not values of type <code>str</code> are replaced with the result of calling <a class="reference internal" href="functions.html#eval" title="eval"><code>eval()</code></a> on those values:</p> <ul class="simple"> <li>If eval_str is true, <a class="reference internal" href="functions.html#eval" title="eval"><code>eval()</code></a> is called on values of type <code>str</code>. (Note that <code>get_annotations</code> doesn’t catch exceptions; if <a class="reference internal" href="functions.html#eval" title="eval"><code>eval()</code></a> raises an exception, it will unwind the stack past the <code>get_annotations</code> call.)</li> <li>If eval_str is false (the default), values of type <code>str</code> are unchanged.</li> </ul> <p><code>globals</code> and <code>locals</code> are passed in to <a class="reference internal" href="functions.html#eval" title="eval"><code>eval()</code></a>; see the documentation for <a class="reference internal" href="functions.html#eval" title="eval"><code>eval()</code></a> for more information. If <code>globals</code> or <code>locals</code> is <code>None</code>, this function may replace that value with a context-specific default, contingent on <code>type(obj)</code>:</p> <ul class="simple"> <li>If <code>obj</code> is a module, <code>globals</code> defaults to <code>obj.__dict__</code>.</li> <li>If <code>obj</code> is a class, <code>globals</code> defaults to <code>sys.modules[obj.__module__].__dict__</code> and <code>locals</code> defaults to the <code>obj</code> class namespace.</li> <li>If <code>obj</code> is a callable, <code>globals</code> defaults to <a class="reference internal" href="../reference/datamodel.html#function.__globals__" title="function.__globals__"><code>obj.__globals__</code></a>, although if <code>obj</code> is a wrapped function (using <a class="reference internal" href="functools.html#functools.update_wrapper" title="functools.update_wrapper"><code>functools.update_wrapper()</code></a>) it is first unwrapped.</li> </ul> <p>Calling <code>get_annotations</code> is best practice for accessing the annotations dict of any object. See <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a> for more information on annotations best practices.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> </section> <section id="the-interpreter-stack"> <span id="inspect-stack"></span><h2>The interpreter stack</h2> <p>Some of the following functions return <a class="reference internal" href="#inspect.FrameInfo" title="inspect.FrameInfo"><code>FrameInfo</code></a> objects. For backwards compatibility these objects allow tuple-like operations on all attributes except <code>positions</code>. This behavior is considered deprecated and may be removed in the future.</p> <dl class="py class"> <dt class="sig sig-object py" id="inspect.FrameInfo">
<code>class inspect.FrameInfo</code> </dt> <dd>
<dl class="py attribute"> <dt class="sig sig-object py" id="inspect.FrameInfo.frame">
<code>frame</code> </dt> <dd>
<p>The <a class="reference internal" href="../reference/datamodel.html#frame-objects"><span class="std std-ref">frame object</span></a> that the record corresponds to.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.FrameInfo.filename">
<code>filename</code> </dt> <dd>
<p>The file name associated with the code being executed by the frame this record corresponds to.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.FrameInfo.lineno">
<code>lineno</code> </dt> <dd>
<p>The line number of the current line associated with the code being executed by the frame this record corresponds to.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.FrameInfo.function">
<code>function</code> </dt> <dd>
<p>The function name that is being executed by the frame this record corresponds to.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.FrameInfo.code_context">
<code>code_context</code> </dt> <dd>
<p>A list of lines of context from the source code that’s being executed by the frame this record corresponds to.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.FrameInfo.index">
<code>index</code> </dt> <dd>
<p>The index of the current line being executed in the <a class="reference internal" href="#inspect.FrameInfo.code_context" title="inspect.FrameInfo.code_context"><code>code_context</code></a> list.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.FrameInfo.positions">
<code>positions</code> </dt> <dd>
<p>A <a class="reference internal" href="dis.html#dis.Positions" title="dis.Positions"><code>dis.Positions</code></a> object containing the start line number, end line number, start column offset, and end column offset associated with the instruction being executed by the frame this record corresponds to.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Return a <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> instead of a <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code>tuple</code></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><code>FrameInfo</code> is now a class instance (that is backwards compatible with the previous <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>).</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="inspect.Traceback">
<code>class inspect.Traceback</code> </dt> <dd>
<dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Traceback.filename">
<code>filename</code> </dt> <dd>
<p>The file name associated with the code being executed by the frame this traceback corresponds to.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Traceback.lineno">
<code>lineno</code> </dt> <dd>
<p>The line number of the current line associated with the code being executed by the frame this traceback corresponds to.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Traceback.function">
<code>function</code> </dt> <dd>
<p>The function name that is being executed by the frame this traceback corresponds to.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Traceback.code_context">
<code>code_context</code> </dt> <dd>
<p>A list of lines of context from the source code that’s being executed by the frame this traceback corresponds to.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Traceback.index">
<code>index</code> </dt> <dd>
<p>The index of the current line being executed in the <a class="reference internal" href="#inspect.Traceback.code_context" title="inspect.Traceback.code_context"><code>code_context</code></a> list.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.Traceback.positions">
<code>positions</code> </dt> <dd>
<p>A <a class="reference internal" href="dis.html#dis.Positions" title="dis.Positions"><code>dis.Positions</code></a> object containing the start line number, end line number, start column offset, and end column offset associated with the instruction being executed by the frame this traceback corresponds to.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><code>Traceback</code> is now a class instance (that is backwards compatible with the previous <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>).</p> </div> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Keeping references to frame objects, as found in the first element of the frame records these functions return, can cause your program to create reference cycles. Once a reference cycle has been created, the lifespan of all objects which can be accessed from the objects which form the cycle can become much longer even if Python’s optional cycle detector is enabled. If such cycles must be created, it is important to ensure they are explicitly broken to avoid the delayed destruction of objects and increased memory consumption which occurs.</p> <p>Though the cycle detector will catch these, destruction of the frames (and local variables) can be made deterministic by removing the cycle in a <a class="reference internal" href="../reference/compound_stmts.html#finally"><code>finally</code></a> clause. This is also important if the cycle detector was disabled when Python was compiled or using <a class="reference internal" href="gc.html#gc.disable" title="gc.disable"><code>gc.disable()</code></a>. For example:</p> <pre data-language="python">def handle_stackframe_without_leak():
    frame = inspect.currentframe()
    try:
        # do something with the frame
    finally:
        del frame
</pre> <p>If you want to keep the frame around (for example to print a traceback later), you can also break reference cycles by using the <a class="reference internal" href="../reference/datamodel.html#frame.clear" title="frame.clear"><code>frame.clear()</code></a> method.</p> </div> <p>The optional <em>context</em> argument supported by most of these functions specifies the number of lines of context to return, which are centered around the current line.</p> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getframeinfo">
<code>inspect.getframeinfo(frame, context=1)</code> </dt> <dd>
<p>Get information about a frame or traceback object. A <a class="reference internal" href="#inspect.Traceback" title="inspect.Traceback"><code>Traceback</code></a> object is returned.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>A <a class="reference internal" href="#inspect.Traceback" title="inspect.Traceback"><code>Traceback</code></a> object is returned instead of a named tuple.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getouterframes">
<code>inspect.getouterframes(frame, context=1)</code> </dt> <dd>
<p>Get a list of <a class="reference internal" href="#inspect.FrameInfo" title="inspect.FrameInfo"><code>FrameInfo</code></a> objects for a frame and all outer frames. These frames represent the calls that lead to the creation of <em>frame</em>. The first entry in the returned list represents <em>frame</em>; the last entry represents the outermost call on <em>frame</em>’s stack.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>A list of <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuples</span></a> <code>FrameInfo(frame, filename, lineno, function, code_context, index)</code> is returned.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>A list of <a class="reference internal" href="#inspect.FrameInfo" title="inspect.FrameInfo"><code>FrameInfo</code></a> objects is returned.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getinnerframes">
<code>inspect.getinnerframes(traceback, context=1)</code> </dt> <dd>
<p>Get a list of <a class="reference internal" href="#inspect.FrameInfo" title="inspect.FrameInfo"><code>FrameInfo</code></a> objects for a traceback’s frame and all inner frames. These frames represent calls made as a consequence of <em>frame</em>. The first entry in the list represents <em>traceback</em>; the last entry represents where the exception was raised.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>A list of <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuples</span></a> <code>FrameInfo(frame, filename, lineno, function, code_context, index)</code> is returned.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>A list of <a class="reference internal" href="#inspect.FrameInfo" title="inspect.FrameInfo"><code>FrameInfo</code></a> objects is returned.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.currentframe">
<code>inspect.currentframe()</code> </dt> <dd>
<p>Return the frame object for the caller’s stack frame.</p> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> This function relies on Python stack frame support in the interpreter, which isn’t guaranteed to exist in all implementations of Python. If running in an implementation without Python stack frame support this function returns <code>None</code>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.stack">
<code>inspect.stack(context=1)</code> </dt> <dd>
<p>Return a list of <a class="reference internal" href="#inspect.FrameInfo" title="inspect.FrameInfo"><code>FrameInfo</code></a> objects for the caller’s stack. The first entry in the returned list represents the caller; the last entry represents the outermost call on the stack.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>A list of <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuples</span></a> <code>FrameInfo(frame, filename, lineno, function, code_context, index)</code> is returned.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>A list of <a class="reference internal" href="#inspect.FrameInfo" title="inspect.FrameInfo"><code>FrameInfo</code></a> objects is returned.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.trace">
<code>inspect.trace(context=1)</code> </dt> <dd>
<p>Return a list of <a class="reference internal" href="#inspect.FrameInfo" title="inspect.FrameInfo"><code>FrameInfo</code></a> objects for the stack between the current frame and the frame in which an exception currently being handled was raised in. The first entry in the list represents the caller; the last entry represents where the exception was raised.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>A list of <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuples</span></a> <code>FrameInfo(frame, filename, lineno, function, code_context, index)</code> is returned.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>A list of <a class="reference internal" href="#inspect.FrameInfo" title="inspect.FrameInfo"><code>FrameInfo</code></a> objects is returned.</p> </div> </dd>
</dl> </section> <section id="fetching-attributes-statically"> <h2>Fetching attributes statically</h2> <p>Both <a class="reference internal" href="functions.html#getattr" title="getattr"><code>getattr()</code></a> and <a class="reference internal" href="functions.html#hasattr" title="hasattr"><code>hasattr()</code></a> can trigger code execution when fetching or checking for the existence of attributes. Descriptors, like properties, will be invoked and <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code>__getattr__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code>__getattribute__()</code></a> may be called.</p> <p>For cases where you want passive introspection, like documentation tools, this can be inconvenient. <a class="reference internal" href="#inspect.getattr_static" title="inspect.getattr_static"><code>getattr_static()</code></a> has the same signature as <a class="reference internal" href="functions.html#getattr" title="getattr"><code>getattr()</code></a> but avoids executing code when it fetches attributes.</p> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getattr_static">
<code>inspect.getattr_static(obj, attr, default=None)</code> </dt> <dd>
<p>Retrieve attributes without triggering dynamic lookup via the descriptor protocol, <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code>__getattr__()</code></a> or <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code>__getattribute__()</code></a>.</p> <p>Note: this function may not be able to retrieve all attributes that getattr can fetch (like dynamically created attributes) and may find attributes that getattr can’t (like descriptors that raise AttributeError). It can also return descriptors objects instead of instance members.</p> <p>If the instance <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> is shadowed by another member (for example a property) then this function will be unable to find instance members.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <p><a class="reference internal" href="#inspect.getattr_static" title="inspect.getattr_static"><code>getattr_static()</code></a> does not resolve descriptors, for example slot descriptors or getset descriptors on objects implemented in C. The descriptor object is returned instead of the underlying attribute.</p> <p>You can handle these with code like the following. Note that for arbitrary getset descriptors invoking these may trigger code execution:</p> <pre data-language="python"># example code for resolving the builtin descriptor types
class _foo:
    __slots__ = ['foo']

slot_descriptor = type(_foo.foo)
getset_descriptor = type(type(open(__file__)).name)
wrapper_descriptor = type(str.__dict__['__add__'])
descriptor_types = (slot_descriptor, getset_descriptor, wrapper_descriptor)

result = getattr_static(some_object, 'foo')
if type(result) in descriptor_types:
    try:
        result = result.__get__()
    except AttributeError:
        # descriptors can raise AttributeError to
        # indicate there is no underlying value
        # in which case the descriptor itself will
        # have to do
        pass
</pre> </section> <section id="current-state-of-generators-coroutines-and-asynchronous-generators"> <h2>Current State of Generators, Coroutines, and Asynchronous Generators</h2> <p>When implementing coroutine schedulers and for other advanced uses of generators, it is useful to determine whether a generator is currently executing, is waiting to start or resume or execution, or has already terminated. <a class="reference internal" href="#inspect.getgeneratorstate" title="inspect.getgeneratorstate"><code>getgeneratorstate()</code></a> allows the current state of a generator to be determined easily.</p> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getgeneratorstate">
<code>inspect.getgeneratorstate(generator)</code> </dt> <dd>
<p>Get current state of a generator-iterator.</p> <p>Possible states are:</p> <ul class="simple"> <li>GEN_CREATED: Waiting to start execution.</li> <li>GEN_RUNNING: Currently being executed by the interpreter.</li> <li>GEN_SUSPENDED: Currently suspended at a yield expression.</li> <li>GEN_CLOSED: Execution has completed.</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getcoroutinestate">
<code>inspect.getcoroutinestate(coroutine)</code> </dt> <dd>
<p>Get current state of a coroutine object. The function is intended to be used with coroutine objects created by <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code>async def</code></a> functions, but will accept any coroutine-like object that has <code>cr_running</code> and <code>cr_frame</code> attributes.</p> <p>Possible states are:</p> <ul class="simple"> <li>CORO_CREATED: Waiting to start execution.</li> <li>CORO_RUNNING: Currently being executed by the interpreter.</li> <li>CORO_SUSPENDED: Currently suspended at an await expression.</li> <li>CORO_CLOSED: Execution has completed.</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getasyncgenstate">
<code>inspect.getasyncgenstate(agen)</code> </dt> <dd>
<p>Get current state of an asynchronous generator object. The function is intended to be used with asynchronous iterator objects created by <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code>async def</code></a> functions which use the <a class="reference internal" href="../reference/simple_stmts.html#yield"><code>yield</code></a> statement, but will accept any asynchronous generator-like object that has <code>ag_running</code> and <code>ag_frame</code> attributes.</p> <p>Possible states are:</p> <ul class="simple"> <li>AGEN_CREATED: Waiting to start execution.</li> <li>AGEN_RUNNING: Currently being executed by the interpreter.</li> <li>AGEN_SUSPENDED: Currently suspended at a yield expression.</li> <li>AGEN_CLOSED: Execution has completed.</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <p>The current internal state of the generator can also be queried. This is mostly useful for testing purposes, to ensure that internal state is being updated as expected:</p> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getgeneratorlocals">
<code>inspect.getgeneratorlocals(generator)</code> </dt> <dd>
<p>Get the mapping of live local variables in <em>generator</em> to their current values. A dictionary is returned that maps from variable names to values. This is the equivalent of calling <a class="reference internal" href="functions.html#locals" title="locals"><code>locals()</code></a> in the body of the generator, and all the same caveats apply.</p> <p>If <em>generator</em> is a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> with no currently associated frame, then an empty dictionary is returned. <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> is raised if <em>generator</em> is not a Python generator object.</p> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> This function relies on the generator exposing a Python stack frame for introspection, which isn’t guaranteed to be the case in all implementations of Python. In such cases, this function will always return an empty dictionary.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getcoroutinelocals">
<code>inspect.getcoroutinelocals(coroutine)</code> </dt> <dd>
<p>This function is analogous to <a class="reference internal" href="#inspect.getgeneratorlocals" title="inspect.getgeneratorlocals"><code>getgeneratorlocals()</code></a>, but works for coroutine objects created by <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code>async def</code></a> functions.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="inspect.getasyncgenlocals">
<code>inspect.getasyncgenlocals(agen)</code> </dt> <dd>
<p>This function is analogous to <a class="reference internal" href="#inspect.getgeneratorlocals" title="inspect.getgeneratorlocals"><code>getgeneratorlocals()</code></a>, but works for asynchronous generator objects created by <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code>async def</code></a> functions which use the <a class="reference internal" href="../reference/simple_stmts.html#yield"><code>yield</code></a> statement.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> </section> <section id="code-objects-bit-flags"> <span id="inspect-module-co-flags"></span><h2>Code Objects Bit Flags</h2> <p>Python code objects have a <a class="reference internal" href="../reference/datamodel.html#codeobject.co_flags" title="codeobject.co_flags"><code>co_flags</code></a> attribute, which is a bitmap of the following flags:</p> <dl class="py data"> <dt class="sig sig-object py" id="inspect.CO_OPTIMIZED">
<code>inspect.CO_OPTIMIZED</code> </dt> <dd>
<p>The code object is optimized, using fast locals.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="inspect.CO_NEWLOCALS">
<code>inspect.CO_NEWLOCALS</code> </dt> <dd>
<p>If set, a new dict will be created for the frame’s <a class="reference internal" href="../reference/datamodel.html#frame.f_locals" title="frame.f_locals"><code>f_locals</code></a> when the code object is executed.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="inspect.CO_VARARGS">
<code>inspect.CO_VARARGS</code> </dt> <dd>
<p>The code object has a variable positional parameter (<code>*args</code>-like).</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="inspect.CO_VARKEYWORDS">
<code>inspect.CO_VARKEYWORDS</code> </dt> <dd>
<p>The code object has a variable keyword parameter (<code>**kwargs</code>-like).</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="inspect.CO_NESTED">
<code>inspect.CO_NESTED</code> </dt> <dd>
<p>The flag is set when the code object is a nested function.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="inspect.CO_GENERATOR">
<code>inspect.CO_GENERATOR</code> </dt> <dd>
<p>The flag is set when the code object is a generator function, i.e. a generator object is returned when the code object is executed.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="inspect.CO_COROUTINE">
<code>inspect.CO_COROUTINE</code> </dt> <dd>
<p>The flag is set when the code object is a coroutine function. When the code object is executed it returns a coroutine object. See <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> for more details.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="inspect.CO_ITERABLE_COROUTINE">
<code>inspect.CO_ITERABLE_COROUTINE</code> </dt> <dd>
<p>The flag is used to transform generators into generator-based coroutines. Generator objects with this flag can be used in <code>await</code> expression, and can <code>yield from</code> coroutine objects. See <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> for more details.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="inspect.CO_ASYNC_GENERATOR">
<code>inspect.CO_ASYNC_GENERATOR</code> </dt> <dd>
<p>The flag is set when the code object is an asynchronous generator function. When the code object is executed it returns an asynchronous generator object. See <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a> for more details.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The flags are specific to CPython, and may not be defined in other Python implementations. Furthermore, the flags are an implementation detail, and can be removed or deprecated in future Python releases. It’s recommended to use public APIs from the <a class="reference internal" href="#module-inspect" title="inspect: Extract information and source code from live objects."><code>inspect</code></a> module for any introspection needs.</p> </div> </section> <section id="buffer-flags"> <h2>Buffer flags</h2> <dl class="py class"> <dt class="sig sig-object py" id="inspect.BufferFlags">
<code>class inspect.BufferFlags</code> </dt> <dd>
<p>This is an <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code>enum.IntFlag</code></a> that represents the flags that can be passed to the <a class="reference internal" href="../reference/datamodel.html#object.__buffer__" title="object.__buffer__"><code>__buffer__()</code></a> method of objects implementing the <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a>.</p> <p>The meaning of the flags is explained at <a class="reference internal" href="../c-api/buffer.html#buffer-request-types"><span class="std std-ref">Buffer request types</span></a>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.SIMPLE">
<code>SIMPLE</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.WRITABLE">
<code>WRITABLE</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.FORMAT">
<code>FORMAT</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.ND">
<code>ND</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.STRIDES">
<code>STRIDES</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.C_CONTIGUOUS">
<code>C_CONTIGUOUS</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.F_CONTIGUOUS">
<code>F_CONTIGUOUS</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.ANY_CONTIGUOUS">
<code>ANY_CONTIGUOUS</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.INDIRECT">
<code>INDIRECT</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.CONTIG">
<code>CONTIG</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.CONTIG_RO">
<code>CONTIG_RO</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.STRIDED">
<code>STRIDED</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.STRIDED_RO">
<code>STRIDED_RO</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.RECORDS">
<code>RECORDS</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.RECORDS_RO">
<code>RECORDS_RO</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.FULL">
<code>FULL</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.FULL_RO">
<code>FULL_RO</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.READ">
<code>READ</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="inspect.BufferFlags.WRITE">
<code>WRITE</code> </dt> <dd></dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> </section> <section id="command-line-interface"> <span id="inspect-module-cli"></span><h2>Command Line Interface</h2> <p>The <a class="reference internal" href="#module-inspect" title="inspect: Extract information and source code from live objects."><code>inspect</code></a> module also provides a basic introspection capability from the command line.</p> <p>By default, accepts the name of a module and prints the source of that module. A class or function within the module can be printed instead by appended a colon and the qualified name of the target object.</p> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-inspect-details">
<code>--details</code> </dt> <dd>
<p>Print information about the specified object rather than the source code</p> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/inspect.html" class="_attribution-link">https://docs.python.org/3.13/library/inspect.html</a>
  </p>
</div>
