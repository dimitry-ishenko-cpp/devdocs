 <span id="hashlib-secure-hashes-and-message-digests"></span><h1>hashlib — Secure hashes and message digests</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/hashlib.py">Lib/hashlib.py</a></p> <span class="target" id="index-0"></span> <p>This module implements a common interface to many different secure hash and message digest algorithms. Included are the FIPS secure hash algorithms SHA1, SHA224, SHA256, SHA384, SHA512, (defined in <a class="reference external" href="https://csrc.nist.gov/publications/detail/fips/180/4/final">the FIPS 180-4 standard</a>), the SHA-3 series (defined in <a class="reference external" href="https://csrc.nist.gov/publications/detail/fips/202/final">the FIPS 202 standard</a>) as well as RSA’s MD5 algorithm (defined in internet <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1321.html"><strong>RFC 1321</strong></a>). The terms “secure hash” and “message digest” are interchangeable. Older algorithms were called message digests. The modern term is secure hash.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you want the adler32 or crc32 hash functions, they are available in the <a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code>zlib</code></a> module.</p> </div> <section id="hash-algorithms"> <span id="id1"></span><h2>Hash algorithms</h2> <p>There is one constructor method named for each type of <em class="dfn">hash</em>. All return a hash object with the same simple interface. For example: use <a class="reference internal" href="#hashlib.sha256" title="hashlib.sha256"><code>sha256()</code></a> to create a SHA-256 hash object. You can now feed this object with <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a> (normally <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>) using the <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code>update</code></a> method. At any point you can ask it for the <em class="dfn">digest</em> of the concatenation of the data fed to it so far using the <a class="reference internal" href="#hashlib.hash.digest" title="hashlib.hash.digest"><code>digest()</code></a> or <a class="reference internal" href="#hashlib.hash.hexdigest" title="hashlib.hash.hexdigest"><code>hexdigest()</code></a> methods.</p> <p>To allow multithreading, the Python <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> is released while computing a hash supplied more than 2047 bytes of data at once in its constructor or <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code>.update</code></a> method.</p> <p id="index-2">Constructors for hash algorithms that are always present in this module are <a class="reference internal" href="#hashlib.sha1" title="hashlib.sha1"><code>sha1()</code></a>, <a class="reference internal" href="#hashlib.sha224" title="hashlib.sha224"><code>sha224()</code></a>, <a class="reference internal" href="#hashlib.sha256" title="hashlib.sha256"><code>sha256()</code></a>, <a class="reference internal" href="#hashlib.sha384" title="hashlib.sha384"><code>sha384()</code></a>, <a class="reference internal" href="#hashlib.sha512" title="hashlib.sha512"><code>sha512()</code></a>, <a class="reference internal" href="#hashlib.sha3_224" title="hashlib.sha3_224"><code>sha3_224()</code></a>, <a class="reference internal" href="#hashlib.sha3_256" title="hashlib.sha3_256"><code>sha3_256()</code></a>, <a class="reference internal" href="#hashlib.sha3_384" title="hashlib.sha3_384"><code>sha3_384()</code></a>, <a class="reference internal" href="#hashlib.sha3_512" title="hashlib.sha3_512"><code>sha3_512()</code></a>, <a class="reference internal" href="#hashlib.shake_128" title="hashlib.shake_128"><code>shake_128()</code></a>, <a class="reference internal" href="#hashlib.shake_256" title="hashlib.shake_256"><code>shake_256()</code></a>, <a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code>blake2b()</code></a>, and <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code>blake2s()</code></a>. <a class="reference internal" href="#hashlib.md5" title="hashlib.md5"><code>md5()</code></a> is normally available as well, though it may be missing or blocked if you are using a rare “FIPS compliant” build of Python. These correspond to <a class="reference internal" href="#hashlib.algorithms_guaranteed" title="hashlib.algorithms_guaranteed"><code>algorithms_guaranteed</code></a>.</p> <p>Additional algorithms may also be available if your Python distribution’s <a class="reference internal" href="#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code>hashlib</code></a> was linked against a build of OpenSSL that provides others. Others <em>are not guaranteed available</em> on all installations and will only be accessible by name via <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code>new()</code></a>. See <a class="reference internal" href="#hashlib.algorithms_available" title="hashlib.algorithms_available"><code>algorithms_available</code></a>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Some algorithms have known hash collision weaknesses (including MD5 and SHA1). Refer to <a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function#Attacks_on_cryptographic_hash_algorithms">Attacks on cryptographic hash algorithms</a> and the <a class="reference internal" href="#hashlib-seealso">hashlib-seealso</a> section at the end of this document.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6: </span>SHA3 (Keccak) and SHAKE constructors <a class="reference internal" href="#hashlib.sha3_224" title="hashlib.sha3_224"><code>sha3_224()</code></a>, <a class="reference internal" href="#hashlib.sha3_256" title="hashlib.sha3_256"><code>sha3_256()</code></a>, <a class="reference internal" href="#hashlib.sha3_384" title="hashlib.sha3_384"><code>sha3_384()</code></a>, <a class="reference internal" href="#hashlib.sha3_512" title="hashlib.sha3_512"><code>sha3_512()</code></a>, <a class="reference internal" href="#hashlib.shake_128" title="hashlib.shake_128"><code>shake_128()</code></a>, <a class="reference internal" href="#hashlib.shake_256" title="hashlib.shake_256"><code>shake_256()</code></a> were added. <a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code>blake2b()</code></a> and <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code>blake2s()</code></a> were added.</p> </div> <div class="versionchanged" id="hashlib-usedforsecurity"> <p><span class="versionmodified changed">Changed in version 3.9: </span>All hashlib constructors take a keyword-only argument <em>usedforsecurity</em> with default value <code>True</code>. A false value allows the use of insecure and blocked hashing algorithms in restricted environments. <code>False</code> indicates that the hashing algorithm is not used in a security context, e.g. as a non-cryptographic one-way compression function.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>Hashlib now uses SHA3 and SHAKE from OpenSSL if it provides it.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>For any of the MD5, SHA1, SHA2, or SHA3 algorithms that the linked OpenSSL does not provide we fall back to a verified implementation from the <a class="reference external" href="https://github.com/hacl-star/hacl-star">HACL* project</a>.</p> </div> </section> <section id="usage"> <h2>Usage</h2> <p>To obtain the digest of the byte string <code>b"Nobody inspects the spammish
repetition"</code>:</p> <pre data-language="python">&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; m = hashlib.sha256()
&gt;&gt;&gt; m.update(b"Nobody inspects")
&gt;&gt;&gt; m.update(b" the spammish repetition")
&gt;&gt;&gt; m.digest()
b'\x03\x1e\xdd}Ae\x15\x93\xc5\xfe\\\x00o\xa5u+7\xfd\xdf\xf7\xbcN\x84:\xa6\xaf\x0c\x95\x0fK\x94\x06'
&gt;&gt;&gt; m.hexdigest()
'031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406'
</pre> <p>More condensed:</p> <pre data-language="python">&gt;&gt;&gt; hashlib.sha256(b"Nobody inspects the spammish repetition").hexdigest()
'031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406'
</pre> </section> <section id="constructors"> <h2>Constructors</h2> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.new">
<code>hashlib.new(name, [data, ]*, usedforsecurity=True)</code> </dt> <dd>
<p>Is a generic constructor that takes the string <em>name</em> of the desired algorithm as its first parameter. It also exists to allow access to the above listed hashes as well as any other algorithms that your OpenSSL library may offer.</p> </dd>
</dl> <p>Using <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code>new()</code></a> with an algorithm name:</p> <pre data-language="python">&gt;&gt;&gt; h = hashlib.new('sha256')
&gt;&gt;&gt; h.update(b"Nobody inspects the spammish repetition")
&gt;&gt;&gt; h.hexdigest()
'031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406'
</pre> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.md5">
<code>hashlib.md5([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.sha1">
<code>hashlib.sha1([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.sha224">
<code>hashlib.sha224([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.sha256">
<code>hashlib.sha256([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.sha384">
<code>hashlib.sha384([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.sha512">
<code>hashlib.sha512([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.sha3_224">
<code>hashlib.sha3_224([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.sha3_256">
<code>hashlib.sha3_256([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.sha3_384">
<code>hashlib.sha3_384([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.sha3_512">
<code>hashlib.sha3_512([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <p>Named constructors such as these are faster than passing an algorithm name to <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code>new()</code></a>.</p> </section> <section id="attributes"> <h2>Attributes</h2> <p>Hashlib provides the following constant module attributes:</p> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.algorithms_guaranteed">
<code>hashlib.algorithms_guaranteed</code> </dt> <dd>
<p>A set containing the names of the hash algorithms guaranteed to be supported by this module on all platforms. Note that ‘md5’ is in this list despite some upstream vendors offering an odd “FIPS compliant” Python build that excludes it.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.algorithms_available">
<code>hashlib.algorithms_available</code> </dt> <dd>
<p>A set containing the names of the hash algorithms that are available in the running Python interpreter. These names will be recognized when passed to <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code>new()</code></a>. <a class="reference internal" href="#hashlib.algorithms_guaranteed" title="hashlib.algorithms_guaranteed"><code>algorithms_guaranteed</code></a> will always be a subset. The same algorithm may appear multiple times in this set under different names (thanks to OpenSSL).</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> </section> <section id="hash-objects"> <h2>Hash Objects</h2> <p>The following values are provided as constant attributes of the hash objects returned by the constructors:</p> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.hash.digest_size">
<code>hash.digest_size</code> </dt> <dd>
<p>The size of the resulting hash in bytes.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.hash.block_size">
<code>hash.block_size</code> </dt> <dd>
<p>The internal block size of the hash algorithm in bytes.</p> </dd>
</dl> <p>A hash object has the following attributes:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="hashlib.hash.name">
<code>hash.name</code> </dt> <dd>
<p>The canonical name of this hash, always lowercase and always suitable as a parameter to <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code>new()</code></a> to create another hash of this type.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The name attribute has been present in CPython since its inception, but until Python 3.4 was not formally specified, so may not exist on some platforms.</p> </div> </dd>
</dl> <p>A hash object has the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="hashlib.hash.update">
<code>hash.update(data)</code> </dt> <dd>
<p>Update the hash object with the <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>. Repeated calls are equivalent to a single call with the concatenation of all the arguments: <code>m.update(a); m.update(b)</code> is equivalent to <code>m.update(a+b)</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="hashlib.hash.digest">
<code>hash.digest()</code> </dt> <dd>
<p>Return the digest of the data passed to the <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code>update()</code></a> method so far. This is a bytes object of size <a class="reference internal" href="#hashlib.hash.digest_size" title="hashlib.hash.digest_size"><code>digest_size</code></a> which may contain bytes in the whole range from 0 to 255.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="hashlib.hash.hexdigest">
<code>hash.hexdigest()</code> </dt> <dd>
<p>Like <a class="reference internal" href="#hashlib.hash.digest" title="hashlib.hash.digest"><code>digest()</code></a> except the digest is returned as a string object of double length, containing only hexadecimal digits. This may be used to exchange the value safely in email or other non-binary environments.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="hashlib.hash.copy">
<code>hash.copy()</code> </dt> <dd>
<p>Return a copy (“clone”) of the hash object. This can be used to efficiently compute the digests of data sharing a common initial substring.</p> </dd>
</dl> </section> <section id="shake-variable-length-digests"> <h2>SHAKE variable length digests</h2> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.shake_128">
<code>hashlib.shake_128([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.shake_256">
<code>hashlib.shake_256([data, ]*, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <p>The <a class="reference internal" href="#hashlib.shake_128" title="hashlib.shake_128"><code>shake_128()</code></a> and <a class="reference internal" href="#hashlib.shake_256" title="hashlib.shake_256"><code>shake_256()</code></a> algorithms provide variable length digests with length_in_bits//2 up to 128 or 256 bits of security. As such, their digest methods require a length. Maximum length is not limited by the SHAKE algorithm.</p> <dl class="py method"> <dt class="sig sig-object py" id="hashlib.shake.digest">
<code>shake.digest(length)</code> </dt> <dd>
<p>Return the digest of the data passed to the <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code>update()</code></a> method so far. This is a bytes object of size <em>length</em> which may contain bytes in the whole range from 0 to 255.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="hashlib.shake.hexdigest">
<code>shake.hexdigest(length)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#hashlib.shake.digest" title="hashlib.shake.digest"><code>digest()</code></a> except the digest is returned as a string object of double length, containing only hexadecimal digits. This may be used to exchange the value in email or other non-binary environments.</p> </dd>
</dl> <p>Example use:</p> <pre data-language="python">&gt;&gt;&gt; h = hashlib.shake_256(b'Nobody inspects the spammish repetition')
&gt;&gt;&gt; h.hexdigest(20)
'44709d6fcb83d92a76dcb0b668c98e1b1d3dafe7'
</pre> </section> <section id="file-hashing"> <h2>File hashing</h2> <p>The hashlib module provides a helper function for efficient hashing of a file or file-like object.</p> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.file_digest">
<code>hashlib.file_digest(fileobj, digest, /)</code> </dt> <dd>
<p>Return a digest object that has been updated with contents of file object.</p> <p><em>fileobj</em> must be a file-like object opened for reading in binary mode. It accepts file objects from builtin <a class="reference internal" href="functions.html#open" title="open"><code>open()</code></a>, <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code>BytesIO</code></a> instances, SocketIO objects from <a class="reference internal" href="socket.html#socket.socket.makefile" title="socket.socket.makefile"><code>socket.socket.makefile()</code></a>, and similar. The function may bypass Python’s I/O and use the file descriptor from <a class="reference internal" href="io.html#io.IOBase.fileno" title="io.IOBase.fileno"><code>fileno()</code></a> directly. <em>fileobj</em> must be assumed to be in an unknown state after this function returns or raises. It is up to the caller to close <em>fileobj</em>.</p> <p><em>digest</em> must either be a hash algorithm name as a <em>str</em>, a hash constructor, or a callable that returns a hash object.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; import io, hashlib, hmac
&gt;&gt;&gt; with open(hashlib.__file__, "rb") as f:
...     digest = hashlib.file_digest(f, "sha256")
...
&gt;&gt;&gt; digest.hexdigest()  
'...'
</pre> <pre data-language="python">&gt;&gt;&gt; buf = io.BytesIO(b"somedata")
&gt;&gt;&gt; mac1 = hmac.HMAC(b"key", digestmod=hashlib.sha512)
&gt;&gt;&gt; digest = hashlib.file_digest(buf, lambda: mac1)
</pre> <pre data-language="python">&gt;&gt;&gt; digest is mac1
True
&gt;&gt;&gt; mac2 = hmac.HMAC(b"key", b"somedata", digestmod=hashlib.sha512)
&gt;&gt;&gt; mac1.digest() == mac2.digest()
True
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.11.</span></p> </div> </dd>
</dl> </section> <section id="key-derivation"> <h2>Key derivation</h2> <p>Key derivation and key stretching algorithms are designed for secure password hashing. Naive algorithms such as <code>sha1(password)</code> are not resistant against brute-force attacks. A good password hashing function must be tunable, slow, and include a <a class="reference external" href="https://en.wikipedia.org/wiki/Salt_%28cryptography%29">salt</a>.</p> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.pbkdf2_hmac">
<code>hashlib.pbkdf2_hmac(hash_name, password, salt, iterations, dklen=None)</code> </dt> <dd>
<p>The function provides PKCS#5 password-based key derivation function 2. It uses HMAC as pseudorandom function.</p> <p>The string <em>hash_name</em> is the desired name of the hash digest algorithm for HMAC, e.g. ‘sha1’ or ‘sha256’. <em>password</em> and <em>salt</em> are interpreted as buffers of bytes. Applications and libraries should limit <em>password</em> to a sensible length (e.g. 1024). <em>salt</em> should be about 16 or more bytes from a proper source, e.g. <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code>os.urandom()</code></a>.</p> <p>The number of <em>iterations</em> should be chosen based on the hash algorithm and computing power. As of 2022, hundreds of thousands of iterations of SHA-256 are suggested. For rationale as to why and how to choose what is best for your application, read <em>Appendix A.2.2</em> of <a class="reference external" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf">NIST-SP-800-132</a>. The answers on the <a class="reference external" href="https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pbkdf2-sha256/">stackexchange pbkdf2 iterations question</a> explain in detail.</p> <p><em>dklen</em> is the length of the derived key in bytes. If <em>dklen</em> is <code>None</code> then the digest size of the hash algorithm <em>hash_name</em> is used, e.g. 64 for SHA-512.</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import pbkdf2_hmac
&gt;&gt;&gt; our_app_iters = 500_000  # Application specific, read above.
&gt;&gt;&gt; dk = pbkdf2_hmac('sha256', b'password', b'bad salt' * 2, our_app_iters)
&gt;&gt;&gt; dk.hex()
'15530bba69924174860db778f2c6f8104d3aaf9d26241840c8c4a641c8d000a9'
</pre> <p>Function only available when Python is compiled with OpenSSL.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Function now only available when Python is built with OpenSSL. The slow pure Python implementation has been removed.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.scrypt">
<code>hashlib.scrypt(password, *, salt, n, r, p, maxmem=0, dklen=64)</code> </dt> <dd>
<p>The function provides scrypt password-based key derivation function as defined in <span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7914.html"><strong>RFC 7914</strong></a>.</p> <p><em>password</em> and <em>salt</em> must be <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>. Applications and libraries should limit <em>password</em> to a sensible length (e.g. 1024). <em>salt</em> should be about 16 or more bytes from a proper source, e.g. <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code>os.urandom()</code></a>.</p> <p><em>n</em> is the CPU/Memory cost factor, <em>r</em> the block size, <em>p</em> parallelization factor and <em>maxmem</em> limits memory (OpenSSL 1.1.0 defaults to 32 MiB). <em>dklen</em> is the length of the derived key in bytes.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> </dd>
</dl> </section> <section id="blake2"> <span id="hashlib-blake2"></span><h2>BLAKE2</h2> <p id="index-4"><a class="reference external" href="https://www.blake2.net">BLAKE2</a> is a cryptographic hash function defined in <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7693.html"><strong>RFC 7693</strong></a> that comes in two flavors:</p> <ul class="simple"> <li>
<strong>BLAKE2b</strong>, optimized for 64-bit platforms and produces digests of any size between 1 and 64 bytes,</li> <li>
<strong>BLAKE2s</strong>, optimized for 8- to 32-bit platforms and produces digests of any size between 1 and 32 bytes.</li> </ul> <p>BLAKE2 supports <strong>keyed mode</strong> (a faster and simpler replacement for <a class="reference external" href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a>), <strong>salted hashing</strong>, <strong>personalization</strong>, and <strong>tree hashing</strong>.</p> <p>Hash objects from this module follow the API of standard library’s <a class="reference internal" href="#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code>hashlib</code></a> objects.</p> <section id="creating-hash-objects"> <h3>Creating hash objects</h3> <p>New hash objects are created by calling constructor functions:</p> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.blake2b">
<code>hashlib.blake2b(data=b'', *, digest_size=64, key=b'', salt=b'', person=b'', fanout=1, depth=1, leaf_size=0, node_offset=0, node_depth=0, inner_size=0, last_node=False, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="hashlib.blake2s">
<code>hashlib.blake2s(data=b'', *, digest_size=32, key=b'', salt=b'', person=b'', fanout=1, depth=1, leaf_size=0, node_offset=0, node_depth=0, inner_size=0, last_node=False, usedforsecurity=True)</code> </dt> <dd></dd>
</dl> <p>These functions return the corresponding hash objects for calculating BLAKE2b or BLAKE2s. They optionally take these general parameters:</p> <ul class="simple"> <li>
<em>data</em>: initial chunk of data to hash, which must be <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>. It can be passed only as positional argument.</li> <li>
<em>digest_size</em>: size of output digest in bytes.</li> <li>
<em>key</em>: key for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes for BLAKE2s).</li> <li>
<em>salt</em>: salt for randomized hashing (up to 16 bytes for BLAKE2b, up to 8 bytes for BLAKE2s).</li> <li>
<em>person</em>: personalization string (up to 16 bytes for BLAKE2b, up to 8 bytes for BLAKE2s).</li> </ul> <p>The following table shows limits for general parameters (in bytes):</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Hash</p></th> <th class="head"><p>digest_size</p></th> <th class="head"><p>len(key)</p></th> <th class="head"><p>len(salt)</p></th> <th class="head"><p>len(person)</p></th> </tr> </thead>  <tr>
<td><p>BLAKE2b</p></td> <td><p>64</p></td> <td><p>64</p></td> <td><p>16</p></td> <td><p>16</p></td> </tr> <tr>
<td><p>BLAKE2s</p></td> <td><p>32</p></td> <td><p>32</p></td> <td><p>8</p></td> <td><p>8</p></td> </tr>  </table> <div class="admonition note"> <p class="admonition-title">Note</p> <p>BLAKE2 specification defines constant lengths for salt and personalization parameters, however, for convenience, this implementation accepts byte strings of any size up to the specified length. If the length of the parameter is less than specified, it is padded with zeros, thus, for example, <code>b'salt'</code> and <code>b'salt\x00'</code> is the same value. (This is not the case for <em>key</em>.)</p> </div> <p>These sizes are available as module <a class="reference internal" href="#constants">constants</a> described below.</p> <p>Constructor functions also accept the following tree hashing parameters:</p> <ul class="simple"> <li>
<em>fanout</em>: fanout (0 to 255, 0 if unlimited, 1 in sequential mode).</li> <li>
<em>depth</em>: maximal depth of tree (1 to 255, 255 if unlimited, 1 in sequential mode).</li> <li>
<em>leaf_size</em>: maximal byte length of leaf (0 to <code>2**32-1</code>, 0 if unlimited or in sequential mode).</li> <li>
<em>node_offset</em>: node offset (0 to <code>2**64-1</code> for BLAKE2b, 0 to <code>2**48-1</code> for BLAKE2s, 0 for the first, leftmost, leaf, or in sequential mode).</li> <li>
<em>node_depth</em>: node depth (0 to 255, 0 for leaves, or in sequential mode).</li> <li>
<em>inner_size</em>: inner digest size (0 to 64 for BLAKE2b, 0 to 32 for BLAKE2s, 0 in sequential mode).</li> <li>
<em>last_node</em>: boolean indicating whether the processed node is the last one (<code>False</code> for sequential mode).</li> </ul> <figure class="align-default"> <img alt="Explanation of tree mode parameters." class="invert-in-dark-mode" src="data:image/png;base64,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"> </figure> <p>See section 2.10 in <a class="reference external" href="https://www.blake2.net/blake2_20130129.pdf">BLAKE2 specification</a> for comprehensive review of tree hashing.</p> </section> <section id="constants"> <h3>Constants</h3> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.blake2b.SALT_SIZE">
<code>blake2b.SALT_SIZE</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.blake2s.SALT_SIZE">
<code>blake2s.SALT_SIZE</code> </dt> <dd></dd>
</dl> <p>Salt length (maximum length accepted by constructors).</p> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.blake2b.PERSON_SIZE">
<code>blake2b.PERSON_SIZE</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.blake2s.PERSON_SIZE">
<code>blake2s.PERSON_SIZE</code> </dt> <dd></dd>
</dl> <p>Personalization string length (maximum length accepted by constructors).</p> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.blake2b.MAX_KEY_SIZE">
<code>blake2b.MAX_KEY_SIZE</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.blake2s.MAX_KEY_SIZE">
<code>blake2s.MAX_KEY_SIZE</code> </dt> <dd></dd>
</dl> <p>Maximum key size.</p> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.blake2b.MAX_DIGEST_SIZE">
<code>blake2b.MAX_DIGEST_SIZE</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="hashlib.blake2s.MAX_DIGEST_SIZE">
<code>blake2s.MAX_DIGEST_SIZE</code> </dt> <dd></dd>
</dl> <p>Maximum digest size that the hash function can output.</p> </section> <section id="examples"> <h3>Examples</h3> <section id="simple-hashing"> <h4>Simple hashing</h4> <p>To calculate hash of some data, you should first construct a hash object by calling the appropriate constructor function (<a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code>blake2b()</code></a> or <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code>blake2s()</code></a>), then update it with the data by calling <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code>update()</code></a> on the object, and, finally, get the digest out of the object by calling <a class="reference internal" href="#hashlib.hash.digest" title="hashlib.hash.digest"><code>digest()</code></a> (or <a class="reference internal" href="#hashlib.hash.hexdigest" title="hashlib.hash.hexdigest"><code>hexdigest()</code></a> for hex-encoded string).</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import blake2b
&gt;&gt;&gt; h = blake2b()
&gt;&gt;&gt; h.update(b'Hello world')
&gt;&gt;&gt; h.hexdigest()
'6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183'
</pre> <p>As a shortcut, you can pass the first chunk of data to update directly to the constructor as the positional argument:</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import blake2b
&gt;&gt;&gt; blake2b(b'Hello world').hexdigest()
'6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183'
</pre> <p>You can call <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code>hash.update()</code></a> as many times as you need to iteratively update the hash:</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import blake2b
&gt;&gt;&gt; items = [b'Hello', b' ', b'world']
&gt;&gt;&gt; h = blake2b()
&gt;&gt;&gt; for item in items:
...     h.update(item)
...
&gt;&gt;&gt; h.hexdigest()
'6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183'
</pre> </section> <section id="using-different-digest-sizes"> <h4>Using different digest sizes</h4> <p>BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to 32 bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without changing the size of output, we can tell BLAKE2b to produce 20-byte digests:</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import blake2b
&gt;&gt;&gt; h = blake2b(digest_size=20)
&gt;&gt;&gt; h.update(b'Replacing SHA1 with the more secure function')
&gt;&gt;&gt; h.hexdigest()
'd24f26cf8de66472d58d4e1b1774b4c9158b1f4c'
&gt;&gt;&gt; h.digest_size
20
&gt;&gt;&gt; len(h.digest())
20
</pre> <p>Hash objects with different digest sizes have completely different outputs (shorter hashes are <em>not</em> prefixes of longer hashes); BLAKE2b and BLAKE2s produce different outputs even if the output length is the same:</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import blake2b, blake2s
&gt;&gt;&gt; blake2b(digest_size=10).hexdigest()
'6fa1d8fcfd719046d762'
&gt;&gt;&gt; blake2b(digest_size=11).hexdigest()
'eb6ec15daf9546254f0809'
&gt;&gt;&gt; blake2s(digest_size=10).hexdigest()
'1bf21a98c78a1c376ae9'
&gt;&gt;&gt; blake2s(digest_size=11).hexdigest()
'567004bf96e4a25773ebf4'
</pre> </section> <section id="keyed-hashing"> <h4>Keyed hashing</h4> <p>Keyed hashing can be used for authentication as a faster and simpler replacement for <a class="reference external" href="https://en.wikipedia.org/wiki/HMAC">Hash-based message authentication code</a> (HMAC). BLAKE2 can be securely used in prefix-MAC mode thanks to the indifferentiability property inherited from BLAKE.</p> <p>This example shows how to get a (hex-encoded) 128-bit authentication code for message <code>b'message data'</code> with key <code>b'pseudorandom key'</code>:</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import blake2b
&gt;&gt;&gt; h = blake2b(key=b'pseudorandom key', digest_size=16)
&gt;&gt;&gt; h.update(b'message data')
&gt;&gt;&gt; h.hexdigest()
'3d363ff7401e02026f4a4687d4863ced'
</pre> <p>As a practical example, a web application can symmetrically sign cookies sent to users and later verify them to make sure they weren’t tampered with:</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import blake2b
&gt;&gt;&gt; from hmac import compare_digest
&gt;&gt;&gt;
&gt;&gt;&gt; SECRET_KEY = b'pseudorandomly generated server secret key'
&gt;&gt;&gt; AUTH_SIZE = 16
&gt;&gt;&gt;
&gt;&gt;&gt; def sign(cookie):
...     h = blake2b(digest_size=AUTH_SIZE, key=SECRET_KEY)
...     h.update(cookie)
...     return h.hexdigest().encode('utf-8')
&gt;&gt;&gt;
&gt;&gt;&gt; def verify(cookie, sig):
...     good_sig = sign(cookie)
...     return compare_digest(good_sig, sig)
&gt;&gt;&gt;
&gt;&gt;&gt; cookie = b'user-alice'
&gt;&gt;&gt; sig = sign(cookie)
&gt;&gt;&gt; print("{0},{1}".format(cookie.decode('utf-8'), sig))
user-alice,b'43b3c982cf697e0c5ab22172d1ca7421'
&gt;&gt;&gt; verify(cookie, sig)
True
&gt;&gt;&gt; verify(b'user-bob', sig)
False
&gt;&gt;&gt; verify(cookie, b'0102030405060708090a0b0c0d0e0f00')
False
</pre> <p>Even though there’s a native keyed hashing mode, BLAKE2 can, of course, be used in HMAC construction with <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code>hmac</code></a> module:</p> <pre data-language="python">&gt;&gt;&gt; import hmac, hashlib
&gt;&gt;&gt; m = hmac.new(b'secret key', digestmod=hashlib.blake2s)
&gt;&gt;&gt; m.update(b'message')
&gt;&gt;&gt; m.hexdigest()
'e3c8102868d28b5ff85fc35dda07329970d1a01e273c37481326fe0c861c8142'
</pre> </section> <section id="randomized-hashing"> <h4>Randomized hashing</h4> <p>By setting <em>salt</em> parameter users can introduce randomization to the hash function. Randomized hashing is useful for protecting against collision attacks on the hash function used in digital signatures.</p>  <p>Randomized hashing is designed for situations where one party, the message preparer, generates all or part of a message to be signed by a second party, the message signer. If the message preparer is able to find cryptographic hash function collisions (i.e., two messages producing the same hash value), then they might prepare meaningful versions of the message that would produce the same hash value and digital signature, but with different results (e.g., transferring $1,000,000 to an account, rather than $10). Cryptographic hash functions have been designed with collision resistance as a major goal, but the current concentration on attacking cryptographic hash functions may result in a given cryptographic hash function providing less collision resistance than expected. Randomized hashing offers the signer additional protection by reducing the likelihood that a preparer can generate two or more messages that ultimately yield the same hash value during the digital signature generation process — even if it is practical to find collisions for the hash function. However, the use of randomized hashing may reduce the amount of security provided by a digital signature when all portions of the message are prepared by the signer.</p> <p>(<a class="reference external" href="https://csrc.nist.gov/publications/detail/sp/800-106/archive/2009-02-25">NIST SP-800-106 “Randomized Hashing for Digital Signatures”</a>)</p>  <p>In BLAKE2 the salt is processed as a one-time input to the hash function during initialization, rather than as an input to each compression function.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><em>Salted hashing</em> (or just hashing) with BLAKE2 or any other general-purpose cryptographic hash function, such as SHA-256, is not suitable for hashing passwords. See <a class="reference external" href="https://www.blake2.net/#qa">BLAKE2 FAQ</a> for more information.</p> </div> <pre data-language="python">&gt;&gt;&gt; import os
&gt;&gt;&gt; from hashlib import blake2b
&gt;&gt;&gt; msg = b'some message'
&gt;&gt;&gt; # Calculate the first hash with a random salt.
&gt;&gt;&gt; salt1 = os.urandom(blake2b.SALT_SIZE)
&gt;&gt;&gt; h1 = blake2b(salt=salt1)
&gt;&gt;&gt; h1.update(msg)
&gt;&gt;&gt; # Calculate the second hash with a different random salt.
&gt;&gt;&gt; salt2 = os.urandom(blake2b.SALT_SIZE)
&gt;&gt;&gt; h2 = blake2b(salt=salt2)
&gt;&gt;&gt; h2.update(msg)
&gt;&gt;&gt; # The digests are different.
&gt;&gt;&gt; h1.digest() != h2.digest()
True
</pre> </section> <section id="personalization"> <h4>Personalization</h4> <p>Sometimes it is useful to force hash function to produce different digests for the same input for different purposes. Quoting the authors of the Skein hash function:</p>  <p>We recommend that all application designers seriously consider doing this; we have seen many protocols where a hash that is computed in one part of the protocol can be used in an entirely different part because two hash computations were done on similar or related data, and the attacker can force the application to make the hash inputs the same. Personalizing each hash function used in the protocol summarily stops this type of attack.</p> <p>(<a class="reference external" href="https://www.schneier.com/wp-content/uploads/2016/02/skein.pdf">The Skein Hash Function Family</a>, p. 21)</p>  <p>BLAKE2 can be personalized by passing bytes to the <em>person</em> argument:</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import blake2b
&gt;&gt;&gt; FILES_HASH_PERSON = b'MyApp Files Hash'
&gt;&gt;&gt; BLOCK_HASH_PERSON = b'MyApp Block Hash'
&gt;&gt;&gt; h = blake2b(digest_size=32, person=FILES_HASH_PERSON)
&gt;&gt;&gt; h.update(b'the same content')
&gt;&gt;&gt; h.hexdigest()
'20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4'
&gt;&gt;&gt; h = blake2b(digest_size=32, person=BLOCK_HASH_PERSON)
&gt;&gt;&gt; h.update(b'the same content')
&gt;&gt;&gt; h.hexdigest()
'cf68fb5761b9c44e7878bfb2c4c9aea52264a80b75005e65619778de59f383a3'
</pre> <p>Personalization together with the keyed mode can also be used to derive different keys from a single one.</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import blake2s
&gt;&gt;&gt; from base64 import b64decode, b64encode
&gt;&gt;&gt; orig_key = b64decode(b'Rm5EPJai72qcK3RGBpW3vPNfZy5OZothY+kHY6h21KM=')
&gt;&gt;&gt; enc_key = blake2s(key=orig_key, person=b'kEncrypt').digest()
&gt;&gt;&gt; mac_key = blake2s(key=orig_key, person=b'kMAC').digest()
&gt;&gt;&gt; print(b64encode(enc_key).decode('utf-8'))
rbPb15S/Z9t+agffno5wuhB77VbRi6F9Iv2qIxU7WHw=
&gt;&gt;&gt; print(b64encode(mac_key).decode('utf-8'))
G9GtHFE1YluXY1zWPlYk1e/nWfu0WSEb0KRcjhDeP/o=
</pre> </section> <section id="tree-mode"> <h4>Tree mode</h4> <p>Here’s an example of hashing a minimal tree with two leaf nodes:</p> <pre data-language="python">  10
 /  \
00  01
</pre> <p>This example uses 64-byte internal digests, and returns the 32-byte final digest:</p> <pre data-language="python">&gt;&gt;&gt; from hashlib import blake2b
&gt;&gt;&gt;
&gt;&gt;&gt; FANOUT = 2
&gt;&gt;&gt; DEPTH = 2
&gt;&gt;&gt; LEAF_SIZE = 4096
&gt;&gt;&gt; INNER_SIZE = 64
&gt;&gt;&gt;
&gt;&gt;&gt; buf = bytearray(6000)
&gt;&gt;&gt;
&gt;&gt;&gt; # Left leaf
... h00 = blake2b(buf[0:LEAF_SIZE], fanout=FANOUT, depth=DEPTH,
...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,
...               node_offset=0, node_depth=0, last_node=False)
&gt;&gt;&gt; # Right leaf
... h01 = blake2b(buf[LEAF_SIZE:], fanout=FANOUT, depth=DEPTH,
...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,
...               node_offset=1, node_depth=0, last_node=True)
&gt;&gt;&gt; # Root node
... h10 = blake2b(digest_size=32, fanout=FANOUT, depth=DEPTH,
...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,
...               node_offset=0, node_depth=1, last_node=True)
&gt;&gt;&gt; h10.update(h00.digest())
&gt;&gt;&gt; h10.update(h01.digest())
&gt;&gt;&gt; h10.hexdigest()
'3ad2a9b37c6070e374c7a8c508fe20ca86b6ed54e286e93a0318e95e881db5aa'
</pre> </section> </section> <section id="credits"> <h3>Credits</h3> <p><a class="reference external" href="https://www.blake2.net">BLAKE2</a> was designed by <em>Jean-Philippe Aumasson</em>, <em>Samuel Neves</em>, <em>Zooko Wilcox-O’Hearn</em>, and <em>Christian Winnerlein</em> based on <a class="reference external" href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms">SHA-3</a> finalist <a class="reference external" href="https://web.archive.org/web/20200918190133/https://131002.net/blake/">BLAKE</a> created by <em>Jean-Philippe Aumasson</em>, <em>Luca Henzen</em>, <em>Willi Meier</em>, and <em>Raphael C.-W. Phan</em>.</p> <p>It uses core algorithm from <a class="reference external" href="https://cr.yp.to/chacha.html">ChaCha</a> cipher designed by <em>Daniel J. Bernstein</em>.</p> <p>The stdlib implementation is based on <a class="reference external" href="https://pythonhosted.org/pyblake2/">pyblake2</a> module. It was written by <em>Dmitry Chestnykh</em> based on C implementation written by <em>Samuel Neves</em>. The documentation was copied from <a class="reference external" href="https://pythonhosted.org/pyblake2/">pyblake2</a> and written by <em>Dmitry Chestnykh</em>.</p> <p>The C code was partly rewritten for Python by <em>Christian Heimes</em>.</p> <p>The following public domain dedication applies for both C hash function implementation, extension code, and this documentation:</p>  <p>To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.</p> <p>You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see <a class="reference external" href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a>.</p>  <p>The following people have helped with development or contributed their changes to the project and the public domain according to the Creative Commons Public Domain Dedication 1.0 Universal:</p> <ul class="simple"> <li><em>Alexandr Sokolovskiy</em></li> </ul> <div class="admonition seealso" id="hashlib-seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code>hmac</code></a>
</dt>
<dd>
<p>A module to generate message authentication codes using hashes.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="base64.html#module-base64" title="base64: RFC 4648: Base16, Base32, Base64 Data Encodings; Base85 and Ascii85"><code>base64</code></a>
</dt>
<dd>
<p>Another way to encode binary hashes for non-binary environments.</p> </dd> <dt><a class="reference external" href="https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf">https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf</a></dt>
<dd>
<p>The FIPS 180-4 publication on Secure Hash Algorithms.</p> </dd> <dt><a class="reference external" href="https://csrc.nist.gov/publications/detail/fips/202/final">https://csrc.nist.gov/publications/detail/fips/202/final</a></dt>
<dd>
<p>The FIPS 202 publication on the SHA-3 Standard.</p> </dd> <dt><a class="reference external" href="https://www.blake2.net/">https://www.blake2.net/</a></dt>
<dd>
<p>Official BLAKE2 website.</p> </dd> <dt><a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">https://en.wikipedia.org/wiki/Cryptographic_hash_function</a></dt>
<dd>
<p>Wikipedia article with information on which algorithms have known issues and what that means regarding their use.</p> </dd> <dt><a class="reference external" href="https://www.ietf.org/rfc/rfc8018.txt">https://www.ietf.org/rfc/rfc8018.txt</a></dt>
<dd>
<p>PKCS #5: Password-Based Cryptography Specification Version 2.1</p> </dd> <dt><a class="reference external" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf">https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf</a></dt>
<dd>
<p>NIST Recommendation for Password-Based Key Derivation.</p> </dd> </dl> </div> </section> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/hashlib.html" class="_attribution-link">https://docs.python.org/3.13/library/hashlib.html</a>
  </p>
</div>
