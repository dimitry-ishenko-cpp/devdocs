 <span id="mailbox-manipulate-mailboxes-in-various-formats"></span><h1>mailbox — Manipulate mailboxes in various formats</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/mailbox.py">Lib/mailbox.py</a></p>  <p>This module defines two classes, <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> and <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a>, for accessing and manipulating on-disk mailboxes and the messages they contain. <code>Mailbox</code> offers a dictionary-like mapping from keys to messages. <code>Message</code> extends the <a class="reference internal" href="email.message.html#module-email.message" title="email.message: The base class representing email messages."><code>email.message</code></a> module’s <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code>Message</code></a> class with format-specific state and behavior. Supported mailbox formats are Maildir, mbox, MH, Babyl, and MMDF.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code>email</code></a>
</dt>
<dd>
<p>Represent and manipulate messages.</p> </dd> </dl> </div> <section id="mailbox-objects"> <span id="id1"></span><h2>
<code>Mailbox</code> objects</h2> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.Mailbox">
<code>class mailbox.Mailbox</code> </dt> <dd>
<p>A mailbox, which may be inspected and modified.</p> <p>The <code>Mailbox</code> class defines an interface and is not intended to be instantiated. Instead, format-specific subclasses should inherit from <code>Mailbox</code> and your code should instantiate a particular subclass.</p> <p>The <code>Mailbox</code> interface is dictionary-like, with small keys corresponding to messages. Keys are issued by the <code>Mailbox</code> instance with which they will be used and are only meaningful to that <code>Mailbox</code> instance. A key continues to identify a message even if the corresponding message is modified, such as by replacing it with another message.</p> <p>Messages may be added to a <code>Mailbox</code> instance using the set-like method <a class="reference internal" href="#mailbox.Mailbox.add" title="mailbox.Mailbox.add"><code>add()</code></a> and removed using a <code>del</code> statement or the set-like methods <a class="reference internal" href="#mailbox.Mailbox.remove" title="mailbox.Mailbox.remove"><code>remove()</code></a> and <a class="reference internal" href="#mailbox.Mailbox.discard" title="mailbox.Mailbox.discard"><code>discard()</code></a>.</p> <p><code>Mailbox</code> interface semantics differ from dictionary semantics in some noteworthy ways. Each time a message is requested, a new representation (typically a <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> instance) is generated based upon the current state of the mailbox. Similarly, when a message is added to a <code>Mailbox</code> instance, the provided message representation’s contents are copied. In neither case is a reference to the message representation kept by the <code>Mailbox</code> instance.</p> <p>The default <code>Mailbox</code> <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> iterates over message representations, not keys as the default <a class="reference internal" href="stdtypes.html#dict" title="dict"><code>dictionary</code></a> iterator does. Moreover, modification of a mailbox during iteration is safe and well-defined. Messages added to the mailbox after an iterator is created will not be seen by the iterator. Messages removed from the mailbox before the iterator yields them will be silently skipped, though using a key from an iterator may result in a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception if the corresponding message is subsequently removed.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Be very cautious when modifying mailboxes that might be simultaneously changed by some other process. The safest mailbox format to use for such tasks is <a class="reference internal" href="#mailbox.Maildir" title="mailbox.Maildir"><code>Maildir</code></a>; try to avoid using single-file formats such as <a class="reference internal" href="#mailbox.mbox" title="mailbox.mbox"><code>mbox</code></a> for concurrent writing. If you’re modifying a mailbox, you <em>must</em> lock it by calling the <a class="reference internal" href="#mailbox.Mailbox.lock" title="mailbox.Mailbox.lock"><code>lock()</code></a> and <a class="reference internal" href="#mailbox.Mailbox.unlock" title="mailbox.Mailbox.unlock"><code>unlock()</code></a> methods <em>before</em> reading any messages in the file or making any changes by adding or deleting a message. Failing to lock the mailbox runs the risk of losing messages or corrupting the entire mailbox.</p> </div> <p><code>Mailbox</code> instances have the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.add">
<code>add(message)</code> </dt> <dd>
<p>Add <em>message</em> to the mailbox and return the key that has been assigned to it.</p> <p>Parameter <em>message</em> may be a <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> instance, an <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code>email.message.Message</code></a> instance, a string, a byte string, or a file-like object (which should be open in binary mode). If <em>message</em> is an instance of the appropriate format-specific <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> subclass (e.g., if it’s an <a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> instance and this is an <a class="reference internal" href="#mailbox.mbox" title="mailbox.mbox"><code>mbox</code></a> instance), its format-specific information is used. Otherwise, reasonable defaults for format-specific information are used.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Support for binary input was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.remove">
<code>remove(key)</code> </dt> <dt class="sig sig-object py" id="mailbox.Mailbox.__delitem__">
<code>__delitem__(key)</code> </dt> <dt class="sig sig-object py" id="mailbox.Mailbox.discard">
<code>discard(key)</code> </dt> <dd>
<p>Delete the message corresponding to <em>key</em> from the mailbox.</p> <p>If no such message exists, a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception is raised if the method was called as <a class="reference internal" href="#mailbox.Mailbox.remove" title="mailbox.Mailbox.remove"><code>remove()</code></a> or <a class="reference internal" href="#mailbox.Mailbox.__delitem__" title="mailbox.Mailbox.__delitem__"><code>__delitem__()</code></a> but no exception is raised if the method was called as <a class="reference internal" href="#mailbox.Mailbox.discard" title="mailbox.Mailbox.discard"><code>discard()</code></a>. The behavior of <a class="reference internal" href="#mailbox.Mailbox.discard" title="mailbox.Mailbox.discard"><code>discard()</code></a> may be preferred if the underlying mailbox format supports concurrent modification by other processes.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.__setitem__">
<code>__setitem__(key, message)</code> </dt> <dd>
<p>Replace the message corresponding to <em>key</em> with <em>message</em>. Raise a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception if no message already corresponds to <em>key</em>.</p> <p>As with <a class="reference internal" href="#mailbox.Mailbox.add" title="mailbox.Mailbox.add"><code>add()</code></a>, parameter <em>message</em> may be a <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> instance, an <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code>email.message.Message</code></a> instance, a string, a byte string, or a file-like object (which should be open in binary mode). If <em>message</em> is an instance of the appropriate format-specific <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> subclass (e.g., if it’s an <a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> instance and this is an <a class="reference internal" href="#mailbox.mbox" title="mailbox.mbox"><code>mbox</code></a> instance), its format-specific information is used. Otherwise, the format-specific information of the message that currently corresponds to <em>key</em> is left unchanged.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.iterkeys">
<code>iterkeys()</code> </dt> <dd>
<p>Return an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> over all keys</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.keys">
<code>keys()</code> </dt> <dd>
<p>The same as <a class="reference internal" href="#mailbox.Mailbox.iterkeys" title="mailbox.Mailbox.iterkeys"><code>iterkeys()</code></a>, except that a <a class="reference internal" href="stdtypes.html#list" title="list"><code>list</code></a> is returned rather than an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.itervalues">
<code>itervalues()</code> </dt> <dt class="sig sig-object py" id="mailbox.Mailbox.__iter__">
<code>__iter__()</code> </dt> <dd>
<p>Return an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> over representations of all messages. The messages are represented as instances of the appropriate format-specific <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> subclass unless a custom message factory was specified when the <code>Mailbox</code> instance was initialized.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The behavior of <a class="reference internal" href="#mailbox.Mailbox.__iter__" title="mailbox.Mailbox.__iter__"><code>__iter__()</code></a> is unlike that of dictionaries, which iterate over keys.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.values">
<code>values()</code> </dt> <dd>
<p>The same as <a class="reference internal" href="#mailbox.Mailbox.itervalues" title="mailbox.Mailbox.itervalues"><code>itervalues()</code></a>, except that a <a class="reference internal" href="stdtypes.html#list" title="list"><code>list</code></a> is returned rather than an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.iteritems">
<code>iteritems()</code> </dt> <dd>
<p>Return an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> over (<em>key</em>, <em>message</em>) pairs, where <em>key</em> is a key and <em>message</em> is a message representation. The messages are represented as instances of the appropriate format-specific <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> subclass unless a custom message factory was specified when the <code>Mailbox</code> instance was initialized.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.items">
<code>items()</code> </dt> <dd>
<p>The same as <a class="reference internal" href="#mailbox.Mailbox.iteritems" title="mailbox.Mailbox.iteritems"><code>iteritems()</code></a>, except that a <a class="reference internal" href="stdtypes.html#list" title="list"><code>list</code></a> of pairs is returned rather than an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> of pairs.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.get">
<code>get(key, default=None)</code> </dt> <dt class="sig sig-object py" id="mailbox.Mailbox.__getitem__">
<code>__getitem__(key)</code> </dt> <dd>
<p>Return a representation of the message corresponding to <em>key</em>. If no such message exists, <em>default</em> is returned if the method was called as <a class="reference internal" href="#mailbox.Mailbox.get" title="mailbox.Mailbox.get"><code>get()</code></a> and a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception is raised if the method was called as <code>__getitem__()</code>. The message is represented as an instance of the appropriate format-specific <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> subclass unless a custom message factory was specified when the <code>Mailbox</code> instance was initialized.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.get_message">
<code>get_message(key)</code> </dt> <dd>
<p>Return a representation of the message corresponding to <em>key</em> as an instance of the appropriate format-specific <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> subclass, or raise a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception if no such message exists.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.get_bytes">
<code>get_bytes(key)</code> </dt> <dd>
<p>Return a byte representation of the message corresponding to <em>key</em>, or raise a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception if no such message exists.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.get_string">
<code>get_string(key)</code> </dt> <dd>
<p>Return a string representation of the message corresponding to <em>key</em>, or raise a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception if no such message exists. The message is processed through <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code>email.message.Message</code></a> to convert it to a 7bit clean representation.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.get_file">
<code>get_file(key)</code> </dt> <dd>
<p>Return a <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">file-like</span></a> representation of the message corresponding to <em>key</em>, or raise a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception if no such message exists. The file-like object behaves as if open in binary mode. This file should be closed once it is no longer needed.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>The file object really is a <a class="reference internal" href="../glossary.html#term-binary-file"><span class="xref std std-term">binary file</span></a>; previously it was incorrectly returned in text mode. Also, the <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">file-like object</span></a> now supports the <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> protocol: you can use a <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> statement to automatically close it.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Unlike other representations of messages, <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">file-like</span></a> representations are not necessarily independent of the <code>Mailbox</code> instance that created them or of the underlying mailbox. More specific documentation is provided by each subclass.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.__contains__">
<code>__contains__(key)</code> </dt> <dd>
<p>Return <code>True</code> if <em>key</em> corresponds to a message, <code>False</code> otherwise.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.__len__">
<code>__len__()</code> </dt> <dd>
<p>Return a count of messages in the mailbox.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.clear">
<code>clear()</code> </dt> <dd>
<p>Delete all messages from the mailbox.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.pop">
<code>pop(key, default=None)</code> </dt> <dd>
<p>Return a representation of the message corresponding to <em>key</em> and delete the message. If no such message exists, return <em>default</em>. The message is represented as an instance of the appropriate format-specific <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> subclass unless a custom message factory was specified when the <code>Mailbox</code> instance was initialized.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.popitem">
<code>popitem()</code> </dt> <dd>
<p>Return an arbitrary (<em>key</em>, <em>message</em>) pair, where <em>key</em> is a key and <em>message</em> is a message representation, and delete the corresponding message. If the mailbox is empty, raise a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception. The message is represented as an instance of the appropriate format-specific <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> subclass unless a custom message factory was specified when the <code>Mailbox</code> instance was initialized.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.update">
<code>update(arg)</code> </dt> <dd>
<p>Parameter <em>arg</em> should be a <em>key</em>-to-<em>message</em> mapping or an iterable of (<em>key</em>, <em>message</em>) pairs. Updates the mailbox so that, for each given <em>key</em> and <em>message</em>, the message corresponding to <em>key</em> is set to <em>message</em> as if by using <a class="reference internal" href="#mailbox.Mailbox.__setitem__" title="mailbox.Mailbox.__setitem__"><code>__setitem__()</code></a>. As with <a class="reference internal" href="#mailbox.Mailbox.__setitem__" title="mailbox.Mailbox.__setitem__"><code>__setitem__()</code></a>, each <em>key</em> must already correspond to a message in the mailbox or else a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> exception will be raised, so in general it is incorrect for <em>arg</em> to be a <code>Mailbox</code> instance.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Unlike with dictionaries, keyword arguments are not supported.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.flush">
<code>flush()</code> </dt> <dd>
<p>Write any pending changes to the filesystem. For some <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> subclasses, changes are always written immediately and <code>flush()</code> does nothing, but you should still make a habit of calling this method.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.lock">
<code>lock()</code> </dt> <dd>
<p>Acquire an exclusive advisory lock on the mailbox so that other processes know not to modify it. An <a class="reference internal" href="#mailbox.ExternalClashError" title="mailbox.ExternalClashError"><code>ExternalClashError</code></a> is raised if the lock is not available. The particular locking mechanisms used depend upon the mailbox format. You should <em>always</em> lock the mailbox before making any modifications to its contents.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.unlock">
<code>unlock()</code> </dt> <dd>
<p>Release the lock on the mailbox, if any.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Mailbox.close">
<code>close()</code> </dt> <dd>
<p>Flush the mailbox, unlock it if necessary, and close any open files. For some <code>Mailbox</code> subclasses, this method does nothing.</p> </dd>
</dl> </dd>
</dl> <section id="maildir-objects"> <span id="mailbox-maildir"></span><h3>
<code>Maildir</code> objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.Maildir">
<code>class mailbox.Maildir(dirname, factory=None, create=True)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> for mailboxes in Maildir format. Parameter <em>factory</em> is a callable object that accepts a file-like message representation (which behaves as if opened in binary mode) and returns a custom representation. If <em>factory</em> is <code>None</code>, <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> is used as the default message representation. If <em>create</em> is <code>True</code>, the mailbox is created if it does not exist.</p> <p>If <em>create</em> is <code>True</code> and the <em>dirname</em> path exists, it will be treated as an existing maildir without attempting to verify its directory layout.</p> <p>It is for historical reasons that <em>dirname</em> is named as such rather than <em>path</em>.</p> <p>Maildir is a directory-based mailbox format invented for the qmail mail transfer agent and now widely supported by other programs. Messages in a Maildir mailbox are stored in separate files within a common directory structure. This design allows Maildir mailboxes to be accessed and modified by multiple unrelated programs without data corruption, so file locking is unnecessary.</p> <p>Maildir mailboxes contain three subdirectories, namely: <code>tmp</code>, <code>new</code>, and <code>cur</code>. Messages are created momentarily in the <code>tmp</code> subdirectory and then moved to the <code>new</code> subdirectory to finalize delivery. A mail user agent may subsequently move the message to the <code>cur</code> subdirectory and store information about the state of the message in a special “info” section appended to its file name.</p> <p>Folders of the style introduced by the Courier mail transfer agent are also supported. Any subdirectory of the main mailbox is considered a folder if <code>'.'</code> is the first character in its name. Folder names are represented by <code>Maildir</code> without the leading <code>'.'</code>. Each folder is itself a Maildir mailbox but should not contain other folders. Instead, a logical nesting is indicated using <code>'.'</code> to delimit levels, e.g., “Archived.2005.07”.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="mailbox.Maildir.colon">
<code>colon</code> </dt> <dd>
<p>The Maildir specification requires the use of a colon (<code>':'</code>) in certain message file names. However, some operating systems do not permit this character in file names, If you wish to use a Maildir-like format on such an operating system, you should specify another character to use instead. The exclamation point (<code>'!'</code>) is a popular choice. For example:</p> <pre data-language="python">import mailbox
mailbox.Maildir.colon = '!'
</pre> <p>The <code>colon</code> attribute may also be set on a per-instance basis.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span><a class="reference internal" href="#mailbox.Maildir" title="mailbox.Maildir"><code>Maildir</code></a> now ignores files with a leading dot.</p> </div> <p><code>Maildir</code> instances have all of the methods of <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> in addition to the following:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.list_folders">
<code>list_folders()</code> </dt> <dd>
<p>Return a list of the names of all folders.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.get_folder">
<code>get_folder(folder)</code> </dt> <dd>
<p>Return a <code>Maildir</code> instance representing the folder whose name is <em>folder</em>. A <a class="reference internal" href="#mailbox.NoSuchMailboxError" title="mailbox.NoSuchMailboxError"><code>NoSuchMailboxError</code></a> exception is raised if the folder does not exist.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.add_folder">
<code>add_folder(folder)</code> </dt> <dd>
<p>Create a folder whose name is <em>folder</em> and return a <code>Maildir</code> instance representing it.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.remove_folder">
<code>remove_folder(folder)</code> </dt> <dd>
<p>Delete the folder whose name is <em>folder</em>. If the folder contains any messages, a <a class="reference internal" href="#mailbox.NotEmptyError" title="mailbox.NotEmptyError"><code>NotEmptyError</code></a> exception will be raised and the folder will not be deleted.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.clean">
<code>clean()</code> </dt> <dd>
<p>Delete temporary files from the mailbox that have not been accessed in the last 36 hours. The Maildir specification says that mail-reading programs should do this occasionally.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.get_flags">
<code>get_flags(key)</code> </dt> <dd>
<p>Return as a string the flags that are set on the message corresponding to <em>key</em>. This is the same as <code>get_message(key).get_flags()</code> but much faster, because it does not open the message file. Use this method when iterating over the keys to determine which messages are interesting to get.</p> <p>If you do have a <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> object, use its <a class="reference internal" href="#mailbox.MaildirMessage.get_flags" title="mailbox.MaildirMessage.get_flags"><code>get_flags()</code></a> method instead, because changes made by the message’s <a class="reference internal" href="#mailbox.MaildirMessage.set_flags" title="mailbox.MaildirMessage.set_flags"><code>set_flags()</code></a>, <a class="reference internal" href="#mailbox.MaildirMessage.add_flag" title="mailbox.MaildirMessage.add_flag"><code>add_flag()</code></a> and <a class="reference internal" href="#mailbox.MaildirMessage.remove_flag" title="mailbox.MaildirMessage.remove_flag"><code>remove_flag()</code></a> methods are not reflected here until the mailbox’s <a class="reference internal" href="#mailbox.Maildir.__setitem__" title="mailbox.Maildir.__setitem__"><code>__setitem__()</code></a> method is called.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.set_flags">
<code>set_flags(key, flags)</code> </dt> <dd>
<p>On the message corresponding to <em>key</em>, set the flags specified by <em>flags</em> and unset all others. Calling <code>some_mailbox.set_flags(key, flags)</code> is similar to</p> <pre data-language="python">one_message = some_mailbox.get_message(key)
one_message.set_flags(flags)
some_mailbox[key] = one_message
</pre> <p>but faster, because it does not open the message file.</p> <p>If you do have a <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> object, use its <a class="reference internal" href="#mailbox.MaildirMessage.set_flags" title="mailbox.MaildirMessage.set_flags"><code>set_flags()</code></a> method instead, because changes made with this mailbox method will not be visible to the message object’s method, <a class="reference internal" href="#mailbox.MaildirMessage.get_flags" title="mailbox.MaildirMessage.get_flags"><code>get_flags()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.add_flag">
<code>add_flag(key, flag)</code> </dt> <dd>
<p>On the message corresponding to <em>key</em>, set the flags specified by <em>flag</em> without changing other flags. To add more than one flag at a time, <em>flag</em> may be a string of more than one character.</p> <p>Considerations for using this method versus the message object’s <a class="reference internal" href="#mailbox.MaildirMessage.add_flag" title="mailbox.MaildirMessage.add_flag"><code>add_flag()</code></a> method are similar to those for <a class="reference internal" href="#mailbox.Maildir.set_flags" title="mailbox.Maildir.set_flags"><code>set_flags()</code></a>; see the discussion there.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.remove_flag">
<code>remove_flag(key, flag)</code> </dt> <dd>
<p>On the message corresponding to <em>key</em>, unset the flags specified by <em>flag</em> without changing other flags. To remove more than one flag at a time, <em>flag</em> may be a string of more than one character.</p> <p>Considerations for using this method versus the message object’s <a class="reference internal" href="#mailbox.MaildirMessage.remove_flag" title="mailbox.MaildirMessage.remove_flag"><code>remove_flag()</code></a> method are similar to those for <a class="reference internal" href="#mailbox.Maildir.set_flags" title="mailbox.Maildir.set_flags"><code>set_flags()</code></a>; see the discussion there.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.get_info">
<code>get_info(key)</code> </dt> <dd>
<p>Return a string containing the info for the message corresponding to <em>key</em>. This is the same as <code>get_message(key).get_info()</code> but much faster, because it does not open the message file. Use this method when iterating over the keys to determine which messages are interesting to get.</p> <p>If you do have a <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> object, use its <a class="reference internal" href="#mailbox.MaildirMessage.get_info" title="mailbox.MaildirMessage.get_info"><code>get_info()</code></a> method instead, because changes made by the message’s <a class="reference internal" href="#mailbox.MaildirMessage.set_info" title="mailbox.MaildirMessage.set_info"><code>set_info()</code></a> method are not reflected here until the mailbox’s <a class="reference internal" href="#mailbox.Maildir.__setitem__" title="mailbox.Maildir.__setitem__"><code>__setitem__()</code></a> method is called.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.set_info">
<code>set_info(key, info)</code> </dt> <dd>
<p>Set the info of the message corresponding to <em>key</em> to <em>info</em>. Calling <code>some_mailbox.set_info(key, flags)</code> is similar to</p> <pre data-language="python">one_message = some_mailbox.get_message(key)
one_message.set_info(info)
some_mailbox[key] = one_message
</pre> <p>but faster, because it does not open the message file.</p> <p>If you do have a <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> object, use its <a class="reference internal" href="#mailbox.MaildirMessage.set_info" title="mailbox.MaildirMessage.set_info"><code>set_info()</code></a> method instead, because changes made with this mailbox method will not be visible to the message object’s method, <a class="reference internal" href="#mailbox.MaildirMessage.get_info" title="mailbox.MaildirMessage.get_info"><code>get_info()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <p>Some <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> methods implemented by <code>Maildir</code> deserve special remarks:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.add">
<code>add(message)</code> </dt> <dt class="sig sig-object py" id="mailbox.Maildir.__setitem__">
<code>__setitem__(key, message)</code> </dt> <dt class="sig sig-object py" id="mailbox.Maildir.update">
<code>update(arg)</code> </dt> <dd>
<div class="admonition warning"> <p class="admonition-title">Warning</p> <p>These methods generate unique file names based upon the current process ID. When using multiple threads, undetected name clashes may occur and cause corruption of the mailbox unless threads are coordinated to avoid using these methods to manipulate the same mailbox simultaneously.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.flush">
<code>flush()</code> </dt> <dd>
<p>All changes to Maildir mailboxes are immediately applied, so this method does nothing.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.lock">
<code>lock()</code> </dt> <dt class="sig sig-object py" id="mailbox.Maildir.unlock">
<code>unlock()</code> </dt> <dd>
<p>Maildir mailboxes do not support (or require) locking, so these methods do nothing.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.close">
<code>close()</code> </dt> <dd>
<p><code>Maildir</code> instances do not keep any open files and the underlying mailboxes do not support locking, so this method does nothing.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Maildir.get_file">
<code>get_file(key)</code> </dt> <dd>
<p>Depending upon the host platform, it may not be possible to modify or remove the underlying message while the returned file remains open.</p> </dd>
</dl> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://www.courier-mta.org/maildir.html">maildir man page from Courier</a></dt>
<dd>
<p>A specification of the format. Describes a common extension for supporting folders.</p> </dd> <dt><a class="reference external" href="https://cr.yp.to/proto/maildir.html">Using maildir format</a></dt>
<dd>
<p>Notes on Maildir by its inventor. Includes an updated name-creation scheme and details on “info” semantics.</p> </dd> </dl> </div> </section> <section id="mbox-objects"> <span id="mailbox-mbox"></span><h3>
<code>mbox</code> objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.mbox">
<code>class mailbox.mbox(path, factory=None, create=True)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> for mailboxes in mbox format. Parameter <em>factory</em> is a callable object that accepts a file-like message representation (which behaves as if opened in binary mode) and returns a custom representation. If <em>factory</em> is <code>None</code>, <a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> is used as the default message representation. If <em>create</em> is <code>True</code>, the mailbox is created if it does not exist.</p> <p>The mbox format is the classic format for storing mail on Unix systems. All messages in an mbox mailbox are stored in a single file with the beginning of each message indicated by a line whose first five characters are “From “.</p> <p>Several variations of the mbox format exist to address perceived shortcomings in the original. In the interest of compatibility, <code>mbox</code> implements the original format, which is sometimes referred to as <em class="dfn">mboxo</em>. This means that the <em class="mailheader">Content-Length</em> header, if present, is ignored and that any occurrences of “From “ at the beginning of a line in a message body are transformed to “&gt;From “ when storing the message, although occurrences of “&gt;From “ are not transformed to “From “ when reading the message.</p> <p>Some <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> methods implemented by <code>mbox</code> deserve special remarks:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.mbox.get_file">
<code>get_file(key)</code> </dt> <dd>
<p>Using the file after calling <a class="reference internal" href="#mailbox.Mailbox.flush" title="mailbox.Mailbox.flush"><code>flush()</code></a> or <a class="reference internal" href="#mailbox.Mailbox.close" title="mailbox.Mailbox.close"><code>close()</code></a> on the <code>mbox</code> instance may yield unpredictable results or raise an exception.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.mbox.lock">
<code>lock()</code> </dt> <dt class="sig sig-object py" id="mailbox.mbox.unlock">
<code>unlock()</code> </dt> <dd>
<p>Three locking mechanisms are used—dot locking and, if available, the <code>flock()</code> and <code>lockf()</code> system calls.</p> </dd>
</dl> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="http://www.tin.org/bin/man.cgi?section=5&amp;topic=mbox">mbox man page from tin</a></dt>
<dd>
<p>A specification of the format, with details on locking.</p> </dd> <dt><a class="reference external" href="https://www.jwz.org/doc/content-length.html">Configuring Netscape Mail on Unix: Why The Content-Length Format is Bad</a></dt>
<dd>
<p>An argument for using the original mbox format rather than a variation.</p> </dd> <dt><a class="reference external" href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000383.shtml">“mbox” is a family of several mutually incompatible mailbox formats</a></dt>
<dd>
<p>A history of mbox variations.</p> </dd> </dl> </div> </section> <section id="mh-objects"> <span id="mailbox-mh"></span><h3>
<code>MH</code> objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.MH">
<code>class mailbox.MH(path, factory=None, create=True)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> for mailboxes in MH format. Parameter <em>factory</em> is a callable object that accepts a file-like message representation (which behaves as if opened in binary mode) and returns a custom representation. If <em>factory</em> is <code>None</code>, <a class="reference internal" href="#mailbox.MHMessage" title="mailbox.MHMessage"><code>MHMessage</code></a> is used as the default message representation. If <em>create</em> is <code>True</code>, the mailbox is created if it does not exist.</p> <p>MH is a directory-based mailbox format invented for the MH Message Handling System, a mail user agent. Each message in an MH mailbox resides in its own file. An MH mailbox may contain other MH mailboxes (called <em class="dfn">folders</em>) in addition to messages. Folders may be nested indefinitely. MH mailboxes also support <em class="dfn">sequences</em>, which are named lists used to logically group messages without moving them to sub-folders. Sequences are defined in a file called <code>.mh_sequences</code> in each folder.</p> <p>The <code>MH</code> class manipulates MH mailboxes, but it does not attempt to emulate all of <strong class="program">mh</strong>’s behaviors. In particular, it does not modify and is not affected by the <code>context</code> or <code>.mh_profile</code> files that are used by <strong class="program">mh</strong> to store its state and configuration.</p> <p><code>MH</code> instances have all of the methods of <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> in addition to the following:</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Supported folders that don’t contain a <code>.mh_sequences</code> file.</p> </div> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.list_folders">
<code>list_folders()</code> </dt> <dd>
<p>Return a list of the names of all folders.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.get_folder">
<code>get_folder(folder)</code> </dt> <dd>
<p>Return an <code>MH</code> instance representing the folder whose name is <em>folder</em>. A <a class="reference internal" href="#mailbox.NoSuchMailboxError" title="mailbox.NoSuchMailboxError"><code>NoSuchMailboxError</code></a> exception is raised if the folder does not exist.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.add_folder">
<code>add_folder(folder)</code> </dt> <dd>
<p>Create a folder whose name is <em>folder</em> and return an <code>MH</code> instance representing it.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.remove_folder">
<code>remove_folder(folder)</code> </dt> <dd>
<p>Delete the folder whose name is <em>folder</em>. If the folder contains any messages, a <a class="reference internal" href="#mailbox.NotEmptyError" title="mailbox.NotEmptyError"><code>NotEmptyError</code></a> exception will be raised and the folder will not be deleted.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.get_sequences">
<code>get_sequences()</code> </dt> <dd>
<p>Return a dictionary of sequence names mapped to key lists. If there are no sequences, the empty dictionary is returned.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.set_sequences">
<code>set_sequences(sequences)</code> </dt> <dd>
<p>Re-define the sequences that exist in the mailbox based upon <em>sequences</em>, a dictionary of names mapped to key lists, like returned by <a class="reference internal" href="#mailbox.MH.get_sequences" title="mailbox.MH.get_sequences"><code>get_sequences()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.pack">
<code>pack()</code> </dt> <dd>
<p>Rename messages in the mailbox as necessary to eliminate gaps in numbering. Entries in the sequences list are updated correspondingly.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Already-issued keys are invalidated by this operation and should not be subsequently used.</p> </div> </dd>
</dl> <p>Some <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> methods implemented by <code>MH</code> deserve special remarks:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.remove">
<code>remove(key)</code> </dt> <dt class="sig sig-object py" id="mailbox.MH.__delitem__">
<code>__delitem__(key)</code> </dt> <dt class="sig sig-object py" id="mailbox.MH.discard">
<code>discard(key)</code> </dt> <dd>
<p>These methods immediately delete the message. The MH convention of marking a message for deletion by prepending a comma to its name is not used.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.lock">
<code>lock()</code> </dt> <dt class="sig sig-object py" id="mailbox.MH.unlock">
<code>unlock()</code> </dt> <dd>
<p>Three locking mechanisms are used—dot locking and, if available, the <code>flock()</code> and <code>lockf()</code> system calls. For MH mailboxes, locking the mailbox means locking the <code>.mh_sequences</code> file and, only for the duration of any operations that affect them, locking individual message files.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.get_file">
<code>get_file(key)</code> </dt> <dd>
<p>Depending upon the host platform, it may not be possible to remove the underlying message while the returned file remains open.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.flush">
<code>flush()</code> </dt> <dd>
<p>All changes to MH mailboxes are immediately applied, so this method does nothing.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MH.close">
<code>close()</code> </dt> <dd>
<p><code>MH</code> instances do not keep any open files, so this method is equivalent to <a class="reference internal" href="#mailbox.MH.unlock" title="mailbox.MH.unlock"><code>unlock()</code></a>.</p> </dd>
</dl> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://www.nongnu.org/nmh/">nmh - Message Handling System</a></dt>
<dd>
<p>Home page of <strong class="program">nmh</strong>, an updated version of the original <strong class="program">mh</strong>.</p> </dd> <dt><a class="reference external" href="https://rand-mh.sourceforge.io/book/">MH &amp; nmh: Email for Users &amp; Programmers</a></dt>
<dd>
<p>A GPL-licensed book on <strong class="program">mh</strong> and <strong class="program">nmh</strong>, with some information on the mailbox format.</p> </dd> </dl> </div> </section> <section id="babyl-objects"> <span id="mailbox-babyl"></span><h3>
<code>Babyl</code> objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.Babyl">
<code>class mailbox.Babyl(path, factory=None, create=True)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> for mailboxes in Babyl format. Parameter <em>factory</em> is a callable object that accepts a file-like message representation (which behaves as if opened in binary mode) and returns a custom representation. If <em>factory</em> is <code>None</code>, <a class="reference internal" href="#mailbox.BabylMessage" title="mailbox.BabylMessage"><code>BabylMessage</code></a> is used as the default message representation. If <em>create</em> is <code>True</code>, the mailbox is created if it does not exist.</p> <p>Babyl is a single-file mailbox format used by the Rmail mail user agent included with Emacs. The beginning of a message is indicated by a line containing the two characters Control-Underscore (<code>'\037'</code>) and Control-L (<code>'\014'</code>). The end of a message is indicated by the start of the next message or, in the case of the last message, a line containing a Control-Underscore (<code>'\037'</code>) character.</p> <p>Messages in a Babyl mailbox have two sets of headers, original headers and so-called visible headers. Visible headers are typically a subset of the original headers that have been reformatted or abridged to be more attractive. Each message in a Babyl mailbox also has an accompanying list of <em class="dfn">labels</em>, or short strings that record extra information about the message, and a list of all user-defined labels found in the mailbox is kept in the Babyl options section.</p> <p><code>Babyl</code> instances have all of the methods of <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> in addition to the following:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Babyl.get_labels">
<code>get_labels()</code> </dt> <dd>
<p>Return a list of the names of all user-defined labels used in the mailbox.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The actual messages are inspected to determine which labels exist in the mailbox rather than consulting the list of labels in the Babyl options section, but the Babyl section is updated whenever the mailbox is modified.</p> </div> </dd>
</dl> <p>Some <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> methods implemented by <code>Babyl</code> deserve special remarks:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Babyl.get_file">
<code>get_file(key)</code> </dt> <dd>
<p>In Babyl mailboxes, the headers of a message are not stored contiguously with the body of the message. To generate a file-like representation, the headers and body are copied together into an <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code>io.BytesIO</code></a> instance, which has an API identical to that of a file. As a result, the file-like object is truly independent of the underlying mailbox but does not save memory compared to a string representation.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.Babyl.lock">
<code>lock()</code> </dt> <dt class="sig sig-object py" id="mailbox.Babyl.unlock">
<code>unlock()</code> </dt> <dd>
<p>Three locking mechanisms are used—dot locking and, if available, the <code>flock()</code> and <code>lockf()</code> system calls.</p> </dd>
</dl> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://quimby.gnus.org/notes/BABYL">Format of Version 5 Babyl Files</a></dt>
<dd>
<p>A specification of the Babyl format.</p> </dd> <dt><a class="reference external" href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Rmail.html">Reading Mail with Rmail</a></dt>
<dd>
<p>The Rmail manual, with some information on Babyl semantics.</p> </dd> </dl> </div> </section> <section id="mmdf-objects"> <span id="mailbox-mmdf"></span><h3>
<code>MMDF</code> objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.MMDF">
<code>class mailbox.MMDF(path, factory=None, create=True)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> for mailboxes in MMDF format. Parameter <em>factory</em> is a callable object that accepts a file-like message representation (which behaves as if opened in binary mode) and returns a custom representation. If <em>factory</em> is <code>None</code>, <a class="reference internal" href="#mailbox.MMDFMessage" title="mailbox.MMDFMessage"><code>MMDFMessage</code></a> is used as the default message representation. If <em>create</em> is <code>True</code>, the mailbox is created if it does not exist.</p> <p>MMDF is a single-file mailbox format invented for the Multichannel Memorandum Distribution Facility, a mail transfer agent. Each message is in the same form as an mbox message but is bracketed before and after by lines containing four Control-A (<code>'\001'</code>) characters. As with the mbox format, the beginning of each message is indicated by a line whose first five characters are “From “, but additional occurrences of “From “ are not transformed to “&gt;From “ when storing messages because the extra message separator lines prevent mistaking such occurrences for the starts of subsequent messages.</p> <p>Some <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> methods implemented by <code>MMDF</code> deserve special remarks:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MMDF.get_file">
<code>get_file(key)</code> </dt> <dd>
<p>Using the file after calling <a class="reference internal" href="#mailbox.Mailbox.flush" title="mailbox.Mailbox.flush"><code>flush()</code></a> or <a class="reference internal" href="#mailbox.Mailbox.close" title="mailbox.Mailbox.close"><code>close()</code></a> on the <code>MMDF</code> instance may yield unpredictable results or raise an exception.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MMDF.lock">
<code>lock()</code> </dt> <dt class="sig sig-object py" id="mailbox.MMDF.unlock">
<code>unlock()</code> </dt> <dd>
<p>Three locking mechanisms are used—dot locking and, if available, the <code>flock()</code> and <code>lockf()</code> system calls.</p> </dd>
</dl> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="http://www.tin.org/bin/man.cgi?section=5&amp;topic=mmdf">mmdf man page from tin</a></dt>
<dd>
<p>A specification of MMDF format from the documentation of tin, a newsreader.</p> </dd> <dt><a class="reference external" href="https://en.wikipedia.org/wiki/MMDF">MMDF</a></dt>
<dd>
<p>A Wikipedia article describing the Multichannel Memorandum Distribution Facility.</p> </dd> </dl> </div> </section> </section> <section id="message-objects"> <span id="mailbox-message-objects"></span><h2>
<code>Message</code> objects</h2> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.Message">
<code>class mailbox.Message(message=None)</code> </dt> <dd>
<p>A subclass of the <a class="reference internal" href="email.message.html#module-email.message" title="email.message: The base class representing email messages."><code>email.message</code></a> module’s <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code>Message</code></a>. Subclasses of <code>mailbox.Message</code> add mailbox-format-specific state and behavior.</p> <p>If <em>message</em> is omitted, the new instance is created in a default, empty state. If <em>message</em> is an <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code>email.message.Message</code></a> instance, its contents are copied; furthermore, any format-specific information is converted insofar as possible if <em>message</em> is a <code>Message</code> instance. If <em>message</em> is a string, a byte string, or a file, it should contain an <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2822.html"><strong>RFC 2822</strong></a>-compliant message, which is read and parsed. Files should be open in binary mode, but text mode files are accepted for backward compatibility.</p> <p>The format-specific state and behaviors offered by subclasses vary, but in general it is only the properties that are not specific to a particular mailbox that are supported (although presumably the properties are specific to a particular mailbox format). For example, file offsets for single-file mailbox formats and file names for directory-based mailbox formats are not retained, because they are only applicable to the original mailbox. But state such as whether a message has been read by the user or marked as important is retained, because it applies to the message itself.</p> <p>There is no requirement that <code>Message</code> instances be used to represent messages retrieved using <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> instances. In some situations, the time and memory required to generate <code>Message</code> representations might not be acceptable. For such situations, <code>Mailbox</code> instances also offer string and file-like representations, and a custom message factory may be specified when a <code>Mailbox</code> instance is initialized.</p> </dd>
</dl> <section id="maildirmessage-objects"> <span id="mailbox-maildirmessage"></span><h3>
<code>MaildirMessage</code> objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.MaildirMessage">
<code>class mailbox.MaildirMessage(message=None)</code> </dt> <dd>
<p>A message with Maildir-specific behaviors. Parameter <em>message</em> has the same meaning as with the <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> constructor.</p> <p>Typically, a mail user agent application moves all of the messages in the <code>new</code> subdirectory to the <code>cur</code> subdirectory after the first time the user opens and closes the mailbox, recording that the messages are old whether or not they’ve actually been read. Each message in <code>cur</code> has an “info” section added to its file name to store information about its state. (Some mail readers may also add an “info” section to messages in <code>new</code>.) The “info” section may take one of two forms: it may contain “2,” followed by a list of standardized flags (e.g., “2,FR”) or it may contain “1,” followed by so-called experimental information. Standard flags for Maildir messages are as follows:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Flag</p></th> <th class="head"><p>Meaning</p></th> <th class="head"><p>Explanation</p></th> </tr> </thead>  <tr>
<td><p>D</p></td> <td><p>Draft</p></td> <td><p>Under composition</p></td> </tr> <tr>
<td><p>F</p></td> <td><p>Flagged</p></td> <td><p>Marked as important</p></td> </tr> <tr>
<td><p>P</p></td> <td><p>Passed</p></td> <td><p>Forwarded, resent, or bounced</p></td> </tr> <tr>
<td><p>R</p></td> <td><p>Replied</p></td> <td><p>Replied to</p></td> </tr> <tr>
<td><p>S</p></td> <td><p>Seen</p></td> <td><p>Read</p></td> </tr> <tr>
<td><p>T</p></td> <td><p>Trashed</p></td> <td><p>Marked for subsequent deletion</p></td> </tr>  </table> <p><code>MaildirMessage</code> instances offer the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MaildirMessage.get_subdir">
<code>get_subdir()</code> </dt> <dd>
<p>Return either “new” (if the message should be stored in the <code>new</code> subdirectory) or “cur” (if the message should be stored in the <code>cur</code> subdirectory).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>A message is typically moved from <code>new</code> to <code>cur</code> after its mailbox has been accessed, whether or not the message has been read. A message <code>msg</code> has been read if <code>"S" in msg.get_flags()</code> is <code>True</code>.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MaildirMessage.set_subdir">
<code>set_subdir(subdir)</code> </dt> <dd>
<p>Set the subdirectory the message should be stored in. Parameter <em>subdir</em> must be either “new” or “cur”.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MaildirMessage.get_flags">
<code>get_flags()</code> </dt> <dd>
<p>Return a string specifying the flags that are currently set. If the message complies with the standard Maildir format, the result is the concatenation in alphabetical order of zero or one occurrence of each of <code>'D'</code>, <code>'F'</code>, <code>'P'</code>, <code>'R'</code>, <code>'S'</code>, and <code>'T'</code>. The empty string is returned if no flags are set or if “info” contains experimental semantics.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MaildirMessage.set_flags">
<code>set_flags(flags)</code> </dt> <dd>
<p>Set the flags specified by <em>flags</em> and unset all others.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MaildirMessage.add_flag">
<code>add_flag(flag)</code> </dt> <dd>
<p>Set the flag(s) specified by <em>flag</em> without changing other flags. To add more than one flag at a time, <em>flag</em> may be a string of more than one character. The current “info” is overwritten whether or not it contains experimental information rather than flags.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MaildirMessage.remove_flag">
<code>remove_flag(flag)</code> </dt> <dd>
<p>Unset the flag(s) specified by <em>flag</em> without changing other flags. To remove more than one flag at a time, <em>flag</em> maybe a string of more than one character. If “info” contains experimental information rather than flags, the current “info” is not modified.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MaildirMessage.get_date">
<code>get_date()</code> </dt> <dd>
<p>Return the delivery date of the message as a floating-point number representing seconds since the epoch.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MaildirMessage.set_date">
<code>set_date(date)</code> </dt> <dd>
<p>Set the delivery date of the message to <em>date</em>, a floating-point number representing seconds since the epoch.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MaildirMessage.get_info">
<code>get_info()</code> </dt> <dd>
<p>Return a string containing the “info” for a message. This is useful for accessing and modifying “info” that is experimental (i.e., not a list of flags).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MaildirMessage.set_info">
<code>set_info(info)</code> </dt> <dd>
<p>Set “info” to <em>info</em>, which should be a string.</p> </dd>
</dl> </dd>
</dl> <p>When a <code>MaildirMessage</code> instance is created based upon an <a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> or <a class="reference internal" href="#mailbox.MMDFMessage" title="mailbox.MMDFMessage"><code>MMDFMessage</code></a> instance, the <em class="mailheader">Status</em> and <em class="mailheader">X-Status</em> headers are omitted and the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> or <a class="reference internal" href="#mailbox.MMDFMessage" title="mailbox.MMDFMessage"><code>MMDFMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>“cur” subdirectory</p></td> <td><p>O flag</p></td> </tr> <tr>
<td><p>F flag</p></td> <td><p>F flag</p></td> </tr> <tr>
<td><p>R flag</p></td> <td><p>A flag</p></td> </tr> <tr>
<td><p>S flag</p></td> <td><p>R flag</p></td> </tr> <tr>
<td><p>T flag</p></td> <td><p>D flag</p></td> </tr>  </table> <p>When a <code>MaildirMessage</code> instance is created based upon an <a class="reference internal" href="#mailbox.MHMessage" title="mailbox.MHMessage"><code>MHMessage</code></a> instance, the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.MHMessage" title="mailbox.MHMessage"><code>MHMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>“cur” subdirectory</p></td> <td><p>“unseen” sequence</p></td> </tr> <tr>
<td><p>“cur” subdirectory and S flag</p></td> <td><p>no “unseen” sequence</p></td> </tr> <tr>
<td><p>F flag</p></td> <td><p>“flagged” sequence</p></td> </tr> <tr>
<td><p>R flag</p></td> <td><p>“replied” sequence</p></td> </tr>  </table> <p>When a <code>MaildirMessage</code> instance is created based upon a <a class="reference internal" href="#mailbox.BabylMessage" title="mailbox.BabylMessage"><code>BabylMessage</code></a> instance, the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.BabylMessage" title="mailbox.BabylMessage"><code>BabylMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>“cur” subdirectory</p></td> <td><p>“unseen” label</p></td> </tr> <tr>
<td><p>“cur” subdirectory and S flag</p></td> <td><p>no “unseen” label</p></td> </tr> <tr>
<td><p>P flag</p></td> <td><p>“forwarded” or “resent” label</p></td> </tr> <tr>
<td><p>R flag</p></td> <td><p>“answered” label</p></td> </tr> <tr>
<td><p>T flag</p></td> <td><p>“deleted” label</p></td> </tr>  </table> </section> <section id="mboxmessage-objects"> <span id="mailbox-mboxmessage"></span><h3>
<code>mboxMessage</code> objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.mboxMessage">
<code>class mailbox.mboxMessage(message=None)</code> </dt> <dd>
<p>A message with mbox-specific behaviors. Parameter <em>message</em> has the same meaning as with the <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> constructor.</p> <p>Messages in an mbox mailbox are stored together in a single file. The sender’s envelope address and the time of delivery are typically stored in a line beginning with “From “ that is used to indicate the start of a message, though there is considerable variation in the exact format of this data among mbox implementations. Flags that indicate the state of the message, such as whether it has been read or marked as important, are typically stored in <em class="mailheader">Status</em> and <em class="mailheader">X-Status</em> headers.</p> <p>Conventional flags for mbox messages are as follows:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Flag</p></th> <th class="head"><p>Meaning</p></th> <th class="head"><p>Explanation</p></th> </tr> </thead>  <tr>
<td><p>R</p></td> <td><p>Read</p></td> <td><p>Read</p></td> </tr> <tr>
<td><p>O</p></td> <td><p>Old</p></td> <td><p>Previously detected by MUA</p></td> </tr> <tr>
<td><p>D</p></td> <td><p>Deleted</p></td> <td><p>Marked for subsequent deletion</p></td> </tr> <tr>
<td><p>F</p></td> <td><p>Flagged</p></td> <td><p>Marked as important</p></td> </tr> <tr>
<td><p>A</p></td> <td><p>Answered</p></td> <td><p>Replied to</p></td> </tr>  </table> <p>The “R” and “O” flags are stored in the <em class="mailheader">Status</em> header, and the “D”, “F”, and “A” flags are stored in the <em class="mailheader">X-Status</em> header. The flags and headers typically appear in the order mentioned.</p> <p><code>mboxMessage</code> instances offer the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.mboxMessage.get_from">
<code>get_from()</code> </dt> <dd>
<p>Return a string representing the “From “ line that marks the start of the message in an mbox mailbox. The leading “From “ and the trailing newline are excluded.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.mboxMessage.set_from">
<code>set_from(from_, time_=None)</code> </dt> <dd>
<p>Set the “From “ line to <em>from_</em>, which should be specified without a leading “From “ or trailing newline. For convenience, <em>time_</em> may be specified and will be formatted appropriately and appended to <em>from_</em>. If <em>time_</em> is specified, it should be a <a class="reference internal" href="time.html#time.struct_time" title="time.struct_time"><code>time.struct_time</code></a> instance, a tuple suitable for passing to <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code>time.strftime()</code></a>, or <code>True</code> (to use <a class="reference internal" href="time.html#time.gmtime" title="time.gmtime"><code>time.gmtime()</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.mboxMessage.get_flags">
<code>get_flags()</code> </dt> <dd>
<p>Return a string specifying the flags that are currently set. If the message complies with the conventional format, the result is the concatenation in the following order of zero or one occurrence of each of <code>'R'</code>, <code>'O'</code>, <code>'D'</code>, <code>'F'</code>, and <code>'A'</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.mboxMessage.set_flags">
<code>set_flags(flags)</code> </dt> <dd>
<p>Set the flags specified by <em>flags</em> and unset all others. Parameter <em>flags</em> should be the concatenation in any order of zero or more occurrences of each of <code>'R'</code>, <code>'O'</code>, <code>'D'</code>, <code>'F'</code>, and <code>'A'</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.mboxMessage.add_flag">
<code>add_flag(flag)</code> </dt> <dd>
<p>Set the flag(s) specified by <em>flag</em> without changing other flags. To add more than one flag at a time, <em>flag</em> may be a string of more than one character.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.mboxMessage.remove_flag">
<code>remove_flag(flag)</code> </dt> <dd>
<p>Unset the flag(s) specified by <em>flag</em> without changing other flags. To remove more than one flag at a time, <em>flag</em> maybe a string of more than one character.</p> </dd>
</dl> </dd>
</dl> <p>When an <code>mboxMessage</code> instance is created based upon a <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> instance, a “From “ line is generated based upon the <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> instance’s delivery date, and the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>R flag</p></td> <td><p>S flag</p></td> </tr> <tr>
<td><p>O flag</p></td> <td><p>“cur” subdirectory</p></td> </tr> <tr>
<td><p>D flag</p></td> <td><p>T flag</p></td> </tr> <tr>
<td><p>F flag</p></td> <td><p>F flag</p></td> </tr> <tr>
<td><p>A flag</p></td> <td><p>R flag</p></td> </tr>  </table> <p>When an <code>mboxMessage</code> instance is created based upon an <a class="reference internal" href="#mailbox.MHMessage" title="mailbox.MHMessage"><code>MHMessage</code></a> instance, the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.MHMessage" title="mailbox.MHMessage"><code>MHMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>R flag and O flag</p></td> <td><p>no “unseen” sequence</p></td> </tr> <tr>
<td><p>O flag</p></td> <td><p>“unseen” sequence</p></td> </tr> <tr>
<td><p>F flag</p></td> <td><p>“flagged” sequence</p></td> </tr> <tr>
<td><p>A flag</p></td> <td><p>“replied” sequence</p></td> </tr>  </table> <p>When an <code>mboxMessage</code> instance is created based upon a <a class="reference internal" href="#mailbox.BabylMessage" title="mailbox.BabylMessage"><code>BabylMessage</code></a> instance, the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.BabylMessage" title="mailbox.BabylMessage"><code>BabylMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>R flag and O flag</p></td> <td><p>no “unseen” label</p></td> </tr> <tr>
<td><p>O flag</p></td> <td><p>“unseen” label</p></td> </tr> <tr>
<td><p>D flag</p></td> <td><p>“deleted” label</p></td> </tr> <tr>
<td><p>A flag</p></td> <td><p>“answered” label</p></td> </tr>  </table> <p>When a <code>mboxMessage</code> instance is created based upon an <a class="reference internal" href="#mailbox.MMDFMessage" title="mailbox.MMDFMessage"><code>MMDFMessage</code></a> instance, the “From “ line is copied and all flags directly correspond:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.MMDFMessage" title="mailbox.MMDFMessage"><code>MMDFMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>R flag</p></td> <td><p>R flag</p></td> </tr> <tr>
<td><p>O flag</p></td> <td><p>O flag</p></td> </tr> <tr>
<td><p>D flag</p></td> <td><p>D flag</p></td> </tr> <tr>
<td><p>F flag</p></td> <td><p>F flag</p></td> </tr> <tr>
<td><p>A flag</p></td> <td><p>A flag</p></td> </tr>  </table> </section> <section id="mhmessage-objects"> <span id="mailbox-mhmessage"></span><h3>
<code>MHMessage</code> objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.MHMessage">
<code>class mailbox.MHMessage(message=None)</code> </dt> <dd>
<p>A message with MH-specific behaviors. Parameter <em>message</em> has the same meaning as with the <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> constructor.</p> <p>MH messages do not support marks or flags in the traditional sense, but they do support sequences, which are logical groupings of arbitrary messages. Some mail reading programs (although not the standard <strong class="program">mh</strong> and <strong class="program">nmh</strong>) use sequences in much the same way flags are used with other formats, as follows:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Sequence</p></th> <th class="head"><p>Explanation</p></th> </tr> </thead>  <tr>
<td><p>unseen</p></td> <td><p>Not read, but previously detected by MUA</p></td> </tr> <tr>
<td><p>replied</p></td> <td><p>Replied to</p></td> </tr> <tr>
<td><p>flagged</p></td> <td><p>Marked as important</p></td> </tr>  </table> <p><code>MHMessage</code> instances offer the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MHMessage.get_sequences">
<code>get_sequences()</code> </dt> <dd>
<p>Return a list of the names of sequences that include this message.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MHMessage.set_sequences">
<code>set_sequences(sequences)</code> </dt> <dd>
<p>Set the list of sequences that include this message.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MHMessage.add_sequence">
<code>add_sequence(sequence)</code> </dt> <dd>
<p>Add <em>sequence</em> to the list of sequences that include this message.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MHMessage.remove_sequence">
<code>remove_sequence(sequence)</code> </dt> <dd>
<p>Remove <em>sequence</em> from the list of sequences that include this message.</p> </dd>
</dl> </dd>
</dl> <p>When an <code>MHMessage</code> instance is created based upon a <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> instance, the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>“unseen” sequence</p></td> <td><p>no S flag</p></td> </tr> <tr>
<td><p>“replied” sequence</p></td> <td><p>R flag</p></td> </tr> <tr>
<td><p>“flagged” sequence</p></td> <td><p>F flag</p></td> </tr>  </table> <p>When an <code>MHMessage</code> instance is created based upon an <a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> or <a class="reference internal" href="#mailbox.MMDFMessage" title="mailbox.MMDFMessage"><code>MMDFMessage</code></a> instance, the <em class="mailheader">Status</em> and <em class="mailheader">X-Status</em> headers are omitted and the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> or <a class="reference internal" href="#mailbox.MMDFMessage" title="mailbox.MMDFMessage"><code>MMDFMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>“unseen” sequence</p></td> <td><p>no R flag</p></td> </tr> <tr>
<td><p>“replied” sequence</p></td> <td><p>A flag</p></td> </tr> <tr>
<td><p>“flagged” sequence</p></td> <td><p>F flag</p></td> </tr>  </table> <p>When an <code>MHMessage</code> instance is created based upon a <a class="reference internal" href="#mailbox.BabylMessage" title="mailbox.BabylMessage"><code>BabylMessage</code></a> instance, the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.BabylMessage" title="mailbox.BabylMessage"><code>BabylMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>“unseen” sequence</p></td> <td><p>“unseen” label</p></td> </tr> <tr>
<td><p>“replied” sequence</p></td> <td><p>“answered” label</p></td> </tr>  </table> </section> <section id="babylmessage-objects"> <span id="mailbox-babylmessage"></span><h3>
<code>BabylMessage</code> objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.BabylMessage">
<code>class mailbox.BabylMessage(message=None)</code> </dt> <dd>
<p>A message with Babyl-specific behaviors. Parameter <em>message</em> has the same meaning as with the <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> constructor.</p> <p>Certain message labels, called <em class="dfn">attributes</em>, are defined by convention to have special meanings. The attributes are as follows:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Label</p></th> <th class="head"><p>Explanation</p></th> </tr> </thead>  <tr>
<td><p>unseen</p></td> <td><p>Not read, but previously detected by MUA</p></td> </tr> <tr>
<td><p>deleted</p></td> <td><p>Marked for subsequent deletion</p></td> </tr> <tr>
<td><p>filed</p></td> <td><p>Copied to another file or mailbox</p></td> </tr> <tr>
<td><p>answered</p></td> <td><p>Replied to</p></td> </tr> <tr>
<td><p>forwarded</p></td> <td><p>Forwarded</p></td> </tr> <tr>
<td><p>edited</p></td> <td><p>Modified by the user</p></td> </tr> <tr>
<td><p>resent</p></td> <td><p>Resent</p></td> </tr>  </table> <p>By default, Rmail displays only visible headers. The <code>BabylMessage</code> class, though, uses the original headers because they are more complete. Visible headers may be accessed explicitly if desired.</p> <p><code>BabylMessage</code> instances offer the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.BabylMessage.get_labels">
<code>get_labels()</code> </dt> <dd>
<p>Return a list of labels on the message.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.BabylMessage.set_labels">
<code>set_labels(labels)</code> </dt> <dd>
<p>Set the list of labels on the message to <em>labels</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.BabylMessage.add_label">
<code>add_label(label)</code> </dt> <dd>
<p>Add <em>label</em> to the list of labels on the message.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.BabylMessage.remove_label">
<code>remove_label(label)</code> </dt> <dd>
<p>Remove <em>label</em> from the list of labels on the message.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.BabylMessage.get_visible">
<code>get_visible()</code> </dt> <dd>
<p>Return a <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> instance whose headers are the message’s visible headers and whose body is empty.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.BabylMessage.set_visible">
<code>set_visible(visible)</code> </dt> <dd>
<p>Set the message’s visible headers to be the same as the headers in <em>message</em>. Parameter <em>visible</em> should be a <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> instance, an <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code>email.message.Message</code></a> instance, a string, or a file-like object (which should be open in text mode).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.BabylMessage.update_visible">
<code>update_visible()</code> </dt> <dd>
<p>When a <code>BabylMessage</code> instance’s original headers are modified, the visible headers are not automatically modified to correspond. This method updates the visible headers as follows: each visible header with a corresponding original header is set to the value of the original header, each visible header without a corresponding original header is removed, and any of <em class="mailheader">Date</em>, <em class="mailheader">From</em>, <em class="mailheader">Reply-To</em>, <em class="mailheader">To</em>, <em class="mailheader">CC</em>, and <em class="mailheader">Subject</em> that are present in the original headers but not the visible headers are added to the visible headers.</p> </dd>
</dl> </dd>
</dl> <p>When a <code>BabylMessage</code> instance is created based upon a <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> instance, the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>“unseen” label</p></td> <td><p>no S flag</p></td> </tr> <tr>
<td><p>“deleted” label</p></td> <td><p>T flag</p></td> </tr> <tr>
<td><p>“answered” label</p></td> <td><p>R flag</p></td> </tr> <tr>
<td><p>“forwarded” label</p></td> <td><p>P flag</p></td> </tr>  </table> <p>When a <code>BabylMessage</code> instance is created based upon an <a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> or <a class="reference internal" href="#mailbox.MMDFMessage" title="mailbox.MMDFMessage"><code>MMDFMessage</code></a> instance, the <em class="mailheader">Status</em> and <em class="mailheader">X-Status</em> headers are omitted and the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> or <a class="reference internal" href="#mailbox.MMDFMessage" title="mailbox.MMDFMessage"><code>MMDFMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>“unseen” label</p></td> <td><p>no R flag</p></td> </tr> <tr>
<td><p>“deleted” label</p></td> <td><p>D flag</p></td> </tr> <tr>
<td><p>“answered” label</p></td> <td><p>A flag</p></td> </tr>  </table> <p>When a <code>BabylMessage</code> instance is created based upon an <a class="reference internal" href="#mailbox.MHMessage" title="mailbox.MHMessage"><code>MHMessage</code></a> instance, the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.MHMessage" title="mailbox.MHMessage"><code>MHMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>“unseen” label</p></td> <td><p>“unseen” sequence</p></td> </tr> <tr>
<td><p>“answered” label</p></td> <td><p>“replied” sequence</p></td> </tr>  </table> </section> <section id="mmdfmessage-objects"> <span id="mailbox-mmdfmessage"></span><h3>
<code>MMDFMessage</code> objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="mailbox.MMDFMessage">
<code>class mailbox.MMDFMessage(message=None)</code> </dt> <dd>
<p>A message with MMDF-specific behaviors. Parameter <em>message</em> has the same meaning as with the <a class="reference internal" href="#mailbox.Message" title="mailbox.Message"><code>Message</code></a> constructor.</p> <p>As with message in an mbox mailbox, MMDF messages are stored with the sender’s address and the delivery date in an initial line beginning with “From “. Likewise, flags that indicate the state of the message are typically stored in <em class="mailheader">Status</em> and <em class="mailheader">X-Status</em> headers.</p> <p>Conventional flags for MMDF messages are identical to those of mbox message and are as follows:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Flag</p></th> <th class="head"><p>Meaning</p></th> <th class="head"><p>Explanation</p></th> </tr> </thead>  <tr>
<td><p>R</p></td> <td><p>Read</p></td> <td><p>Read</p></td> </tr> <tr>
<td><p>O</p></td> <td><p>Old</p></td> <td><p>Previously detected by MUA</p></td> </tr> <tr>
<td><p>D</p></td> <td><p>Deleted</p></td> <td><p>Marked for subsequent deletion</p></td> </tr> <tr>
<td><p>F</p></td> <td><p>Flagged</p></td> <td><p>Marked as important</p></td> </tr> <tr>
<td><p>A</p></td> <td><p>Answered</p></td> <td><p>Replied to</p></td> </tr>  </table> <p>The “R” and “O” flags are stored in the <em class="mailheader">Status</em> header, and the “D”, “F”, and “A” flags are stored in the <em class="mailheader">X-Status</em> header. The flags and headers typically appear in the order mentioned.</p> <p><code>MMDFMessage</code> instances offer the following methods, which are identical to those offered by <a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a>:</p> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MMDFMessage.get_from">
<code>get_from()</code> </dt> <dd>
<p>Return a string representing the “From “ line that marks the start of the message in an mbox mailbox. The leading “From “ and the trailing newline are excluded.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MMDFMessage.set_from">
<code>set_from(from_, time_=None)</code> </dt> <dd>
<p>Set the “From “ line to <em>from_</em>, which should be specified without a leading “From “ or trailing newline. For convenience, <em>time_</em> may be specified and will be formatted appropriately and appended to <em>from_</em>. If <em>time_</em> is specified, it should be a <a class="reference internal" href="time.html#time.struct_time" title="time.struct_time"><code>time.struct_time</code></a> instance, a tuple suitable for passing to <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code>time.strftime()</code></a>, or <code>True</code> (to use <a class="reference internal" href="time.html#time.gmtime" title="time.gmtime"><code>time.gmtime()</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MMDFMessage.get_flags">
<code>get_flags()</code> </dt> <dd>
<p>Return a string specifying the flags that are currently set. If the message complies with the conventional format, the result is the concatenation in the following order of zero or one occurrence of each of <code>'R'</code>, <code>'O'</code>, <code>'D'</code>, <code>'F'</code>, and <code>'A'</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MMDFMessage.set_flags">
<code>set_flags(flags)</code> </dt> <dd>
<p>Set the flags specified by <em>flags</em> and unset all others. Parameter <em>flags</em> should be the concatenation in any order of zero or more occurrences of each of <code>'R'</code>, <code>'O'</code>, <code>'D'</code>, <code>'F'</code>, and <code>'A'</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MMDFMessage.add_flag">
<code>add_flag(flag)</code> </dt> <dd>
<p>Set the flag(s) specified by <em>flag</em> without changing other flags. To add more than one flag at a time, <em>flag</em> may be a string of more than one character.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="mailbox.MMDFMessage.remove_flag">
<code>remove_flag(flag)</code> </dt> <dd>
<p>Unset the flag(s) specified by <em>flag</em> without changing other flags. To remove more than one flag at a time, <em>flag</em> maybe a string of more than one character.</p> </dd>
</dl> </dd>
</dl> <p>When an <code>MMDFMessage</code> instance is created based upon a <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> instance, a “From “ line is generated based upon the <a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> instance’s delivery date, and the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.MaildirMessage" title="mailbox.MaildirMessage"><code>MaildirMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>R flag</p></td> <td><p>S flag</p></td> </tr> <tr>
<td><p>O flag</p></td> <td><p>“cur” subdirectory</p></td> </tr> <tr>
<td><p>D flag</p></td> <td><p>T flag</p></td> </tr> <tr>
<td><p>F flag</p></td> <td><p>F flag</p></td> </tr> <tr>
<td><p>A flag</p></td> <td><p>R flag</p></td> </tr>  </table> <p>When an <code>MMDFMessage</code> instance is created based upon an <a class="reference internal" href="#mailbox.MHMessage" title="mailbox.MHMessage"><code>MHMessage</code></a> instance, the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.MHMessage" title="mailbox.MHMessage"><code>MHMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>R flag and O flag</p></td> <td><p>no “unseen” sequence</p></td> </tr> <tr>
<td><p>O flag</p></td> <td><p>“unseen” sequence</p></td> </tr> <tr>
<td><p>F flag</p></td> <td><p>“flagged” sequence</p></td> </tr> <tr>
<td><p>A flag</p></td> <td><p>“replied” sequence</p></td> </tr>  </table> <p>When an <code>MMDFMessage</code> instance is created based upon a <a class="reference internal" href="#mailbox.BabylMessage" title="mailbox.BabylMessage"><code>BabylMessage</code></a> instance, the following conversions take place:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.BabylMessage" title="mailbox.BabylMessage"><code>BabylMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>R flag and O flag</p></td> <td><p>no “unseen” label</p></td> </tr> <tr>
<td><p>O flag</p></td> <td><p>“unseen” label</p></td> </tr> <tr>
<td><p>D flag</p></td> <td><p>“deleted” label</p></td> </tr> <tr>
<td><p>A flag</p></td> <td><p>“answered” label</p></td> </tr>  </table> <p>When an <code>MMDFMessage</code> instance is created based upon an <a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> instance, the “From “ line is copied and all flags directly correspond:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Resulting state</p></th> <th class="head"><p><a class="reference internal" href="#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> state</p></th> </tr> </thead>  <tr>
<td><p>R flag</p></td> <td><p>R flag</p></td> </tr> <tr>
<td><p>O flag</p></td> <td><p>O flag</p></td> </tr> <tr>
<td><p>D flag</p></td> <td><p>D flag</p></td> </tr> <tr>
<td><p>F flag</p></td> <td><p>F flag</p></td> </tr> <tr>
<td><p>A flag</p></td> <td><p>A flag</p></td> </tr>  </table> </section> </section> <section id="exceptions"> <h2>Exceptions</h2> <p>The following exception classes are defined in the <code>mailbox</code> module:</p> <dl class="py exception"> <dt class="sig sig-object py" id="mailbox.Error">
<code>exception mailbox.Error</code> </dt> <dd>
<p>The based class for all other module-specific exceptions.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="mailbox.NoSuchMailboxError">
<code>exception mailbox.NoSuchMailboxError</code> </dt> <dd>
<p>Raised when a mailbox is expected but is not found, such as when instantiating a <a class="reference internal" href="#mailbox.Mailbox" title="mailbox.Mailbox"><code>Mailbox</code></a> subclass with a path that does not exist (and with the <em>create</em> parameter set to <code>False</code>), or when opening a folder that does not exist.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="mailbox.NotEmptyError">
<code>exception mailbox.NotEmptyError</code> </dt> <dd>
<p>Raised when a mailbox is not empty but is expected to be, such as when deleting a folder that contains messages.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="mailbox.ExternalClashError">
<code>exception mailbox.ExternalClashError</code> </dt> <dd>
<p>Raised when some mailbox-related condition beyond the control of the program causes it to be unable to proceed, such as when failing to acquire a lock that another program already holds a lock, or when a uniquely generated file name already exists.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="mailbox.FormatError">
<code>exception mailbox.FormatError</code> </dt> <dd>
<p>Raised when the data in a file cannot be parsed, such as when an <a class="reference internal" href="#mailbox.MH" title="mailbox.MH"><code>MH</code></a> instance attempts to read a corrupted <code>.mh_sequences</code> file.</p> </dd>
</dl> </section> <section id="examples"> <span id="mailbox-examples"></span><h2>Examples</h2> <p>A simple example of printing the subjects of all messages in a mailbox that seem interesting:</p> <pre data-language="python">import mailbox
for message in mailbox.mbox('~/mbox'):
    subject = message['subject']       # Could possibly be None.
    if subject and 'python' in subject.lower():
        print(subject)
</pre> <p>To copy all mail from a Babyl mailbox to an MH mailbox, converting all of the format-specific information that can be converted:</p> <pre data-language="python">import mailbox
destination = mailbox.MH('~/Mail')
destination.lock()
for message in mailbox.Babyl('~/RMAIL'):
    destination.add(mailbox.MHMessage(message))
destination.flush()
destination.unlock()
</pre> <p>This example sorts mail from several mailing lists into different mailboxes, being careful to avoid mail corruption due to concurrent modification by other programs, mail loss due to interruption of the program, or premature termination due to malformed messages in the mailbox:</p> <pre data-language="python">import mailbox
import email.errors

list_names = ('python-list', 'python-dev', 'python-bugs')

boxes = {name: mailbox.mbox('~/email/%s' % name) for name in list_names}
inbox = mailbox.Maildir('~/Maildir', factory=None)

for key in inbox.iterkeys():
    try:
        message = inbox[key]
    except email.errors.MessageParseError:
        continue                # The message is malformed. Just leave it.

    for name in list_names:
        list_id = message['list-id']
        if list_id and name in list_id:
            # Get mailbox to use
            box = boxes[name]

            # Write copy to disk before removing original.
            # If there's a crash, you might duplicate a message, but
            # that's better than losing a message completely.
            box.lock()
            box.add(message)
            box.flush()
            box.unlock()

            # Remove original message
            inbox.lock()
            inbox.discard(key)
            inbox.flush()
            inbox.unlock()
            break               # Found destination, so stop looking.

for box in boxes.itervalues():
    box.close()
</pre> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/mailbox.html" class="_attribution-link">https://docs.python.org/3.13/library/mailbox.html</a>
  </p>
</div>
