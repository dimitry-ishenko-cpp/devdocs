 <span id="tkinter-ttk-tk-themed-widgets"></span><h1>tkinter.ttk — Tk themed widgets</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/tkinter/ttk.py">Lib/tkinter/ttk.py</a></p>  <p>The <a class="reference internal" href="#module-tkinter.ttk" title="tkinter.ttk: Tk themed widget set"><code>tkinter.ttk</code></a> module provides access to the Tk themed widget set, introduced in Tk 8.5. It provides additional benefits including anti-aliased font rendering under X11 and window transparency (requiring a composition window manager on X11).</p> <p>The basic idea for <a class="reference internal" href="#module-tkinter.ttk" title="tkinter.ttk: Tk themed widget set"><code>tkinter.ttk</code></a> is to separate, to the extent possible, the code implementing a widget’s behavior from the code implementing its appearance.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://core.tcl.tk/tips/doc/trunk/tip/48.md">Tk Widget Styling Support</a></dt>
<dd>
<p>A document introducing theming support for Tk</p> </dd> </dl> </div> <section id="using-ttk"> <h2>Using Ttk</h2> <p>To start using Ttk, import its module:</p> <pre data-language="python">from tkinter import ttk
</pre> <p>To override the basic Tk widgets, the import should follow the Tk import:</p> <pre data-language="python">from tkinter import *
from tkinter.ttk import *
</pre> <p>That code causes several <a class="reference internal" href="#module-tkinter.ttk" title="tkinter.ttk: Tk themed widget set"><code>tkinter.ttk</code></a> widgets (<code>Button</code>, <code>Checkbutton</code>, <code>Entry</code>, <code>Frame</code>, <code>Label</code>, <code>LabelFrame</code>, <code>Menubutton</code>, <code>PanedWindow</code>, <code>Radiobutton</code>, <code>Scale</code> and <code>Scrollbar</code>) to automatically replace the Tk widgets.</p> <p>This has the direct benefit of using the new widgets which gives a better look and feel across platforms; however, the replacement widgets are not completely compatible. The main difference is that widget options such as “fg”, “bg” and others related to widget styling are no longer present in Ttk widgets. Instead, use the <code>ttk.Style</code> class for improved styling effects.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://tktable.sourceforge.net/tile/doc/converting.txt">Converting existing applications to use Tile widgets</a></dt>
<dd>
<p>A monograph (using Tcl terminology) about differences typically encountered when moving applications to use the new widgets.</p> </dd> </dl> </div> </section> <section id="ttk-widgets"> <h2>Ttk Widgets</h2> <p>Ttk comes with 18 widgets, twelve of which already existed in tkinter: <code>Button</code>, <code>Checkbutton</code>, <code>Entry</code>, <code>Frame</code>, <code>Label</code>, <code>LabelFrame</code>, <code>Menubutton</code>, <code>PanedWindow</code>, <code>Radiobutton</code>, <code>Scale</code>, <code>Scrollbar</code>, and <a class="reference internal" href="#tkinter.ttk.Spinbox" title="tkinter.ttk.Spinbox"><code>Spinbox</code></a>. The other six are new: <a class="reference internal" href="#tkinter.ttk.Combobox" title="tkinter.ttk.Combobox"><code>Combobox</code></a>, <a class="reference internal" href="#tkinter.ttk.Notebook" title="tkinter.ttk.Notebook"><code>Notebook</code></a>, <a class="reference internal" href="#tkinter.ttk.Progressbar" title="tkinter.ttk.Progressbar"><code>Progressbar</code></a>, <code>Separator</code>, <code>Sizegrip</code> and <a class="reference internal" href="#tkinter.ttk.Treeview" title="tkinter.ttk.Treeview"><code>Treeview</code></a>. And all them are subclasses of <a class="reference internal" href="#tkinter.ttk.Widget" title="tkinter.ttk.Widget"><code>Widget</code></a>.</p> <p>Using the Ttk widgets gives the application an improved look and feel. As discussed above, there are differences in how the styling is coded.</p> <p>Tk code:</p> <pre data-language="python">l1 = tkinter.Label(text="Test", fg="black", bg="white")
l2 = tkinter.Label(text="Test", fg="black", bg="white")
</pre> <p>Ttk code:</p> <pre data-language="python">style = ttk.Style()
style.configure("BW.TLabel", foreground="black", background="white")

l1 = ttk.Label(text="Test", style="BW.TLabel")
l2 = ttk.Label(text="Test", style="BW.TLabel")
</pre> <p>For more information about <a class="reference internal" href="#ttkstyling">TtkStyling</a>, see the <a class="reference internal" href="#tkinter.ttk.Style" title="tkinter.ttk.Style"><code>Style</code></a> class documentation.</p> </section> <section id="widget"> <h2>Widget</h2> <p><code>ttk.Widget</code> defines standard options and methods supported by Tk themed widgets and is not supposed to be directly instantiated.</p> <section id="standard-options"> <h3>Standard Options</h3> <p>All the <code>ttk</code> Widgets accept the following options:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>class</p></td> <td><p>Specifies the window class. The class is used when querying the option database for the window’s other options, to determine the default bindtags for the window, and to select the widget’s default layout and style. This option is read-only, and may only be specified when the window is created.</p></td> </tr> <tr>
<td><p>cursor</p></td> <td><p>Specifies the mouse cursor to be used for the widget. If set to the empty string (the default), the cursor is inherited for the parent widget.</p></td> </tr> <tr>
<td><p>takefocus</p></td> <td><p>Determines whether the window accepts the focus during keyboard traversal. 0, 1 or an empty string is returned. If 0 is returned, it means that the window should be skipped entirely during keyboard traversal. If 1, it means that the window should receive the input focus as long as it is viewable. And an empty string means that the traversal scripts make the decision about whether or not to focus on the window.</p></td> </tr> <tr>
<td><p>style</p></td> <td><p>May be used to specify a custom widget style.</p></td> </tr>  </table> </section> <section id="scrollable-widget-options"> <h3>Scrollable Widget Options</h3> <p>The following options are supported by widgets that are controlled by a scrollbar.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>xscrollcommand</p></td> <td>
<p>Used to communicate with horizontal scrollbars.</p> <p>When the view in the widget’s window change, the widget will generate a Tcl command based on the scrollcommand.</p> <p>Usually this option consists of the method <code>Scrollbar.set()</code> of some scrollbar. This will cause the scrollbar to be updated whenever the view in the window changes.</p> </td> </tr> <tr>
<td><p>yscrollcommand</p></td> <td><p>Used to communicate with vertical scrollbars. For some more information, see above.</p></td> </tr>  </table> </section> <section id="label-options"> <h3>Label Options</h3> <p>The following options are supported by labels, buttons and other button-like widgets.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>text</p></td> <td><p>Specifies a text string to be displayed inside the widget.</p></td> </tr> <tr>
<td><p>textvariable</p></td> <td><p>Specifies a name whose value will be used in place of the text option resource.</p></td> </tr> <tr>
<td><p>underline</p></td> <td><p>If set, specifies the index (0-based) of a character to underline in the text string. The underline character is used for mnemonic activation.</p></td> </tr> <tr>
<td><p>image</p></td> <td><p>Specifies an image to display. This is a list of 1 or more elements. The first element is the default image name. The rest of the list if a sequence of statespec/value pairs as defined by <a class="reference internal" href="#tkinter.ttk.Style.map" title="tkinter.ttk.Style.map"><code>Style.map()</code></a>, specifying different images to use when the widget is in a particular state or a combination of states. All images in the list should have the same size.</p></td> </tr> <tr>
<td><p>compound</p></td> <td>
<p>Specifies how to display the image relative to the text, in the case both text and images options are present. Valid values are:</p> <ul class="simple"> <li>text: display text only</li> <li>image: display image only</li> <li>top, bottom, left, right: display image above, below, left of, or right of the text, respectively.</li> <li>none: the default. display the image if present, otherwise the text.</li> </ul> </td> </tr> <tr>
<td><p>width</p></td> <td><p>If greater than zero, specifies how much space, in character widths, to allocate for the text label, if less than zero, specifies a minimum width. If zero or unspecified, the natural width of the text label is used.</p></td> </tr>  </table> </section> <section id="compatibility-options"> <h3>Compatibility Options</h3> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>state</p></td> <td><p>May be set to “normal” or “disabled” to control the “disabled” state bit. This is a write-only option: setting it changes the widget state, but the <a class="reference internal" href="#tkinter.ttk.Widget.state" title="tkinter.ttk.Widget.state"><code>Widget.state()</code></a> method does not affect this option.</p></td> </tr>  </table> </section> <section id="widget-states"> <h3>Widget States</h3> <p>The widget state is a bitmap of independent state flags.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Flag</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>active</p></td> <td><p>The mouse cursor is over the widget and pressing a mouse button will cause some action to occur</p></td> </tr> <tr>
<td><p>disabled</p></td> <td><p>Widget is disabled under program control</p></td> </tr> <tr>
<td><p>focus</p></td> <td><p>Widget has keyboard focus</p></td> </tr> <tr>
<td><p>pressed</p></td> <td><p>Widget is being pressed</p></td> </tr> <tr>
<td><p>selected</p></td> <td><p>“On”, “true”, or “current” for things like Checkbuttons and radiobuttons</p></td> </tr> <tr>
<td><p>background</p></td> <td><p>Windows and Mac have a notion of an “active” or foreground window. The <em>background</em> state is set for widgets in a background window, and cleared for those in the foreground window</p></td> </tr> <tr>
<td><p>readonly</p></td> <td><p>Widget should not allow user modification</p></td> </tr> <tr>
<td><p>alternate</p></td> <td><p>A widget-specific alternate display format</p></td> </tr> <tr>
<td><p>invalid</p></td> <td><p>The widget’s value is invalid</p></td> </tr>  </table> <p>A state specification is a sequence of state names, optionally prefixed with an exclamation point indicating that the bit is off.</p> </section> <section id="ttk-widget"> <h3>ttk.Widget</h3> <p>Besides the methods described below, the <code>ttk.Widget</code> supports the methods <code>tkinter.Widget.cget()</code> and <code>tkinter.Widget.configure()</code>.</p> <dl class="py class"> <dt class="sig sig-object py" id="tkinter.ttk.Widget">
<code>class tkinter.ttk.Widget</code> </dt> <dd>
<dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Widget.identify">
<code>identify(x, y)</code> </dt> <dd>
<p>Returns the name of the element at position <em>x</em> <em>y</em>, or the empty string if the point does not lie within any element.</p> <p><em>x</em> and <em>y</em> are pixel coordinates relative to the widget.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Widget.instate">
<code>instate(statespec, callback=None, *args, **kw)</code> </dt> <dd>
<p>Test the widget’s state. If a callback is not specified, returns <code>True</code> if the widget state matches <em>statespec</em> and <code>False</code> otherwise. If callback is specified then it is called with args if widget state matches <em>statespec</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Widget.state">
<code>state(statespec=None)</code> </dt> <dd>
<p>Modify or inquire widget state. If <em>statespec</em> is specified, sets the widget state according to it and return a new <em>statespec</em> indicating which flags were changed. If <em>statespec</em> is not specified, returns the currently enabled state flags.</p> </dd>
</dl> <p><em>statespec</em> will usually be a list or a tuple.</p> </dd>
</dl> </section> </section> <section id="combobox"> <h2>Combobox</h2> <p>The <code>ttk.Combobox</code> widget combines a text field with a pop-down list of values. This widget is a subclass of <code>Entry</code>.</p> <p>Besides the methods inherited from <a class="reference internal" href="#tkinter.ttk.Widget" title="tkinter.ttk.Widget"><code>Widget</code></a>: <code>Widget.cget()</code>, <code>Widget.configure()</code>, <a class="reference internal" href="#tkinter.ttk.Widget.identify" title="tkinter.ttk.Widget.identify"><code>Widget.identify()</code></a>, <a class="reference internal" href="#tkinter.ttk.Widget.instate" title="tkinter.ttk.Widget.instate"><code>Widget.instate()</code></a> and <a class="reference internal" href="#tkinter.ttk.Widget.state" title="tkinter.ttk.Widget.state"><code>Widget.state()</code></a>, and the following inherited from <code>Entry</code>: <code>Entry.bbox()</code>, <code>Entry.delete()</code>, <code>Entry.icursor()</code>, <code>Entry.index()</code>, <code>Entry.insert()</code>, <code>Entry.selection()</code>, <code>Entry.xview()</code>, it has some other methods, described at <code>ttk.Combobox</code>.</p> <section id="options"> <h3>Options</h3> <p>This widget accepts the following specific options:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>exportselection</p></td> <td><p>Boolean value. If set, the widget selection is linked to the Window Manager selection (which can be returned by invoking Misc.selection_get, for example).</p></td> </tr> <tr>
<td><p>justify</p></td> <td><p>Specifies how the text is aligned within the widget. One of “left”, “center”, or “right”.</p></td> </tr> <tr>
<td><p>height</p></td> <td><p>Specifies the height of the pop-down listbox, in rows.</p></td> </tr> <tr>
<td><p>postcommand</p></td> <td><p>A script (possibly registered with Misc.register) that is called immediately before displaying the values. It may specify which values to display.</p></td> </tr> <tr>
<td><p>state</p></td> <td><p>One of “normal”, “readonly”, or “disabled”. In the “readonly” state, the value may not be edited directly, and the user can only selection of the values from the dropdown list. In the “normal” state, the text field is directly editable. In the “disabled” state, no interaction is possible.</p></td> </tr> <tr>
<td><p>textvariable</p></td> <td><p>Specifies a name whose value is linked to the widget value. Whenever the value associated with that name changes, the widget value is updated, and vice versa. See <code>tkinter.StringVar</code>.</p></td> </tr> <tr>
<td><p>values</p></td> <td><p>Specifies the list of values to display in the drop-down listbox.</p></td> </tr> <tr>
<td><p>width</p></td> <td><p>Specifies an integer value indicating the desired width of the entry window, in average-size characters of the widget’s font.</p></td> </tr>  </table> </section> <section id="virtual-events"> <h3>Virtual events</h3> <p>The combobox widgets generates a <strong>&lt;&lt;ComboboxSelected&gt;&gt;</strong> virtual event when the user selects an element from the list of values.</p> </section> <section id="ttk-combobox"> <h3>ttk.Combobox</h3> <dl class="py class"> <dt class="sig sig-object py" id="tkinter.ttk.Combobox">
<code>class tkinter.ttk.Combobox</code> </dt> <dd>
<dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Combobox.current">
<code>current(newindex=None)</code> </dt> <dd>
<p>If <em>newindex</em> is specified, sets the combobox value to the element position <em>newindex</em>. Otherwise, returns the index of the current value or -1 if the current value is not in the values list.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Combobox.get">
<code>get()</code> </dt> <dd>
<p>Returns the current value of the combobox.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Combobox.set">
<code>set(value)</code> </dt> <dd>
<p>Sets the value of the combobox to <em>value</em>.</p> </dd>
</dl> </dd>
</dl> </section> </section> <section id="spinbox"> <h2>Spinbox</h2> <p>The <code>ttk.Spinbox</code> widget is a <code>ttk.Entry</code> enhanced with increment and decrement arrows. It can be used for numbers or lists of string values. This widget is a subclass of <code>Entry</code>.</p> <p>Besides the methods inherited from <a class="reference internal" href="#tkinter.ttk.Widget" title="tkinter.ttk.Widget"><code>Widget</code></a>: <code>Widget.cget()</code>, <code>Widget.configure()</code>, <a class="reference internal" href="#tkinter.ttk.Widget.identify" title="tkinter.ttk.Widget.identify"><code>Widget.identify()</code></a>, <a class="reference internal" href="#tkinter.ttk.Widget.instate" title="tkinter.ttk.Widget.instate"><code>Widget.instate()</code></a> and <a class="reference internal" href="#tkinter.ttk.Widget.state" title="tkinter.ttk.Widget.state"><code>Widget.state()</code></a>, and the following inherited from <code>Entry</code>: <code>Entry.bbox()</code>, <code>Entry.delete()</code>, <code>Entry.icursor()</code>, <code>Entry.index()</code>, <code>Entry.insert()</code>, <code>Entry.xview()</code>, it has some other methods, described at <code>ttk.Spinbox</code>.</p> <section id="id1"> <h3>Options</h3> <p>This widget accepts the following specific options:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>from</p></td> <td><p>Float value. If set, this is the minimum value to which the decrement button will decrement. Must be spelled as <code>from_</code> when used as an argument, since <code>from</code> is a Python keyword.</p></td> </tr> <tr>
<td><p>to</p></td> <td><p>Float value. If set, this is the maximum value to which the increment button will increment.</p></td> </tr> <tr>
<td><p>increment</p></td> <td><p>Float value. Specifies the amount which the increment/decrement buttons change the value. Defaults to 1.0.</p></td> </tr> <tr>
<td><p>values</p></td> <td><p>Sequence of string or float values. If specified, the increment/decrement buttons will cycle through the items in this sequence rather than incrementing or decrementing numbers.</p></td> </tr> <tr>
<td><p>wrap</p></td> <td><p>Boolean value. If <code>True</code>, increment and decrement buttons will cycle from the <code>to</code> value to the <code>from</code> value or the <code>from</code> value to the <code>to</code> value, respectively.</p></td> </tr> <tr>
<td><p>format</p></td> <td><p>String value. This specifies the format of numbers set by the increment/decrement buttons. It must be in the form “%W.Pf”, where W is the padded width of the value, P is the precision, and ‘%’ and ‘f’ are literal.</p></td> </tr> <tr>
<td><p>command</p></td> <td><p>Python callable. Will be called with no arguments whenever either of the increment or decrement buttons are pressed.</p></td> </tr>  </table> </section> <section id="id2"> <h3>Virtual events</h3> <p>The spinbox widget generates an <strong>&lt;&lt;Increment&gt;&gt;</strong> virtual event when the user presses &lt;Up&gt;, and a <strong>&lt;&lt;Decrement&gt;&gt;</strong> virtual event when the user presses &lt;Down&gt;.</p> </section> <section id="ttk-spinbox"> <h3>ttk.Spinbox</h3> <dl class="py class"> <dt class="sig sig-object py" id="tkinter.ttk.Spinbox">
<code>class tkinter.ttk.Spinbox</code> </dt> <dd>
<dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Spinbox.get">
<code>get()</code> </dt> <dd>
<p>Returns the current value of the spinbox.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Spinbox.set">
<code>set(value)</code> </dt> <dd>
<p>Sets the value of the spinbox to <em>value</em>.</p> </dd>
</dl> </dd>
</dl> </section> </section> <section id="notebook"> <h2>Notebook</h2> <p>Ttk Notebook widget manages a collection of windows and displays a single one at a time. Each child window is associated with a tab, which the user may select to change the currently displayed window.</p> <section id="id3"> <h3>Options</h3> <p>This widget accepts the following specific options:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>height</p></td> <td><p>If present and greater than zero, specifies the desired height of the pane area (not including internal padding or tabs). Otherwise, the maximum height of all panes is used.</p></td> </tr> <tr>
<td><p>padding</p></td> <td><p>Specifies the amount of extra space to add around the outside of the notebook. The padding is a list up to four length specifications left top right bottom. If fewer than four elements are specified, bottom defaults to top, right defaults to left, and top defaults to left.</p></td> </tr> <tr>
<td><p>width</p></td> <td><p>If present and greater than zero, specified the desired width of the pane area (not including internal padding). Otherwise, the maximum width of all panes is used.</p></td> </tr>  </table> </section> <section id="tab-options"> <h3>Tab Options</h3> <p>There are also specific options for tabs:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>state</p></td> <td><p>Either “normal”, “disabled” or “hidden”. If “disabled”, then the tab is not selectable. If “hidden”, then the tab is not shown.</p></td> </tr> <tr>
<td><p>sticky</p></td> <td><p>Specifies how the child window is positioned within the pane area. Value is a string containing zero or more of the characters “n”, “s”, “e” or “w”. Each letter refers to a side (north, south, east or west) that the child window will stick to, as per the <code>grid()</code> geometry manager.</p></td> </tr> <tr>
<td><p>padding</p></td> <td><p>Specifies the amount of extra space to add between the notebook and this pane. Syntax is the same as for the option padding used by this widget.</p></td> </tr> <tr>
<td><p>text</p></td> <td><p>Specifies a text to be displayed in the tab.</p></td> </tr> <tr>
<td><p>image</p></td> <td><p>Specifies an image to display in the tab. See the option image described in <a class="reference internal" href="#tkinter.ttk.Widget" title="tkinter.ttk.Widget"><code>Widget</code></a>.</p></td> </tr> <tr>
<td><p>compound</p></td> <td><p>Specifies how to display the image relative to the text, in the case both options text and image are present. See <a class="reference internal" href="#label-options">Label Options</a> for legal values.</p></td> </tr> <tr>
<td><p>underline</p></td> <td><p>Specifies the index (0-based) of a character to underline in the text string. The underlined character is used for mnemonic activation if <a class="reference internal" href="#tkinter.ttk.Notebook.enable_traversal" title="tkinter.ttk.Notebook.enable_traversal"><code>Notebook.enable_traversal()</code></a> is called.</p></td> </tr>  </table> </section> <section id="tab-identifiers"> <h3>Tab Identifiers</h3> <p>The tab_id present in several methods of <code>ttk.Notebook</code> may take any of the following forms:</p> <ul class="simple"> <li>An integer between zero and the number of tabs</li> <li>The name of a child window</li> <li>A positional specification of the form “@x,y”, which identifies the tab</li> <li>The literal string “current”, which identifies the currently selected tab</li> <li>The literal string “end”, which returns the number of tabs (only valid for <a class="reference internal" href="#tkinter.ttk.Notebook.index" title="tkinter.ttk.Notebook.index"><code>Notebook.index()</code></a>)</li> </ul> </section> <section id="id4"> <h3>Virtual Events</h3> <p>This widget generates a <strong>&lt;&lt;NotebookTabChanged&gt;&gt;</strong> virtual event after a new tab is selected.</p> </section> <section id="ttk-notebook"> <h3>ttk.Notebook</h3> <dl class="py class"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook">
<code>class tkinter.ttk.Notebook</code> </dt> <dd>
<dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook.add">
<code>add(child, **kw)</code> </dt> <dd>
<p>Adds a new tab to the notebook.</p> <p>If window is currently managed by the notebook but hidden, it is restored to its previous position.</p> <p>See <a class="reference internal" href="#tab-options">Tab Options</a> for the list of available options.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook.forget">
<code>forget(tab_id)</code> </dt> <dd>
<p>Removes the tab specified by <em>tab_id</em>, unmaps and unmanages the associated window.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook.hide">
<code>hide(tab_id)</code> </dt> <dd>
<p>Hides the tab specified by <em>tab_id</em>.</p> <p>The tab will not be displayed, but the associated window remains managed by the notebook and its configuration remembered. Hidden tabs may be restored with the <a class="reference internal" href="#tkinter.ttk.Notebook.add" title="tkinter.ttk.Notebook.add"><code>add()</code></a> command.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook.identify">
<code>identify(x, y)</code> </dt> <dd>
<p>Returns the name of the tab element at position <em>x</em>, <em>y</em>, or the empty string if none.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook.index">
<code>index(tab_id)</code> </dt> <dd>
<p>Returns the numeric index of the tab specified by <em>tab_id</em>, or the total number of tabs if <em>tab_id</em> is the string “end”.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook.insert">
<code>insert(pos, child, **kw)</code> </dt> <dd>
<p>Inserts a pane at the specified position.</p> <p><em>pos</em> is either the string “end”, an integer index, or the name of a managed child. If <em>child</em> is already managed by the notebook, moves it to the specified position.</p> <p>See <a class="reference internal" href="#tab-options">Tab Options</a> for the list of available options.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook.select">
<code>select(tab_id=None)</code> </dt> <dd>
<p>Selects the specified <em>tab_id</em>.</p> <p>The associated child window will be displayed, and the previously selected window (if different) is unmapped. If <em>tab_id</em> is omitted, returns the widget name of the currently selected pane.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook.tab">
<code>tab(tab_id, option=None, **kw)</code> </dt> <dd>
<p>Query or modify the options of the specific <em>tab_id</em>.</p> <p>If <em>kw</em> is not given, returns a dictionary of the tab option values. If <em>option</em> is specified, returns the value of that <em>option</em>. Otherwise, sets the options to the corresponding values.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook.tabs">
<code>tabs()</code> </dt> <dd>
<p>Returns a list of windows managed by the notebook.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Notebook.enable_traversal">
<code>enable_traversal()</code> </dt> <dd>
<p>Enable keyboard traversal for a toplevel window containing this notebook.</p> <p>This will extend the bindings for the toplevel window containing the notebook as follows:</p> <ul class="simple"> <li>
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">Tab</kbd></kbd>: selects the tab following the currently selected one.</li> <li>
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Shift</kbd>-<kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">Tab</kbd></kbd>: selects the tab preceding the currently selected one.</li> <li>
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Alt</kbd>-<kbd class="kbd docutils literal notranslate">K</kbd></kbd>: where <em>K</em> is the mnemonic (underlined) character of any tab, will select that tab.</li> </ul> <p>Multiple notebooks in a single toplevel may be enabled for traversal, including nested notebooks. However, notebook traversal only works properly if all panes have the notebook they are in as master.</p> </dd>
</dl> </dd>
</dl> </section> </section> <section id="progressbar"> <h2>Progressbar</h2> <p>The <code>ttk.Progressbar</code> widget shows the status of a long-running operation. It can operate in two modes: 1) the determinate mode which shows the amount completed relative to the total amount of work to be done and 2) the indeterminate mode which provides an animated display to let the user know that work is progressing.</p> <section id="id5"> <h3>Options</h3> <p>This widget accepts the following specific options:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>orient</p></td> <td><p>One of “horizontal” or “vertical”. Specifies the orientation of the progress bar.</p></td> </tr> <tr>
<td><p>length</p></td> <td><p>Specifies the length of the long axis of the progress bar (width if horizontal, height if vertical).</p></td> </tr> <tr>
<td><p>mode</p></td> <td><p>One of “determinate” or “indeterminate”.</p></td> </tr> <tr>
<td><p>maximum</p></td> <td><p>A number specifying the maximum value. Defaults to 100.</p></td> </tr> <tr>
<td><p>value</p></td> <td><p>The current value of the progress bar. In “determinate” mode, this represents the amount of work completed. In “indeterminate” mode, it is interpreted as modulo <em>maximum</em>; that is, the progress bar completes one “cycle” when its value increases by <em>maximum</em>.</p></td> </tr> <tr>
<td><p>variable</p></td> <td><p>A name which is linked to the option value. If specified, the value of the progress bar is automatically set to the value of this name whenever the latter is modified.</p></td> </tr> <tr>
<td><p>phase</p></td> <td><p>Read-only option. The widget periodically increments the value of this option whenever its value is greater than 0 and, in determinate mode, less than maximum. This option may be used by the current theme to provide additional animation effects.</p></td> </tr>  </table> </section> <section id="ttk-progressbar"> <h3>ttk.Progressbar</h3> <dl class="py class"> <dt class="sig sig-object py" id="tkinter.ttk.Progressbar">
<code>class tkinter.ttk.Progressbar</code> </dt> <dd>
<dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Progressbar.start">
<code>start(interval=None)</code> </dt> <dd>
<p>Begin autoincrement mode: schedules a recurring timer event that calls <a class="reference internal" href="#tkinter.ttk.Progressbar.step" title="tkinter.ttk.Progressbar.step"><code>Progressbar.step()</code></a> every <em>interval</em> milliseconds. If omitted, <em>interval</em> defaults to 50 milliseconds.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Progressbar.step">
<code>step(amount=None)</code> </dt> <dd>
<p>Increments the progress bar’s value by <em>amount</em>.</p> <p><em>amount</em> defaults to 1.0 if omitted.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Progressbar.stop">
<code>stop()</code> </dt> <dd>
<p>Stop autoincrement mode: cancels any recurring timer event initiated by <a class="reference internal" href="#tkinter.ttk.Progressbar.start" title="tkinter.ttk.Progressbar.start"><code>Progressbar.start()</code></a> for this progress bar.</p> </dd>
</dl> </dd>
</dl> </section> </section> <section id="separator"> <h2>Separator</h2> <p>The <code>ttk.Separator</code> widget displays a horizontal or vertical separator bar.</p> <p>It has no other methods besides the ones inherited from <code>ttk.Widget</code>.</p> <section id="id6"> <h3>Options</h3> <p>This widget accepts the following specific option:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>orient</p></td> <td><p>One of “horizontal” or “vertical”. Specifies the orientation of the separator.</p></td> </tr>  </table> </section> </section> <section id="sizegrip"> <h2>Sizegrip</h2> <p>The <code>ttk.Sizegrip</code> widget (also known as a grow box) allows the user to resize the containing toplevel window by pressing and dragging the grip.</p> <p>This widget has neither specific options nor specific methods, besides the ones inherited from <code>ttk.Widget</code>.</p> <section id="platform-specific-notes"> <h3>Platform-specific notes</h3> <ul class="simple"> <li>On macOS, toplevel windows automatically include a built-in size grip by default. Adding a <code>Sizegrip</code> is harmless, since the built-in grip will just mask the widget.</li> </ul> </section> <section id="bugs"> <h3>Bugs</h3> <ul class="simple"> <li>If the containing toplevel’s position was specified relative to the right or bottom of the screen (e.g. ….), the <code>Sizegrip</code> widget will not resize the window.</li> <li>This widget supports only “southeast” resizing.</li> </ul> </section> </section> <section id="treeview"> <h2>Treeview</h2> <p>The <code>ttk.Treeview</code> widget displays a hierarchical collection of items. Each item has a textual label, an optional image, and an optional list of data values. The data values are displayed in successive columns after the tree label.</p> <p>The order in which data values are displayed may be controlled by setting the widget option <code>displaycolumns</code>. The tree widget can also display column headings. Columns may be accessed by number or symbolic names listed in the widget option columns. See <a class="reference internal" href="#column-identifiers">Column Identifiers</a>.</p> <p>Each item is identified by a unique name. The widget will generate item IDs if they are not supplied by the caller. There is a distinguished root item, named <code>{}</code>. The root item itself is not displayed; its children appear at the top level of the hierarchy.</p> <p>Each item also has a list of tags, which can be used to associate event bindings with individual items and control the appearance of the item.</p> <p>The Treeview widget supports horizontal and vertical scrolling, according to the options described in <a class="reference internal" href="#scrollable-widget-options">Scrollable Widget Options</a> and the methods <a class="reference internal" href="#tkinter.ttk.Treeview.xview" title="tkinter.ttk.Treeview.xview"><code>Treeview.xview()</code></a> and <a class="reference internal" href="#tkinter.ttk.Treeview.yview" title="tkinter.ttk.Treeview.yview"><code>Treeview.yview()</code></a>.</p> <section id="id7"> <h3>Options</h3> <p>This widget accepts the following specific options:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>columns</p></td> <td><p>A list of column identifiers, specifying the number of columns and their names.</p></td> </tr> <tr>
<td><p>displaycolumns</p></td> <td><p>A list of column identifiers (either symbolic or integer indices) specifying which data columns are displayed and the order in which they appear, or the string “#all”.</p></td> </tr> <tr>
<td><p>height</p></td> <td><p>Specifies the number of rows which should be visible. Note: the requested width is determined from the sum of the column widths.</p></td> </tr> <tr>
<td><p>padding</p></td> <td><p>Specifies the internal padding for the widget. The padding is a list of up to four length specifications.</p></td> </tr> <tr>
<td><p>selectmode</p></td> <td>
<p>Controls how the built-in class bindings manage the selection. One of “extended”, “browse” or “none”. If set to “extended” (the default), multiple items may be selected. If “browse”, only a single item will be selected at a time. If “none”, the selection will not be changed.</p> <p>Note that the application code and tag bindings can set the selection however they wish, regardless of the value of this option.</p> </td> </tr> <tr>
<td><p>show</p></td> <td>
<p>A list containing zero or more of the following values, specifying which elements of the tree to display.</p> <ul class="simple"> <li>tree: display tree labels in column #0.</li> <li>headings: display the heading row.</li> </ul> <p>The default is “tree headings”, i.e., show all elements.</p> <p><strong>Note</strong>: Column #0 always refers to the tree column, even if show=”tree” is not specified.</p> </td> </tr>  </table> </section> <section id="item-options"> <h3>Item Options</h3> <p>The following item options may be specified for items in the insert and item widget commands.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>text</p></td> <td><p>The textual label to display for the item.</p></td> </tr> <tr>
<td><p>image</p></td> <td><p>A Tk Image, displayed to the left of the label.</p></td> </tr> <tr>
<td><p>values</p></td> <td>
<p>The list of values associated with the item.</p> <p>Each item should have the same number of values as the widget option columns. If there are fewer values than columns, the remaining values are assumed empty. If there are more values than columns, the extra values are ignored.</p> </td> </tr> <tr>
<td><p>open</p></td> <td><p><code>True</code>/<code>False</code> value indicating whether the item’s children should be displayed or hidden.</p></td> </tr> <tr>
<td><p>tags</p></td> <td><p>A list of tags associated with this item.</p></td> </tr>  </table> </section> <section id="tag-options"> <h3>Tag Options</h3> <p>The following options may be specified on tags:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>foreground</p></td> <td><p>Specifies the text foreground color.</p></td> </tr> <tr>
<td><p>background</p></td> <td><p>Specifies the cell or item background color.</p></td> </tr> <tr>
<td><p>font</p></td> <td><p>Specifies the font to use when drawing text.</p></td> </tr> <tr>
<td><p>image</p></td> <td><p>Specifies the item image, in case the item’s image option is empty.</p></td> </tr>  </table> </section> <section id="column-identifiers"> <h3>Column Identifiers</h3> <p>Column identifiers take any of the following forms:</p> <ul class="simple"> <li>A symbolic name from the list of columns option.</li> <li>An integer n, specifying the nth data column.</li> <li>A string of the form #n, where n is an integer, specifying the nth display column.</li> </ul> <p>Notes:</p> <ul class="simple"> <li>Item’s option values may be displayed in a different order than the order in which they are stored.</li> <li>Column #0 always refers to the tree column, even if show=”tree” is not specified.</li> </ul> <p>A data column number is an index into an item’s option values list; a display column number is the column number in the tree where the values are displayed. Tree labels are displayed in column #0. If option displaycolumns is not set, then data column n is displayed in column #n+1. Again, <strong>column #0 always refers to the tree column</strong>.</p> </section> <section id="id8"> <h3>Virtual Events</h3> <p>The Treeview widget generates the following virtual events.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Event</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>&lt;&lt;TreeviewSelect&gt;&gt;</p></td> <td><p>Generated whenever the selection changes.</p></td> </tr> <tr>
<td><p>&lt;&lt;TreeviewOpen&gt;&gt;</p></td> <td><p>Generated just before settings the focus item to open=True.</p></td> </tr> <tr>
<td><p>&lt;&lt;TreeviewClose&gt;&gt;</p></td> <td><p>Generated just after setting the focus item to open=False.</p></td> </tr>  </table> <p>The <a class="reference internal" href="#tkinter.ttk.Treeview.focus" title="tkinter.ttk.Treeview.focus"><code>Treeview.focus()</code></a> and <a class="reference internal" href="#tkinter.ttk.Treeview.selection" title="tkinter.ttk.Treeview.selection"><code>Treeview.selection()</code></a> methods can be used to determine the affected item or items.</p> </section> <section id="ttk-treeview"> <h3>ttk.Treeview</h3> <dl class="py class"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview">
<code>class tkinter.ttk.Treeview</code> </dt> <dd>
<dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.bbox">
<code>bbox(item, column=None)</code> </dt> <dd>
<p>Returns the bounding box (relative to the treeview widget’s window) of the specified <em>item</em> in the form (x, y, width, height).</p> <p>If <em>column</em> is specified, returns the bounding box of that cell. If the <em>item</em> is not visible (i.e., if it is a descendant of a closed item or is scrolled offscreen), returns an empty string.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.get_children">
<code>get_children(item=None)</code> </dt> <dd>
<p>Returns the list of children belonging to <em>item</em>.</p> <p>If <em>item</em> is not specified, returns root children.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.set_children">
<code>set_children(item, *newchildren)</code> </dt> <dd>
<p>Replaces <em>item</em>’s child with <em>newchildren</em>.</p> <p>Children present in <em>item</em> that are not present in <em>newchildren</em> are detached from the tree. No items in <em>newchildren</em> may be an ancestor of <em>item</em>. Note that not specifying <em>newchildren</em> results in detaching <em>item</em>’s children.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.column">
<code>column(column, option=None, **kw)</code> </dt> <dd>
<p>Query or modify the options for the specified <em>column</em>.</p> <p>If <em>kw</em> is not given, returns a dict of the column option values. If <em>option</em> is specified then the value for that <em>option</em> is returned. Otherwise, sets the options to the corresponding values.</p> <p>The valid options/values are:</p> <dl class="simple"> <dt><em>id</em></dt>
<dd>
<p>Returns the column name. This is a read-only option.</p> </dd> <dt>
<em>anchor</em>: One of the standard Tk anchor values.</dt>
<dd>
<p>Specifies how the text in this column should be aligned with respect to the cell.</p> </dd> <dt>
<em>minwidth</em>: width</dt>
<dd>
<p>The minimum width of the column in pixels. The treeview widget will not make the column any smaller than specified by this option when the widget is resized or the user drags a column.</p> </dd> <dt>
<code>stretch: True/False</code> </dt>
<dd>
<p>Specifies whether the column’s width should be adjusted when the widget is resized.</p> </dd> <dt>
<em>width</em>: width</dt>
<dd>
<p>The width of the column in pixels.</p> </dd> </dl> <p>To configure the tree column, call this with column = “#0”</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.delete">
<code>delete(*items)</code> </dt> <dd>
<p>Delete all specified <em>items</em> and all their descendants.</p> <p>The root item may not be deleted.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.detach">
<code>detach(*items)</code> </dt> <dd>
<p>Unlinks all of the specified <em>items</em> from the tree.</p> <p>The items and all of their descendants are still present, and may be reinserted at another point in the tree, but will not be displayed.</p> <p>The root item may not be detached.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.exists">
<code>exists(item)</code> </dt> <dd>
<p>Returns <code>True</code> if the specified <em>item</em> is present in the tree.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.focus">
<code>focus(item=None)</code> </dt> <dd>
<p>If <em>item</em> is specified, sets the focus item to <em>item</em>. Otherwise, returns the current focus item, or ‘’ if there is none.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.heading">
<code>heading(column, option=None, **kw)</code> </dt> <dd>
<p>Query or modify the heading options for the specified <em>column</em>.</p> <p>If <em>kw</em> is not given, returns a dict of the heading option values. If <em>option</em> is specified then the value for that <em>option</em> is returned. Otherwise, sets the options to the corresponding values.</p> <p>The valid options/values are:</p> <dl class="simple"> <dt>
<em>text</em>: text</dt>
<dd>
<p>The text to display in the column heading.</p> </dd> <dt>
<em>image</em>: imageName</dt>
<dd>
<p>Specifies an image to display to the right of the column heading.</p> </dd> <dt>
<em>anchor</em>: anchor</dt>
<dd>
<p>Specifies how the heading text should be aligned. One of the standard Tk anchor values.</p> </dd> <dt>
<em>command</em>: callback</dt>
<dd>
<p>A callback to be invoked when the heading label is pressed.</p> </dd> </dl> <p>To configure the tree column heading, call this with column = “#0”.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.identify">
<code>identify(component, x, y)</code> </dt> <dd>
<p>Returns a description of the specified <em>component</em> under the point given by <em>x</em> and <em>y</em>, or the empty string if no such <em>component</em> is present at that position.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.identify_row">
<code>identify_row(y)</code> </dt> <dd>
<p>Returns the item ID of the item at position <em>y</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.identify_column">
<code>identify_column(x)</code> </dt> <dd>
<p>Returns the data column identifier of the cell at position <em>x</em>.</p> <p>The tree column has ID #0.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.identify_region">
<code>identify_region(x, y)</code> </dt> <dd>
<p>Returns one of:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>region</p></th> <th class="head"><p>meaning</p></th> </tr> </thead>  <tr>
<td><p>heading</p></td> <td><p>Tree heading area.</p></td> </tr> <tr>
<td><p>separator</p></td> <td><p>Space between two columns headings.</p></td> </tr> <tr>
<td><p>tree</p></td> <td><p>The tree area.</p></td> </tr> <tr>
<td><p>cell</p></td> <td><p>A data cell.</p></td> </tr>  </table> <p>Availability: Tk 8.6.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.identify_element">
<code>identify_element(x, y)</code> </dt> <dd>
<p>Returns the element at position <em>x</em>, <em>y</em>.</p> <p>Availability: Tk 8.6.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.index">
<code>index(item)</code> </dt> <dd>
<p>Returns the integer index of <em>item</em> within its parent’s list of children.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.insert">
<code>insert(parent, index, iid=None, **kw)</code> </dt> <dd>
<p>Creates a new item and returns the item identifier of the newly created item.</p> <p><em>parent</em> is the item ID of the parent item, or the empty string to create a new top-level item. <em>index</em> is an integer, or the value “end”, specifying where in the list of parent’s children to insert the new item. If <em>index</em> is less than or equal to zero, the new node is inserted at the beginning; if <em>index</em> is greater than or equal to the current number of children, it is inserted at the end. If <em>iid</em> is specified, it is used as the item identifier; <em>iid</em> must not already exist in the tree. Otherwise, a new unique identifier is generated.</p> <p>See <a class="reference internal" href="#item-options">Item Options</a> for the list of available options.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.item">
<code>item(item, option=None, **kw)</code> </dt> <dd>
<p>Query or modify the options for the specified <em>item</em>.</p> <p>If no options are given, a dict with options/values for the item is returned. If <em>option</em> is specified then the value for that option is returned. Otherwise, sets the options to the corresponding values as given by <em>kw</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.move">
<code>move(item, parent, index)</code> </dt> <dd>
<p>Moves <em>item</em> to position <em>index</em> in <em>parent</em>’s list of children.</p> <p>It is illegal to move an item under one of its descendants. If <em>index</em> is less than or equal to zero, <em>item</em> is moved to the beginning; if greater than or equal to the number of children, it is moved to the end. If <em>item</em> was detached it is reattached.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.next">
<code>next(item)</code> </dt> <dd>
<p>Returns the identifier of <em>item</em>’s next sibling, or ‘’ if <em>item</em> is the last child of its parent.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.parent">
<code>parent(item)</code> </dt> <dd>
<p>Returns the ID of the parent of <em>item</em>, or ‘’ if <em>item</em> is at the top level of the hierarchy.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.prev">
<code>prev(item)</code> </dt> <dd>
<p>Returns the identifier of <em>item</em>’s previous sibling, or ‘’ if <em>item</em> is the first child of its parent.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.reattach">
<code>reattach(item, parent, index)</code> </dt> <dd>
<p>An alias for <a class="reference internal" href="#tkinter.ttk.Treeview.move" title="tkinter.ttk.Treeview.move"><code>Treeview.move()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.see">
<code>see(item)</code> </dt> <dd>
<p>Ensure that <em>item</em> is visible.</p> <p>Sets all of <em>item</em>’s ancestors open option to <code>True</code>, and scrolls the widget if necessary so that <em>item</em> is within the visible portion of the tree.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.selection">
<code>selection()</code> </dt> <dd>
<p>Returns a tuple of selected items.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span><code>selection()</code> no longer takes arguments. For changing the selection state use the following selection methods.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.selection_set">
<code>selection_set(*items)</code> </dt> <dd>
<p><em>items</em> becomes the new selection.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>items</em> can be passed as separate arguments, not just as a single tuple.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.selection_add">
<code>selection_add(*items)</code> </dt> <dd>
<p>Add <em>items</em> to the selection.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>items</em> can be passed as separate arguments, not just as a single tuple.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.selection_remove">
<code>selection_remove(*items)</code> </dt> <dd>
<p>Remove <em>items</em> from the selection.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>items</em> can be passed as separate arguments, not just as a single tuple.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.selection_toggle">
<code>selection_toggle(*items)</code> </dt> <dd>
<p>Toggle the selection state of each item in <em>items</em>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>items</em> can be passed as separate arguments, not just as a single tuple.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.set">
<code>set(item, column=None, value=None)</code> </dt> <dd>
<p>With one argument, returns a dictionary of column/value pairs for the specified <em>item</em>. With two arguments, returns the current value of the specified <em>column</em>. With three arguments, sets the value of given <em>column</em> in given <em>item</em> to the specified <em>value</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.tag_bind">
<code>tag_bind(tagname, sequence=None, callback=None)</code> </dt> <dd>
<p>Bind a callback for the given event <em>sequence</em> to the tag <em>tagname</em>. When an event is delivered to an item, the callbacks for each of the item’s tags option are called.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.tag_configure">
<code>tag_configure(tagname, option=None, **kw)</code> </dt> <dd>
<p>Query or modify the options for the specified <em>tagname</em>.</p> <p>If <em>kw</em> is not given, returns a dict of the option settings for <em>tagname</em>. If <em>option</em> is specified, returns the value for that <em>option</em> for the specified <em>tagname</em>. Otherwise, sets the options to the corresponding values for the given <em>tagname</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.tag_has">
<code>tag_has(tagname, item=None)</code> </dt> <dd>
<p>If <em>item</em> is specified, returns 1 or 0 depending on whether the specified <em>item</em> has the given <em>tagname</em>. Otherwise, returns a list of all items that have the specified tag.</p> <p>Availability: Tk 8.6</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.xview">
<code>xview(*args)</code> </dt> <dd>
<p>Query or modify horizontal position of the treeview.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Treeview.yview">
<code>yview(*args)</code> </dt> <dd>
<p>Query or modify vertical position of the treeview.</p> </dd>
</dl> </dd>
</dl> </section> </section> <section id="ttk-styling"> <span id="ttkstyling"></span><h2>Ttk Styling</h2> <p>Each widget in <code>ttk</code> is assigned a style, which specifies the set of elements making up the widget and how they are arranged, along with dynamic and default settings for element options. By default the style name is the same as the widget’s class name, but it may be overridden by the widget’s style option. If you don’t know the class name of a widget, use the method <code>Misc.winfo_class()</code> (somewidget.winfo_class()).</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://tktable.sourceforge.net/tile/tile-tcl2004.pdf">Tcl’2004 conference presentation</a></dt>
<dd>
<p>This document explains how the theme engine works</p> </dd> </dl> </div> <dl class="py class"> <dt class="sig sig-object py" id="tkinter.ttk.Style">
<code>class tkinter.ttk.Style</code> </dt> <dd>
<p>This class is used to manipulate the style database.</p> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.configure">
<code>configure(style, query_opt=None, **kw)</code> </dt> <dd>
<p>Query or set the default value of the specified option(s) in <em>style</em>.</p> <p>Each key in <em>kw</em> is an option and each value is a string identifying the value for that option.</p> <p>For example, to change every default button to be a flat button with some padding and a different background color:</p> <pre data-language="python">from tkinter import ttk
import tkinter

root = tkinter.Tk()

ttk.Style().configure("TButton", padding=6, relief="flat",
   background="#ccc")

btn = ttk.Button(text="Sample")
btn.pack()

root.mainloop()
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.map">
<code>map(style, query_opt=None, **kw)</code> </dt> <dd>
<p>Query or sets dynamic values of the specified option(s) in <em>style</em>.</p> <p>Each key in <em>kw</em> is an option and each value should be a list or a tuple (usually) containing statespecs grouped in tuples, lists, or some other preference. A statespec is a compound of one or more states and then a value.</p> <p>An example may make it more understandable:</p> <pre data-language="python">import tkinter
from tkinter import ttk

root = tkinter.Tk()

style = ttk.Style()
style.map("C.TButton",
    foreground=[('pressed', 'red'), ('active', 'blue')],
    background=[('pressed', '!disabled', 'black'), ('active', 'white')]
    )

colored_btn = ttk.Button(text="Test", style="C.TButton").pack()

root.mainloop()
</pre> <p>Note that the order of the (states, value) sequences for an option does matter, if the order is changed to <code>[('active', 'blue'), ('pressed',
'red')]</code> in the foreground option, for example, the result would be a blue foreground when the widget were in active or pressed states.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.lookup">
<code>lookup(style, option, state=None, default=None)</code> </dt> <dd>
<p>Returns the value specified for <em>option</em> in <em>style</em>.</p> <p>If <em>state</em> is specified, it is expected to be a sequence of one or more states. If the <em>default</em> argument is set, it is used as a fallback value in case no specification for option is found.</p> <p>To check what font a Button uses by default:</p> <pre data-language="python">from tkinter import ttk

print(ttk.Style().lookup("TButton", "font"))
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.layout">
<code>layout(style, layoutspec=None)</code> </dt> <dd>
<p>Define the widget layout for given <em>style</em>. If <em>layoutspec</em> is omitted, return the layout specification for given style.</p> <p><em>layoutspec</em>, if specified, is expected to be a list or some other sequence type (excluding strings), where each item should be a tuple and the first item is the layout name and the second item should have the format described in <a class="reference internal" href="#layouts">Layouts</a>.</p> <p>To understand the format, see the following example (it is not intended to do anything useful):</p> <pre data-language="python">from tkinter import ttk
import tkinter

root = tkinter.Tk()

style = ttk.Style()
style.layout("TMenubutton", [
   ("Menubutton.background", None),
   ("Menubutton.button", {"children":
       [("Menubutton.focus", {"children":
           [("Menubutton.padding", {"children":
               [("Menubutton.label", {"side": "left", "expand": 1})]
           })]
       })]
   }),
])

mbtn = ttk.Menubutton(text='Text')
mbtn.pack()
root.mainloop()
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.element_create">
<code>element_create(elementname, etype, *args, **kw)</code> </dt> <dd>
<p>Create a new element in the current theme, of the given <em>etype</em> which is expected to be either “image”, “from” or “vsapi”. The latter is only available in Tk 8.6 on Windows.</p> <p>If “image” is used, <em>args</em> should contain the default image name followed by statespec/value pairs (this is the imagespec), and <em>kw</em> may have the following options:</p> <dl class="simple"> <dt>border=padding</dt>
<dd>
<p>padding is a list of up to four integers, specifying the left, top, right, and bottom borders, respectively.</p> </dd> <dt>height=height</dt>
<dd>
<p>Specifies a minimum height for the element. If less than zero, the base image’s height is used as a default.</p> </dd> <dt>padding=padding</dt>
<dd>
<p>Specifies the element’s interior padding. Defaults to border’s value if not specified.</p> </dd> <dt>sticky=spec</dt>
<dd>
<p>Specifies how the image is placed within the final parcel. spec contains zero or more characters “n”, “s”, “w”, or “e”.</p> </dd> <dt>width=width</dt>
<dd>
<p>Specifies a minimum width for the element. If less than zero, the base image’s width is used as a default.</p> </dd> </dl> <p>Example:</p> <pre data-language="python">img1 = tkinter.PhotoImage(master=root, file='button.png')
img1 = tkinter.PhotoImage(master=root, file='button-pressed.png')
img1 = tkinter.PhotoImage(master=root, file='button-active.png')
style = ttk.Style(root)
style.element_create('Button.button', 'image',
                     img1, ('pressed', img2), ('active', img3),
                     border=(2, 4), sticky='we')
</pre> <p>If “from” is used as the value of <em>etype</em>, <a class="reference internal" href="#tkinter.ttk.Style.element_create" title="tkinter.ttk.Style.element_create"><code>element_create()</code></a> will clone an existing element. <em>args</em> is expected to contain a themename, from which the element will be cloned, and optionally an element to clone from. If this element to clone from is not specified, an empty element will be used. <em>kw</em> is discarded.</p> <p>Example:</p> <pre data-language="python">style = ttk.Style(root)
style.element_create('plain.background', 'from', 'default')
</pre> <p>If “vsapi” is used as the value of <em>etype</em>, <a class="reference internal" href="#tkinter.ttk.Style.element_create" title="tkinter.ttk.Style.element_create"><code>element_create()</code></a> will create a new element in the current theme whose visual appearance is drawn using the Microsoft Visual Styles API which is responsible for the themed styles on Windows XP and Vista. <em>args</em> is expected to contain the Visual Styles class and part as given in the Microsoft documentation followed by an optional sequence of tuples of ttk states and the corresponding Visual Styles API state value. <em>kw</em> may have the following options:</p> <dl class="simple"> <dt>padding=padding</dt>
<dd>
<p>Specify the element’s interior padding. <em>padding</em> is a list of up to four integers specifying the left, top, right and bottom padding quantities respectively. If fewer than four elements are specified, bottom defaults to top, right defaults to left, and top defaults to left. In other words, a list of three numbers specify the left, vertical, and right padding; a list of two numbers specify the horizontal and the vertical padding; a single number specifies the same padding all the way around the widget. This option may not be mixed with any other options.</p> </dd> <dt>margins=padding</dt>
<dd>
<p>Specifies the elements exterior padding. <em>padding</em> is a list of up to four integers specifying the left, top, right and bottom padding quantities respectively. This option may not be mixed with any other options.</p> </dd> <dt>width=width</dt>
<dd>
<p>Specifies the width for the element. If this option is set then the Visual Styles API will not be queried for the recommended size or the part. If this option is set then <em>height</em> should also be set. The <em>width</em> and <em>height</em> options cannot be mixed with the <em>padding</em> or <em>margins</em> options.</p> </dd> <dt>height=height</dt>
<dd>
<p>Specifies the height of the element. See the comments for <em>width</em>.</p> </dd> </dl> <p>Example:</p> <pre data-language="python">style = ttk.Style(root)
style.element_create('pin', 'vsapi', 'EXPLORERBAR', 3, [
                     ('pressed', '!selected', 3),
                     ('active', '!selected', 2),
                     ('pressed', 'selected', 6),
                     ('active', 'selected', 5),
                     ('selected', 4),
                     ('', 1)])
style.layout('Explorer.Pin',
             [('Explorer.Pin.pin', {'sticky': 'news'})])
pin = ttk.Checkbutton(style='Explorer.Pin')
pin.pack(expand=True, fill='both')
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Added support of the “vsapi” element factory.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.element_names">
<code>element_names()</code> </dt> <dd>
<p>Returns the list of elements defined in the current theme.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.element_options">
<code>element_options(elementname)</code> </dt> <dd>
<p>Returns the list of <em>elementname</em>’s options.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.theme_create">
<code>theme_create(themename, parent=None, settings=None)</code> </dt> <dd>
<p>Create a new theme.</p> <p>It is an error if <em>themename</em> already exists. If <em>parent</em> is specified, the new theme will inherit styles, elements and layouts from the parent theme. If <em>settings</em> are present they are expected to have the same syntax used for <a class="reference internal" href="#tkinter.ttk.Style.theme_settings" title="tkinter.ttk.Style.theme_settings"><code>theme_settings()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.theme_settings">
<code>theme_settings(themename, settings)</code> </dt> <dd>
<p>Temporarily sets the current theme to <em>themename</em>, apply specified <em>settings</em> and then restore the previous theme.</p> <p>Each key in <em>settings</em> is a style and each value may contain the keys ‘configure’, ‘map’, ‘layout’ and ‘element create’ and they are expected to have the same format as specified by the methods <a class="reference internal" href="#tkinter.ttk.Style.configure" title="tkinter.ttk.Style.configure"><code>Style.configure()</code></a>, <a class="reference internal" href="#tkinter.ttk.Style.map" title="tkinter.ttk.Style.map"><code>Style.map()</code></a>, <a class="reference internal" href="#tkinter.ttk.Style.layout" title="tkinter.ttk.Style.layout"><code>Style.layout()</code></a> and <a class="reference internal" href="#tkinter.ttk.Style.element_create" title="tkinter.ttk.Style.element_create"><code>Style.element_create()</code></a> respectively.</p> <p>As an example, let’s change the Combobox for the default theme a bit:</p> <pre data-language="python">from tkinter import ttk
import tkinter

root = tkinter.Tk()

style = ttk.Style()
style.theme_settings("default", {
   "TCombobox": {
       "configure": {"padding": 5},
       "map": {
           "background": [("active", "green2"),
                          ("!disabled", "green4")],
           "fieldbackground": [("!disabled", "green3")],
           "foreground": [("focus", "OliveDrab1"),
                          ("!disabled", "OliveDrab2")]
       }
   }
})

combo = ttk.Combobox().pack()

root.mainloop()
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.theme_names">
<code>theme_names()</code> </dt> <dd>
<p>Returns a list of all known themes.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="tkinter.ttk.Style.theme_use">
<code>theme_use(themename=None)</code> </dt> <dd>
<p>If <em>themename</em> is not given, returns the theme in use. Otherwise, sets the current theme to <em>themename</em>, refreshes all widgets and emits a &lt;&lt;ThemeChanged&gt;&gt; event.</p> </dd>
</dl> </dd>
</dl> <section id="layouts"> <h3>Layouts</h3> <p>A layout can be just <code>None</code>, if it takes no options, or a dict of options specifying how to arrange the element. The layout mechanism uses a simplified version of the pack geometry manager: given an initial cavity, each element is allocated a parcel.</p> <p>The valid options/values are:</p> <dl class="simple"> <dt>
<em>side</em>: whichside</dt>
<dd>
<p>Specifies which side of the cavity to place the element; one of top, right, bottom or left. If omitted, the element occupies the entire cavity.</p> </dd> <dt>
<em>sticky</em>: nswe</dt>
<dd>
<p>Specifies where the element is placed inside its allocated parcel.</p> </dd> <dt>
<em>unit</em>: 0 or 1</dt>
<dd>
<p>If set to 1, causes the element and all of its descendants to be treated as a single element for the purposes of <a class="reference internal" href="#tkinter.ttk.Widget.identify" title="tkinter.ttk.Widget.identify"><code>Widget.identify()</code></a> et al. It’s used for things like scrollbar thumbs with grips.</p> </dd> <dt>
<em>children</em>: [sublayout… ]</dt>
<dd>
<p>Specifies a list of elements to place inside the element. Each element is a tuple (or other sequence type) where the first item is the layout name, and the other is a <a class="reference internal" href="#layouts">Layout</a>.</p> </dd> </dl> </section> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/tkinter.ttk.html" class="_attribution-link">https://docs.python.org/3.13/library/tkinter.ttk.html</a>
  </p>
</div>
