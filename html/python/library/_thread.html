 <span id="thread-low-level-threading-api"></span><h1>_thread — Low-level threading API</h1>  <p>This module provides low-level primitives for working with multiple threads (also called <em class="dfn">light-weight processes</em> or <em class="dfn">tasks</em>) — multiple threads of control sharing their global data space. For synchronization, simple locks (also called <em class="dfn">mutexes</em> or <em class="dfn">binary semaphores</em>) are provided. The <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code>threading</code></a> module provides an easier to use and higher-level threading API built on top of this module.</p> <div class="versionchanged" id="index-1"> <p><span class="versionmodified changed">Changed in version 3.7: </span>This module used to be optional, it is now always available.</p> </div> <p>This module defines the following constants and functions:</p> <dl class="py exception"> <dt class="sig sig-object py" id="thread.error">
<code>exception _thread.error</code> </dt> <dd>
<p>Raised on thread-specific errors.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>This is now a synonym of the built-in <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a>.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="thread.LockType">
<code>_thread.LockType</code> </dt> <dd>
<p>This is the type of lock objects.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="thread.start_new_thread">
<code>_thread.start_new_thread(function, args[, kwargs])</code> </dt> <dd>
<p>Start a new thread and return its identifier. The thread executes the function <em>function</em> with the argument list <em>args</em> (which must be a tuple). The optional <em>kwargs</em> argument specifies a dictionary of keyword arguments.</p> <p>When the function returns, the thread silently exits.</p> <p>When the function terminates with an unhandled exception, <a class="reference internal" href="sys.html#sys.unraisablehook" title="sys.unraisablehook"><code>sys.unraisablehook()</code></a> is called to handle the exception. The <em>object</em> attribute of the hook argument is <em>function</em>. By default, a stack trace is printed and then the thread exits (but other threads continue to run).</p> <p>When the function raises a <a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code>SystemExit</code></a> exception, it is silently ignored.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>_thread.start_new_thread</code> with arguments <code>function</code>, <code>args</code>, <code>kwargs</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span><a class="reference internal" href="sys.html#sys.unraisablehook" title="sys.unraisablehook"><code>sys.unraisablehook()</code></a> is now used to handle unhandled exceptions.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="thread.interrupt_main">
<code>_thread.interrupt_main(signum=signal.SIGINT, /)</code> </dt> <dd>
<p>Simulate the effect of a signal arriving in the main thread. A thread can use this function to interrupt the main thread, though there is no guarantee that the interruption will happen immediately.</p> <p>If given, <em>signum</em> is the number of the signal to simulate. If <em>signum</em> is not given, <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code>signal.SIGINT</code></a> is simulated.</p> <p>If the given signal isn’t handled by Python (it was set to <a class="reference internal" href="signal.html#signal.SIG_DFL" title="signal.SIG_DFL"><code>signal.SIG_DFL</code></a> or <a class="reference internal" href="signal.html#signal.SIG_IGN" title="signal.SIG_IGN"><code>signal.SIG_IGN</code></a>), this function does nothing.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <em>signum</em> argument is added to customize the signal number.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This does not emit the corresponding signal but schedules a call to the associated handler (if it exists). If you want to truly emit the signal, use <a class="reference internal" href="signal.html#signal.raise_signal" title="signal.raise_signal"><code>signal.raise_signal()</code></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="thread.exit">
<code>_thread.exit()</code> </dt> <dd>
<p>Raise the <a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code>SystemExit</code></a> exception. When not caught, this will cause the thread to exit silently.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="thread.allocate_lock">
<code>_thread.allocate_lock()</code> </dt> <dd>
<p>Return a new lock object. Methods of locks are described below. The lock is initially unlocked.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="thread.get_ident">
<code>_thread.get_ident()</code> </dt> <dd>
<p>Return the ‘thread identifier’ of the current thread. This is a nonzero integer. Its value has no direct meaning; it is intended as a magic cookie to be used e.g. to index a dictionary of thread-specific data. Thread identifiers may be recycled when a thread exits and another thread is created.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="thread.get_native_id">
<code>_thread.get_native_id()</code> </dt> <dd>
<p>Return the native integral Thread ID of the current thread assigned by the kernel. This is a non-negative integer. Its value may be used to uniquely identify this particular thread system-wide (until the thread terminates, after which the value may be recycled by the OS).</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX, DragonFlyBSD, GNU/kFreeBSD.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Added support for GNU/kFreeBSD.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="thread.stack_size">
<code>_thread.stack_size([size])</code> </dt> <dd>
<p>Return the thread stack size used when creating new threads. The optional <em>size</em> argument specifies the stack size to be used for subsequently created threads, and must be 0 (use platform or configured default) or a positive integer value of at least 32,768 (32 KiB). If <em>size</em> is not specified, 0 is used. If changing the thread stack size is unsupported, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised. If the specified stack size is invalid, a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised and the stack size is unmodified. 32 KiB is currently the minimum supported stack size value to guarantee sufficient stack space for the interpreter itself. Note that some platforms may have particular restrictions on values for the stack size, such as requiring a minimum stack size &gt; 32 KiB or requiring allocation in multiples of the system memory page size - platform documentation should be referred to for more information (4 KiB pages are common; using multiples of 4096 for the stack size is the suggested approach in the absence of more specific information).</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows, pthreads.</p> <p>Unix platforms with POSIX threads support.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="thread.TIMEOUT_MAX">
<code>_thread.TIMEOUT_MAX</code> </dt> <dd>
<p>The maximum value allowed for the <em>timeout</em> parameter of <a class="reference internal" href="threading.html#threading.Lock.acquire" title="threading.Lock.acquire"><code>Lock.acquire</code></a>. Specifying a timeout greater than this value will raise an <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <p>Lock objects have the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="thread.lock.acquire">
<code>lock.acquire(blocking=True, timeout=-1)</code> </dt> <dd>
<p>Without any optional argument, this method acquires the lock unconditionally, if necessary waiting until it is released by another thread (only one thread at a time can acquire a lock — that’s their reason for existence).</p> <p>If the <em>blocking</em> argument is present, the action depends on its value: if it is false, the lock is only acquired if it can be acquired immediately without waiting, while if it is true, the lock is acquired unconditionally as above.</p> <p>If the floating-point <em>timeout</em> argument is present and positive, it specifies the maximum wait time in seconds before returning. A negative <em>timeout</em> argument specifies an unbounded wait. You cannot specify a <em>timeout</em> if <em>blocking</em> is false.</p> <p>The return value is <code>True</code> if the lock is acquired successfully, <code>False</code> if not.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>The <em>timeout</em> parameter is new.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Lock acquires can now be interrupted by signals on POSIX.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="thread.lock.release">
<code>lock.release()</code> </dt> <dd>
<p>Releases the lock. The lock must have been acquired earlier, but not necessarily by the same thread.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="thread.lock.locked">
<code>lock.locked()</code> </dt> <dd>
<p>Return the status of the lock: <code>True</code> if it has been acquired by some thread, <code>False</code> if not.</p> </dd>
</dl> <p>In addition to these methods, lock objects can also be used via the <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> statement, e.g.:</p> <pre data-language="python">import _thread

a_lock = _thread.allocate_lock()

with a_lock:
    print("a_lock is locked while this executes")
</pre> <p><strong>Caveats:</strong></p> <ul class="simple" id="index-2"> <li>Interrupts always go to the main thread (the <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a> exception will be received by that thread.)</li> <li>Calling <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code>sys.exit()</code></a> or raising the <a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code>SystemExit</code></a> exception is equivalent to calling <a class="reference internal" href="#thread.exit" title="_thread.exit"><code>_thread.exit()</code></a>.</li> <li>It is platform-dependent whether the <a class="reference internal" href="threading.html#threading.Lock.acquire" title="threading.Lock.acquire"><code>acquire()</code></a> method on a lock can be interrupted (so that the <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a> exception will happen immediately, rather than only after the lock has been acquired or the operation has timed out). It can be interrupted on POSIX, but not on Windows.</li> <li>When the main thread exits, it is system defined whether the other threads survive. On most systems, they are killed without executing <a class="reference internal" href="../reference/compound_stmts.html#try"><code>try</code></a> … <a class="reference internal" href="../reference/compound_stmts.html#finally"><code>finally</code></a> clauses or executing object destructors.</li> </ul> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/_thread.html" class="_attribution-link">https://docs.python.org/3.13/library/_thread.html</a>
  </p>
</div>
