 <span id="shutil-high-level-file-operations"></span><h1>shutil — High-level file operations</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/shutil.py">Lib/shutil.py</a></p>  <p>The <a class="reference internal" href="#module-shutil" title="shutil: High-level file operations, including copying."><code>shutil</code></a> module offers a number of high-level operations on files and collections of files. In particular, functions are provided which support file copying and removal. For operations on individual files, see also the <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code>os</code></a> module.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Even the higher-level file copying functions (<a class="reference internal" href="#shutil.copy" title="shutil.copy"><code>shutil.copy()</code></a>, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>shutil.copy2()</code></a>) cannot copy all file metadata.</p> <p>On POSIX platforms, this means that file owner and group are lost as well as ACLs. On Mac OS, the resource fork and other metadata are not used. This means that resources will be lost and file type and creator codes will not be correct. On Windows, file owners, ACLs and alternate data streams are not copied.</p> </div> <section id="directory-and-files-operations"> <span id="file-operations"></span><h2>Directory and files operations</h2> <dl class="py function"> <dt class="sig sig-object py" id="shutil.copyfileobj">
<code>shutil.copyfileobj(fsrc, fdst[, length])</code> </dt> <dd>
<p>Copy the contents of the <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file-like object</span></a> <em>fsrc</em> to the file-like object <em>fdst</em>. The integer <em>length</em>, if given, is the buffer size. In particular, a negative <em>length</em> value means to copy the data without looping over the source data in chunks; by default the data is read in chunks to avoid uncontrolled memory consumption. Note that if the current file position of the <em>fsrc</em> object is not 0, only the contents from the current file position to the end of the file will be copied.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.copyfile">
<code>shutil.copyfile(src, dst, *, follow_symlinks=True)</code> </dt> <dd>
<p>Copy the contents (no metadata) of the file named <em>src</em> to a file named <em>dst</em> and return <em>dst</em> in the most efficient way possible. <em>src</em> and <em>dst</em> are <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like objects</span></a> or path names given as strings.</p> <p><em>dst</em> must be the complete target file name; look at <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code>copy()</code></a> for a copy that accepts a target directory path. If <em>src</em> and <em>dst</em> specify the same file, <a class="reference internal" href="#shutil.SameFileError" title="shutil.SameFileError"><code>SameFileError</code></a> is raised.</p> <p>The destination location must be writable; otherwise, an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> exception will be raised. If <em>dst</em> already exists, it will be replaced. Special files such as character or block devices and pipes cannot be copied with this function.</p> <p>If <em>follow_symlinks</em> is false and <em>src</em> is a symbolic link, a new symbolic link will be created instead of copying the file <em>src</em> points to.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.copyfile</code> with arguments <code>src</code>, <code>dst</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span><a class="reference internal" href="exceptions.html#IOError" title="IOError"><code>IOError</code></a> used to be raised instead of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a>. Added <em>follow_symlinks</em> argument. Now returns <em>dst</em>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Raise <a class="reference internal" href="#shutil.SameFileError" title="shutil.SameFileError"><code>SameFileError</code></a> instead of <a class="reference internal" href="#shutil.Error" title="shutil.Error"><code>Error</code></a>. Since the former is a subclass of the latter, this change is backward compatible.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Platform-specific fast-copy syscalls may be used internally in order to copy the file more efficiently. See <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">Platform-dependent efficient copy operations</span></a> section.</p> </div> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="shutil.SameFileError">
<code>exception shutil.SameFileError</code> </dt> <dd>
<p>This exception is raised if source and destination in <a class="reference internal" href="#shutil.copyfile" title="shutil.copyfile"><code>copyfile()</code></a> are the same file.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.copymode">
<code>shutil.copymode(src, dst, *, follow_symlinks=True)</code> </dt> <dd>
<p>Copy the permission bits from <em>src</em> to <em>dst</em>. The file contents, owner, and group are unaffected. <em>src</em> and <em>dst</em> are <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like objects</span></a> or path names given as strings. If <em>follow_symlinks</em> is false, and both <em>src</em> and <em>dst</em> are symbolic links, <a class="reference internal" href="#shutil.copymode" title="shutil.copymode"><code>copymode()</code></a> will attempt to modify the mode of <em>dst</em> itself (rather than the file it points to). This functionality is not available on every platform; please see <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a> for more information. If <a class="reference internal" href="#shutil.copymode" title="shutil.copymode"><code>copymode()</code></a> cannot modify symbolic links on the local platform, and it is asked to do so, it will do nothing and return.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.copymode</code> with arguments <code>src</code>, <code>dst</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added <em>follow_symlinks</em> argument.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.copystat">
<code>shutil.copystat(src, dst, *, follow_symlinks=True)</code> </dt> <dd>
<p>Copy the permission bits, last access time, last modification time, and flags from <em>src</em> to <em>dst</em>. On Linux, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a> also copies the “extended attributes” where possible. The file contents, owner, and group are unaffected. <em>src</em> and <em>dst</em> are <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like objects</span></a> or path names given as strings.</p> <p>If <em>follow_symlinks</em> is false, and <em>src</em> and <em>dst</em> both refer to symbolic links, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a> will operate on the symbolic links themselves rather than the files the symbolic links refer to—reading the information from the <em>src</em> symbolic link, and writing the information to the <em>dst</em> symbolic link.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Not all platforms provide the ability to examine and modify symbolic links. Python itself can tell you what functionality is locally available.</p> <ul class="simple"> <li>If <code>os.chmod in os.supports_follow_symlinks</code> is <code>True</code>, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a> can modify the permission bits of a symbolic link.</li> <li>If <code>os.utime in os.supports_follow_symlinks</code> is <code>True</code>, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a> can modify the last access and modification times of a symbolic link.</li> <li>If <code>os.chflags in os.supports_follow_symlinks</code> is <code>True</code>, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a> can modify the flags of a symbolic link. (<code>os.chflags</code> is not available on all platforms.)</li> </ul> <p>On platforms where some or all of this functionality is unavailable, when asked to modify a symbolic link, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a> will copy everything it can. <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a> never returns failure.</p> <p>Please see <a class="reference internal" href="os.html#os.supports_follow_symlinks" title="os.supports_follow_symlinks"><code>os.supports_follow_symlinks</code></a> for more information.</p> </div> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.copystat</code> with arguments <code>src</code>, <code>dst</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added <em>follow_symlinks</em> argument and support for Linux extended attributes.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.copy">
<code>shutil.copy(src, dst, *, follow_symlinks=True)</code> </dt> <dd>
<p>Copies the file <em>src</em> to the file or directory <em>dst</em>. <em>src</em> and <em>dst</em> should be <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like objects</span></a> or strings. If <em>dst</em> specifies a directory, the file will be copied into <em>dst</em> using the base filename from <em>src</em>. If <em>dst</em> specifies a file that already exists, it will be replaced. Returns the path to the newly created file.</p> <p>If <em>follow_symlinks</em> is false, and <em>src</em> is a symbolic link, <em>dst</em> will be created as a symbolic link. If <em>follow_symlinks</em> is true and <em>src</em> is a symbolic link, <em>dst</em> will be a copy of the file <em>src</em> refers to.</p> <p><a class="reference internal" href="#shutil.copy" title="shutil.copy"><code>copy()</code></a> copies the file data and the file’s permission mode (see <a class="reference internal" href="os.html#os.chmod" title="os.chmod"><code>os.chmod()</code></a>). Other metadata, like the file’s creation and modification times, is not preserved. To preserve all file metadata from the original, use <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>copy2()</code></a> instead.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.copyfile</code> with arguments <code>src</code>, <code>dst</code>.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.copymode</code> with arguments <code>src</code>, <code>dst</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added <em>follow_symlinks</em> argument. Now returns path to the newly created file.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Platform-specific fast-copy syscalls may be used internally in order to copy the file more efficiently. See <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">Platform-dependent efficient copy operations</span></a> section.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.copy2">
<code>shutil.copy2(src, dst, *, follow_symlinks=True)</code> </dt> <dd>
<p>Identical to <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code>copy()</code></a> except that <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>copy2()</code></a> also attempts to preserve file metadata.</p> <p>When <em>follow_symlinks</em> is false, and <em>src</em> is a symbolic link, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>copy2()</code></a> attempts to copy all metadata from the <em>src</em> symbolic link to the newly created <em>dst</em> symbolic link. However, this functionality is not available on all platforms. On platforms where some or all of this functionality is unavailable, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>copy2()</code></a> will preserve all the metadata it can; <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>copy2()</code></a> never raises an exception because it cannot preserve file metadata.</p> <p><a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>copy2()</code></a> uses <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a> to copy the file metadata. Please see <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a> for more information about platform support for modifying symbolic link metadata.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.copyfile</code> with arguments <code>src</code>, <code>dst</code>.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.copystat</code> with arguments <code>src</code>, <code>dst</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added <em>follow_symlinks</em> argument, try to copy extended file system attributes too (currently Linux only). Now returns path to the newly created file.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Platform-specific fast-copy syscalls may be used internally in order to copy the file more efficiently. See <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">Platform-dependent efficient copy operations</span></a> section.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.ignore_patterns">
<code>shutil.ignore_patterns(*patterns)</code> </dt> <dd>
<p>This factory function creates a function that can be used as a callable for <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code>copytree()</code></a>'s <em>ignore</em> argument, ignoring files and directories that match one of the glob-style <em>patterns</em> provided. See the example below.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.copytree">
<code>shutil.copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False, dirs_exist_ok=False)</code> </dt> <dd>
<p>Recursively copy an entire directory tree rooted at <em>src</em> to a directory named <em>dst</em> and return the destination directory. All intermediate directories needed to contain <em>dst</em> will also be created by default.</p> <p>Permissions and times of directories are copied with <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code>copystat()</code></a>, individual files are copied using <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>copy2()</code></a>.</p> <p>If <em>symlinks</em> is true, symbolic links in the source tree are represented as symbolic links in the new tree and the metadata of the original links will be copied as far as the platform allows; if false or omitted, the contents and metadata of the linked files are copied to the new tree.</p> <p>When <em>symlinks</em> is false, if the file pointed to by the symlink doesn’t exist, an exception will be added in the list of errors raised in an <a class="reference internal" href="#shutil.Error" title="shutil.Error"><code>Error</code></a> exception at the end of the copy process. You can set the optional <em>ignore_dangling_symlinks</em> flag to true if you want to silence this exception. Notice that this option has no effect on platforms that don’t support <a class="reference internal" href="os.html#os.symlink" title="os.symlink"><code>os.symlink()</code></a>.</p> <p>If <em>ignore</em> is given, it must be a callable that will receive as its arguments the directory being visited by <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code>copytree()</code></a>, and a list of its contents, as returned by <a class="reference internal" href="os.html#os.listdir" title="os.listdir"><code>os.listdir()</code></a>. Since <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code>copytree()</code></a> is called recursively, the <em>ignore</em> callable will be called once for each directory that is copied. The callable must return a sequence of directory and file names relative to the current directory (i.e. a subset of the items in its second argument); these names will then be ignored in the copy process. <a class="reference internal" href="#shutil.ignore_patterns" title="shutil.ignore_patterns"><code>ignore_patterns()</code></a> can be used to create such a callable that ignores names based on glob-style patterns.</p> <p>If exception(s) occur, an <a class="reference internal" href="#shutil.Error" title="shutil.Error"><code>Error</code></a> is raised with a list of reasons.</p> <p>If <em>copy_function</em> is given, it must be a callable that will be used to copy each file. It will be called with the source path and the destination path as arguments. By default, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>copy2()</code></a> is used, but any function that supports the same signature (like <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code>copy()</code></a>) can be used.</p> <p>If <em>dirs_exist_ok</em> is false (the default) and <em>dst</em> already exists, a <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a> is raised. If <em>dirs_exist_ok</em> is true, the copying operation will continue if it encounters existing directories, and files within the <em>dst</em> tree will be overwritten by corresponding files from the <em>src</em> tree.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.copytree</code> with arguments <code>src</code>, <code>dst</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Added the <em>copy_function</em> argument to be able to provide a custom copy function. Added the <em>ignore_dangling_symlinks</em> argument to silence dangling symlinks errors when <em>symlinks</em> is false.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Copy metadata when <em>symlinks</em> is false. Now returns <em>dst</em>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Platform-specific fast-copy syscalls may be used internally in order to copy the file more efficiently. See <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">Platform-dependent efficient copy operations</span></a> section.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added the <em>dirs_exist_ok</em> parameter.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.rmtree">
<code>shutil.rmtree(path, ignore_errors=False, onerror=None, *, onexc=None, dir_fd=None)</code> </dt> <dd>
<p id="index-1">Delete an entire directory tree; <em>path</em> must point to a directory (but not a symbolic link to a directory). If <em>ignore_errors</em> is true, errors resulting from failed removals will be ignored; if false or omitted, such errors are handled by calling a handler specified by <em>onexc</em> or <em>onerror</em> or, if both are omitted, exceptions are propagated to the caller.</p> <p>This function can support <a class="reference internal" href="os.html#dir-fd"><span class="std std-ref">paths relative to directory descriptors</span></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>On platforms that support the necessary fd-based functions a symlink attack resistant version of <a class="reference internal" href="#shutil.rmtree" title="shutil.rmtree"><code>rmtree()</code></a> is used by default. On other platforms, the <a class="reference internal" href="#shutil.rmtree" title="shutil.rmtree"><code>rmtree()</code></a> implementation is susceptible to a symlink attack: given proper timing and circumstances, attackers can manipulate symlinks on the filesystem to delete files they wouldn’t be able to access otherwise. Applications can use the <a class="reference internal" href="#shutil.rmtree.avoids_symlink_attacks" title="shutil.rmtree.avoids_symlink_attacks"><code>rmtree.avoids_symlink_attacks</code></a> function attribute to determine which case applies.</p> </div> <p>If <em>onexc</em> is provided, it must be a callable that accepts three parameters: <em>function</em>, <em>path</em>, and <em>excinfo</em>.</p> <p>The first parameter, <em>function</em>, is the function which raised the exception; it depends on the platform and implementation. The second parameter, <em>path</em>, will be the path name passed to <em>function</em>. The third parameter, <em>excinfo</em>, is the exception that was raised. Exceptions raised by <em>onexc</em> will not be caught.</p> <p>The deprecated <em>onerror</em> is similar to <em>onexc</em>, except that the third parameter it receives is the tuple returned from <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a>.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.rmtree</code> with arguments <code>path</code>, <code>dir_fd</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added a symlink attack resistant version that is used automatically if platform supports fd-based functions.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>On Windows, will no longer delete the contents of a directory junction before removing the junction.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Added the <em>dir_fd</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Added the <em>onexc</em> parameter, deprecated <em>onerror</em>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span><code>rmtree()</code> now ignores <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code>FileNotFoundError</code></a> exceptions for all but the top-level path. Exceptions other than <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> and subclasses of <code>OSError</code> are now always propagated to the caller.</p> </div> <dl class="py attribute"> <dt class="sig sig-object py" id="shutil.rmtree.avoids_symlink_attacks">
<code>rmtree.avoids_symlink_attacks</code> </dt> <dd>
<p>Indicates whether the current platform and implementation provides a symlink attack resistant version of <a class="reference internal" href="#shutil.rmtree" title="shutil.rmtree"><code>rmtree()</code></a>. Currently this is only true for platforms supporting fd-based directory access functions.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.move">
<code>shutil.move(src, dst, copy_function=copy2)</code> </dt> <dd>
<p>Recursively move a file or directory (<em>src</em>) to another location and return the destination.</p> <p>If <em>dst</em> is an existing directory or a symlink to a directory, then <em>src</em> is moved inside that directory. The destination path in that directory must not already exist.</p> <p>If <em>dst</em> already exists but is not a directory, it may be overwritten depending on <a class="reference internal" href="os.html#os.rename" title="os.rename"><code>os.rename()</code></a> semantics.</p> <p>If the destination is on the current filesystem, then <a class="reference internal" href="os.html#os.rename" title="os.rename"><code>os.rename()</code></a> is used. Otherwise, <em>src</em> is copied to the destination using <em>copy_function</em> and then removed. In case of symlinks, a new symlink pointing to the target of <em>src</em> will be created as the destination and <em>src</em> will be removed.</p> <p>If <em>copy_function</em> is given, it must be a callable that takes two arguments, <em>src</em> and the destination, and will be used to copy <em>src</em> to the destination if <a class="reference internal" href="os.html#os.rename" title="os.rename"><code>os.rename()</code></a> cannot be used. If the source is a directory, <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code>copytree()</code></a> is called, passing it the <em>copy_function</em>. The default <em>copy_function</em> is <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>copy2()</code></a>. Using <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code>copy()</code></a> as the <em>copy_function</em> allows the move to succeed when it is not possible to also copy the metadata, at the expense of not copying any of the metadata.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.move</code> with arguments <code>src</code>, <code>dst</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added explicit symlink handling for foreign filesystems, thus adapting it to the behavior of GNU’s <strong class="program">mv</strong>. Now returns <em>dst</em>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Added the <em>copy_function</em> keyword argument.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Platform-specific fast-copy syscalls may be used internally in order to copy the file more efficiently. See <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">Platform-dependent efficient copy operations</span></a> section.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a> for both <em>src</em> and <em>dst</em>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.disk_usage">
<code>shutil.disk_usage(path)</code> </dt> <dd>
<p>Return disk usage statistics about the given path as a <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> with the attributes <em>total</em>, <em>used</em> and <em>free</em>, which are the amount of total, used and free space, in bytes. <em>path</em> may be a file or a directory.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>On Unix filesystems, <em>path</em> must point to a path within a <strong>mounted</strong> filesystem partition. On those platforms, CPython doesn’t attempt to retrieve disk usage information from non-mounted filesystems.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>On Windows, <em>path</em> can now be a file or directory.</p> </div> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, Windows.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.chown">
<code>shutil.chown(path, user=None, group=None, *, dir_fd=None, follow_symlinks=True)</code> </dt> <dd>
<p>Change owner <em>user</em> and/or <em>group</em> of the given <em>path</em>.</p> <p><em>user</em> can be a system user name or a uid; the same applies to <em>group</em>. At least one argument is required.</p> <p>See also <a class="reference internal" href="os.html#os.chown" title="os.chown"><code>os.chown()</code></a>, the underlying function.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.chown</code> with arguments <code>path</code>, <code>user</code>, <code>group</code>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Added <em>dir_fd</em> and <em>follow_symlinks</em> parameters.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.which">
<code>shutil.which(cmd, mode=os.F_OK | os.X_OK, path=None)</code> </dt> <dd>
<p>Return the path to an executable which would be run if the given <em>cmd</em> was called. If no <em>cmd</em> would be called, return <code>None</code>.</p> <p><em>mode</em> is a permission mask passed to <a class="reference internal" href="os.html#os.access" title="os.access"><code>os.access()</code></a>, by default determining if the file exists and is executable.</p> <p><em>path</em> is a “<code>PATH</code> string” specifying the lookup directory list. When no <em>path</em> is specified, the results of <a class="reference internal" href="os.html#os.environ" title="os.environ"><code>os.environ()</code></a> are used, returning either the “PATH” value or a fallback of <a class="reference internal" href="os.html#os.defpath" title="os.defpath"><code>os.defpath</code></a>.</p> <p>On Windows, the current directory is prepended to the <em>path</em> if <em>mode</em> does not include <code>os.X_OK</code>. When the <em>mode</em> does include <code>os.X_OK</code>, the Windows API <code>NeedCurrentDirectoryForExePathW</code> will be consulted to determine if the current directory should be prepended to <em>path</em>. To avoid consulting the current working directory for executables: set the environment variable <code>NoDefaultCurrentDirectoryInExePath</code>.</p> <p>Also on Windows, the <code>PATHEXT</code> variable is used to resolve commands that may not already include an extension. For example, if you call <code>shutil.which("python")</code>, <a class="reference internal" href="#shutil.which" title="shutil.which"><code>which()</code></a> will search <code>PATHEXT</code> to know that it should look for <code>python.exe</code> within the <em>path</em> directories. For example, on Windows:</p> <pre data-language="python">&gt;&gt;&gt; shutil.which("python")
'C:\\Python33\\python.EXE'
</pre> <p>This is also applied when <em>cmd</em> is a path that contains a directory component:</p> <pre data-language="python">&gt;&gt; shutil.which("C:\\Python33\\python")
'C:\\Python33\\python.EXE'
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>The <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> type is now accepted. If <em>cmd</em> type is <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>, the result type is also <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>On Windows, the current directory is no longer prepended to the search path if <em>mode</em> includes <code>os.X_OK</code> and WinAPI <code>NeedCurrentDirectoryForExePathW(cmd)</code> is false, else the current directory is prepended even if it is already in the search path; <code>PATHEXT</code> is used now even when <em>cmd</em> includes a directory component or ends with an extension that is in <code>PATHEXT</code>; and filenames that have no extension can now be found.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12.1: </span>On Windows, if <em>mode</em> includes <code>os.X_OK</code>, executables with an extension in <code>PATHEXT</code> will be preferred over executables without a matching extension. This brings behavior closer to that of Python 3.11.</p> </div> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="shutil.Error">
<code>exception shutil.Error</code> </dt> <dd>
<p>This exception collects exceptions that are raised during a multi-file operation. For <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code>copytree()</code></a>, the exception argument is a list of 3-tuples (<em>srcname</em>, <em>dstname</em>, <em>exception</em>).</p> </dd>
</dl> <section id="platform-dependent-efficient-copy-operations"> <span id="shutil-platform-dependent-efficient-copy-operations"></span><h3>Platform-dependent efficient copy operations</h3> <p>Starting from Python 3.8, all functions involving a file copy (<a class="reference internal" href="#shutil.copyfile" title="shutil.copyfile"><code>copyfile()</code></a>, <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code>copy()</code></a>, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code>copy2()</code></a>, <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code>copytree()</code></a>, and <a class="reference internal" href="#shutil.move" title="shutil.move"><code>move()</code></a>) may use platform-specific “fast-copy” syscalls in order to copy the file more efficiently (see <a class="reference external" href="https://bugs.python.org/issue?@action=redirect&amp;bpo=33671">bpo-33671</a>). “fast-copy” means that the copying operation occurs within the kernel, avoiding the use of userspace buffers in Python as in “<code>outfd.write(infd.read())</code>”.</p> <p>On macOS <a class="reference external" href="http://www.manpagez.com/man/3/copyfile/">fcopyfile</a> is used to copy the file content (not metadata).</p> <p>On Linux <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code>os.sendfile()</code></a> is used.</p> <p>On Windows <a class="reference internal" href="#shutil.copyfile" title="shutil.copyfile"><code>shutil.copyfile()</code></a> uses a bigger default buffer size (1 MiB instead of 64 KiB) and a <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code>memoryview()</code></a>-based variant of <a class="reference internal" href="#shutil.copyfileobj" title="shutil.copyfileobj"><code>shutil.copyfileobj()</code></a> is used.</p> <p>If the fast-copy operation fails and no data was written in the destination file then shutil will silently fallback on using less efficient <a class="reference internal" href="#shutil.copyfileobj" title="shutil.copyfileobj"><code>copyfileobj()</code></a> function internally.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8.</span></p> </div> </section> <section id="copytree-example"> <span id="shutil-copytree-example"></span><h3>copytree example</h3> <p>An example that uses the <a class="reference internal" href="#shutil.ignore_patterns" title="shutil.ignore_patterns"><code>ignore_patterns()</code></a> helper:</p> <pre data-language="python">from shutil import copytree, ignore_patterns

copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))
</pre> <p>This will copy everything except <code>.pyc</code> files and files or directories whose name starts with <code>tmp</code>.</p> <p>Another example that uses the <em>ignore</em> argument to add a logging call:</p> <pre data-language="python">from shutil import copytree
import logging

def _logpath(path, names):
    logging.info('Working in %s', path)
    return []   # nothing will be ignored

copytree(source, destination, ignore=_logpath)
</pre> </section> <section id="rmtree-example"> <span id="shutil-rmtree-example"></span><h3>rmtree example</h3> <p>This example shows how to remove a directory tree on Windows where some of the files have their read-only bit set. It uses the onexc callback to clear the readonly bit and reattempt the remove. Any subsequent failure will propagate.</p> <pre data-language="python">import os, stat
import shutil

def remove_readonly(func, path, _):
    "Clear the readonly bit and reattempt the removal"
    os.chmod(path, stat.S_IWRITE)
    func(path)

shutil.rmtree(directory, onexc=remove_readonly)
</pre> </section> </section> <section id="archiving-operations"> <span id="id1"></span><h2>Archiving operations</h2> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Added support for the <em>xztar</em> format.</p> </div> <p>High-level utilities to create and read compressed and archived files are also provided. They rely on the <a class="reference internal" href="zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code>zipfile</code></a> and <a class="reference internal" href="tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code>tarfile</code></a> modules.</p> <dl class="py function"> <dt class="sig sig-object py" id="shutil.make_archive">
<code>shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])</code> </dt> <dd>
<p>Create an archive file (such as zip or tar) and return its name.</p> <p><em>base_name</em> is the name of the file to create, including the path, minus any format-specific extension.</p> <p><em>format</em> is the archive format: one of “zip” (if the <a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code>zlib</code></a> module is available), “tar”, “gztar” (if the <a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code>zlib</code></a> module is available), “bztar” (if the <a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code>bz2</code></a> module is available), or “xztar” (if the <a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code>lzma</code></a> module is available).</p> <p><em>root_dir</em> is a directory that will be the root directory of the archive, all paths in the archive will be relative to it; for example, we typically chdir into <em>root_dir</em> before creating the archive.</p> <p><em>base_dir</em> is the directory where we start archiving from; i.e. <em>base_dir</em> will be the common prefix of all files and directories in the archive. <em>base_dir</em> must be given relative to <em>root_dir</em>. See <a class="reference internal" href="#shutil-archiving-example-with-basedir"><span class="std std-ref">Archiving example with base_dir</span></a> for how to use <em>base_dir</em> and <em>root_dir</em> together.</p> <p><em>root_dir</em> and <em>base_dir</em> both default to the current directory.</p> <p>If <em>dry_run</em> is true, no archive is created, but the operations that would be executed are logged to <em>logger</em>.</p> <p><em>owner</em> and <em>group</em> are used when creating a tar archive. By default, uses the current owner and group.</p> <p><em>logger</em> must be an object compatible with <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0282/"><strong>PEP 282</strong></a>, usually an instance of <a class="reference internal" href="logging.html#logging.Logger" title="logging.Logger"><code>logging.Logger</code></a>.</p> <p>The <em>verbose</em> argument is unused and deprecated.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.make_archive</code> with arguments <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is not thread-safe when custom archivers registered with <a class="reference internal" href="#shutil.register_archive_format" title="shutil.register_archive_format"><code>register_archive_format()</code></a> do not support the <em>root_dir</em> argument. In this case it temporarily changes the current working directory of the process to <em>root_dir</em> to perform archiving.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU format for archives created with <code>format="tar"</code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10.6: </span>This function is now made thread-safe during creation of standard <code>.zip</code> and tar archives.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.get_archive_formats">
<code>shutil.get_archive_formats()</code> </dt> <dd>
<p>Return a list of supported formats for archiving. Each element of the returned sequence is a tuple <code>(name, description)</code>.</p> <p>By default <a class="reference internal" href="#module-shutil" title="shutil: High-level file operations, including copying."><code>shutil</code></a> provides these formats:</p> <ul class="simple"> <li>
<em>zip</em>: ZIP file (if the <a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code>zlib</code></a> module is available).</li> <li>
<em>tar</em>: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives.</li> <li>
<em>gztar</em>: gzip’ed tar-file (if the <a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code>zlib</code></a> module is available).</li> <li>
<em>bztar</em>: bzip2’ed tar-file (if the <a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code>bz2</code></a> module is available).</li> <li>
<em>xztar</em>: xz’ed tar-file (if the <a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code>lzma</code></a> module is available).</li> </ul> <p>You can register new formats or provide your own archiver for any existing formats, by using <a class="reference internal" href="#shutil.register_archive_format" title="shutil.register_archive_format"><code>register_archive_format()</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.register_archive_format">
<code>shutil.register_archive_format(name, function[, extra_args[, description]])</code> </dt> <dd>
<p>Register an archiver for the format <em>name</em>.</p> <p><em>function</em> is the callable that will be used to unpack archives. The callable will receive the <em>base_name</em> of the file to create, followed by the <em>base_dir</em> (which defaults to <a class="reference internal" href="os.html#os.curdir" title="os.curdir"><code>os.curdir</code></a>) to start archiving from. Further arguments are passed as keyword arguments: <em>owner</em>, <em>group</em>, <em>dry_run</em> and <em>logger</em> (as passed in <a class="reference internal" href="#shutil.make_archive" title="shutil.make_archive"><code>make_archive()</code></a>).</p> <p>If <em>function</em> has the custom attribute <code>function.supports_root_dir</code> set to <code>True</code>, the <em>root_dir</em> argument is passed as a keyword argument. Otherwise the current working directory of the process is temporarily changed to <em>root_dir</em> before calling <em>function</em>. In this case <a class="reference internal" href="#shutil.make_archive" title="shutil.make_archive"><code>make_archive()</code></a> is not thread-safe.</p> <p>If given, <em>extra_args</em> is a sequence of <code>(name, value)</code> pairs that will be used as extra keywords arguments when the archiver callable is used.</p> <p><em>description</em> is used by <a class="reference internal" href="#shutil.get_archive_formats" title="shutil.get_archive_formats"><code>get_archive_formats()</code></a> which returns the list of archivers. Defaults to an empty string.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Added support for functions supporting the <em>root_dir</em> argument.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.unregister_archive_format">
<code>shutil.unregister_archive_format(name)</code> </dt> <dd>
<p>Remove the archive format <em>name</em> from the list of supported formats.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.unpack_archive">
<code>shutil.unpack_archive(filename[, extract_dir[, format[, filter]]])</code> </dt> <dd>
<p>Unpack an archive. <em>filename</em> is the full path of the archive.</p> <p><em>extract_dir</em> is the name of the target directory where the archive is unpacked. If not provided, the current working directory is used.</p> <p><em>format</em> is the archive format: one of “zip”, “tar”, “gztar”, “bztar”, or “xztar”. Or any other format registered with <a class="reference internal" href="#shutil.register_unpack_format" title="shutil.register_unpack_format"><code>register_unpack_format()</code></a>. If not provided, <a class="reference internal" href="#shutil.unpack_archive" title="shutil.unpack_archive"><code>unpack_archive()</code></a> will use the archive file name extension and see if an unpacker was registered for that extension. In case none is found, a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised.</p> <p>The keyword-only <em>filter</em> argument is passed to the underlying unpacking function. For zip files, <em>filter</em> is not accepted. For tar files, it is recommended to set it to <code>'data'</code>, unless using features specific to tar and UNIX-like filesystems. (See <a class="reference internal" href="tarfile.html#tarfile-extraction-filter"><span class="std std-ref">Extraction filters</span></a> for details.) The <code>'data'</code> filter will become the default for tar files in Python 3.14.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>shutil.unpack_archive</code> with arguments <code>filename</code>, <code>extract_dir</code>, <code>format</code>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Never extract archives from untrusted sources without prior inspection. It is possible that files are created outside of the path specified in the <em>extract_dir</em> argument, e.g. members that have absolute filenames starting with “/” or filenames with two dots “..”.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a> for <em>filename</em> and <em>extract_dir</em>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Added the <em>filter</em> argument.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.register_unpack_format">
<code>shutil.register_unpack_format(name, extensions, function[, extra_args[, description]])</code> </dt> <dd>
<p>Registers an unpack format. <em>name</em> is the name of the format and <em>extensions</em> is a list of extensions corresponding to the format, like <code>.zip</code> for Zip files.</p> <p><em>function</em> is the callable that will be used to unpack archives. The callable will receive:</p> <ul class="simple"> <li>the path of the archive, as a positional argument;</li> <li>the directory the archive must be extracted to, as a positional argument;</li> <li>possibly a <em>filter</em> keyword argument, if it was given to <a class="reference internal" href="#shutil.unpack_archive" title="shutil.unpack_archive"><code>unpack_archive()</code></a>;</li> <li>additional keyword arguments, specified by <em>extra_args</em> as a sequence of <code>(name, value)</code> tuples.</li> </ul> <p><em>description</em> can be provided to describe the format, and will be returned by the <a class="reference internal" href="#shutil.get_unpack_formats" title="shutil.get_unpack_formats"><code>get_unpack_formats()</code></a> function.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.unregister_unpack_format">
<code>shutil.unregister_unpack_format(name)</code> </dt> <dd>
<p>Unregister an unpack format. <em>name</em> is the name of the format.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="shutil.get_unpack_formats">
<code>shutil.get_unpack_formats()</code> </dt> <dd>
<p>Return a list of all registered formats for unpacking. Each element of the returned sequence is a tuple <code>(name, extensions, description)</code>.</p> <p>By default <a class="reference internal" href="#module-shutil" title="shutil: High-level file operations, including copying."><code>shutil</code></a> provides these formats:</p> <ul class="simple"> <li>
<em>zip</em>: ZIP file (unpacking compressed files works only if the corresponding module is available).</li> <li>
<em>tar</em>: uncompressed tar file.</li> <li>
<em>gztar</em>: gzip’ed tar-file (if the <a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code>zlib</code></a> module is available).</li> <li>
<em>bztar</em>: bzip2’ed tar-file (if the <a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code>bz2</code></a> module is available).</li> <li>
<em>xztar</em>: xz’ed tar-file (if the <a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code>lzma</code></a> module is available).</li> </ul> <p>You can register new formats or provide your own unpacker for any existing formats, by using <a class="reference internal" href="#shutil.register_unpack_format" title="shutil.register_unpack_format"><code>register_unpack_format()</code></a>.</p> </dd>
</dl> <section id="archiving-example"> <span id="shutil-archiving-example"></span><h3>Archiving example</h3> <p>In this example, we create a gzip’ed tar-file archive containing all files found in the <code>.ssh</code> directory of the user:</p> <pre data-language="python">&gt;&gt;&gt; from shutil import make_archive
&gt;&gt;&gt; import os
&gt;&gt;&gt; archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))
&gt;&gt;&gt; root_dir = os.path.expanduser(os.path.join('~', '.ssh'))
&gt;&gt;&gt; make_archive(archive_name, 'gztar', root_dir)
'/Users/tarek/myarchive.tar.gz'
</pre> <p>The resulting archive contains:</p> <pre data-language="shell">$ tar -tzvf /Users/tarek/myarchive.tar.gz
drwx------ tarek/staff       0 2010-02-01 16:23:40 ./
-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys
-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config
-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa
-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub
-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa
-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub
-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts
</pre> </section> <section id="archiving-example-with-base-dir"> <span id="shutil-archiving-example-with-basedir"></span><h3>Archiving example with <em>base_dir</em>
</h3> <p>In this example, similar to the <a class="reference internal" href="#shutil-archiving-example">one above</a>, we show how to use <a class="reference internal" href="#shutil.make_archive" title="shutil.make_archive"><code>make_archive()</code></a>, but this time with the usage of <em>base_dir</em>. We now have the following directory structure:</p> <pre data-language="shell">$ tree tmp
tmp
└── root
    └── structure
        ├── content
            └── please_add.txt
        └── do_not_add.txt
</pre> <p>In the final archive, <code>please_add.txt</code> should be included, but <code>do_not_add.txt</code> should not. Therefore we use the following:</p> <pre data-language="python">&gt;&gt;&gt; from shutil import make_archive
&gt;&gt;&gt; import os
&gt;&gt;&gt; archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))
&gt;&gt;&gt; make_archive(
...     archive_name,
...     'tar',
...     root_dir='tmp/root',
...     base_dir='structure/content',
... )
'/Users/tarek/my_archive.tar'
</pre> <p>Listing the files in the resulting archive gives us:</p> <pre data-language="shell">$ python -m tarfile -l /Users/tarek/myarchive.tar
structure/content/
structure/content/please_add.txt
</pre> </section> </section> <section id="querying-the-size-of-the-output-terminal"> <h2>Querying the size of the output terminal</h2> <dl class="py function"> <dt class="sig sig-object py" id="shutil.get_terminal_size">
<code>shutil.get_terminal_size(fallback=(columns, lines))</code> </dt> <dd>
<p>Get the size of the terminal window.</p> <p>For each of the two dimensions, the environment variable, <code>COLUMNS</code> and <code>LINES</code> respectively, is checked. If the variable is defined and the value is a positive integer, it is used.</p> <p>When <code>COLUMNS</code> or <code>LINES</code> is not defined, which is the common case, the terminal connected to <a class="reference internal" href="sys.html#sys.__stdout__" title="sys.__stdout__"><code>sys.__stdout__</code></a> is queried by invoking <a class="reference internal" href="os.html#os.get_terminal_size" title="os.get_terminal_size"><code>os.get_terminal_size()</code></a>.</p> <p>If the terminal size cannot be successfully queried, either because the system doesn’t support querying, or because we are not connected to a terminal, the value given in <code>fallback</code> parameter is used. <code>fallback</code> defaults to <code>(80, 24)</code> which is the default size used by many terminal emulators.</p> <p>The value returned is a named tuple of type <a class="reference internal" href="os.html#os.terminal_size" title="os.terminal_size"><code>os.terminal_size</code></a>.</p> <p>See also: The Single UNIX Specification, Version 2, <a class="reference external" href="https://pubs.opengroup.org/onlinepubs/7908799/xbd/envvar.html#tag_002_003">Other Environment Variables</a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>The <code>fallback</code> values are also used if <a class="reference internal" href="os.html#os.get_terminal_size" title="os.get_terminal_size"><code>os.get_terminal_size()</code></a> returns zeroes.</p> </div> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/shutil.html" class="_attribution-link">https://docs.python.org/3.13/library/shutil.html</a>
  </p>
</div>
