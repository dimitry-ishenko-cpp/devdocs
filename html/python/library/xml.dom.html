 <span id="xml-dom-the-document-object-model-api"></span><h1>xml.dom — The Document Object Model API</h1> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/xml/dom/__init__.py">Lib/xml/dom/__init__.py</a></p>  <p>The Document Object Model, or “DOM,” is a cross-language API from the World Wide Web Consortium (W3C) for accessing and modifying XML documents. A DOM implementation presents an XML document as a tree structure, or allows client code to build such a structure from scratch. It then gives access to the structure through a set of objects which provided well-known interfaces.</p> <p>The DOM is extremely useful for random-access applications. SAX only allows you a view of one bit of the document at a time. If you are looking at one SAX element, you have no access to another. If you are looking at a text node, you have no access to a containing element. When you write a SAX application, you need to keep track of your program’s position in the document somewhere in your own code. SAX does not do it for you. Also, if you need to look ahead in the XML document, you are just out of luck.</p> <p>Some applications are simply impossible in an event driven model with no access to a tree. Of course you could build some sort of tree yourself in SAX events, but the DOM allows you to avoid writing that code. The DOM is a standard tree representation for XML data.</p> <p>The Document Object Model is being defined by the W3C in stages, or “levels” in their terminology. The Python mapping of the API is substantially based on the DOM Level 2 recommendation.</p> <p>DOM applications typically start by parsing some XML into a DOM. How this is accomplished is not covered at all by DOM Level 1, and Level 2 provides only limited improvements: There is a <code>DOMImplementation</code> object class which provides access to <code>Document</code> creation methods, but no way to access an XML reader/parser/Document builder in an implementation-independent way. There is also no well-defined way to access these methods without an existing <code>Document</code> object. In Python, each DOM implementation will provide a function <a class="reference internal" href="#xml.dom.getDOMImplementation" title="xml.dom.getDOMImplementation"><code>getDOMImplementation()</code></a>. DOM Level 3 adds a Load/Store specification, which defines an interface to the reader, but this is not yet available in the Python standard library.</p> <p>Once you have a DOM document object, you can access the parts of your XML document through its properties and methods. These properties are defined in the DOM specification; this portion of the reference manual describes the interpretation of the specification in Python.</p> <p>The specification provided by the W3C defines the DOM API for Java, ECMAScript, and OMG IDL. The Python mapping defined here is based in large part on the IDL version of the specification, but strict compliance is not required (though implementations are free to support the strict mapping from IDL). See section <a class="reference internal" href="#dom-conformance"><span class="std std-ref">Conformance</span></a> for a detailed discussion of mapping requirements.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/">Document Object Model (DOM) Level 2 Specification</a></dt>
<dd>
<p>The W3C recommendation upon which the Python DOM API is based.</p> </dd> <dt><a class="reference external" href="https://www.w3.org/TR/REC-DOM-Level-1/">Document Object Model (DOM) Level 1 Specification</a></dt>
<dd>
<p>The W3C recommendation for the DOM supported by <a class="reference internal" href="xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code>xml.dom.minidom</code></a>.</p> </dd> <dt><a class="reference external" href="https://www.omg.org/spec/PYTH/1.2/PDF">Python Language Mapping Specification</a></dt>
<dd>
<p>This specifies the mapping from OMG IDL to Python.</p> </dd> </dl> </div> <section id="module-contents"> <h2>Module Contents</h2> <p>The <a class="reference internal" href="#module-xml.dom" title="xml.dom: Document Object Model API for Python."><code>xml.dom</code></a> contains the following functions:</p> <dl class="py function"> <dt class="sig sig-object py" id="xml.dom.registerDOMImplementation">
<code>xml.dom.registerDOMImplementation(name, factory)</code> </dt> <dd>
<p>Register the <em>factory</em> function with the name <em>name</em>. The factory function should return an object which implements the <code>DOMImplementation</code> interface. The factory function can return the same object every time, or a new one for each call, as appropriate for the specific implementation (e.g. if that implementation supports some customization).</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="xml.dom.getDOMImplementation">
<code>xml.dom.getDOMImplementation(name=None, features=())</code> </dt> <dd>
<p>Return a suitable DOM implementation. The <em>name</em> is either well-known, the module name of a DOM implementation, or <code>None</code>. If it is not <code>None</code>, imports the corresponding module and returns a <code>DOMImplementation</code> object if the import succeeds. If no name is given, and if the environment variable <span class="target" id="index-0"></span><code>PYTHON_DOM</code> is set, this variable is used to find the implementation.</p> <p>If name is not given, this examines the available implementations to find one with the required feature set. If no implementation can be found, raise an <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code>ImportError</code></a>. The features list must be a sequence of <code>(feature,
version)</code> pairs which are passed to the <code>hasFeature()</code> method on available <code>DOMImplementation</code> objects.</p> </dd>
</dl> <p>Some convenience constants are also provided:</p> <dl class="py data"> <dt class="sig sig-object py" id="xml.dom.EMPTY_NAMESPACE">
<code>xml.dom.EMPTY_NAMESPACE</code> </dt> <dd>
<p>The value used to indicate that no namespace is associated with a node in the DOM. This is typically found as the <code>namespaceURI</code> of a node, or used as the <em>namespaceURI</em> parameter to a namespaces-specific method.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.dom.XML_NAMESPACE">
<code>xml.dom.XML_NAMESPACE</code> </dt> <dd>
<p>The namespace URI associated with the reserved prefix <code>xml</code>, as defined by <a class="reference external" href="https://www.w3.org/TR/REC-xml-names/">Namespaces in XML</a> (section 4).</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.dom.XMLNS_NAMESPACE">
<code>xml.dom.XMLNS_NAMESPACE</code> </dt> <dd>
<p>The namespace URI for namespace declarations, as defined by <a class="reference external" href="https://www.w3.org/TR/DOM-Level-2-Core/core.html">Document Object Model (DOM) Level 2 Core Specification</a> (section 1.1.8).</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.dom.XHTML_NAMESPACE">
<code>xml.dom.XHTML_NAMESPACE</code> </dt> <dd>
<p>The URI of the XHTML namespace as defined by <a class="reference external" href="https://www.w3.org/TR/xhtml1/">XHTML 1.0: The Extensible HyperText Markup Language</a> (section 3.1.1).</p> </dd>
</dl> <p>In addition, <a class="reference internal" href="#module-xml.dom" title="xml.dom: Document Object Model API for Python."><code>xml.dom</code></a> contains a base <code>Node</code> class and the DOM exception classes. The <code>Node</code> class provided by this module does not implement any of the methods or attributes defined by the DOM specification; concrete DOM implementations must provide those. The <code>Node</code> class provided as part of this module does provide the constants used for the <code>nodeType</code> attribute on concrete <code>Node</code> objects; they are located within the class rather than at the module level to conform with the DOM specifications.</p> </section> <section id="objects-in-the-dom"> <span id="dom-objects"></span><h2>Objects in the DOM</h2> <p>The definitive documentation for the DOM is the DOM specification from the W3C.</p> <p>Note that DOM attributes may also be manipulated as nodes instead of as simple strings. It is fairly rare that you must do this, however, so this usage is not yet documented.</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Interface</p></th> <th class="head"><p>Section</p></th> <th class="head"><p>Purpose</p></th> </tr> </thead>  <tr>
<td><p><code>DOMImplementation</code></p></td> <td><p><a class="reference internal" href="#dom-implementation-objects"><span class="std std-ref">DOMImplementation Objects</span></a></p></td> <td><p>Interface to the underlying implementation.</p></td> </tr> <tr>
<td><p><code>Node</code></p></td> <td><p><a class="reference internal" href="#dom-node-objects"><span class="std std-ref">Node Objects</span></a></p></td> <td><p>Base interface for most objects in a document.</p></td> </tr> <tr>
<td><p><code>NodeList</code></p></td> <td><p><a class="reference internal" href="#dom-nodelist-objects"><span class="std std-ref">NodeList Objects</span></a></p></td> <td><p>Interface for a sequence of nodes.</p></td> </tr> <tr>
<td><p><code>DocumentType</code></p></td> <td><p><a class="reference internal" href="#dom-documenttype-objects"><span class="std std-ref">DocumentType Objects</span></a></p></td> <td><p>Information about the declarations needed to process a document.</p></td> </tr> <tr>
<td><p><code>Document</code></p></td> <td><p><a class="reference internal" href="#dom-document-objects"><span class="std std-ref">Document Objects</span></a></p></td> <td><p>Object which represents an entire document.</p></td> </tr> <tr>
<td><p><code>Element</code></p></td> <td><p><a class="reference internal" href="#dom-element-objects"><span class="std std-ref">Element Objects</span></a></p></td> <td><p>Element nodes in the document hierarchy.</p></td> </tr> <tr>
<td><p><code>Attr</code></p></td> <td><p><a class="reference internal" href="#dom-attr-objects"><span class="std std-ref">Attr Objects</span></a></p></td> <td><p>Attribute value nodes on element nodes.</p></td> </tr> <tr>
<td><p><code>Comment</code></p></td> <td><p><a class="reference internal" href="#dom-comment-objects"><span class="std std-ref">Comment Objects</span></a></p></td> <td><p>Representation of comments in the source document.</p></td> </tr> <tr>
<td><p><code>Text</code></p></td> <td><p><a class="reference internal" href="#dom-text-objects"><span class="std std-ref">Text and CDATASection Objects</span></a></p></td> <td><p>Nodes containing textual content from the document.</p></td> </tr> <tr>
<td><p><code>ProcessingInstruction</code></p></td> <td><p><a class="reference internal" href="#dom-pi-objects"><span class="std std-ref">ProcessingInstruction Objects</span></a></p></td> <td><p>Processing instruction representation.</p></td> </tr>  </table> <p>An additional section describes the exceptions defined for working with the DOM in Python.</p> <section id="domimplementation-objects"> <span id="dom-implementation-objects"></span><h3>DOMImplementation Objects</h3> <p>The <code>DOMImplementation</code> interface provides a way for applications to determine the availability of particular features in the DOM they are using. DOM Level 2 added the ability to create new <code>Document</code> and <code>DocumentType</code> objects using the <code>DOMImplementation</code> as well.</p> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.DOMImplementation.hasFeature">
<code>DOMImplementation.hasFeature(feature, version)</code> </dt> <dd>
<p>Return <code>True</code> if the feature identified by the pair of strings <em>feature</em> and <em>version</em> is implemented.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.DOMImplementation.createDocument">
<code>DOMImplementation.createDocument(namespaceUri, qualifiedName, doctype)</code> </dt> <dd>
<p>Return a new <code>Document</code> object (the root of the DOM), with a child <code>Element</code> object having the given <em>namespaceUri</em> and <em>qualifiedName</em>. The <em>doctype</em> must be a <code>DocumentType</code> object created by <a class="reference internal" href="#xml.dom.DOMImplementation.createDocumentType" title="xml.dom.DOMImplementation.createDocumentType"><code>createDocumentType()</code></a>, or <code>None</code>. In the Python DOM API, the first two arguments can also be <code>None</code> in order to indicate that no <code>Element</code> child is to be created.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.DOMImplementation.createDocumentType">
<code>DOMImplementation.createDocumentType(qualifiedName, publicId, systemId)</code> </dt> <dd>
<p>Return a new <code>DocumentType</code> object that encapsulates the given <em>qualifiedName</em>, <em>publicId</em>, and <em>systemId</em> strings, representing the information contained in an XML document type declaration.</p> </dd>
</dl> </section> <section id="node-objects"> <span id="dom-node-objects"></span><h3>Node Objects</h3> <p>All of the components of an XML document are subclasses of <code>Node</code>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.nodeType">
<code>Node.nodeType</code> </dt> <dd>
<p>An integer representing the node type. Symbolic constants for the types are on the <code>Node</code> object: <code>ELEMENT_NODE</code>, <code>ATTRIBUTE_NODE</code>, <code>TEXT_NODE</code>, <code>CDATA_SECTION_NODE</code>, <code>ENTITY_NODE</code>, <code>PROCESSING_INSTRUCTION_NODE</code>, <code>COMMENT_NODE</code>, <code>DOCUMENT_NODE</code>, <code>DOCUMENT_TYPE_NODE</code>, <code>NOTATION_NODE</code>. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.parentNode">
<code>Node.parentNode</code> </dt> <dd>
<p>The parent of the current node, or <code>None</code> for the document node. The value is always a <code>Node</code> object or <code>None</code>. For <code>Element</code> nodes, this will be the parent element, except for the root element, in which case it will be the <code>Document</code> object. For <code>Attr</code> nodes, this is always <code>None</code>. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.attributes">
<code>Node.attributes</code> </dt> <dd>
<p>A <code>NamedNodeMap</code> of attribute objects. Only elements have actual values for this; others provide <code>None</code> for this attribute. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.previousSibling">
<code>Node.previousSibling</code> </dt> <dd>
<p>The node that immediately precedes this one with the same parent. For instance the element with an end-tag that comes just before the <em>self</em> element’s start-tag. Of course, XML documents are made up of more than just elements so the previous sibling could be text, a comment, or something else. If this node is the first child of the parent, this attribute will be <code>None</code>. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.nextSibling">
<code>Node.nextSibling</code> </dt> <dd>
<p>The node that immediately follows this one with the same parent. See also <a class="reference internal" href="#xml.dom.Node.previousSibling" title="xml.dom.Node.previousSibling"><code>previousSibling</code></a>. If this is the last child of the parent, this attribute will be <code>None</code>. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.childNodes">
<code>Node.childNodes</code> </dt> <dd>
<p>A list of nodes contained within this node. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.firstChild">
<code>Node.firstChild</code> </dt> <dd>
<p>The first child of the node, if there are any, or <code>None</code>. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.lastChild">
<code>Node.lastChild</code> </dt> <dd>
<p>The last child of the node, if there are any, or <code>None</code>. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.localName">
<code>Node.localName</code> </dt> <dd>
<p>The part of the <code>tagName</code> following the colon if there is one, else the entire <code>tagName</code>. The value is a string.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.prefix">
<code>Node.prefix</code> </dt> <dd>
<p>The part of the <code>tagName</code> preceding the colon if there is one, else the empty string. The value is a string, or <code>None</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.namespaceURI">
<code>Node.namespaceURI</code> </dt> <dd>
<p>The namespace associated with the element name. This will be a string or <code>None</code>. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.nodeName">
<code>Node.nodeName</code> </dt> <dd>
<p>This has a different meaning for each node type; see the DOM specification for details. You can always get the information you would get here from another property such as the <code>tagName</code> property for elements or the <code>name</code> property for attributes. For all node types, the value of this attribute will be either a string or <code>None</code>. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Node.nodeValue">
<code>Node.nodeValue</code> </dt> <dd>
<p>This has a different meaning for each node type; see the DOM specification for details. The situation is similar to that with <a class="reference internal" href="#xml.dom.Node.nodeName" title="xml.dom.Node.nodeName"><code>nodeName</code></a>. The value is a string or <code>None</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Node.hasAttributes">
<code>Node.hasAttributes()</code> </dt> <dd>
<p>Return <code>True</code> if the node has any attributes.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Node.hasChildNodes">
<code>Node.hasChildNodes()</code> </dt> <dd>
<p>Return <code>True</code> if the node has any child nodes.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Node.isSameNode">
<code>Node.isSameNode(other)</code> </dt> <dd>
<p>Return <code>True</code> if <em>other</em> refers to the same node as this node. This is especially useful for DOM implementations which use any sort of proxy architecture (because more than one object can refer to the same node).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This is based on a proposed DOM Level 3 API which is still in the “working draft” stage, but this particular interface appears uncontroversial. Changes from the W3C will not necessarily affect this method in the Python DOM interface (though any new W3C API for this would also be supported).</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Node.appendChild">
<code>Node.appendChild(newChild)</code> </dt> <dd>
<p>Add a new child node to this node at the end of the list of children, returning <em>newChild</em>. If the node was already in the tree, it is removed first.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Node.insertBefore">
<code>Node.insertBefore(newChild, refChild)</code> </dt> <dd>
<p>Insert a new child node before an existing child. It must be the case that <em>refChild</em> is a child of this node; if not, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised. <em>newChild</em> is returned. If <em>refChild</em> is <code>None</code>, it inserts <em>newChild</em> at the end of the children’s list.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Node.removeChild">
<code>Node.removeChild(oldChild)</code> </dt> <dd>
<p>Remove a child node. <em>oldChild</em> must be a child of this node; if not, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised. <em>oldChild</em> is returned on success. If <em>oldChild</em> will not be used further, its <code>unlink()</code> method should be called.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Node.replaceChild">
<code>Node.replaceChild(newChild, oldChild)</code> </dt> <dd>
<p>Replace an existing node with a new node. It must be the case that <em>oldChild</em> is a child of this node; if not, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Node.normalize">
<code>Node.normalize()</code> </dt> <dd>
<p>Join adjacent text nodes so that all stretches of text are stored as single <code>Text</code> instances. This simplifies processing text from a DOM tree for many applications.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Node.cloneNode">
<code>Node.cloneNode(deep)</code> </dt> <dd>
<p>Clone this node. Setting <em>deep</em> means to clone all child nodes as well. This returns the clone.</p> </dd>
</dl> </section> <section id="nodelist-objects"> <span id="dom-nodelist-objects"></span><h3>NodeList Objects</h3> <p>A <code>NodeList</code> represents a sequence of nodes. These objects are used in two ways in the DOM Core recommendation: an <code>Element</code> object provides one as its list of child nodes, and the <code>getElementsByTagName()</code> and <code>getElementsByTagNameNS()</code> methods of <code>Node</code> return objects with this interface to represent query results.</p> <p>The DOM Level 2 recommendation defines one method and one attribute for these objects:</p> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.NodeList.item">
<code>NodeList.item(i)</code> </dt> <dd>
<p>Return the <em>i</em>’th item from the sequence, if there is one, or <code>None</code>. The index <em>i</em> is not allowed to be less than zero or greater than or equal to the length of the sequence.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.NodeList.length">
<code>NodeList.length</code> </dt> <dd>
<p>The number of nodes in the sequence.</p> </dd>
</dl> <p>In addition, the Python DOM interface requires that some additional support is provided to allow <code>NodeList</code> objects to be used as Python sequences. All <code>NodeList</code> implementations must include support for <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code>__len__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a>; this allows iteration over the <code>NodeList</code> in <a class="reference internal" href="../reference/compound_stmts.html#for"><code>for</code></a> statements and proper support for the <a class="reference internal" href="functions.html#len" title="len"><code>len()</code></a> built-in function.</p> <p>If a DOM implementation supports modification of the document, the <code>NodeList</code> implementation must also support the <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code>__setitem__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code>__delitem__()</code></a> methods.</p> </section> <section id="documenttype-objects"> <span id="dom-documenttype-objects"></span><h3>DocumentType Objects</h3> <p>Information about the notations and entities declared by a document (including the external subset if the parser uses it and can provide the information) is available from a <code>DocumentType</code> object. The <code>DocumentType</code> for a document is available from the <code>Document</code> object’s <code>doctype</code> attribute; if there is no <code>DOCTYPE</code> declaration for the document, the document’s <code>doctype</code> attribute will be set to <code>None</code> instead of an instance of this interface.</p> <p><code>DocumentType</code> is a specialization of <code>Node</code>, and adds the following attributes:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.DocumentType.publicId">
<code>DocumentType.publicId</code> </dt> <dd>
<p>The public identifier for the external subset of the document type definition. This will be a string or <code>None</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.DocumentType.systemId">
<code>DocumentType.systemId</code> </dt> <dd>
<p>The system identifier for the external subset of the document type definition. This will be a URI as a string, or <code>None</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.DocumentType.internalSubset">
<code>DocumentType.internalSubset</code> </dt> <dd>
<p>A string giving the complete internal subset from the document. This does not include the brackets which enclose the subset. If the document has no internal subset, this should be <code>None</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.DocumentType.name">
<code>DocumentType.name</code> </dt> <dd>
<p>The name of the root element as given in the <code>DOCTYPE</code> declaration, if present.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.DocumentType.entities">
<code>DocumentType.entities</code> </dt> <dd>
<p>This is a <code>NamedNodeMap</code> giving the definitions of external entities. For entity names defined more than once, only the first definition is provided (others are ignored as required by the XML recommendation). This may be <code>None</code> if the information is not provided by the parser, or if no entities are defined.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.DocumentType.notations">
<code>DocumentType.notations</code> </dt> <dd>
<p>This is a <code>NamedNodeMap</code> giving the definitions of notations. For notation names defined more than once, only the first definition is provided (others are ignored as required by the XML recommendation). This may be <code>None</code> if the information is not provided by the parser, or if no notations are defined.</p> </dd>
</dl> </section> <section id="document-objects"> <span id="dom-document-objects"></span><h3>Document Objects</h3> <p>A <code>Document</code> represents an entire XML document, including its constituent elements, attributes, processing instructions, comments etc. Remember that it inherits properties from <code>Node</code>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Document.documentElement">
<code>Document.documentElement</code> </dt> <dd>
<p>The one and only root element of the document.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Document.createElement">
<code>Document.createElement(tagName)</code> </dt> <dd>
<p>Create and return a new element node. The element is not inserted into the document when it is created. You need to explicitly insert it with one of the other methods such as <code>insertBefore()</code> or <code>appendChild()</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Document.createElementNS">
<code>Document.createElementNS(namespaceURI, tagName)</code> </dt> <dd>
<p>Create and return a new element with a namespace. The <em>tagName</em> may have a prefix. The element is not inserted into the document when it is created. You need to explicitly insert it with one of the other methods such as <code>insertBefore()</code> or <code>appendChild()</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Document.createTextNode">
<code>Document.createTextNode(data)</code> </dt> <dd>
<p>Create and return a text node containing the data passed as a parameter. As with the other creation methods, this one does not insert the node into the tree.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Document.createComment">
<code>Document.createComment(data)</code> </dt> <dd>
<p>Create and return a comment node containing the data passed as a parameter. As with the other creation methods, this one does not insert the node into the tree.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Document.createProcessingInstruction">
<code>Document.createProcessingInstruction(target, data)</code> </dt> <dd>
<p>Create and return a processing instruction node containing the <em>target</em> and <em>data</em> passed as parameters. As with the other creation methods, this one does not insert the node into the tree.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Document.createAttribute">
<code>Document.createAttribute(name)</code> </dt> <dd>
<p>Create and return an attribute node. This method does not associate the attribute node with any particular element. You must use <code>setAttributeNode()</code> on the appropriate <code>Element</code> object to use the newly created attribute instance.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Document.createAttributeNS">
<code>Document.createAttributeNS(namespaceURI, qualifiedName)</code> </dt> <dd>
<p>Create and return an attribute node with a namespace. The <em>tagName</em> may have a prefix. This method does not associate the attribute node with any particular element. You must use <code>setAttributeNode()</code> on the appropriate <code>Element</code> object to use the newly created attribute instance.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Document.getElementsByTagName">
<code>Document.getElementsByTagName(tagName)</code> </dt> <dd>
<p>Search for all descendants (direct children, children’s children, etc.) with a particular element type name.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Document.getElementsByTagNameNS">
<code>Document.getElementsByTagNameNS(namespaceURI, localName)</code> </dt> <dd>
<p>Search for all descendants (direct children, children’s children, etc.) with a particular namespace URI and localname. The localname is the part of the namespace after the prefix.</p> </dd>
</dl> </section> <section id="element-objects"> <span id="dom-element-objects"></span><h3>Element Objects</h3> <p><code>Element</code> is a subclass of <code>Node</code>, so inherits all the attributes of that class.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Element.tagName">
<code>Element.tagName</code> </dt> <dd>
<p>The element type name. In a namespace-using document it may have colons in it. The value is a string.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.getElementsByTagName">
<code>Element.getElementsByTagName(tagName)</code> </dt> <dd>
<p>Same as equivalent method in the <code>Document</code> class.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.getElementsByTagNameNS">
<code>Element.getElementsByTagNameNS(namespaceURI, localName)</code> </dt> <dd>
<p>Same as equivalent method in the <code>Document</code> class.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.hasAttribute">
<code>Element.hasAttribute(name)</code> </dt> <dd>
<p>Return <code>True</code> if the element has an attribute named by <em>name</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.hasAttributeNS">
<code>Element.hasAttributeNS(namespaceURI, localName)</code> </dt> <dd>
<p>Return <code>True</code> if the element has an attribute named by <em>namespaceURI</em> and <em>localName</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.getAttribute">
<code>Element.getAttribute(name)</code> </dt> <dd>
<p>Return the value of the attribute named by <em>name</em> as a string. If no such attribute exists, an empty string is returned, as if the attribute had no value.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.getAttributeNode">
<code>Element.getAttributeNode(attrname)</code> </dt> <dd>
<p>Return the <code>Attr</code> node for the attribute named by <em>attrname</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.getAttributeNS">
<code>Element.getAttributeNS(namespaceURI, localName)</code> </dt> <dd>
<p>Return the value of the attribute named by <em>namespaceURI</em> and <em>localName</em> as a string. If no such attribute exists, an empty string is returned, as if the attribute had no value.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.getAttributeNodeNS">
<code>Element.getAttributeNodeNS(namespaceURI, localName)</code> </dt> <dd>
<p>Return an attribute value as a node, given a <em>namespaceURI</em> and <em>localName</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.removeAttribute">
<code>Element.removeAttribute(name)</code> </dt> <dd>
<p>Remove an attribute by name. If there is no matching attribute, a <a class="reference internal" href="#xml.dom.NotFoundErr" title="xml.dom.NotFoundErr"><code>NotFoundErr</code></a> is raised.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.removeAttributeNode">
<code>Element.removeAttributeNode(oldAttr)</code> </dt> <dd>
<p>Remove and return <em>oldAttr</em> from the attribute list, if present. If <em>oldAttr</em> is not present, <a class="reference internal" href="#xml.dom.NotFoundErr" title="xml.dom.NotFoundErr"><code>NotFoundErr</code></a> is raised.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.removeAttributeNS">
<code>Element.removeAttributeNS(namespaceURI, localName)</code> </dt> <dd>
<p>Remove an attribute by name. Note that it uses a localName, not a qname. No exception is raised if there is no matching attribute.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.setAttribute">
<code>Element.setAttribute(name, value)</code> </dt> <dd>
<p>Set an attribute value from a string.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.setAttributeNode">
<code>Element.setAttributeNode(newAttr)</code> </dt> <dd>
<p>Add a new attribute node to the element, replacing an existing attribute if necessary if the <code>name</code> attribute matches. If a replacement occurs, the old attribute node will be returned. If <em>newAttr</em> is already in use, <a class="reference internal" href="#xml.dom.InuseAttributeErr" title="xml.dom.InuseAttributeErr"><code>InuseAttributeErr</code></a> will be raised.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.setAttributeNodeNS">
<code>Element.setAttributeNodeNS(newAttr)</code> </dt> <dd>
<p>Add a new attribute node to the element, replacing an existing attribute if necessary if the <code>namespaceURI</code> and <code>localName</code> attributes match. If a replacement occurs, the old attribute node will be returned. If <em>newAttr</em> is already in use, <a class="reference internal" href="#xml.dom.InuseAttributeErr" title="xml.dom.InuseAttributeErr"><code>InuseAttributeErr</code></a> will be raised.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.Element.setAttributeNS">
<code>Element.setAttributeNS(namespaceURI, qname, value)</code> </dt> <dd>
<p>Set an attribute value from a string, given a <em>namespaceURI</em> and a <em>qname</em>. Note that a qname is the whole attribute name. This is different than above.</p> </dd>
</dl> </section> <section id="attr-objects"> <span id="dom-attr-objects"></span><h3>Attr Objects</h3> <p><code>Attr</code> inherits from <code>Node</code>, so inherits all its attributes.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Attr.name">
<code>Attr.name</code> </dt> <dd>
<p>The attribute name. In a namespace-using document it may include a colon.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Attr.localName">
<code>Attr.localName</code> </dt> <dd>
<p>The part of the name following the colon if there is one, else the entire name. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Attr.prefix">
<code>Attr.prefix</code> </dt> <dd>
<p>The part of the name preceding the colon if there is one, else the empty string.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Attr.value">
<code>Attr.value</code> </dt> <dd>
<p>The text value of the attribute. This is a synonym for the <code>nodeValue</code> attribute.</p> </dd>
</dl> </section> <section id="namednodemap-objects"> <span id="dom-attributelist-objects"></span><h3>NamedNodeMap Objects</h3> <p><code>NamedNodeMap</code> does <em>not</em> inherit from <code>Node</code>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.NamedNodeMap.length">
<code>NamedNodeMap.length</code> </dt> <dd>
<p>The length of the attribute list.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.dom.NamedNodeMap.item">
<code>NamedNodeMap.item(index)</code> </dt> <dd>
<p>Return an attribute with a particular index. The order you get the attributes in is arbitrary but will be consistent for the life of a DOM. Each item is an attribute node. Get its value with the <code>value</code> attribute.</p> </dd>
</dl> <p>There are also experimental methods that give this class more mapping behavior. You can use them or you can use the standardized <code>getAttribute*()</code> family of methods on the <code>Element</code> objects.</p> </section> <section id="comment-objects"> <span id="dom-comment-objects"></span><h3>Comment Objects</h3> <p><code>Comment</code> represents a comment in the XML document. It is a subclass of <code>Node</code>, but cannot have child nodes.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Comment.data">
<code>Comment.data</code> </dt> <dd>
<p>The content of the comment as a string. The attribute contains all characters between the leading <code>&lt;!-</code><code>-</code> and trailing <code>-</code><code>-&gt;</code>, but does not include them.</p> </dd>
</dl> </section> <section id="text-and-cdatasection-objects"> <span id="dom-text-objects"></span><h3>Text and CDATASection Objects</h3> <p>The <code>Text</code> interface represents text in the XML document. If the parser and DOM implementation support the DOM’s XML extension, portions of the text enclosed in CDATA marked sections are stored in <code>CDATASection</code> objects. These two interfaces are identical, but provide different values for the <code>nodeType</code> attribute.</p> <p>These interfaces extend the <code>Node</code> interface. They cannot have child nodes.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.Text.data">
<code>Text.data</code> </dt> <dd>
<p>The content of the text node as a string.</p> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The use of a <code>CDATASection</code> node does not indicate that the node represents a complete CDATA marked section, only that the content of the node was part of a CDATA section. A single CDATA section may be represented by more than one node in the document tree. There is no way to determine whether two adjacent <code>CDATASection</code> nodes represent different CDATA marked sections.</p> </div> </section> <section id="processinginstruction-objects"> <span id="dom-pi-objects"></span><h3>ProcessingInstruction Objects</h3> <p>Represents a processing instruction in the XML document; this inherits from the <code>Node</code> interface and cannot have child nodes.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.ProcessingInstruction.target">
<code>ProcessingInstruction.target</code> </dt> <dd>
<p>The content of the processing instruction up to the first whitespace character. This is a read-only attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.dom.ProcessingInstruction.data">
<code>ProcessingInstruction.data</code> </dt> <dd>
<p>The content of the processing instruction following the first whitespace character.</p> </dd>
</dl> </section> <section id="exceptions"> <span id="dom-exceptions"></span><h3>Exceptions</h3> <p>The DOM Level 2 recommendation defines a single exception, <a class="reference internal" href="#xml.dom.DOMException" title="xml.dom.DOMException"><code>DOMException</code></a>, and a number of constants that allow applications to determine what sort of error occurred. <a class="reference internal" href="#xml.dom.DOMException" title="xml.dom.DOMException"><code>DOMException</code></a> instances carry a <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code>code</code></a> attribute that provides the appropriate value for the specific exception.</p> <p>The Python DOM interface provides the constants, but also expands the set of exceptions so that a specific exception exists for each of the exception codes defined by the DOM. The implementations must raise the appropriate specific exception, each of which carries the appropriate value for the <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code>code</code></a> attribute.</p> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.DOMException">
<code>exception xml.dom.DOMException</code> </dt> <dd>
<p>Base exception class used for all specific DOM exceptions. This exception class cannot be directly instantiated.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.DomstringSizeErr">
<code>exception xml.dom.DomstringSizeErr</code> </dt> <dd>
<p>Raised when a specified range of text does not fit into a string. This is not known to be used in the Python DOM implementations, but may be received from DOM implementations not written in Python.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.HierarchyRequestErr">
<code>exception xml.dom.HierarchyRequestErr</code> </dt> <dd>
<p>Raised when an attempt is made to insert a node where the node type is not allowed.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.IndexSizeErr">
<code>exception xml.dom.IndexSizeErr</code> </dt> <dd>
<p>Raised when an index or size parameter to a method is negative or exceeds the allowed values.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.InuseAttributeErr">
<code>exception xml.dom.InuseAttributeErr</code> </dt> <dd>
<p>Raised when an attempt is made to insert an <code>Attr</code> node that is already present elsewhere in the document.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.InvalidAccessErr">
<code>exception xml.dom.InvalidAccessErr</code> </dt> <dd>
<p>Raised if a parameter or an operation is not supported on the underlying object.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.InvalidCharacterErr">
<code>exception xml.dom.InvalidCharacterErr</code> </dt> <dd>
<p>This exception is raised when a string parameter contains a character that is not permitted in the context it’s being used in by the XML 1.0 recommendation. For example, attempting to create an <code>Element</code> node with a space in the element type name will cause this error to be raised.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.InvalidModificationErr">
<code>exception xml.dom.InvalidModificationErr</code> </dt> <dd>
<p>Raised when an attempt is made to modify the type of a node.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.InvalidStateErr">
<code>exception xml.dom.InvalidStateErr</code> </dt> <dd>
<p>Raised when an attempt is made to use an object that is not defined or is no longer usable.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.NamespaceErr">
<code>exception xml.dom.NamespaceErr</code> </dt> <dd>
<p>If an attempt is made to change any object in a way that is not permitted with regard to the <a class="reference external" href="https://www.w3.org/TR/REC-xml-names/">Namespaces in XML</a> recommendation, this exception is raised.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.NotFoundErr">
<code>exception xml.dom.NotFoundErr</code> </dt> <dd>
<p>Exception when a node does not exist in the referenced context. For example, <code>NamedNodeMap.removeNamedItem()</code> will raise this if the node passed in does not exist in the map.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.NotSupportedErr">
<code>exception xml.dom.NotSupportedErr</code> </dt> <dd>
<p>Raised when the implementation does not support the requested type of object or operation.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.NoDataAllowedErr">
<code>exception xml.dom.NoDataAllowedErr</code> </dt> <dd>
<p>This is raised if data is specified for a node which does not support data.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.NoModificationAllowedErr">
<code>exception xml.dom.NoModificationAllowedErr</code> </dt> <dd>
<p>Raised on attempts to modify an object where modifications are not allowed (such as for read-only nodes).</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.SyntaxErr">
<code>exception xml.dom.SyntaxErr</code> </dt> <dd>
<p>Raised when an invalid or illegal string is specified.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.dom.WrongDocumentErr">
<code>exception xml.dom.WrongDocumentErr</code> </dt> <dd>
<p>Raised when a node is inserted in a different document than it currently belongs to, and the implementation does not support migrating the node from one document to the other.</p> </dd>
</dl> <p>The exception codes defined in the DOM recommendation map to the exceptions described above according to this table:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Constant</p></th> <th class="head"><p>Exception</p></th> </tr> </thead>  <tr>
<td><p><code>DOMSTRING_SIZE_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.DomstringSizeErr" title="xml.dom.DomstringSizeErr"><code>DomstringSizeErr</code></a></p></td> </tr> <tr>
<td><p><code>HIERARCHY_REQUEST_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.HierarchyRequestErr" title="xml.dom.HierarchyRequestErr"><code>HierarchyRequestErr</code></a></p></td> </tr> <tr>
<td><p><code>INDEX_SIZE_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.IndexSizeErr" title="xml.dom.IndexSizeErr"><code>IndexSizeErr</code></a></p></td> </tr> <tr>
<td><p><code>INUSE_ATTRIBUTE_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.InuseAttributeErr" title="xml.dom.InuseAttributeErr"><code>InuseAttributeErr</code></a></p></td> </tr> <tr>
<td><p><code>INVALID_ACCESS_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.InvalidAccessErr" title="xml.dom.InvalidAccessErr"><code>InvalidAccessErr</code></a></p></td> </tr> <tr>
<td><p><code>INVALID_CHARACTER_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.InvalidCharacterErr" title="xml.dom.InvalidCharacterErr"><code>InvalidCharacterErr</code></a></p></td> </tr> <tr>
<td><p><code>INVALID_MODIFICATION_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.InvalidModificationErr" title="xml.dom.InvalidModificationErr"><code>InvalidModificationErr</code></a></p></td> </tr> <tr>
<td><p><code>INVALID_STATE_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.InvalidStateErr" title="xml.dom.InvalidStateErr"><code>InvalidStateErr</code></a></p></td> </tr> <tr>
<td><p><code>NAMESPACE_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.NamespaceErr" title="xml.dom.NamespaceErr"><code>NamespaceErr</code></a></p></td> </tr> <tr>
<td><p><code>NOT_FOUND_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.NotFoundErr" title="xml.dom.NotFoundErr"><code>NotFoundErr</code></a></p></td> </tr> <tr>
<td><p><code>NOT_SUPPORTED_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.NotSupportedErr" title="xml.dom.NotSupportedErr"><code>NotSupportedErr</code></a></p></td> </tr> <tr>
<td><p><code>NO_DATA_ALLOWED_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.NoDataAllowedErr" title="xml.dom.NoDataAllowedErr"><code>NoDataAllowedErr</code></a></p></td> </tr> <tr>
<td><p><code>NO_MODIFICATION_ALLOWED_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.NoModificationAllowedErr" title="xml.dom.NoModificationAllowedErr"><code>NoModificationAllowedErr</code></a></p></td> </tr> <tr>
<td><p><code>SYNTAX_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.SyntaxErr" title="xml.dom.SyntaxErr"><code>SyntaxErr</code></a></p></td> </tr> <tr>
<td><p><code>WRONG_DOCUMENT_ERR</code></p></td> <td><p><a class="reference internal" href="#xml.dom.WrongDocumentErr" title="xml.dom.WrongDocumentErr"><code>WrongDocumentErr</code></a></p></td> </tr>  </table> </section> </section> <section id="conformance"> <span id="dom-conformance"></span><h2>Conformance</h2> <p>This section describes the conformance requirements and relationships between the Python DOM API, the W3C DOM recommendations, and the OMG IDL mapping for Python.</p> <section id="type-mapping"> <span id="dom-type-mapping"></span><h3>Type Mapping</h3> <p>The IDL types used in the DOM specification are mapped to Python types according to the following table.</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>IDL Type</p></th> <th class="head"><p>Python Type</p></th> </tr> </thead>  <tr>
<td><p><code>boolean</code></p></td> <td><p><code>bool</code> or <code>int</code></p></td> </tr> <tr>
<td><p><code>int</code></p></td> <td><p><code>int</code></p></td> </tr> <tr>
<td><p><code>long int</code></p></td> <td><p><code>int</code></p></td> </tr> <tr>
<td><p><code>unsigned int</code></p></td> <td><p><code>int</code></p></td> </tr> <tr>
<td><p><code>DOMString</code></p></td> <td><p><code>str</code> or <code>bytes</code></p></td> </tr> <tr>
<td><p><code>null</code></p></td> <td><p><code>None</code></p></td> </tr>  </table> </section> <section id="accessor-methods"> <span id="dom-accessor-methods"></span><h3>Accessor Methods</h3> <p>The mapping from OMG IDL to Python defines accessor functions for IDL <code>attribute</code> declarations in much the way the Java mapping does. Mapping the IDL declarations</p> <pre data-language="python">readonly attribute string someValue;
         attribute string anotherValue;
</pre> <p>yields three accessor functions: a “get” method for <code>someValue</code> (<code>_get_someValue()</code>), and “get” and “set” methods for <code>anotherValue</code> (<code>_get_anotherValue()</code> and <code>_set_anotherValue()</code>). The mapping, in particular, does not require that the IDL attributes are accessible as normal Python attributes: <code>object.someValue</code> is <em>not</em> required to work, and may raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code>AttributeError</code></a>.</p> <p>The Python DOM API, however, <em>does</em> require that normal attribute access work. This means that the typical surrogates generated by Python IDL compilers are not likely to work, and wrapper objects may be needed on the client if the DOM objects are accessed via CORBA. While this does require some additional consideration for CORBA DOM clients, the implementers with experience using DOM over CORBA from Python do not consider this a problem. Attributes that are declared <code>readonly</code> may not restrict write access in all DOM implementations.</p> <p>In the Python DOM API, accessor functions are not required. If provided, they should take the form defined by the Python IDL mapping, but these methods are considered unnecessary since the attributes are accessible directly from Python. “Set” accessors should never be provided for <code>readonly</code> attributes.</p> <p>The IDL definitions do not fully embody the requirements of the W3C DOM API, such as the notion of certain objects, such as the return value of <code>getElementsByTagName()</code>, being “live”. The Python DOM API does not require implementations to enforce such requirements.</p> </section> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/xml.dom.html" class="_attribution-link">https://docs.python.org/3.12/library/xml.dom.html</a>
  </p>
</div>
