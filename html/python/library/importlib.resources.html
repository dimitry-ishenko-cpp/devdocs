 <span id="importlib-resources-package-resource-reading-opening-and-access"></span><h1>importlib.resources – Package resource reading, opening and access</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/importlib/resources/__init__.py">Lib/importlib/resources/__init__.py</a></p>  <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.7.</span></p> </div> <p>This module leverages Python’s import system to provide access to <em>resources</em> within <em>packages</em>.</p> <p>“Resources” are file-like resources associated with a module or package in Python. The resources may be contained directly in a package, within a subdirectory contained in that package, or adjacent to modules outside a package. Resources may be text or binary. As a result, Python module sources (.py) of a package and compilation artifacts (pycache) are technically de-facto resources of that package. In practice, however, resources are primarily those non-Python artifacts exposed specifically by the package author.</p> <p>Resources can be opened or read in either binary or text mode.</p> <p>Resources are roughly akin to files inside directories, though it’s important to keep in mind that this is just a metaphor. Resources and packages <strong>do not</strong> have to exist as physical files and directories on the file system: for example, a package and its resources can be imported from a zip file using <a class="reference internal" href="zipimport.html#module-zipimport" title="zipimport: Support for importing Python modules from ZIP archives."><code>zipimport</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This module provides functionality similar to <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html">pkg_resources</a> <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-resource-access">Basic Resource Access</a> without the performance overhead of that package. This makes reading resources included in packages easier, with more stable and consistent semantics.</p> <p>The standalone backport of this module provides more information on <a class="reference external" href="https://importlib-resources.readthedocs.io/en/latest/using.html">using importlib.resources</a> and <a class="reference external" href="https://importlib-resources.readthedocs.io/en/latest/migration.html">migrating from pkg_resources to importlib.resources</a>.</p> </div> <p><a class="reference internal" href="importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code>Loaders</code></a> that wish to support resource reading should implement a <code>get_resource_reader(fullname)</code> method as specified by <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.ResourceReader" title="importlib.resources.abc.ResourceReader"><code>importlib.resources.abc.ResourceReader</code></a>.</p> <dl class="py class"> <dt class="sig sig-object py" id="importlib.resources.Anchor">
<code>class importlib.resources.Anchor</code> </dt> <dd>
<p>Represents an anchor for resources, either a <a class="reference internal" href="types.html#types.ModuleType" title="types.ModuleType"><code>module object</code></a> or a module name as a string. Defined as <code>Union[str, ModuleType]</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="importlib.resources.files">
<code>importlib.resources.files(anchor: Anchor | None = None)</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.Traversable" title="importlib.resources.abc.Traversable"><code>Traversable</code></a> object representing the resource container (think directory) and its resources (think files). A Traversable may contain other containers (think subdirectories).</p> <p><em>anchor</em> is an optional <a class="reference internal" href="#importlib.resources.Anchor" title="importlib.resources.Anchor"><code>Anchor</code></a>. If the anchor is a package, resources are resolved from that package. If a module, resources are resolved adjacent to that module (in the same package or the package root). If the anchor is omitted, the caller’s module is used.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span><em>package</em> parameter was renamed to <em>anchor</em>. <em>anchor</em> can now be a non-package module and if omitted will default to the caller’s module. <em>package</em> is still accepted for compatibility but will raise a <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code>DeprecationWarning</code></a>. Consider passing the anchor positionally or using <code>importlib_resources &gt;= 5.10</code> for a compatible interface on older Pythons.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="importlib.resources.as_file">
<code>importlib.resources.as_file(traversable)</code> </dt> <dd>
<p>Given a <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.Traversable" title="importlib.resources.abc.Traversable"><code>Traversable</code></a> object representing a file or directory, typically from <a class="reference internal" href="#importlib.resources.files" title="importlib.resources.files"><code>importlib.resources.files()</code></a>, return a context manager for use in a <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> statement. The context manager provides a <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code>pathlib.Path</code></a> object.</p> <p>Exiting the context manager cleans up any temporary file or directory created when the resource was extracted from e.g. a zip file.</p> <p>Use <code>as_file</code> when the Traversable methods (<code>read_text</code>, etc) are insufficient and an actual file or directory on the file system is required.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Added support for <em>traversable</em> representing a directory.</p> </div> </dd>
</dl> <section id="functional-api"> <span id="importlib-resources-functional"></span><h2>Functional API</h2> <p>A set of simplified, backwards-compatible helpers is available. These allow common operations in a single function call.</p> <p>For all the following functions:</p> <ul> <li>
<em>anchor</em> is an <a class="reference internal" href="#importlib.resources.Anchor" title="importlib.resources.Anchor"><code>Anchor</code></a>, as in <a class="reference internal" href="#importlib.resources.files" title="importlib.resources.files"><code>files()</code></a>. Unlike in <code>files</code>, it may not be omitted.</li> <li>
<p><em>path_names</em> are components of a resource’s path name, relative to the anchor. For example, to get the text of resource named <code>info.txt</code>, use:</p> <pre data-language="python">importlib.resources.read_text(my_module, "info.txt")
</pre> <p>Like <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.Traversable" title="importlib.resources.abc.Traversable"><code>Traversable.joinpath</code></a>, The individual components should use forward slashes (<code>/</code>) as path separators. For example, the following are equivalent:</p> <pre data-language="python">importlib.resources.read_binary(my_module, "pics/painting.png")
importlib.resources.read_binary(my_module, "pics", "painting.png")
</pre> <p>For backward compatibility reasons, functions that read text require an explicit <em>encoding</em> argument if multiple <em>path_names</em> are given. For example, to get the text of <code>info/chapter1.txt</code>, use:</p> <pre data-language="python">importlib.resources.read_text(my_module, "info", "chapter1.txt",
                              encoding='utf-8')
</pre> </li> </ul> <dl class="py function"> <dt class="sig sig-object py" id="importlib.resources.open_binary">
<code>importlib.resources.open_binary(anchor, *path_names)</code> </dt> <dd>
<p>Open the named resource for binary reading.</p> <p>See <a class="reference internal" href="#importlib-resources-functional"><span class="std std-ref">the introduction</span></a> for details on <em>anchor</em> and <em>path_names</em>.</p> <p>This function returns a <a class="reference internal" href="typing.html#typing.BinaryIO" title="typing.BinaryIO"><code>BinaryIO</code></a> object, that is, a binary stream open for reading.</p> <p>This function is roughly equivalent to:</p> <pre data-language="python">files(anchor).joinpath(*path_names).open('rb')
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Multiple <em>path_names</em> are accepted.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="importlib.resources.open_text">
<code>importlib.resources.open_text(anchor, *path_names, encoding='utf-8', errors='strict')</code> </dt> <dd>
<p>Open the named resource for text reading. By default, the contents are read as strict UTF-8.</p> <p>See <a class="reference internal" href="#importlib-resources-functional"><span class="std std-ref">the introduction</span></a> for details on <em>anchor</em> and <em>path_names</em>. <em>encoding</em> and <em>errors</em> have the same meaning as in built-in <a class="reference internal" href="functions.html#open" title="open"><code>open()</code></a>.</p> <p>For backward compatibility reasons, the <em>encoding</em> argument must be given explicitly if there are multiple <em>path_names</em>. This limitation is scheduled to be removed in Python 3.15.</p> <p>This function returns a <a class="reference internal" href="typing.html#typing.TextIO" title="typing.TextIO"><code>TextIO</code></a> object, that is, a text stream open for reading.</p> <p>This function is roughly equivalent to:</p> <pre data-language="python">files(anchor).joinpath(*path_names).open('r', encoding=encoding)
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Multiple <em>path_names</em> are accepted. <em>encoding</em> and <em>errors</em> must be given as keyword arguments.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="importlib.resources.read_binary">
<code>importlib.resources.read_binary(anchor, *path_names)</code> </dt> <dd>
<p>Read and return the contents of the named resource as <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>.</p> <p>See <a class="reference internal" href="#importlib-resources-functional"><span class="std std-ref">the introduction</span></a> for details on <em>anchor</em> and <em>path_names</em>.</p> <p>This function is roughly equivalent to:</p> <pre data-language="python">files(anchor).joinpath(*path_names).read_bytes()
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Multiple <em>path_names</em> are accepted.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="importlib.resources.read_text">
<code>importlib.resources.read_text(anchor, *path_names, encoding='utf-8', errors='strict')</code> </dt> <dd>
<p>Read and return the contents of the named resource as <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a>. By default, the contents are read as strict UTF-8.</p> <p>See <a class="reference internal" href="#importlib-resources-functional"><span class="std std-ref">the introduction</span></a> for details on <em>anchor</em> and <em>path_names</em>. <em>encoding</em> and <em>errors</em> have the same meaning as in built-in <a class="reference internal" href="functions.html#open" title="open"><code>open()</code></a>.</p> <p>For backward compatibility reasons, the <em>encoding</em> argument must be given explicitly if there are multiple <em>path_names</em>. This limitation is scheduled to be removed in Python 3.15.</p> <p>This function is roughly equivalent to:</p> <pre data-language="python">files(anchor).joinpath(*path_names).read_text(encoding=encoding)
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Multiple <em>path_names</em> are accepted. <em>encoding</em> and <em>errors</em> must be given as keyword arguments.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="importlib.resources.path">
<code>importlib.resources.path(anchor, *path_names)</code> </dt> <dd>
<p>Provides the path to the <em>resource</em> as an actual file system path. This function returns a context manager for use in a <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> statement. The context manager provides a <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code>pathlib.Path</code></a> object.</p> <p>Exiting the context manager cleans up any temporary files created, e.g. when the resource needs to be extracted from a zip file.</p> <p>For example, the <a class="reference internal" href="pathlib.html#pathlib.Path.stat" title="pathlib.Path.stat"><code>stat()</code></a> method requires an actual file system path; it can be used like this:</p> <pre data-language="python">with importlib.resources.path(anchor, "resource.txt") as fspath:
    result = fspath.stat()
</pre> <p>See <a class="reference internal" href="#importlib-resources-functional"><span class="std std-ref">the introduction</span></a> for details on <em>anchor</em> and <em>path_names</em>.</p> <p>This function is roughly equivalent to:</p> <pre data-language="python">as_file(files(anchor).joinpath(*path_names))
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Multiple <em>path_names</em> are accepted. <em>encoding</em> and <em>errors</em> must be given as keyword arguments.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="importlib.resources.is_resource">
<code>importlib.resources.is_resource(anchor, *path_names)</code> </dt> <dd>
<p>Return <code>True</code> if the named resource exists, otherwise <code>False</code>. This function does not consider directories to be resources.</p> <p>See <a class="reference internal" href="#importlib-resources-functional"><span class="std std-ref">the introduction</span></a> for details on <em>anchor</em> and <em>path_names</em>.</p> <p>This function is roughly equivalent to:</p> <pre data-language="python">files(anchor).joinpath(*path_names).is_file()
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Multiple <em>path_names</em> are accepted.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="importlib.resources.contents">
<code>importlib.resources.contents(anchor, *path_names)</code> </dt> <dd>
<p>Return an iterable over the named items within the package or path. The iterable returns names of resources (e.g. files) and non-resources (e.g. directories) as <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a>. The iterable does not recurse into subdirectories.</p> <p>See <a class="reference internal" href="#importlib-resources-functional"><span class="std std-ref">the introduction</span></a> for details on <em>anchor</em> and <em>path_names</em>.</p> <p>This function is roughly equivalent to:</p> <pre data-language="python">for resource in files(anchor).joinpath(*path_names).iterdir():
    yield resource.name
</pre> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.11: </span>Prefer <code>iterdir()</code> as above, which offers more control over the results and richer functionality.</p> </div> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/importlib.resources.html" class="_attribution-link">https://docs.python.org/3.13/library/importlib.resources.html</a>
  </p>
</div>
