 <span id="ipaddress-ipv4-ipv6-manipulation-library"></span><h1>ipaddress — IPv4/IPv6 manipulation library</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/ipaddress.py">Lib/ipaddress.py</a></p>  <p><a class="reference internal" href="#module-ipaddress" title="ipaddress: IPv4/IPv6 manipulation library."><code>ipaddress</code></a> provides the capabilities to create, manipulate and operate on IPv4 and IPv6 addresses and networks.</p> <p>The functions and classes in this module make it straightforward to handle various tasks related to IP addresses, including checking whether or not two hosts are on the same subnet, iterating over all hosts in a particular subnet, checking whether or not a string represents a valid IP address or network definition, and so on.</p> <p>This is the full module API reference—for an overview and introduction, see <a class="reference internal" href="../howto/ipaddress.html#ipaddress-howto"><span class="std std-ref">An introduction to the ipaddress module</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <section id="convenience-factory-functions"> <h2>Convenience factory functions</h2> <p>The <a class="reference internal" href="#module-ipaddress" title="ipaddress: IPv4/IPv6 manipulation library."><code>ipaddress</code></a> module provides factory functions to conveniently create IP addresses, networks and interfaces:</p> <dl class="py function"> <dt class="sig sig-object py" id="ipaddress.ip_address">
<code>ipaddress.ip_address(address)</code> </dt> <dd>
<p>Return an <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a> or <a class="reference internal" href="#ipaddress.IPv6Address" title="ipaddress.IPv6Address"><code>IPv6Address</code></a> object depending on the IP address passed as argument. Either IPv4 or IPv6 addresses may be supplied; integers less than <code>2**32</code> will be considered to be IPv4 by default. A <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised if <em>address</em> does not represent a valid IPv4 or IPv6 address.</p> <pre data-language="python">&gt;&gt;&gt; ipaddress.ip_address('192.168.0.1')
IPv4Address('192.168.0.1')
&gt;&gt;&gt; ipaddress.ip_address('2001:db8::')
IPv6Address('2001:db8::')
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="ipaddress.ip_network">
<code>ipaddress.ip_network(address, strict=True)</code> </dt> <dd>
<p>Return an <a class="reference internal" href="#ipaddress.IPv4Network" title="ipaddress.IPv4Network"><code>IPv4Network</code></a> or <a class="reference internal" href="#ipaddress.IPv6Network" title="ipaddress.IPv6Network"><code>IPv6Network</code></a> object depending on the IP address passed as argument. <em>address</em> is a string or integer representing the IP network. Either IPv4 or IPv6 networks may be supplied; integers less than <code>2**32</code> will be considered to be IPv4 by default. <em>strict</em> is passed to <a class="reference internal" href="#ipaddress.IPv4Network" title="ipaddress.IPv4Network"><code>IPv4Network</code></a> or <a class="reference internal" href="#ipaddress.IPv6Network" title="ipaddress.IPv6Network"><code>IPv6Network</code></a> constructor. A <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised if <em>address</em> does not represent a valid IPv4 or IPv6 address, or if the network has host bits set.</p> <pre data-language="python">&gt;&gt;&gt; ipaddress.ip_network('192.168.0.0/28')
IPv4Network('192.168.0.0/28')
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="ipaddress.ip_interface">
<code>ipaddress.ip_interface(address)</code> </dt> <dd>
<p>Return an <a class="reference internal" href="#ipaddress.IPv4Interface" title="ipaddress.IPv4Interface"><code>IPv4Interface</code></a> or <a class="reference internal" href="#ipaddress.IPv6Interface" title="ipaddress.IPv6Interface"><code>IPv6Interface</code></a> object depending on the IP address passed as argument. <em>address</em> is a string or integer representing the IP address. Either IPv4 or IPv6 addresses may be supplied; integers less than <code>2**32</code> will be considered to be IPv4 by default. A <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised if <em>address</em> does not represent a valid IPv4 or IPv6 address.</p> </dd>
</dl> <p>One downside of these convenience functions is that the need to handle both IPv4 and IPv6 formats means that error messages provide minimal information on the precise error, as the functions don’t know whether the IPv4 or IPv6 format was intended. More detailed error reporting can be obtained by calling the appropriate version specific class constructors directly.</p> </section> <section id="ip-addresses"> <h2>IP Addresses</h2> <section id="address-objects"> <h3>Address objects</h3> <p>The <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a> and <a class="reference internal" href="#ipaddress.IPv6Address" title="ipaddress.IPv6Address"><code>IPv6Address</code></a> objects share a lot of common attributes. Some attributes that are only meaningful for IPv6 addresses are also implemented by <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a> objects, in order to make it easier to write code that handles both IP versions correctly. Address objects are <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, so they can be used as keys in dictionaries.</p> <dl class="py class"> <dt class="sig sig-object py" id="ipaddress.IPv4Address">
<code>class ipaddress.IPv4Address(address)</code> </dt> <dd>
<p>Construct an IPv4 address. An <a class="reference internal" href="#ipaddress.AddressValueError" title="ipaddress.AddressValueError"><code>AddressValueError</code></a> is raised if <em>address</em> is not a valid IPv4 address.</p> <p>The following constitutes a valid IPv4 address:</p> <ol class="arabic simple"> <li>A string in decimal-dot notation, consisting of four decimal integers in the inclusive range 0–255, separated by dots (e.g. <code>192.168.0.1</code>). Each integer represents an octet (byte) in the address. Leading zeroes are not tolerated to prevent confusion with octal notation.</li> <li>An integer that fits into 32 bits.</li> <li>An integer packed into a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object of length 4 (most significant octet first).</li> </ol> <pre data-language="python">&gt;&gt;&gt; ipaddress.IPv4Address('192.168.0.1')
IPv4Address('192.168.0.1')
&gt;&gt;&gt; ipaddress.IPv4Address(3232235521)
IPv4Address('192.168.0.1')
&gt;&gt;&gt; ipaddress.IPv4Address(b'\xC0\xA8\x00\x01')
IPv4Address('192.168.0.1')
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Leading zeros are tolerated, even in ambiguous cases that look like octal notation.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9.5: </span>Leading zeros are no longer tolerated and are treated as an error. IPv4 address strings are now parsed as strict as glibc <a class="reference internal" href="socket.html#socket.inet_pton" title="socket.inet_pton"><code>inet_pton()</code></a>.</p> </div> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.version">
<code>version</code> </dt> <dd>
<p>The appropriate version number: <code>4</code> for IPv4, <code>6</code> for IPv6.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.max_prefixlen">
<code>max_prefixlen</code> </dt> <dd>
<p>The total number of bits in the address representation for this version: <code>32</code> for IPv4, <code>128</code> for IPv6.</p> <p>The prefix defines the number of leading bits in an address that are compared to determine whether or not an address is part of a network.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.compressed">
<code>compressed</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.exploded">
<code>exploded</code> </dt> <dd>
<p>The string representation in dotted decimal notation. Leading zeroes are never included in the representation.</p> <p>As IPv4 does not define a shorthand notation for addresses with octets set to zero, these two attributes are always the same as <code>str(addr)</code> for IPv4 addresses. Exposing these attributes makes it easier to write display code that can handle both IPv4 and IPv6 addresses.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.packed">
<code>packed</code> </dt> <dd>
<p>The binary representation of this address - a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object of the appropriate length (most significant octet first). This is 4 bytes for IPv4 and 16 bytes for IPv6.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.reverse_pointer">
<code>reverse_pointer</code> </dt> <dd>
<p>The name of the reverse DNS PTR record for the IP address, e.g.:</p> <pre data-language="python">&gt;&gt;&gt; ipaddress.ip_address("127.0.0.1").reverse_pointer
'1.0.0.127.in-addr.arpa'
&gt;&gt;&gt; ipaddress.ip_address("2001:db8::1").reverse_pointer
'1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
</pre> <p>This is the name that could be used for performing a PTR lookup, not the resolved hostname itself.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.is_multicast">
<code>is_multicast</code> </dt> <dd>
<p><code>True</code> if the address is reserved for multicast use. See <span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3171.html"><strong>RFC 3171</strong></a> (for IPv4) or <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2373.html"><strong>RFC 2373</strong></a> (for IPv6).</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.is_private">
<code>is_private</code> </dt> <dd>
<p><code>True</code> if the address is defined as not globally reachable by <a class="reference external" href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml">iana-ipv4-special-registry</a> (for IPv4) or <a class="reference external" href="https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml">iana-ipv6-special-registry</a> (for IPv6) with the following exceptions:</p> <ul> <li>
<code>is_private</code> is <code>False</code> for the shared address space (<code>100.64.0.0/10</code>)</li> <li>
<p>For IPv4-mapped IPv6-addresses the <code>is_private</code> value is determined by the semantics of the underlying IPv4 addresses and the following condition holds (see <a class="reference internal" href="#ipaddress.IPv6Address.ipv4_mapped" title="ipaddress.IPv6Address.ipv4_mapped"><code>IPv6Address.ipv4_mapped</code></a>):</p> <pre data-language="python">address.is_private == address.ipv4_mapped.is_private
</pre> </li> </ul> <p><code>is_private</code> has value opposite to <a class="reference internal" href="#ipaddress.IPv4Address.is_global" title="ipaddress.IPv4Address.is_global"><code>is_global</code></a>, except for the shared address space (<code>100.64.0.0/10</code> range) where they are both <code>False</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Fixed some false positives and false negatives.</p> <ul class="simple"> <li>
<code>192.0.0.0/24</code> is considered private with the exception of <code>192.0.0.9/32</code> and <code>192.0.0.10/32</code> (previously: only the <code>192.0.0.0/29</code> sub-range was considered private).</li> <li>
<code>64:ff9b:1::/48</code> is considered private.</li> <li>
<code>2002::/16</code> is considered private.</li> <li>There are exceptions within <code>2001::/23</code> (otherwise considered private): <code>2001:1::1/128</code>, <code>2001:1::2/128</code>, <code>2001:3::/32</code>, <code>2001:4:112::/48</code>, <code>2001:20::/28</code>, <code>2001:30::/28</code>. The exceptions are not considered private.</li> </ul> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.is_global">
<code>is_global</code> </dt> <dd>
<p><code>True</code> if the address is defined as globally reachable by <a class="reference external" href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml">iana-ipv4-special-registry</a> (for IPv4) or <a class="reference external" href="https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml">iana-ipv6-special-registry</a> (for IPv6) with the following exception:</p> <p>For IPv4-mapped IPv6-addresses the <code>is_private</code> value is determined by the semantics of the underlying IPv4 addresses and the following condition holds (see <a class="reference internal" href="#ipaddress.IPv6Address.ipv4_mapped" title="ipaddress.IPv6Address.ipv4_mapped"><code>IPv6Address.ipv4_mapped</code></a>):</p> <pre data-language="python">address.is_global == address.ipv4_mapped.is_global
</pre> <p><code>is_global</code> has value opposite to <a class="reference internal" href="#ipaddress.IPv4Address.is_private" title="ipaddress.IPv4Address.is_private"><code>is_private</code></a>, except for the shared address space (<code>100.64.0.0/10</code> range) where they are both <code>False</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Fixed some false positives and false negatives, see <a class="reference internal" href="#ipaddress.IPv4Address.is_private" title="ipaddress.IPv4Address.is_private"><code>is_private</code></a> for details.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.is_unspecified">
<code>is_unspecified</code> </dt> <dd>
<p><code>True</code> if the address is unspecified. See <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5735.html"><strong>RFC 5735</strong></a> (for IPv4) or <span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2373.html"><strong>RFC 2373</strong></a> (for IPv6).</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.is_reserved">
<code>is_reserved</code> </dt> <dd>
<p><code>True</code> if the address is otherwise IETF reserved.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.is_loopback">
<code>is_loopback</code> </dt> <dd>
<p><code>True</code> if this is a loopback address. See <span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3330.html"><strong>RFC 3330</strong></a> (for IPv4) or <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2373.html"><strong>RFC 2373</strong></a> (for IPv6).</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.is_link_local">
<code>is_link_local</code> </dt> <dd>
<p><code>True</code> if the address is reserved for link-local usage. See <span class="target" id="index-6"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3927.html"><strong>RFC 3927</strong></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.ipv6_mapped">
<code>ipv6_mapped</code> </dt> <dd>
<p><a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a> object representing the IPv4-mapped IPv6 address. See <span class="target" id="index-7"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4291.html"><strong>RFC 4291</strong></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv4Address.__format__">
<code>IPv4Address.__format__(fmt)</code> </dt> <dd>
<p>Returns a string representation of the IP address, controlled by an explicit format string. <em>fmt</em> can be one of the following: <code>'s'</code>, the default option, equivalent to <a class="reference internal" href="stdtypes.html#str" title="str"><code>str()</code></a>, <code>'b'</code> for a zero-padded binary string, <code>'X'</code> or <code>'x'</code> for an uppercase or lowercase hexadecimal representation, or <code>'n'</code>, which is equivalent to <code>'b'</code> for IPv4 addresses and <code>'x'</code> for IPv6. For binary and hexadecimal representations, the form specifier <code>'#'</code> and the grouping option <code>'_'</code> are available. <code>__format__</code> is used by <code>format</code>, <code>str.format</code> and f-strings.</p> <pre data-language="python">&gt;&gt;&gt; format(ipaddress.IPv4Address('192.168.0.1'))
'192.168.0.1'
&gt;&gt;&gt; '{:#b}'.format(ipaddress.IPv4Address('192.168.0.1'))
'0b11000000101010000000000000000001'
&gt;&gt;&gt; f'{ipaddress.IPv6Address("2001:db8::1000"):s}'
'2001:db8::1000'
&gt;&gt;&gt; format(ipaddress.IPv6Address('2001:db8::1000'), '_X')
'2001_0DB8_0000_0000_0000_0000_0000_1000'
&gt;&gt;&gt; '{:#_n}'.format(ipaddress.IPv6Address('2001:db8::1000'))
'0x2001_0db8_0000_0000_0000_0000_0000_1000'
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="ipaddress.IPv6Address">
<code>class ipaddress.IPv6Address(address)</code> </dt> <dd>
<p>Construct an IPv6 address. An <a class="reference internal" href="#ipaddress.AddressValueError" title="ipaddress.AddressValueError"><code>AddressValueError</code></a> is raised if <em>address</em> is not a valid IPv6 address.</p> <p>The following constitutes a valid IPv6 address:</p> <ol class="arabic"> <li>
<p>A string consisting of eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons. This describes an <em>exploded</em> (longhand) notation. The string can also be <em>compressed</em> (shorthand notation) by various means. See <span class="target" id="index-8"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4291.html"><strong>RFC 4291</strong></a> for details. For example, <code>"0000:0000:0000:0000:0000:0abc:0007:0def"</code> can be compressed to <code>"::abc:7:def"</code>.</p> <p>Optionally, the string may also have a scope zone ID, expressed with a suffix <code>%scope_id</code>. If present, the scope ID must be non-empty, and may not contain <code>%</code>. See <span class="target" id="index-9"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4007.html"><strong>RFC 4007</strong></a> for details. For example, <code>fe80::1234%1</code> might identify address <code>fe80::1234</code> on the first link of the node.</p> </li> <li>An integer that fits into 128 bits.</li> <li>An integer packed into a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object of length 16, big-endian.</li> </ol> <pre data-language="python">&gt;&gt;&gt; ipaddress.IPv6Address('2001:db8::1000')
IPv6Address('2001:db8::1000')
&gt;&gt;&gt; ipaddress.IPv6Address('ff02::5678%1')
IPv6Address('ff02::5678%1')
</pre> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.compressed">
<code>compressed</code> </dt> <dd></dd>
</dl> <p>The short form of the address representation, with leading zeroes in groups omitted and the longest sequence of groups consisting entirely of zeroes collapsed to a single empty group.</p> <p>This is also the value returned by <code>str(addr)</code> for IPv6 addresses.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.exploded">
<code>exploded</code> </dt> <dd></dd>
</dl> <p>The long form of the address representation, with all leading zeroes and groups consisting entirely of zeroes included.</p> <p>For the following attributes and methods, see the corresponding documentation of the <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a> class:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.packed">
<code>packed</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.reverse_pointer">
<code>reverse_pointer</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.version">
<code>version</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.max_prefixlen">
<code>max_prefixlen</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.is_multicast">
<code>is_multicast</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.is_private">
<code>is_private</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.is_global">
<code>is_global</code> </dt> <dd>
<div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.is_unspecified">
<code>is_unspecified</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.is_reserved">
<code>is_reserved</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.is_loopback">
<code>is_loopback</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.is_link_local">
<code>is_link_local</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.is_site_local">
<code>is_site_local</code> </dt> <dd>
<p><code>True</code> if the address is reserved for site-local usage. Note that the site-local address space has been deprecated by <span class="target" id="index-10"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3879.html"><strong>RFC 3879</strong></a>. Use <a class="reference internal" href="#ipaddress.IPv4Address.is_private" title="ipaddress.IPv4Address.is_private"><code>is_private</code></a> to test if this address is in the space of unique local addresses as defined by <span class="target" id="index-11"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4193.html"><strong>RFC 4193</strong></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.ipv4_mapped">
<code>ipv4_mapped</code> </dt> <dd>
<p>For addresses that appear to be IPv4 mapped addresses (starting with <code>::FFFF/96</code>), this property will report the embedded IPv4 address. For any other address, this property will be <code>None</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.scope_id">
<code>scope_id</code> </dt> <dd>
<p>For scoped addresses as defined by <span class="target" id="index-12"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4007.html"><strong>RFC 4007</strong></a>, this property identifies the particular zone of the address’s scope that the address belongs to, as a string. When no scope zone is specified, this property will be <code>None</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.sixtofour">
<code>sixtofour</code> </dt> <dd>
<p>For addresses that appear to be 6to4 addresses (starting with <code>2002::/16</code>) as defined by <span class="target" id="index-13"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3056.html"><strong>RFC 3056</strong></a>, this property will report the embedded IPv4 address. For any other address, this property will be <code>None</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.teredo">
<code>teredo</code> </dt> <dd>
<p>For addresses that appear to be Teredo addresses (starting with <code>2001::/32</code>) as defined by <span class="target" id="index-14"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4380.html"><strong>RFC 4380</strong></a>, this property will report the embedded <code>(server, client)</code> IP address pair. For any other address, this property will be <code>None</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv6Address.__format__">
<code>IPv6Address.__format__(fmt)</code> </dt> <dd>
<p>Refer to the corresponding method documentation in <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> </section> <section id="conversion-to-strings-and-integers"> <h3>Conversion to Strings and Integers</h3> <p>To interoperate with networking interfaces such as the socket module, addresses must be converted to strings or integers. This is handled using the <a class="reference internal" href="stdtypes.html#str" title="str"><code>str()</code></a> and <a class="reference internal" href="functions.html#int" title="int"><code>int()</code></a> builtin functions:</p> <pre data-language="python">&gt;&gt;&gt; str(ipaddress.IPv4Address('192.168.0.1'))
'192.168.0.1'
&gt;&gt;&gt; int(ipaddress.IPv4Address('192.168.0.1'))
3232235521
&gt;&gt;&gt; str(ipaddress.IPv6Address('::1'))
'::1'
&gt;&gt;&gt; int(ipaddress.IPv6Address('::1'))
1
</pre> <p>Note that IPv6 scoped addresses are converted to integers without scope zone ID.</p> </section> <section id="operators"> <h3>Operators</h3> <p>Address objects support some operators. Unless stated otherwise, operators can only be applied between compatible objects (i.e. IPv4 with IPv4, IPv6 with IPv6).</p> <section id="comparison-operators"> <h4>Comparison operators</h4> <p>Address objects can be compared with the usual set of comparison operators. Same IPv6 addresses with different scope zone IDs are not equal. Some examples:</p> <pre data-language="python">&gt;&gt;&gt; IPv4Address('127.0.0.2') &gt; IPv4Address('127.0.0.1')
True
&gt;&gt;&gt; IPv4Address('127.0.0.2') == IPv4Address('127.0.0.1')
False
&gt;&gt;&gt; IPv4Address('127.0.0.2') != IPv4Address('127.0.0.1')
True
&gt;&gt;&gt; IPv6Address('fe80::1234') == IPv6Address('fe80::1234%1')
False
&gt;&gt;&gt; IPv6Address('fe80::1234%1') != IPv6Address('fe80::1234%2')
True
</pre> </section> <section id="arithmetic-operators"> <h4>Arithmetic operators</h4> <p>Integers can be added to or subtracted from address objects. Some examples:</p> <pre data-language="python">&gt;&gt;&gt; IPv4Address('127.0.0.2') + 3
IPv4Address('127.0.0.5')
&gt;&gt;&gt; IPv4Address('127.0.0.2') - 3
IPv4Address('126.255.255.255')
&gt;&gt;&gt; IPv4Address('255.255.255.255') + 1
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ipaddress.AddressValueError: 4294967296 (&gt;= 2**32) is not permitted as an IPv4 address
</pre> </section> </section> </section> <section id="ip-network-definitions"> <h2>IP Network definitions</h2> <p>The <a class="reference internal" href="#ipaddress.IPv4Network" title="ipaddress.IPv4Network"><code>IPv4Network</code></a> and <a class="reference internal" href="#ipaddress.IPv6Network" title="ipaddress.IPv6Network"><code>IPv6Network</code></a> objects provide a mechanism for defining and inspecting IP network definitions. A network definition consists of a <em>mask</em> and a <em>network address</em>, and as such defines a range of IP addresses that equal the network address when masked (binary AND) with the mask. For example, a network definition with the mask <code>255.255.255.0</code> and the network address <code>192.168.1.0</code> consists of IP addresses in the inclusive range <code>192.168.1.0</code> to <code>192.168.1.255</code>.</p> <section id="prefix-net-mask-and-host-mask"> <h3>Prefix, net mask and host mask</h3> <p>There are several equivalent ways to specify IP network masks. A <em>prefix</em> <code>/&lt;nbits&gt;</code> is a notation that denotes how many high-order bits are set in the network mask. A <em>net mask</em> is an IP address with some number of high-order bits set. Thus the prefix <code>/24</code> is equivalent to the net mask <code>255.255.255.0</code> in IPv4, or <code>ffff:ff00::</code> in IPv6. In addition, a <em>host mask</em> is the logical inverse of a <em>net mask</em>, and is sometimes used (for example in Cisco access control lists) to denote a network mask. The host mask equivalent to <code>/24</code> in IPv4 is <code>0.0.0.255</code>.</p> </section> <section id="network-objects"> <h3>Network objects</h3> <p>All attributes implemented by address objects are implemented by network objects as well. In addition, network objects implement additional attributes. All of these are common between <a class="reference internal" href="#ipaddress.IPv4Network" title="ipaddress.IPv4Network"><code>IPv4Network</code></a> and <a class="reference internal" href="#ipaddress.IPv6Network" title="ipaddress.IPv6Network"><code>IPv6Network</code></a>, so to avoid duplication they are only documented for <a class="reference internal" href="#ipaddress.IPv4Network" title="ipaddress.IPv4Network"><code>IPv4Network</code></a>. Network objects are <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, so they can be used as keys in dictionaries.</p> <dl class="py class"> <dt class="sig sig-object py" id="ipaddress.IPv4Network">
<code>class ipaddress.IPv4Network(address, strict=True)</code> </dt> <dd>
<p>Construct an IPv4 network definition. <em>address</em> can be one of the following:</p> <ol class="arabic"> <li>
<p>A string consisting of an IP address and an optional mask, separated by a slash (<code>/</code>). The IP address is the network address, and the mask can be either a single number, which means it’s a <em>prefix</em>, or a string representation of an IPv4 address. If it’s the latter, the mask is interpreted as a <em>net mask</em> if it starts with a non-zero field, or as a <em>host mask</em> if it starts with a zero field, with the single exception of an all-zero mask which is treated as a <em>net mask</em>. If no mask is provided, it’s considered to be <code>/32</code>.</p> <p>For example, the following <em>address</em> specifications are equivalent: <code>192.168.1.0/24</code>, <code>192.168.1.0/255.255.255.0</code> and <code>192.168.1.0/0.0.0.255</code>.</p> </li> <li>An integer that fits into 32 bits. This is equivalent to a single-address network, with the network address being <em>address</em> and the mask being <code>/32</code>.</li> <li>An integer packed into a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object of length 4, big-endian. The interpretation is similar to an integer <em>address</em>.</li> <li>A two-tuple of an address description and a netmask, where the address description is either a string, a 32-bits integer, a 4-bytes packed integer, or an existing IPv4Address object; and the netmask is either an integer representing the prefix length (e.g. <code>24</code>) or a string representing the prefix mask (e.g. <code>255.255.255.0</code>).</li> </ol> <p>An <a class="reference internal" href="#ipaddress.AddressValueError" title="ipaddress.AddressValueError"><code>AddressValueError</code></a> is raised if <em>address</em> is not a valid IPv4 address. A <a class="reference internal" href="#ipaddress.NetmaskValueError" title="ipaddress.NetmaskValueError"><code>NetmaskValueError</code></a> is raised if the mask is not valid for an IPv4 address.</p> <p>If <em>strict</em> is <code>True</code> and host bits are set in the supplied address, then <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised. Otherwise, the host bits are masked out to determine the appropriate network address.</p> <p>Unless stated otherwise, all network methods accepting other network/address objects will raise <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> if the argument’s IP version is incompatible to <code>self</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Added the two-tuple form for the <em>address</em> constructor parameter.</p> </div> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.version">
<code>version</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.max_prefixlen">
<code>max_prefixlen</code> </dt> <dd>
<p>Refer to the corresponding attribute documentation in <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.is_multicast">
<code>is_multicast</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.is_private">
<code>is_private</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.is_unspecified">
<code>is_unspecified</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.is_reserved">
<code>is_reserved</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.is_loopback">
<code>is_loopback</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.is_link_local">
<code>is_link_local</code> </dt> <dd>
<p>These attributes are true for the network as a whole if they are true for both the network address and the broadcast address.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.network_address">
<code>network_address</code> </dt> <dd>
<p>The network address for the network. The network address and the prefix length together uniquely define a network.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.broadcast_address">
<code>broadcast_address</code> </dt> <dd>
<p>The broadcast address for the network. Packets sent to the broadcast address should be received by every host on the network.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.hostmask">
<code>hostmask</code> </dt> <dd>
<p>The host mask, as an <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a> object.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.netmask">
<code>netmask</code> </dt> <dd>
<p>The net mask, as an <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a> object.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.with_prefixlen">
<code>with_prefixlen</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.compressed">
<code>compressed</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.exploded">
<code>exploded</code> </dt> <dd>
<p>A string representation of the network, with the mask in prefix notation.</p> <p><code>with_prefixlen</code> and <code>compressed</code> are always the same as <code>str(network)</code>. <code>exploded</code> uses the exploded form the network address.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.with_netmask">
<code>with_netmask</code> </dt> <dd>
<p>A string representation of the network, with the mask in net mask notation.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.with_hostmask">
<code>with_hostmask</code> </dt> <dd>
<p>A string representation of the network, with the mask in host mask notation.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.num_addresses">
<code>num_addresses</code> </dt> <dd>
<p>The total number of addresses in the network.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.prefixlen">
<code>prefixlen</code> </dt> <dd>
<p>Length of the network prefix, in bits.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.hosts">
<code>hosts()</code> </dt> <dd>
<p>Returns an iterator over the usable hosts in the network. The usable hosts are all the IP addresses that belong to the network, except the network address itself and the network broadcast address. For networks with a mask length of 31, the network address and network broadcast address are also included in the result. Networks with a mask of 32 will return a list containing the single host address.</p> <pre data-language="python">&gt;&gt;&gt; list(ip_network('192.0.2.0/29').hosts())  
[IPv4Address('192.0.2.1'), IPv4Address('192.0.2.2'),
 IPv4Address('192.0.2.3'), IPv4Address('192.0.2.4'),
 IPv4Address('192.0.2.5'), IPv4Address('192.0.2.6')]
&gt;&gt;&gt; list(ip_network('192.0.2.0/31').hosts())
[IPv4Address('192.0.2.0'), IPv4Address('192.0.2.1')]
&gt;&gt;&gt; list(ip_network('192.0.2.1/32').hosts())
[IPv4Address('192.0.2.1')]
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.overlaps">
<code>overlaps(other)</code> </dt> <dd>
<p><code>True</code> if this network is partly or wholly contained in <em>other</em> or <em>other</em> is wholly contained in this network.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.address_exclude">
<code>address_exclude(network)</code> </dt> <dd>
<p>Computes the network definitions resulting from removing the given <em>network</em> from this one. Returns an iterator of network objects. Raises <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if <em>network</em> is not completely contained in this network.</p> <pre data-language="python">&gt;&gt;&gt; n1 = ip_network('192.0.2.0/28')
&gt;&gt;&gt; n2 = ip_network('192.0.2.1/32')
&gt;&gt;&gt; list(n1.address_exclude(n2))  
[IPv4Network('192.0.2.8/29'), IPv4Network('192.0.2.4/30'),
 IPv4Network('192.0.2.2/31'), IPv4Network('192.0.2.0/32')]
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.subnets">
<code>subnets(prefixlen_diff=1, new_prefix=None)</code> </dt> <dd>
<p>The subnets that join to make the current network definition, depending on the argument values. <em>prefixlen_diff</em> is the amount our prefix length should be increased by. <em>new_prefix</em> is the desired new prefix of the subnets; it must be larger than our prefix. One and only one of <em>prefixlen_diff</em> and <em>new_prefix</em> must be set. Returns an iterator of network objects.</p> <pre data-language="python">&gt;&gt;&gt; list(ip_network('192.0.2.0/24').subnets())
[IPv4Network('192.0.2.0/25'), IPv4Network('192.0.2.128/25')]
&gt;&gt;&gt; list(ip_network('192.0.2.0/24').subnets(prefixlen_diff=2))  
[IPv4Network('192.0.2.0/26'), IPv4Network('192.0.2.64/26'),
 IPv4Network('192.0.2.128/26'), IPv4Network('192.0.2.192/26')]
&gt;&gt;&gt; list(ip_network('192.0.2.0/24').subnets(new_prefix=26))  
[IPv4Network('192.0.2.0/26'), IPv4Network('192.0.2.64/26'),
 IPv4Network('192.0.2.128/26'), IPv4Network('192.0.2.192/26')]
&gt;&gt;&gt; list(ip_network('192.0.2.0/24').subnets(new_prefix=23))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    raise ValueError('new prefix must be longer')
ValueError: new prefix must be longer
&gt;&gt;&gt; list(ip_network('192.0.2.0/24').subnets(new_prefix=25))
[IPv4Network('192.0.2.0/25'), IPv4Network('192.0.2.128/25')]
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.supernet">
<code>supernet(prefixlen_diff=1, new_prefix=None)</code> </dt> <dd>
<p>The supernet containing this network definition, depending on the argument values. <em>prefixlen_diff</em> is the amount our prefix length should be decreased by. <em>new_prefix</em> is the desired new prefix of the supernet; it must be smaller than our prefix. One and only one of <em>prefixlen_diff</em> and <em>new_prefix</em> must be set. Returns a single network object.</p> <pre data-language="python">&gt;&gt;&gt; ip_network('192.0.2.0/24').supernet()
IPv4Network('192.0.2.0/23')
&gt;&gt;&gt; ip_network('192.0.2.0/24').supernet(prefixlen_diff=2)
IPv4Network('192.0.0.0/22')
&gt;&gt;&gt; ip_network('192.0.2.0/24').supernet(new_prefix=20)
IPv4Network('192.0.0.0/20')
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.subnet_of">
<code>subnet_of(other)</code> </dt> <dd>
<p>Return <code>True</code> if this network is a subnet of <em>other</em>.</p> <pre data-language="python">&gt;&gt;&gt; a = ip_network('192.168.1.0/24')
&gt;&gt;&gt; b = ip_network('192.168.1.128/30')
&gt;&gt;&gt; b.subnet_of(a)
True
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.7.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.supernet_of">
<code>supernet_of(other)</code> </dt> <dd>
<p>Return <code>True</code> if this network is a supernet of <em>other</em>.</p> <pre data-language="python">&gt;&gt;&gt; a = ip_network('192.168.1.0/24')
&gt;&gt;&gt; b = ip_network('192.168.1.128/30')
&gt;&gt;&gt; a.supernet_of(b)
True
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.7.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv4Network.compare_networks">
<code>compare_networks(other)</code> </dt> <dd>
<p>Compare this network to <em>other</em>. In this comparison only the network addresses are considered; host bits aren’t. Returns either <code>-1</code>, <code>0</code> or <code>1</code>.</p> <pre data-language="python">&gt;&gt;&gt; ip_network('192.0.2.1/32').compare_networks(ip_network('192.0.2.2/32'))
-1
&gt;&gt;&gt; ip_network('192.0.2.1/32').compare_networks(ip_network('192.0.2.0/32'))
1
&gt;&gt;&gt; ip_network('192.0.2.1/32').compare_networks(ip_network('192.0.2.1/32'))
0
</pre> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.7: </span>It uses the same ordering and comparison algorithm as “&lt;”, “==”, and “&gt;”</p> </div> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="ipaddress.IPv6Network">
<code>class ipaddress.IPv6Network(address, strict=True)</code> </dt> <dd>
<p>Construct an IPv6 network definition. <em>address</em> can be one of the following:</p> <ol class="arabic"> <li>
<p>A string consisting of an IP address and an optional prefix length, separated by a slash (<code>/</code>). The IP address is the network address, and the prefix length must be a single number, the <em>prefix</em>. If no prefix length is provided, it’s considered to be <code>/128</code>.</p> <p>Note that currently expanded netmasks are not supported. That means <code>2001:db00::0/24</code> is a valid argument while <code>2001:db00::0/ffff:ff00::</code> is not.</p> </li> <li>An integer that fits into 128 bits. This is equivalent to a single-address network, with the network address being <em>address</em> and the mask being <code>/128</code>.</li> <li>An integer packed into a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object of length 16, big-endian. The interpretation is similar to an integer <em>address</em>.</li> <li>A two-tuple of an address description and a netmask, where the address description is either a string, a 128-bits integer, a 16-bytes packed integer, or an existing IPv6Address object; and the netmask is an integer representing the prefix length.</li> </ol> <p>An <a class="reference internal" href="#ipaddress.AddressValueError" title="ipaddress.AddressValueError"><code>AddressValueError</code></a> is raised if <em>address</em> is not a valid IPv6 address. A <a class="reference internal" href="#ipaddress.NetmaskValueError" title="ipaddress.NetmaskValueError"><code>NetmaskValueError</code></a> is raised if the mask is not valid for an IPv6 address.</p> <p>If <em>strict</em> is <code>True</code> and host bits are set in the supplied address, then <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised. Otherwise, the host bits are masked out to determine the appropriate network address.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Added the two-tuple form for the <em>address</em> constructor parameter.</p> </div> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.version">
<code>version</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.max_prefixlen">
<code>max_prefixlen</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.is_multicast">
<code>is_multicast</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.is_private">
<code>is_private</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.is_unspecified">
<code>is_unspecified</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.is_reserved">
<code>is_reserved</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.is_loopback">
<code>is_loopback</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.is_link_local">
<code>is_link_local</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.network_address">
<code>network_address</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.broadcast_address">
<code>broadcast_address</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.hostmask">
<code>hostmask</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.netmask">
<code>netmask</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.with_prefixlen">
<code>with_prefixlen</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.compressed">
<code>compressed</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.exploded">
<code>exploded</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.with_netmask">
<code>with_netmask</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.with_hostmask">
<code>with_hostmask</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.num_addresses">
<code>num_addresses</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.prefixlen">
<code>prefixlen</code> </dt> <dd></dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.hosts">
<code>hosts()</code> </dt> <dd>
<p>Returns an iterator over the usable hosts in the network. The usable hosts are all the IP addresses that belong to the network, except the Subnet-Router anycast address. For networks with a mask length of 127, the Subnet-Router anycast address is also included in the result. Networks with a mask of 128 will return a list containing the single host address.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.overlaps">
<code>overlaps(other)</code> </dt> <dd></dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.address_exclude">
<code>address_exclude(network)</code> </dt> <dd></dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.subnets">
<code>subnets(prefixlen_diff=1, new_prefix=None)</code> </dt> <dd></dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.supernet">
<code>supernet(prefixlen_diff=1, new_prefix=None)</code> </dt> <dd></dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.subnet_of">
<code>subnet_of(other)</code> </dt> <dd></dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.supernet_of">
<code>supernet_of(other)</code> </dt> <dd></dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.compare_networks">
<code>compare_networks(other)</code> </dt> <dd>
<p>Refer to the corresponding attribute documentation in <a class="reference internal" href="#ipaddress.IPv4Network" title="ipaddress.IPv4Network"><code>IPv4Network</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Network.is_site_local">
<code>is_site_local</code> </dt> <dd>
<p>These attribute is true for the network as a whole if it is true for both the network address and the broadcast address.</p> </dd>
</dl> </dd>
</dl> </section> <section id="id1"> <h3>Operators</h3> <p>Network objects support some operators. Unless stated otherwise, operators can only be applied between compatible objects (i.e. IPv4 with IPv4, IPv6 with IPv6).</p> <section id="logical-operators"> <h4>Logical operators</h4> <p>Network objects can be compared with the usual set of logical operators. Network objects are ordered first by network address, then by net mask.</p> </section> <section id="iteration"> <h4>Iteration</h4> <p>Network objects can be iterated to list all the addresses belonging to the network. For iteration, <em>all</em> hosts are returned, including unusable hosts (for usable hosts, use the <a class="reference internal" href="#ipaddress.IPv4Network.hosts" title="ipaddress.IPv4Network.hosts"><code>hosts()</code></a> method). An example:</p> <pre data-language="python">&gt;&gt;&gt; for addr in IPv4Network('192.0.2.0/28'):
...     addr
...
IPv4Address('192.0.2.0')
IPv4Address('192.0.2.1')
IPv4Address('192.0.2.2')
IPv4Address('192.0.2.3')
IPv4Address('192.0.2.4')
IPv4Address('192.0.2.5')
IPv4Address('192.0.2.6')
IPv4Address('192.0.2.7')
IPv4Address('192.0.2.8')
IPv4Address('192.0.2.9')
IPv4Address('192.0.2.10')
IPv4Address('192.0.2.11')
IPv4Address('192.0.2.12')
IPv4Address('192.0.2.13')
IPv4Address('192.0.2.14')
IPv4Address('192.0.2.15')
</pre> </section> <section id="networks-as-containers-of-addresses"> <h4>Networks as containers of addresses</h4> <p>Network objects can act as containers of addresses. Some examples:</p> <pre data-language="python">&gt;&gt;&gt; IPv4Network('192.0.2.0/28')[0]
IPv4Address('192.0.2.0')
&gt;&gt;&gt; IPv4Network('192.0.2.0/28')[15]
IPv4Address('192.0.2.15')
&gt;&gt;&gt; IPv4Address('192.0.2.6') in IPv4Network('192.0.2.0/28')
True
&gt;&gt;&gt; IPv4Address('192.0.3.6') in IPv4Network('192.0.2.0/28')
False
</pre> </section> </section> </section> <section id="interface-objects"> <h2>Interface objects</h2> <p>Interface objects are <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, so they can be used as keys in dictionaries.</p> <dl class="py class"> <dt class="sig sig-object py" id="ipaddress.IPv4Interface">
<code>class ipaddress.IPv4Interface(address)</code> </dt> <dd>
<p>Construct an IPv4 interface. The meaning of <em>address</em> is as in the constructor of <a class="reference internal" href="#ipaddress.IPv4Network" title="ipaddress.IPv4Network"><code>IPv4Network</code></a>, except that arbitrary host addresses are always accepted.</p> <p><a class="reference internal" href="#ipaddress.IPv4Interface" title="ipaddress.IPv4Interface"><code>IPv4Interface</code></a> is a subclass of <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a>, so it inherits all the attributes from that class. In addition, the following attributes are available:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Interface.ip">
<code>ip</code> </dt> <dd>
<p>The address (<a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a>) without network information.</p> <pre data-language="python">&gt;&gt;&gt; interface = IPv4Interface('192.0.2.5/24')
&gt;&gt;&gt; interface.ip
IPv4Address('192.0.2.5')
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Interface.network">
<code>network</code> </dt> <dd>
<p>The network (<a class="reference internal" href="#ipaddress.IPv4Network" title="ipaddress.IPv4Network"><code>IPv4Network</code></a>) this interface belongs to.</p> <pre data-language="python">&gt;&gt;&gt; interface = IPv4Interface('192.0.2.5/24')
&gt;&gt;&gt; interface.network
IPv4Network('192.0.2.0/24')
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Interface.with_prefixlen">
<code>with_prefixlen</code> </dt> <dd>
<p>A string representation of the interface with the mask in prefix notation.</p> <pre data-language="python">&gt;&gt;&gt; interface = IPv4Interface('192.0.2.5/24')
&gt;&gt;&gt; interface.with_prefixlen
'192.0.2.5/24'
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Interface.with_netmask">
<code>with_netmask</code> </dt> <dd>
<p>A string representation of the interface with the network as a net mask.</p> <pre data-language="python">&gt;&gt;&gt; interface = IPv4Interface('192.0.2.5/24')
&gt;&gt;&gt; interface.with_netmask
'192.0.2.5/255.255.255.0'
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv4Interface.with_hostmask">
<code>with_hostmask</code> </dt> <dd>
<p>A string representation of the interface with the network as a host mask.</p> <pre data-language="python">&gt;&gt;&gt; interface = IPv4Interface('192.0.2.5/24')
&gt;&gt;&gt; interface.with_hostmask
'192.0.2.5/0.0.0.255'
</pre> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="ipaddress.IPv6Interface">
<code>class ipaddress.IPv6Interface(address)</code> </dt> <dd>
<p>Construct an IPv6 interface. The meaning of <em>address</em> is as in the constructor of <a class="reference internal" href="#ipaddress.IPv6Network" title="ipaddress.IPv6Network"><code>IPv6Network</code></a>, except that arbitrary host addresses are always accepted.</p> <p><a class="reference internal" href="#ipaddress.IPv6Interface" title="ipaddress.IPv6Interface"><code>IPv6Interface</code></a> is a subclass of <a class="reference internal" href="#ipaddress.IPv6Address" title="ipaddress.IPv6Address"><code>IPv6Address</code></a>, so it inherits all the attributes from that class. In addition, the following attributes are available:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Interface.ip">
<code>ip</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Interface.network">
<code>network</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Interface.with_prefixlen">
<code>with_prefixlen</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Interface.with_netmask">
<code>with_netmask</code> </dt> <dd></dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="ipaddress.IPv6Interface.with_hostmask">
<code>with_hostmask</code> </dt> <dd>
<p>Refer to the corresponding attribute documentation in <a class="reference internal" href="#ipaddress.IPv4Interface" title="ipaddress.IPv4Interface"><code>IPv4Interface</code></a>.</p> </dd>
</dl> </dd>
</dl> <section id="id2"> <h3>Operators</h3> <p>Interface objects support some operators. Unless stated otherwise, operators can only be applied between compatible objects (i.e. IPv4 with IPv4, IPv6 with IPv6).</p> <section id="id3"> <h4>Logical operators</h4> <p>Interface objects can be compared with the usual set of logical operators.</p> <p>For equality comparison (<code>==</code> and <code>!=</code>), both the IP address and network must be the same for the objects to be equal. An interface will not compare equal to any address or network object.</p> <p>For ordering (<code>&lt;</code>, <code>&gt;</code>, etc) the rules are different. Interface and address objects with the same IP version can be compared, and the address objects will always sort before the interface objects. Two interface objects are first compared by their networks and, if those are the same, then by their IP addresses.</p> </section> </section> </section> <section id="other-module-level-functions"> <h2>Other Module Level Functions</h2> <p>The module also provides the following module level functions:</p> <dl class="py function"> <dt class="sig sig-object py" id="ipaddress.v4_int_to_packed">
<code>ipaddress.v4_int_to_packed(address)</code> </dt> <dd>
<p>Represent an address as 4 packed bytes in network (big-endian) order. <em>address</em> is an integer representation of an IPv4 IP address. A <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised if the integer is negative or too large to be an IPv4 IP address.</p> <pre data-language="python">&gt;&gt;&gt; ipaddress.ip_address(3221225985)
IPv4Address('192.0.2.1')
&gt;&gt;&gt; ipaddress.v4_int_to_packed(3221225985)
b'\xc0\x00\x02\x01'
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="ipaddress.v6_int_to_packed">
<code>ipaddress.v6_int_to_packed(address)</code> </dt> <dd>
<p>Represent an address as 16 packed bytes in network (big-endian) order. <em>address</em> is an integer representation of an IPv6 IP address. A <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised if the integer is negative or too large to be an IPv6 IP address.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="ipaddress.summarize_address_range">
<code>ipaddress.summarize_address_range(first, last)</code> </dt> <dd>
<p>Return an iterator of the summarized network range given the first and last IP addresses. <em>first</em> is the first <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a> or <a class="reference internal" href="#ipaddress.IPv6Address" title="ipaddress.IPv6Address"><code>IPv6Address</code></a> in the range and <em>last</em> is the last <a class="reference internal" href="#ipaddress.IPv4Address" title="ipaddress.IPv4Address"><code>IPv4Address</code></a> or <a class="reference internal" href="#ipaddress.IPv6Address" title="ipaddress.IPv6Address"><code>IPv6Address</code></a> in the range. A <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> is raised if <em>first</em> or <em>last</em> are not IP addresses or are not of the same version. A <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised if <em>last</em> is not greater than <em>first</em> or if <em>first</em> address version is not 4 or 6.</p> <pre data-language="python">&gt;&gt;&gt; [ipaddr for ipaddr in ipaddress.summarize_address_range(
...    ipaddress.IPv4Address('192.0.2.0'),
...    ipaddress.IPv4Address('192.0.2.130'))]
[IPv4Network('192.0.2.0/25'), IPv4Network('192.0.2.128/31'), IPv4Network('192.0.2.130/32')]
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="ipaddress.collapse_addresses">
<code>ipaddress.collapse_addresses(addresses)</code> </dt> <dd>
<p>Return an iterator of the collapsed <a class="reference internal" href="#ipaddress.IPv4Network" title="ipaddress.IPv4Network"><code>IPv4Network</code></a> or <a class="reference internal" href="#ipaddress.IPv6Network" title="ipaddress.IPv6Network"><code>IPv6Network</code></a> objects. <em>addresses</em> is an <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> of <a class="reference internal" href="#ipaddress.IPv4Network" title="ipaddress.IPv4Network"><code>IPv4Network</code></a> or <a class="reference internal" href="#ipaddress.IPv6Network" title="ipaddress.IPv6Network"><code>IPv6Network</code></a> objects. A <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> is raised if <em>addresses</em> contains mixed version objects.</p> <pre data-language="python">&gt;&gt;&gt; [ipaddr for ipaddr in
... ipaddress.collapse_addresses([ipaddress.IPv4Network('192.0.2.0/25'),
... ipaddress.IPv4Network('192.0.2.128/25')])]
[IPv4Network('192.0.2.0/24')]
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="ipaddress.get_mixed_type_key">
<code>ipaddress.get_mixed_type_key(obj)</code> </dt> <dd>
<p>Return a key suitable for sorting between networks and addresses. Address and Network objects are not sortable by default; they’re fundamentally different, so the expression:</p> <pre data-language="python">IPv4Address('192.0.2.0') &lt;= IPv4Network('192.0.2.0/24')
</pre> <p>doesn’t make sense. There are some times however, where you may wish to have <a class="reference internal" href="#module-ipaddress" title="ipaddress: IPv4/IPv6 manipulation library."><code>ipaddress</code></a> sort these anyway. If you need to do this, you can use this function as the <em>key</em> argument to <a class="reference internal" href="functions.html#sorted" title="sorted"><code>sorted()</code></a>.</p> <p><em>obj</em> is either a network or address object.</p> </dd>
</dl> </section> <section id="custom-exceptions"> <h2>Custom Exceptions</h2> <p>To support more specific error reporting from class constructors, the module defines the following exceptions:</p> <dl class="py exception"> <dt class="sig sig-object py" id="ipaddress.AddressValueError">
<code>exception ipaddress.AddressValueError(ValueError)</code> </dt> <dd>
<p>Any value error related to the address.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="ipaddress.NetmaskValueError">
<code>exception ipaddress.NetmaskValueError(ValueError)</code> </dt> <dd>
<p>Any value error related to the net mask.</p> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/ipaddress.html" class="_attribution-link">https://docs.python.org/3.13/library/ipaddress.html</a>
  </p>
</div>
