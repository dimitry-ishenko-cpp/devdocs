 <span id="itertools-functions-creating-iterators-for-efficient-looping"></span><h1>itertools — Functions creating iterators for efficient looping</h1>  <p>This module implements a number of <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> building blocks inspired by constructs from APL, Haskell, and SML. Each has been recast in a form suitable for Python.</p> <p>The module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an “iterator algebra” making it possible to construct specialized tools succinctly and efficiently in pure Python.</p> <p>For instance, SML provides a tabulation tool: <code>tabulate(f)</code> which produces a sequence <code>f(0), f(1), ...</code>. The same effect can be achieved in Python by combining <a class="reference internal" href="functions.html#map" title="map"><code>map()</code></a> and <a class="reference internal" href="#itertools.count" title="itertools.count"><code>count()</code></a> to form <code>map(f, count())</code>.</p> <p>These tools and their built-in counterparts also work well with the high-speed functions in the <a class="reference internal" href="operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code>operator</code></a> module. For example, the multiplication operator can be mapped across two vectors to form an efficient dot-product: <code>sum(starmap(operator.mul, zip(vec1, vec2, strict=True)))</code>.</p> <p><strong>Infinite iterators:</strong></p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Iterator</p></th> <th class="head"><p>Arguments</p></th> <th class="head"><p>Results</p></th> <th class="head"><p>Example</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#itertools.count" title="itertools.count"><code>count()</code></a></p></td> <td><p>[start[, step]]</p></td> <td><p>start, start+step, start+2*step, …</p></td> <td><p><code>count(10) → 10 11 12 13 14 ...</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.cycle" title="itertools.cycle"><code>cycle()</code></a></p></td> <td><p>p</p></td> <td><p>p0, p1, … plast, p0, p1, …</p></td> <td><p><code>cycle('ABCD') → A B C D A B C D ...</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.repeat" title="itertools.repeat"><code>repeat()</code></a></p></td> <td><p>elem [,n]</p></td> <td><p>elem, elem, elem, … endlessly or up to n times</p></td> <td><p><code>repeat(10, 3) → 10 10 10</code></p></td> </tr>  </table> <p><strong>Iterators terminating on the shortest input sequence:</strong></p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Iterator</p></th> <th class="head"><p>Arguments</p></th> <th class="head"><p>Results</p></th> <th class="head"><p>Example</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#itertools.accumulate" title="itertools.accumulate"><code>accumulate()</code></a></p></td> <td><p>p [,func]</p></td> <td><p>p0, p0+p1, p0+p1+p2, …</p></td> <td><p><code>accumulate([1,2,3,4,5]) → 1 3 6 10 15</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.batched" title="itertools.batched"><code>batched()</code></a></p></td> <td><p>p, n</p></td> <td><p>(p0, p1, …, p_n-1), …</p></td> <td><p><code>batched('ABCDEFG', n=3) → ABC DEF G</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.chain" title="itertools.chain"><code>chain()</code></a></p></td> <td><p>p, q, …</p></td> <td><p>p0, p1, … plast, q0, q1, …</p></td> <td><p><code>chain('ABC', 'DEF') → A B C D E F</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.chain.from_iterable" title="itertools.chain.from_iterable"><code>chain.from_iterable()</code></a></p></td> <td><p>iterable</p></td> <td><p>p0, p1, … plast, q0, q1, …</p></td> <td><p><code>chain.from_iterable(['ABC', 'DEF']) → A B C D E F</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.compress" title="itertools.compress"><code>compress()</code></a></p></td> <td><p>data, selectors</p></td> <td><p>(d[0] if s[0]), (d[1] if s[1]), …</p></td> <td><p><code>compress('ABCDEF', [1,0,1,0,1,1]) → A C E F</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.dropwhile" title="itertools.dropwhile"><code>dropwhile()</code></a></p></td> <td><p>predicate, seq</p></td> <td><p>seq[n], seq[n+1], starting when predicate fails</p></td> <td><p><code>dropwhile(lambda x: x&lt;5, [1,4,6,3,8]) → 6 3 8</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.filterfalse" title="itertools.filterfalse"><code>filterfalse()</code></a></p></td> <td><p>predicate, seq</p></td> <td><p>elements of seq where predicate(elem) fails</p></td> <td><p><code>filterfalse(lambda x: x&lt;5, [1,4,6,3,8]) → 6 8</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code>groupby()</code></a></p></td> <td><p>iterable[, key]</p></td> <td><p>sub-iterators grouped by value of key(v)</p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.islice" title="itertools.islice"><code>islice()</code></a></p></td> <td><p>seq, [start,] stop [, step]</p></td> <td><p>elements from seq[start:stop:step]</p></td> <td><p><code>islice('ABCDEFG', 2, None) → C D E F G</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.pairwise" title="itertools.pairwise"><code>pairwise()</code></a></p></td> <td><p>iterable</p></td> <td><p>(p[0], p[1]), (p[1], p[2])</p></td> <td><p><code>pairwise('ABCDEFG') → AB BC CD DE EF FG</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><code>starmap()</code></a></p></td> <td><p>func, seq</p></td> <td><p>func(*seq[0]), func(*seq[1]), …</p></td> <td><p><code>starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.takewhile" title="itertools.takewhile"><code>takewhile()</code></a></p></td> <td><p>predicate, seq</p></td> <td><p>seq[0], seq[1], until predicate fails</p></td> <td><p><code>takewhile(lambda x: x&lt;5, [1,4,6,3,8]) → 1 4</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.tee" title="itertools.tee"><code>tee()</code></a></p></td> <td><p>it, n</p></td> <td><p>it1, it2, … itn splits one iterator into n</p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.zip_longest" title="itertools.zip_longest"><code>zip_longest()</code></a></p></td> <td><p>p, q, …</p></td> <td><p>(p[0], q[0]), (p[1], q[1]), …</p></td> <td><p><code>zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-</code></p></td> </tr>  </table> <p><strong>Combinatoric iterators:</strong></p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Iterator</p></th> <th class="head"><p>Arguments</p></th> <th class="head"><p>Results</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#itertools.product" title="itertools.product"><code>product()</code></a></p></td> <td><p>p, q, … [repeat=1]</p></td> <td><p>cartesian product, equivalent to a nested for-loop</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.permutations" title="itertools.permutations"><code>permutations()</code></a></p></td> <td><p>p[, r]</p></td> <td><p>r-length tuples, all possible orderings, no repeated elements</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.combinations" title="itertools.combinations"><code>combinations()</code></a></p></td> <td><p>p, r</p></td> <td><p>r-length tuples, in sorted order, no repeated elements</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.combinations_with_replacement" title="itertools.combinations_with_replacement"><code>combinations_with_replacement()</code></a></p></td> <td><p>p, r</p></td> <td><p>r-length tuples, in sorted order, with repeated elements</p></td> </tr>  </table> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Examples</p></th> <th class="head"><p>Results</p></th> </tr> </thead>  <tr>
<td><p><code>product('ABCD', repeat=2)</code></p></td> <td><p><code>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</code></p></td> </tr> <tr>
<td><p><code>permutations('ABCD', 2)</code></p></td> <td><p><code>AB AC AD BA BC BD CA CB CD DA DB DC</code></p></td> </tr> <tr>
<td><p><code>combinations('ABCD', 2)</code></p></td> <td><p><code>AB AC AD BC BD CD</code></p></td> </tr> <tr>
<td><p><code>combinations_with_replacement('ABCD', 2)</code></p></td> <td><p><code>AA AB AC AD BB BC BD CC CD DD</code></p></td> </tr>  </table> <section id="itertool-functions"> <span id="itertools-functions"></span><h2>Itertool Functions</h2> <p>The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream.</p> <dl class="py function"> <dt class="sig sig-object py" id="itertools.accumulate">
<code>itertools.accumulate(iterable[, function, *, initial=None])</code> </dt> <dd>
<p>Make an iterator that returns accumulated sums or accumulated results from other binary functions.</p> <p>The <em>function</em> defaults to addition. The <em>function</em> should accept two arguments, an accumulated total and a value from the <em>iterable</em>.</p> <p>If an <em>initial</em> value is provided, the accumulation will start with that value and the output will have one more element than the input iterable.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def accumulate(iterable, function=operator.add, *, initial=None):
    'Return running totals'
    # accumulate([1,2,3,4,5]) → 1 3 6 10 15
    # accumulate([1,2,3,4,5], initial=100) → 100 101 103 106 110 115
    # accumulate([1,2,3,4,5], operator.mul) → 1 2 6 24 120

    iterator = iter(iterable)
    total = initial
    if initial is None:
        try:
            total = next(iterator)
        except StopIteration:
            return

    yield total
    for element in iterator:
        total = function(total, element)
        yield total
</pre> <p>The <em>function</em> argument can be set to <a class="reference internal" href="functions.html#min" title="min"><code>min()</code></a> for a running minimum, <a class="reference internal" href="functions.html#max" title="max"><code>max()</code></a> for a running maximum, or <a class="reference internal" href="operator.html#operator.mul" title="operator.mul"><code>operator.mul()</code></a> for a running product. <a class="reference external" href="https://www.ramseysolutions.com/real-estate/amortization-schedule">Amortization tables</a> can be built by accumulating interest and applying payments:</p> <pre data-language="pycon">&gt;&gt;&gt; data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]
&gt;&gt;&gt; list(accumulate(data, max))              # running maximum
[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]
&gt;&gt;&gt; list(accumulate(data, operator.mul))     # running product
[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]

# Amortize a 5% loan of 1000 with 10 annual payments of 90
&gt;&gt;&gt; update = lambda balance, payment: round(balance * 1.05) - payment
&gt;&gt;&gt; list(accumulate(repeat(90, 10), update, initial=1_000))
[1000, 960, 918, 874, 828, 779, 728, 674, 618, 559, 497]
</pre> <p>See <a class="reference internal" href="functools.html#functools.reduce" title="functools.reduce"><code>functools.reduce()</code></a> for a similar function that returns only the final accumulated value.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added the optional <em>function</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added the optional <em>initial</em> parameter.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.batched">
<code>itertools.batched(iterable, n, *, strict=False)</code> </dt> <dd>
<p>Batch data from the <em>iterable</em> into tuples of length <em>n</em>. The last batch may be shorter than <em>n</em>.</p> <p>If <em>strict</em> is true, will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if the final batch is shorter than <em>n</em>.</p> <p>Loops over the input iterable and accumulates data into tuples up to size <em>n</em>. The input is consumed lazily, just enough to fill a batch. The result is yielded as soon as the batch is full or when the input iterable is exhausted:</p> <pre data-language="pycon">&gt;&gt;&gt; flattened_data = ['roses', 'red', 'violets', 'blue', 'sugar', 'sweet']
&gt;&gt;&gt; unflattened = list(batched(flattened_data, 2))
&gt;&gt;&gt; unflattened
[('roses', 'red'), ('violets', 'blue'), ('sugar', 'sweet')]
</pre> <p>Roughly equivalent to:</p> <pre data-language="python">def batched(iterable, n, *, strict=False):
    # batched('ABCDEFG', 3) → ABC DEF G
    if n &lt; 1:
        raise ValueError('n must be at least one')
    iterator = iter(iterable)
    while batch := tuple(islice(iterator, n)):
        if strict and len(batch) != n:
            raise ValueError('batched(): incomplete batch')
        yield batch
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Added the <em>strict</em> option.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.chain">
<code>itertools.chain(*iterables)</code> </dt> <dd>
<p>Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to:</p> <pre data-language="python">def chain(*iterables):
    # chain('ABC', 'DEF') → A B C D E F
    for iterable in iterables:
        yield from iterable
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="itertools.chain.from_iterable">
<code>classmethod chain.from_iterable(iterable)</code> </dt> <dd>
<p>Alternate constructor for <a class="reference internal" href="#itertools.chain" title="itertools.chain"><code>chain()</code></a>. Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to:</p> <pre data-language="python">def from_iterable(iterables):
    # chain.from_iterable(['ABC', 'DEF']) → A B C D E F
    for iterable in iterables:
        yield from iterable
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.combinations">
<code>itertools.combinations(iterable, r)</code> </dt> <dd>
<p>Return <em>r</em> length subsequences of elements from the input <em>iterable</em>.</p> <p>The output is a subsequence of <a class="reference internal" href="#itertools.product" title="itertools.product"><code>product()</code></a> keeping only entries that are subsequences of the <em>iterable</em>. The length of the output is given by <a class="reference internal" href="math.html#math.comb" title="math.comb"><code>math.comb()</code></a> which computes <code>n! / r! / (n - r)!</code> when <code>0 ≤ r
≤ n</code> or zero when <code>r &gt; n</code>.</p> <p>The combination tuples are emitted in lexicographic order according to the order of the input <em>iterable</em>. If the input <em>iterable</em> is sorted, the output tuples will be produced in sorted order.</p> <p>Elements are treated as unique based on their position, not on their value. If the input elements are unique, there will be no repeated values within each combination.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def combinations(iterable, r):
    # combinations('ABCD', 2) → AB AC AD BC BD CD
    # combinations(range(4), 3) → 012 013 023 123

    pool = tuple(iterable)
    n = len(pool)
    if r &gt; n:
        return
    indices = list(range(r))

    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i] != i + n - r:
                break
        else:
            return
        indices[i] += 1
        for j in range(i+1, r):
            indices[j] = indices[j-1] + 1
        yield tuple(pool[i] for i in indices)
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.combinations_with_replacement">
<code>itertools.combinations_with_replacement(iterable, r)</code> </dt> <dd>
<p>Return <em>r</em> length subsequences of elements from the input <em>iterable</em> allowing individual elements to be repeated more than once.</p> <p>The output is a subsequence of <a class="reference internal" href="#itertools.product" title="itertools.product"><code>product()</code></a> that keeps only entries that are subsequences (with possible repeated elements) of the <em>iterable</em>. The number of subsequence returned is <code>(n + r - 1)! / r! /
(n - 1)!</code> when <code>n &gt; 0</code>.</p> <p>The combination tuples are emitted in lexicographic order according to the order of the input <em>iterable</em>. if the input <em>iterable</em> is sorted, the output tuples will be produced in sorted order.</p> <p>Elements are treated as unique based on their position, not on their value. If the input elements are unique, the generated combinations will also be unique.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def combinations_with_replacement(iterable, r):
    # combinations_with_replacement('ABC', 2) → AA AB AC BB BC CC

    pool = tuple(iterable)
    n = len(pool)
    if not n and r:
        return
    indices = [0] * r

    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i] != n - 1:
                break
        else:
            return
        indices[i:] = [indices[i] + 1] * (r - i)
        yield tuple(pool[i] for i in indices)
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.1.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.compress">
<code>itertools.compress(data, selectors)</code> </dt> <dd>
<p>Make an iterator that returns elements from <em>data</em> where the corresponding element in <em>selectors</em> is true. Stops when either the <em>data</em> or <em>selectors</em> iterables have been exhausted. Roughly equivalent to:</p> <pre data-language="python">def compress(data, selectors):
    # compress('ABCDEF', [1,0,1,0,1,1]) → A C E F
    return (datum for datum, selector in zip(data, selectors) if selector)
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.1.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.count">
<code>itertools.count(start=0, step=1)</code> </dt> <dd>
<p>Make an iterator that returns evenly spaced values beginning with <em>start</em>. Can be used with <a class="reference internal" href="functions.html#map" title="map"><code>map()</code></a> to generate consecutive data points or with <a class="reference internal" href="functions.html#zip" title="zip"><code>zip()</code></a> to add sequence numbers. Roughly equivalent to:</p> <pre data-language="python">def count(start=0, step=1):
    # count(10) → 10 11 12 13 14 ...
    # count(2.5, 0.5) → 2.5 3.0 3.5 ...
    n = start
    while True:
        yield n
        n += step
</pre> <p>When counting with floating-point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: <code>(start + step * i
for i in count())</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.1: </span>Added <em>step</em> argument and allowed non-integer arguments.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.cycle">
<code>itertools.cycle(iterable)</code> </dt> <dd>
<p>Make an iterator returning elements from the <em>iterable</em> and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to:</p> <pre data-language="python">def cycle(iterable):
    # cycle('ABCD') → A B C D A B C D A B C D ...
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
            yield element
</pre> <p>This itertool may require significant auxiliary storage (depending on the length of the iterable).</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.dropwhile">
<code>itertools.dropwhile(predicate, iterable)</code> </dt> <dd>
<p>Make an iterator that drops elements from the <em>iterable</em> while the <em>predicate</em> is true and afterwards returns every element. Roughly equivalent to:</p> <pre data-language="python">def dropwhile(predicate, iterable):
    # dropwhile(lambda x: x&lt;5, [1,4,6,3,8]) → 6 3 8

    iterator = iter(iterable)
    for x in iterator:
        if not predicate(x):
            yield x
            break

    for x in iterator:
        yield x
</pre> <p>Note this does not produce <em>any</em> output until the predicate first becomes false, so this itertool may have a lengthy start-up time.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.filterfalse">
<code>itertools.filterfalse(predicate, iterable)</code> </dt> <dd>
<p>Make an iterator that filters elements from the <em>iterable</em> returning only those for which the <em>predicate</em> returns a false value. If <em>predicate</em> is <code>None</code>, returns the items that are false. Roughly equivalent to:</p> <pre data-language="python">def filterfalse(predicate, iterable):
    # filterfalse(lambda x: x&lt;5, [1,4,6,3,8]) → 6 8
    if predicate is None:
        predicate = bool
    for x in iterable:
        if not predicate(x):
            yield x
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.groupby">
<code>itertools.groupby(iterable, key=None)</code> </dt> <dd>
<p>Make an iterator that returns consecutive keys and groups from the <em>iterable</em>. The <em>key</em> is a function computing a key value for each element. If not specified or is <code>None</code>, <em>key</em> defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function.</p> <p>The operation of <a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code>groupby()</code></a> is similar to the <code>uniq</code> filter in Unix. It generates a break or new group every time the value of the key function changes (which is why it is usually necessary to have sorted the data using the same key function). That behavior differs from SQL’s GROUP BY which aggregates common elements regardless of their input order.</p> <p>The returned group is itself an iterator that shares the underlying iterable with <a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code>groupby()</code></a>. Because the source is shared, when the <a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code>groupby()</code></a> object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list:</p> <pre data-language="python">groups = []
uniquekeys = []
data = sorted(data, key=keyfunc)
for k, g in groupby(data, keyfunc):
    groups.append(list(g))      # Store group iterator as a list
    uniquekeys.append(k)
</pre> <p><a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code>groupby()</code></a> is roughly equivalent to:</p> <pre data-language="python">def groupby(iterable, key=None):
    # [k for k, g in groupby('AAAABBBCCDAABBB')] → A B C D A B
    # [list(g) for k, g in groupby('AAAABBBCCD')] → AAAA BBB CC D

    keyfunc = (lambda x: x) if key is None else key
    iterator = iter(iterable)
    exhausted = False

    def _grouper(target_key):
        nonlocal curr_value, curr_key, exhausted
        yield curr_value
        for curr_value in iterator:
            curr_key = keyfunc(curr_value)
            if curr_key != target_key:
                return
            yield curr_value
        exhausted = True

    try:
        curr_value = next(iterator)
    except StopIteration:
        return
    curr_key = keyfunc(curr_value)

    while not exhausted:
        target_key = curr_key
        curr_group = _grouper(target_key)
        yield curr_key, curr_group
        if curr_key == target_key:
            for _ in curr_group:
                pass
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.islice">
<code>itertools.islice(iterable, stop)</code> </dt> <dt class="sig sig-object py"> <span class="sig-prename descclassname">itertools.</span><span class="sig-name descname">islice</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">iterable</span></em>, <em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">stop</span></em><span class="optional">[</span>, <em class="sig-param"><span class="n">step</span></em><span class="optional">]</span><span class="sig-paren">)</span>
</dt> <dd>
<p>Make an iterator that returns selected elements from the iterable. Works like sequence slicing but does not support negative values for <em>start</em>, <em>stop</em>, or <em>step</em>.</p> <p>If <em>start</em> is zero or <code>None</code>, iteration starts at zero. Otherwise, elements from the iterable are skipped until <em>start</em> is reached.</p> <p>If <em>stop</em> is <code>None</code>, iteration continues until the iterator is exhausted, if at all. Otherwise, it stops at the specified position.</p> <p>If <em>step</em> is <code>None</code>, the step defaults to one. Elements are returned consecutively unless <em>step</em> is set higher than one which results in items being skipped.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def islice(iterable, *args):
    # islice('ABCDEFG', 2) → A B
    # islice('ABCDEFG', 2, 4) → C D
    # islice('ABCDEFG', 2, None) → C D E F G
    # islice('ABCDEFG', 0, None, 2) → A C E G

    s = slice(*args)
    start = 0 if s.start is None else s.start
    stop = s.stop
    step = 1 if s.step is None else s.step
    if start &lt; 0 or (stop is not None and stop &lt; 0) or step &lt;= 0:
        raise ValueError

    indices = count() if stop is None else range(max(start, stop))
    next_i = start
    for i, element in zip(indices, iterable):
        if i == next_i:
            yield element
            next_i += step
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.pairwise">
<code>itertools.pairwise(iterable)</code> </dt> <dd>
<p>Return successive overlapping pairs taken from the input <em>iterable</em>.</p> <p>The number of 2-tuples in the output iterator will be one fewer than the number of inputs. It will be empty if the input iterable has fewer than two values.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def pairwise(iterable):
    # pairwise('ABCDEFG') → AB BC CD DE EF FG
    iterator = iter(iterable)
    a = next(iterator, None)
    for b in iterator:
        yield a, b
        a = b
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.permutations">
<code>itertools.permutations(iterable, r=None)</code> </dt> <dd>
<p>Return successive <em>r</em> length <a class="reference external" href="https://www.britannica.com/science/permutation">permutations of elements</a> from the <em>iterable</em>.</p> <p>If <em>r</em> is not specified or is <code>None</code>, then <em>r</em> defaults to the length of the <em>iterable</em> and all possible full-length permutations are generated.</p> <p>The output is a subsequence of <a class="reference internal" href="#itertools.product" title="itertools.product"><code>product()</code></a> where entries with repeated elements have been filtered out. The length of the output is given by <a class="reference internal" href="math.html#math.perm" title="math.perm"><code>math.perm()</code></a> which computes <code>n! / (n - r)!</code> when <code>0 ≤ r ≤ n</code> or zero when <code>r &gt; n</code>.</p> <p>The permutation tuples are emitted in lexicographic order according to the order of the input <em>iterable</em>. If the input <em>iterable</em> is sorted, the output tuples will be produced in sorted order.</p> <p>Elements are treated as unique based on their position, not on their value. If the input elements are unique, there will be no repeated values within a permutation.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def permutations(iterable, r=None):
    # permutations('ABCD', 2) → AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) → 012 021 102 120 201 210

    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    if r &gt; n:
        return

    indices = list(range(n))
    cycles = list(range(n, n-r, -1))
    yield tuple(pool[i] for i in indices[:r])

    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield tuple(pool[i] for i in indices[:r])
                break
        else:
            return
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.product">
<code>itertools.product(*iterables, repeat=1)</code> </dt> <dd>
<p>Cartesian product of input iterables.</p> <p>Roughly equivalent to nested for-loops in a generator expression. For example, <code>product(A, B)</code> returns the same as <code>((x,y) for x in A for y in B)</code>.</p> <p>The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order.</p> <p>To compute the product of an iterable with itself, specify the number of repetitions with the optional <em>repeat</em> keyword argument. For example, <code>product(A, repeat=4)</code> means the same as <code>product(A, A, A, A)</code>.</p> <p>This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory:</p> <pre data-language="python">def product(*iterables, repeat=1):
    # product('ABCD', 'xy') → Ax Ay Bx By Cx Cy Dx Dy
    # product(range(2), repeat=3) → 000 001 010 011 100 101 110 111

    pools = [tuple(pool) for pool in iterables] * repeat

    result = [[]]
    for pool in pools:
        result = [x+[y] for x in result for y in pool]

    for prod in result:
        yield tuple(prod)
</pre> <p>Before <a class="reference internal" href="#itertools.product" title="itertools.product"><code>product()</code></a> runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.repeat">
<code>itertools.repeat(object[, times])</code> </dt> <dd>
<p>Make an iterator that returns <em>object</em> over and over again. Runs indefinitely unless the <em>times</em> argument is specified.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def repeat(object, times=None):
    # repeat(10, 3) → 10 10 10
    if times is None:
        while True:
            yield object
    else:
        for i in range(times):
            yield object
</pre> <p>A common use for <em>repeat</em> is to supply a stream of constant values to <em>map</em> or <em>zip</em>:</p> <pre data-language="pycon">&gt;&gt;&gt; list(map(pow, range(10), repeat(2)))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.starmap">
<code>itertools.starmap(function, iterable)</code> </dt> <dd>
<p>Make an iterator that computes the <em>function</em> using arguments obtained from the <em>iterable</em>. Used instead of <a class="reference internal" href="functions.html#map" title="map"><code>map()</code></a> when argument parameters have already been “pre-zipped” into tuples.</p> <p>The difference between <a class="reference internal" href="functions.html#map" title="map"><code>map()</code></a> and <a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><code>starmap()</code></a> parallels the distinction between <code>function(a,b)</code> and <code>function(*c)</code>. Roughly equivalent to:</p> <pre data-language="python">def starmap(function, iterable):
    # starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000
    for args in iterable:
        yield function(*args)
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.takewhile">
<code>itertools.takewhile(predicate, iterable)</code> </dt> <dd>
<p>Make an iterator that returns elements from the <em>iterable</em> as long as the <em>predicate</em> is true. Roughly equivalent to:</p> <pre data-language="python">def takewhile(predicate, iterable):
    # takewhile(lambda x: x&lt;5, [1,4,6,3,8]) → 1 4
    for x in iterable:
        if not predicate(x):
            break
        yield x
</pre> <p>Note, the element that first fails the predicate condition is consumed from the input iterator and there is no way to access it. This could be an issue if an application wants to further consume the input iterator after <em>takewhile</em> has been run to exhaustion. To work around this problem, consider using <a class="reference external" href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.before_and_after">more-iterools before_and_after()</a> instead.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.tee">
<code>itertools.tee(iterable, n=2)</code> </dt> <dd>
<p>Return <em>n</em> independent iterators from a single iterable.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def tee(iterable, n=2):
    iterator = iter(iterable)
    shared_link = [None, None]
    return tuple(_tee(iterator, shared_link) for _ in range(n))

def _tee(iterator, link):
    try:
        while True:
            if link[1] is None:
                link[0] = next(iterator)
                link[1] = [None, None]
            value, link = link
            yield value
    except StopIteration:
        return
</pre> <p>Once a <a class="reference internal" href="#itertools.tee" title="itertools.tee"><code>tee()</code></a> has been created, the original <em>iterable</em> should not be used anywhere else; otherwise, the <em>iterable</em> could get advanced without the tee objects being informed.</p> <p><code>tee</code> iterators are not threadsafe. A <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> may be raised when simultaneously using iterators returned by the same <a class="reference internal" href="#itertools.tee" title="itertools.tee"><code>tee()</code></a> call, even if the original <em>iterable</em> is threadsafe.</p> <p>This itertool may require significant auxiliary storage (depending on how much temporary data needs to be stored). In general, if one iterator uses most or all of the data before another iterator starts, it is faster to use <a class="reference internal" href="stdtypes.html#list" title="list"><code>list()</code></a> instead of <a class="reference internal" href="#itertools.tee" title="itertools.tee"><code>tee()</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="itertools.zip_longest">
<code>itertools.zip_longest(*iterables, fillvalue=None)</code> </dt> <dd>
<p>Make an iterator that aggregates elements from each of the <em>iterables</em>.</p> <p>If the iterables are of uneven length, missing values are filled-in with <em>fillvalue</em>. If not specified, <em>fillvalue</em> defaults to <code>None</code>.</p> <p>Iteration continues until the longest iterable is exhausted.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def zip_longest(*iterables, fillvalue=None):
    # zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-

    iterators = list(map(iter, iterables))
    num_active = len(iterators)
    if not num_active:
        return

    while True:
        values = []
        for i, iterator in enumerate(iterators):
            try:
                value = next(iterator)
            except StopIteration:
                num_active -= 1
                if not num_active:
                    return
                iterators[i] = repeat(fillvalue)
                value = fillvalue
            values.append(value)
        yield tuple(values)
</pre> <p>If one of the iterables is potentially infinite, then the <a class="reference internal" href="#itertools.zip_longest" title="itertools.zip_longest"><code>zip_longest()</code></a> function should be wrapped with something that limits the number of calls (for example <a class="reference internal" href="#itertools.islice" title="itertools.islice"><code>islice()</code></a> or <a class="reference internal" href="#itertools.takewhile" title="itertools.takewhile"><code>takewhile()</code></a>).</p> </dd>
</dl> </section> <section id="itertools-recipes"> <span id="id1"></span><h2>Itertools Recipes</h2> <p>This section shows recipes for creating an extended toolset using the existing itertools as building blocks.</p> <p>The primary purpose of the itertools recipes is educational. The recipes show various ways of thinking about individual tools — for example, that <code>chain.from_iterable</code> is related to the concept of flattening. The recipes also give ideas about ways that the tools can be combined — for example, how <code>starmap()</code> and <code>repeat()</code> can work together. The recipes also show patterns for using itertools with the <a class="reference internal" href="operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code>operator</code></a> and <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code>collections</code></a> modules as well as with the built-in itertools such as <code>map()</code>, <code>filter()</code>, <code>reversed()</code>, and <code>enumerate()</code>.</p> <p>A secondary purpose of the recipes is to serve as an incubator. The <code>accumulate()</code>, <code>compress()</code>, and <code>pairwise()</code> itertools started out as recipes. Currently, the <code>sliding_window()</code>, <code>iter_index()</code>, and <code>sieve()</code> recipes are being tested to see whether they prove their worth.</p> <p>Substantially all of these recipes and many, many others can be installed from the <a class="extlink-pypi reference external" href="https://pypi.org/project/more-itertools/">more-itertools</a> project found on the Python Package Index:</p> <pre data-language="python">python -m pip install more-itertools
</pre> <p>Many of the recipes offer the same high performance as the underlying toolset. Superior memory performance is kept by processing elements one at a time rather than bringing the whole iterable into memory all at once. Code volume is kept small by linking the tools together in a <a class="reference external" href="https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf">functional style</a>. High speed is retained by preferring “vectorized” building blocks over the use of for-loops and <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generators</span></a> which incur interpreter overhead.</p> <pre data-language="python">import collections
import contextlib
import functools
import math
import operator
import random

def take(n, iterable):
    "Return first n items of the iterable as a list."
    return list(islice(iterable, n))

def prepend(value, iterable):
    "Prepend a single value in front of an iterable."
    # prepend(1, [2, 3, 4]) → 1 2 3 4
    return chain([value], iterable)

def tabulate(function, start=0):
    "Return function(0), function(1), ..."
    return map(function, count(start))

def repeatfunc(func, times=None, *args):
    "Repeat calls to func with specified arguments."
    if times is None:
        return starmap(func, repeat(args))
    return starmap(func, repeat(args, times))

def flatten(list_of_lists):
    "Flatten one level of nesting."
    return chain.from_iterable(list_of_lists)

def ncycles(iterable, n):
    "Returns the sequence elements n times."
    return chain.from_iterable(repeat(tuple(iterable), n))

def tail(n, iterable):
    "Return an iterator over the last n items."
    # tail(3, 'ABCDEFG') → E F G
    return iter(collections.deque(iterable, maxlen=n))

def consume(iterator, n=None):
    "Advance the iterator n-steps ahead. If n is None, consume entirely."
    # Use functions that consume iterators at C speed.
    if n is None:
        collections.deque(iterator, maxlen=0)
    else:
        next(islice(iterator, n, n), None)

def nth(iterable, n, default=None):
    "Returns the nth item or a default value."
    return next(islice(iterable, n, None), default)

def quantify(iterable, predicate=bool):
    "Given a predicate that returns True or False, count the True results."
    return sum(map(predicate, iterable))

def first_true(iterable, default=False, predicate=None):
    "Returns the first true value or the *default* if there is no true value."
    # first_true([a,b,c], x) → a or b or c or x
    # first_true([a,b], x, f) → a if f(a) else b if f(b) else x
    return next(filter(predicate, iterable), default)

def all_equal(iterable, key=None):
    "Returns True if all the elements are equal to each other."
    # all_equal('4٤௪౪໔', key=int) → True
    return len(take(2, groupby(iterable, key))) &lt;= 1

def unique_justseen(iterable, key=None):
    "Yield unique elements, preserving order. Remember only the element just seen."
    # unique_justseen('AAAABBBCCDAABBB') → A B C D A B
    # unique_justseen('ABBcCAD', str.casefold) → A B c A D
    if key is None:
        return map(operator.itemgetter(0), groupby(iterable))
    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))

def unique_everseen(iterable, key=None):
    "Yield unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') → A B C D
    # unique_everseen('ABBcCAD', str.casefold) → A B c D
    seen = set()
    if key is None:
        for element in filterfalse(seen.__contains__, iterable):
            seen.add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen.add(k)
                yield element

def unique(iterable, key=None, reverse=False):
   "Yield unique elements in sorted order. Supports unhashable inputs."
   # unique([[1, 2], [3, 4], [1, 2]]) → [1, 2] [3, 4]
   return unique_justseen(sorted(iterable, key=key, reverse=reverse), key=key)

def sliding_window(iterable, n):
    "Collect data into overlapping fixed-length chunks or blocks."
    # sliding_window('ABCDEFG', 4) → ABCD BCDE CDEF DEFG
    iterator = iter(iterable)
    window = collections.deque(islice(iterator, n - 1), maxlen=n)
    for x in iterator:
        window.append(x)
        yield tuple(window)

def grouper(iterable, n, *, incomplete='fill', fillvalue=None):
    "Collect data into non-overlapping fixed-length chunks or blocks."
    # grouper('ABCDEFG', 3, fillvalue='x') → ABC DEF Gxx
    # grouper('ABCDEFG', 3, incomplete='strict') → ABC DEF ValueError
    # grouper('ABCDEFG', 3, incomplete='ignore') → ABC DEF
    iterators = [iter(iterable)] * n
    match incomplete:
        case 'fill':
            return zip_longest(*iterators, fillvalue=fillvalue)
        case 'strict':
            return zip(*iterators, strict=True)
        case 'ignore':
            return zip(*iterators)
        case _:
            raise ValueError('Expected fill, strict, or ignore')

def roundrobin(*iterables):
    "Visit input iterables in a cycle until each is exhausted."
    # roundrobin('ABC', 'D', 'EF') → A D E B F C
    # Algorithm credited to George Sakkis
    iterators = map(iter, iterables)
    for num_active in range(len(iterables), 0, -1):
        iterators = cycle(islice(iterators, num_active))
        yield from map(next, iterators)

def partition(predicate, iterable):
    """Partition entries into false entries and true entries.

    If *predicate* is slow, consider wrapping it with functools.lru_cache().
    """
    # partition(is_odd, range(10)) → 0 2 4 6 8   and  1 3 5 7 9
    t1, t2 = tee(iterable)
    return filterfalse(predicate, t1), filter(predicate, t2)

def subslices(seq):
    "Return all contiguous non-empty subslices of a sequence."
    # subslices('ABCD') → A AB ABC ABCD B BC BCD C CD D
    slices = starmap(slice, combinations(range(len(seq) + 1), 2))
    return map(operator.getitem, repeat(seq), slices)

def iter_index(iterable, value, start=0, stop=None):
    "Return indices where a value occurs in a sequence or iterable."
    # iter_index('AABCADEAF', 'A') → 0 1 4 7
    seq_index = getattr(iterable, 'index', None)
    if seq_index is None:
        iterator = islice(iterable, start, stop)
        for i, element in enumerate(iterator, start):
            if element is value or element == value:
                yield i
    else:
        stop = len(iterable) if stop is None else stop
        i = start
        with contextlib.suppress(ValueError):
            while True:
                yield (i := seq_index(value, i, stop))
                i += 1

def iter_except(func, exception, first=None):
    "Convert a call-until-exception interface to an iterator interface."
    # iter_except(d.popitem, KeyError) → non-blocking dictionary iterator
    with contextlib.suppress(exception):
        if first is not None:
            yield first()
        while True:
            yield func()
</pre> <p>The following recipes have a more mathematical flavor:</p> <pre data-language="python">def powerset(iterable):
    "powerset([1,2,3]) → () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

def sum_of_squares(iterable):
    "Add up the squares of the input values."
    # sum_of_squares([10, 20, 30]) → 1400
    return math.sumprod(*tee(iterable))

def reshape(matrix, cols):
    "Reshape a 2-D matrix to have a given number of columns."
    # reshape([(0, 1), (2, 3), (4, 5)], 3) →  (0, 1, 2), (3, 4, 5)
    return batched(chain.from_iterable(matrix), cols, strict=True)

def transpose(matrix):
    "Swap the rows and columns of a 2-D matrix."
    # transpose([(1, 2, 3), (11, 22, 33)]) → (1, 11) (2, 22) (3, 33)
    return zip(*matrix, strict=True)

def matmul(m1, m2):
    "Multiply two matrices."
    # matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]) → (49, 80), (41, 60)
    n = len(m2[0])
    return batched(starmap(math.sumprod, product(m1, transpose(m2))), n)

def convolve(signal, kernel):
    """Discrete linear convolution of two iterables.
    Equivalent to polynomial multiplication.

    Convolutions are mathematically commutative; however, the inputs are
    evaluated differently.  The signal is consumed lazily and can be
    infinite. The kernel is fully consumed before the calculations begin.

    Article:  https://betterexplained.com/articles/intuitive-convolution/
    Video:    https://www.youtube.com/watch?v=KuXjwB4LzSA
    """
    # convolve([1, -1, -20], [1, -3]) → 1 -4 -17 60
    # convolve(data, [0.25, 0.25, 0.25, 0.25]) → Moving average (blur)
    # convolve(data, [1/2, 0, -1/2]) → 1st derivative estimate
    # convolve(data, [1, -2, 1]) → 2nd derivative estimate
    kernel = tuple(kernel)[::-1]
    n = len(kernel)
    padded_signal = chain(repeat(0, n-1), signal, repeat(0, n-1))
    windowed_signal = sliding_window(padded_signal, n)
    return map(math.sumprod, repeat(kernel), windowed_signal)

def polynomial_from_roots(roots):
    """Compute a polynomial's coefficients from its roots.

       (x - 5) (x + 4) (x - 3)  expands to:   x³ -4x² -17x + 60
    """
    # polynomial_from_roots([5, -4, 3]) → [1, -4, -17, 60]
    factors = zip(repeat(1), map(operator.neg, roots))
    return list(functools.reduce(convolve, factors, [1]))

def polynomial_eval(coefficients, x):
    """Evaluate a polynomial at a specific value.

    Computes with better numeric stability than Horner's method.
    """
    # Evaluate x³ -4x² -17x + 60 at x = 5
    # polynomial_eval([1, -4, -17, 60], x=5) → 0
    n = len(coefficients)
    if not n:
        return type(x)(0)
    powers = map(pow, repeat(x), reversed(range(n)))
    return math.sumprod(coefficients, powers)

def polynomial_derivative(coefficients):
    """Compute the first derivative of a polynomial.

       f(x)  =  x³ -4x² -17x + 60
       f'(x) = 3x² -8x  -17
    """
    # polynomial_derivative([1, -4, -17, 60]) → [3, -8, -17]
    n = len(coefficients)
    powers = reversed(range(1, n))
    return list(map(operator.mul, coefficients, powers))

def sieve(n):
    "Primes less than n."
    # sieve(30) → 2 3 5 7 11 13 17 19 23 29
    if n &gt; 2:
        yield 2
    data = bytearray((0, 1)) * (n // 2)
    for p in iter_index(data, 1, start=3, stop=math.isqrt(n) + 1):
        data[p*p : n : p+p] = bytes(len(range(p*p, n, p+p)))
    yield from iter_index(data, 1, start=3)

def factor(n):
    "Prime factors of n."
    # factor(99) → 3 3 11
    # factor(1_000_000_000_000_007) → 47 59 360620266859
    # factor(1_000_000_000_000_403) → 1000000000000403
    for prime in sieve(math.isqrt(n) + 1):
        while not n % prime:
            yield prime
            n //= prime
            if n == 1:
                return
    if n &gt; 1:
        yield n

def totient(n):
    "Count of natural numbers up to n that are coprime to n."
    # https://mathworld.wolfram.com/TotientFunction.html
    # totient(12) → 4 because len([1, 5, 7, 11]) == 4
    for prime in set(factor(n)):
        n -= n // prime
    return n
</pre> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/itertools.html" class="_attribution-link">https://docs.python.org/3.13/library/itertools.html</a>
  </p>
</div>
