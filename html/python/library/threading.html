 <span id="threading-thread-based-parallelism"></span><h1>threading — Thread-based parallelism</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/threading.py">Lib/threading.py</a></p>  <p>This module constructs higher-level threading interfaces on top of the lower level <a class="reference internal" href="_thread.html#module-_thread" title="_thread: Low-level threading API."><code>_thread</code></a> module.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>This module used to be optional, it is now always available.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code>concurrent.futures.ThreadPoolExecutor</code></a> offers a higher level interface to push tasks to a background thread without blocking execution of the calling thread, while still being able to retrieve their results when needed.</p> <p><a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code>queue</code></a> provides a thread-safe interface for exchanging data between running threads.</p> <p><a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code>asyncio</code></a> offers an alternative approach to achieving task level concurrency without requiring the use of multiple operating system threads.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In the Python 2.x series, this module contained <code>camelCase</code> names for some methods and functions. These are deprecated as of Python 3.10, but they are still supported for compatibility with Python 2.5 and lower.</p> </div> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> In CPython, due to the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">Global Interpreter Lock</span></a>, only one thread can execute Python code at once (even though certain performance-oriented libraries might overcome this limitation). If you want your application to make better use of the computational resources of multi-core machines, you are advised to use <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code>multiprocessing</code></a> or <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code>concurrent.futures.ProcessPoolExecutor</code></a>. However, threading is still an appropriate model if you want to run multiple I/O-bound tasks simultaneously.</p> </div> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p> <p>This module does not work or is not available on WebAssembly. See <a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#wasm-availability"><span class="std std-ref">WebAssembly platforms</span></a> for more information.</p> </div> <p>This module defines the following functions:</p> <dl class="py function"> <dt class="sig sig-object py" id="threading.active_count">
<code>threading.active_count()</code> </dt> <dd>
<p>Return the number of <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> objects currently alive. The returned count is equal to the length of the list returned by <a class="reference internal" href="#threading.enumerate" title="threading.enumerate"><code>enumerate()</code></a>.</p> <p>The function <code>activeCount</code> is a deprecated alias for this function.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.current_thread">
<code>threading.current_thread()</code> </dt> <dd>
<p>Return the current <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> object, corresponding to the caller’s thread of control. If the caller’s thread of control was not created through the <a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code>threading</code></a> module, a dummy thread object with limited functionality is returned.</p> <p>The function <code>currentThread</code> is a deprecated alias for this function.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.excepthook">
<code>threading.excepthook(args, /)</code> </dt> <dd>
<p>Handle uncaught exception raised by <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>Thread.run()</code></a>.</p> <p>The <em>args</em> argument has the following attributes:</p> <ul class="simple"> <li>
<em>exc_type</em>: Exception type.</li> <li>
<em>exc_value</em>: Exception value, can be <code>None</code>.</li> <li>
<em>exc_traceback</em>: Exception traceback, can be <code>None</code>.</li> <li>
<em>thread</em>: Thread which raised the exception, can be <code>None</code>.</li> </ul> <p>If <em>exc_type</em> is <a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code>SystemExit</code></a>, the exception is silently ignored. Otherwise, the exception is printed out on <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code>sys.stderr</code></a>.</p> <p>If this function raises an exception, <a class="reference internal" href="sys.html#sys.excepthook" title="sys.excepthook"><code>sys.excepthook()</code></a> is called to handle it.</p> <p><a class="reference internal" href="#threading.excepthook" title="threading.excepthook"><code>threading.excepthook()</code></a> can be overridden to control how uncaught exceptions raised by <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>Thread.run()</code></a> are handled.</p> <p>Storing <em>exc_value</em> using a custom hook can create a reference cycle. It should be cleared explicitly to break the reference cycle when the exception is no longer needed.</p> <p>Storing <em>thread</em> using a custom hook can resurrect it if it is set to an object which is being finalized. Avoid storing <em>thread</em> after the custom hook completes to avoid resurrecting objects.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="sys.html#sys.excepthook" title="sys.excepthook"><code>sys.excepthook()</code></a> handles uncaught exceptions.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="threading.__excepthook__">
<code>threading.__excepthook__</code> </dt> <dd>
<p>Holds the original value of <a class="reference internal" href="#threading.excepthook" title="threading.excepthook"><code>threading.excepthook()</code></a>. It is saved so that the original value can be restored in case they happen to get replaced with broken or alternative objects.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.get_ident">
<code>threading.get_ident()</code> </dt> <dd>
<p>Return the ‘thread identifier’ of the current thread. This is a nonzero integer. Its value has no direct meaning; it is intended as a magic cookie to be used e.g. to index a dictionary of thread-specific data. Thread identifiers may be recycled when a thread exits and another thread is created.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.get_native_id">
<code>threading.get_native_id()</code> </dt> <dd>
<p>Return the native integral Thread ID of the current thread assigned by the kernel. This is a non-negative integer. Its value may be used to uniquely identify this particular thread system-wide (until the thread terminates, after which the value may be recycled by the OS).</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX, DragonFlyBSD, GNU/kFreeBSD.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Added support for GNU/kFreeBSD.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.enumerate">
<code>threading.enumerate()</code> </dt> <dd>
<p>Return a list of all <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> objects currently active. The list includes daemonic threads and dummy thread objects created by <a class="reference internal" href="#threading.current_thread" title="threading.current_thread"><code>current_thread()</code></a>. It excludes terminated threads and threads that have not yet been started. However, the main thread is always part of the result, even when terminated.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.main_thread">
<code>threading.main_thread()</code> </dt> <dd>
<p>Return the main <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> object. In normal conditions, the main thread is the thread from which the Python interpreter was started.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.settrace">
<code>threading.settrace(func)</code> </dt> <dd>
<p id="index-0">Set a trace function for all threads started from the <a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code>threading</code></a> module. The <em>func</em> will be passed to <a class="reference internal" href="sys.html#sys.settrace" title="sys.settrace"><code>sys.settrace()</code></a> for each thread, before its <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method is called.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.settrace_all_threads">
<code>threading.settrace_all_threads(func)</code> </dt> <dd>
<p>Set a trace function for all threads started from the <a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code>threading</code></a> module and all Python threads that are currently executing.</p> <p>The <em>func</em> will be passed to <a class="reference internal" href="sys.html#sys.settrace" title="sys.settrace"><code>sys.settrace()</code></a> for each thread, before its <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method is called.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.gettrace">
<code>threading.gettrace()</code> </dt> <dd>
<p id="index-1">Get the trace function as set by <a class="reference internal" href="#threading.settrace" title="threading.settrace"><code>settrace()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.setprofile">
<code>threading.setprofile(func)</code> </dt> <dd>
<p id="index-2">Set a profile function for all threads started from the <a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code>threading</code></a> module. The <em>func</em> will be passed to <a class="reference internal" href="sys.html#sys.setprofile" title="sys.setprofile"><code>sys.setprofile()</code></a> for each thread, before its <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method is called.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.setprofile_all_threads">
<code>threading.setprofile_all_threads(func)</code> </dt> <dd>
<p>Set a profile function for all threads started from the <a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code>threading</code></a> module and all Python threads that are currently executing.</p> <p>The <em>func</em> will be passed to <a class="reference internal" href="sys.html#sys.setprofile" title="sys.setprofile"><code>sys.setprofile()</code></a> for each thread, before its <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method is called.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.getprofile">
<code>threading.getprofile()</code> </dt> <dd>
<p id="index-3">Get the profiler function as set by <a class="reference internal" href="#threading.setprofile" title="threading.setprofile"><code>setprofile()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="threading.stack_size">
<code>threading.stack_size([size])</code> </dt> <dd>
<p>Return the thread stack size used when creating new threads. The optional <em>size</em> argument specifies the stack size to be used for subsequently created threads, and must be 0 (use platform or configured default) or a positive integer value of at least 32,768 (32 KiB). If <em>size</em> is not specified, 0 is used. If changing the thread stack size is unsupported, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised. If the specified stack size is invalid, a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised and the stack size is unmodified. 32 KiB is currently the minimum supported stack size value to guarantee sufficient stack space for the interpreter itself. Note that some platforms may have particular restrictions on values for the stack size, such as requiring a minimum stack size &gt; 32 KiB or requiring allocation in multiples of the system memory page size - platform documentation should be referred to for more information (4 KiB pages are common; using multiples of 4096 for the stack size is the suggested approach in the absence of more specific information).</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows, pthreads.</p> <p>Unix platforms with POSIX threads support.</p> </div> </dd>
</dl> <p>This module also defines the following constant:</p> <dl class="py data"> <dt class="sig sig-object py" id="threading.TIMEOUT_MAX">
<code>threading.TIMEOUT_MAX</code> </dt> <dd>
<p>The maximum value allowed for the <em>timeout</em> parameter of blocking functions (<a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code>Lock.acquire()</code></a>, <a class="reference internal" href="#threading.RLock.acquire" title="threading.RLock.acquire"><code>RLock.acquire()</code></a>, <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code>Condition.wait()</code></a>, etc.). Specifying a timeout greater than this value will raise an <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <p>This module defines a number of classes, which are detailed in the sections below.</p> <p>The design of this module is loosely based on Java’s threading model. However, where Java makes locks and condition variables basic behavior of every object, they are separate objects in Python. Python’s <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> class supports a subset of the behavior of Java’s Thread class; currently, there are no priorities, no thread groups, and threads cannot be destroyed, stopped, suspended, resumed, or interrupted. The static methods of Java’s Thread class, when implemented, are mapped to module-level functions.</p> <p>All of the methods described below are executed atomically.</p> <section id="thread-local-data"> <h2>Thread-Local Data</h2> <p>Thread-local data is data whose values are thread specific. To manage thread-local data, just create an instance of <a class="reference internal" href="#threading.local" title="threading.local"><code>local</code></a> (or a subclass) and store attributes on it:</p> <pre data-language="python">mydata = threading.local()
mydata.x = 1
</pre> <p>The instance’s values will be different for separate threads.</p> <dl class="py class"> <dt class="sig sig-object py" id="threading.local">
<code>class threading.local</code> </dt> <dd>
<p>A class that represents thread-local data.</p> <p>For more details and extensive examples, see the documentation string of the <code>_threading_local</code> module: <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/_threading_local.py">Lib/_threading_local.py</a>.</p> </dd>
</dl> </section> <section id="thread-objects"> <span id="id1"></span><h2>Thread Objects</h2> <p>The <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> class represents an activity that is run in a separate thread of control. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method in a subclass. No other methods (except for the constructor) should be overridden in a subclass. In other words, <em>only</em> override the <code>__init__()</code> and <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> methods of this class.</p> <p>Once a thread object is created, its activity must be started by calling the thread’s <a class="reference internal" href="#threading.Thread.start" title="threading.Thread.start"><code>start()</code></a> method. This invokes the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method in a separate thread of control.</p> <p>Once the thread’s activity is started, the thread is considered ‘alive’. It stops being alive when its <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method terminates – either normally, or by raising an unhandled exception. The <a class="reference internal" href="#threading.Thread.is_alive" title="threading.Thread.is_alive"><code>is_alive()</code></a> method tests whether the thread is alive.</p> <p>Other threads can call a thread’s <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> method. This blocks the calling thread until the thread whose <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> method is called is terminated.</p> <p>A thread has a name. The name can be passed to the constructor, and read or changed through the <a class="reference internal" href="#threading.Thread.name" title="threading.Thread.name"><code>name</code></a> attribute.</p> <p>If the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method raises an exception, <a class="reference internal" href="#threading.excepthook" title="threading.excepthook"><code>threading.excepthook()</code></a> is called to handle it. By default, <a class="reference internal" href="#threading.excepthook" title="threading.excepthook"><code>threading.excepthook()</code></a> ignores silently <a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code>SystemExit</code></a>.</p> <p>A thread can be flagged as a “daemon thread”. The significance of this flag is that the entire Python program exits when only daemon threads are left. The initial value is inherited from the creating thread. The flag can be set through the <a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><code>daemon</code></a> property or the <em>daemon</em> constructor argument.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Daemon threads are abruptly stopped at shutdown. Their resources (such as open files, database transactions, etc.) may not be released properly. If you want your threads to stop gracefully, make them non-daemonic and use a suitable signalling mechanism such as an <a class="reference internal" href="#threading.Event" title="threading.Event"><code>Event</code></a>.</p> </div> <p>There is a “main thread” object; this corresponds to the initial thread of control in the Python program. It is not a daemon thread.</p> <p>There is the possibility that “dummy thread objects” are created. These are thread objects corresponding to “alien threads”, which are threads of control started outside the threading module, such as directly from C code. Dummy thread objects have limited functionality; they are always considered alive and daemonic, and cannot be <a class="reference internal" href="#meth-thread-join"><span class="std std-ref">joined</span></a>. They are never deleted, since it is impossible to detect the termination of alien threads.</p> <dl class="py class"> <dt class="sig sig-object py" id="threading.Thread">
<code>class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)</code> </dt> <dd>
<p>This constructor should always be called with keyword arguments. Arguments are:</p> <p><em>group</em> should be <code>None</code>; reserved for future extension when a <code>ThreadGroup</code> class is implemented.</p> <p><em>target</em> is the callable object to be invoked by the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method. Defaults to <code>None</code>, meaning nothing is called.</p> <p><em>name</em> is the thread name. By default, a unique name is constructed of the form “Thread-<em>N</em>” where <em>N</em> is a small decimal number, or “Thread-<em>N</em> (target)” where “target” is <code>target.__name__</code> if the <em>target</em> argument is specified.</p> <p><em>args</em> is a list or tuple of arguments for the target invocation. Defaults to <code>()</code>.</p> <p><em>kwargs</em> is a dictionary of keyword arguments for the target invocation. Defaults to <code>{}</code>.</p> <p>If not <code>None</code>, <em>daemon</em> explicitly sets whether the thread is daemonic. If <code>None</code> (the default), the daemonic property is inherited from the current thread.</p> <p>If the subclass overrides the constructor, it must make sure to invoke the base class constructor (<code>Thread.__init__()</code>) before doing anything else to the thread.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added the <em>daemon</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>Use the <em>target</em> name if <em>name</em> argument is omitted.</p> </div> <dl class="py method"> <dt class="sig sig-object py" id="threading.Thread.start">
<code>start()</code> </dt> <dd>
<p>Start the thread’s activity.</p> <p>It must be called at most once per thread object. It arranges for the object’s <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method to be invoked in a separate thread of control.</p> <p>This method will raise a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> if called more than once on the same thread object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Thread.run">
<code>run()</code> </dt> <dd>
<p>Method representing the thread’s activity.</p> <p>You may override this method in a subclass. The standard <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method invokes the callable object passed to the object’s constructor as the <em>target</em> argument, if any, with positional and keyword arguments taken from the <em>args</em> and <em>kwargs</em> arguments, respectively.</p> <p>Using list or tuple as the <em>args</em> argument which passed to the <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> could achieve the same effect.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; from threading import Thread
&gt;&gt;&gt; t = Thread(target=print, args=[1])
&gt;&gt;&gt; t.run()
1
&gt;&gt;&gt; t = Thread(target=print, args=(1,))
&gt;&gt;&gt; t.run()
1
</pre> </dd>
</dl> <dl class="py method" id="meth-thread-join"> <dt class="sig sig-object py" id="threading.Thread.join">
<code>join(timeout=None)</code> </dt> <dd>
<p>Wait until the thread terminates. This blocks the calling thread until the thread whose <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> method is called terminates – either normally or through an unhandled exception – or until the optional timeout occurs.</p> <p>When the <em>timeout</em> argument is present and not <code>None</code>, it should be a floating-point number specifying a timeout for the operation in seconds (or fractions thereof). As <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> always returns <code>None</code>, you must call <a class="reference internal" href="#threading.Thread.is_alive" title="threading.Thread.is_alive"><code>is_alive()</code></a> after <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> to decide whether a timeout happened – if the thread is still alive, the <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> call timed out.</p> <p>When the <em>timeout</em> argument is not present or <code>None</code>, the operation will block until the thread terminates.</p> <p>A thread can be joined many times.</p> <p><a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> raises a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> a thread before it has been started and attempts to do so raise the same exception.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="threading.Thread.name">
<code>name</code> </dt> <dd>
<p>A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Thread.getName">
<code>getName()</code> </dt> <dt class="sig sig-object py" id="threading.Thread.setName">
<code>setName()</code> </dt> <dd>
<p>Deprecated getter/setter API for <a class="reference internal" href="#threading.Thread.name" title="threading.Thread.name"><code>name</code></a>; use it directly as a property instead.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.10.</span></p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="threading.Thread.ident">
<code>ident</code> </dt> <dd>
<p>The ‘thread identifier’ of this thread or <code>None</code> if the thread has not been started. This is a nonzero integer. See the <a class="reference internal" href="#threading.get_ident" title="threading.get_ident"><code>get_ident()</code></a> function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="threading.Thread.native_id">
<code>native_id</code> </dt> <dd>
<p>The Thread ID (<code>TID</code>) of this thread, as assigned by the OS (kernel). This is a non-negative integer, or <code>None</code> if the thread has not been started. See the <a class="reference internal" href="#threading.get_native_id" title="threading.get_native_id"><code>get_native_id()</code></a> function. This value may be used to uniquely identify this particular thread system-wide (until the thread terminates, after which the value may be recycled by the OS).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Similar to Process IDs, Thread IDs are only valid (guaranteed unique system-wide) from the time the thread is created until the thread has been terminated.</p> </div> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX, DragonFlyBSD.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Thread.is_alive">
<code>is_alive()</code> </dt> <dd>
<p>Return whether the thread is alive.</p> <p>This method returns <code>True</code> just before the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method starts until just after the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method terminates. The module function <a class="reference internal" href="#threading.enumerate" title="threading.enumerate"><code>enumerate()</code></a> returns a list of all alive threads.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="threading.Thread.daemon">
<code>daemon</code> </dt> <dd>
<p>A boolean value indicating whether this thread is a daemon thread (<code>True</code>) or not (<code>False</code>). This must be set before <a class="reference internal" href="#threading.Thread.start" title="threading.Thread.start"><code>start()</code></a> is called, otherwise <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to <a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><code>daemon</code></a> = <code>False</code>.</p> <p>The entire Python program exits when no alive non-daemon threads are left.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Thread.isDaemon">
<code>isDaemon()</code> </dt> <dt class="sig sig-object py" id="threading.Thread.setDaemon">
<code>setDaemon()</code> </dt> <dd>
<p>Deprecated getter/setter API for <a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><code>daemon</code></a>; use it directly as a property instead.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.10.</span></p> </div> </dd>
</dl> </dd>
</dl> </section> <section id="lock-objects"> <span id="id2"></span><h2>Lock Objects</h2> <p>A primitive lock is a synchronization primitive that is not owned by a particular thread when locked. In Python, it is currently the lowest level synchronization primitive available, implemented directly by the <a class="reference internal" href="_thread.html#module-_thread" title="_thread: Low-level threading API."><code>_thread</code></a> extension module.</p> <p>A primitive lock is in one of two states, “locked” or “unlocked”. It is created in the unlocked state. It has two basic methods, <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code>acquire()</code></a> and <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code>release()</code></a>. When the state is unlocked, <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code>acquire()</code></a> changes the state to locked and returns immediately. When the state is locked, <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code>acquire()</code></a> blocks until a call to <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code>release()</code></a> in another thread changes it to unlocked, then the <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code>acquire()</code></a> call resets it to locked and returns. The <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code>release()</code></a> method should only be called in the locked state; it changes the state to unlocked and returns immediately. If an attempt is made to release an unlocked lock, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> will be raised.</p> <p>Locks also support the <a class="reference internal" href="#with-locks"><span class="std std-ref">context management protocol</span></a>.</p> <p>When more than one thread is blocked in <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code>acquire()</code></a> waiting for the state to turn to unlocked, only one thread proceeds when a <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code>release()</code></a> call resets the state to unlocked; which one of the waiting threads proceeds is not defined, and may vary across implementations.</p> <p>All methods are executed atomically.</p> <dl class="py class"> <dt class="sig sig-object py" id="threading.Lock">
<code>class threading.Lock</code> </dt> <dd>
<p>The class implementing primitive lock objects. Once a thread has acquired a lock, subsequent attempts to acquire it block, until it is released; any thread may release it.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span><code>Lock</code> is now a class. In earlier Pythons, <code>Lock</code> was a factory function which returned an instance of the underlying private lock type.</p> </div> <dl class="py method"> <dt class="sig sig-object py" id="threading.Lock.acquire">
<code>acquire(blocking=True, timeout=-1)</code> </dt> <dd>
<p>Acquire a lock, blocking or non-blocking.</p> <p>When invoked with the <em>blocking</em> argument set to <code>True</code> (the default), block until the lock is unlocked, then set it to locked and return <code>True</code>.</p> <p>When invoked with the <em>blocking</em> argument set to <code>False</code>, do not block. If a call with <em>blocking</em> set to <code>True</code> would block, return <code>False</code> immediately; otherwise, set the lock to locked and return <code>True</code>.</p> <p>When invoked with the floating-point <em>timeout</em> argument set to a positive value, block for at most the number of seconds specified by <em>timeout</em> and as long as the lock cannot be acquired. A <em>timeout</em> argument of <code>-1</code> specifies an unbounded wait. It is forbidden to specify a <em>timeout</em> when <em>blocking</em> is <code>False</code>.</p> <p>The return value is <code>True</code> if the lock is acquired successfully, <code>False</code> if not (for example if the <em>timeout</em> expired).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>The <em>timeout</em> parameter is new.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Lock acquisition can now be interrupted by signals on POSIX if the underlying threading implementation supports it.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Lock.release">
<code>release()</code> </dt> <dd>
<p>Release a lock. This can be called from any thread, not only the thread which has acquired the lock.</p> <p>When the lock is locked, reset it to unlocked, and return. If any other threads are blocked waiting for the lock to become unlocked, allow exactly one of them to proceed.</p> <p>When invoked on an unlocked lock, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised.</p> <p>There is no return value.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Lock.locked">
<code>locked()</code> </dt> <dd>
<p>Return <code>True</code> if the lock is acquired.</p> </dd>
</dl> </dd>
</dl> </section> <section id="rlock-objects"> <span id="id3"></span><h2>RLock Objects</h2> <p>A reentrant lock is a synchronization primitive that may be acquired multiple times by the same thread. Internally, it uses the concepts of “owning thread” and “recursion level” in addition to the locked/unlocked state used by primitive locks. In the locked state, some thread owns the lock; in the unlocked state, no thread owns it.</p> <p>Threads call a lock’s <a class="reference internal" href="#threading.RLock.acquire" title="threading.RLock.acquire"><code>acquire()</code></a> method to lock it, and its <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code>release()</code></a> method to unlock it.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Reentrant locks support the <a class="reference internal" href="#with-locks"><span class="std std-ref">context management protocol</span></a>, so it is recommended to use <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> instead of manually calling <a class="reference internal" href="#threading.RLock.acquire" title="threading.RLock.acquire"><code>acquire()</code></a> and <a class="reference internal" href="#threading.RLock.release" title="threading.RLock.release"><code>release()</code></a> to handle acquiring and releasing the lock for a block of code.</p> </div> <p>RLock’s <a class="reference internal" href="#threading.RLock.acquire" title="threading.RLock.acquire"><code>acquire()</code></a>/<a class="reference internal" href="#threading.RLock.release" title="threading.RLock.release"><code>release()</code></a> call pairs may be nested, unlike Lock’s <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code>acquire()</code></a>/<a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code>release()</code></a>. Only the final <a class="reference internal" href="#threading.RLock.release" title="threading.RLock.release"><code>release()</code></a> (the <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code>release()</code></a> of the outermost pair) resets the lock to an unlocked state and allows another thread blocked in <a class="reference internal" href="#threading.RLock.acquire" title="threading.RLock.acquire"><code>acquire()</code></a> to proceed.</p> <p><a class="reference internal" href="#threading.RLock.acquire" title="threading.RLock.acquire"><code>acquire()</code></a>/<a class="reference internal" href="#threading.RLock.release" title="threading.RLock.release"><code>release()</code></a> must be used in pairs: each acquire must have a release in the thread that has acquired the lock. Failing to call release as many times the lock has been acquired can lead to deadlock.</p> <dl class="py class"> <dt class="sig sig-object py" id="threading.RLock">
<code>class threading.RLock</code> </dt> <dd>
<p>This class implements reentrant lock objects. A reentrant lock must be released by the thread that acquired it. Once a thread has acquired a reentrant lock, the same thread may acquire it again without blocking; the thread must release it once for each time it has acquired it.</p> <p>Note that <code>RLock</code> is actually a factory function which returns an instance of the most efficient version of the concrete RLock class that is supported by the platform.</p> <dl class="py method"> <dt class="sig sig-object py" id="threading.RLock.acquire">
<code>acquire(blocking=True, timeout=-1)</code> </dt> <dd>
<p>Acquire a lock, blocking or non-blocking.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#with-locks"><span class="std std-ref">Using RLock as a context manager</span></a></dt>
<dd>
<p>Recommended over manual <code>acquire()</code> and <a class="reference internal" href="#threading.RLock.release" title="threading.RLock.release"><code>release()</code></a> calls whenever practical.</p> </dd> </dl> </div> <p>When invoked with the <em>blocking</em> argument set to <code>True</code> (the default):</p>  <ul class="simple"> <li>If no thread owns the lock, acquire the lock and return immediately.</li> <li>If another thread owns the lock, block until we are able to acquire lock, or <em>timeout</em>, if set to a positive float value.</li> <li>If the same thread owns the lock, acquire the lock again, and return immediately. This is the difference between <a class="reference internal" href="#threading.Lock" title="threading.Lock"><code>Lock</code></a> and <code>RLock</code>; <a class="reference internal" href="#threading.Lock" title="threading.Lock"><code>Lock</code></a> handles this case the same as the previous, blocking until the lock can be acquired.</li> </ul>  <p>When invoked with the <em>blocking</em> argument set to <code>False</code>:</p>  <ul class="simple"> <li>If no thread owns the lock, acquire the lock and return immediately.</li> <li>If another thread owns the lock, return immediately.</li> <li>If the same thread owns the lock, acquire the lock again and return immediately.</li> </ul>  <p>In all cases, if the thread was able to acquire the lock, return <code>True</code>. If the thread was unable to acquire the lock (i.e. if not blocking or the timeout was reached) return <code>False</code>.</p> <p>If called multiple times, failing to call <a class="reference internal" href="#threading.RLock.release" title="threading.RLock.release"><code>release()</code></a> as many times may lead to deadlock. Consider using <code>RLock</code> as a context manager rather than calling acquire/release directly.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>The <em>timeout</em> parameter is new.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.RLock.release">
<code>release()</code> </dt> <dd>
<p>Release a lock, decrementing the recursion level. If after the decrement it is zero, reset the lock to unlocked (not owned by any thread), and if any other threads are blocked waiting for the lock to become unlocked, allow exactly one of them to proceed. If after the decrement the recursion level is still nonzero, the lock remains locked and owned by the calling thread.</p> <p>Only call this method when the calling thread owns the lock. A <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised if this method is called when the lock is not acquired.</p> <p>There is no return value.</p> </dd>
</dl> </dd>
</dl> </section> <section id="condition-objects"> <span id="id4"></span><h2>Condition Objects</h2> <p>A condition variable is always associated with some kind of lock; this can be passed in or one will be created by default. Passing one in is useful when several condition variables must share the same lock. The lock is part of the condition object: you don’t have to track it separately.</p> <p>A condition variable obeys the <a class="reference internal" href="#with-locks"><span class="std std-ref">context management protocol</span></a>: using the <code>with</code> statement acquires the associated lock for the duration of the enclosed block. The <a class="reference internal" href="#threading.Condition.acquire" title="threading.Condition.acquire"><code>acquire()</code></a> and <a class="reference internal" href="#threading.Condition.release" title="threading.Condition.release"><code>release()</code></a> methods also call the corresponding methods of the associated lock.</p> <p>Other methods must be called with the associated lock held. The <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code>wait()</code></a> method releases the lock, and then blocks until another thread awakens it by calling <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> or <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code>notify_all()</code></a>. Once awakened, <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code>wait()</code></a> re-acquires the lock and returns. It is also possible to specify a timeout.</p> <p>The <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> method wakes up one of the threads waiting for the condition variable, if any are waiting. The <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code>notify_all()</code></a> method wakes up all threads waiting for the condition variable.</p> <p>Note: the <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> and <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code>notify_all()</code></a> methods don’t release the lock; this means that the thread or threads awakened will not return from their <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code>wait()</code></a> call immediately, but only when the thread that called <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> or <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code>notify_all()</code></a> finally relinquishes ownership of the lock.</p> <p>The typical programming style using condition variables uses the lock to synchronize access to some shared state; threads that are interested in a particular change of state call <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code>wait()</code></a> repeatedly until they see the desired state, while threads that modify the state call <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> or <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code>notify_all()</code></a> when they change the state in such a way that it could possibly be a desired state for one of the waiters. For example, the following code is a generic producer-consumer situation with unlimited buffer capacity:</p> <pre data-language="python"># Consume one item
with cv:
    while not an_item_is_available():
        cv.wait()
    get_an_available_item()

# Produce one item
with cv:
    make_an_item_available()
    cv.notify()
</pre> <p>The <code>while</code> loop checking for the application’s condition is necessary because <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code>wait()</code></a> can return after an arbitrary long time, and the condition which prompted the <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> call may no longer hold true. This is inherent to multi-threaded programming. The <a class="reference internal" href="#threading.Condition.wait_for" title="threading.Condition.wait_for"><code>wait_for()</code></a> method can be used to automate the condition checking, and eases the computation of timeouts:</p> <pre data-language="python"># Consume an item
with cv:
    cv.wait_for(an_item_is_available)
    get_an_available_item()
</pre> <p>To choose between <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> and <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code>notify_all()</code></a>, consider whether one state change can be interesting for only one or several waiting threads. E.g. in a typical producer-consumer situation, adding one item to the buffer only needs to wake up one consumer thread.</p> <dl class="py class"> <dt class="sig sig-object py" id="threading.Condition">
<code>class threading.Condition(lock=None)</code> </dt> <dd>
<p>This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread.</p> <p>If the <em>lock</em> argument is given and not <code>None</code>, it must be a <a class="reference internal" href="#threading.Lock" title="threading.Lock"><code>Lock</code></a> or <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code>RLock</code></a> object, and it is used as the underlying lock. Otherwise, a new <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code>RLock</code></a> object is created and used as the underlying lock.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>changed from a factory function to a class.</p> </div> <dl class="py method"> <dt class="sig sig-object py" id="threading.Condition.acquire">
<code>acquire(*args)</code> </dt> <dd>
<p>Acquire the underlying lock. This method calls the corresponding method on the underlying lock; the return value is whatever that method returns.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Condition.release">
<code>release()</code> </dt> <dd>
<p>Release the underlying lock. This method calls the corresponding method on the underlying lock; there is no return value.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Condition.wait">
<code>wait(timeout=None)</code> </dt> <dd>
<p>Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised.</p> <p>This method releases the underlying lock, and then blocks until it is awakened by a <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> or <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code>notify_all()</code></a> call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns.</p> <p>When the <em>timeout</em> argument is present and not <code>None</code>, it should be a floating-point number specifying a timeout for the operation in seconds (or fractions thereof).</p> <p>When the underlying lock is an <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code>RLock</code></a>, it is not released using its <a class="reference internal" href="#threading.Condition.release" title="threading.Condition.release"><code>release()</code></a> method, since this may not actually unlock the lock when it was acquired multiple times recursively. Instead, an internal interface of the <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code>RLock</code></a> class is used, which really unlocks it even when it has been recursively acquired several times. Another internal interface is then used to restore the recursion level when the lock is reacquired.</p> <p>The return value is <code>True</code> unless a given <em>timeout</em> expired, in which case it is <code>False</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Previously, the method always returned <code>None</code>.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Condition.wait_for">
<code>wait_for(predicate, timeout=None)</code> </dt> <dd>
<p>Wait until a condition evaluates to true. <em>predicate</em> should be a callable which result will be interpreted as a boolean value. A <em>timeout</em> may be provided giving the maximum time to wait.</p> <p>This utility method may call <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code>wait()</code></a> repeatedly until the predicate is satisfied, or until a timeout occurs. The return value is the last return value of the predicate and will evaluate to <code>False</code> if the method timed out.</p> <p>Ignoring the timeout feature, calling this method is roughly equivalent to writing:</p> <pre data-language="python">while not predicate():
    cv.wait()
</pre> <p>Therefore, the same rules apply as with <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code>wait()</code></a>: The lock must be held when called and is re-acquired on return. The predicate is evaluated with the lock held.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Condition.notify">
<code>notify(n=1)</code> </dt> <dd>
<p>By default, wake up one thread waiting on this condition, if any. If the calling thread has not acquired the lock when this method is called, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised.</p> <p>This method wakes up at most <em>n</em> of the threads waiting for the condition variable; it is a no-op if no threads are waiting.</p> <p>The current implementation wakes up exactly <em>n</em> threads, if at least <em>n</em> threads are waiting. However, it’s not safe to rely on this behavior. A future, optimized implementation may occasionally wake up more than <em>n</em> threads.</p> <p>Note: an awakened thread does not actually return from its <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code>wait()</code></a> call until it can reacquire the lock. Since <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> does not release the lock, its caller should.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Condition.notify_all">
<code>notify_all()</code> </dt> <dd>
<p>Wake up all threads waiting on this condition. This method acts like <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a>, but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised.</p> <p>The method <code>notifyAll</code> is a deprecated alias for this method.</p> </dd>
</dl> </dd>
</dl> </section> <section id="semaphore-objects"> <span id="id5"></span><h2>Semaphore Objects</h2> <p>This is one of the oldest synchronization primitives in the history of computer science, invented by the early Dutch computer scientist Edsger W. Dijkstra (he used the names <code>P()</code> and <code>V()</code> instead of <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code>acquire()</code></a> and <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code>release()</code></a>).</p> <p>A semaphore manages an internal counter which is decremented by each <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code>acquire()</code></a> call and incremented by each <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code>release()</code></a> call. The counter can never go below zero; when <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code>acquire()</code></a> finds that it is zero, it blocks, waiting until some other thread calls <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code>release()</code></a>.</p> <p>Semaphores also support the <a class="reference internal" href="#with-locks"><span class="std std-ref">context management protocol</span></a>.</p> <dl class="py class"> <dt class="sig sig-object py" id="threading.Semaphore">
<code>class threading.Semaphore(value=1)</code> </dt> <dd>
<p>This class implements semaphore objects. A semaphore manages an atomic counter representing the number of <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code>release()</code></a> calls minus the number of <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code>acquire()</code></a> calls, plus an initial value. The <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code>acquire()</code></a> method blocks if necessary until it can return without making the counter negative. If not given, <em>value</em> defaults to 1.</p> <p>The optional argument gives the initial <em>value</em> for the internal counter; it defaults to <code>1</code>. If the <em>value</em> given is less than 0, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>changed from a factory function to a class.</p> </div> <dl class="py method"> <dt class="sig sig-object py" id="threading.Semaphore.acquire">
<code>acquire(blocking=True, timeout=None)</code> </dt> <dd>
<p>Acquire a semaphore.</p> <p>When invoked without arguments:</p> <ul class="simple"> <li>If the internal counter is larger than zero on entry, decrement it by one and return <code>True</code> immediately.</li> <li>If the internal counter is zero on entry, block until awoken by a call to <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code>release()</code></a>. Once awoken (and the counter is greater than 0), decrement the counter by 1 and return <code>True</code>. Exactly one thread will be awoken by each call to <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code>release()</code></a>. The order in which threads are awoken should not be relied on.</li> </ul> <p>When invoked with <em>blocking</em> set to <code>False</code>, do not block. If a call without an argument would block, return <code>False</code> immediately; otherwise, do the same thing as when called without arguments, and return <code>True</code>.</p> <p>When invoked with a <em>timeout</em> other than <code>None</code>, it will block for at most <em>timeout</em> seconds. If acquire does not complete successfully in that interval, return <code>False</code>. Return <code>True</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>The <em>timeout</em> parameter is new.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Semaphore.release">
<code>release(n=1)</code> </dt> <dd>
<p>Release a semaphore, incrementing the internal counter by <em>n</em>. When it was zero on entry and other threads are waiting for it to become larger than zero again, wake up <em>n</em> of those threads.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>Added the <em>n</em> parameter to release multiple waiting threads at once.</p> </div> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="threading.BoundedSemaphore">
<code>class threading.BoundedSemaphore(value=1)</code> </dt> <dd>
<p>Class implementing bounded semaphore objects. A bounded semaphore checks to make sure its current value doesn’t exceed its initial value. If it does, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised. In most situations semaphores are used to guard resources with limited capacity. If the semaphore is released too many times it’s a sign of a bug. If not given, <em>value</em> defaults to 1.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>changed from a factory function to a class.</p> </div> </dd>
</dl> <section id="semaphore-example"> <span id="semaphore-examples"></span><h3>
<a class="reference internal" href="#threading.Semaphore" title="threading.Semaphore"><code>Semaphore</code></a> Example</h3> <p>Semaphores are often used to guard resources with limited capacity, for example, a database server. In any situation where the size of the resource is fixed, you should use a bounded semaphore. Before spawning any worker threads, your main thread would initialize the semaphore:</p> <pre data-language="python">maxconnections = 5
# ...
pool_sema = BoundedSemaphore(value=maxconnections)
</pre> <p>Once spawned, worker threads call the semaphore’s acquire and release methods when they need to connect to the server:</p> <pre data-language="python">with pool_sema:
    conn = connectdb()
    try:
        # ... use connection ...
    finally:
        conn.close()
</pre> <p>The use of a bounded semaphore reduces the chance that a programming error which causes the semaphore to be released more than it’s acquired will go undetected.</p> </section> </section> <section id="event-objects"> <span id="id6"></span><h2>Event Objects</h2> <p>This is one of the simplest mechanisms for communication between threads: one thread signals an event and other threads wait for it.</p> <p>An event object manages an internal flag that can be set to true with the <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code>set()</code></a> method and reset to false with the <a class="reference internal" href="#threading.Event.clear" title="threading.Event.clear"><code>clear()</code></a> method. The <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code>wait()</code></a> method blocks until the flag is true.</p> <dl class="py class"> <dt class="sig sig-object py" id="threading.Event">
<code>class threading.Event</code> </dt> <dd>
<p>Class implementing event objects. An event manages a flag that can be set to true with the <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code>set()</code></a> method and reset to false with the <a class="reference internal" href="#threading.Event.clear" title="threading.Event.clear"><code>clear()</code></a> method. The <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code>wait()</code></a> method blocks until the flag is true. The flag is initially false.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>changed from a factory function to a class.</p> </div> <dl class="py method"> <dt class="sig sig-object py" id="threading.Event.is_set">
<code>is_set()</code> </dt> <dd>
<p>Return <code>True</code> if and only if the internal flag is true.</p> <p>The method <code>isSet</code> is a deprecated alias for this method.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Event.set">
<code>set()</code> </dt> <dd>
<p>Set the internal flag to true. All threads waiting for it to become true are awakened. Threads that call <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code>wait()</code></a> once the flag is true will not block at all.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Event.clear">
<code>clear()</code> </dt> <dd>
<p>Reset the internal flag to false. Subsequently, threads calling <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code>wait()</code></a> will block until <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code>set()</code></a> is called to set the internal flag to true again.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Event.wait">
<code>wait(timeout=None)</code> </dt> <dd>
<p>Block as long as the internal flag is false and the timeout, if given, has not expired. The return value represents the reason that this blocking method returned; <code>True</code> if returning because the internal flag is set to true, or <code>False</code> if a timeout is given and the the internal flag did not become true within the given wait time.</p> <p>When the timeout argument is present and not <code>None</code>, it should be a floating-point number specifying a timeout for the operation in seconds, or fractions thereof.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.1: </span>Previously, the method always returned <code>None</code>.</p> </div> </dd>
</dl> </dd>
</dl> </section> <section id="timer-objects"> <span id="id7"></span><h2>Timer Objects</h2> <p>This class represents an action that should be run only after a certain amount of time has passed — a timer. <a class="reference internal" href="#threading.Timer" title="threading.Timer"><code>Timer</code></a> is a subclass of <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> and as such also functions as an example of creating custom threads.</p> <p>Timers are started, as with threads, by calling their <a class="reference internal" href="#threading.Thread.start" title="threading.Thread.start"><code>Timer.start</code></a> method. The timer can be stopped (before its action has begun) by calling the <a class="reference internal" href="#threading.Timer.cancel" title="threading.Timer.cancel"><code>cancel()</code></a> method. The interval the timer will wait before executing its action may not be exactly the same as the interval specified by the user.</p> <p>For example:</p> <pre data-language="python">def hello():
    print("hello, world")

t = Timer(30.0, hello)
t.start()  # after 30 seconds, "hello, world" will be printed
</pre> <dl class="py class"> <dt class="sig sig-object py" id="threading.Timer">
<code>class threading.Timer(interval, function, args=None, kwargs=None)</code> </dt> <dd>
<p>Create a timer that will run <em>function</em> with arguments <em>args</em> and keyword arguments <em>kwargs</em>, after <em>interval</em> seconds have passed. If <em>args</em> is <code>None</code> (the default) then an empty list will be used. If <em>kwargs</em> is <code>None</code> (the default) then an empty dict will be used.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>changed from a factory function to a class.</p> </div> <dl class="py method"> <dt class="sig sig-object py" id="threading.Timer.cancel">
<code>cancel()</code> </dt> <dd>
<p>Stop the timer, and cancel the execution of the timer’s action. This will only work if the timer is still in its waiting stage.</p> </dd>
</dl> </dd>
</dl> </section> <section id="barrier-objects"> <h2>Barrier Objects</h2> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> <p>This class provides a simple synchronization primitive for use by a fixed number of threads that need to wait for each other. Each of the threads tries to pass the barrier by calling the <a class="reference internal" href="#threading.Barrier.wait" title="threading.Barrier.wait"><code>wait()</code></a> method and will block until all of the threads have made their <a class="reference internal" href="#threading.Barrier.wait" title="threading.Barrier.wait"><code>wait()</code></a> calls. At this point, the threads are released simultaneously.</p> <p>The barrier can be reused any number of times for the same number of threads.</p> <p>As an example, here is a simple way to synchronize a client and server thread:</p> <pre data-language="python">b = Barrier(2, timeout=5)

def server():
    start_server()
    b.wait()
    while True:
        connection = accept_connection()
        process_server_connection(connection)

def client():
    b.wait()
    while True:
        connection = make_connection()
        process_client_connection(connection)
</pre> <dl class="py class"> <dt class="sig sig-object py" id="threading.Barrier">
<code>class threading.Barrier(parties, action=None, timeout=None)</code> </dt> <dd>
<p>Create a barrier object for <em>parties</em> number of threads. An <em>action</em>, when provided, is a callable to be called by one of the threads when they are released. <em>timeout</em> is the default timeout value if none is specified for the <a class="reference internal" href="#threading.Barrier.wait" title="threading.Barrier.wait"><code>wait()</code></a> method.</p> <dl class="py method"> <dt class="sig sig-object py" id="threading.Barrier.wait">
<code>wait(timeout=None)</code> </dt> <dd>
<p>Pass the barrier. When all the threads party to the barrier have called this function, they are all released simultaneously. If a <em>timeout</em> is provided, it is used in preference to any that was supplied to the class constructor.</p> <p>The return value is an integer in the range 0 to <em>parties</em> – 1, different for each thread. This can be used to select a thread to do some special housekeeping, e.g.:</p> <pre data-language="python">i = barrier.wait()
if i == 0:
    # Only one thread needs to print this
    print("passed the barrier")
</pre> <p>If an <em>action</em> was provided to the constructor, one of the threads will have called it prior to being released. Should this call raise an error, the barrier is put into the broken state.</p> <p>If the call times out, the barrier is put into the broken state.</p> <p>This method may raise a <a class="reference internal" href="#threading.BrokenBarrierError" title="threading.BrokenBarrierError"><code>BrokenBarrierError</code></a> exception if the barrier is broken or reset while a thread is waiting.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Barrier.reset">
<code>reset()</code> </dt> <dd>
<p>Return the barrier to the default, empty state. Any threads waiting on it will receive the <a class="reference internal" href="#threading.BrokenBarrierError" title="threading.BrokenBarrierError"><code>BrokenBarrierError</code></a> exception.</p> <p>Note that using this function may require some external synchronization if there are other threads whose state is unknown. If a barrier is broken it may be better to just leave it and create a new one.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="threading.Barrier.abort">
<code>abort()</code> </dt> <dd>
<p>Put the barrier into a broken state. This causes any active or future calls to <a class="reference internal" href="#threading.Barrier.wait" title="threading.Barrier.wait"><code>wait()</code></a> to fail with the <a class="reference internal" href="#threading.BrokenBarrierError" title="threading.BrokenBarrierError"><code>BrokenBarrierError</code></a>. Use this for example if one of the threads needs to abort, to avoid deadlocking the application.</p> <p>It may be preferable to simply create the barrier with a sensible <em>timeout</em> value to automatically guard against one of the threads going awry.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="threading.Barrier.parties">
<code>parties</code> </dt> <dd>
<p>The number of threads required to pass the barrier.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="threading.Barrier.n_waiting">
<code>n_waiting</code> </dt> <dd>
<p>The number of threads currently waiting in the barrier.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="threading.Barrier.broken">
<code>broken</code> </dt> <dd>
<p>A boolean that is <code>True</code> if the barrier is in the broken state.</p> </dd>
</dl> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="threading.BrokenBarrierError">
<code>exception threading.BrokenBarrierError</code> </dt> <dd>
<p>This exception, a subclass of <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a>, is raised when the <a class="reference internal" href="#threading.Barrier" title="threading.Barrier"><code>Barrier</code></a> object is reset or broken.</p> </dd>
</dl> </section> <section id="using-locks-conditions-and-semaphores-in-the-with-statement"> <span id="with-locks"></span><h2>Using locks, conditions, and semaphores in the <code>with</code> statement</h2> <p>All of the objects provided by this module that have <code>acquire</code> and <code>release</code> methods can be used as context managers for a <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> statement. The <code>acquire</code> method will be called when the block is entered, and <code>release</code> will be called when the block is exited. Hence, the following snippet:</p> <pre data-language="python">with some_lock:
    # do something...
</pre> <p>is equivalent to:</p> <pre data-language="python">some_lock.acquire()
try:
    # do something...
finally:
    some_lock.release()
</pre> <p>Currently, <a class="reference internal" href="#threading.Lock" title="threading.Lock"><code>Lock</code></a>, <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code>RLock</code></a>, <a class="reference internal" href="#threading.Condition" title="threading.Condition"><code>Condition</code></a>, <a class="reference internal" href="#threading.Semaphore" title="threading.Semaphore"><code>Semaphore</code></a>, and <a class="reference internal" href="#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><code>BoundedSemaphore</code></a> objects may be used as <a class="reference internal" href="../reference/compound_stmts.html#with"><code>with</code></a> statement context managers.</p> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/threading.html" class="_attribution-link">https://docs.python.org/3.13/library/threading.html</a>
  </p>
</div>
