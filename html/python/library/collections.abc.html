 <span id="collections-abc-abstract-base-classes-for-containers"></span><h1>collections.abc — Abstract Base Classes for Containers</h1> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3: </span>Formerly, this module was part of the <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code>collections</code></a> module.</p> </div> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/_collections_abc.py">Lib/_collections_abc.py</a></p>  <p>This module provides <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base classes</span></a> that can be used to test whether a class provides a particular interface; for example, whether it is <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> or whether it is a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>.</p> <p>An <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code>issubclass()</code></a> or <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> test for an interface works in one of three ways.</p> <p>1) A newly written class can inherit directly from one of the abstract base classes. The class must supply the required abstract methods. The remaining mixin methods come from inheritance and can be overridden if desired. Other methods may be added as needed:</p> <pre data-language="python">class C(Sequence):                      # Direct inheritance
    def __init__(self): ...             # Extra method not required by the ABC
    def __getitem__(self, index):  ...  # Required abstract method
    def __len__(self):  ...             # Required abstract method
    def count(self, value): ...         # Optionally override a mixin method
</pre> <pre data-language="pycon">&gt;&gt;&gt; issubclass(C, Sequence)
True
&gt;&gt;&gt; isinstance(C(), Sequence)
True
</pre> <p>2) Existing classes and built-in classes can be registered as “virtual subclasses” of the ABCs. Those classes should define the full API including all of the abstract methods and all of the mixin methods. This lets users rely on <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code>issubclass()</code></a> or <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> tests to determine whether the full interface is supported. The exception to this rule is for methods that are automatically inferred from the rest of the API:</p> <pre data-language="python">class D:                                 # No inheritance
    def __init__(self): ...              # Extra method not required by the ABC
    def __getitem__(self, index):  ...   # Abstract method
    def __len__(self):  ...              # Abstract method
    def count(self, value): ...          # Mixin method
    def index(self, value): ...          # Mixin method

Sequence.register(D)                     # Register instead of inherit
</pre> <pre data-language="pycon">&gt;&gt;&gt; issubclass(D, Sequence)
True
&gt;&gt;&gt; isinstance(D(), Sequence)
True
</pre> <p>In this example, class <code>D</code> does not need to define <code>__contains__</code>, <code>__iter__</code>, and <code>__reversed__</code> because the <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">in-operator</span></a>, the <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iteration</span></a> logic, and the <a class="reference internal" href="functions.html#reversed" title="reversed"><code>reversed()</code></a> function automatically fall back to using <code>__getitem__</code> and <code>__len__</code>.</p> <p>3) Some simple interfaces are directly recognizable by the presence of the required methods (unless those methods have been set to <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a>):</p> <pre data-language="python">class E:
    def __iter__(self): ...
    def __next__(self): ...
</pre> <pre data-language="pycon">&gt;&gt;&gt; issubclass(E, Iterable)
True
&gt;&gt;&gt; isinstance(E(), Iterable)
True
</pre> <p>Complex interfaces do not support this last technique because an interface is more than just the presence of method names. Interfaces specify semantics and relationships between methods that cannot be inferred solely from the presence of specific method names. For example, knowing that a class supplies <code>__getitem__</code>, <code>__len__</code>, and <code>__iter__</code> is insufficient for distinguishing a <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a> from a <a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9: </span>These abstract classes now support <code>[]</code>. See <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Type</span></a> and <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>.</p> </div> <section id="collections-abstract-base-classes"> <span id="id1"></span><h2>Collections Abstract Base Classes</h2> <p>The collections module offers the following <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">ABCs</span></a>:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>ABC</p></th> <th class="head"><p>Inherits from</p></th> <th class="head"><p>Abstract Methods</p></th> <th class="head"><p>Mixin Methods</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#collections.abc.Container" title="collections.abc.Container"><code>Container</code></a> <a class="footnote-reference brackets" href="#id18" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td></td> <td><p><code>__contains__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Hashable" title="collections.abc.Hashable"><code>Hashable</code></a> <a class="footnote-reference brackets" href="#id18" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td></td> <td><p><code>__hash__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a> <a class="footnote-reference brackets" href="#id18" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id19" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td> <td></td> <td><p><code>__iter__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Iterator" title="collections.abc.Iterator"><code>Iterator</code></a> <a class="footnote-reference brackets" href="#id18" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a></p></td> <td><p><code>__next__</code></p></td> <td><p><code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Reversible" title="collections.abc.Reversible"><code>Reversible</code></a> <a class="footnote-reference brackets" href="#id18" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a></p></td> <td><p><code>__reversed__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Generator" title="collections.abc.Generator"><code>Generator</code></a> <a class="footnote-reference brackets" href="#id18" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Iterator" title="collections.abc.Iterator"><code>Iterator</code></a></p></td> <td><p><code>send</code>, <code>throw</code></p></td> <td><p><code>close</code>, <code>__iter__</code>, <code>__next__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code>Sized</code></a> <a class="footnote-reference brackets" href="#id18" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td></td> <td><p><code>__len__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Callable" title="collections.abc.Callable"><code>Callable</code></a> <a class="footnote-reference brackets" href="#id18" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td></td> <td><p><code>__call__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a> <a class="footnote-reference brackets" href="#id18" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code>Sized</code></a>, <a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a>, <a class="reference internal" href="#collections.abc.Container" title="collections.abc.Container"><code>Container</code></a></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Reversible" title="collections.abc.Reversible"><code>Reversible</code></a>, <a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><code>__getitem__</code>, <code>__len__</code></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__reversed__</code>, <code>index</code>, and <code>count</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code>MutableSequence</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a></p></td> <td><p><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__len__</code>, <code>insert</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a> methods and <code>append</code>, <code>clear</code>, <code>reverse</code>, <code>extend</code>, <code>pop</code>, <code>remove</code>, and <code>__iadd__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.ByteString" title="collections.abc.ByteString"><code>ByteString</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a></p></td> <td><p><code>__getitem__</code>, <code>__len__</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a> methods</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td><p><code>__le__</code>, <code>__lt__</code>, <code>__eq__</code>, <code>__ne__</code>, <code>__gt__</code>, <code>__ge__</code>, <code>__and__</code>, <code>__or__</code>, <code>__sub__</code>, <code>__xor__</code>, and <code>isdisjoint</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code>MutableSet</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code>, <code>add</code>, <code>discard</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> methods and <code>clear</code>, <code>pop</code>, <code>remove</code>, <code>__ior__</code>, <code>__iand__</code>, <code>__ixor__</code>, and <code>__isub__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td><p><code>__contains__</code>, <code>keys</code>, <code>items</code>, <code>values</code>, <code>get</code>, <code>__eq__</code>, and <code>__ne__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code>MutableMapping</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a></p></td> <td><p><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a> methods and <code>pop</code>, <code>popitem</code>, <code>clear</code>, <code>update</code>, and <code>setdefault</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code>Sized</code></a></p></td> <td></td> <td><p><code>__len__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.ItemsView" title="collections.abc.ItemsView"><code>ItemsView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a>, <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td></td> <td><p><code>__contains__</code>, <code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.KeysView" title="collections.abc.KeysView"><code>KeysView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a>, <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td></td> <td><p><code>__contains__</code>, <code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.ValuesView" title="collections.abc.ValuesView"><code>ValuesView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a>, <a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td></td> <td><p><code>__contains__</code>, <code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code>Awaitable</code></a> <a class="footnote-reference brackets" href="#id18" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td></td> <td><p><code>__await__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code>Coroutine</code></a> <a class="footnote-reference brackets" href="#id18" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code>Awaitable</code></a></p></td> <td><p><code>send</code>, <code>throw</code></p></td> <td><p><code>close</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code>AsyncIterable</code></a> <a class="footnote-reference brackets" href="#id18" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td></td> <td><p><code>__aiter__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code>AsyncIterator</code></a> <a class="footnote-reference brackets" href="#id18" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td><p><a class="reference internal" href="#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code>AsyncIterable</code></a></p></td> <td><p><code>__anext__</code></p></td> <td><p><code>__aiter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code>AsyncGenerator</code></a> <a class="footnote-reference brackets" href="#id18" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td><p><a class="reference internal" href="#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code>AsyncIterator</code></a></p></td> <td><p><code>asend</code>, <code>athrow</code></p></td> <td><p><code>aclose</code>, <code>__aiter__</code>, <code>__anext__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Buffer" title="collections.abc.Buffer"><code>Buffer</code></a> <a class="footnote-reference brackets" href="#id18" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td></td> <td><p><code>__buffer__</code></p></td> <td></td> </tr>  </table> <h4 class="rubric">Footnotes</h4> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id18" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>,<a role="doc-backlink" href="#id4">3</a>,<a role="doc-backlink" href="#id6">4</a>,<a role="doc-backlink" href="#id7">5</a>,<a role="doc-backlink" href="#id8">6</a>,<a role="doc-backlink" href="#id9">7</a>,<a role="doc-backlink" href="#id10">8</a>,<a role="doc-backlink" href="#id11">9</a>,<a role="doc-backlink" href="#id12">10</a>,<a role="doc-backlink" href="#id13">11</a>,<a role="doc-backlink" href="#id14">12</a>,<a role="doc-backlink" href="#id15">13</a>,<a role="doc-backlink" href="#id16">14</a>,<a role="doc-backlink" href="#id17">15</a>)</span> <p>These ABCs override <a class="reference internal" href="abc.html#abc.ABCMeta.__subclasshook__" title="abc.ABCMeta.__subclasshook__"><code>__subclasshook__()</code></a> to support testing an interface by verifying the required methods are present and have not been set to <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a>. This only works for simple interfaces. More complex interfaces require registration or direct subclassing.</p> </aside> <aside class="footnote brackets" id="id19" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">2</a><span class="fn-bracket">]</span></span> <p>Checking <code>isinstance(obj, Iterable)</code> detects classes that are registered as <a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a> or that have an <a class="reference internal" href="stdtypes.html#container.__iter__" title="container.__iter__"><code>__iter__()</code></a> method, but it does not detect classes that iterate with the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> method. The only reliable way to determine whether an object is <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> is to call <code>iter(obj)</code>.</p> </aside> </aside> </section> <section id="collections-abstract-base-classes-detailed-descriptions"> <h2>Collections Abstract Base Classes – Detailed Descriptions</h2> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Container">
<code>class collections.abc.Container</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code>__contains__()</code></a> method.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Hashable">
<code>class collections.abc.Hashable</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> method.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Sized">
<code>class collections.abc.Sized</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code>__len__()</code></a> method.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Callable">
<code>class collections.abc.Callable</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code>__call__()</code></a> method.</p> <p>See <a class="reference internal" href="typing.html#annotating-callables"><span class="std std-ref">Annotating callable objects</span></a> for details on how to use <code>Callable</code> in type annotations.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Iterable">
<code>class collections.abc.Iterable</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="stdtypes.html#container.__iter__" title="container.__iter__"><code>__iter__()</code></a> method.</p> <p>Checking <code>isinstance(obj, Iterable)</code> detects classes that are registered as <a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a> or that have an <a class="reference internal" href="stdtypes.html#container.__iter__" title="container.__iter__"><code>__iter__()</code></a> method, but it does not detect classes that iterate with the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> method. The only reliable way to determine whether an object is <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> is to call <code>iter(obj)</code>.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Collection">
<code>class collections.abc.Collection</code> </dt> <dd>
<p>ABC for sized iterable container classes.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Iterator">
<code>class collections.abc.Iterator</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code>__iter__()</code></a> and <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> methods. See also the definition of <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Reversible">
<code>class collections.abc.Reversible</code> </dt> <dd>
<p>ABC for iterable classes that also provide the <a class="reference internal" href="../reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code>__reversed__()</code></a> method.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Generator">
<code>class collections.abc.Generator</code> </dt> <dd>
<p>ABC for <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> classes that implement the protocol defined in <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0342/"><strong>PEP 342</strong></a> that extends <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterators</span></a> with the <a class="reference internal" href="../reference/expressions.html#generator.send" title="generator.send"><code>send()</code></a>, <a class="reference internal" href="../reference/expressions.html#generator.throw" title="generator.throw"><code>throw()</code></a> and <a class="reference internal" href="../reference/expressions.html#generator.close" title="generator.close"><code>close()</code></a> methods.</p> <p>See <a class="reference internal" href="typing.html#annotating-generators-and-coroutines"><span class="std std-ref">Annotating generators and coroutines</span></a> for details on using <code>Generator</code> in type annotations.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Sequence">
<code>class collections.abc.Sequence</code> </dt> <dt class="sig sig-object py" id="collections.abc.MutableSequence">
<code>class collections.abc.MutableSequence</code> </dt> <dt class="sig sig-object py" id="collections.abc.ByteString">
<code>class collections.abc.ByteString</code> </dt> <dd>
<p>ABCs for read-only and mutable <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a>.</p> <p>Implementation note: Some of the mixin methods, such as <a class="reference internal" href="stdtypes.html#container.__iter__" title="container.__iter__"><code>__iter__()</code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code>__reversed__()</code></a> and <code>index()</code>, make repeated calls to the underlying <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> method. Consequently, if <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> is implemented with constant access speed, the mixin methods will have linear performance; however, if the underlying method is linear (as it would be with a linked list), the mixins will have quadratic performance and will likely need to be overridden.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The index() method added support for <em>stop</em> and <em>start</em> arguments.</p> </div> <div class="deprecated-removed"> <p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.14: </span>The <a class="reference internal" href="#collections.abc.ByteString" title="collections.abc.ByteString"><code>ByteString</code></a> ABC has been deprecated. For use in typing, prefer a union, like <code>bytes | bytearray</code>, or <a class="reference internal" href="#collections.abc.Buffer" title="collections.abc.Buffer"><code>collections.abc.Buffer</code></a>. For use as an ABC, prefer <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a> or <a class="reference internal" href="#collections.abc.Buffer" title="collections.abc.Buffer"><code>collections.abc.Buffer</code></a>.</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Set">
<code>class collections.abc.Set</code> </dt> <dt class="sig sig-object py" id="collections.abc.MutableSet">
<code>class collections.abc.MutableSet</code> </dt> <dd>
<p>ABCs for read-only and mutable <a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">sets</span></a>.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Mapping">
<code>class collections.abc.Mapping</code> </dt> <dt class="sig sig-object py" id="collections.abc.MutableMapping">
<code>class collections.abc.MutableMapping</code> </dt> <dd>
<p>ABCs for read-only and mutable <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mappings</span></a>.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.MappingView">
<code>class collections.abc.MappingView</code> </dt> <dt class="sig sig-object py" id="collections.abc.ItemsView">
<code>class collections.abc.ItemsView</code> </dt> <dt class="sig sig-object py" id="collections.abc.KeysView">
<code>class collections.abc.KeysView</code> </dt> <dt class="sig sig-object py" id="collections.abc.ValuesView">
<code>class collections.abc.ValuesView</code> </dt> <dd>
<p>ABCs for mapping, items, keys, and values <a class="reference internal" href="../glossary.html#term-dictionary-view"><span class="xref std std-term">views</span></a>.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Awaitable">
<code>class collections.abc.Awaitable</code> </dt> <dd>
<p>ABC for <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> objects, which can be used in <a class="reference internal" href="../reference/expressions.html#await"><code>await</code></a> expressions. Custom implementations must provide the <a class="reference internal" href="../reference/datamodel.html#object.__await__" title="object.__await__"><code>__await__()</code></a> method.</p> <p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine</span></a> objects and instances of the <a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code>Coroutine</code></a> ABC are all instances of this ABC.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In CPython, generator-based coroutines (<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generators</span></a> decorated with <a class="reference internal" href="types.html#types.coroutine" title="types.coroutine"><code>@types.coroutine</code></a>) are <em>awaitables</em>, even though they do not have an <a class="reference internal" href="../reference/datamodel.html#object.__await__" title="object.__await__"><code>__await__()</code></a> method. Using <code>isinstance(gencoro, Awaitable)</code> for them will return <code>False</code>. Use <a class="reference internal" href="inspect.html#inspect.isawaitable" title="inspect.isawaitable"><code>inspect.isawaitable()</code></a> to detect them.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Coroutine">
<code>class collections.abc.Coroutine</code> </dt> <dd>
<p>ABC for <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> compatible classes. These implement the following methods, defined in <a class="reference internal" href="../reference/datamodel.html#coroutine-objects"><span class="std std-ref">Coroutine Objects</span></a>: <a class="reference internal" href="../reference/datamodel.html#coroutine.send" title="coroutine.send"><code>send()</code></a>, <a class="reference internal" href="../reference/datamodel.html#coroutine.throw" title="coroutine.throw"><code>throw()</code></a>, and <a class="reference internal" href="../reference/datamodel.html#coroutine.close" title="coroutine.close"><code>close()</code></a>. Custom implementations must also implement <a class="reference internal" href="../reference/datamodel.html#object.__await__" title="object.__await__"><code>__await__()</code></a>. All <a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code>Coroutine</code></a> instances are also instances of <a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code>Awaitable</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In CPython, generator-based coroutines (<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generators</span></a> decorated with <a class="reference internal" href="types.html#types.coroutine" title="types.coroutine"><code>@types.coroutine</code></a>) are <em>awaitables</em>, even though they do not have an <a class="reference internal" href="../reference/datamodel.html#object.__await__" title="object.__await__"><code>__await__()</code></a> method. Using <code>isinstance(gencoro, Coroutine)</code> for them will return <code>False</code>. Use <a class="reference internal" href="inspect.html#inspect.isawaitable" title="inspect.isawaitable"><code>inspect.isawaitable()</code></a> to detect them.</p> </div> <p>See <a class="reference internal" href="typing.html#annotating-generators-and-coroutines"><span class="std std-ref">Annotating generators and coroutines</span></a> for details on using <code>Coroutine</code> in type annotations. The variance and order of type parameters correspond to those of <a class="reference internal" href="#collections.abc.Generator" title="collections.abc.Generator"><code>Generator</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.AsyncIterable">
<code>class collections.abc.AsyncIterable</code> </dt> <dd>
<p>ABC for classes that provide an <code>__aiter__</code> method. See also the definition of <a class="reference internal" href="../glossary.html#term-asynchronous-iterable"><span class="xref std std-term">asynchronous iterable</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.AsyncIterator">
<code>class collections.abc.AsyncIterator</code> </dt> <dd>
<p>ABC for classes that provide <code>__aiter__</code> and <code>__anext__</code> methods. See also the definition of <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.AsyncGenerator">
<code>class collections.abc.AsyncGenerator</code> </dt> <dd>
<p>ABC for <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> classes that implement the protocol defined in <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a> and <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p> <p>See <a class="reference internal" href="typing.html#annotating-generators-and-coroutines"><span class="std std-ref">Annotating generators and coroutines</span></a> for details on using <code>AsyncGenerator</code> in type annotations.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.6.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="collections.abc.Buffer">
<code>class collections.abc.Buffer</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="../reference/datamodel.html#object.__buffer__" title="object.__buffer__"><code>__buffer__()</code></a> method, implementing the <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a>. See <span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0688/"><strong>PEP 688</strong></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> </section> <section id="examples-and-recipes"> <h2>Examples and Recipes</h2> <p>ABCs allow us to ask classes or instances if they provide particular functionality, for example:</p> <pre data-language="python">size = None
if isinstance(myvar, collections.abc.Sized):
    size = len(myvar)
</pre> <p>Several of the ABCs are also useful as mixins that make it easier to develop classes supporting container APIs. For example, to write a class supporting the full <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> API, it is only necessary to supply the three underlying abstract methods: <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code>__contains__()</code></a>, <a class="reference internal" href="stdtypes.html#container.__iter__" title="container.__iter__"><code>__iter__()</code></a>, and <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code>__len__()</code></a>. The ABC supplies the remaining methods such as <code>__and__()</code> and <a class="reference internal" href="stdtypes.html#frozenset.isdisjoint" title="frozenset.isdisjoint"><code>isdisjoint()</code></a>:</p> <pre data-language="python">class ListBasedSet(collections.abc.Set):
    ''' Alternate set implementation favoring space over speed
        and not requiring the set elements to be hashable. '''
    def __init__(self, iterable):
        self.elements = lst = []
        for value in iterable:
            if value not in lst:
                lst.append(value)

    def __iter__(self):
        return iter(self.elements)

    def __contains__(self, value):
        return value in self.elements

    def __len__(self):
        return len(self.elements)

s1 = ListBasedSet('abcdef')
s2 = ListBasedSet('defghi')
overlap = s1 &amp; s2            # The __and__() method is supported automatically
</pre> <p>Notes on using <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> and <a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code>MutableSet</code></a> as a mixin:</p> <ol class="arabic simple"> <li>Since some set operations create new sets, the default mixin methods need a way to create new instances from an <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>. The class constructor is assumed to have a signature in the form <code>ClassName(iterable)</code>. That assumption is factored-out to an internal <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code>classmethod</code></a> called <code>_from_iterable()</code> which calls <code>cls(iterable)</code> to produce a new set. If the <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> mixin is being used in a class with a different constructor signature, you will need to override <code>_from_iterable()</code> with a classmethod or regular method that can construct new instances from an iterable argument.</li> <li>To override the comparisons (presumably for speed, as the semantics are fixed), redefine <a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code>__le__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code>__ge__()</code></a>, then the other operations will automatically follow suit.</li> <li>The <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> mixin provides a <code>_hash()</code> method to compute a hash value for the set; however, <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> is not defined because not all sets are <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> or immutable. To add set hashability using mixins, inherit from both <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set()</code></a> and <a class="reference internal" href="#collections.abc.Hashable" title="collections.abc.Hashable"><code>Hashable()</code></a>, then define <code>__hash__ = Set._hash</code>.</li> </ol> <div class="admonition seealso"> <p class="admonition-title">See also</p> <ul class="simple"> <li>
<a class="reference external" href="https://code.activestate.com/recipes/576694/">OrderedSet recipe</a> for an example built on <a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code>MutableSet</code></a>.</li> <li>For more about ABCs, see the <a class="reference internal" href="abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code>abc</code></a> module and <span class="target" id="index-5"></span><a class="pep reference external" href="https://peps.python.org/pep-3119/"><strong>PEP 3119</strong></a>.</li> </ul> </div> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/collections.abc.html" class="_attribution-link">https://docs.python.org/3.13/library/collections.abc.html</a>
  </p>
</div>
