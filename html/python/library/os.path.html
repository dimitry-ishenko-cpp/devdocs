 <span id="os-path-common-pathname-manipulations"></span><h1>os.path — Common pathname manipulations</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/genericpath.py">Lib/genericpath.py</a>, <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/posixpath.py">Lib/posixpath.py</a> (for POSIX) and <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/ntpath.py">Lib/ntpath.py</a> (for Windows).</p>  <p>This module implements some useful functions on pathnames. To read or write files see <a class="reference internal" href="functions.html#open" title="open"><code>open()</code></a>, and for accessing the filesystem see the <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code>os</code></a> module. The path parameters can be passed as strings, or bytes, or any object implementing the <a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> protocol.</p> <p>Unlike a Unix shell, Python does not do any <em>automatic</em> path expansions. Functions such as <a class="reference internal" href="#os.path.expanduser" title="os.path.expanduser"><code>expanduser()</code></a> and <a class="reference internal" href="#os.path.expandvars" title="os.path.expandvars"><code>expandvars()</code></a> can be invoked explicitly when an application desires shell-like path expansion. (See also the <a class="reference internal" href="glob.html#module-glob" title="glob: Unix shell style pathname pattern expansion."><code>glob</code></a> module.)</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="pathlib.html#module-pathlib" title="pathlib: Object-oriented filesystem paths"><code>pathlib</code></a> module offers high-level path objects.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>All of these functions accept either only bytes or only string objects as their parameters. The result is an object of the same type, if a path or file name is returned.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Since different operating systems have different path name conventions, there are several versions of this module in the standard library. The <a class="reference internal" href="#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a> module is always the path module suitable for the operating system Python is running on, and therefore usable for local paths. However, you can also import and use the individual modules if you want to manipulate a path that is <em>always</em> in one of the different formats. They all have the same interface:</p> <ul class="simple"> <li>
<code>posixpath</code> for UNIX-style paths</li> <li>
<code>ntpath</code> for Windows paths</li> </ul> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span><a class="reference internal" href="#os.path.exists" title="os.path.exists"><code>exists()</code></a>, <a class="reference internal" href="#os.path.lexists" title="os.path.lexists"><code>lexists()</code></a>, <a class="reference internal" href="#os.path.isdir" title="os.path.isdir"><code>isdir()</code></a>, <a class="reference internal" href="#os.path.isfile" title="os.path.isfile"><code>isfile()</code></a>, <a class="reference internal" href="#os.path.islink" title="os.path.islink"><code>islink()</code></a>, and <a class="reference internal" href="#os.path.ismount" title="os.path.ismount"><code>ismount()</code></a> now return <code>False</code> instead of raising an exception for paths that contain characters or bytes unrepresentable at the OS level.</p> </div> <dl class="py function"> <dt class="sig sig-object py" id="os.path.abspath">
<code>os.path.abspath(path)</code> </dt> <dd>
<p>Return a normalized absolutized version of the pathname <em>path</em>. On most platforms, this is equivalent to calling the function <a class="reference internal" href="#os.path.normpath" title="os.path.normpath"><code>normpath()</code></a> as follows: <code>normpath(join(os.getcwd(), path))</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.basename">
<code>os.path.basename(path)</code> </dt> <dd>
<p>Return the base name of pathname <em>path</em>. This is the second element of the pair returned by passing <em>path</em> to the function <a class="reference internal" href="#os.path.split" title="os.path.split"><code>split()</code></a>. Note that the result of this function is different from the Unix <strong class="program">basename</strong> program; where <strong class="program">basename</strong> for <code>'/foo/bar/'</code> returns <code>'bar'</code>, the <a class="reference internal" href="#os.path.basename" title="os.path.basename"><code>basename()</code></a> function returns an empty string (<code>''</code>).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.commonpath">
<code>os.path.commonpath(paths)</code> </dt> <dd>
<p>Return the longest common sub-path of each pathname in the iterable <em>paths</em>. Raise <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if <em>paths</em> contain both absolute and relative pathnames, if <em>paths</em> are on different drives, or if <em>paths</em> is empty. Unlike <a class="reference internal" href="#os.path.commonprefix" title="os.path.commonprefix"><code>commonprefix()</code></a>, this returns a valid path.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a sequence of <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like objects</span></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Any iterable can now be passed, rather than just sequences.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.commonprefix">
<code>os.path.commonprefix(list)</code> </dt> <dd>
<p>Return the longest path prefix (taken character-by-character) that is a prefix of all paths in <em>list</em>. If <em>list</em> is empty, return the empty string (<code>''</code>).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function may return invalid paths because it works a character at a time. To obtain a valid path, see <a class="reference internal" href="#os.path.commonpath" title="os.path.commonpath"><code>commonpath()</code></a>.</p> <pre data-language="python">&gt;&gt;&gt; os.path.commonprefix(['/usr/lib', '/usr/local/lib'])
'/usr/l'

&gt;&gt;&gt; os.path.commonpath(['/usr/lib', '/usr/local/lib'])
'/usr'
</pre> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.dirname">
<code>os.path.dirname(path)</code> </dt> <dd>
<p>Return the directory name of pathname <em>path</em>. This is the first element of the pair returned by passing <em>path</em> to the function <a class="reference internal" href="#os.path.split" title="os.path.split"><code>split()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.exists">
<code>os.path.exists(path)</code> </dt> <dd>
<p>Return <code>True</code> if <em>path</em> refers to an existing path or an open file descriptor. Returns <code>False</code> for broken symbolic links. On some platforms, this function may return <code>False</code> if permission is not granted to execute <a class="reference internal" href="os.html#os.stat" title="os.stat"><code>os.stat()</code></a> on the requested file, even if the <em>path</em> physically exists.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span><em>path</em> can now be an integer: <code>True</code> is returned if it is an open file descriptor, <code>False</code> otherwise.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.lexists">
<code>os.path.lexists(path)</code> </dt> <dd>
<p>Return <code>True</code> if <em>path</em> refers to an existing path, including broken symbolic links. Equivalent to <a class="reference internal" href="#os.path.exists" title="os.path.exists"><code>exists()</code></a> on platforms lacking <a class="reference internal" href="os.html#os.lstat" title="os.lstat"><code>os.lstat()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function" id="index-1"> <dt class="sig sig-object py" id="os.path.expanduser">
<code>os.path.expanduser(path)</code> </dt> <dd>
<p>On Unix and Windows, return the argument with an initial component of <code>~</code> or <code>~user</code> replaced by that <em>user</em>’s home directory.</p> <p id="index-2">On Unix, an initial <code>~</code> is replaced by the environment variable <span class="target" id="index-3"></span><code>HOME</code> if it is set; otherwise the current user’s home directory is looked up in the password directory through the built-in module <a class="reference internal" href="pwd.html#module-pwd" title="pwd: The password database (getpwnam() and friends). (Unix)"><code>pwd</code></a>. An initial <code>~user</code> is looked up directly in the password directory.</p> <p>On Windows, <span class="target" id="index-4"></span><code>USERPROFILE</code> will be used if set, otherwise a combination of <span class="target" id="index-5"></span><code>HOMEPATH</code> and <span class="target" id="index-6"></span><code>HOMEDRIVE</code> will be used. An initial <code>~user</code> is handled by checking that the last directory component of the current user’s home directory matches <span class="target" id="index-7"></span><code>USERNAME</code>, and replacing it if so.</p> <p>If the expansion fails or if the path does not begin with a tilde, the path is returned unchanged.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>No longer uses <span class="target" id="index-8"></span><code>HOME</code> on Windows.</p> </div> </dd>
</dl> <dl class="py function" id="index-9"> <dt class="sig sig-object py" id="os.path.expandvars">
<code>os.path.expandvars(path)</code> </dt> <dd>
<p>Return the argument with environment variables expanded. Substrings of the form <code>$name</code> or <code>${name}</code> are replaced by the value of environment variable <em>name</em>. Malformed variable names and references to non-existing variables are left unchanged.</p> <p>On Windows, <code>%name%</code> expansions are supported in addition to <code>$name</code> and <code>${name}</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.getatime">
<code>os.path.getatime(path)</code> </dt> <dd>
<p>Return the time of last access of <em>path</em>. The return value is a floating-point number giving the number of seconds since the epoch (see the <a class="reference internal" href="time.html#module-time" title="time: Time access and conversions."><code>time</code></a> module). Raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> if the file does not exist or is inaccessible.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.getmtime">
<code>os.path.getmtime(path)</code> </dt> <dd>
<p>Return the time of last modification of <em>path</em>. The return value is a floating-point number giving the number of seconds since the epoch (see the <a class="reference internal" href="time.html#module-time" title="time: Time access and conversions."><code>time</code></a> module). Raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> if the file does not exist or is inaccessible.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.getctime">
<code>os.path.getctime(path)</code> </dt> <dd>
<p>Return the system’s ctime which, on some systems (like Unix) is the time of the last metadata change, and, on others (like Windows), is the creation time for <em>path</em>. The return value is a number giving the number of seconds since the epoch (see the <a class="reference internal" href="time.html#module-time" title="time: Time access and conversions."><code>time</code></a> module). Raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> if the file does not exist or is inaccessible.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.getsize">
<code>os.path.getsize(path)</code> </dt> <dd>
<p>Return the size, in bytes, of <em>path</em>. Raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> if the file does not exist or is inaccessible.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.isabs">
<code>os.path.isabs(path)</code> </dt> <dd>
<p>Return <code>True</code> if <em>path</em> is an absolute pathname. On Unix, that means it begins with a slash, on Windows that it begins with two (back)slashes, or a drive letter, colon, and (back)slash together.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>On Windows, returns <code>False</code> if the given path starts with exactly one (back)slash.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.isfile">
<code>os.path.isfile(path)</code> </dt> <dd>
<p>Return <code>True</code> if <em>path</em> is an <a class="reference internal" href="#os.path.exists" title="os.path.exists"><code>existing</code></a> regular file. This follows symbolic links, so both <a class="reference internal" href="#os.path.islink" title="os.path.islink"><code>islink()</code></a> and <a class="reference internal" href="#os.path.isfile" title="os.path.isfile"><code>isfile()</code></a> can be true for the same path.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.isdir">
<code>os.path.isdir(path)</code> </dt> <dd>
<p>Return <code>True</code> if <em>path</em> is an <a class="reference internal" href="#os.path.exists" title="os.path.exists"><code>existing</code></a> directory. This follows symbolic links, so both <a class="reference internal" href="#os.path.islink" title="os.path.islink"><code>islink()</code></a> and <a class="reference internal" href="#os.path.isdir" title="os.path.isdir"><code>isdir()</code></a> can be true for the same path.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.isjunction">
<code>os.path.isjunction(path)</code> </dt> <dd>
<p>Return <code>True</code> if <em>path</em> refers to an <a class="reference internal" href="#os.path.lexists" title="os.path.lexists"><code>existing</code></a> directory entry that is a junction. Always return <code>False</code> if junctions are not supported on the current platform.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.islink">
<code>os.path.islink(path)</code> </dt> <dd>
<p>Return <code>True</code> if <em>path</em> refers to an <a class="reference internal" href="#os.path.exists" title="os.path.exists"><code>existing</code></a> directory entry that is a symbolic link. Always <code>False</code> if symbolic links are not supported by the Python runtime.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.ismount">
<code>os.path.ismount(path)</code> </dt> <dd>
<p>Return <code>True</code> if pathname <em>path</em> is a <em class="dfn">mount point</em>: a point in a file system where a different file system has been mounted. On POSIX, the function checks whether <em>path</em>’s parent, <code><em>path</em>/..</code>, is on a different device than <em>path</em>, or whether <code><em>path</em>/..</code> and <em>path</em> point to the same i-node on the same device — this should detect mount points for all Unix and POSIX variants. It is not able to reliably detect bind mounts on the same filesystem. On Windows, a drive letter root and a share UNC are always mount points, and for any other path <code>GetVolumePathName</code> is called to see if it is different from the input path.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Added support for detecting non-root mount points on Windows.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.isdevdrive">
<code>os.path.isdevdrive(path)</code> </dt> <dd>
<p>Return <code>True</code> if pathname <em>path</em> is located on a Windows Dev Drive. A Dev Drive is optimized for developer scenarios, and offers faster performance for reading and writing files. It is recommended for use for source code, temporary build directories, package caches, and other IO-intensive operations.</p> <p>May raise an error for an invalid path, for example, one without a recognizable drive, but returns <code>False</code> on platforms that do not support Dev Drives. See <a class="reference external" href="https://learn.microsoft.com/windows/dev-drive/">the Windows documentation</a> for information on enabling and creating Dev Drives.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The function is now available on all platforms, and will always return <code>False</code> on those that have no support for Dev Drives</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.isreserved">
<code>os.path.isreserved(path)</code> </dt> <dd>
<p>Return <code>True</code> if <em>path</em> is a reserved pathname on the current system.</p> <p>On Windows, reserved filenames include those that end with a space or dot; those that contain colons (i.e. file streams such as “name:stream”), wildcard characters (i.e. <code>'*?"&lt;&gt;'</code>), pipe, or ASCII control characters; as well as DOS device names such as “NUL”, “CON”, “CONIN$”, “CONOUT$”, “AUX”, “PRN”, “COM1”, and “LPT1”.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function approximates rules for reserved paths on most Windows systems. These rules change over time in various Windows releases. This function may be updated in future Python releases as changes to the rules become broadly available.</p> </div> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.join">
<code>os.path.join(path, *paths)</code> </dt> <dd>
<p>Join one or more path segments intelligently. The return value is the concatenation of <em>path</em> and all members of <em>*paths</em>, with exactly one directory separator following each non-empty part, except the last. That is, the result will only end in a separator if the last part is either empty or ends in a separator. If a segment is an absolute path (which on Windows requires both a drive and a root), then all previous segments are ignored and joining continues from the absolute path segment.</p> <p>On Windows, the drive is not reset when a rooted path segment (e.g., <code>r'\foo'</code>) is encountered. If a segment is on a different drive or is an absolute path, all previous segments are ignored and the drive is reset. Note that since there is a current directory for each drive, <code>os.path.join("c:", "foo")</code> represents a path relative to the current directory on drive <code>C:</code> (<code>c:foo</code>), not <code>c:\foo</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a> for <em>path</em> and <em>paths</em>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.normcase">
<code>os.path.normcase(path)</code> </dt> <dd>
<p>Normalize the case of a pathname. On Windows, convert all characters in the pathname to lowercase, and also convert forward slashes to backward slashes. On other operating systems, return the path unchanged.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.normpath">
<code>os.path.normpath(path)</code> </dt> <dd>
<p>Normalize a pathname by collapsing redundant separators and up-level references so that <code>A//B</code>, <code>A/B/</code>, <code>A/./B</code> and <code>A/foo/../B</code> all become <code>A/B</code>. This string manipulation may change the meaning of a path that contains symbolic links. On Windows, it converts forward slashes to backward slashes. To normalize case, use <a class="reference internal" href="#os.path.normcase" title="os.path.normcase"><code>normcase()</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>On POSIX systems, in accordance with <a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13">IEEE Std 1003.1 2013 Edition; 4.13 Pathname Resolution</a>, if a pathname begins with exactly two slashes, the first component following the leading characters may be interpreted in an implementation-defined manner, although more than two leading characters shall be treated as a single character.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.realpath">
<code>os.path.realpath(path, *, strict=False)</code> </dt> <dd>
<p>Return the canonical path of the specified filename, eliminating any symbolic links encountered in the path (if they are supported by the operating system). On Windows, this function will also resolve MS-DOS (also called 8.3) style names such as <code>C:\\PROGRA~1</code> to <code>C:\\Program Files</code>.</p> <p>If a path doesn’t exist or a symlink loop is encountered, and <em>strict</em> is <code>True</code>, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> is raised. If <em>strict</em> is <code>False</code> these errors are ignored, and so the result might be missing or otherwise inaccessible.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function emulates the operating system’s procedure for making a path canonical, which differs slightly between Windows and UNIX with respect to how links and subsequent path components interact.</p> <p>Operating system APIs make paths canonical as needed, so it’s not normally necessary to call this function.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Symbolic links and junctions are now resolved on Windows.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <em>strict</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.relpath">
<code>os.path.relpath(path, start=os.curdir)</code> </dt> <dd>
<p>Return a relative filepath to <em>path</em> either from the current directory or from an optional <em>start</em> directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of <em>path</em> or <em>start</em>. On Windows, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised when <em>path</em> and <em>start</em> are on different drives.</p> <p><em>start</em> defaults to <a class="reference internal" href="os.html#os.curdir" title="os.curdir"><code>os.curdir</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.samefile">
<code>os.path.samefile(path1, path2)</code> </dt> <dd>
<p>Return <code>True</code> if both pathname arguments refer to the same file or directory. This is determined by the device number and i-node number and raises an exception if an <a class="reference internal" href="os.html#os.stat" title="os.stat"><code>os.stat()</code></a> call on either pathname fails.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Added Windows support.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Windows now uses the same implementation as all other platforms.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.sameopenfile">
<code>os.path.sameopenfile(fp1, fp2)</code> </dt> <dd>
<p>Return <code>True</code> if the file descriptors <em>fp1</em> and <em>fp2</em> refer to the same file.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Added Windows support.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.samestat">
<code>os.path.samestat(stat1, stat2)</code> </dt> <dd>
<p>Return <code>True</code> if the stat tuples <em>stat1</em> and <em>stat2</em> refer to the same file. These structures may have been returned by <a class="reference internal" href="os.html#os.fstat" title="os.fstat"><code>os.fstat()</code></a>, <a class="reference internal" href="os.html#os.lstat" title="os.lstat"><code>os.lstat()</code></a>, or <a class="reference internal" href="os.html#os.stat" title="os.stat"><code>os.stat()</code></a>. This function implements the underlying comparison used by <a class="reference internal" href="#os.path.samefile" title="os.path.samefile"><code>samefile()</code></a> and <a class="reference internal" href="#os.path.sameopenfile" title="os.path.sameopenfile"><code>sameopenfile()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Added Windows support.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.split">
<code>os.path.split(path)</code> </dt> <dd>
<p>Split the pathname <em>path</em> into a pair, <code>(head, tail)</code> where <em>tail</em> is the last pathname component and <em>head</em> is everything leading up to that. The <em>tail</em> part will never contain a slash; if <em>path</em> ends in a slash, <em>tail</em> will be empty. If there is no slash in <em>path</em>, <em>head</em> will be empty. If <em>path</em> is empty, both <em>head</em> and <em>tail</em> are empty. Trailing slashes are stripped from <em>head</em> unless it is the root (one or more slashes only). In all cases, <code>join(head, tail)</code> returns a path to the same location as <em>path</em> (but the strings may differ). Also see the functions <a class="reference internal" href="#os.path.dirname" title="os.path.dirname"><code>dirname()</code></a> and <a class="reference internal" href="#os.path.basename" title="os.path.basename"><code>basename()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.splitdrive">
<code>os.path.splitdrive(path)</code> </dt> <dd>
<p>Split the pathname <em>path</em> into a pair <code>(drive, tail)</code> where <em>drive</em> is either a mount point or the empty string. On systems which do not use drive specifications, <em>drive</em> will always be the empty string. In all cases, <code>drive
+ tail</code> will be the same as <em>path</em>.</p> <p>On Windows, splits a pathname into drive/UNC sharepoint and relative path.</p> <p>If the path contains a drive letter, drive will contain everything up to and including the colon:</p> <pre data-language="python">&gt;&gt;&gt; splitdrive("c:/dir")
("c:", "/dir")
</pre> <p>If the path contains a UNC path, drive will contain the host name and share:</p> <pre data-language="python">&gt;&gt;&gt; splitdrive("//host/computer/dir")
("//host/computer", "/dir")
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.splitroot">
<code>os.path.splitroot(path)</code> </dt> <dd>
<p>Split the pathname <em>path</em> into a 3-item tuple <code>(drive, root, tail)</code> where <em>drive</em> is a device name or mount point, <em>root</em> is a string of separators after the drive, and <em>tail</em> is everything after the root. Any of these items may be the empty string. In all cases, <code>drive + root + tail</code> will be the same as <em>path</em>.</p> <p>On POSIX systems, <em>drive</em> is always empty. The <em>root</em> may be empty (if <em>path</em> is relative), a single forward slash (if <em>path</em> is absolute), or two forward slashes (implementation-defined per <a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13">IEEE Std 1003.1-2017; 4.13 Pathname Resolution</a>.) For example:</p> <pre data-language="python">&gt;&gt;&gt; splitroot('/home/sam')
('', '/', 'home/sam')
&gt;&gt;&gt; splitroot('//home/sam')
('', '//', 'home/sam')
&gt;&gt;&gt; splitroot('///home/sam')
('', '/', '//home/sam')
</pre> <p>On Windows, <em>drive</em> may be empty, a drive-letter name, a UNC share, or a device name. The <em>root</em> may be empty, a forward slash, or a backward slash. For example:</p> <pre data-language="python">&gt;&gt;&gt; splitroot('C:/Users/Sam')
('C:', '/', 'Users/Sam')
&gt;&gt;&gt; splitroot('//Server/Share/Users/Sam')
('//Server/Share', '/', 'Users/Sam')
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="os.path.splitext">
<code>os.path.splitext(path)</code> </dt> <dd>
<p>Split the pathname <em>path</em> into a pair <code>(root, ext)</code> such that <code>root + ext ==
path</code>, and the extension, <em>ext</em>, is empty or begins with a period and contains at most one period.</p> <p>If the path contains no extension, <em>ext</em> will be <code>''</code>:</p> <pre data-language="python">&gt;&gt;&gt; splitext('bar')
('bar', '')
</pre> <p>If the path contains an extension, then <em>ext</em> will be set to this extension, including the leading period. Note that previous periods will be ignored:</p> <pre data-language="python">&gt;&gt;&gt; splitext('foo.bar.exe')
('foo.bar', '.exe')
&gt;&gt;&gt; splitext('/foo/bar.exe')
('/foo/bar', '.exe')
</pre> <p>Leading periods of the last component of the path are considered to be part of the root:</p> <pre data-language="python">&gt;&gt;&gt; splitext('.cshrc')
('.cshrc', '')
&gt;&gt;&gt; splitext('/foo/....jpg')
('/foo/....jpg', '')
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="os.path.supports_unicode_filenames">
<code>os.path.supports_unicode_filenames</code> </dt> <dd>
<p><code>True</code> if arbitrary Unicode strings can be used as file names (within limitations imposed by the file system).</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/os.path.html" class="_attribution-link">https://docs.python.org/3.13/library/os.path.html</a>
  </p>
</div>
