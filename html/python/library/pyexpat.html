 <span id="xml-parsers-expat-fast-xml-parsing-using-expat"></span><h1>xml.parsers.expat — Fast XML parsing using Expat</h1>  <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The <code>pyexpat</code> module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data see <a class="reference internal" href="xml.html#xml-vulnerabilities"><span class="std std-ref">XML vulnerabilities</span></a>.</p> </div> <p id="index-0">The <a class="reference internal" href="#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code>xml.parsers.expat</code></a> module is a Python interface to the Expat non-validating XML parser. The module provides a single extension type, <code>xmlparser</code>, that represents the current state of an XML parser. After an <code>xmlparser</code> object has been created, various attributes of the object can be set to handler functions. When an XML document is then fed to the parser, the handler functions are called for the character data and markup in the XML document.</p> <p id="index-1">This module uses the <code>pyexpat</code> module to provide access to the Expat parser. Direct use of the <code>pyexpat</code> module is deprecated.</p> <p>This module provides one exception and one type object:</p> <dl class="py exception"> <dt class="sig sig-object py" id="xml.parsers.expat.ExpatError">
<code>exception xml.parsers.expat.ExpatError</code> </dt> <dd>
<p>The exception raised when Expat reports an error. See section <a class="reference internal" href="#expaterror-objects"><span class="std std-ref">ExpatError Exceptions</span></a> for more information on interpreting Expat errors.</p> </dd>
</dl> <dl class="py exception"> <dt class="sig sig-object py" id="xml.parsers.expat.error">
<code>exception xml.parsers.expat.error</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#xml.parsers.expat.ExpatError" title="xml.parsers.expat.ExpatError"><code>ExpatError</code></a>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.XMLParserType">
<code>xml.parsers.expat.XMLParserType</code> </dt> <dd>
<p>The type of the return values from the <a class="reference internal" href="#xml.parsers.expat.ParserCreate" title="xml.parsers.expat.ParserCreate"><code>ParserCreate()</code></a> function.</p> </dd>
</dl> <p>The <a class="reference internal" href="#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code>xml.parsers.expat</code></a> module contains two functions:</p> <dl class="py function"> <dt class="sig sig-object py" id="xml.parsers.expat.ErrorString">
<code>xml.parsers.expat.ErrorString(errno)</code> </dt> <dd>
<p>Returns an explanatory string for a given error number <em>errno</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="xml.parsers.expat.ParserCreate">
<code>xml.parsers.expat.ParserCreate(encoding=None, namespace_separator=None)</code> </dt> <dd>
<p>Creates and returns a new <code>xmlparser</code> object. <em>encoding</em>, if specified, must be a string naming the encoding used by the XML data. Expat doesn’t support as many encodings as Python does, and its repertoire of encodings can’t be extended; it supports UTF-8, UTF-16, ISO-8859-1 (Latin1), and ASCII. If <em>encoding</em> <a class="footnote-reference brackets" href="#id3" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> is given it will override the implicit or explicit encoding of the document.</p> <p>Expat can optionally do XML namespace processing for you, enabled by providing a value for <em>namespace_separator</em>. The value must be a one-character string; a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> will be raised if the string has an illegal length (<code>None</code> is considered the same as omission). When namespace processing is enabled, element type names and attribute names that belong to a namespace will be expanded. The element name passed to the element handlers <code>StartElementHandler</code> and <code>EndElementHandler</code> will be the concatenation of the namespace URI, the namespace separator character, and the local part of the name. If the namespace separator is a zero byte (<code>chr(0)</code>) then the namespace URI and the local part will be concatenated without any separator.</p> <p>For example, if <em>namespace_separator</em> is set to a space character (<code>' '</code>) and the following document is parsed:</p> <pre data-language="xml">&lt;?xml version="1.0"?&gt;
&lt;root xmlns    = "http://default-namespace.org/"
      xmlns:py = "http://www.python.org/ns/"&gt;
  &lt;py:elem1 /&gt;
  &lt;elem2 xmlns="" /&gt;
&lt;/root&gt;
</pre> <p><code>StartElementHandler</code> will receive the following strings for each element:</p> <pre data-language="python">http://default-namespace.org/ root
http://www.python.org/ns/ elem1
elem2
</pre> <p>Due to limitations in the <code>Expat</code> library used by <code>pyexpat</code>, the <code>xmlparser</code> instance returned can only be used to parse a single XML document. Call <code>ParserCreate</code> for each document to provide unique parser instances.</p> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="http://www.libexpat.org/">The Expat XML Parser</a></dt>
<dd>
<p>Home page of the Expat project.</p> </dd> </dl> </div> <section id="xmlparser-objects"> <span id="id2"></span><h2>XMLParser Objects</h2> <p><code>xmlparser</code> objects have the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.Parse">
<code>xmlparser.Parse(data[, isfinal])</code> </dt> <dd>
<p>Parses the contents of the string <em>data</em>, calling the appropriate handler functions to process the parsed data. <em>isfinal</em> must be true on the final call to this method; it allows the parsing of a single file in fragments, not the submission of multiple files. <em>data</em> can be the empty string at any time.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.ParseFile">
<code>xmlparser.ParseFile(file)</code> </dt> <dd>
<p>Parse XML data reading from the object <em>file</em>. <em>file</em> only needs to provide the <code>read(nbytes)</code> method, returning the empty string when there’s no more data.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.SetBase">
<code>xmlparser.SetBase(base)</code> </dt> <dd>
<p>Sets the base to be used for resolving relative URIs in system identifiers in declarations. Resolving relative identifiers is left to the application: this value will be passed through as the <em>base</em> argument to the <a class="reference internal" href="#xml.parsers.expat.xmlparser.ExternalEntityRefHandler" title="xml.parsers.expat.xmlparser.ExternalEntityRefHandler"><code>ExternalEntityRefHandler()</code></a>, <a class="reference internal" href="#xml.parsers.expat.xmlparser.NotationDeclHandler" title="xml.parsers.expat.xmlparser.NotationDeclHandler"><code>NotationDeclHandler()</code></a>, and <a class="reference internal" href="#xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler" title="xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler"><code>UnparsedEntityDeclHandler()</code></a> functions.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.GetBase">
<code>xmlparser.GetBase()</code> </dt> <dd>
<p>Returns a string containing the base set by a previous call to <a class="reference internal" href="#xml.parsers.expat.xmlparser.SetBase" title="xml.parsers.expat.xmlparser.SetBase"><code>SetBase()</code></a>, or <code>None</code> if <a class="reference internal" href="#xml.parsers.expat.xmlparser.SetBase" title="xml.parsers.expat.xmlparser.SetBase"><code>SetBase()</code></a> hasn’t been called.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.GetInputContext">
<code>xmlparser.GetInputContext()</code> </dt> <dd>
<p>Returns the input data that generated the current event as a string. The data is in the encoding of the entity which contains the text. When called while an event handler is not active, the return value is <code>None</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.ExternalEntityParserCreate">
<code>xmlparser.ExternalEntityParserCreate(context[, encoding])</code> </dt> <dd>
<p>Create a “child” parser which can be used to parse an external parsed entity referred to by content parsed by the parent parser. The <em>context</em> parameter should be the string passed to the <a class="reference internal" href="#xml.parsers.expat.xmlparser.ExternalEntityRefHandler" title="xml.parsers.expat.xmlparser.ExternalEntityRefHandler"><code>ExternalEntityRefHandler()</code></a> handler function, described below. The child parser is created with the <a class="reference internal" href="#xml.parsers.expat.xmlparser.ordered_attributes" title="xml.parsers.expat.xmlparser.ordered_attributes"><code>ordered_attributes</code></a> and <a class="reference internal" href="#xml.parsers.expat.xmlparser.specified_attributes" title="xml.parsers.expat.xmlparser.specified_attributes"><code>specified_attributes</code></a> set to the values of this parser.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.SetParamEntityParsing">
<code>xmlparser.SetParamEntityParsing(flag)</code> </dt> <dd>
<p>Control parsing of parameter entities (including the external DTD subset). Possible <em>flag</em> values are <code>XML_PARAM_ENTITY_PARSING_NEVER</code>, <code>XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE</code> and <code>XML_PARAM_ENTITY_PARSING_ALWAYS</code>. Return true if setting the flag was successful.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.UseForeignDTD">
<code>xmlparser.UseForeignDTD([flag])</code> </dt> <dd>
<p>Calling this with a true value for <em>flag</em> (the default) will cause Expat to call the <a class="reference internal" href="#xml.parsers.expat.xmlparser.ExternalEntityRefHandler" title="xml.parsers.expat.xmlparser.ExternalEntityRefHandler"><code>ExternalEntityRefHandler</code></a> with <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a> for all arguments to allow an alternate DTD to be loaded. If the document does not contain a document type declaration, the <a class="reference internal" href="#xml.parsers.expat.xmlparser.ExternalEntityRefHandler" title="xml.parsers.expat.xmlparser.ExternalEntityRefHandler"><code>ExternalEntityRefHandler</code></a> will still be called, but the <a class="reference internal" href="#xml.parsers.expat.xmlparser.StartDoctypeDeclHandler" title="xml.parsers.expat.xmlparser.StartDoctypeDeclHandler"><code>StartDoctypeDeclHandler</code></a> and <a class="reference internal" href="#xml.parsers.expat.xmlparser.EndDoctypeDeclHandler" title="xml.parsers.expat.xmlparser.EndDoctypeDeclHandler"><code>EndDoctypeDeclHandler</code></a> will not be called.</p> <p>Passing a false value for <em>flag</em> will cancel a previous call that passed a true value, but otherwise has no effect.</p> <p>This method can only be called before the <a class="reference internal" href="#xml.parsers.expat.xmlparser.Parse" title="xml.parsers.expat.xmlparser.Parse"><code>Parse()</code></a> or <a class="reference internal" href="#xml.parsers.expat.xmlparser.ParseFile" title="xml.parsers.expat.xmlparser.ParseFile"><code>ParseFile()</code></a> methods are called; calling it after either of those have been called causes <a class="reference internal" href="#xml.parsers.expat.ExpatError" title="xml.parsers.expat.ExpatError"><code>ExpatError</code></a> to be raised with the <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code>code</code></a> attribute set to <code>errors.codes[errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING]</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.SetReparseDeferralEnabled">
<code>xmlparser.SetReparseDeferralEnabled(enabled)</code> </dt> <dd>
<div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Calling <code>SetReparseDeferralEnabled(False)</code> has security implications, as detailed below; please make sure to understand these consequences prior to using the <code>SetReparseDeferralEnabled</code> method.</p> </div> <p>Expat 2.6.0 introduced a security mechanism called “reparse deferral” where instead of causing denial of service through quadratic runtime from reparsing large tokens, reparsing of unfinished tokens is now delayed by default until a sufficient amount of input is reached. Due to this delay, registered handlers may — depending of the sizing of input chunks pushed to Expat — no longer be called right after pushing new input to the parser. Where immediate feedback and taking over responsibility of protecting against denial of service from large tokens are both wanted, calling <code>SetReparseDeferralEnabled(False)</code> disables reparse deferral for the current Expat parser instance, temporarily or altogether. Calling <code>SetReparseDeferralEnabled(True)</code> allows re-enabling reparse deferral.</p> <p>Note that <a class="reference internal" href="#xml.parsers.expat.xmlparser.SetReparseDeferralEnabled" title="xml.parsers.expat.xmlparser.SetReparseDeferralEnabled"><code>SetReparseDeferralEnabled()</code></a> has been backported to some prior releases of CPython as a security fix. Check for availability of <a class="reference internal" href="#xml.parsers.expat.xmlparser.SetReparseDeferralEnabled" title="xml.parsers.expat.xmlparser.SetReparseDeferralEnabled"><code>SetReparseDeferralEnabled()</code></a> using <a class="reference internal" href="functions.html#hasattr" title="hasattr"><code>hasattr()</code></a> if used in code running across a variety of Python versions.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.GetReparseDeferralEnabled">
<code>xmlparser.GetReparseDeferralEnabled()</code> </dt> <dd>
<p>Returns whether reparse deferral is currently enabled for the given Expat parser instance.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <p><code>xmlparser</code> objects have the following attributes:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.buffer_size">
<code>xmlparser.buffer_size</code> </dt> <dd>
<p>The size of the buffer used when <a class="reference internal" href="#xml.parsers.expat.xmlparser.buffer_text" title="xml.parsers.expat.xmlparser.buffer_text"><code>buffer_text</code></a> is true. A new buffer size can be set by assigning a new integer value to this attribute. When the size is changed, the buffer will be flushed.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.buffer_text">
<code>xmlparser.buffer_text</code> </dt> <dd>
<p>Setting this to true causes the <code>xmlparser</code> object to buffer textual content returned by Expat to avoid multiple calls to the <a class="reference internal" href="#xml.parsers.expat.xmlparser.CharacterDataHandler" title="xml.parsers.expat.xmlparser.CharacterDataHandler"><code>CharacterDataHandler()</code></a> callback whenever possible. This can improve performance substantially since Expat normally breaks character data into chunks at every line ending. This attribute is false by default, and may be changed at any time. Note that when it is false, data that does not contain newlines may be chunked too.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.buffer_used">
<code>xmlparser.buffer_used</code> </dt> <dd>
<p>If <a class="reference internal" href="#xml.parsers.expat.xmlparser.buffer_text" title="xml.parsers.expat.xmlparser.buffer_text"><code>buffer_text</code></a> is enabled, the number of bytes stored in the buffer. These bytes represent UTF-8 encoded text. This attribute has no meaningful interpretation when <a class="reference internal" href="#xml.parsers.expat.xmlparser.buffer_text" title="xml.parsers.expat.xmlparser.buffer_text"><code>buffer_text</code></a> is false.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.ordered_attributes">
<code>xmlparser.ordered_attributes</code> </dt> <dd>
<p>Setting this attribute to a non-zero integer causes the attributes to be reported as a list rather than a dictionary. The attributes are presented in the order found in the document text. For each attribute, two list entries are presented: the attribute name and the attribute value. (Older versions of this module also used this format.) By default, this attribute is false; it may be changed at any time.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.specified_attributes">
<code>xmlparser.specified_attributes</code> </dt> <dd>
<p>If set to a non-zero integer, the parser will report only those attributes which were specified in the document instance and not those which were derived from attribute declarations. Applications which set this need to be especially careful to use what additional information is available from the declarations as needed to comply with the standards for the behavior of XML processors. By default, this attribute is false; it may be changed at any time.</p> </dd>
</dl> <p>The following attributes contain values relating to the most recent error encountered by an <code>xmlparser</code> object, and will only have correct values once a call to <code>Parse()</code> or <code>ParseFile()</code> has raised an <a class="reference internal" href="#xml.parsers.expat.ExpatError" title="xml.parsers.expat.ExpatError"><code>xml.parsers.expat.ExpatError</code></a> exception.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.ErrorByteIndex">
<code>xmlparser.ErrorByteIndex</code> </dt> <dd>
<p>Byte index at which an error occurred.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.ErrorCode">
<code>xmlparser.ErrorCode</code> </dt> <dd>
<p>Numeric code specifying the problem. This value can be passed to the <a class="reference internal" href="#xml.parsers.expat.ErrorString" title="xml.parsers.expat.ErrorString"><code>ErrorString()</code></a> function, or compared to one of the constants defined in the <code>errors</code> object.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.ErrorColumnNumber">
<code>xmlparser.ErrorColumnNumber</code> </dt> <dd>
<p>Column number at which an error occurred.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.ErrorLineNumber">
<code>xmlparser.ErrorLineNumber</code> </dt> <dd>
<p>Line number at which an error occurred.</p> </dd>
</dl> <p>The following attributes contain values relating to the current parse location in an <code>xmlparser</code> object. During a callback reporting a parse event they indicate the location of the first of the sequence of characters that generated the event. When called outside of a callback, the position indicated will be just past the last parse event (regardless of whether there was an associated callback).</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.CurrentByteIndex">
<code>xmlparser.CurrentByteIndex</code> </dt> <dd>
<p>Current byte index in the parser input.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.CurrentColumnNumber">
<code>xmlparser.CurrentColumnNumber</code> </dt> <dd>
<p>Current column number in the parser input.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.CurrentLineNumber">
<code>xmlparser.CurrentLineNumber</code> </dt> <dd>
<p>Current line number in the parser input.</p> </dd>
</dl> <p>Here is the list of handlers that can be set. To set a handler on an <code>xmlparser</code> object <em>o</em>, use <code>o.handlername = func</code>. <em>handlername</em> must be taken from the following list, and <em>func</em> must be a callable object accepting the correct number of arguments. The arguments are all strings, unless otherwise stated.</p> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.XmlDeclHandler">
<code>xmlparser.XmlDeclHandler(version, encoding, standalone)</code> </dt> <dd>
<p>Called when the XML declaration is parsed. The XML declaration is the (optional) declaration of the applicable version of the XML recommendation, the encoding of the document text, and an optional “standalone” declaration. <em>version</em> and <em>encoding</em> will be strings, and <em>standalone</em> will be <code>1</code> if the document is declared standalone, <code>0</code> if it is declared not to be standalone, or <code>-1</code> if the standalone clause was omitted. This is only available with Expat version 1.95.0 or newer.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.StartDoctypeDeclHandler">
<code>xmlparser.StartDoctypeDeclHandler(doctypeName, systemId, publicId, has_internal_subset)</code> </dt> <dd>
<p>Called when Expat begins parsing the document type declaration (<code>&lt;!DOCTYPE
...</code>). The <em>doctypeName</em> is provided exactly as presented. The <em>systemId</em> and <em>publicId</em> parameters give the system and public identifiers if specified, or <code>None</code> if omitted. <em>has_internal_subset</em> will be true if the document contains and internal document declaration subset. This requires Expat version 1.2 or newer.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.EndDoctypeDeclHandler">
<code>xmlparser.EndDoctypeDeclHandler()</code> </dt> <dd>
<p>Called when Expat is done parsing the document type declaration. This requires Expat version 1.2 or newer.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.ElementDeclHandler">
<code>xmlparser.ElementDeclHandler(name, model)</code> </dt> <dd>
<p>Called once for each element type declaration. <em>name</em> is the name of the element type, and <em>model</em> is a representation of the content model.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.AttlistDeclHandler">
<code>xmlparser.AttlistDeclHandler(elname, attname, type, default, required)</code> </dt> <dd>
<p>Called for each declared attribute for an element type. If an attribute list declaration declares three attributes, this handler is called three times, once for each attribute. <em>elname</em> is the name of the element to which the declaration applies and <em>attname</em> is the name of the attribute declared. The attribute type is a string passed as <em>type</em>; the possible values are <code>'CDATA'</code>, <code>'ID'</code>, <code>'IDREF'</code>, … <em>default</em> gives the default value for the attribute used when the attribute is not specified by the document instance, or <code>None</code> if there is no default value (<code>#IMPLIED</code> values). If the attribute is required to be given in the document instance, <em>required</em> will be true. This requires Expat version 1.95.0 or newer.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.StartElementHandler">
<code>xmlparser.StartElementHandler(name, attributes)</code> </dt> <dd>
<p>Called for the start of every element. <em>name</em> is a string containing the element name, and <em>attributes</em> is the element attributes. If <a class="reference internal" href="#xml.parsers.expat.xmlparser.ordered_attributes" title="xml.parsers.expat.xmlparser.ordered_attributes"><code>ordered_attributes</code></a> is true, this is a list (see <a class="reference internal" href="#xml.parsers.expat.xmlparser.ordered_attributes" title="xml.parsers.expat.xmlparser.ordered_attributes"><code>ordered_attributes</code></a> for a full description). Otherwise it’s a dictionary mapping names to values.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.EndElementHandler">
<code>xmlparser.EndElementHandler(name)</code> </dt> <dd>
<p>Called for the end of every element.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.ProcessingInstructionHandler">
<code>xmlparser.ProcessingInstructionHandler(target, data)</code> </dt> <dd>
<p>Called for every processing instruction.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.CharacterDataHandler">
<code>xmlparser.CharacterDataHandler(data)</code> </dt> <dd>
<p>Called for character data. This will be called for normal character data, CDATA marked content, and ignorable whitespace. Applications which must distinguish these cases can use the <a class="reference internal" href="#xml.parsers.expat.xmlparser.StartCdataSectionHandler" title="xml.parsers.expat.xmlparser.StartCdataSectionHandler"><code>StartCdataSectionHandler</code></a>, <a class="reference internal" href="#xml.parsers.expat.xmlparser.EndCdataSectionHandler" title="xml.parsers.expat.xmlparser.EndCdataSectionHandler"><code>EndCdataSectionHandler</code></a>, and <a class="reference internal" href="#xml.parsers.expat.xmlparser.ElementDeclHandler" title="xml.parsers.expat.xmlparser.ElementDeclHandler"><code>ElementDeclHandler</code></a> callbacks to collect the required information. Note that the character data may be chunked even if it is short and so you may receive more than one call to <a class="reference internal" href="#xml.parsers.expat.xmlparser.CharacterDataHandler" title="xml.parsers.expat.xmlparser.CharacterDataHandler"><code>CharacterDataHandler()</code></a>. Set the <a class="reference internal" href="#xml.parsers.expat.xmlparser.buffer_text" title="xml.parsers.expat.xmlparser.buffer_text"><code>buffer_text</code></a> instance attribute to <code>True</code> to avoid that.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler">
<code>xmlparser.UnparsedEntityDeclHandler(entityName, base, systemId, publicId, notationName)</code> </dt> <dd>
<p>Called for unparsed (NDATA) entity declarations. This is only present for version 1.2 of the Expat library; for more recent versions, use <a class="reference internal" href="#xml.parsers.expat.xmlparser.EntityDeclHandler" title="xml.parsers.expat.xmlparser.EntityDeclHandler"><code>EntityDeclHandler</code></a> instead. (The underlying function in the Expat library has been declared obsolete.)</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.EntityDeclHandler">
<code>xmlparser.EntityDeclHandler(entityName, is_parameter_entity, value, base, systemId, publicId, notationName)</code> </dt> <dd>
<p>Called for all entity declarations. For parameter and internal entities, <em>value</em> will be a string giving the declared contents of the entity; this will be <code>None</code> for external entities. The <em>notationName</em> parameter will be <code>None</code> for parsed entities, and the name of the notation for unparsed entities. <em>is_parameter_entity</em> will be true if the entity is a parameter entity or false for general entities (most applications only need to be concerned with general entities). This is only available starting with version 1.95.0 of the Expat library.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.NotationDeclHandler">
<code>xmlparser.NotationDeclHandler(notationName, base, systemId, publicId)</code> </dt> <dd>
<p>Called for notation declarations. <em>notationName</em>, <em>base</em>, and <em>systemId</em>, and <em>publicId</em> are strings if given. If the public identifier is omitted, <em>publicId</em> will be <code>None</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.StartNamespaceDeclHandler">
<code>xmlparser.StartNamespaceDeclHandler(prefix, uri)</code> </dt> <dd>
<p>Called when an element contains a namespace declaration. Namespace declarations are processed before the <a class="reference internal" href="#xml.parsers.expat.xmlparser.StartElementHandler" title="xml.parsers.expat.xmlparser.StartElementHandler"><code>StartElementHandler</code></a> is called for the element on which declarations are placed.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.EndNamespaceDeclHandler">
<code>xmlparser.EndNamespaceDeclHandler(prefix)</code> </dt> <dd>
<p>Called when the closing tag is reached for an element that contained a namespace declaration. This is called once for each namespace declaration on the element in the reverse of the order for which the <a class="reference internal" href="#xml.parsers.expat.xmlparser.StartNamespaceDeclHandler" title="xml.parsers.expat.xmlparser.StartNamespaceDeclHandler"><code>StartNamespaceDeclHandler</code></a> was called to indicate the start of each namespace declaration’s scope. Calls to this handler are made after the corresponding <a class="reference internal" href="#xml.parsers.expat.xmlparser.EndElementHandler" title="xml.parsers.expat.xmlparser.EndElementHandler"><code>EndElementHandler</code></a> for the end of the element.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.CommentHandler">
<code>xmlparser.CommentHandler(data)</code> </dt> <dd>
<p>Called for comments. <em>data</em> is the text of the comment, excluding the leading <code>'&lt;!-</code><code>-'</code> and trailing <code>'-</code><code>-&gt;'</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.StartCdataSectionHandler">
<code>xmlparser.StartCdataSectionHandler()</code> </dt> <dd>
<p>Called at the start of a CDATA section. This and <a class="reference internal" href="#xml.parsers.expat.xmlparser.EndCdataSectionHandler" title="xml.parsers.expat.xmlparser.EndCdataSectionHandler"><code>EndCdataSectionHandler</code></a> are needed to be able to identify the syntactical start and end for CDATA sections.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.EndCdataSectionHandler">
<code>xmlparser.EndCdataSectionHandler()</code> </dt> <dd>
<p>Called at the end of a CDATA section.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.DefaultHandler">
<code>xmlparser.DefaultHandler(data)</code> </dt> <dd>
<p>Called for any characters in the XML document for which no applicable handler has been specified. This means characters that are part of a construct which could be reported, but for which no handler has been supplied.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.DefaultHandlerExpand">
<code>xmlparser.DefaultHandlerExpand(data)</code> </dt> <dd>
<p>This is the same as the <a class="reference internal" href="#xml.parsers.expat.xmlparser.DefaultHandler" title="xml.parsers.expat.xmlparser.DefaultHandler"><code>DefaultHandler()</code></a>, but doesn’t inhibit expansion of internal entities. The entity reference will not be passed to the default handler.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.NotStandaloneHandler">
<code>xmlparser.NotStandaloneHandler()</code> </dt> <dd>
<p>Called if the XML document hasn’t been declared as being a standalone document. This happens when there is an external subset or a reference to a parameter entity, but the XML declaration does not set standalone to <code>yes</code> in an XML declaration. If this handler returns <code>0</code>, then the parser will raise an <code>XML_ERROR_NOT_STANDALONE</code> error. If this handler is not set, no exception is raised by the parser for this condition.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="xml.parsers.expat.xmlparser.ExternalEntityRefHandler">
<code>xmlparser.ExternalEntityRefHandler(context, base, systemId, publicId)</code> </dt> <dd>
<p>Called for references to external entities. <em>base</em> is the current base, as set by a previous call to <a class="reference internal" href="#xml.parsers.expat.xmlparser.SetBase" title="xml.parsers.expat.xmlparser.SetBase"><code>SetBase()</code></a>. The public and system identifiers, <em>systemId</em> and <em>publicId</em>, are strings if given; if the public identifier is not given, <em>publicId</em> will be <code>None</code>. The <em>context</em> value is opaque and should only be used as described below.</p> <p>For external entities to be parsed, this handler must be implemented. It is responsible for creating the sub-parser using <code>ExternalEntityParserCreate(context)</code>, initializing it with the appropriate callbacks, and parsing the entity. This handler should return an integer; if it returns <code>0</code>, the parser will raise an <code>XML_ERROR_EXTERNAL_ENTITY_HANDLING</code> error, otherwise parsing will continue.</p> <p>If this handler is not provided, external entities are reported by the <a class="reference internal" href="#xml.parsers.expat.xmlparser.DefaultHandler" title="xml.parsers.expat.xmlparser.DefaultHandler"><code>DefaultHandler</code></a> callback, if provided.</p> </dd>
</dl> </section> <section id="expaterror-exceptions"> <span id="expaterror-objects"></span><h2>ExpatError Exceptions</h2> <p><a class="reference internal" href="#xml.parsers.expat.ExpatError" title="xml.parsers.expat.ExpatError"><code>ExpatError</code></a> exceptions have a number of interesting attributes:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.ExpatError.code">
<code>ExpatError.code</code> </dt> <dd>
<p>Expat’s internal error number for the specific error. The <a class="reference internal" href="#xml.parsers.expat.errors.messages" title="xml.parsers.expat.errors.messages"><code>errors.messages</code></a> dictionary maps these error numbers to Expat’s error messages. For example:</p> <pre data-language="python">from xml.parsers.expat import ParserCreate, ExpatError, errors

p = ParserCreate()
try:
    p.Parse(some_xml_document)
except ExpatError as err:
    print("Error:", errors.messages[err.code])
</pre> <p>The <a class="reference internal" href="#module-xml.parsers.expat.errors" title="xml.parsers.expat.errors"><code>errors</code></a> module also provides error message constants and a dictionary <a class="reference internal" href="#xml.parsers.expat.errors.codes" title="xml.parsers.expat.errors.codes"><code>codes</code></a> mapping these messages back to the error codes, see below.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.ExpatError.lineno">
<code>ExpatError.lineno</code> </dt> <dd>
<p>Line number on which the error was detected. The first line is numbered <code>1</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="xml.parsers.expat.ExpatError.offset">
<code>ExpatError.offset</code> </dt> <dd>
<p>Character offset into the line where the error occurred. The first column is numbered <code>0</code>.</p> </dd>
</dl> </section> <section id="example"> <span id="expat-example"></span><h2>Example</h2> <p>The following program defines three handlers that just print out their arguments.</p> <pre data-language="python">import xml.parsers.expat

# 3 handler functions
def start_element(name, attrs):
    print('Start element:', name, attrs)
def end_element(name):
    print('End element:', name)
def char_data(data):
    print('Character data:', repr(data))

p = xml.parsers.expat.ParserCreate()

p.StartElementHandler = start_element
p.EndElementHandler = end_element
p.CharacterDataHandler = char_data

p.Parse("""&lt;?xml version="1.0"?&gt;
&lt;parent id="top"&gt;&lt;child1 name="paul"&gt;Text goes here&lt;/child1&gt;
&lt;child2 name="fred"&gt;More text&lt;/child2&gt;
&lt;/parent&gt;""", 1)
</pre> <p>The output from this program is:</p> <pre data-language="python">Start element: parent {'id': 'top'}
Start element: child1 {'name': 'paul'}
Character data: 'Text goes here'
End element: child1
Character data: '\n'
Start element: child2 {'name': 'fred'}
Character data: 'More text'
End element: child2
Character data: '\n'
End element: parent
</pre> </section> <section id="module-xml.parsers.expat.model"> <span id="content-model-descriptions"></span><span id="expat-content-models"></span><h2>Content Model Descriptions</h2> <p>Content models are described using nested tuples. Each tuple contains four values: the type, the quantifier, the name, and a tuple of children. Children are simply additional content model descriptions.</p> <p>The values of the first two fields are constants defined in the <a class="reference internal" href="#module-xml.parsers.expat.model" title="xml.parsers.expat.model"><code>xml.parsers.expat.model</code></a> module. These constants can be collected in two groups: the model type group and the quantifier group.</p> <p>The constants in the model type group are:</p> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">xml.parsers.expat.model.</span><span class="sig-name descname">XML_CTYPE_ANY</span>
</dt> <dd>
<p>The element named by the model name was declared to have a content model of <code>ANY</code>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">xml.parsers.expat.model.</span><span class="sig-name descname">XML_CTYPE_CHOICE</span>
</dt> <dd>
<p>The named element allows a choice from a number of options; this is used for content models such as <code>(A | B | C)</code>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">xml.parsers.expat.model.</span><span class="sig-name descname">XML_CTYPE_EMPTY</span>
</dt> <dd>
<p>Elements which are declared to be <code>EMPTY</code> have this model type.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">xml.parsers.expat.model.</span><span class="sig-name descname">XML_CTYPE_MIXED</span>
</dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">xml.parsers.expat.model.</span><span class="sig-name descname">XML_CTYPE_NAME</span>
</dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">xml.parsers.expat.model.</span><span class="sig-name descname">XML_CTYPE_SEQ</span>
</dt> <dd>
<p>Models which represent a series of models which follow one after the other are indicated with this model type. This is used for models such as <code>(A, B, C)</code>.</p> </dd>
</dl> <p>The constants in the quantifier group are:</p> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">xml.parsers.expat.model.</span><span class="sig-name descname">XML_CQUANT_NONE</span>
</dt> <dd>
<p>No modifier is given, so it can appear exactly once, as for <code>A</code>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">xml.parsers.expat.model.</span><span class="sig-name descname">XML_CQUANT_OPT</span>
</dt> <dd>
<p>The model is optional: it can appear once or not at all, as for <code>A?</code>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">xml.parsers.expat.model.</span><span class="sig-name descname">XML_CQUANT_PLUS</span>
</dt> <dd>
<p>The model must occur one or more times (like <code>A+</code>).</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-prename descclassname">xml.parsers.expat.model.</span><span class="sig-name descname">XML_CQUANT_REP</span>
</dt> <dd>
<p>The model must occur zero or more times, as for <code>A*</code>.</p> </dd>
</dl> </section> <section id="module-xml.parsers.expat.errors"> <span id="expat-error-constants"></span><span id="expat-errors"></span><h2>Expat error constants</h2> <p>The following constants are provided in the <a class="reference internal" href="#module-xml.parsers.expat.errors" title="xml.parsers.expat.errors"><code>xml.parsers.expat.errors</code></a> module. These constants are useful in interpreting some of the attributes of the <code>ExpatError</code> exception objects raised when an error has occurred. Since for backwards compatibility reasons, the constants’ value is the error <em>message</em> and not the numeric error <em>code</em>, you do this by comparing its <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code>code</code></a> attribute with <code>errors.codes[errors.XML_ERROR_<em>CONSTANT_NAME</em>]</code>.</p> <p>The <code>errors</code> module has the following attributes:</p> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.codes">
<code>xml.parsers.expat.errors.codes</code> </dt> <dd>
<p>A dictionary mapping string descriptions to their error codes.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.messages">
<code>xml.parsers.expat.errors.messages</code> </dt> <dd>
<p>A dictionary mapping numeric error codes to their string descriptions.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_ASYNC_ENTITY">
<code>xml.parsers.expat.errors.XML_ERROR_ASYNC_ENTITY</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF">
<code>xml.parsers.expat.errors.XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF</code> </dt> <dd>
<p>An entity reference in an attribute value referred to an external entity instead of an internal entity.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_BAD_CHAR_REF">
<code>xml.parsers.expat.errors.XML_ERROR_BAD_CHAR_REF</code> </dt> <dd>
<p>A character reference referred to a character which is illegal in XML (for example, character <code>0</code>, or ‘<code>&amp;#0;</code>’).</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_BINARY_ENTITY_REF">
<code>xml.parsers.expat.errors.XML_ERROR_BINARY_ENTITY_REF</code> </dt> <dd>
<p>An entity reference referred to an entity which was declared with a notation, so cannot be parsed.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_DUPLICATE_ATTRIBUTE">
<code>xml.parsers.expat.errors.XML_ERROR_DUPLICATE_ATTRIBUTE</code> </dt> <dd>
<p>An attribute was used more than once in a start tag.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_INCORRECT_ENCODING">
<code>xml.parsers.expat.errors.XML_ERROR_INCORRECT_ENCODING</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_INVALID_TOKEN">
<code>xml.parsers.expat.errors.XML_ERROR_INVALID_TOKEN</code> </dt> <dd>
<p>Raised when an input byte could not properly be assigned to a character; for example, a NUL byte (value <code>0</code>) in a UTF-8 input stream.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_JUNK_AFTER_DOC_ELEMENT">
<code>xml.parsers.expat.errors.XML_ERROR_JUNK_AFTER_DOC_ELEMENT</code> </dt> <dd>
<p>Something other than whitespace occurred after the document element.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_MISPLACED_XML_PI">
<code>xml.parsers.expat.errors.XML_ERROR_MISPLACED_XML_PI</code> </dt> <dd>
<p>An XML declaration was found somewhere other than the start of the input data.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_NO_ELEMENTS">
<code>xml.parsers.expat.errors.XML_ERROR_NO_ELEMENTS</code> </dt> <dd>
<p>The document contains no elements (XML requires all documents to contain exactly one top-level element)..</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_NO_MEMORY">
<code>xml.parsers.expat.errors.XML_ERROR_NO_MEMORY</code> </dt> <dd>
<p>Expat was not able to allocate memory internally.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_PARAM_ENTITY_REF">
<code>xml.parsers.expat.errors.XML_ERROR_PARAM_ENTITY_REF</code> </dt> <dd>
<p>A parameter entity reference was found where it was not allowed.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_PARTIAL_CHAR">
<code>xml.parsers.expat.errors.XML_ERROR_PARTIAL_CHAR</code> </dt> <dd>
<p>An incomplete character was found in the input.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_RECURSIVE_ENTITY_REF">
<code>xml.parsers.expat.errors.XML_ERROR_RECURSIVE_ENTITY_REF</code> </dt> <dd>
<p>An entity reference contained another reference to the same entity; possibly via a different name, and possibly indirectly.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_SYNTAX">
<code>xml.parsers.expat.errors.XML_ERROR_SYNTAX</code> </dt> <dd>
<p>Some unspecified syntax error was encountered.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_TAG_MISMATCH">
<code>xml.parsers.expat.errors.XML_ERROR_TAG_MISMATCH</code> </dt> <dd>
<p>An end tag did not match the innermost open start tag.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_UNCLOSED_TOKEN">
<code>xml.parsers.expat.errors.XML_ERROR_UNCLOSED_TOKEN</code> </dt> <dd>
<p>Some token (such as a start tag) was not closed before the end of the stream or the next token was encountered.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_UNDEFINED_ENTITY">
<code>xml.parsers.expat.errors.XML_ERROR_UNDEFINED_ENTITY</code> </dt> <dd>
<p>A reference was made to an entity which was not defined.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_UNKNOWN_ENCODING">
<code>xml.parsers.expat.errors.XML_ERROR_UNKNOWN_ENCODING</code> </dt> <dd>
<p>The document encoding is not supported by Expat.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_UNCLOSED_CDATA_SECTION">
<code>xml.parsers.expat.errors.XML_ERROR_UNCLOSED_CDATA_SECTION</code> </dt> <dd>
<p>A CDATA marked section was not closed.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_EXTERNAL_ENTITY_HANDLING">
<code>xml.parsers.expat.errors.XML_ERROR_EXTERNAL_ENTITY_HANDLING</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_NOT_STANDALONE">
<code>xml.parsers.expat.errors.XML_ERROR_NOT_STANDALONE</code> </dt> <dd>
<p>The parser determined that the document was not “standalone” though it declared itself to be in the XML declaration, and the <code>NotStandaloneHandler</code> was set and returned <code>0</code>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_UNEXPECTED_STATE">
<code>xml.parsers.expat.errors.XML_ERROR_UNEXPECTED_STATE</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_ENTITY_DECLARED_IN_PE">
<code>xml.parsers.expat.errors.XML_ERROR_ENTITY_DECLARED_IN_PE</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_FEATURE_REQUIRES_XML_DTD">
<code>xml.parsers.expat.errors.XML_ERROR_FEATURE_REQUIRES_XML_DTD</code> </dt> <dd>
<p>An operation was requested that requires DTD support to be compiled in, but Expat was configured without DTD support. This should never be reported by a standard build of the <a class="reference internal" href="#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code>xml.parsers.expat</code></a> module.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING">
<code>xml.parsers.expat.errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</code> </dt> <dd>
<p>A behavioral change was requested after parsing started that can only be changed before parsing has started. This is (currently) only raised by <code>UseForeignDTD()</code>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_UNBOUND_PREFIX">
<code>xml.parsers.expat.errors.XML_ERROR_UNBOUND_PREFIX</code> </dt> <dd>
<p>An undeclared prefix was found when namespace processing was enabled.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_UNDECLARING_PREFIX">
<code>xml.parsers.expat.errors.XML_ERROR_UNDECLARING_PREFIX</code> </dt> <dd>
<p>The document attempted to remove the namespace declaration associated with a prefix.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_INCOMPLETE_PE">
<code>xml.parsers.expat.errors.XML_ERROR_INCOMPLETE_PE</code> </dt> <dd>
<p>A parameter entity contained incomplete markup.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_XML_DECL">
<code>xml.parsers.expat.errors.XML_ERROR_XML_DECL</code> </dt> <dd>
<p>The document contained no document element at all.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_TEXT_DECL">
<code>xml.parsers.expat.errors.XML_ERROR_TEXT_DECL</code> </dt> <dd>
<p>There was an error parsing a text declaration in an external entity.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_PUBLICID">
<code>xml.parsers.expat.errors.XML_ERROR_PUBLICID</code> </dt> <dd>
<p>Characters were found in the public id that are not allowed.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_SUSPENDED">
<code>xml.parsers.expat.errors.XML_ERROR_SUSPENDED</code> </dt> <dd>
<p>The requested operation was made on a suspended parser, but isn’t allowed. This includes attempts to provide additional input or to stop the parser.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_NOT_SUSPENDED">
<code>xml.parsers.expat.errors.XML_ERROR_NOT_SUSPENDED</code> </dt> <dd>
<p>An attempt to resume the parser was made when the parser had not been suspended.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_ABORTED">
<code>xml.parsers.expat.errors.XML_ERROR_ABORTED</code> </dt> <dd>
<p>This should not be reported to Python applications.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_FINISHED">
<code>xml.parsers.expat.errors.XML_ERROR_FINISHED</code> </dt> <dd>
<p>The requested operation was made on a parser which was finished parsing input, but isn’t allowed. This includes attempts to provide additional input or to stop the parser.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_SUSPEND_PE">
<code>xml.parsers.expat.errors.XML_ERROR_SUSPEND_PE</code> </dt> <dd></dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_RESERVED_PREFIX_XML">
<code>xml.parsers.expat.errors.XML_ERROR_RESERVED_PREFIX_XML</code> </dt> <dd>
<p>An attempt was made to undeclare reserved namespace prefix <code>xml</code> or to bind it to another namespace URI.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_RESERVED_PREFIX_XMLNS">
<code>xml.parsers.expat.errors.XML_ERROR_RESERVED_PREFIX_XMLNS</code> </dt> <dd>
<p>An attempt was made to declare or undeclare reserved namespace prefix <code>xmlns</code>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_RESERVED_NAMESPACE_URI">
<code>xml.parsers.expat.errors.XML_ERROR_RESERVED_NAMESPACE_URI</code> </dt> <dd>
<p>An attempt was made to bind the URI of one the reserved namespace prefixes <code>xml</code> and <code>xmlns</code> to another namespace prefix.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_INVALID_ARGUMENT">
<code>xml.parsers.expat.errors.XML_ERROR_INVALID_ARGUMENT</code> </dt> <dd>
<p>This should not be reported to Python applications.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_NO_BUFFER">
<code>xml.parsers.expat.errors.XML_ERROR_NO_BUFFER</code> </dt> <dd>
<p>This should not be reported to Python applications.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="xml.parsers.expat.errors.XML_ERROR_AMPLIFICATION_LIMIT_BREACH">
<code>xml.parsers.expat.errors.XML_ERROR_AMPLIFICATION_LIMIT_BREACH</code> </dt> <dd>
<p>The limit on input amplification factor (from DTD and entities) has been breached.</p> </dd>
</dl> <h4 class="rubric">Footnotes</h4> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id3" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span> <p>The encoding string included in XML output should conform to the appropriate standards. For example, “UTF-8” is valid, but “UTF8” is not. See <a class="reference external" href="https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl">https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl</a> and <a class="reference external" href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">https://www.iana.org/assignments/character-sets/character-sets.xhtml</a>.</p> </aside> </aside> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/pyexpat.html" class="_attribution-link">https://docs.python.org/3.13/library/pyexpat.html</a>
  </p>
</div>
