 <span id="pathlib-object-oriented-filesystem-paths"></span><h1>pathlib — Object-oriented filesystem paths</h1> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.4.</span></p> </div> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/pathlib/">Lib/pathlib/</a></p>  <p>This module offers classes representing filesystem paths with semantics appropriate for different operating systems. Path classes are divided between <a class="reference internal" href="#pure-paths"><span class="std std-ref">pure paths</span></a>, which provide purely computational operations without I/O, and <a class="reference internal" href="#concrete-paths"><span class="std std-ref">concrete paths</span></a>, which inherit from pure paths but also provide I/O operations.</p> <img alt="Inheritance diagram showing the classes available in pathlib. The most basic class is PurePath, which has three direct subclasses: PurePosixPath, PureWindowsPath, and Path. Further to these four classes, there are two classes that use multiple inheritance: PosixPath subclasses PurePosixPath and Path, and WindowsPath subclasses PureWindowsPath and Path." class="invert-in-dark-mode align-center" src="data:image/png;base64,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"> <p>If you’ve never used this module before or just aren’t sure which class is right for your task, <a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code>Path</code></a> is most likely what you need. It instantiates a <a class="reference internal" href="#concrete-paths"><span class="std std-ref">concrete path</span></a> for the platform the code is running on.</p> <p>Pure paths are useful in some special cases; for example:</p> <ol class="arabic simple"> <li>If you want to manipulate Windows paths on a Unix machine (or vice versa). You cannot instantiate a <a class="reference internal" href="#pathlib.WindowsPath" title="pathlib.WindowsPath"><code>WindowsPath</code></a> when running on Unix, but you can instantiate <a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code>PureWindowsPath</code></a>.</li> <li>You want to make sure that your code only manipulates paths without actually accessing the OS. In this case, instantiating one of the pure classes may be useful since those simply don’t have any OS-accessing operations.</li> </ol> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0428/"><strong>PEP 428</strong></a>: The pathlib module – object-oriented filesystem paths.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>For low-level path manipulation on strings, you can also use the <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a> module.</p> </div> <section id="basic-use"> <h2>Basic use</h2> <p>Importing the main class:</p> <pre data-language="python">&gt;&gt;&gt; from pathlib import Path
</pre> <p>Listing subdirectories:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('.')
&gt;&gt;&gt; [x for x in p.iterdir() if x.is_dir()]
[PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'),
 PosixPath('__pycache__'), PosixPath('build')]
</pre> <p>Listing Python source files in this directory tree:</p> <pre data-language="python">&gt;&gt;&gt; list(p.glob('**/*.py'))
[PosixPath('test_pathlib.py'), PosixPath('setup.py'),
 PosixPath('pathlib.py'), PosixPath('docs/conf.py'),
 PosixPath('build/lib/pathlib.py')]
</pre> <p>Navigating inside a directory tree:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('/etc')
&gt;&gt;&gt; q = p / 'init.d' / 'reboot'
&gt;&gt;&gt; q
PosixPath('/etc/init.d/reboot')
&gt;&gt;&gt; q.resolve()
PosixPath('/etc/rc.d/init.d/halt')
</pre> <p>Querying path properties:</p> <pre data-language="python">&gt;&gt;&gt; q.exists()
True
&gt;&gt;&gt; q.is_dir()
False
</pre> <p>Opening a file:</p> <pre data-language="python">&gt;&gt;&gt; with q.open() as f: f.readline()
...
'#!/bin/bash\n'
</pre> </section> <section id="exceptions"> <h2>Exceptions</h2> <dl class="py exception"> <dt class="sig sig-object py" id="pathlib.UnsupportedOperation">
<code>exception pathlib.UnsupportedOperation</code> </dt> <dd>
<p>An exception inheriting <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a> that is raised when an unsupported operation is called on a path object.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> </section> <section id="pure-paths"> <span id="id1"></span><h2>Pure paths</h2> <p>Pure path objects provide path-handling operations which don’t actually access a filesystem. There are three ways to access these classes, which we also call <em>flavours</em>:</p> <dl class="py class"> <dt class="sig sig-object py" id="pathlib.PurePath">
<code>class pathlib.PurePath(*pathsegments)</code> </dt> <dd>
<p>A generic class that represents the system’s path flavour (instantiating it creates either a <a class="reference internal" href="#pathlib.PurePosixPath" title="pathlib.PurePosixPath"><code>PurePosixPath</code></a> or a <a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code>PureWindowsPath</code></a>):</p> <pre data-language="python">&gt;&gt;&gt; PurePath('setup.py')      # Running on a Unix machine
PurePosixPath('setup.py')
</pre> <p>Each element of <em>pathsegments</em> can be either a string representing a path segment, or an object implementing the <a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> interface where the <a class="reference internal" href="os.html#os.PathLike.__fspath__" title="os.PathLike.__fspath__"><code>__fspath__()</code></a> method returns a string, such as another path object:</p> <pre data-language="python">&gt;&gt;&gt; PurePath('foo', 'some/path', 'bar')
PurePosixPath('foo/some/path/bar')
&gt;&gt;&gt; PurePath(Path('foo'), Path('bar'))
PurePosixPath('foo/bar')
</pre> <p>When <em>pathsegments</em> is empty, the current directory is assumed:</p> <pre data-language="python">&gt;&gt;&gt; PurePath()
PurePosixPath('.')
</pre> <p>If a segment is an absolute path, all previous segments are ignored (like <a class="reference internal" href="os.path.html#os.path.join" title="os.path.join"><code>os.path.join()</code></a>):</p> <pre data-language="python">&gt;&gt;&gt; PurePath('/etc', '/usr', 'lib64')
PurePosixPath('/usr/lib64')
&gt;&gt;&gt; PureWindowsPath('c:/Windows', 'd:bar')
PureWindowsPath('d:bar')
</pre> <p>On Windows, the drive is not reset when a rooted relative path segment (e.g., <code>r'\foo'</code>) is encountered:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('c:/Windows', '/Program Files')
PureWindowsPath('c:/Program Files')
</pre> <p>Spurious slashes and single dots are collapsed, but double dots (<code>'..'</code>) and leading double slashes (<code>'//'</code>) are not, since this would change the meaning of a path for various reasons (e.g. symbolic links, UNC paths):</p> <pre data-language="python">&gt;&gt;&gt; PurePath('foo//bar')
PurePosixPath('foo/bar')
&gt;&gt;&gt; PurePath('//foo/bar')
PurePosixPath('//foo/bar')
&gt;&gt;&gt; PurePath('foo/./bar')
PurePosixPath('foo/bar')
&gt;&gt;&gt; PurePath('foo/../bar')
PurePosixPath('foo/../bar')
</pre> <p>(a naïve approach would make <code>PurePosixPath('foo/../bar')</code> equivalent to <code>PurePosixPath('bar')</code>, which is wrong if <code>foo</code> is a symbolic link to another directory)</p> <p>Pure path objects implement the <a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> interface, allowing them to be used anywhere the interface is accepted.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Added support for the <a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> interface.</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="pathlib.PurePosixPath">
<code>class pathlib.PurePosixPath(*pathsegments)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>, this path flavour represents non-Windows filesystem paths:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('/etc/hosts')
PurePosixPath('/etc/hosts')
</pre> <p><em>pathsegments</em> is specified similarly to <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="pathlib.PureWindowsPath">
<code>class pathlib.PureWindowsPath(*pathsegments)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>, this path flavour represents Windows filesystem paths, including <a class="reference external" href="https://en.wikipedia.org/wiki/Path_(computing)#UNC">UNC paths</a>:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('c:/', 'Users', 'Ximénez')
PureWindowsPath('c:/Users/Ximénez')
&gt;&gt;&gt; PureWindowsPath('//server/share/file')
PureWindowsPath('//server/share/file')
</pre> <p><em>pathsegments</em> is specified similarly to <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>.</p> </dd>
</dl> <p>Regardless of the system you’re running on, you can instantiate all of these classes, since they don’t provide any operation that does system calls.</p> <section id="general-properties"> <h3>General properties</h3> <p>Paths are immutable and <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>. Paths of a same flavour are comparable and orderable. These properties respect the flavour’s case-folding semantics:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('foo') == PurePosixPath('FOO')
False
&gt;&gt;&gt; PureWindowsPath('foo') == PureWindowsPath('FOO')
True
&gt;&gt;&gt; PureWindowsPath('FOO') in { PureWindowsPath('foo') }
True
&gt;&gt;&gt; PureWindowsPath('C:') &lt; PureWindowsPath('d:')
True
</pre> <p>Paths of a different flavour compare unequal and cannot be ordered:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('foo') == PurePosixPath('foo')
False
&gt;&gt;&gt; PureWindowsPath('foo') &lt; PurePosixPath('foo')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: '&lt;' not supported between instances of 'PureWindowsPath' and 'PurePosixPath'
</pre> </section> <section id="operators"> <h3>Operators</h3> <p>The slash operator helps create child paths, like <a class="reference internal" href="os.path.html#os.path.join" title="os.path.join"><code>os.path.join()</code></a>. If the argument is an absolute path, the previous path is ignored. On Windows, the drive is not reset when the argument is a rooted relative path (e.g., <code>r'\foo'</code>):</p> <pre data-language="python">&gt;&gt;&gt; p = PurePath('/etc')
&gt;&gt;&gt; p
PurePosixPath('/etc')
&gt;&gt;&gt; p / 'init.d' / 'apache2'
PurePosixPath('/etc/init.d/apache2')
&gt;&gt;&gt; q = PurePath('bin')
&gt;&gt;&gt; '/usr' / q
PurePosixPath('/usr/bin')
&gt;&gt;&gt; p / '/an_absolute_path'
PurePosixPath('/an_absolute_path')
&gt;&gt;&gt; PureWindowsPath('c:/Windows', '/Program Files')
PureWindowsPath('c:/Program Files')
</pre> <p>A path object can be used anywhere an object implementing <a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> is accepted:</p> <pre data-language="python">&gt;&gt;&gt; import os
&gt;&gt;&gt; p = PurePath('/etc')
&gt;&gt;&gt; os.fspath(p)
'/etc'
</pre> <p>The string representation of a path is the raw filesystem path itself (in native form, e.g. with backslashes under Windows), which you can pass to any function taking a file path as a string:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePath('/etc')
&gt;&gt;&gt; str(p)
'/etc'
&gt;&gt;&gt; p = PureWindowsPath('c:/Program Files')
&gt;&gt;&gt; str(p)
'c:\\Program Files'
</pre> <p>Similarly, calling <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> on a path gives the raw filesystem path as a bytes object, as encoded by <a class="reference internal" href="os.html#os.fsencode" title="os.fsencode"><code>os.fsencode()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; bytes(p)
b'/etc'
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Calling <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> is only recommended under Unix. Under Windows, the unicode form is the canonical representation of filesystem paths.</p> </div> </section> <section id="accessing-individual-parts"> <h3>Accessing individual parts</h3> <p>To access the individual “parts” (components) of a path, use the following property:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.parts">
<code>PurePath.parts</code> </dt> <dd>
<p>A tuple giving access to the path’s various components:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePath('/usr/bin/python3')
&gt;&gt;&gt; p.parts
('/', 'usr', 'bin', 'python3')

&gt;&gt;&gt; p = PureWindowsPath('c:/Program Files/PSF')
&gt;&gt;&gt; p.parts
('c:\\', 'Program Files', 'PSF')
</pre> <p>(note how the drive and local root are regrouped in a single part)</p> </dd>
</dl> </section> <section id="methods-and-properties"> <h3>Methods and properties</h3> <p>Pure paths provide the following methods and properties:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.parser">
<code>PurePath.parser</code> </dt> <dd>
<p>The implementation of the <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a> module used for low-level path parsing and joining: either <code>posixpath</code> or <code>ntpath</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.drive">
<code>PurePath.drive</code> </dt> <dd>
<p>A string representing the drive letter or name, if any:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('c:/Program Files/').drive
'c:'
&gt;&gt;&gt; PureWindowsPath('/Program Files/').drive
''
&gt;&gt;&gt; PurePosixPath('/etc').drive
''
</pre> <p>UNC shares are also considered drives:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('//host/share/foo.txt').drive
'\\\\host\\share'
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.root">
<code>PurePath.root</code> </dt> <dd>
<p>A string representing the (local or global) root, if any:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('c:/Program Files/').root
'\\'
&gt;&gt;&gt; PureWindowsPath('c:Program Files/').root
''
&gt;&gt;&gt; PurePosixPath('/etc').root
'/'
</pre> <p>UNC shares always have a root:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('//host/share').root
'\\'
</pre> <p>If the path starts with more than two successive slashes, <a class="reference internal" href="#pathlib.PurePosixPath" title="pathlib.PurePosixPath"><code>PurePosixPath</code></a> collapses them:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('//etc').root
'//'
&gt;&gt;&gt; PurePosixPath('///etc').root
'/'
&gt;&gt;&gt; PurePosixPath('////etc').root
'/'
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This behavior conforms to <em>The Open Group Base Specifications Issue 6</em>, paragraph <a class="reference external" href="https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap04.html#tag_04_11">4.11 Pathname Resolution</a>:</p> <p><em>“A pathname that begins with two successive slashes may be interpreted in an implementation-defined manner, although more than two leading slashes shall be treated as a single slash.”</em></p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.anchor">
<code>PurePath.anchor</code> </dt> <dd>
<p>The concatenation of the drive and root:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('c:/Program Files/').anchor
'c:\\'
&gt;&gt;&gt; PureWindowsPath('c:Program Files/').anchor
'c:'
&gt;&gt;&gt; PurePosixPath('/etc').anchor
'/'
&gt;&gt;&gt; PureWindowsPath('//host/share').anchor
'\\\\host\\share\\'
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.parents">
<code>PurePath.parents</code> </dt> <dd>
<p>An immutable sequence providing access to the logical ancestors of the path:</p> <pre data-language="python">&gt;&gt;&gt; p = PureWindowsPath('c:/foo/bar/setup.py')
&gt;&gt;&gt; p.parents[0]
PureWindowsPath('c:/foo/bar')
&gt;&gt;&gt; p.parents[1]
PureWindowsPath('c:/foo')
&gt;&gt;&gt; p.parents[2]
PureWindowsPath('c:/')
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The parents sequence now supports <a class="reference internal" href="../glossary.html#term-slice"><span class="xref std std-term">slices</span></a> and negative index values.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.parent">
<code>PurePath.parent</code> </dt> <dd>
<p>The logical parent of the path:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePosixPath('/a/b/c/d')
&gt;&gt;&gt; p.parent
PurePosixPath('/a/b/c')
</pre> <p>You cannot go past an anchor, or empty path:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePosixPath('/')
&gt;&gt;&gt; p.parent
PurePosixPath('/')
&gt;&gt;&gt; p = PurePosixPath('.')
&gt;&gt;&gt; p.parent
PurePosixPath('.')
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This is a purely lexical operation, hence the following behaviour:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePosixPath('foo/..')
&gt;&gt;&gt; p.parent
PurePosixPath('foo')
</pre> <p>If you want to walk an arbitrary filesystem path upwards, it is recommended to first call <a class="reference internal" href="#pathlib.Path.resolve" title="pathlib.Path.resolve"><code>Path.resolve()</code></a> so as to resolve symlinks and eliminate <code>".."</code> components.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.name">
<code>PurePath.name</code> </dt> <dd>
<p>A string representing the final path component, excluding the drive and root, if any:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('my/library/setup.py').name
'setup.py'
</pre> <p>UNC drive names are not considered:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('//some/share/setup.py').name
'setup.py'
&gt;&gt;&gt; PureWindowsPath('//some/share').name
''
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.suffix">
<code>PurePath.suffix</code> </dt> <dd>
<p>The last dot-separated portion of the final component, if any:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('my/library/setup.py').suffix
'.py'
&gt;&gt;&gt; PurePosixPath('my/library.tar.gz').suffix
'.gz'
&gt;&gt;&gt; PurePosixPath('my/library').suffix
''
</pre> <p>This is commonly called the file extension.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.suffixes">
<code>PurePath.suffixes</code> </dt> <dd>
<p>A list of the path’s suffixes, often called file extensions:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('my/library.tar.gar').suffixes
['.tar', '.gar']
&gt;&gt;&gt; PurePosixPath('my/library.tar.gz').suffixes
['.tar', '.gz']
&gt;&gt;&gt; PurePosixPath('my/library').suffixes
[]
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="pathlib.PurePath.stem">
<code>PurePath.stem</code> </dt> <dd>
<p>The final path component, without its suffix:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('my/library.tar.gz').stem
'library.tar'
&gt;&gt;&gt; PurePosixPath('my/library.tar').stem
'library'
&gt;&gt;&gt; PurePosixPath('my/library').stem
'library'
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.as_posix">
<code>PurePath.as_posix()</code> </dt> <dd>
<p>Return a string representation of the path with forward slashes (<code>/</code>):</p> <pre data-language="python">&gt;&gt;&gt; p = PureWindowsPath('c:\\windows')
&gt;&gt;&gt; str(p)
'c:\\windows'
&gt;&gt;&gt; p.as_posix()
'c:/windows'
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.is_absolute">
<code>PurePath.is_absolute()</code> </dt> <dd>
<p>Return whether the path is absolute or not. A path is considered absolute if it has both a root and (if the flavour allows) a drive:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('/a/b').is_absolute()
True
&gt;&gt;&gt; PurePosixPath('a/b').is_absolute()
False

&gt;&gt;&gt; PureWindowsPath('c:/a/b').is_absolute()
True
&gt;&gt;&gt; PureWindowsPath('/a/b').is_absolute()
False
&gt;&gt;&gt; PureWindowsPath('c:').is_absolute()
False
&gt;&gt;&gt; PureWindowsPath('//some/share').is_absolute()
True
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.is_relative_to">
<code>PurePath.is_relative_to(other)</code> </dt> <dd>
<p>Return whether or not this path is relative to the <em>other</em> path.</p> <pre data-language="python">&gt;&gt;&gt; p = PurePath('/etc/passwd')
&gt;&gt;&gt; p.is_relative_to('/etc')
True
&gt;&gt;&gt; p.is_relative_to('/usr')
False
</pre> <p>This method is string-based; it neither accesses the filesystem nor treats “<code>..</code>” segments specially. The following code is equivalent:</p> <pre data-language="python">&gt;&gt;&gt; u = PurePath('/usr')
&gt;&gt;&gt; u == p or u in p.parents
False
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> <div class="deprecated-removed"> <p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.14: </span>Passing additional arguments is deprecated; if supplied, they are joined with <em>other</em>.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.is_reserved">
<code>PurePath.is_reserved()</code> </dt> <dd>
<p>With <a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code>PureWindowsPath</code></a>, return <code>True</code> if the path is considered reserved under Windows, <code>False</code> otherwise. With <a class="reference internal" href="#pathlib.PurePosixPath" title="pathlib.PurePosixPath"><code>PurePosixPath</code></a>, <code>False</code> is always returned.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Windows path names that contain a colon, or end with a dot or a space, are considered reserved. UNC paths may be reserved.</p> </div> <div class="deprecated-removed"> <p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>This method is deprecated; use <a class="reference internal" href="os.path.html#os.path.isreserved" title="os.path.isreserved"><code>os.path.isreserved()</code></a> to detect reserved paths on Windows.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.joinpath">
<code>PurePath.joinpath(*pathsegments)</code> </dt> <dd>
<p>Calling this method is equivalent to combining the path with each of the given <em>pathsegments</em> in turn:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('/etc').joinpath('passwd')
PurePosixPath('/etc/passwd')
&gt;&gt;&gt; PurePosixPath('/etc').joinpath(PurePosixPath('passwd'))
PurePosixPath('/etc/passwd')
&gt;&gt;&gt; PurePosixPath('/etc').joinpath('init.d', 'apache2')
PurePosixPath('/etc/init.d/apache2')
&gt;&gt;&gt; PureWindowsPath('c:').joinpath('/Program Files')
PureWindowsPath('c:/Program Files')
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.full_match">
<code>PurePath.full_match(pattern, *, case_sensitive=None)</code> </dt> <dd>
<p>Match this path against the provided glob-style pattern. Return <code>True</code> if matching is successful, <code>False</code> otherwise. For example:</p> <pre data-language="python">&gt;&gt;&gt; PurePath('a/b.py').full_match('a/*.py')
True
&gt;&gt;&gt; PurePath('a/b.py').full_match('*.py')
False
&gt;&gt;&gt; PurePath('/a/b/c.py').full_match('/a/**')
True
&gt;&gt;&gt; PurePath('/a/b/c.py').full_match('**/*.py')
True
</pre> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="#pathlib-pattern-language"><span class="std std-ref">Pattern language</span></a> documentation.</p> </div> <p>As with other methods, case-sensitivity follows platform defaults:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('b.py').full_match('*.PY')
False
&gt;&gt;&gt; PureWindowsPath('b.py').full_match('*.PY')
True
</pre> <p>Set <em>case_sensitive</em> to <code>True</code> or <code>False</code> to override this behaviour.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.match">
<code>PurePath.match(pattern, *, case_sensitive=None)</code> </dt> <dd>
<p>Match this path against the provided non-recursive glob-style pattern. Return <code>True</code> if matching is successful, <code>False</code> otherwise.</p> <p>This method is similar to <a class="reference internal" href="#pathlib.PurePath.full_match" title="pathlib.PurePath.full_match"><code>full_match()</code></a>, but empty patterns aren’t allowed (<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised), the recursive wildcard “<code>**</code>” isn’t supported (it acts like non-recursive “<code>*</code>”), and if a relative pattern is provided, then matching is done from the right:</p> <pre data-language="python">&gt;&gt;&gt; PurePath('a/b.py').match('*.py')
True
&gt;&gt;&gt; PurePath('/a/b/c.py').match('b/*.py')
True
&gt;&gt;&gt; PurePath('/a/b/c.py').match('a/*.py')
False
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The <em>pattern</em> parameter accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The <em>case_sensitive</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.relative_to">
<code>PurePath.relative_to(other, walk_up=False)</code> </dt> <dd>
<p>Compute a version of this path relative to the path represented by <em>other</em>. If it’s impossible, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePosixPath('/etc/passwd')
&gt;&gt;&gt; p.relative_to('/')
PurePosixPath('etc/passwd')
&gt;&gt;&gt; p.relative_to('/etc')
PurePosixPath('passwd')
&gt;&gt;&gt; p.relative_to('/usr')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "pathlib.py", line 941, in relative_to
    raise ValueError(error_message.format(str(self), str(formatted)))
ValueError: '/etc/passwd' is not in the subpath of '/usr' OR one path is relative and the other is absolute.
</pre> <p>When <em>walk_up</em> is false (the default), the path must start with <em>other</em>. When the argument is true, <code>..</code> entries may be added to form the relative path. In all other cases, such as the paths referencing different drives, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised.:</p> <pre data-language="python">&gt;&gt;&gt; p.relative_to('/usr', walk_up=True)
PurePosixPath('../etc/passwd')
&gt;&gt;&gt; p.relative_to('foo', walk_up=True)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "pathlib.py", line 941, in relative_to
    raise ValueError(error_message.format(str(self), str(formatted)))
ValueError: '/etc/passwd' is not on the same drive as 'foo' OR one path is relative and the other is absolute.
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This function is part of <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a> and works with strings. It does not check or access the underlying file structure. This can impact the <em>walk_up</em> option as it assumes that no symlinks are present in the path; call <a class="reference internal" href="#pathlib.Path.resolve" title="pathlib.Path.resolve"><code>resolve()</code></a> first if necessary to resolve symlinks.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The <em>walk_up</em> parameter was added (old behavior is the same as <code>walk_up=False</code>).</p> </div> <div class="deprecated-removed"> <p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.14: </span>Passing additional positional arguments is deprecated; if supplied, they are joined with <em>other</em>.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.with_name">
<code>PurePath.with_name(name)</code> </dt> <dd>
<p>Return a new path with the <a class="reference internal" href="#pathlib.PurePath.name" title="pathlib.PurePath.name"><code>name</code></a> changed. If the original path doesn’t have a name, ValueError is raised:</p> <pre data-language="python">&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
&gt;&gt;&gt; p.with_name('setup.py')
PureWindowsPath('c:/Downloads/setup.py')
&gt;&gt;&gt; p = PureWindowsPath('c:/')
&gt;&gt;&gt; p.with_name('setup.py')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/antoine/cpython/default/Lib/pathlib.py", line 751, in with_name
    raise ValueError("%r has an empty name" % (self,))
ValueError: PureWindowsPath('c:/') has an empty name
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.with_stem">
<code>PurePath.with_stem(stem)</code> </dt> <dd>
<p>Return a new path with the <a class="reference internal" href="#pathlib.PurePath.stem" title="pathlib.PurePath.stem"><code>stem</code></a> changed. If the original path doesn’t have a name, ValueError is raised:</p> <pre data-language="python">&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/draft.txt')
&gt;&gt;&gt; p.with_stem('final')
PureWindowsPath('c:/Downloads/final.txt')
&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
&gt;&gt;&gt; p.with_stem('lib')
PureWindowsPath('c:/Downloads/lib.gz')
&gt;&gt;&gt; p = PureWindowsPath('c:/')
&gt;&gt;&gt; p.with_stem('')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/antoine/cpython/default/Lib/pathlib.py", line 861, in with_stem
    return self.with_name(stem + self.suffix)
  File "/home/antoine/cpython/default/Lib/pathlib.py", line 851, in with_name
    raise ValueError("%r has an empty name" % (self,))
ValueError: PureWindowsPath('c:/') has an empty name
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.with_suffix">
<code>PurePath.with_suffix(suffix)</code> </dt> <dd>
<p>Return a new path with the <a class="reference internal" href="#pathlib.PurePath.suffix" title="pathlib.PurePath.suffix"><code>suffix</code></a> changed. If the original path doesn’t have a suffix, the new <em>suffix</em> is appended instead. If the <em>suffix</em> is an empty string, the original suffix is removed:</p> <pre data-language="python">&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
&gt;&gt;&gt; p.with_suffix('.bz2')
PureWindowsPath('c:/Downloads/pathlib.tar.bz2')
&gt;&gt;&gt; p = PureWindowsPath('README')
&gt;&gt;&gt; p.with_suffix('.txt')
PureWindowsPath('README.txt')
&gt;&gt;&gt; p = PureWindowsPath('README.txt')
&gt;&gt;&gt; p.with_suffix('')
PureWindowsPath('README')
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.PurePath.with_segments">
<code>PurePath.with_segments(*pathsegments)</code> </dt> <dd>
<p>Create a new path object of the same type by combining the given <em>pathsegments</em>. This method is called whenever a derivative path is created, such as from <a class="reference internal" href="#pathlib.PurePath.parent" title="pathlib.PurePath.parent"><code>parent</code></a> and <a class="reference internal" href="#pathlib.PurePath.relative_to" title="pathlib.PurePath.relative_to"><code>relative_to()</code></a>. Subclasses may override this method to pass information to derivative paths, for example:</p> <pre data-language="python">from pathlib import PurePosixPath

class MyPath(PurePosixPath):
    def __init__(self, *pathsegments, session_id):
        super().__init__(*pathsegments)
        self.session_id = session_id

    def with_segments(self, *pathsegments):
        return type(self)(*pathsegments, session_id=self.session_id)

etc = MyPath('/etc', session_id=42)
hosts = etc / 'hosts'
print(hosts.session_id)  # 42
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> </section> </section> <section id="concrete-paths"> <span id="id2"></span><h2>Concrete paths</h2> <p>Concrete paths are subclasses of the pure path classes. In addition to operations provided by the latter, they also provide methods to do system calls on path objects. There are three ways to instantiate concrete paths:</p> <dl class="py class"> <dt class="sig sig-object py" id="pathlib.Path">
<code>class pathlib.Path(*pathsegments)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>, this class represents concrete paths of the system’s path flavour (instantiating it creates either a <a class="reference internal" href="#pathlib.PosixPath" title="pathlib.PosixPath"><code>PosixPath</code></a> or a <a class="reference internal" href="#pathlib.WindowsPath" title="pathlib.WindowsPath"><code>WindowsPath</code></a>):</p> <pre data-language="python">&gt;&gt;&gt; Path('setup.py')
PosixPath('setup.py')
</pre> <p><em>pathsegments</em> is specified similarly to <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="pathlib.PosixPath">
<code>class pathlib.PosixPath(*pathsegments)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code>Path</code></a> and <a class="reference internal" href="#pathlib.PurePosixPath" title="pathlib.PurePosixPath"><code>PurePosixPath</code></a>, this class represents concrete non-Windows filesystem paths:</p> <pre data-language="python">&gt;&gt;&gt; PosixPath('/etc/hosts')
PosixPath('/etc/hosts')
</pre> <p><em>pathsegments</em> is specified similarly to <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Raises <a class="reference internal" href="#pathlib.UnsupportedOperation" title="pathlib.UnsupportedOperation"><code>UnsupportedOperation</code></a> on Windows. In previous versions, <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a> was raised instead.</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="pathlib.WindowsPath">
<code>class pathlib.WindowsPath(*pathsegments)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code>Path</code></a> and <a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code>PureWindowsPath</code></a>, this class represents concrete Windows filesystem paths:</p> <pre data-language="python">&gt;&gt;&gt; WindowsPath('c:/', 'Users', 'Ximénez')
WindowsPath('c:/Users/Ximénez')
</pre> <p><em>pathsegments</em> is specified similarly to <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Raises <a class="reference internal" href="#pathlib.UnsupportedOperation" title="pathlib.UnsupportedOperation"><code>UnsupportedOperation</code></a> on non-Windows platforms. In previous versions, <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a> was raised instead.</p> </div> </dd>
</dl> <p>You can only instantiate the class flavour that corresponds to your system (allowing system calls on non-compatible path flavours could lead to bugs or failures in your application):</p> <pre data-language="python">&gt;&gt;&gt; import os
&gt;&gt;&gt; os.name
'posix'
&gt;&gt;&gt; Path('setup.py')
PosixPath('setup.py')
&gt;&gt;&gt; PosixPath('setup.py')
PosixPath('setup.py')
&gt;&gt;&gt; WindowsPath('setup.py')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "pathlib.py", line 798, in __new__
    % (cls.__name__,))
UnsupportedOperation: cannot instantiate 'WindowsPath' on your system
</pre> <p>Some concrete path methods can raise an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> if a system call fails (for example because the path doesn’t exist).</p> <section id="parsing-and-generating-uris"> <h3>Parsing and generating URIs</h3> <p>Concrete path objects can be created from, and represented as, ‘file’ URIs conforming to <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8089.html"><strong>RFC 8089</strong></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>File URIs are not portable across machines with different <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">filesystem encodings</span></a>.</p> </div> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.from_uri">
<code>classmethod Path.from_uri(uri)</code> </dt> <dd>
<p>Return a new path object from parsing a ‘file’ URI. For example:</p> <pre data-language="python">&gt;&gt;&gt; p = Path.from_uri('file:///etc/hosts')
PosixPath('/etc/hosts')
</pre> <p>On Windows, DOS device and UNC paths may be parsed from URIs:</p> <pre data-language="python">&gt;&gt;&gt; p = Path.from_uri('file:///c:/windows')
WindowsPath('c:/windows')
&gt;&gt;&gt; p = Path.from_uri('file://server/share')
WindowsPath('//server/share')
</pre> <p>Several variant forms are supported:</p> <pre data-language="python">&gt;&gt;&gt; p = Path.from_uri('file:////server/share')
WindowsPath('//server/share')
&gt;&gt;&gt; p = Path.from_uri('file://///server/share')
WindowsPath('//server/share')
&gt;&gt;&gt; p = Path.from_uri('file:c:/windows')
WindowsPath('c:/windows')
&gt;&gt;&gt; p = Path.from_uri('file:/c|/windows')
WindowsPath('c:/windows')
</pre> <p><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised if the URI does not start with <code>file:</code>, or the parsed path isn’t absolute.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.13.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.as_uri">
<code>Path.as_uri()</code> </dt> <dd>
<p>Represent the path as a ‘file’ URI. <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised if the path isn’t absolute.</p> <pre data-language="pycon">&gt;&gt;&gt; p = PosixPath('/etc/passwd')
&gt;&gt;&gt; p.as_uri()
'file:///etc/passwd'
&gt;&gt;&gt; p = WindowsPath('c:/Windows')
&gt;&gt;&gt; p.as_uri()
'file:///c:/Windows'
</pre> <p>For historical reasons, this method is also available from <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a> objects. However, its use of <a class="reference internal" href="os.html#os.fsencode" title="os.fsencode"><code>os.fsencode()</code></a> makes it strictly impure.</p> </dd>
</dl> </section> <section id="expanding-and-resolving-paths"> <h3>Expanding and resolving paths</h3> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.home">
<code>classmethod Path.home()</code> </dt> <dd>
<p>Return a new path object representing the user’s home directory (as returned by <a class="reference internal" href="os.path.html#os.path.expanduser" title="os.path.expanduser"><code>os.path.expanduser()</code></a> with <code>~</code> construct). If the home directory can’t be resolved, <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised.</p> <pre data-language="python">&gt;&gt;&gt; Path.home()
PosixPath('/home/antoine')
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.expanduser">
<code>Path.expanduser()</code> </dt> <dd>
<p>Return a new path with expanded <code>~</code> and <code>~user</code> constructs, as returned by <a class="reference internal" href="os.path.html#os.path.expanduser" title="os.path.expanduser"><code>os.path.expanduser()</code></a>. If a home directory can’t be resolved, <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised.</p> <pre data-language="python">&gt;&gt;&gt; p = PosixPath('~/films/Monty Python')
&gt;&gt;&gt; p.expanduser()
PosixPath('/home/eric/films/Monty Python')
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.cwd">
<code>classmethod Path.cwd()</code> </dt> <dd>
<p>Return a new path object representing the current directory (as returned by <a class="reference internal" href="os.html#os.getcwd" title="os.getcwd"><code>os.getcwd()</code></a>):</p> <pre data-language="python">&gt;&gt;&gt; Path.cwd()
PosixPath('/home/antoine/pathlib')
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.absolute">
<code>Path.absolute()</code> </dt> <dd>
<p>Make the path absolute, without normalization or resolving symlinks. Returns a new path object:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('tests')
&gt;&gt;&gt; p
PosixPath('tests')
&gt;&gt;&gt; p.absolute()
PosixPath('/home/antoine/pathlib/tests')
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.resolve">
<code>Path.resolve(strict=False)</code> </dt> <dd>
<p>Make the path absolute, resolving any symlinks. A new path object is returned:</p> <pre data-language="python">&gt;&gt;&gt; p = Path()
&gt;&gt;&gt; p
PosixPath('.')
&gt;&gt;&gt; p.resolve()
PosixPath('/home/antoine/pathlib')
</pre> <p>“<code>..</code>” components are also eliminated (this is the only method to do so):</p> <pre data-language="python">&gt;&gt;&gt; p = Path('docs/../setup.py')
&gt;&gt;&gt; p.resolve()
PosixPath('/home/antoine/pathlib/setup.py')
</pre> <p>If a path doesn’t exist or a symlink loop is encountered, and <em>strict</em> is <code>True</code>, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> is raised. If <em>strict</em> is <code>False</code>, the path is resolved as far as possible and any remainder is appended without checking whether it exists.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>The <em>strict</em> parameter was added (pre-3.6 behavior is strict).</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Symlink loops are treated like other errors: <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> is raised in strict mode, and no exception is raised in non-strict mode. In previous versions, <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised no matter the value of <em>strict</em>.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.readlink">
<code>Path.readlink()</code> </dt> <dd>
<p>Return the path to which the symbolic link points (as returned by <a class="reference internal" href="os.html#os.readlink" title="os.readlink"><code>os.readlink()</code></a>):</p> <pre data-language="python">&gt;&gt;&gt; p = Path('mylink')
&gt;&gt;&gt; p.symlink_to('setup.py')
&gt;&gt;&gt; p.readlink()
PosixPath('setup.py')
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Raises <a class="reference internal" href="#pathlib.UnsupportedOperation" title="pathlib.UnsupportedOperation"><code>UnsupportedOperation</code></a> if <a class="reference internal" href="os.html#os.readlink" title="os.readlink"><code>os.readlink()</code></a> is not available. In previous versions, <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a> was raised.</p> </div> </dd>
</dl> </section> <section id="querying-file-type-and-status"> <h3>Querying file type and status</h3> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span><a class="reference internal" href="#pathlib.Path.exists" title="pathlib.Path.exists"><code>exists()</code></a>, <a class="reference internal" href="#pathlib.Path.is_dir" title="pathlib.Path.is_dir"><code>is_dir()</code></a>, <a class="reference internal" href="#pathlib.Path.is_file" title="pathlib.Path.is_file"><code>is_file()</code></a>, <a class="reference internal" href="#pathlib.Path.is_mount" title="pathlib.Path.is_mount"><code>is_mount()</code></a>, <a class="reference internal" href="#pathlib.Path.is_symlink" title="pathlib.Path.is_symlink"><code>is_symlink()</code></a>, <a class="reference internal" href="#pathlib.Path.is_block_device" title="pathlib.Path.is_block_device"><code>is_block_device()</code></a>, <a class="reference internal" href="#pathlib.Path.is_char_device" title="pathlib.Path.is_char_device"><code>is_char_device()</code></a>, <a class="reference internal" href="#pathlib.Path.is_fifo" title="pathlib.Path.is_fifo"><code>is_fifo()</code></a>, <a class="reference internal" href="#pathlib.Path.is_socket" title="pathlib.Path.is_socket"><code>is_socket()</code></a> now return <code>False</code> instead of raising an exception for paths that contain characters unrepresentable at the OS level.</p> </div> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.stat">
<code>Path.stat(*, follow_symlinks=True)</code> </dt> <dd>
<p>Return an <a class="reference internal" href="os.html#os.stat_result" title="os.stat_result"><code>os.stat_result</code></a> object containing information about this path, like <a class="reference internal" href="os.html#os.stat" title="os.stat"><code>os.stat()</code></a>. The result is looked up at each call to this method.</p> <p>This method normally follows symlinks; to stat a symlink add the argument <code>follow_symlinks=False</code>, or use <a class="reference internal" href="#pathlib.Path.lstat" title="pathlib.Path.lstat"><code>lstat()</code></a>.</p> <pre data-language="python">&gt;&gt;&gt; p = Path('setup.py')
&gt;&gt;&gt; p.stat().st_size
956
&gt;&gt;&gt; p.stat().st_mtime
1327883547.852554
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <em>follow_symlinks</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.lstat">
<code>Path.lstat()</code> </dt> <dd>
<p>Like <a class="reference internal" href="#pathlib.Path.stat" title="pathlib.Path.stat"><code>Path.stat()</code></a> but, if the path points to a symbolic link, return the symbolic link’s information rather than its target’s.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.exists">
<code>Path.exists(*, follow_symlinks=True)</code> </dt> <dd>
<p>Return <code>True</code> if the path points to an existing file or directory.</p> <p>This method normally follows symlinks; to check if a symlink exists, add the argument <code>follow_symlinks=False</code>.</p> <pre data-language="python">&gt;&gt;&gt; Path('.').exists()
True
&gt;&gt;&gt; Path('setup.py').exists()
True
&gt;&gt;&gt; Path('/etc').exists()
True
&gt;&gt;&gt; Path('nonexistentfile').exists()
False
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The <em>follow_symlinks</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.is_file">
<code>Path.is_file(*, follow_symlinks=True)</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a regular file, <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> <p>This method normally follows symlinks; to exclude symlinks, add the argument <code>follow_symlinks=False</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The <em>follow_symlinks</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.is_dir">
<code>Path.is_dir(*, follow_symlinks=True)</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a directory, <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> <p>This method normally follows symlinks; to exclude symlinks to directories, add the argument <code>follow_symlinks=False</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The <em>follow_symlinks</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.is_symlink">
<code>Path.is_symlink()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a symbolic link, <code>False</code> otherwise.</p> <p><code>False</code> is also returned if the path doesn’t exist; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.is_junction">
<code>Path.is_junction()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a junction, and <code>False</code> for any other type of file. Currently only Windows supports junctions.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.is_mount">
<code>Path.is_mount()</code> </dt> <dd>
<p>Return <code>True</code> if the path is a <em class="dfn">mount point</em>: a point in a file system where a different file system has been mounted. On POSIX, the function checks whether <em>path</em>’s parent, <code>path/..</code>, is on a different device than <em>path</em>, or whether <code>path/..</code> and <em>path</em> point to the same i-node on the same device — this should detect mount points for all Unix and POSIX variants. On Windows, a mount point is considered to be a drive letter root (e.g. <code>c:\</code>), a UNC share (e.g. <code>\\server\share</code>), or a mounted filesystem directory.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.7.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Windows support was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.is_socket">
<code>Path.is_socket()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a Unix socket (or a symbolic link pointing to a Unix socket), <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.is_fifo">
<code>Path.is_fifo()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a FIFO (or a symbolic link pointing to a FIFO), <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.is_block_device">
<code>Path.is_block_device()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a block device (or a symbolic link pointing to a block device), <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.is_char_device">
<code>Path.is_char_device()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a character device (or a symbolic link pointing to a character device), <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.samefile">
<code>Path.samefile(other_path)</code> </dt> <dd>
<p>Return whether this path points to the same file as <em>other_path</em>, which can be either a Path object, or a string. The semantics are similar to <a class="reference internal" href="os.path.html#os.path.samefile" title="os.path.samefile"><code>os.path.samefile()</code></a> and <a class="reference internal" href="os.path.html#os.path.samestat" title="os.path.samestat"><code>os.path.samestat()</code></a>.</p> <p>An <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> can be raised if either file cannot be accessed for some reason.</p> <pre data-language="python">&gt;&gt;&gt; p = Path('spam')
&gt;&gt;&gt; q = Path('eggs')
&gt;&gt;&gt; p.samefile(q)
False
&gt;&gt;&gt; p.samefile('spam')
True
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> </section> <section id="reading-and-writing-files"> <h3>Reading and writing files</h3> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.open">
<code>Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)</code> </dt> <dd>
<p>Open the file pointed to by the path, like the built-in <a class="reference internal" href="functions.html#open" title="open"><code>open()</code></a> function does:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('setup.py')
&gt;&gt;&gt; with p.open() as f:
...     f.readline()
...
'#!/usr/bin/env python3\n'
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.read_text">
<code>Path.read_text(encoding=None, errors=None, newline=None)</code> </dt> <dd>
<p>Return the decoded contents of the pointed-to file as a string:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('my_text_file')
&gt;&gt;&gt; p.write_text('Text file contents')
18
&gt;&gt;&gt; p.read_text()
'Text file contents'
</pre> <p>The file is opened and then closed. The optional parameters have the same meaning as in <a class="reference internal" href="functions.html#open" title="open"><code>open()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The <em>newline</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.read_bytes">
<code>Path.read_bytes()</code> </dt> <dd>
<p>Return the binary contents of the pointed-to file as a bytes object:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('my_binary_file')
&gt;&gt;&gt; p.write_bytes(b'Binary file contents')
20
&gt;&gt;&gt; p.read_bytes()
b'Binary file contents'
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.write_text">
<code>Path.write_text(data, encoding=None, errors=None, newline=None)</code> </dt> <dd>
<p>Open the file pointed to in text mode, write <em>data</em> to it, and close the file:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('my_text_file')
&gt;&gt;&gt; p.write_text('Text file contents')
18
&gt;&gt;&gt; p.read_text()
'Text file contents'
</pre> <p>An existing file of the same name is overwritten. The optional parameters have the same meaning as in <a class="reference internal" href="functions.html#open" title="open"><code>open()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <em>newline</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.write_bytes">
<code>Path.write_bytes(data)</code> </dt> <dd>
<p>Open the file pointed to in bytes mode, write <em>data</em> to it, and close the file:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('my_binary_file')
&gt;&gt;&gt; p.write_bytes(b'Binary file contents')
20
&gt;&gt;&gt; p.read_bytes()
b'Binary file contents'
</pre> <p>An existing file of the same name is overwritten.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> </section> <section id="reading-directories"> <h3>Reading directories</h3> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.iterdir">
<code>Path.iterdir()</code> </dt> <dd>
<p>When the path points to a directory, yield path objects of the directory contents:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('docs')
&gt;&gt;&gt; for child in p.iterdir(): child
...
PosixPath('docs/conf.py')
PosixPath('docs/_templates')
PosixPath('docs/make.bat')
PosixPath('docs/index.rst')
PosixPath('docs/_build')
PosixPath('docs/_static')
PosixPath('docs/Makefile')
</pre> <p>The children are yielded in arbitrary order, and the special entries <code>'.'</code> and <code>'..'</code> are not included. If a file is removed from or added to the directory after creating the iterator, it is unspecified whether a path object for that file is included.</p> <p>If the path is not a directory or otherwise inaccessible, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> is raised.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.glob">
<code>Path.glob(pattern, *, case_sensitive=None, recurse_symlinks=False)</code> </dt> <dd>
<p>Glob the given relative <em>pattern</em> in the directory represented by this path, yielding all matching files (of any kind):</p> <pre data-language="python">&gt;&gt;&gt; sorted(Path('.').glob('*.py'))
[PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')]
&gt;&gt;&gt; sorted(Path('.').glob('*/*.py'))
[PosixPath('docs/conf.py')]
&gt;&gt;&gt; sorted(Path('.').glob('**/*.py'))
[PosixPath('build/lib/pathlib.py'),
 PosixPath('docs/conf.py'),
 PosixPath('pathlib.py'),
 PosixPath('setup.py'),
 PosixPath('test_pathlib.py')]
</pre> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="#pathlib-pattern-language"><span class="std std-ref">Pattern language</span></a> documentation.</p> </div> <p>By default, or when the <em>case_sensitive</em> keyword-only argument is set to <code>None</code>, this method matches paths using platform-specific casing rules: typically, case-sensitive on POSIX, and case-insensitive on Windows. Set <em>case_sensitive</em> to <code>True</code> or <code>False</code> to override this behaviour.</p> <p>By default, or when the <em>recurse_symlinks</em> keyword-only argument is set to <code>False</code>, this method follows symlinks except when expanding “<code>**</code>” wildcards. Set <em>recurse_symlinks</em> to <code>True</code> to always follow symlinks.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>pathlib.Path.glob</code> with arguments <code>self</code>, <code>pattern</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The <em>case_sensitive</em> parameter was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The <em>recurse_symlinks</em> parameter was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The <em>pattern</em> parameter accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Any <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> exceptions raised from scanning the filesystem are suppressed. In previous versions, such exceptions are suppressed in many cases, but not all.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.rglob">
<code>Path.rglob(pattern, *, case_sensitive=None, recurse_symlinks=False)</code> </dt> <dd>
<p>Glob the given relative <em>pattern</em> recursively. This is like calling <a class="reference internal" href="#pathlib.Path.glob" title="pathlib.Path.glob"><code>Path.glob()</code></a> with “<code>**/</code>” added in front of the <em>pattern</em>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="#pathlib-pattern-language"><span class="std std-ref">Pattern language</span></a> and <a class="reference internal" href="#pathlib.Path.glob" title="pathlib.Path.glob"><code>Path.glob()</code></a> documentation.</p> </div> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>pathlib.Path.rglob</code> with arguments <code>self</code>, <code>pattern</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>The <em>case_sensitive</em> parameter was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The <em>recurse_symlinks</em> parameter was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The <em>pattern</em> parameter accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.walk">
<code>Path.walk(top_down=True, on_error=None, follow_symlinks=False)</code> </dt> <dd>
<p>Generate the file names in a directory tree by walking the tree either top-down or bottom-up.</p> <p>For each directory in the directory tree rooted at <em>self</em> (including <em>self</em> but excluding ‘.’ and ‘..’), the method yields a 3-tuple of <code>(dirpath, dirnames, filenames)</code>.</p> <p><em>dirpath</em> is a <a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code>Path</code></a> to the directory currently being walked, <em>dirnames</em> is a list of strings for the names of subdirectories in <em>dirpath</em> (excluding <code>'.'</code> and <code>'..'</code>), and <em>filenames</em> is a list of strings for the names of the non-directory files in <em>dirpath</em>. To get a full path (which begins with <em>self</em>) to a file or directory in <em>dirpath</em>, do <code>dirpath / name</code>. Whether or not the lists are sorted is file system-dependent.</p> <p>If the optional argument <em>top_down</em> is true (which is the default), the triple for a directory is generated before the triples for any of its subdirectories (directories are walked top-down). If <em>top_down</em> is false, the triple for a directory is generated after the triples for all of its subdirectories (directories are walked bottom-up). No matter the value of <em>top_down</em>, the list of subdirectories is retrieved before the triples for the directory and its subdirectories are walked.</p> <p>When <em>top_down</em> is true, the caller can modify the <em>dirnames</em> list in-place (for example, using <a class="reference internal" href="../reference/simple_stmts.html#del"><code>del</code></a> or slice assignment), and <a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> will only recurse into the subdirectories whose names remain in <em>dirnames</em>. This can be used to prune the search, or to impose a specific order of visiting, or even to inform <a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> about directories the caller creates or renames before it resumes <a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> again. Modifying <em>dirnames</em> when <em>top_down</em> is false has no effect on the behavior of <a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> since the directories in <em>dirnames</em> have already been generated by the time <em>dirnames</em> is yielded to the caller.</p> <p>By default, errors from <a class="reference internal" href="os.html#os.scandir" title="os.scandir"><code>os.scandir()</code></a> are ignored. If the optional argument <em>on_error</em> is specified, it should be a callable; it will be called with one argument, an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> instance. The callable can handle the error to continue the walk or re-raise it to stop the walk. Note that the filename is available as the <code>filename</code> attribute of the exception object.</p> <p>By default, <a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> does not follow symbolic links, and instead adds them to the <em>filenames</em> list. Set <em>follow_symlinks</em> to true to resolve symlinks and place them in <em>dirnames</em> and <em>filenames</em> as appropriate for their targets, and consequently visit directories pointed to by symlinks (where supported).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Be aware that setting <em>follow_symlinks</em> to true can lead to infinite recursion if a link points to a parent directory of itself. <a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> does not keep track of the directories it has already visited.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> assumes the directories it walks are not modified during execution. For example, if a directory from <em>dirnames</em> has been replaced with a symlink and <em>follow_symlinks</em> is false, <a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> will still try to descend into it. To prevent such behavior, remove directories from <em>dirnames</em> as appropriate.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Unlike <a class="reference internal" href="os.html#os.walk" title="os.walk"><code>os.walk()</code></a>, <a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> lists symlinks to directories in <em>filenames</em> if <em>follow_symlinks</em> is false.</p> </div> <p>This example displays the number of bytes used by all files in each directory, while ignoring <code>__pycache__</code> directories:</p> <pre data-language="python">from pathlib import Path
for root, dirs, files in Path("cpython/Lib/concurrent").walk(on_error=print):
  print(
      root,
      "consumes",
      sum((root / file).stat().st_size for file in files),
      "bytes in",
      len(files),
      "non-directory files"
  )
  if '__pycache__' in dirs:
        dirs.remove('__pycache__')
</pre> <p>This next example is a simple implementation of <a class="reference internal" href="shutil.html#shutil.rmtree" title="shutil.rmtree"><code>shutil.rmtree()</code></a>. Walking the tree bottom-up is essential as <a class="reference internal" href="#pathlib.Path.rmdir" title="pathlib.Path.rmdir"><code>rmdir()</code></a> doesn’t allow deleting a directory before it is empty:</p> <pre data-language="python"># Delete everything reachable from the directory "top".
# CAUTION:  This is dangerous! For example, if top == Path('/'),
# it could delete all of your files.
for root, dirs, files in top.walk(top_down=False):
    for name in files:
        (root / name).unlink()
    for name in dirs:
        (root / name).rmdir()
</pre> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.12.</span></p> </div> </dd>
</dl> </section> <section id="creating-files-and-directories"> <h3>Creating files and directories</h3> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.touch">
<code>Path.touch(mode=0o666, exist_ok=True)</code> </dt> <dd>
<p>Create a file at this given path. If <em>mode</em> is given, it is combined with the process’s <code>umask</code> value to determine the file mode and access flags. If the file already exists, the function succeeds when <em>exist_ok</em> is true (and its modification time is updated to the current time), otherwise <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a> is raised.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="#pathlib.Path.open" title="pathlib.Path.open"><code>open()</code></a>, <a class="reference internal" href="#pathlib.Path.write_text" title="pathlib.Path.write_text"><code>write_text()</code></a> and <a class="reference internal" href="#pathlib.Path.write_bytes" title="pathlib.Path.write_bytes"><code>write_bytes()</code></a> methods are often used to create files.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.mkdir">
<code>Path.mkdir(mode=0o777, parents=False, exist_ok=False)</code> </dt> <dd>
<p>Create a new directory at this given path. If <em>mode</em> is given, it is combined with the process’s <code>umask</code> value to determine the file mode and access flags. If the path already exists, <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a> is raised.</p> <p>If <em>parents</em> is true, any missing parents of this path are created as needed; they are created with the default permissions without taking <em>mode</em> into account (mimicking the POSIX <code>mkdir -p</code> command).</p> <p>If <em>parents</em> is false (the default), a missing parent raises <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code>FileNotFoundError</code></a>.</p> <p>If <em>exist_ok</em> is false (the default), <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a> is raised if the target directory already exists.</p> <p>If <em>exist_ok</em> is true, <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a> will not be raised unless the given path already exists in the file system and is not a directory (same behavior as the POSIX <code>mkdir -p</code> command).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The <em>exist_ok</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.symlink_to">
<code>Path.symlink_to(target, target_is_directory=False)</code> </dt> <dd>
<p>Make this path a symbolic link pointing to <em>target</em>.</p> <p>On Windows, a symlink represents either a file or a directory, and does not morph to the target dynamically. If the target is present, the type of the symlink will be created to match. Otherwise, the symlink will be created as a directory if <em>target_is_directory</em> is true or a file symlink (the default) otherwise. On non-Windows platforms, <em>target_is_directory</em> is ignored.</p> <pre data-language="python">&gt;&gt;&gt; p = Path('mylink')
&gt;&gt;&gt; p.symlink_to('setup.py')
&gt;&gt;&gt; p.resolve()
PosixPath('/home/antoine/pathlib/setup.py')
&gt;&gt;&gt; p.stat().st_size
956
&gt;&gt;&gt; p.lstat().st_size
8
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The order of arguments (link, target) is the reverse of <a class="reference internal" href="os.html#os.symlink" title="os.symlink"><code>os.symlink()</code></a>’s.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Raises <a class="reference internal" href="#pathlib.UnsupportedOperation" title="pathlib.UnsupportedOperation"><code>UnsupportedOperation</code></a> if <a class="reference internal" href="os.html#os.symlink" title="os.symlink"><code>os.symlink()</code></a> is not available. In previous versions, <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a> was raised.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.hardlink_to">
<code>Path.hardlink_to(target)</code> </dt> <dd>
<p>Make this path a hard link to the same file as <em>target</em>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The order of arguments (link, target) is the reverse of <a class="reference internal" href="os.html#os.link" title="os.link"><code>os.link()</code></a>’s.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Raises <a class="reference internal" href="#pathlib.UnsupportedOperation" title="pathlib.UnsupportedOperation"><code>UnsupportedOperation</code></a> if <a class="reference internal" href="os.html#os.link" title="os.link"><code>os.link()</code></a> is not available. In previous versions, <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a> was raised.</p> </div> </dd>
</dl> </section> <section id="renaming-and-deleting"> <h3>Renaming and deleting</h3> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.rename">
<code>Path.rename(target)</code> </dt> <dd>
<p>Rename this file or directory to the given <em>target</em>, and return a new <code>Path</code> instance pointing to <em>target</em>. On Unix, if <em>target</em> exists and is a file, it will be replaced silently if the user has permission. On Windows, if <em>target</em> exists, <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a> will be raised. <em>target</em> can be either a string or another path object:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('foo')
&gt;&gt;&gt; p.open('w').write('some text')
9
&gt;&gt;&gt; target = Path('bar')
&gt;&gt;&gt; p.rename(target)
PosixPath('bar')
&gt;&gt;&gt; target.open().read()
'some text'
</pre> <p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, <em>not</em> the directory of the <code>Path</code> object.</p> <p>It is implemented in terms of <a class="reference internal" href="os.html#os.rename" title="os.rename"><code>os.rename()</code></a> and gives the same guarantees.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added return value, return the new <code>Path</code> instance.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.replace">
<code>Path.replace(target)</code> </dt> <dd>
<p>Rename this file or directory to the given <em>target</em>, and return a new <code>Path</code> instance pointing to <em>target</em>. If <em>target</em> points to an existing file or empty directory, it will be unconditionally replaced.</p> <p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, <em>not</em> the directory of the <code>Path</code> object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added return value, return the new <code>Path</code> instance.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.unlink">
<code>Path.unlink(missing_ok=False)</code> </dt> <dd>
<p>Remove this file or symbolic link. If the path points to a directory, use <a class="reference internal" href="#pathlib.Path.rmdir" title="pathlib.Path.rmdir"><code>Path.rmdir()</code></a> instead.</p> <p>If <em>missing_ok</em> is false (the default), <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code>FileNotFoundError</code></a> is raised if the path does not exist.</p> <p>If <em>missing_ok</em> is true, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code>FileNotFoundError</code></a> exceptions will be ignored (same behavior as the POSIX <code>rm -f</code> command).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>The <em>missing_ok</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.rmdir">
<code>Path.rmdir()</code> </dt> <dd>
<p>Remove this directory. The directory must be empty.</p> </dd>
</dl> </section> <section id="permissions-and-ownership"> <h3>Permissions and ownership</h3> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.owner">
<code>Path.owner(*, follow_symlinks=True)</code> </dt> <dd>
<p>Return the name of the user owning the file. <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> is raised if the file’s user identifier (UID) isn’t found in the system database.</p> <p>This method normally follows symlinks; to get the owner of the symlink, add the argument <code>follow_symlinks=False</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Raises <a class="reference internal" href="#pathlib.UnsupportedOperation" title="pathlib.UnsupportedOperation"><code>UnsupportedOperation</code></a> if the <a class="reference internal" href="pwd.html#module-pwd" title="pwd: The password database (getpwnam() and friends). (Unix)"><code>pwd</code></a> module is not available. In earlier versions, <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a> was raised.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The <em>follow_symlinks</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.group">
<code>Path.group(*, follow_symlinks=True)</code> </dt> <dd>
<p>Return the name of the group owning the file. <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> is raised if the file’s group identifier (GID) isn’t found in the system database.</p> <p>This method normally follows symlinks; to get the group of the symlink, add the argument <code>follow_symlinks=False</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Raises <a class="reference internal" href="#pathlib.UnsupportedOperation" title="pathlib.UnsupportedOperation"><code>UnsupportedOperation</code></a> if the <a class="reference internal" href="grp.html#module-grp" title="grp: The group database (getgrnam() and friends). (Unix)"><code>grp</code></a> module is not available. In earlier versions, <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a> was raised.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>The <em>follow_symlinks</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.chmod">
<code>Path.chmod(mode, *, follow_symlinks=True)</code> </dt> <dd>
<p>Change the file mode and permissions, like <a class="reference internal" href="os.html#os.chmod" title="os.chmod"><code>os.chmod()</code></a>.</p> <p>This method normally follows symlinks. Some Unix flavours support changing permissions on the symlink itself; on these platforms you may add the argument <code>follow_symlinks=False</code>, or use <a class="reference internal" href="#pathlib.Path.lchmod" title="pathlib.Path.lchmod"><code>lchmod()</code></a>.</p> <pre data-language="python">&gt;&gt;&gt; p = Path('setup.py')
&gt;&gt;&gt; p.stat().st_mode
33277
&gt;&gt;&gt; p.chmod(0o444)
&gt;&gt;&gt; p.stat().st_mode
33060
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <em>follow_symlinks</em> parameter was added.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="pathlib.Path.lchmod">
<code>Path.lchmod(mode)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#pathlib.Path.chmod" title="pathlib.Path.chmod"><code>Path.chmod()</code></a> but, if the path points to a symbolic link, the symbolic link’s mode is changed rather than its target’s.</p> </dd>
</dl> </section> </section> <section id="pattern-language"> <span id="pathlib-pattern-language"></span><h2>Pattern language</h2> <p>The following wildcards are supported in patterns for <a class="reference internal" href="#pathlib.PurePath.full_match" title="pathlib.PurePath.full_match"><code>full_match()</code></a>, <a class="reference internal" href="#pathlib.Path.glob" title="pathlib.Path.glob"><code>glob()</code></a> and <a class="reference internal" href="#pathlib.Path.rglob" title="pathlib.Path.rglob"><code>rglob()</code></a>:</p> <dl class="simple"> <dt>
<code>** (entire segment)</code> </dt>
<dd>
<p>Matches any number of file or directory segments, including zero.</p> </dd> <dt>
<code>* (entire segment)</code> </dt>
<dd>
<p>Matches one file or directory segment.</p> </dd> <dt>
<code>* (part of a segment)</code> </dt>
<dd>
<p>Matches any number of non-separator characters, including zero.</p> </dd> <dt>
<code>?</code> </dt>
<dd>
<p>Matches one non-separator character.</p> </dd> <dt>
<code>[seq]</code> </dt>
<dd>
<p>Matches one character in <em>seq</em>.</p> </dd> <dt>
<code>[!seq]</code> </dt>
<dd>
<p>Matches one character not in <em>seq</em>.</p> </dd> </dl> <p>For a literal match, wrap the meta-characters in brackets. For example, <code>"[?]"</code> matches the character <code>"?"</code>.</p> <p>The “<code>**</code>” wildcard enables recursive globbing. A few examples:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Pattern</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p>“<code>**/*</code>”</p></td> <td><p>Any path with at least one segment.</p></td> </tr> <tr>
<td><p>“<code>**/*.py</code>”</p></td> <td><p>Any path with a final segment ending “<code>.py</code>”.</p></td> </tr> <tr>
<td><p>“<code>assets/**</code>”</p></td> <td><p>Any path starting with “<code>assets/</code>”.</p></td> </tr> <tr>
<td><p>“<code>assets/**/*</code>”</p></td> <td><p>Any path starting with “<code>assets/</code>”, excluding “<code>assets/</code>” itself.</p></td> </tr>  </table> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Globbing with the “<code>**</code>” wildcard visits every directory in the tree. Large directory trees may take a long time to search.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.13: </span>Globbing with a pattern that ends with “<code>**</code>” returns both files and directories. In previous versions, only directories were returned.</p> </div> <p>In <a class="reference internal" href="#pathlib.Path.glob" title="pathlib.Path.glob"><code>Path.glob()</code></a> and <a class="reference internal" href="#pathlib.Path.rglob" title="pathlib.Path.rglob"><code>rglob()</code></a>, a trailing slash may be added to the pattern to match only directories.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Globbing with a pattern that ends with a pathname components separator (<a class="reference internal" href="os.html#os.sep" title="os.sep"><code>sep</code></a> or <a class="reference internal" href="os.html#os.altsep" title="os.altsep"><code>altsep</code></a>) returns only directories.</p> </div> </section> <section id="comparison-to-the-glob-module"> <h2>Comparison to the glob module</h2> <p>The patterns accepted and results generated by <a class="reference internal" href="#pathlib.Path.glob" title="pathlib.Path.glob"><code>Path.glob()</code></a> and <a class="reference internal" href="#pathlib.Path.rglob" title="pathlib.Path.rglob"><code>Path.rglob()</code></a> differ slightly from those by the <a class="reference internal" href="glob.html#module-glob" title="glob: Unix shell style pathname pattern expansion."><code>glob</code></a> module:</p> <ol class="arabic simple"> <li>Files beginning with a dot are not special in pathlib. This is like passing <code>include_hidden=True</code> to <a class="reference internal" href="glob.html#glob.glob" title="glob.glob"><code>glob.glob()</code></a>.</li> <li>“<code>**</code>” pattern components are always recursive in pathlib. This is like passing <code>recursive=True</code> to <a class="reference internal" href="glob.html#glob.glob" title="glob.glob"><code>glob.glob()</code></a>.</li> <li>“<code>**</code>” pattern components do not follow symlinks by default in pathlib. This behaviour has no equivalent in <a class="reference internal" href="glob.html#glob.glob" title="glob.glob"><code>glob.glob()</code></a>, but you can pass <code>recurse_symlinks=True</code> to <a class="reference internal" href="#pathlib.Path.glob" title="pathlib.Path.glob"><code>Path.glob()</code></a> for compatible behaviour.</li> <li>Like all <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a> and <a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code>Path</code></a> objects, the values returned from <a class="reference internal" href="#pathlib.Path.glob" title="pathlib.Path.glob"><code>Path.glob()</code></a> and <a class="reference internal" href="#pathlib.Path.rglob" title="pathlib.Path.rglob"><code>Path.rglob()</code></a> don’t include trailing slashes.</li> <li>The values returned from pathlib’s <code>path.glob()</code> and <code>path.rglob()</code> include the <em>path</em> as a prefix, unlike the results of <code>glob.glob(root_dir=path)</code>.</li> <li>The values returned from pathlib’s <code>path.glob()</code> and <code>path.rglob()</code> may include <em>path</em> itself, for example when globbing “<code>**</code>”, whereas the results of <code>glob.glob(root_dir=path)</code> never include an empty string that would correspond to <em>path</em>.</li> </ol> </section> <section id="comparison-to-the-os-and-os-path-modules"> <h2>Comparison to the os and os.path modules</h2> <p>pathlib implements path operations using <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a> and <a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code>Path</code></a> objects, and so it’s said to be <em>object-oriented</em>. On the other hand, the <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code>os</code></a> and <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a> modules supply functions that work with low-level <code>str</code> and <code>bytes</code> objects, which is a more <em>procedural</em> approach. Some users consider the object-oriented style to be more readable.</p> <p>Many functions in <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code>os</code></a> and <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a> support <code>bytes</code> paths and <a class="reference internal" href="os.html#dir-fd"><span class="std std-ref">paths relative to directory descriptors</span></a>. These features aren’t available in pathlib.</p> <p>Python’s <code>str</code> and <code>bytes</code> types, and portions of the <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code>os</code></a> and <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a> modules, are written in C and are very speedy. pathlib is written in pure Python and is often slower, but rarely slow enough to matter.</p> <p>pathlib’s path normalization is slightly more opinionated and consistent than <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a>. For example, whereas <a class="reference internal" href="os.path.html#os.path.abspath" title="os.path.abspath"><code>os.path.abspath()</code></a> eliminates “<code>..</code>” segments from a path, which may change its meaning if symlinks are involved, <a class="reference internal" href="#pathlib.Path.absolute" title="pathlib.Path.absolute"><code>Path.absolute()</code></a> preserves these segments for greater safety.</p> <p>pathlib’s path normalization may render it unsuitable for some applications:</p> <ol class="arabic simple"> <li>pathlib normalizes <code>Path("my_folder/")</code> to <code>Path("my_folder")</code>, which changes a path’s meaning when supplied to various operating system APIs and command-line utilities. Specifically, the absence of a trailing separator may allow the path to be resolved as either a file or directory, rather than a directory only.</li> <li>pathlib normalizes <code>Path("./my_program")</code> to <code>Path("my_program")</code>, which changes a path’s meaning when used as an executable search path, such as in a shell or when spawning a child process. Specifically, the absence of a separator in the path may force it to be looked up in <span class="target" id="index-3"></span><code>PATH</code> rather than the current directory.</li> </ol> <p>As a consequence of these differences, pathlib is not a drop-in replacement for <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a>.</p> <section id="corresponding-tools"> <h3>Corresponding tools</h3> <p>Below is a table mapping various <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code>os</code></a> functions to their corresponding <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>/<a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code>Path</code></a> equivalent.</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p><a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code>os</code></a> and <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a></p></th> <th class="head"><p><a class="reference internal" href="#module-pathlib" title="pathlib: Object-oriented filesystem paths"><code>pathlib</code></a></p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.dirname" title="os.path.dirname"><code>os.path.dirname()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.PurePath.parent" title="pathlib.PurePath.parent"><code>PurePath.parent</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.basename" title="os.path.basename"><code>os.path.basename()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.PurePath.name" title="pathlib.PurePath.name"><code>PurePath.name</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.splitext" title="os.path.splitext"><code>os.path.splitext()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.PurePath.stem" title="pathlib.PurePath.stem"><code>PurePath.stem</code></a>, <a class="reference internal" href="#pathlib.PurePath.suffix" title="pathlib.PurePath.suffix"><code>PurePath.suffix</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.join" title="os.path.join"><code>os.path.join()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.PurePath.joinpath" title="pathlib.PurePath.joinpath"><code>PurePath.joinpath()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.isabs" title="os.path.isabs"><code>os.path.isabs()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.PurePath.is_absolute" title="pathlib.PurePath.is_absolute"><code>PurePath.is_absolute()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.relpath" title="os.path.relpath"><code>os.path.relpath()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.PurePath.relative_to" title="pathlib.PurePath.relative_to"><code>PurePath.relative_to()</code></a> <a class="footnote-reference brackets" href="#id7" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.expanduser" title="os.path.expanduser"><code>os.path.expanduser()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.expanduser" title="pathlib.Path.expanduser"><code>Path.expanduser()</code></a> <a class="footnote-reference brackets" href="#id8" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.realpath" title="os.path.realpath"><code>os.path.realpath()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.resolve" title="pathlib.Path.resolve"><code>Path.resolve()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.abspath" title="os.path.abspath"><code>os.path.abspath()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.absolute" title="pathlib.Path.absolute"><code>Path.absolute()</code></a> <a class="footnote-reference brackets" href="#id9" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.exists" title="os.path.exists"><code>os.path.exists()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.exists" title="pathlib.Path.exists"><code>Path.exists()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.isfile" title="os.path.isfile"><code>os.path.isfile()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.is_file" title="pathlib.Path.is_file"><code>Path.is_file()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.isdir" title="os.path.isdir"><code>os.path.isdir()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.is_dir" title="pathlib.Path.is_dir"><code>Path.is_dir()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.islink" title="os.path.islink"><code>os.path.islink()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.is_symlink" title="pathlib.Path.is_symlink"><code>Path.is_symlink()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.isjunction" title="os.path.isjunction"><code>os.path.isjunction()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.is_junction" title="pathlib.Path.is_junction"><code>Path.is_junction()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.ismount" title="os.path.ismount"><code>os.path.ismount()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.is_mount" title="pathlib.Path.is_mount"><code>Path.is_mount()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.path.html#os.path.samefile" title="os.path.samefile"><code>os.path.samefile()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.samefile" title="pathlib.Path.samefile"><code>Path.samefile()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.getcwd" title="os.getcwd"><code>os.getcwd()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.cwd" title="pathlib.Path.cwd"><code>Path.cwd()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.stat" title="os.stat"><code>os.stat()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.stat" title="pathlib.Path.stat"><code>Path.stat()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.lstat" title="os.lstat"><code>os.lstat()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.lstat" title="pathlib.Path.lstat"><code>Path.lstat()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.listdir" title="os.listdir"><code>os.listdir()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.iterdir" title="pathlib.Path.iterdir"><code>Path.iterdir()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.walk" title="os.walk"><code>os.walk()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> <a class="footnote-reference brackets" href="#id10" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.mkdir" title="os.mkdir"><code>os.mkdir()</code></a>, <a class="reference internal" href="os.html#os.makedirs" title="os.makedirs"><code>os.makedirs()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.mkdir" title="pathlib.Path.mkdir"><code>Path.mkdir()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.link" title="os.link"><code>os.link()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.hardlink_to" title="pathlib.Path.hardlink_to"><code>Path.hardlink_to()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.symlink" title="os.symlink"><code>os.symlink()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.symlink_to" title="pathlib.Path.symlink_to"><code>Path.symlink_to()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.readlink" title="os.readlink"><code>os.readlink()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.readlink" title="pathlib.Path.readlink"><code>Path.readlink()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.rename" title="os.rename"><code>os.rename()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.rename" title="pathlib.Path.rename"><code>Path.rename()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.replace" title="os.replace"><code>os.replace()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.replace" title="pathlib.Path.replace"><code>Path.replace()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.remove" title="os.remove"><code>os.remove()</code></a>, <a class="reference internal" href="os.html#os.unlink" title="os.unlink"><code>os.unlink()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.unlink" title="pathlib.Path.unlink"><code>Path.unlink()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.rmdir" title="os.rmdir"><code>os.rmdir()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.rmdir" title="pathlib.Path.rmdir"><code>Path.rmdir()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.chmod" title="os.chmod"><code>os.chmod()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.chmod" title="pathlib.Path.chmod"><code>Path.chmod()</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="os.html#os.lchmod" title="os.lchmod"><code>os.lchmod()</code></a></p></td> <td><p><a class="reference internal" href="#pathlib.Path.lchmod" title="pathlib.Path.lchmod"><code>Path.lchmod()</code></a></p></td> </tr>  </table> <h4 class="rubric">Footnotes</h4> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id7" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span> <p><a class="reference internal" href="os.path.html#os.path.relpath" title="os.path.relpath"><code>os.path.relpath()</code></a> calls <a class="reference internal" href="os.path.html#os.path.abspath" title="os.path.abspath"><code>abspath()</code></a> to make paths absolute and remove “<code>..</code>” parts, whereas <a class="reference internal" href="#pathlib.PurePath.relative_to" title="pathlib.PurePath.relative_to"><code>PurePath.relative_to()</code></a> is a lexical operation that raises <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> when its inputs’ anchors differ (e.g. if one path is absolute and the other relative.)</p> </aside> <aside class="footnote brackets" id="id8" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">2</a><span class="fn-bracket">]</span></span> <p><a class="reference internal" href="os.path.html#os.path.expanduser" title="os.path.expanduser"><code>os.path.expanduser()</code></a> returns the path unchanged if the home directory can’t be resolved, whereas <a class="reference internal" href="#pathlib.Path.expanduser" title="pathlib.Path.expanduser"><code>Path.expanduser()</code></a> raises <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a>.</p> </aside> <aside class="footnote brackets" id="id9" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">3</a><span class="fn-bracket">]</span></span> <p><a class="reference internal" href="os.path.html#os.path.abspath" title="os.path.abspath"><code>os.path.abspath()</code></a> removes “<code>..</code>” components without resolving symlinks, which may change the meaning of the path, whereas <a class="reference internal" href="#pathlib.Path.absolute" title="pathlib.Path.absolute"><code>Path.absolute()</code></a> leaves any “<code>..</code>” components in the path.</p> </aside> <aside class="footnote brackets" id="id10" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">4</a><span class="fn-bracket">]</span></span> <p><a class="reference internal" href="os.html#os.walk" title="os.walk"><code>os.walk()</code></a> always follows symlinks when categorizing paths into <em>dirnames</em> and <em>filenames</em>, whereas <a class="reference internal" href="#pathlib.Path.walk" title="pathlib.Path.walk"><code>Path.walk()</code></a> categorizes all symlinks into <em>filenames</em> when <em>follow_symlinks</em> is false (the default.)</p> </aside> </aside> </section> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/pathlib.html" class="_attribution-link">https://docs.python.org/3.13/library/pathlib.html</a>
  </p>
</div>
