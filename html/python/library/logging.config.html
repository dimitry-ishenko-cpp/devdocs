 <span id="logging-config-logging-configuration"></span><h1>logging.config — Logging configuration</h1> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/logging/config.py">Lib/logging/config.py</a></p> <aside class="sidebar"> <p class="sidebar-title">Important</p> <p>This page contains only reference information. For tutorials, please see</p> <ul class="simple"> <li><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span class="std std-ref">Basic Tutorial</span></a></li> <li><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">Advanced Tutorial</span></a></li> <li><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">Logging Cookbook</span></a></li> </ul> </aside>  <p>This section describes the API for configuring the logging module.</p> <section id="configuration-functions"> <span id="logging-config-api"></span><h2>Configuration functions</h2> <p>The following functions configure the logging module. They are located in the <a class="reference internal" href="#module-logging.config" title="logging.config: Configuration of the logging module."><code>logging.config</code></a> module. Their use is optional — you can configure the logging module using these functions or by making calls to the main API (defined in <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code>logging</code></a> itself) and defining handlers which are declared either in <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code>logging</code></a> or <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code>logging.handlers</code></a>.</p> <dl class="py function"> <dt class="sig sig-object py" id="logging.config.dictConfig">
<code>logging.config.dictConfig(config)</code> </dt> <dd>
<p>Takes the logging configuration from a dictionary. The contents of this dictionary are described in <a class="reference internal" href="#logging-config-dictschema"><span class="std std-ref">Configuration dictionary schema</span></a> below.</p> <p>If an error is encountered during configuration, this function will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>, <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>, <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code>AttributeError</code></a> or <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code>ImportError</code></a> with a suitably descriptive message. The following is a (possibly incomplete) list of conditions which will raise an error:</p> <ul class="simple"> <li>A <code>level</code> which is not a string or which is a string not corresponding to an actual logging level.</li> <li>A <code>propagate</code> value which is not a boolean.</li> <li>An id which does not have a corresponding destination.</li> <li>A non-existent handler id found during an incremental call.</li> <li>An invalid logger name.</li> <li>Inability to resolve to an internal or external object.</li> </ul> <p>Parsing is performed by the <code>DictConfigurator</code> class, whose constructor is passed the dictionary used for configuration, and has a <code>configure()</code> method. The <a class="reference internal" href="#module-logging.config" title="logging.config: Configuration of the logging module."><code>logging.config</code></a> module has a callable attribute <code>dictConfigClass</code> which is initially set to <code>DictConfigurator</code>. You can replace the value of <code>dictConfigClass</code> with a suitable implementation of your own.</p> <p><a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> calls <code>dictConfigClass</code> passing the specified dictionary, and then calls the <code>configure()</code> method on the returned object to put the configuration into effect:</p> <pre data-language="python">def dictConfig(config):
    dictConfigClass(config).configure()
</pre> <p>For example, a subclass of <code>DictConfigurator</code> could call <code>DictConfigurator.__init__()</code> in its own <code>__init__()</code>, then set up custom prefixes which would be usable in the subsequent <code>configure()</code> call. <code>dictConfigClass</code> would be bound to this new subclass, and then <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> could be called exactly as in the default, uncustomized state.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="logging.config.fileConfig">
<code>logging.config.fileConfig(fname, defaults=None, disable_existing_loggers=True, encoding=None)</code> </dt> <dd>
<p>Reads the logging configuration from a <a class="reference internal" href="configparser.html#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a>-format file. The format of the file should be as described in <a class="reference internal" href="#logging-config-fileformat"><span class="std std-ref">Configuration file format</span></a>. This function can be called several times from an application, allowing an end user to select from various pre-canned configurations (if the developer provides a mechanism to present the choices and load the chosen configuration).</p> <p>It will raise <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code>FileNotFoundError</code></a> if the file doesn’t exist and <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> if the file is invalid or empty.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>fname</strong> – A filename, or a file-like object, or an instance derived from <a class="reference internal" href="configparser.html#configparser.RawConfigParser" title="configparser.RawConfigParser"><code>RawConfigParser</code></a>. If a <code>RawConfigParser</code>-derived instance is passed, it is used as is. Otherwise, a <a class="reference internal" href="configparser.html#configparser.ConfigParser" title="configparser.ConfigParser"><code>ConfigParser</code></a> is instantiated, and the configuration read by it from the object passed in <code>fname</code>. If that has a <a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code>readline()</code></a> method, it is assumed to be a file-like object and read using <a class="reference internal" href="configparser.html#configparser.ConfigParser.read_file" title="configparser.ConfigParser.read_file"><code>read_file()</code></a>; otherwise, it is assumed to be a filename and passed to <a class="reference internal" href="configparser.html#configparser.ConfigParser.read" title="configparser.ConfigParser.read"><code>read()</code></a>.</li> <li>
<strong>defaults</strong> – Defaults to be passed to the <code>ConfigParser</code> can be specified in this argument.</li> <li>
<strong>disable_existing_loggers</strong> – If specified as <code>False</code>, loggers which exist when this call is made are left enabled. The default is <code>True</code> because this enables old behaviour in a backward-compatible way. This behaviour is to disable any existing non-root loggers unless they or their ancestors are explicitly named in the logging configuration.</li> <li>
<strong>encoding</strong> – The encoding used to open file when <em>fname</em> is filename.</li> </ul> </dd> </dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>An instance of a subclass of <a class="reference internal" href="configparser.html#configparser.RawConfigParser" title="configparser.RawConfigParser"><code>RawConfigParser</code></a> is now accepted as a value for <code>fname</code>. This facilitates:</p>  <ul class="simple"> <li>Use of a configuration file where logging configuration is just part of the overall application configuration.</li> <li>Use of a configuration read from a file, and then modified by the using application (e.g. based on command-line parameters or other aspects of the runtime environment) before being passed to <code>fileConfig</code>.</li> </ul>  <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10: </span>The <em>encoding</em> parameter is added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>An exception will be thrown if the provided file doesn’t exist or is invalid or empty.</p> </div> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="logging.config.listen">
<code>logging.config.listen(port=DEFAULT_LOGGING_CONFIG_PORT, verify=None)</code> </dt> <dd>
<p>Starts up a socket server on the specified port, and listens for new configurations. If no port is specified, the module’s default <code>DEFAULT_LOGGING_CONFIG_PORT</code> is used. Logging configurations will be sent as a file suitable for processing by <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> or <a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code>fileConfig()</code></a>. Returns a <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code>Thread</code></a> instance on which you can call <a class="reference internal" href="threading.html#threading.Thread.start" title="threading.Thread.start"><code>start()</code></a> to start the server, and which you can <a class="reference internal" href="threading.html#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> when appropriate. To stop the server, call <a class="reference internal" href="#logging.config.stopListening" title="logging.config.stopListening"><code>stopListening()</code></a>.</p> <p>The <code>verify</code> argument, if specified, should be a callable which should verify whether bytes received across the socket are valid and should be processed. This could be done by encrypting and/or signing what is sent across the socket, such that the <code>verify</code> callable can perform signature verification and/or decryption. The <code>verify</code> callable is called with a single argument - the bytes received across the socket - and should return the bytes to be processed, or <code>None</code> to indicate that the bytes should be discarded. The returned bytes could be the same as the passed in bytes (e.g. when only verification is done), or they could be completely different (perhaps if decryption were performed).</p> <p>To send a configuration to the socket, read in the configuration file and send it to the socket as a sequence of bytes preceded by a four-byte length string packed in binary using <code>struct.pack('&gt;L', n)</code>.</p> <div class="admonition note" id="logging-eval-security"> <p class="admonition-title">Note</p> <p>Because portions of the configuration are passed through <a class="reference internal" href="functions.html#eval" title="eval"><code>eval()</code></a>, use of this function may open its users to a security risk. While the function only binds to a socket on <code>localhost</code>, and so does not accept connections from remote machines, there are scenarios where untrusted code could be run under the account of the process which calls <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code>listen()</code></a>. Specifically, if the process calling <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code>listen()</code></a> runs on a multi-user machine where users cannot trust each other, then a malicious user could arrange to run essentially arbitrary code in a victim user’s process, simply by connecting to the victim’s <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code>listen()</code></a> socket and sending a configuration which runs whatever code the attacker wants to have executed in the victim’s process. This is especially easy to do if the default port is used, but not hard even if a different port is used. To avoid the risk of this happening, use the <code>verify</code> argument to <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code>listen()</code></a> to prevent unrecognised configurations from being applied.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The <code>verify</code> argument was added.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you want to send configurations to the listener which don’t disable existing loggers, you will need to use a JSON format for the configuration, which will use <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> for configuration. This method allows you to specify <code>disable_existing_loggers</code> as <code>False</code> in the configuration you send.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="logging.config.stopListening">
<code>logging.config.stopListening()</code> </dt> <dd>
<p>Stops the listening server which was created with a call to <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code>listen()</code></a>. This is typically called before calling <code>join()</code> on the return value from <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code>listen()</code></a>.</p> </dd>
</dl> </section> <section id="security-considerations"> <h2>Security considerations</h2> <p>The logging configuration functionality tries to offer convenience, and in part this is done by offering the ability to convert text in configuration files into Python objects used in logging configuration - for example, as described in <a class="reference internal" href="#logging-config-dict-userdef"><span class="std std-ref">User-defined objects</span></a>. However, these same mechanisms (importing callables from user-defined modules and calling them with parameters from the configuration) could be used to invoke any code you like, and for this reason you should treat configuration files from untrusted sources with <em>extreme caution</em> and satisfy yourself that nothing bad can happen if you load them, before actually loading them.</p> </section> <section id="configuration-dictionary-schema"> <span id="logging-config-dictschema"></span><h2>Configuration dictionary schema</h2> <p>Describing a logging configuration requires listing the various objects to create and the connections between them; for example, you may create a handler named ‘console’ and then say that the logger named ‘startup’ will send its messages to the ‘console’ handler. These objects aren’t limited to those provided by the <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code>logging</code></a> module because you might write your own formatter or handler class. The parameters to these classes may also need to include external objects such as <code>sys.stderr</code>. The syntax for describing these objects and connections is defined in <a class="reference internal" href="#logging-config-dict-connections"><span class="std std-ref">Object connections</span></a> below.</p> <section id="dictionary-schema-details"> <h3>Dictionary Schema Details</h3> <p>The dictionary passed to <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> must contain the following keys:</p> <ul class="simple"> <li>
<em>version</em> - to be set to an integer value representing the schema version. The only valid value at present is 1, but having this key allows the schema to evolve while still preserving backwards compatibility.</li> </ul> <p>All other keys are optional, but if present they will be interpreted as described below. In all cases below where a ‘configuring dict’ is mentioned, it will be checked for the special <code>'()'</code> key to see if a custom instantiation is required. If so, the mechanism described in <a class="reference internal" href="#logging-config-dict-userdef"><span class="std std-ref">User-defined objects</span></a> below is used to create an instance; otherwise, the context is used to determine what to instantiate.</p> <ul id="logging-config-dictschema-formatters"> <li>
<p><em>formatters</em> - the corresponding value will be a dict in which each key is a formatter id and each value is a dict describing how to configure the corresponding <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> instance.</p> <p>The configuring dict is searched for the following optional keys which correspond to the arguments passed to create a <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> object:</p> <ul class="simple"> <li><code>format</code></li> <li><code>datefmt</code></li> <li><code>style</code></li> <li>
<code>validate</code> (since version &gt;=3.8)</li> <li>
<code>defaults</code> (since version &gt;=3.12)</li> </ul> <p>An optional <code>class</code> key indicates the name of the formatter’s class (as a dotted module and class name). The instantiation arguments are as for <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a>, thus this key is most useful for instantiating a customised subclass of <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a>. For example, the alternative class might present exception tracebacks in an expanded or condensed format. If your formatter requires different or extra configuration keys, you should use <a class="reference internal" href="#logging-config-dict-userdef"><span class="std std-ref">User-defined objects</span></a>.</p> </li> <li>
<p><em>filters</em> - the corresponding value will be a dict in which each key is a filter id and each value is a dict describing how to configure the corresponding Filter instance.</p> <p>The configuring dict is searched for the key <code>name</code> (defaulting to the empty string) and this is used to construct a <a class="reference internal" href="logging.html#logging.Filter" title="logging.Filter"><code>logging.Filter</code></a> instance.</p> </li> <li>
<p><em>handlers</em> - the corresponding value will be a dict in which each key is a handler id and each value is a dict describing how to configure the corresponding Handler instance.</p> <p>The configuring dict is searched for the following keys:</p> <ul> <li>
<code>class</code> (mandatory). This is the fully qualified name of the handler class.</li> <li>
<code>level</code> (optional). The level of the handler.</li> <li>
<code>formatter</code> (optional). The id of the formatter for this handler.</li> <li>
<p><code>filters</code> (optional). A list of ids of the filters for this handler.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><code>filters</code> can take filter instances in addition to ids.</p> </div> </li> </ul> <p>All <em>other</em> keys are passed through as keyword arguments to the handler’s constructor. For example, given the snippet:</p> <pre data-language="yaml">handlers:
  console:
    class : logging.StreamHandler
    formatter: brief
    level   : INFO
    filters: [allow_foo]
    stream  : ext://sys.stdout
  file:
    class : logging.handlers.RotatingFileHandler
    formatter: precise
    filename: logconfig.log
    maxBytes: 1024
    backupCount: 3
</pre> <p>the handler with id <code>console</code> is instantiated as a <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code>logging.StreamHandler</code></a>, using <code>sys.stdout</code> as the underlying stream. The handler with id <code>file</code> is instantiated as a <a class="reference internal" href="logging.handlers.html#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code>logging.handlers.RotatingFileHandler</code></a> with the keyword arguments <code>filename='logconfig.log', maxBytes=1024, backupCount=3</code>.</p> </li> <li>
<p><em>loggers</em> - the corresponding value will be a dict in which each key is a logger name and each value is a dict describing how to configure the corresponding Logger instance.</p> <p>The configuring dict is searched for the following keys:</p> <ul> <li>
<code>level</code> (optional). The level of the logger.</li> <li>
<code>propagate</code> (optional). The propagation setting of the logger.</li> <li>
<p><code>filters</code> (optional). A list of ids of the filters for this logger.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span><code>filters</code> can take filter instances in addition to ids.</p> </div> </li> <li>
<code>handlers</code> (optional). A list of ids of the handlers for this logger.</li> </ul> <p>The specified loggers will be configured according to the level, propagation, filters and handlers specified.</p> </li> <li>
<em>root</em> - this will be the configuration for the root logger. Processing of the configuration will be as for any logger, except that the <code>propagate</code> setting will not be applicable.</li> <li>
<p><em>incremental</em> - whether the configuration is to be interpreted as incremental to the existing configuration. This value defaults to <code>False</code>, which means that the specified configuration replaces the existing configuration with the same semantics as used by the existing <a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code>fileConfig()</code></a> API.</p> <p>If the specified value is <code>True</code>, the configuration is processed as described in the section on <a class="reference internal" href="#logging-config-dict-incremental"><span class="std std-ref">Incremental Configuration</span></a>.</p> </li> <li>
<em>disable_existing_loggers</em> - whether any existing non-root loggers are to be disabled. This setting mirrors the parameter of the same name in <a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code>fileConfig()</code></a>. If absent, this parameter defaults to <code>True</code>. This value is ignored if <em>incremental</em> is <code>True</code>.</li> </ul> </section> <section id="incremental-configuration"> <span id="logging-config-dict-incremental"></span><h3>Incremental Configuration</h3> <p>It is difficult to provide complete flexibility for incremental configuration. For example, because objects such as filters and formatters are anonymous, once a configuration is set up, it is not possible to refer to such anonymous objects when augmenting a configuration.</p> <p>Furthermore, there is not a compelling case for arbitrarily altering the object graph of loggers, handlers, filters, formatters at run-time, once a configuration is set up; the verbosity of loggers and handlers can be controlled just by setting levels (and, in the case of loggers, propagation flags). Changing the object graph arbitrarily in a safe way is problematic in a multi-threaded environment; while not impossible, the benefits are not worth the complexity it adds to the implementation.</p> <p>Thus, when the <code>incremental</code> key of a configuration dict is present and is <code>True</code>, the system will completely ignore any <code>formatters</code> and <code>filters</code> entries, and process only the <code>level</code> settings in the <code>handlers</code> entries, and the <code>level</code> and <code>propagate</code> settings in the <code>loggers</code> and <code>root</code> entries.</p> <p>Using a value in the configuration dict lets configurations to be sent over the wire as pickled dicts to a socket listener. Thus, the logging verbosity of a long-running application can be altered over time with no need to stop and restart the application.</p> </section> <section id="object-connections"> <span id="logging-config-dict-connections"></span><h3>Object connections</h3> <p>The schema describes a set of logging objects - loggers, handlers, formatters, filters - which are connected to each other in an object graph. Thus, the schema needs to represent connections between the objects. For example, say that, once configured, a particular logger has attached to it a particular handler. For the purposes of this discussion, we can say that the logger represents the source, and the handler the destination, of a connection between the two. Of course in the configured objects this is represented by the logger holding a reference to the handler. In the configuration dict, this is done by giving each destination object an id which identifies it unambiguously, and then using the id in the source object’s configuration to indicate that a connection exists between the source and the destination object with that id.</p> <p>So, for example, consider the following YAML snippet:</p> <pre data-language="yaml">formatters:
  brief:
    # configuration for formatter with id 'brief' goes here
  precise:
    # configuration for formatter with id 'precise' goes here
handlers:
  h1: #This is an id
   # configuration of handler with id 'h1' goes here
   formatter: brief
  h2: #This is another id
   # configuration of handler with id 'h2' goes here
   formatter: precise
loggers:
  foo.bar.baz:
    # other configuration for logger 'foo.bar.baz'
    handlers: [h1, h2]
</pre> <p>(Note: YAML used here because it’s a little more readable than the equivalent Python source form for the dictionary.)</p> <p>The ids for loggers are the logger names which would be used programmatically to obtain a reference to those loggers, e.g. <code>foo.bar.baz</code>. The ids for Formatters and Filters can be any string value (such as <code>brief</code>, <code>precise</code> above) and they are transient, in that they are only meaningful for processing the configuration dictionary and used to determine connections between objects, and are not persisted anywhere when the configuration call is complete.</p> <p>The above snippet indicates that logger named <code>foo.bar.baz</code> should have two handlers attached to it, which are described by the handler ids <code>h1</code> and <code>h2</code>. The formatter for <code>h1</code> is that described by id <code>brief</code>, and the formatter for <code>h2</code> is that described by id <code>precise</code>.</p> </section> <section id="user-defined-objects"> <span id="logging-config-dict-userdef"></span><h3>User-defined objects</h3> <p>The schema supports user-defined objects for handlers, filters and formatters. (Loggers do not need to have different types for different instances, so there is no support in this configuration schema for user-defined logger classes.)</p> <p>Objects to be configured are described by dictionaries which detail their configuration. In some places, the logging system will be able to infer from the context how an object is to be instantiated, but when a user-defined object is to be instantiated, the system will not know how to do this. In order to provide complete flexibility for user-defined object instantiation, the user needs to provide a ‘factory’ - a callable which is called with a configuration dictionary and which returns the instantiated object. This is signalled by an absolute import path to the factory being made available under the special key <code>'()'</code>. Here’s a concrete example:</p> <pre data-language="yaml">formatters:
  brief:
    format: '%(message)s'
  default:
    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'
    datefmt: '%Y-%m-%d %H:%M:%S'
  custom:
      (): my.package.customFormatterFactory
      bar: baz
      spam: 99.9
      answer: 42
</pre> <p>The above YAML snippet defines three formatters. The first, with id <code>brief</code>, is a standard <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code>logging.Formatter</code></a> instance with the specified format string. The second, with id <code>default</code>, has a longer format and also defines the time format explicitly, and will result in a <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code>logging.Formatter</code></a> initialized with those two format strings. Shown in Python source form, the <code>brief</code> and <code>default</code> formatters have configuration sub-dictionaries:</p> <pre data-language="python">{
  'format' : '%(message)s'
}
</pre> <p>and:</p> <pre data-language="python">{
  'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',
  'datefmt' : '%Y-%m-%d %H:%M:%S'
}
</pre> <p>respectively, and as these dictionaries do not contain the special key <code>'()'</code>, the instantiation is inferred from the context: as a result, standard <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code>logging.Formatter</code></a> instances are created. The configuration sub-dictionary for the third formatter, with id <code>custom</code>, is:</p> <pre data-language="python">{
  '()' : 'my.package.customFormatterFactory',
  'bar' : 'baz',
  'spam' : 99.9,
  'answer' : 42
}
</pre> <p>and this contains the special key <code>'()'</code>, which means that user-defined instantiation is wanted. In this case, the specified factory callable will be used. If it is an actual callable it will be used directly - otherwise, if you specify a string (as in the example) the actual callable will be located using normal import mechanisms. The callable will be called with the <strong>remaining</strong> items in the configuration sub-dictionary as keyword arguments. In the above example, the formatter with id <code>custom</code> will be assumed to be returned by the call:</p> <pre data-language="python">my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The values for keys such as <code>bar</code>, <code>spam</code> and <code>answer</code> in the above example should not be configuration dictionaries or references such as <code>cfg://foo</code> or <code>ext://bar</code>, because they will not be processed by the configuration machinery, but passed to the callable as-is.</p> </div> <p>The key <code>'()'</code> has been used as the special key because it is not a valid keyword parameter name, and so will not clash with the names of the keyword arguments used in the call. The <code>'()'</code> also serves as a mnemonic that the corresponding value is a callable.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>The <code>filters</code> member of <code>handlers</code> and <code>loggers</code> can take filter instances in addition to ids.</p> </div> <p>You can also specify a special key <code>'.'</code> whose value is a dictionary is a mapping of attribute names to values. If found, the specified attributes will be set on the user-defined object before it is returned. Thus, with the following configuration:</p> <pre data-language="python">{
  '()' : 'my.package.customFormatterFactory',
  'bar' : 'baz',
  'spam' : 99.9,
  'answer' : 42,
  '.' {
    'foo': 'bar',
    'baz': 'bozz'
  }
}
</pre> <p>the returned formatter will have attribute <code>foo</code> set to <code>'bar'</code> and attribute <code>baz</code> set to <code>'bozz'</code>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The values for attributes such as <code>foo</code> and <code>baz</code> in the above example should not be configuration dictionaries or references such as <code>cfg://foo</code> or <code>ext://bar</code>, because they will not be processed by the configuration machinery, but set as attribute values as-is.</p> </div> </section> <section id="handler-configuration-order"> <span id="handler-config-dict-order"></span><h3>Handler configuration order</h3> <p>Handlers are configured in alphabetical order of their keys, and a configured handler replaces the configuration dictionary in (a working copy of) the <code>handlers</code> dictionary in the schema. If you use a construct such as <code>cfg://handlers.foo</code>, then initially <code>handlers['foo']</code> points to the configuration dictionary for the handler named <code>foo</code>, and later (once that handler has been configured) it points to the configured handler instance. Thus, <code>cfg://handlers.foo</code> could resolve to either a dictionary or a handler instance. In general, it is wise to name handlers in a way such that dependent handlers are configured _after_ any handlers they depend on; that allows something like <code>cfg://handlers.foo</code> to be used in configuring a handler that depends on handler <code>foo</code>. If that dependent handler were named <code>bar</code>, problems would result, because the configuration of <code>bar</code> would be attempted before that of <code>foo</code>, and <code>foo</code> would not yet have been configured. However, if the dependent handler were named <code>foobar</code>, it would be configured after <code>foo</code>, with the result that <code>cfg://handlers.foo</code> would resolve to configured handler <code>foo</code>, and not its configuration dictionary.</p> </section> <section id="access-to-external-objects"> <span id="logging-config-dict-externalobj"></span><h3>Access to external objects</h3> <p>There are times where a configuration needs to refer to objects external to the configuration, for example <code>sys.stderr</code>. If the configuration dict is constructed using Python code, this is straightforward, but a problem arises when the configuration is provided via a text file (e.g. JSON, YAML). In a text file, there is no standard way to distinguish <code>sys.stderr</code> from the literal string <code>'sys.stderr'</code>. To facilitate this distinction, the configuration system looks for certain special prefixes in string values and treat them specially. For example, if the literal string <code>'ext://sys.stderr'</code> is provided as a value in the configuration, then the <code>ext://</code> will be stripped off and the remainder of the value processed using normal import mechanisms.</p> <p>The handling of such prefixes is done in a way analogous to protocol handling: there is a generic mechanism to look for prefixes which match the regular expression <code>^(?P&lt;prefix&gt;[a-z]+)://(?P&lt;suffix&gt;.*)$</code> whereby, if the <code>prefix</code> is recognised, the <code>suffix</code> is processed in a prefix-dependent manner and the result of the processing replaces the string value. If the prefix is not recognised, then the string value will be left as-is.</p> </section> <section id="access-to-internal-objects"> <span id="logging-config-dict-internalobj"></span><h3>Access to internal objects</h3> <p>As well as external objects, there is sometimes also a need to refer to objects in the configuration. This will be done implicitly by the configuration system for things that it knows about. For example, the string value <code>'DEBUG'</code> for a <code>level</code> in a logger or handler will automatically be converted to the value <code>logging.DEBUG</code>, and the <code>handlers</code>, <code>filters</code> and <code>formatter</code> entries will take an object id and resolve to the appropriate destination object.</p> <p>However, a more generic mechanism is needed for user-defined objects which are not known to the <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code>logging</code></a> module. For example, consider <a class="reference internal" href="logging.handlers.html#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code>logging.handlers.MemoryHandler</code></a>, which takes a <code>target</code> argument which is another handler to delegate to. Since the system already knows about this class, then in the configuration, the given <code>target</code> just needs to be the object id of the relevant target handler, and the system will resolve to the handler from the id. If, however, a user defines a <code>my.package.MyHandler</code> which has an <code>alternate</code> handler, the configuration system would not know that the <code>alternate</code> referred to a handler. To cater for this, a generic resolution system allows the user to specify:</p> <pre data-language="yaml">handlers:
  file:
    # configuration of file handler goes here

  custom:
    (): my.package.MyHandler
    alternate: cfg://handlers.file
</pre> <p>The literal string <code>'cfg://handlers.file'</code> will be resolved in an analogous way to strings with the <code>ext://</code> prefix, but looking in the configuration itself rather than the import namespace. The mechanism allows access by dot or by index, in a similar way to that provided by <code>str.format</code>. Thus, given the following snippet:</p> <pre data-language="yaml">handlers:
  email:
    class: logging.handlers.SMTPHandler
    mailhost: localhost
    fromaddr: my_app@domain.tld
    toaddrs:
      - support_team@domain.tld
      - dev_team@domain.tld
    subject: Houston, we have a problem.
</pre> <p>in the configuration, the string <code>'cfg://handlers'</code> would resolve to the dict with key <code>handlers</code>, the string <code>'cfg://handlers.email</code> would resolve to the dict with key <code>email</code> in the <code>handlers</code> dict, and so on. The string <code>'cfg://handlers.email.toaddrs[1]</code> would resolve to <code>'dev_team@domain.tld'</code> and the string <code>'cfg://handlers.email.toaddrs[0]'</code> would resolve to the value <code>'support_team@domain.tld'</code>. The <code>subject</code> value could be accessed using either <code>'cfg://handlers.email.subject'</code> or, equivalently, <code>'cfg://handlers.email[subject]'</code>. The latter form only needs to be used if the key contains spaces or non-alphanumeric characters. If an index value consists only of decimal digits, access will be attempted using the corresponding integer value, falling back to the string value if needed.</p> <p>Given a string <code>cfg://handlers.myhandler.mykey.123</code>, this will resolve to <code>config_dict['handlers']['myhandler']['mykey']['123']</code>. If the string is specified as <code>cfg://handlers.myhandler.mykey[123]</code>, the system will attempt to retrieve the value from <code>config_dict['handlers']['myhandler']['mykey'][123]</code>, and fall back to <code>config_dict['handlers']['myhandler']['mykey']['123']</code> if that fails.</p> </section> <section id="import-resolution-and-custom-importers"> <span id="logging-import-resolution"></span><h3>Import resolution and custom importers</h3> <p>Import resolution, by default, uses the builtin <a class="reference internal" href="functions.html#import__" title="__import__"><code>__import__()</code></a> function to do its importing. You may want to replace this with your own importing mechanism: if so, you can replace the <code>importer</code> attribute of the <code>DictConfigurator</code> or its superclass, the <code>BaseConfigurator</code> class. However, you need to be careful because of the way functions are accessed from classes via descriptors. If you are using a Python callable to do your imports, and you want to define it at class level rather than instance level, you need to wrap it with <a class="reference internal" href="functions.html#staticmethod" title="staticmethod"><code>staticmethod()</code></a>. For example:</p> <pre data-language="python">from importlib import import_module
from logging.config import BaseConfigurator

BaseConfigurator.importer = staticmethod(import_module)
</pre> <p>You don’t need to wrap with <a class="reference internal" href="functions.html#staticmethod" title="staticmethod"><code>staticmethod()</code></a> if you’re setting the import callable on a configurator <em>instance</em>.</p> </section> <section id="configuring-queuehandler-and-queuelistener"> <span id="configure-queue"></span><h3>Configuring QueueHandler and QueueListener</h3> <p>If you want to configure a <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code>QueueHandler</code></a>, noting that this is normally used in conjunction with a <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code>QueueListener</code></a>, you can configure both together. After the configuration, the <code>QueueListener</code> instance will be available as the <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueHandler.listener" title="logging.handlers.QueueHandler.listener"><code>listener</code></a> attribute of the created handler, and that in turn will be available to you using <a class="reference internal" href="logging.html#logging.getHandlerByName" title="logging.getHandlerByName"><code>getHandlerByName()</code></a> and passing the name you have used for the <code>QueueHandler</code> in your configuration. The dictionary schema for configuring the pair is shown in the example YAML snippet below.</p> <pre data-language="yaml">handlers:
  qhand:
    class: logging.handlers.QueueHandler
    queue: my.module.queue_factory
    listener: my.package.CustomListener
    handlers:
      - hand_name_1
      - hand_name_2
      ...
</pre> <p>The <code>queue</code> and <code>listener</code> keys are optional.</p> <p>If the <code>queue</code> key is present, the corresponding value can be one of the following:</p> <ul class="simple"> <li>An actual instance of <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code>queue.Queue</code></a> or a subclass thereof. This is of course only possible if you are constructing or modifying the configuration dictionary in code.</li> <li>A string that resolves to a callable which, when called with no arguments, returns the <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code>queue.Queue</code></a> instance to use. That callable could be a <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code>queue.Queue</code></a> subclass or a function which returns a suitable queue instance, such as <code>my.module.queue_factory()</code>.</li> <li>A dict with a <code>'()'</code> key which is constructed in the usual way as discussed in <a class="reference internal" href="#logging-config-dict-userdef"><span class="std std-ref">User-defined objects</span></a>. The result of this construction should be a <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code>queue.Queue</code></a> instance.</li> </ul> <p>If the <code>queue</code> key is absent, a standard unbounded <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code>queue.Queue</code></a> instance is created and used.</p> <p>If the <code>listener</code> key is present, the corresponding value can be one of the following:</p> <ul class="simple"> <li>A subclass of <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code>logging.handlers.QueueListener</code></a>. This is of course only possible if you are constructing or modifying the configuration dictionary in code.</li> <li>A string which resolves to a class which is a subclass of <code>QueueListener</code>, such as <code>'my.package.CustomListener'</code>.</li> <li>A dict with a <code>'()'</code> key which is constructed in the usual way as discussed in <a class="reference internal" href="#logging-config-dict-userdef"><span class="std std-ref">User-defined objects</span></a>. The result of this construction should be a callable with the same signature as the <code>QueueListener</code> initializer.</li> </ul> <p>If the <code>listener</code> key is absent, <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code>logging.handlers.QueueListener</code></a> is used.</p> <p>The values under the <code>handlers</code> key are the names of other handlers in the configuration (not shown in the above snippet) which will be passed to the queue listener.</p> <p>Any custom queue handler and listener classes will need to be defined with the same initialization signatures as <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code>QueueHandler</code></a> and <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code>QueueListener</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </section> </section> <section id="configuration-file-format"> <span id="logging-config-fileformat"></span><h2>Configuration file format</h2> <p>The configuration file format understood by <a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code>fileConfig()</code></a> is based on <a class="reference internal" href="configparser.html#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a> functionality. The file must contain sections called <code>[loggers]</code>, <code>[handlers]</code> and <code>[formatters]</code> which identify by name the entities of each type which are defined in the file. For each such entity, there is a separate section which identifies how that entity is configured. Thus, for a logger named <code>log01</code> in the <code>[loggers]</code> section, the relevant configuration details are held in a section <code>[logger_log01]</code>. Similarly, a handler called <code>hand01</code> in the <code>[handlers]</code> section will have its configuration held in a section called <code>[handler_hand01]</code>, while a formatter called <code>form01</code> in the <code>[formatters]</code> section will have its configuration specified in a section called <code>[formatter_form01]</code>. The root logger configuration must be specified in a section called <code>[logger_root]</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code>fileConfig()</code></a> API is older than the <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> API and does not provide functionality to cover certain aspects of logging. For example, you cannot configure <a class="reference internal" href="logging.html#logging.Filter" title="logging.Filter"><code>Filter</code></a> objects, which provide for filtering of messages beyond simple integer levels, using <a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code>fileConfig()</code></a>. If you need to have instances of <a class="reference internal" href="logging.html#logging.Filter" title="logging.Filter"><code>Filter</code></a> in your logging configuration, you will need to use <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a>. Note that future enhancements to configuration functionality will be added to <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a>, so it’s worth considering transitioning to this newer API when it’s convenient to do so.</p> </div> <p>Examples of these sections in the file are given below.</p> <pre data-language="ini">[loggers]
keys=root,log02,log03,log04,log05,log06,log07

[handlers]
keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09

[formatters]
keys=form01,form02,form03,form04,form05,form06,form07,form08,form09
</pre> <p>The root logger must specify a level and a list of handlers. An example of a root logger section is given below.</p> <pre data-language="ini">[logger_root]
level=NOTSET
handlers=hand01
</pre> <p>The <code>level</code> entry can be one of <code>DEBUG, INFO, WARNING, ERROR, CRITICAL</code> or <code>NOTSET</code>. For the root logger only, <code>NOTSET</code> means that all messages will be logged. Level values are <a class="reference internal" href="functions.html#func-eval"><span class="std std-ref">evaluated</span></a> in the context of the <code>logging</code> package’s namespace.</p> <p>The <code>handlers</code> entry is a comma-separated list of handler names, which must appear in the <code>[handlers]</code> section. These names must appear in the <code>[handlers]</code> section and have corresponding sections in the configuration file.</p> <p>For loggers other than the root logger, some additional information is required. This is illustrated by the following example.</p> <pre data-language="ini">[logger_parser]
level=DEBUG
handlers=hand01
propagate=1
qualname=compiler.parser
</pre> <p>The <code>level</code> and <code>handlers</code> entries are interpreted as for the root logger, except that if a non-root logger’s level is specified as <code>NOTSET</code>, the system consults loggers higher up the hierarchy to determine the effective level of the logger. The <code>propagate</code> entry is set to 1 to indicate that messages must propagate to handlers higher up the logger hierarchy from this logger, or 0 to indicate that messages are <strong>not</strong> propagated to handlers up the hierarchy. The <code>qualname</code> entry is the hierarchical channel name of the logger, that is to say the name used by the application to get the logger.</p> <p>Sections which specify handler configuration are exemplified by the following.</p> <pre data-language="ini">[handler_hand01]
class=StreamHandler
level=NOTSET
formatter=form01
args=(sys.stdout,)
</pre> <p>The <code>class</code> entry indicates the handler’s class (as determined by <a class="reference internal" href="functions.html#eval" title="eval"><code>eval()</code></a> in the <code>logging</code> package’s namespace). The <code>level</code> is interpreted as for loggers, and <code>NOTSET</code> is taken to mean ‘log everything’.</p> <p>The <code>formatter</code> entry indicates the key name of the formatter for this handler. If blank, a default formatter (<code>logging._defaultFormatter</code>) is used. If a name is specified, it must appear in the <code>[formatters]</code> section and have a corresponding section in the configuration file.</p> <p>The <code>args</code> entry, when <a class="reference internal" href="functions.html#func-eval"><span class="std std-ref">evaluated</span></a> in the context of the <code>logging</code> package’s namespace, is the list of arguments to the constructor for the handler class. Refer to the constructors for the relevant handlers, or to the examples below, to see how typical entries are constructed. If not provided, it defaults to <code>()</code>.</p> <p>The optional <code>kwargs</code> entry, when <a class="reference internal" href="functions.html#func-eval"><span class="std std-ref">evaluated</span></a> in the context of the <code>logging</code> package’s namespace, is the keyword argument dict to the constructor for the handler class. If not provided, it defaults to <code>{}</code>.</p> <pre data-language="ini">[handler_hand02]
class=FileHandler
level=DEBUG
formatter=form02
args=('python.log', 'w')

[handler_hand03]
class=handlers.SocketHandler
level=INFO
formatter=form03
args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)

[handler_hand04]
class=handlers.DatagramHandler
level=WARN
formatter=form04
args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)

[handler_hand05]
class=handlers.SysLogHandler
level=ERROR
formatter=form05
args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)

[handler_hand06]
class=handlers.NTEventLogHandler
level=CRITICAL
formatter=form06
args=('Python Application', '', 'Application')

[handler_hand07]
class=handlers.SMTPHandler
level=WARN
formatter=form07
args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger Subject')
kwargs={'timeout': 10.0}

[handler_hand08]
class=handlers.MemoryHandler
level=NOTSET
formatter=form08
target=
args=(10, ERROR)

[handler_hand09]
class=handlers.HTTPHandler
level=NOTSET
formatter=form09
args=('localhost:9022', '/log', 'GET')
kwargs={'secure': True}
</pre> <p>Sections which specify formatter configuration are typified by the following.</p> <pre data-language="ini">[formatter_form01]
format=F1 %(asctime)s %(levelname)s %(message)s %(customfield)s
datefmt=
style=%
validate=True
defaults={'customfield': 'defaultvalue'}
class=logging.Formatter
</pre> <p>The arguments for the formatter configuration are the same as the keys in the dictionary schema <a class="reference internal" href="#logging-config-dictschema-formatters"><span class="std std-ref">formatters section</span></a>.</p> <p>The <code>defaults</code> entry, when <a class="reference internal" href="functions.html#func-eval"><span class="std std-ref">evaluated</span></a> in the context of the <code>logging</code> package’s namespace, is a dictionary of default values for custom formatting fields. If not provided, it defaults to <code>None</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Due to the use of <a class="reference internal" href="functions.html#eval" title="eval"><code>eval()</code></a> as described above, there are potential security risks which result from using the <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code>listen()</code></a> to send and receive configurations via sockets. The risks are limited to where multiple users with no mutual trust run code on the same machine; see the <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code>listen()</code></a> documentation for more information.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code>logging</code></a>
</dt>
<dd>
<p>API reference for the logging module.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code>logging.handlers</code></a>
</dt>
<dd>
<p>Useful handlers included with the logging module.</p> </dd> </dl> </div> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/logging.config.html" class="_attribution-link">https://docs.python.org/3.12/library/logging.config.html</a>
  </p>
</div>
