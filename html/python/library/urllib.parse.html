 <span id="urllib-parse-parse-urls-into-components"></span><h1>urllib.parse — Parse URLs into components</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/urllib/parse.py">Lib/urllib/parse.py</a></p>  <p>This module defines a standard interface to break Uniform Resource Locator (URL) strings up in components (addressing scheme, network location, path etc.), to combine the components back into a URL string, and to convert a “relative URL” to an absolute URL given a “base URL.”</p> <p>The module has been designed to match the internet RFC on Relative Uniform Resource Locators. It supports the following URL schemes: <code>file</code>, <code>ftp</code>, <code>gopher</code>, <code>hdl</code>, <code>http</code>, <code>https</code>, <code>imap</code>, <code>itms-services</code>, <code>mailto</code>, <code>mms</code>, <code>news</code>, <code>nntp</code>, <code>prospero</code>, <code>rsync</code>, <code>rtsp</code>, <code>rtsps</code>, <code>rtspu</code>, <code>sftp</code>, <code>shttp</code>, <code>sip</code>, <code>sips</code>, <code>snews</code>, <code>svn</code>, <code>svn+ssh</code>, <code>telnet</code>, <code>wais</code>, <code>ws</code>, <code>wss</code>.</p> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> The inclusion of the <code>itms-services</code> URL scheme can prevent an app from passing Apple’s App Store review process for the macOS and iOS App Stores. Handling for the <code>itms-services</code> scheme is always removed on iOS; on macOS, it <em>may</em> be removed if CPython has been built with the <a class="reference internal" href="../using/configure.html#cmdoption-with-app-store-compliance"><code>--with-app-store-compliance</code></a> option.</p> </div> <p>The <a class="reference internal" href="#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code>urllib.parse</code></a> module defines functions that fall into two broad categories: URL parsing and URL quoting. These are covered in detail in the following sections.</p> <p>This module’s functions use the deprecated term <code>netloc</code> (or <code>net_loc</code>), which was introduced in <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1808.html"><strong>RFC 1808</strong></a>. However, this term has been obsoleted by <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a>, which introduced the term <code>authority</code> as its replacement. The use of <code>netloc</code> is continued for backward compatibility.</p> <section id="url-parsing"> <h2>URL Parsing</h2> <p>The URL parsing functions focus on splitting a URL string into its components, or on combining URL components into a URL string.</p> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.urlparse">
<code>urllib.parse.urlparse(urlstring, scheme='', allow_fragments=True)</code> </dt> <dd>
<p>Parse a URL into six components, returning a 6-item <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>. This corresponds to the general structure of a URL: <code>scheme://netloc/path;parameters?query#fragment</code>. Each tuple item is a string, possibly empty. The components are not broken up into smaller parts (for example, the network location is a single string), and % escapes are not expanded. The delimiters as shown above are not part of the result, except for a leading slash in the <em>path</em> component, which is retained if present. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; from urllib.parse import urlparse
&gt;&gt;&gt; urlparse("scheme://netloc/path;parameters?query#fragment")
ParseResult(scheme='scheme', netloc='netloc', path='/path;parameters', params='',
            query='query', fragment='fragment')
&gt;&gt;&gt; o = urlparse("http://docs.python.org:80/3/library/urllib.parse.html?"
...              "highlight=params#url-parsing")
&gt;&gt;&gt; o
ParseResult(scheme='http', netloc='docs.python.org:80',
            path='/3/library/urllib.parse.html', params='',
            query='highlight=params', fragment='url-parsing')
&gt;&gt;&gt; o.scheme
'http'
&gt;&gt;&gt; o.netloc
'docs.python.org:80'
&gt;&gt;&gt; o.hostname
'docs.python.org'
&gt;&gt;&gt; o.port
80
&gt;&gt;&gt; o._replace(fragment="").geturl()
'http://docs.python.org:80/3/library/urllib.parse.html?highlight=params'
</pre> <p>Following the syntax specifications in <span class="target" id="index-3"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1808.html"><strong>RFC 1808</strong></a>, urlparse recognizes a netloc only if it is properly introduced by ‘//’. Otherwise the input is presumed to be a relative URL and thus to start with a path component.</p> <pre data-language="pycon">&gt;&gt;&gt; from urllib.parse import urlparse
&gt;&gt;&gt; urlparse('//www.cwi.nl:80/%7Eguido/Python.html')
ParseResult(scheme='', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',
            params='', query='', fragment='')
&gt;&gt;&gt; urlparse('www.cwi.nl/%7Eguido/Python.html')
ParseResult(scheme='', netloc='', path='www.cwi.nl/%7Eguido/Python.html',
            params='', query='', fragment='')
&gt;&gt;&gt; urlparse('help/Python.html')
ParseResult(scheme='', netloc='', path='help/Python.html', params='',
            query='', fragment='')
</pre> <p>The <em>scheme</em> argument gives the default addressing scheme, to be used only if the URL does not specify one. It should be the same type (text or bytes) as <em>urlstring</em>, except that the default value <code>''</code> is always allowed, and is automatically converted to <code>b''</code> if appropriate.</p> <p>If the <em>allow_fragments</em> argument is false, fragment identifiers are not recognized. Instead, they are parsed as part of the path, parameters or query component, and <code>fragment</code> is set to the empty string in the return value.</p> <p>The return value is a <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>, which means that its items can be accessed by index or as named attributes, which are:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Attribute</p></th> <th class="head"><p>Index</p></th> <th class="head"><p>Value</p></th> <th class="head"><p>Value if not present</p></th> </tr> </thead>  <tr>
<td><p><code>scheme</code></p></td> <td><p>0</p></td> <td><p>URL scheme specifier</p></td> <td><p><em>scheme</em> parameter</p></td> </tr> <tr>
<td><p><code>netloc</code></p></td> <td><p>1</p></td> <td><p>Network location part</p></td> <td><p>empty string</p></td> </tr> <tr>
<td><p><code>path</code></p></td> <td><p>2</p></td> <td><p>Hierarchical path</p></td> <td><p>empty string</p></td> </tr> <tr>
<td><p><code>params</code></p></td> <td><p>3</p></td> <td><p>Parameters for last path element</p></td> <td><p>empty string</p></td> </tr> <tr>
<td><p><code>query</code></p></td> <td><p>4</p></td> <td><p>Query component</p></td> <td><p>empty string</p></td> </tr> <tr>
<td><p><code>fragment</code></p></td> <td><p>5</p></td> <td><p>Fragment identifier</p></td> <td><p>empty string</p></td> </tr> <tr>
<td><p><code>username</code></p></td> <td></td> <td><p>User name</p></td> <td><p><a class="reference internal" href="constants.html#None" title="None"><code>None</code></a></p></td> </tr> <tr>
<td><p><code>password</code></p></td> <td></td> <td><p>Password</p></td> <td><p><a class="reference internal" href="constants.html#None" title="None"><code>None</code></a></p></td> </tr> <tr>
<td><p><code>hostname</code></p></td> <td></td> <td><p>Host name (lower case)</p></td> <td><p><a class="reference internal" href="constants.html#None" title="None"><code>None</code></a></p></td> </tr> <tr>
<td><p><code>port</code></p></td> <td></td> <td><p>Port number as integer, if present</p></td> <td><p><a class="reference internal" href="constants.html#None" title="None"><code>None</code></a></p></td> </tr>  </table> <p>Reading the <code>port</code> attribute will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if an invalid port is specified in the URL. See section <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">Structured Parse Results</span></a> for more information on the result object.</p> <p>Unmatched square brackets in the <code>netloc</code> attribute will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>.</p> <p>Characters in the <code>netloc</code> attribute that decompose under NFKC normalization (as used by the IDNA encoding) into any of <code>/</code>, <code>?</code>, <code>#</code>, <code>@</code>, or <code>:</code> will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>. If the URL is decomposed before parsing, no error will be raised.</p> <p>As is the case with all named tuples, the subclass has a few additional methods and attributes that are particularly useful. One such method is <code>_replace()</code>. The <code>_replace()</code> method will return a new ParseResult object replacing specified fields with new values.</p> <pre data-language="pycon">&gt;&gt;&gt; from urllib.parse import urlparse
&gt;&gt;&gt; u = urlparse('//www.cwi.nl:80/%7Eguido/Python.html')
&gt;&gt;&gt; u
ParseResult(scheme='', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',
            params='', query='', fragment='')
&gt;&gt;&gt; u._replace(scheme='http')
ParseResult(scheme='http', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',
            params='', query='', fragment='')
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code>urlparse()</code></a> does not perform validation. See <a class="reference internal" href="#url-parsing-security"><span class="std std-ref">URL parsing security</span></a> for details.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Added IPv6 URL parsing capabilities.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>The fragment is now parsed for all URL schemes (unless <em>allow_fragments</em> is false), in accordance with <span class="target" id="index-4"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a>. Previously, an allowlist of schemes that support fragments existed.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Out-of-range port numbers now raise <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>, instead of returning <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Characters that affect netloc parsing under NFKC normalization will now raise <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.parse_qs">
<code>urllib.parse.parse_qs(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace', max_num_fields=None, separator='&amp;')</code> </dt> <dd>
<p>Parse a query string given as a string argument (data of type <em class="mimetype">application/x-www-form-urlencoded</em>). Data are returned as a dictionary. The dictionary keys are the unique query variable names and the values are lists of values for each name.</p> <p>The optional argument <em>keep_blank_values</em> is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings. A true value indicates that blanks should be retained as blank strings. The default false value indicates that blank values are to be ignored and treated as if they were not included.</p> <p>The optional argument <em>strict_parsing</em> is a flag indicating what to do with parsing errors. If false (the default), errors are silently ignored. If true, errors raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> exception.</p> <p>The optional <em>encoding</em> and <em>errors</em> parameters specify how to decode percent-encoded sequences into Unicode characters, as accepted by the <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code>bytes.decode()</code></a> method.</p> <p>The optional argument <em>max_num_fields</em> is the maximum number of fields to read. If set, then throws a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if there are more than <em>max_num_fields</em> fields read.</p> <p>The optional argument <em>separator</em> is the symbol to use for separating the query arguments. It defaults to <code>&amp;</code>.</p> <p>Use the <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code>urllib.parse.urlencode()</code></a> function (with the <code>doseq</code> parameter set to <code>True</code>) to convert such dictionaries into query strings.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Add <em>encoding</em> and <em>errors</em> parameters.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added <em>max_num_fields</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>Added <em>separator</em> parameter with the default value of <code>&amp;</code>. Python versions earlier than Python 3.10 allowed using both <code>;</code> and <code>&amp;</code> as query parameter separator. This has been changed to allow only a single separator key, with <code>&amp;</code> as the default separator.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.parse_qsl">
<code>urllib.parse.parse_qsl(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace', max_num_fields=None, separator='&amp;')</code> </dt> <dd>
<p>Parse a query string given as a string argument (data of type <em class="mimetype">application/x-www-form-urlencoded</em>). Data are returned as a list of name, value pairs.</p> <p>The optional argument <em>keep_blank_values</em> is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings. A true value indicates that blanks should be retained as blank strings. The default false value indicates that blank values are to be ignored and treated as if they were not included.</p> <p>The optional argument <em>strict_parsing</em> is a flag indicating what to do with parsing errors. If false (the default), errors are silently ignored. If true, errors raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> exception.</p> <p>The optional <em>encoding</em> and <em>errors</em> parameters specify how to decode percent-encoded sequences into Unicode characters, as accepted by the <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code>bytes.decode()</code></a> method.</p> <p>The optional argument <em>max_num_fields</em> is the maximum number of fields to read. If set, then throws a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if there are more than <em>max_num_fields</em> fields read.</p> <p>The optional argument <em>separator</em> is the symbol to use for separating the query arguments. It defaults to <code>&amp;</code>.</p> <p>Use the <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code>urllib.parse.urlencode()</code></a> function to convert such lists of pairs into query strings.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Add <em>encoding</em> and <em>errors</em> parameters.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added <em>max_num_fields</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>Added <em>separator</em> parameter with the default value of <code>&amp;</code>. Python versions earlier than Python 3.10 allowed using both <code>;</code> and <code>&amp;</code> as query parameter separator. This has been changed to allow only a single separator key, with <code>&amp;</code> as the default separator.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.urlunparse">
<code>urllib.parse.urlunparse(parts)</code> </dt> <dd>
<p>Construct a URL from a tuple as returned by <code>urlparse()</code>. The <em>parts</em> argument can be any six-item iterable. This may result in a slightly different, but equivalent URL, if the URL that was parsed originally had unnecessary delimiters (for example, a <code>?</code> with an empty query; the RFC states that these are equivalent).</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.urlsplit">
<code>urllib.parse.urlsplit(urlstring, scheme='', allow_fragments=True)</code> </dt> <dd>
<p>This is similar to <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code>urlparse()</code></a>, but does not split the params from the URL. This should generally be used instead of <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code>urlparse()</code></a> if the more recent URL syntax allowing parameters to be applied to each segment of the <em>path</em> portion of the URL (see <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2396.html"><strong>RFC 2396</strong></a>) is wanted. A separate function is needed to separate the path segments and parameters. This function returns a 5-item <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>:</p> <pre data-language="python">(addressing scheme, network location, path, query, fragment identifier).
</pre> <p>The return value is a <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>, its items can be accessed by index or as named attributes:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Attribute</p></th> <th class="head"><p>Index</p></th> <th class="head"><p>Value</p></th> <th class="head"><p>Value if not present</p></th> </tr> </thead>  <tr>
<td><p><code>scheme</code></p></td> <td><p>0</p></td> <td><p>URL scheme specifier</p></td> <td><p><em>scheme</em> parameter</p></td> </tr> <tr>
<td><p><code>netloc</code></p></td> <td><p>1</p></td> <td><p>Network location part</p></td> <td><p>empty string</p></td> </tr> <tr>
<td><p><code>path</code></p></td> <td><p>2</p></td> <td><p>Hierarchical path</p></td> <td><p>empty string</p></td> </tr> <tr>
<td><p><code>query</code></p></td> <td><p>3</p></td> <td><p>Query component</p></td> <td><p>empty string</p></td> </tr> <tr>
<td><p><code>fragment</code></p></td> <td><p>4</p></td> <td><p>Fragment identifier</p></td> <td><p>empty string</p></td> </tr> <tr>
<td><p><code>username</code></p></td> <td></td> <td><p>User name</p></td> <td><p><a class="reference internal" href="constants.html#None" title="None"><code>None</code></a></p></td> </tr> <tr>
<td><p><code>password</code></p></td> <td></td> <td><p>Password</p></td> <td><p><a class="reference internal" href="constants.html#None" title="None"><code>None</code></a></p></td> </tr> <tr>
<td><p><code>hostname</code></p></td> <td></td> <td><p>Host name (lower case)</p></td> <td><p><a class="reference internal" href="constants.html#None" title="None"><code>None</code></a></p></td> </tr> <tr>
<td><p><code>port</code></p></td> <td></td> <td><p>Port number as integer, if present</p></td> <td><p><a class="reference internal" href="constants.html#None" title="None"><code>None</code></a></p></td> </tr>  </table> <p>Reading the <code>port</code> attribute will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if an invalid port is specified in the URL. See section <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">Structured Parse Results</span></a> for more information on the result object.</p> <p>Unmatched square brackets in the <code>netloc</code> attribute will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>.</p> <p>Characters in the <code>netloc</code> attribute that decompose under NFKC normalization (as used by the IDNA encoding) into any of <code>/</code>, <code>?</code>, <code>#</code>, <code>@</code>, or <code>:</code> will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>. If the URL is decomposed before parsing, no error will be raised.</p> <p>Following some of the <a class="reference external" href="https://url.spec.whatwg.org/#concept-basic-url-parser">WHATWG spec</a> that updates RFC 3986, leading C0 control and space characters are stripped from the URL. <code>\n</code>, <code>\r</code> and tab <code>\t</code> characters are removed from the URL at any position.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code>urlsplit()</code></a> does not perform validation. See <a class="reference internal" href="#url-parsing-security"><span class="std std-ref">URL parsing security</span></a> for details.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Out-of-range port numbers now raise <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>, instead of returning <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Characters that affect netloc parsing under NFKC normalization will now raise <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>ASCII newline and tab characters are stripped from the URL.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Leading WHATWG C0 control and space characters are stripped from the URL.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.urlunsplit">
<code>urllib.parse.urlunsplit(parts)</code> </dt> <dd>
<p>Combine the elements of a tuple as returned by <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code>urlsplit()</code></a> into a complete URL as a string. The <em>parts</em> argument can be any five-item iterable. This may result in a slightly different, but equivalent URL, if the URL that was parsed originally had unnecessary delimiters (for example, a ? with an empty query; the RFC states that these are equivalent).</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.urljoin">
<code>urllib.parse.urljoin(base, url, allow_fragments=True)</code> </dt> <dd>
<p>Construct a full (“absolute”) URL by combining a “base URL” (<em>base</em>) with another URL (<em>url</em>). Informally, this uses components of the base URL, in particular the addressing scheme, the network location and (part of) the path, to provide missing components in the relative URL. For example:</p> <pre data-language="python">&gt;&gt;&gt; from urllib.parse import urljoin
&gt;&gt;&gt; urljoin('http://www.cwi.nl/%7Eguido/Python.html', 'FAQ.html')
'http://www.cwi.nl/%7Eguido/FAQ.html'
</pre> <p>The <em>allow_fragments</em> argument has the same meaning and default as for <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code>urlparse()</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If <em>url</em> is an absolute URL (that is, it starts with <code>//</code> or <code>scheme://</code>), the <em>url</em>’s hostname and/or scheme will be present in the result. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; urljoin('http://www.cwi.nl/%7Eguido/Python.html',
...         '//www.python.org/%7Eguido')
'http://www.python.org/%7Eguido'
</pre> <p>If you do not want that behavior, preprocess the <em>url</em> with <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code>urlsplit()</code></a> and <a class="reference internal" href="#urllib.parse.urlunsplit" title="urllib.parse.urlunsplit"><code>urlunsplit()</code></a>, removing possible <em>scheme</em> and <em>netloc</em> parts.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Behavior updated to match the semantics defined in <span class="target" id="index-6"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.urldefrag">
<code>urllib.parse.urldefrag(url)</code> </dt> <dd>
<p>If <em>url</em> contains a fragment identifier, return a modified version of <em>url</em> with no fragment identifier, and the fragment identifier as a separate string. If there is no fragment identifier in <em>url</em>, return <em>url</em> unmodified and an empty string.</p> <p>The return value is a <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>, its items can be accessed by index or as named attributes:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>Attribute</p></th> <th class="head"><p>Index</p></th> <th class="head"><p>Value</p></th> <th class="head"><p>Value if not present</p></th> </tr> </thead>  <tr>
<td><p><code>url</code></p></td> <td><p>0</p></td> <td><p>URL with no fragment</p></td> <td><p>empty string</p></td> </tr> <tr>
<td><p><code>fragment</code></p></td> <td><p>1</p></td> <td><p>Fragment identifier</p></td> <td><p>empty string</p></td> </tr>  </table> <p>See section <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">Structured Parse Results</span></a> for more information on the result object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Result is a structured object rather than a simple 2-tuple.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.unwrap">
<code>urllib.parse.unwrap(url)</code> </dt> <dd>
<p>Extract the url from a wrapped URL (that is, a string formatted as <code>&lt;URL:scheme://host/path&gt;</code>, <code>&lt;scheme://host/path&gt;</code>, <code>URL:scheme://host/path</code> or <code>scheme://host/path</code>). If <em>url</em> is not a wrapped URL, it is returned without changes.</p> </dd>
</dl> </section> <section id="url-parsing-security"> <span id="id1"></span><h2>URL parsing security</h2> <p>The <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code>urlsplit()</code></a> and <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code>urlparse()</code></a> APIs do not perform <strong>validation</strong> of inputs. They may not raise errors on inputs that other applications consider invalid. They may also succeed on some inputs that might not be considered URLs elsewhere. Their purpose is for practical functionality rather than purity.</p> <p>Instead of raising an exception on unusual input, they may instead return some component parts as empty strings. Or components may contain more than perhaps they should.</p> <p>We recommend that users of these APIs where the values may be used anywhere with security implications code defensively. Do some verification within your code before trusting a returned component part. Does that <code>scheme</code> make sense? Is that a sensible <code>path</code>? Is there anything strange about that <code>hostname</code>? etc.</p> <p>What constitutes a URL is not universally well defined. Different applications have different needs and desired constraints. For instance the living <a class="reference external" href="https://url.spec.whatwg.org/#concept-basic-url-parser">WHATWG spec</a> describes what user facing web clients such as a web browser require. While <span class="target" id="index-7"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a> is more general. These functions incorporate some aspects of both, but cannot be claimed compliant with either. The APIs and existing user code with expectations on specific behaviors predate both standards leading us to be very cautious about making API behavior changes.</p> </section> <section id="parsing-ascii-encoded-bytes"> <span id="id2"></span><h2>Parsing ASCII Encoded Bytes</h2> <p>The URL parsing functions were originally designed to operate on character strings only. In practice, it is useful to be able to manipulate properly quoted and encoded URLs as sequences of ASCII bytes. Accordingly, the URL parsing functions in this module all operate on <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> and <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> objects in addition to <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> objects.</p> <p>If <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> data is passed in, the result will also contain only <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> data. If <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> or <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> data is passed in, the result will contain only <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> data.</p> <p>Attempting to mix <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> data with <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> or <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> in a single function call will result in a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> being raised, while attempting to pass in non-ASCII byte values will trigger <a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code>UnicodeDecodeError</code></a>.</p> <p>To support easier conversion of result objects between <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> and <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>, all return values from URL parsing functions provide either an <code>encode()</code> method (when the result contains <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> data) or a <code>decode()</code> method (when the result contains <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> data). The signatures of these methods match those of the corresponding <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> and <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> methods (except that the default encoding is <code>'ascii'</code> rather than <code>'utf-8'</code>). Each produces a value of a corresponding type that contains either <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> data (for <code>encode()</code> methods) or <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> data (for <code>decode()</code> methods).</p> <p>Applications that need to operate on potentially improperly quoted URLs that may contain non-ASCII data will need to do their own decoding from bytes to characters before invoking the URL parsing methods.</p> <p>The behaviour described in this section applies only to the URL parsing functions. The URL quoting functions use their own rules when producing or consuming byte sequences as detailed in the documentation of the individual URL quoting functions.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>URL parsing functions now accept ASCII encoded byte sequences</p> </div> </section> <section id="structured-parse-results"> <span id="urlparse-result-object"></span><h2>Structured Parse Results</h2> <p>The result objects from the <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code>urlparse()</code></a>, <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code>urlsplit()</code></a> and <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code>urldefrag()</code></a> functions are subclasses of the <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code>tuple</code></a> type. These subclasses add the attributes listed in the documentation for those functions, the encoding and decoding support described in the previous section, as well as an additional method:</p> <dl class="py method"> <dt class="sig sig-object py" id="urllib.parse.urllib.parse.SplitResult.geturl">
<code>urllib.parse.SplitResult.geturl()</code> </dt> <dd>
<p>Return the re-combined version of the original URL as a string. This may differ from the original URL in that the scheme may be normalized to lower case and empty components may be dropped. Specifically, empty parameters, queries, and fragment identifiers will be removed.</p> <p>For <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code>urldefrag()</code></a> results, only empty fragment identifiers will be removed. For <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code>urlsplit()</code></a> and <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code>urlparse()</code></a> results, all noted changes will be made to the URL returned by this method.</p> <p>The result of this method remains unchanged if passed back through the original parsing function:</p> <pre data-language="python">&gt;&gt;&gt; from urllib.parse import urlsplit
&gt;&gt;&gt; url = 'HTTP://www.Python.org/doc/#'
&gt;&gt;&gt; r1 = urlsplit(url)
&gt;&gt;&gt; r1.geturl()
'http://www.Python.org/doc/'
&gt;&gt;&gt; r2 = urlsplit(r1.geturl())
&gt;&gt;&gt; r2.geturl()
'http://www.Python.org/doc/'
</pre> </dd>
</dl> <p>The following classes provide the implementations of the structured parse results when operating on <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> objects:</p> <dl class="py class"> <dt class="sig sig-object py" id="urllib.parse.DefragResult">
<code>class urllib.parse.DefragResult(url, fragment)</code> </dt> <dd>
<p>Concrete class for <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code>urldefrag()</code></a> results containing <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> data. The <code>encode()</code> method returns a <a class="reference internal" href="#urllib.parse.DefragResultBytes" title="urllib.parse.DefragResultBytes"><code>DefragResultBytes</code></a> instance.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="urllib.parse.ParseResult">
<code>class urllib.parse.ParseResult(scheme, netloc, path, params, query, fragment)</code> </dt> <dd>
<p>Concrete class for <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code>urlparse()</code></a> results containing <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> data. The <code>encode()</code> method returns a <a class="reference internal" href="#urllib.parse.ParseResultBytes" title="urllib.parse.ParseResultBytes"><code>ParseResultBytes</code></a> instance.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="urllib.parse.SplitResult">
<code>class urllib.parse.SplitResult(scheme, netloc, path, query, fragment)</code> </dt> <dd>
<p>Concrete class for <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code>urlsplit()</code></a> results containing <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> data. The <code>encode()</code> method returns a <a class="reference internal" href="#urllib.parse.SplitResultBytes" title="urllib.parse.SplitResultBytes"><code>SplitResultBytes</code></a> instance.</p> </dd>
</dl> <p>The following classes provide the implementations of the parse results when operating on <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> or <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> objects:</p> <dl class="py class"> <dt class="sig sig-object py" id="urllib.parse.DefragResultBytes">
<code>class urllib.parse.DefragResultBytes(url, fragment)</code> </dt> <dd>
<p>Concrete class for <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code>urldefrag()</code></a> results containing <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> data. The <code>decode()</code> method returns a <a class="reference internal" href="#urllib.parse.DefragResult" title="urllib.parse.DefragResult"><code>DefragResult</code></a> instance.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="urllib.parse.ParseResultBytes">
<code>class urllib.parse.ParseResultBytes(scheme, netloc, path, params, query, fragment)</code> </dt> <dd>
<p>Concrete class for <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code>urlparse()</code></a> results containing <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> data. The <code>decode()</code> method returns a <a class="reference internal" href="#urllib.parse.ParseResult" title="urllib.parse.ParseResult"><code>ParseResult</code></a> instance.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="urllib.parse.SplitResultBytes">
<code>class urllib.parse.SplitResultBytes(scheme, netloc, path, query, fragment)</code> </dt> <dd>
<p>Concrete class for <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code>urlsplit()</code></a> results containing <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> data. The <code>decode()</code> method returns a <a class="reference internal" href="#urllib.parse.SplitResult" title="urllib.parse.SplitResult"><code>SplitResult</code></a> instance.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> </section> <section id="url-quoting"> <h2>URL Quoting</h2> <p>The URL quoting functions focus on taking program data and making it safe for use as URL components by quoting special characters and appropriately encoding non-ASCII text. They also support reversing these operations to recreate the original data from the contents of a URL component if that task isn’t already covered by the URL parsing functions above.</p> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.quote">
<code>urllib.parse.quote(string, safe='/', encoding=None, errors=None)</code> </dt> <dd>
<p>Replace special characters in <em>string</em> using the <code>%<em>xx</em></code> escape. Letters, digits, and the characters <code>'_.-~'</code> are never quoted. By default, this function is intended for quoting the path section of a URL. The optional <em>safe</em> parameter specifies additional ASCII characters that should not be quoted — its default value is <code>'/'</code>.</p> <p><em>string</em> may be either a <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> or a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Moved from <span class="target" id="index-8"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2396.html"><strong>RFC 2396</strong></a> to <span class="target" id="index-9"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a> for quoting URL strings. “~” is now included in the set of unreserved characters.</p> </div> <p>The optional <em>encoding</em> and <em>errors</em> parameters specify how to deal with non-ASCII characters, as accepted by the <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code>str.encode()</code></a> method. <em>encoding</em> defaults to <code>'utf-8'</code>. <em>errors</em> defaults to <code>'strict'</code>, meaning unsupported characters raise a <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code>UnicodeEncodeError</code></a>. <em>encoding</em> and <em>errors</em> must not be supplied if <em>string</em> is a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a>, or a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> is raised.</p> <p>Note that <code>quote(string, safe, encoding, errors)</code> is equivalent to <code>quote_from_bytes(string.encode(encoding, errors), safe)</code>.</p> <p>Example: <code>quote('/El Niño/')</code> yields <code>'/El%20Ni%C3%B1o/'</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.quote_plus">
<code>urllib.parse.quote_plus(string, safe='', encoding=None, errors=None)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code>quote()</code></a>, but also replace spaces with plus signs, as required for quoting HTML form values when building up a query string to go into a URL. Plus signs in the original string are escaped unless they are included in <em>safe</em>. It also does not have <em>safe</em> default to <code>'/'</code>.</p> <p>Example: <code>quote_plus('/El Niño/')</code> yields <code>'%2FEl+Ni%C3%B1o%2F'</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.quote_from_bytes">
<code>urllib.parse.quote_from_bytes(bytes, safe='/')</code> </dt> <dd>
<p>Like <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code>quote()</code></a>, but accepts a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object rather than a <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a>, and does not perform string-to-bytes encoding.</p> <p>Example: <code>quote_from_bytes(b'a&amp;\xef')</code> yields <code>'a%26%EF'</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.unquote">
<code>urllib.parse.unquote(string, encoding='utf-8', errors='replace')</code> </dt> <dd>
<p>Replace <code>%<em>xx</em></code> escapes with their single-character equivalent. The optional <em>encoding</em> and <em>errors</em> parameters specify how to decode percent-encoded sequences into Unicode characters, as accepted by the <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code>bytes.decode()</code></a> method.</p> <p><em>string</em> may be either a <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> or a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object.</p> <p><em>encoding</em> defaults to <code>'utf-8'</code>. <em>errors</em> defaults to <code>'replace'</code>, meaning invalid sequences are replaced by a placeholder character.</p> <p>Example: <code>unquote('/El%20Ni%C3%B1o/')</code> yields <code>'/El Niño/'</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span><em>string</em> parameter supports bytes and str objects (previously only str).</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.unquote_plus">
<code>urllib.parse.unquote_plus(string, encoding='utf-8', errors='replace')</code> </dt> <dd>
<p>Like <a class="reference internal" href="#urllib.parse.unquote" title="urllib.parse.unquote"><code>unquote()</code></a>, but also replace plus signs with spaces, as required for unquoting HTML form values.</p> <p><em>string</em> must be a <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a>.</p> <p>Example: <code>unquote_plus('/El+Ni%C3%B1o/')</code> yields <code>'/El Niño/'</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.unquote_to_bytes">
<code>urllib.parse.unquote_to_bytes(string)</code> </dt> <dd>
<p>Replace <code>%<em>xx</em></code> escapes with their single-octet equivalent, and return a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object.</p> <p><em>string</em> may be either a <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> or a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> object.</p> <p>If it is a <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a>, unescaped non-ASCII characters in <em>string</em> are encoded into UTF-8 bytes.</p> <p>Example: <code>unquote_to_bytes('a%26%EF')</code> yields <code>b'a&amp;\xef'</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="urllib.parse.urlencode">
<code>urllib.parse.urlencode(query, doseq=False, safe='', encoding=None, errors=None, quote_via=quote_plus)</code> </dt> <dd>
<p>Convert a mapping object or a sequence of two-element tuples, which may contain <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a> or <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code>bytes</code></a> objects, to a percent-encoded ASCII text string. If the resultant string is to be used as a <em>data</em> for POST operation with the <a class="reference internal" href="urllib.request.html#urllib.request.urlopen" title="urllib.request.urlopen"><code>urlopen()</code></a> function, then it should be encoded to bytes, otherwise it would result in a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>.</p> <p>The resulting string is a series of <code>key=value</code> pairs separated by <code>'&amp;'</code> characters, where both <em>key</em> and <em>value</em> are quoted using the <em>quote_via</em> function. By default, <a class="reference internal" href="#urllib.parse.quote_plus" title="urllib.parse.quote_plus"><code>quote_plus()</code></a> is used to quote the values, which means spaces are quoted as a <code>'+'</code> character and ‘/’ characters are encoded as <code>%2F</code>, which follows the standard for GET requests (<code>application/x-www-form-urlencoded</code>). An alternate function that can be passed as <em>quote_via</em> is <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code>quote()</code></a>, which will encode spaces as <code>%20</code> and not encode ‘/’ characters. For maximum control of what is quoted, use <code>quote</code> and specify a value for <em>safe</em>.</p> <p>When a sequence of two-element tuples is used as the <em>query</em> argument, the first element of each tuple is a key and the second is a value. The value element in itself can be a sequence and in that case, if the optional parameter <em>doseq</em> evaluates to <code>True</code>, individual <code>key=value</code> pairs separated by <code>'&amp;'</code> are generated for each element of the value sequence for the key. The order of parameters in the encoded string will match the order of parameter tuples in the sequence.</p> <p>The <em>safe</em>, <em>encoding</em>, and <em>errors</em> parameters are passed down to <em>quote_via</em> (the <em>encoding</em> and <em>errors</em> parameters are only passed when a query element is a <a class="reference internal" href="stdtypes.html#str" title="str"><code>str</code></a>).</p> <p>To reverse this encoding process, <a class="reference internal" href="#urllib.parse.parse_qs" title="urllib.parse.parse_qs"><code>parse_qs()</code></a> and <a class="reference internal" href="#urllib.parse.parse_qsl" title="urllib.parse.parse_qsl"><code>parse_qsl()</code></a> are provided in this module to parse query strings into Python data structures.</p> <p>Refer to <a class="reference internal" href="urllib.request.html#urllib-examples"><span class="std std-ref">urllib examples</span></a> to find out how the <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code>urllib.parse.urlencode()</code></a> method can be used for generating the query string of a URL or data for a POST request.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span><em>query</em> supports bytes and string objects.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Added the <em>quote_via</em> parameter.</p> </div> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="reference external" href="https://url.spec.whatwg.org/">WHATWG</a> - URL Living standard</dt>
<dd>
<p>Working Group for the URL Standard that defines URLs, domains, IP addresses, the application/x-www-form-urlencoded format, and their API.</p> </dd> <dt>
<span class="target" id="index-10"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a> - Uniform Resource Identifiers</dt>
<dd>
<p>This is the current standard (STD66). Any changes to urllib.parse module should conform to this. Certain deviations could be observed, which are mostly for backward compatibility purposes and for certain de-facto parsing requirements as commonly observed in major browsers.</p> </dd> <dt>
<span class="target" id="index-11"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2732.html"><strong>RFC 2732</strong></a> - Format for Literal IPv6 Addresses in URL’s.</dt>
<dd>
<p>This specifies the parsing requirements of IPv6 URLs.</p> </dd> <dt>
<span class="target" id="index-12"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2396.html"><strong>RFC 2396</strong></a> - Uniform Resource Identifiers (URI): Generic Syntax</dt>
<dd>
<p>Document describing the generic syntactic requirements for both Uniform Resource Names (URNs) and Uniform Resource Locators (URLs).</p> </dd> <dt>
<span class="target" id="index-13"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2368.html"><strong>RFC 2368</strong></a> - The mailto URL scheme.</dt>
<dd>
<p>Parsing requirements for mailto URL schemes.</p> </dd> <dt>
<span class="target" id="index-14"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1808.html"><strong>RFC 1808</strong></a> - Relative Uniform Resource Locators</dt>
<dd>
<p>This Request For Comments includes the rules for joining an absolute and a relative URL, including a fair number of “Abnormal Examples” which govern the treatment of border cases.</p> </dd> <dt>
<span class="target" id="index-15"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1738.html"><strong>RFC 1738</strong></a> - Uniform Resource Locators (URL)</dt>
<dd>
<p>This specifies the formal syntax and semantics of absolute URLs.</p> </dd> </dl> </div> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/urllib.parse.html" class="_attribution-link">https://docs.python.org/3.13/library/urllib.parse.html</a>
  </p>
</div>
