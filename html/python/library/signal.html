 <span id="signal-set-handlers-for-asynchronous-events"></span><h1>signal — Set handlers for asynchronous events</h1> <p><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/signal.py">Lib/signal.py</a></p>  <p>This module provides mechanisms to use signal handlers in Python.</p> <section id="general-rules"> <h2>General rules</h2> <p>The <a class="reference internal" href="#signal.signal" title="signal.signal"><code>signal.signal()</code></a> function allows defining custom handlers to be executed when a signal is received. A small number of default handlers are installed: <a class="reference internal" href="#signal.SIGPIPE" title="signal.SIGPIPE"><code>SIGPIPE</code></a> is ignored (so write errors on pipes and sockets can be reported as ordinary Python exceptions) and <a class="reference internal" href="#signal.SIGINT" title="signal.SIGINT"><code>SIGINT</code></a> is translated into a <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a> exception if the parent process has not changed it.</p> <p>A handler for a particular signal, once set, remains installed until it is explicitly reset (Python emulates the BSD style interface regardless of the underlying implementation), with the exception of the handler for <a class="reference internal" href="#signal.SIGCHLD" title="signal.SIGCHLD"><code>SIGCHLD</code></a>, which follows the underlying implementation.</p> <p>On WebAssembly platforms, signals are emulated and therefore behave differently. Several functions and signals are not available on these platforms.</p> <section id="execution-of-python-signal-handlers"> <h3>Execution of Python signal handlers</h3> <p>A Python signal handler does not get executed inside the low-level (C) signal handler. Instead, the low-level signal handler sets a flag which tells the <a class="reference internal" href="../glossary.html#term-virtual-machine"><span class="xref std std-term">virtual machine</span></a> to execute the corresponding Python signal handler at a later point(for example at the next <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> instruction). This has consequences:</p> <ul class="simple"> <li>It makes little sense to catch synchronous errors like <a class="reference internal" href="#signal.SIGFPE" title="signal.SIGFPE"><code>SIGFPE</code></a> or <a class="reference internal" href="#signal.SIGSEGV" title="signal.SIGSEGV"><code>SIGSEGV</code></a> that are caused by an invalid operation in C code. Python will return from the signal handler to the C code, which is likely to raise the same signal again, causing Python to apparently hang. From Python 3.3 onwards, you can use the <a class="reference internal" href="faulthandler.html#module-faulthandler" title="faulthandler: Dump the Python traceback."><code>faulthandler</code></a> module to report on synchronous errors.</li> <li>A long-running calculation implemented purely in C (such as regular expression matching on a large body of text) may run uninterrupted for an arbitrary amount of time, regardless of any signals received. The Python signal handlers will be called when the calculation finishes.</li> <li>If the handler raises an exception, it will be raised “out of thin air” in the main thread. See the <a class="reference internal" href="#handlers-and-exceptions"><span class="std std-ref">note below</span></a> for a discussion.</li> </ul> </section> <section id="signals-and-threads"> <span id="id1"></span><h3>Signals and threads</h3> <p>Python signal handlers are always executed in the main Python thread of the main interpreter, even if the signal was received in another thread. This means that signals can’t be used as a means of inter-thread communication. You can use the synchronization primitives from the <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code>threading</code></a> module instead.</p> <p>Besides, only the main thread of the main interpreter is allowed to set a new signal handler.</p> </section> </section> <section id="module-contents"> <h2>Module contents</h2> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>signal (SIG*), handler (<a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code>SIG_DFL</code></a>, <a class="reference internal" href="#signal.SIG_IGN" title="signal.SIG_IGN"><code>SIG_IGN</code></a>) and sigmask (<a class="reference internal" href="#signal.SIG_BLOCK" title="signal.SIG_BLOCK"><code>SIG_BLOCK</code></a>, <a class="reference internal" href="#signal.SIG_UNBLOCK" title="signal.SIG_UNBLOCK"><code>SIG_UNBLOCK</code></a>, <a class="reference internal" href="#signal.SIG_SETMASK" title="signal.SIG_SETMASK"><code>SIG_SETMASK</code></a>) related constants listed below were turned into <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code>enums</code></a> (<a class="reference internal" href="#signal.Signals" title="signal.Signals"><code>Signals</code></a>, <a class="reference internal" href="#signal.Handlers" title="signal.Handlers"><code>Handlers</code></a> and <a class="reference internal" href="#signal.Sigmasks" title="signal.Sigmasks"><code>Sigmasks</code></a> respectively). <a class="reference internal" href="#signal.getsignal" title="signal.getsignal"><code>getsignal()</code></a>, <a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code>pthread_sigmask()</code></a>, <a class="reference internal" href="#signal.sigpending" title="signal.sigpending"><code>sigpending()</code></a> and <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code>sigwait()</code></a> functions return human-readable <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code>enums</code></a> as <a class="reference internal" href="#signal.Signals" title="signal.Signals"><code>Signals</code></a> objects.</p> </div> <p>The signal module defines three enums:</p> <dl class="py class"> <dt class="sig sig-object py" id="signal.Signals">
<code>class signal.Signals</code> </dt> <dd>
<p><a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code>enum.IntEnum</code></a> collection of SIG* constants and the CTRL_* constants.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="signal.Handlers">
<code>class signal.Handlers</code> </dt> <dd>
<p><a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code>enum.IntEnum</code></a> collection the constants <a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code>SIG_DFL</code></a> and <a class="reference internal" href="#signal.SIG_IGN" title="signal.SIG_IGN"><code>SIG_IGN</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="signal.Sigmasks">
<code>class signal.Sigmasks</code> </dt> <dd>
<p><a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code>enum.IntEnum</code></a> collection the constants <a class="reference internal" href="#signal.SIG_BLOCK" title="signal.SIG_BLOCK"><code>SIG_BLOCK</code></a>, <a class="reference internal" href="#signal.SIG_UNBLOCK" title="signal.SIG_UNBLOCK"><code>SIG_UNBLOCK</code></a> and <a class="reference internal" href="#signal.SIG_SETMASK" title="signal.SIG_SETMASK"><code>SIG_SETMASK</code></a>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> <p>See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigprocmask(2)">sigprocmask(2)</a></em> and <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/pthread_sigmask(3)">pthread_sigmask(3)</a></em> for further information.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.5.</span></p> </div> </dd>
</dl> <p>The variables defined in the <a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code>signal</code></a> module are:</p> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIG_DFL">
<code>signal.SIG_DFL</code> </dt> <dd>
<p>This is one of two standard signal handling options; it will simply perform the default function for the signal. For example, on most systems the default action for <code>SIGQUIT</code> is to dump core and exit, while the default action for <a class="reference internal" href="#signal.SIGCHLD" title="signal.SIGCHLD"><code>SIGCHLD</code></a> is to simply ignore it.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIG_IGN">
<code>signal.SIG_IGN</code> </dt> <dd>
<p>This is another standard signal handler, which will simply ignore the given signal.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGABRT">
<code>signal.SIGABRT</code> </dt> <dd>
<p>Abort signal from <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/abort(3)">abort(3)</a></em>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGALRM">
<code>signal.SIGALRM</code> </dt> <dd>
<p>Timer signal from <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/alarm(2)">alarm(2)</a></em>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGBREAK">
<code>signal.SIGBREAK</code> </dt> <dd>
<p>Interrupt from keyboard (CTRL + BREAK).</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGBUS">
<code>signal.SIGBUS</code> </dt> <dd>
<p>Bus error (bad memory access).</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGCHLD">
<code>signal.SIGCHLD</code> </dt> <dd>
<p>Child process stopped or terminated.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGCLD">
<code>signal.SIGCLD</code> </dt> <dd>
<p>Alias to <a class="reference internal" href="#signal.SIGCHLD" title="signal.SIGCHLD"><code>SIGCHLD</code></a>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: not macOS.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGCONT">
<code>signal.SIGCONT</code> </dt> <dd>
<p>Continue the process if it is currently stopped</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGFPE">
<code>signal.SIGFPE</code> </dt> <dd>
<p>Floating-point exception. For example, division by zero.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code>ZeroDivisionError</code></a> is raised when the second argument of a division or modulo operation is zero.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGHUP">
<code>signal.SIGHUP</code> </dt> <dd>
<p>Hangup detected on controlling terminal or death of controlling process.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGILL">
<code>signal.SIGILL</code> </dt> <dd>
<p>Illegal instruction.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGINT">
<code>signal.SIGINT</code> </dt> <dd>
<p>Interrupt from keyboard (CTRL + C).</p> <p>Default action is to raise <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGKILL">
<code>signal.SIGKILL</code> </dt> <dd>
<p>Kill signal.</p> <p>It cannot be caught, blocked, or ignored.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGPIPE">
<code>signal.SIGPIPE</code> </dt> <dd>
<p>Broken pipe: write to pipe with no readers.</p> <p>Default action is to ignore the signal.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGSEGV">
<code>signal.SIGSEGV</code> </dt> <dd>
<p>Segmentation fault: invalid memory reference.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGSTKFLT">
<code>signal.SIGSTKFLT</code> </dt> <dd> <p>Stack fault on coprocessor. The Linux kernel does not raise this signal: it can only be raised in user space.</p>  <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux.</p> <p>On architectures where the signal is available. See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/signal(7)">signal(7)</a></em> for further information.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.11.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGTERM">
<code>signal.SIGTERM</code> </dt> <dd>
<p>Termination signal.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGUSR1">
<code>signal.SIGUSR1</code> </dt> <dd>
<p>User-defined signal 1.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGUSR2">
<code>signal.SIGUSR2</code> </dt> <dd>
<p>User-defined signal 2.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIGWINCH">
<code>signal.SIGWINCH</code> </dt> <dd>
<p>Window resize signal.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py"> <span class="sig-name descname">SIG*</span>
</dt> <dd>
<p>All the signal numbers are defined symbolically. For example, the hangup signal is defined as <a class="reference internal" href="#signal.SIGHUP" title="signal.SIGHUP"><code>signal.SIGHUP</code></a>; the variable names are identical to the names used in C programs, as found in <code>&lt;signal.h&gt;</code>. The Unix man page for ‘<code>signal()</code>’ lists the existing signals (on some systems this is <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/signal(2)">signal(2)</a></em>, on others the list is in <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/signal(7)">signal(7)</a></em>). Note that not all systems define the same set of signal names; only those names defined by the system are defined by this module.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.CTRL_C_EVENT">
<code>signal.CTRL_C_EVENT</code> </dt> <dd>
<p>The signal corresponding to the <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>+<kbd class="kbd docutils literal notranslate">C</kbd></kbd> keystroke event. This signal can only be used with <a class="reference internal" href="os.html#os.kill" title="os.kill"><code>os.kill()</code></a>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.CTRL_BREAK_EVENT">
<code>signal.CTRL_BREAK_EVENT</code> </dt> <dd>
<p>The signal corresponding to the <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>+<kbd class="kbd docutils literal notranslate">Break</kbd></kbd> keystroke event. This signal can only be used with <a class="reference internal" href="os.html#os.kill" title="os.kill"><code>os.kill()</code></a>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.NSIG">
<code>signal.NSIG</code> </dt> <dd>
<p>One more than the number of the highest signal number. Use <a class="reference internal" href="#signal.valid_signals" title="signal.valid_signals"><code>valid_signals()</code></a> to get valid signal numbers.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.ITIMER_REAL">
<code>signal.ITIMER_REAL</code> </dt> <dd>
<p>Decrements interval timer in real time, and delivers <a class="reference internal" href="#signal.SIGALRM" title="signal.SIGALRM"><code>SIGALRM</code></a> upon expiration.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.ITIMER_VIRTUAL">
<code>signal.ITIMER_VIRTUAL</code> </dt> <dd>
<p>Decrements interval timer only when the process is executing, and delivers SIGVTALRM upon expiration.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.ITIMER_PROF">
<code>signal.ITIMER_PROF</code> </dt> <dd>
<p>Decrements interval timer both when the process executes and when the system is executing on behalf of the process. Coupled with ITIMER_VIRTUAL, this timer is usually used to profile the time spent by the application in user and kernel space. SIGPROF is delivered upon expiration.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIG_BLOCK">
<code>signal.SIG_BLOCK</code> </dt> <dd>
<p>A possible value for the <em>how</em> parameter to <a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code>pthread_sigmask()</code></a> indicating that signals are to be blocked.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIG_UNBLOCK">
<code>signal.SIG_UNBLOCK</code> </dt> <dd>
<p>A possible value for the <em>how</em> parameter to <a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code>pthread_sigmask()</code></a> indicating that signals are to be unblocked.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="signal.SIG_SETMASK">
<code>signal.SIG_SETMASK</code> </dt> <dd>
<p>A possible value for the <em>how</em> parameter to <a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code>pthread_sigmask()</code></a> indicating that the signal mask is to be replaced.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <p>The <a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code>signal</code></a> module defines one exception:</p> <dl class="py exception"> <dt class="sig sig-object py" id="signal.ItimerError">
<code>exception signal.ItimerError</code> </dt> <dd>
<p>Raised to signal an error from the underlying <a class="reference internal" href="#signal.setitimer" title="signal.setitimer"><code>setitimer()</code></a> or <a class="reference internal" href="#signal.getitimer" title="signal.getitimer"><code>getitimer()</code></a> implementation. Expect this error if an invalid interval timer or a negative time is passed to <a class="reference internal" href="#signal.setitimer" title="signal.setitimer"><code>setitimer()</code></a>. This error is a subtype of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3: </span>This error used to be a subtype of <a class="reference internal" href="exceptions.html#IOError" title="IOError"><code>IOError</code></a>, which is now an alias of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a>.</p> </div> </dd>
</dl> <p>The <a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code>signal</code></a> module defines the following functions:</p> <dl class="py function"> <dt class="sig sig-object py" id="signal.alarm">
<code>signal.alarm(time)</code> </dt> <dd>
<p>If <em>time</em> is non-zero, this function requests that a <a class="reference internal" href="#signal.SIGALRM" title="signal.SIGALRM"><code>SIGALRM</code></a> signal be sent to the process in <em>time</em> seconds. Any previously scheduled alarm is canceled (only one alarm can be scheduled at any time). The returned value is then the number of seconds before any previously set alarm was to have been delivered. If <em>time</em> is zero, no alarm is scheduled, and any scheduled alarm is canceled. If the return value is zero, no alarm is currently scheduled.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> <p>See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/alarm(2)">alarm(2)</a></em> for further information.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.getsignal">
<code>signal.getsignal(signalnum)</code> </dt> <dd>
<p>Return the current signal handler for the signal <em>signalnum</em>. The returned value may be a callable Python object, or one of the special values <a class="reference internal" href="#signal.SIG_IGN" title="signal.SIG_IGN"><code>signal.SIG_IGN</code></a>, <a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code>signal.SIG_DFL</code></a> or <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a>. Here, <a class="reference internal" href="#signal.SIG_IGN" title="signal.SIG_IGN"><code>signal.SIG_IGN</code></a> means that the signal was previously ignored, <a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code>signal.SIG_DFL</code></a> means that the default way of handling the signal was previously in use, and <code>None</code> means that the previous signal handler was not installed from Python.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.strsignal">
<code>signal.strsignal(signalnum)</code> </dt> <dd>
<p>Returns the description of signal <em>signalnum</em>, such as “Interrupt” for <a class="reference internal" href="#signal.SIGINT" title="signal.SIGINT"><code>SIGINT</code></a>. Returns <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a> if <em>signalnum</em> has no description. Raises <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> if <em>signalnum</em> is invalid.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.valid_signals">
<code>signal.valid_signals()</code> </dt> <dd>
<p>Return the set of valid signal numbers on this platform. This can be less than <code>range(1, NSIG)</code> if some signals are reserved by the system for internal use.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.pause">
<code>signal.pause()</code> </dt> <dd>
<p>Cause the process to sleep until a signal is received; the appropriate handler will then be called. Returns nothing.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> <p>See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/signal(2)">signal(2)</a></em> for further information.</p> </div> <p>See also <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code>sigwait()</code></a>, <a class="reference internal" href="#signal.sigwaitinfo" title="signal.sigwaitinfo"><code>sigwaitinfo()</code></a>, <a class="reference internal" href="#signal.sigtimedwait" title="signal.sigtimedwait"><code>sigtimedwait()</code></a> and <a class="reference internal" href="#signal.sigpending" title="signal.sigpending"><code>sigpending()</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.raise_signal">
<code>signal.raise_signal(signum)</code> </dt> <dd>
<p>Sends a signal to the calling process. Returns nothing.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.8.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.pidfd_send_signal">
<code>signal.pidfd_send_signal(pidfd, sig, siginfo=None, flags=0)</code> </dt> <dd>
<p>Send signal <em>sig</em> to the process referred to by file descriptor <em>pidfd</em>. Python does not currently support the <em>siginfo</em> parameter; it must be <code>None</code>. The <em>flags</em> argument is provided for future extensions; no flag values are currently defined.</p> <p>See the <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/pidfd_send_signal(2)">pidfd_send_signal(2)</a></em> man page for more information.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 5.1</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.9.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.pthread_kill">
<code>signal.pthread_kill(thread_id, signalnum)</code> </dt> <dd>
<p>Send the signal <em>signalnum</em> to the thread <em>thread_id</em>, another thread in the same process as the caller. The target thread can be executing any code (Python or not). However, if the target thread is executing the Python interpreter, the Python signal handlers will be <a class="reference internal" href="#signals-and-threads"><span class="std std-ref">executed by the main thread of the main interpreter</span></a>. Therefore, the only point of sending a signal to a particular Python thread would be to force a running system call to fail with <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code>InterruptedError</code></a>.</p> <p>Use <a class="reference internal" href="threading.html#threading.get_ident" title="threading.get_ident"><code>threading.get_ident()</code></a> or the <a class="reference internal" href="threading.html#threading.Thread.ident" title="threading.Thread.ident"><code>ident</code></a> attribute of <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code>threading.Thread</code></a> objects to get a suitable value for <em>thread_id</em>.</p> <p>If <em>signalnum</em> is 0, then no signal is sent, but error checking is still performed; this can be used to check if the target thread is still running.</p> <p class="audit-hook">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code>signal.pthread_kill</code> with arguments <code>thread_id</code>, <code>signalnum</code>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> <p>See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/pthread_kill(3)">pthread_kill(3)</a></em> for further information.</p> </div> <p>See also <a class="reference internal" href="os.html#os.kill" title="os.kill"><code>os.kill()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.pthread_sigmask">
<code>signal.pthread_sigmask(how, mask)</code> </dt> <dd>
<p>Fetch and/or change the signal mask of the calling thread. The signal mask is the set of signals whose delivery is currently blocked for the caller. Return the old signal mask as a set of signals.</p> <p>The behavior of the call is dependent on the value of <em>how</em>, as follows.</p> <ul class="simple"> <li>
<a class="reference internal" href="#signal.SIG_BLOCK" title="signal.SIG_BLOCK"><code>SIG_BLOCK</code></a>: The set of blocked signals is the union of the current set and the <em>mask</em> argument.</li> <li>
<a class="reference internal" href="#signal.SIG_UNBLOCK" title="signal.SIG_UNBLOCK"><code>SIG_UNBLOCK</code></a>: The signals in <em>mask</em> are removed from the current set of blocked signals. It is permissible to attempt to unblock a signal which is not blocked.</li> <li>
<a class="reference internal" href="#signal.SIG_SETMASK" title="signal.SIG_SETMASK"><code>SIG_SETMASK</code></a>: The set of blocked signals is set to the <em>mask</em> argument.</li> </ul> <p><em>mask</em> is a set of signal numbers (e.g. {<a class="reference internal" href="#signal.SIGINT" title="signal.SIGINT"><code>signal.SIGINT</code></a>, <a class="reference internal" href="#signal.SIGTERM" title="signal.SIGTERM"><code>signal.SIGTERM</code></a>}). Use <a class="reference internal" href="#signal.valid_signals" title="signal.valid_signals"><code>valid_signals()</code></a> for a full mask including all signals.</p> <p>For example, <code>signal.pthread_sigmask(signal.SIG_BLOCK, [])</code> reads the signal mask of the calling thread.</p> <p><a class="reference internal" href="#signal.SIGKILL" title="signal.SIGKILL"><code>SIGKILL</code></a> and <code>SIGSTOP</code> cannot be blocked.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> <p>See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigprocmask(2)">sigprocmask(2)</a></em> and <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/pthread_sigmask(3)">pthread_sigmask(3)</a></em> for further information.</p> </div> <p>See also <a class="reference internal" href="#signal.pause" title="signal.pause"><code>pause()</code></a>, <a class="reference internal" href="#signal.sigpending" title="signal.sigpending"><code>sigpending()</code></a> and <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code>sigwait()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.setitimer">
<code>signal.setitimer(which, seconds, interval=0.0)</code> </dt> <dd>
<p>Sets given interval timer (one of <a class="reference internal" href="#signal.ITIMER_REAL" title="signal.ITIMER_REAL"><code>signal.ITIMER_REAL</code></a>, <a class="reference internal" href="#signal.ITIMER_VIRTUAL" title="signal.ITIMER_VIRTUAL"><code>signal.ITIMER_VIRTUAL</code></a> or <a class="reference internal" href="#signal.ITIMER_PROF" title="signal.ITIMER_PROF"><code>signal.ITIMER_PROF</code></a>) specified by <em>which</em> to fire after <em>seconds</em> (float is accepted, different from <a class="reference internal" href="#signal.alarm" title="signal.alarm"><code>alarm()</code></a>) and after that every <em>interval</em> seconds (if <em>interval</em> is non-zero). The interval timer specified by <em>which</em> can be cleared by setting <em>seconds</em> to zero.</p> <p>When an interval timer fires, a signal is sent to the process. The signal sent is dependent on the timer being used; <a class="reference internal" href="#signal.ITIMER_REAL" title="signal.ITIMER_REAL"><code>signal.ITIMER_REAL</code></a> will deliver <a class="reference internal" href="#signal.SIGALRM" title="signal.SIGALRM"><code>SIGALRM</code></a>, <a class="reference internal" href="#signal.ITIMER_VIRTUAL" title="signal.ITIMER_VIRTUAL"><code>signal.ITIMER_VIRTUAL</code></a> sends <code>SIGVTALRM</code>, and <a class="reference internal" href="#signal.ITIMER_PROF" title="signal.ITIMER_PROF"><code>signal.ITIMER_PROF</code></a> will deliver <code>SIGPROF</code>.</p> <p>The old values are returned as a tuple: (delay, interval).</p> <p>Attempting to pass an invalid interval timer will cause an <a class="reference internal" href="#signal.ItimerError" title="signal.ItimerError"><code>ItimerError</code></a>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.getitimer">
<code>signal.getitimer(which)</code> </dt> <dd>
<p>Returns current value of a given interval timer specified by <em>which</em>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.set_wakeup_fd">
<code>signal.set_wakeup_fd(fd, *, warn_on_full_buffer=True)</code> </dt> <dd>
<p>Set the wakeup file descriptor to <em>fd</em>. When a signal is received, the signal number is written as a single byte into the fd. This can be used by a library to wakeup a poll or select call, allowing the signal to be fully processed.</p> <p>The old wakeup fd is returned (or -1 if file descriptor wakeup was not enabled). If <em>fd</em> is -1, file descriptor wakeup is disabled. If not -1, <em>fd</em> must be non-blocking. It is up to the library to remove any bytes from <em>fd</em> before calling poll or select again.</p> <p>When threads are enabled, this function can only be called from <a class="reference internal" href="#signals-and-threads"><span class="std std-ref">the main thread of the main interpreter</span></a>; attempting to call it from other threads will cause a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> exception to be raised.</p> <p>There are two common ways to use this function. In both approaches, you use the fd to wake up when a signal arrives, but then they differ in how they determine <em>which</em> signal or signals have arrived.</p> <p>In the first approach, we read the data out of the fd’s buffer, and the byte values give you the signal numbers. This is simple, but in rare cases it can run into a problem: generally the fd will have a limited amount of buffer space, and if too many signals arrive too quickly, then the buffer may become full, and some signals may be lost. If you use this approach, then you should set <code>warn_on_full_buffer=True</code>, which will at least cause a warning to be printed to stderr when signals are lost.</p> <p>In the second approach, we use the wakeup fd <em>only</em> for wakeups, and ignore the actual byte values. In this case, all we care about is whether the fd’s buffer is empty or non-empty; a full buffer doesn’t indicate a problem at all. If you use this approach, then you should set <code>warn_on_full_buffer=False</code>, so that your users are not confused by spurious warning messages.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>On Windows, the function now also supports socket handles.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Added <code>warn_on_full_buffer</code> parameter.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.siginterrupt">
<code>signal.siginterrupt(signalnum, flag)</code> </dt> <dd>
<p>Change system call restart behaviour: if <em>flag</em> is <a class="reference internal" href="constants.html#False" title="False"><code>False</code></a>, system calls will be restarted when interrupted by signal <em>signalnum</em>, otherwise system calls will be interrupted. Returns nothing.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> <p>See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/siginterrupt(3)">siginterrupt(3)</a></em> for further information.</p> </div> <p>Note that installing a signal handler with <a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code>signal()</code></a> will reset the restart behaviour to interruptible by implicitly calling <code>siginterrupt()</code> with a true <em>flag</em> value for the given signal.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.signal">
<code>signal.signal(signalnum, handler)</code> </dt> <dd>
<p>Set the handler for signal <em>signalnum</em> to the function <em>handler</em>. <em>handler</em> can be a callable Python object taking two arguments (see below), or one of the special values <a class="reference internal" href="#signal.SIG_IGN" title="signal.SIG_IGN"><code>signal.SIG_IGN</code></a> or <a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code>signal.SIG_DFL</code></a>. The previous signal handler will be returned (see the description of <a class="reference internal" href="#signal.getsignal" title="signal.getsignal"><code>getsignal()</code></a> above). (See the Unix man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/signal(2)">signal(2)</a></em> for further information.)</p> <p>When threads are enabled, this function can only be called from <a class="reference internal" href="#signals-and-threads"><span class="std std-ref">the main thread of the main interpreter</span></a>; attempting to call it from other threads will cause a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> exception to be raised.</p> <p>The <em>handler</em> is called with two arguments: the signal number and the current stack frame (<code>None</code> or a frame object; for a description of frame objects, see the <a class="reference internal" href="../reference/datamodel.html#frame-objects"><span class="std std-ref">description in the type hierarchy</span></a> or see the attribute descriptions in the <a class="reference internal" href="inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code>inspect</code></a> module).</p> <p>On Windows, <a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code>signal()</code></a> can only be called with <a class="reference internal" href="#signal.SIGABRT" title="signal.SIGABRT"><code>SIGABRT</code></a>, <a class="reference internal" href="#signal.SIGFPE" title="signal.SIGFPE"><code>SIGFPE</code></a>, <a class="reference internal" href="#signal.SIGILL" title="signal.SIGILL"><code>SIGILL</code></a>, <a class="reference internal" href="#signal.SIGINT" title="signal.SIGINT"><code>SIGINT</code></a>, <a class="reference internal" href="#signal.SIGSEGV" title="signal.SIGSEGV"><code>SIGSEGV</code></a>, <a class="reference internal" href="#signal.SIGTERM" title="signal.SIGTERM"><code>SIGTERM</code></a>, or <a class="reference internal" href="#signal.SIGBREAK" title="signal.SIGBREAK"><code>SIGBREAK</code></a>. A <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> will be raised in any other case. Note that not all systems define the same set of signal names; an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code>AttributeError</code></a> will be raised if a signal name is not defined as <code>SIG*</code> module level constant.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.sigpending">
<code>signal.sigpending()</code> </dt> <dd>
<p>Examine the set of signals that are pending for delivery to the calling thread (i.e., the signals which have been raised while blocked). Return the set of the pending signals.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> <p>See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigpending(2)">sigpending(2)</a></em> for further information.</p> </div> <p>See also <a class="reference internal" href="#signal.pause" title="signal.pause"><code>pause()</code></a>, <a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code>pthread_sigmask()</code></a> and <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code>sigwait()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.sigwait">
<code>signal.sigwait(sigset)</code> </dt> <dd>
<p>Suspend execution of the calling thread until the delivery of one of the signals specified in the signal set <em>sigset</em>. The function accepts the signal (removes it from the pending list of signals), and returns the signal number.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> <p>See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigwait(3)">sigwait(3)</a></em> for further information.</p> </div> <p>See also <a class="reference internal" href="#signal.pause" title="signal.pause"><code>pause()</code></a>, <a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code>pthread_sigmask()</code></a>, <a class="reference internal" href="#signal.sigpending" title="signal.sigpending"><code>sigpending()</code></a>, <a class="reference internal" href="#signal.sigwaitinfo" title="signal.sigwaitinfo"><code>sigwaitinfo()</code></a> and <a class="reference internal" href="#signal.sigtimedwait" title="signal.sigtimedwait"><code>sigtimedwait()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.sigwaitinfo">
<code>signal.sigwaitinfo(sigset)</code> </dt> <dd>
<p>Suspend execution of the calling thread until the delivery of one of the signals specified in the signal set <em>sigset</em>. The function accepts the signal and removes it from the pending list of signals. If one of the signals in <em>sigset</em> is already pending for the calling thread, the function will return immediately with information about that signal. The signal handler is not called for the delivered signal. The function raises an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code>InterruptedError</code></a> if it is interrupted by a signal that is not in <em>sigset</em>.</p> <p>The return value is an object representing the data contained in the <code>siginfo_t</code> structure, namely: <code>si_signo</code>, <code>si_code</code>, <code>si_errno</code>, <code>si_pid</code>, <code>si_uid</code>, <code>si_status</code>, <code>si_band</code>.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> <p>See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigwaitinfo(2)">sigwaitinfo(2)</a></em> for further information.</p> </div> <p>See also <a class="reference internal" href="#signal.pause" title="signal.pause"><code>pause()</code></a>, <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code>sigwait()</code></a> and <a class="reference internal" href="#signal.sigtimedwait" title="signal.sigtimedwait"><code>sigtimedwait()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The function is now retried if interrupted by a signal not in <em>sigset</em> and the signal handler does not raise an exception (see <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> for the rationale).</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="signal.sigtimedwait">
<code>signal.sigtimedwait(sigset, timeout)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#signal.sigwaitinfo" title="signal.sigwaitinfo"><code>sigwaitinfo()</code></a>, but takes an additional <em>timeout</em> argument specifying a timeout. If <em>timeout</em> is specified as <code>0</code>, a poll is performed. Returns <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a> if a timeout occurs.</p> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p> <p>See the man page <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigtimedwait(2)">sigtimedwait(2)</a></em> for further information.</p> </div> <p>See also <a class="reference internal" href="#signal.pause" title="signal.pause"><code>pause()</code></a>, <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code>sigwait()</code></a> and <a class="reference internal" href="#signal.sigwaitinfo" title="signal.sigwaitinfo"><code>sigwaitinfo()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The function is now retried with the recomputed <em>timeout</em> if interrupted by a signal not in <em>sigset</em> and the signal handler does not raise an exception (see <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> for the rationale).</p> </div> </dd>
</dl> </section> <section id="examples"> <span id="signal-example"></span><h2>Examples</h2> <p>Here is a minimal example program. It uses the <a class="reference internal" href="#signal.alarm" title="signal.alarm"><code>alarm()</code></a> function to limit the time spent waiting to open a file; this is useful if the file is for a serial device that may not be turned on, which would normally cause the <a class="reference internal" href="os.html#os.open" title="os.open"><code>os.open()</code></a> to hang indefinitely. The solution is to set a 5-second alarm before opening the file; if the operation takes too long, the alarm signal will be sent, and the handler raises an exception.</p> <pre data-language="python">import signal, os

def handler(signum, frame):
    signame = signal.Signals(signum).name
    print(f'Signal handler called with signal {signame} ({signum})')
    raise OSError("Couldn't open device!")

# Set the signal handler and a 5-second alarm
signal.signal(signal.SIGALRM, handler)
signal.alarm(5)

# This open() may hang indefinitely
fd = os.open('/dev/ttyS0', os.O_RDWR)

signal.alarm(0)          # Disable the alarm
</pre> </section> <section id="note-on-sigpipe"> <h2>Note on SIGPIPE</h2> <p>Piping output of your program to tools like <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/head(1)">head(1)</a></em> will cause a <a class="reference internal" href="#signal.SIGPIPE" title="signal.SIGPIPE"><code>SIGPIPE</code></a> signal to be sent to your process when the receiver of its standard output closes early. This results in an exception like <code>BrokenPipeError: [Errno 32] Broken pipe</code>. To handle this case, wrap your entry point to catch this exception as follows:</p> <pre data-language="python">import os
import sys

def main():
    try:
        # simulate large output (your code replaces this loop)
        for x in range(10000):
            print("y")
        # flush output here to force SIGPIPE to be triggered
        # while inside this try block.
        sys.stdout.flush()
    except BrokenPipeError:
        # Python flushes standard streams on exit; redirect remaining output
        # to devnull to avoid another BrokenPipeError at shutdown
        devnull = os.open(os.devnull, os.O_WRONLY)
        os.dup2(devnull, sys.stdout.fileno())
        sys.exit(1)  # Python exits with error code 1 on EPIPE

if __name__ == '__main__':
    main()
</pre> <p>Do not set <a class="reference internal" href="#signal.SIGPIPE" title="signal.SIGPIPE"><code>SIGPIPE</code></a>’s disposition to <a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code>SIG_DFL</code></a> in order to avoid <a class="reference internal" href="exceptions.html#BrokenPipeError" title="BrokenPipeError"><code>BrokenPipeError</code></a>. Doing that would cause your program to exit unexpectedly whenever any socket connection is interrupted while your program is still writing to it.</p> </section> <section id="note-on-signal-handlers-and-exceptions"> <span id="handlers-and-exceptions"></span><h2>Note on Signal Handlers and Exceptions</h2> <p>If a signal handler raises an exception, the exception will be propagated to the main thread and may be raised after any <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> instruction. Most notably, a <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a> may appear at any point during execution. Most Python code, including the standard library, cannot be made robust against this, and so a <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a> (or any other exception resulting from a signal handler) may on rare occasions put the program in an unexpected state.</p> <p>To illustrate this issue, consider the following code:</p> <pre data-language="python">class SpamContext:
    def __init__(self):
        self.lock = threading.Lock()

    def __enter__(self):
        # If KeyboardInterrupt occurs here, everything is fine
        self.lock.acquire()
        # If KeyboardInterrupt occurs here, __exit__ will not be called
        ...
        # KeyboardInterrupt could occur just before the function returns

    def __exit__(self, exc_type, exc_val, exc_tb):
        ...
        self.lock.release()
</pre> <p>For many programs, especially those that merely want to exit on <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a>, this is not a problem, but applications that are complex or require high reliability should avoid raising exceptions from signal handlers. They should also avoid catching <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a> as a means of gracefully shutting down. Instead, they should install their own <a class="reference internal" href="#signal.SIGINT" title="signal.SIGINT"><code>SIGINT</code></a> handler. Below is an example of an HTTP server that avoids <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a>:</p> <pre data-language="python">import signal
import socket
from selectors import DefaultSelector, EVENT_READ
from http.server import HTTPServer, SimpleHTTPRequestHandler

interrupt_read, interrupt_write = socket.socketpair()

def handler(signum, frame):
    print('Signal handler called with signal', signum)
    interrupt_write.send(b'\0')
signal.signal(signal.SIGINT, handler)

def serve_forever(httpd):
    sel = DefaultSelector()
    sel.register(interrupt_read, EVENT_READ)
    sel.register(httpd, EVENT_READ)

    while True:
        for key, _ in sel.select():
            if key.fileobj == interrupt_read:
                interrupt_read.recv(1)
                return
            if key.fileobj == httpd:
                httpd.handle_request()

print("Serving on port 8000")
httpd = HTTPServer(('', 8000), SimpleHTTPRequestHandler)
serve_forever(httpd)
print("Shutdown...")
</pre> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/library/signal.html" class="_attribution-link">https://docs.python.org/3.13/library/signal.html</a>
  </p>
</div>
