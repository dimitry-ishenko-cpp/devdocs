 <span id="using-ios"></span><h1> Using Python on iOS</h1> <dl class="field-list simple"> <dt class="field-odd">Authors<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>Russell Keith-Magee (2024-03)</p> </dd> </dl> <p>Python on iOS is unlike Python on desktop platforms. On a desktop platform, Python is generally installed as a system resource that can be used by any user of that computer. Users then interact with Python by running a <strong class="program">python</strong> executable and entering commands at an interactive prompt, or by running a Python script.</p> <p>On iOS, there is no concept of installing as a system resource. The only unit of software distribution is an “app”. There is also no console where you could run a <strong class="program">python</strong> executable, or interact with a Python REPL.</p> <p>As a result, the only way you can use Python on iOS is in embedded mode - that is, by writing a native iOS application, and embedding a Python interpreter using <code>libPython</code>, and invoking Python code using the <a class="reference internal" href="../extending/embedding.html#embedding"><span class="std std-ref">Python embedding API</span></a>. The full Python interpreter, the standard library, and all your Python code is then packaged as a standalone bundle that can be distributed via the iOS App Store.</p> <p>If you’re looking to experiment for the first time with writing an iOS app in Python, projects such as <a class="reference external" href="https://beeware.org">BeeWare</a> and <a class="reference external" href="https://kivy.org">Kivy</a> will provide a much more approachable user experience. These projects manage the complexities associated with getting an iOS project running, so you only need to deal with the Python code itself.</p> <section id="python-at-runtime-on-ios"> <h2>
<span class="section-number">6.1. </span>Python at runtime on iOS</h2> <section id="ios-version-compatibility"> <h3>
<span class="section-number">6.1.1. </span>iOS version compatibility</h3> <p>The minimum supported iOS version is specified at compile time, using the <a class="reference internal" href="configure.html#cmdoption-host"><code>--host</code></a> option to <code>configure</code>. By default, when compiled for iOS, Python will be compiled with a minimum supported iOS version of 13.0. To use a different minimum iOS version, provide the version number as part of the <code>--host</code> argument - for example, <code>--host=arm64-apple-ios15.4-simulator</code> would compile an ARM64 simulator build with a deployment target of 15.4.</p> </section> <section id="platform-identification"> <h3>
<span class="section-number">6.1.2. </span>Platform identification</h3> <p>When executing on iOS, <code>sys.platform</code> will report as <code>ios</code>. This value will be returned on an iPhone or iPad, regardless of whether the app is running on the simulator or a physical device.</p> <p>Information about the specific runtime environment, including the iOS version, device model, and whether the device is a simulator, can be obtained using <a class="reference internal" href="../library/platform.html#platform.ios_ver" title="platform.ios_ver"><code>platform.ios_ver()</code></a>. <a class="reference internal" href="../library/platform.html#platform.system" title="platform.system"><code>platform.system()</code></a> will report <code>iOS</code> or <code>iPadOS</code>, depending on the device.</p> <p><a class="reference internal" href="../library/os.html#os.uname" title="os.uname"><code>os.uname()</code></a> reports kernel-level details; it will report a name of <code>Darwin</code>.</p> </section> <section id="standard-library-availability"> <h3>
<span class="section-number">6.1.3. </span>Standard library availability</h3> <p>The Python standard library has some notable omissions and restrictions on iOS. See the <a class="reference internal" href="https://docs.python.org/3.13/library/intro.html#ios-availability"><span class="std std-ref">API availability guide for iOS</span></a> for details.</p> </section> <section id="binary-extension-modules"> <h3>
<span class="section-number">6.1.4. </span>Binary extension modules</h3> <p>One notable difference about iOS as a platform is that App Store distribution imposes hard requirements on the packaging of an application. One of these requirements governs how binary extension modules are distributed.</p> <p>The iOS App Store requires that <em>all</em> binary modules in an iOS app must be dynamic libraries, contained in a framework with appropriate metadata, stored in the <code>Frameworks</code> folder of the packaged app. There can be only a single binary per framework, and there can be no executable binary material outside the <code>Frameworks</code> folder.</p> <p>This conflicts with the usual Python approach for distributing binaries, which allows a binary extension module to be loaded from any location on <code>sys.path</code>. To ensure compliance with App Store policies, an iOS project must post-process any Python packages, converting <code>.so</code> binary modules into individual standalone frameworks with appropriate metadata and signing. For details on how to perform this post-processing, see the guide for <a class="reference internal" href="#adding-ios"><span class="std std-ref">adding Python to your project</span></a>.</p> <p>To help Python discover binaries in their new location, the original <code>.so</code> file on <code>sys.path</code> is replaced with a <code>.fwork</code> file. This file is a text file containing the location of the framework binary, relative to the app bundle. To allow the framework to resolve back to the original location, the framework must contain a <code>.origin</code> file that contains the location of the <code>.fwork</code> file, relative to the app bundle.</p> <p>For example, consider the case of an import <code>from foo.bar import _whiz</code>, where <code>_whiz</code> is implemented with the binary module <code>sources/foo/bar/_whiz.abi3.so</code>, with <code>sources</code> being the location registered on <code>sys.path</code>, relative to the application bundle. This module <em>must</em> be distributed as <code>Frameworks/foo.bar._whiz.framework/foo.bar._whiz</code> (creating the framework name from the full import path of the module), with an <code>Info.plist</code> file in the <code>.framework</code> directory identifying the binary as a framework. The <code>foo.bar._whiz</code> module would be represented in the original location with a <code>sources/foo/bar/_whiz.abi3.fwork</code> marker file, containing the path <code>Frameworks/foo.bar._whiz/foo.bar._whiz</code>. The framework would also contain <code>Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin</code>, containing the path to the <code>.fwork</code> file.</p> <p>When running on iOS, the Python interpreter will install an <a class="reference internal" href="../library/importlib.html#importlib.machinery.AppleFrameworkLoader" title="importlib.machinery.AppleFrameworkLoader"><code>AppleFrameworkLoader</code></a> that is able to read and import <code>.fwork</code> files. Once imported, the <code>__file__</code> attribute of the binary module will report as the location of the <code>.fwork</code> file. However, the <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code>ModuleSpec</code></a> for the loaded module will report the <code>origin</code> as the location of the binary in the framework folder.</p> </section> <section id="compiler-stub-binaries"> <h3>
<span class="section-number">6.1.5. </span>Compiler stub binaries</h3> <p>Xcode doesn’t expose explicit compilers for iOS; instead, it uses an <code>xcrun</code> script that resolves to a full compiler path (e.g., <code>xcrun --sdk iphoneos
clang</code> to get the <code>clang</code> for an iPhone device). However, using this script poses two problems:</p> <ul class="simple"> <li>The output of <code>xcrun</code> includes paths that are machine specific, resulting in a sysconfig module that cannot be shared between users; and</li> <li>It results in <code>CC</code>/<code>CPP</code>/<code>LD</code>/<code>AR</code> definitions that include spaces. There is a lot of C ecosystem tooling that assumes that you can split a command line at the first space to get the path to the compiler executable; this isn’t the case when using <code>xcrun</code>.</li> </ul> <p>To avoid these problems, Python provided stubs for these tools. These stubs are shell script wrappers around the underingly <code>xcrun</code> tools, distributed in a <code>bin</code> folder distributed alongside the compiled iOS framework. These scripts are relocatable, and will always resolve to the appropriate local system paths. By including these scripts in the bin folder that accompanies a framework, the contents of the <code>sysconfig</code> module becomes useful for end-users to compile their own modules. When compiling third-party Python modules for iOS, you should ensure these stub binaries are on your path.</p> </section> </section> <section id="installing-python-on-ios"> <h2>
<span class="section-number">6.2. </span>Installing Python on iOS</h2> <section id="tools-for-building-ios-apps"> <h3>
<span class="section-number">6.2.1. </span>Tools for building iOS apps</h3> <p>Building for iOS requires the use of Apple’s Xcode tooling. It is strongly recommended that you use the most recent stable release of Xcode. This will require the use of the most (or second-most) recently released macOS version, as Apple does not maintain Xcode for older macOS versions. The Xcode Command Line Tools are not sufficient for iOS development; you need a <em>full</em> Xcode install.</p> <p>If you want to run your code on the iOS simulator, you’ll also need to install an iOS Simulator Platform. You should be prompted to select an iOS Simulator Platform when you first run Xcode. Alternatively, you can add an iOS Simulator Platform by selecting from the Platforms tab of the Xcode Settings panel.</p> </section> <section id="adding-python-to-an-ios-project"> <span id="adding-ios"></span><h3>
<span class="section-number">6.2.2. </span>Adding Python to an iOS project</h3> <p>Python can be added to any iOS project, using either Swift or Objective C. The following examples will use Objective C; if you are using Swift, you may find a library like <a class="reference external" href="https://github.com/pvieito/PythonKit">PythonKit</a> to be helpful.</p> <p>To add Python to an iOS Xcode project:</p> <ol class="arabic"> <li>Build or obtain a Python <code>XCFramework</code>. See the instructions in <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/iOS/README.rst">iOS/README.rst</a> (in the CPython source distribution) for details on how to build a Python <code>XCFramework</code>. At a minimum, you will need a build that supports <code>arm64-apple-ios</code>, plus one of either <code>arm64-apple-ios-simulator</code> or <code>x86_64-apple-ios-simulator</code>.</li> <li>Drag the <code>XCframework</code> into your iOS project. In the following instructions, we’ll assume you’ve dropped the <code>XCframework</code> into the root of your project; however, you can use any other location that you want by adjusting paths as needed.</li> <li>Drag the <code>iOS/Resources/dylib-Info-template.plist</code> file into your project, and ensure it is associated with the app target.</li> <li>Add your application code as a folder in your Xcode project. In the following instructions, we’ll assume that your user code is in a folder named <code>app</code> in the root of your project; you can use any other location by adjusting paths as needed. Ensure that this folder is associated with your app target.</li> <li>Select the app target by selecting the root node of your Xcode project, then the target name in the sidebar that appears.</li> <li>In the “General” settings, under “Frameworks, Libraries and Embedded Content”, add <code>Python.xcframework</code>, with “Embed &amp; Sign” selected.</li> <li>
<p>In the “Build Settings” tab, modify the following:</p> <ul class="simple"> <li>
<p>Build Options</p> <ul> <li>User Script Sandboxing: No</li> <li>Enable Testability: Yes</li> </ul> </li> <li>
<p>Search Paths</p> <ul> <li>Framework Search Paths: <code>$(PROJECT_DIR)</code>
</li> <li>Header Search Paths: <code>"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers"</code>
</li> </ul> </li> <li>
<p>Apple Clang - Warnings - All languages</p> <ul> <li>Quoted Include In Framework Header: No</li> </ul> </li> </ul> </li> <li>
<p>Add a build step that copies the Python standard library into your app. In the “Build Phases” tab, add a new “Run Script” build step <em>before</em> the “Embed Frameworks” step, but <em>after</em> the “Copy Bundle Resources” step. Name the step “Install Target Specific Python Standard Library”, disable the “Based on dependency analysis” checkbox, and set the script content to:</p> <pre data-language="bash">set -e

mkdir -p "$CODESIGNING_FOLDER_PATH/python/lib"
if [ "$EFFECTIVE_PLATFORM_NAME" = "-iphonesimulator" ]; then
    echo "Installing Python modules for iOS Simulator"
    rsync -au --delete "$PROJECT_DIR/Python.xcframework/ios-arm64_x86_64-simulator/lib/" "$CODESIGNING_FOLDER_PATH/python/lib/"
else
    echo "Installing Python modules for iOS Device"
    rsync -au --delete "$PROJECT_DIR/Python.xcframework/ios-arm64/lib/" "$CODESIGNING_FOLDER_PATH/python/lib/"
fi
</pre> <p>Note that the name of the simulator “slice” in the XCframework may be different, depending the CPU architectures your <code>XCFramework</code> supports.</p> </li> <li>
<p>Add a second build step that processes the binary extension modules in the standard library into “Framework” format. Add a “Run Script” build step <em>directly after</em> the one you added in step 8, named “Prepare Python Binary Modules”. It should also have “Based on dependency analysis” unchecked, with the following script content:</p> <pre data-language="bash">set -e

install_dylib () {
    INSTALL_BASE=$1
    FULL_EXT=$2

    # The name of the extension file
    EXT=$(basename "$FULL_EXT")
    # The location of the extension file, relative to the bundle
    RELATIVE_EXT=${FULL_EXT#$CODESIGNING_FOLDER_PATH/}
    # The path to the extension file, relative to the install base
    PYTHON_EXT=${RELATIVE_EXT/$INSTALL_BASE/}
    # The full dotted name of the extension module, constructed from the file path.
    FULL_MODULE_NAME=$(echo $PYTHON_EXT | cut -d "." -f 1 | tr "/" ".");
    # A bundle identifier; not actually used, but required by Xcode framework packaging
    FRAMEWORK_BUNDLE_ID=$(echo $PRODUCT_BUNDLE_IDENTIFIER.$FULL_MODULE_NAME | tr "_" "-")
    # The name of the framework folder.
    FRAMEWORK_FOLDER="Frameworks/$FULL_MODULE_NAME.framework"

    # If the framework folder doesn't exist, create it.
    if [ ! -d "$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER" ]; then
        echo "Creating framework for $RELATIVE_EXT"
        mkdir -p "$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER"
        cp "$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist" "$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist"
        plutil -replace CFBundleExecutable -string "$FULL_MODULE_NAME" "$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist"
        plutil -replace CFBundleIdentifier -string "$FRAMEWORK_BUNDLE_ID" "$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist"
    fi

    echo "Installing binary for $FRAMEWORK_FOLDER/$FULL_MODULE_NAME"
    mv "$FULL_EXT" "$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/$FULL_MODULE_NAME"
    # Create a placeholder .fwork file where the .so was
    echo "$FRAMEWORK_FOLDER/$FULL_MODULE_NAME" &gt; ${FULL_EXT%.so}.fwork
    # Create a back reference to the .so file location in the framework
    echo "${RELATIVE_EXT%.so}.fwork" &gt; "$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/$FULL_MODULE_NAME.origin"
 }

 PYTHON_VER=$(ls -1 "$CODESIGNING_FOLDER_PATH/python/lib")
 echo "Install Python $PYTHON_VER standard library extension modules..."
 find "$CODESIGNING_FOLDER_PATH/python/lib/$PYTHON_VER/lib-dynload" -name "*.so" | while read FULL_EXT; do
    install_dylib python/lib/$PYTHON_VER/lib-dynload/ "$FULL_EXT"
 done

 # Clean up dylib template
 rm -f "$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist"

 echo "Signing frameworks as $EXPANDED_CODE_SIGN_IDENTITY_NAME ($EXPANDED_CODE_SIGN_IDENTITY)..."
 find "$CODESIGNING_FOLDER_PATH/Frameworks" -name "*.framework" -exec /usr/bin/codesign --force --sign "$EXPANDED_CODE_SIGN_IDENTITY" ${OTHER_CODE_SIGN_FLAGS:-} -o runtime --timestamp=none --preserve-metadata=identifier,entitlements,flags --generate-entitlement-der "{}" \;
</pre> </li> <li>Add Objective C code to initialize and use a Python interpreter in embedded mode. You should ensure that:</li> </ol>  <ul class="simple"> <li>
<a class="reference internal" href="../c-api/init_config.html#c.PyPreConfig.utf8_mode" title="PyPreConfig.utf8_mode"><code>UTF-8 mode</code></a> is <em>enabled</em>;</li> <li>
<a class="reference internal" href="../c-api/init_config.html#c.PyConfig.buffered_stdio" title="PyConfig.buffered_stdio"><code>Buffered stdio</code></a> is <em>disabled</em>;</li> <li>
<a class="reference internal" href="../c-api/init_config.html#c.PyConfig.write_bytecode" title="PyConfig.write_bytecode"><code>Writing bytecode</code></a> is <em>disabled</em>;</li> <li>
<a class="reference internal" href="../c-api/init_config.html#c.PyConfig.install_signal_handlers" title="PyConfig.install_signal_handlers"><code>Signal handlers</code></a> are <em>enabled</em>;</li> <li>
<code>PYTHONHOME</code> for the interpreter is configured to point at the <code>python</code> subfolder of your app’s bundle; and</li> <li>
<p>The <code>PYTHONPATH</code> for the interpreter includes:</p> <ul> <li>the <code>python/lib/python3.X</code> subfolder of your app’s bundle,</li> <li>the <code>python/lib/python3.X/lib-dynload</code> subfolder of your app’s bundle, and</li> <li>the <code>app</code> subfolder of your app’s bundle</li> </ul> </li> </ul> <p>Your app’s bundle location can be determined using <code>[[NSBundle mainBundle]
resourcePath]</code>.</p>  <p>Steps 8, 9 and 10 of these instructions assume that you have a single folder of pure Python application code, named <code>app</code>. If you have third-party binary modules in your app, some additional steps will be required:</p> <ul class="simple"> <li>You need to ensure that any folders containing third-party binaries are either associated with the app target, or copied in as part of step 8. Step 8 should also purge any binaries that are not appropriate for the platform a specific build is targeting (i.e., delete any device binaries if you’re building an app targeting the simulator).</li> <li>Any folders that contain third-party binaries must be processed into framework form by step 9. The invocation of <code>install_dylib</code> that processes the <code>lib-dynload</code> folder can be copied and adapted for this purpose.</li> <li>If you’re using a separate folder for third-party packages, ensure that folder is included as part of the <code>PYTHONPATH</code> configuration in step 10.</li> </ul> </section> </section> <section id="app-store-compliance"> <h2>
<span class="section-number">6.3. </span>App Store Compliance</h2> <p>The only mechanism for distributing apps to third-party iOS devices is to submit the app to the iOS App Store; apps submitted for distribution must pass Apple’s app review process. This process includes a set of automated validation rules that inspect the submitted application bundle for problematic code.</p> <p>The Python standard library contains some code that is known to violate these automated rules. While these violations appear to be false positives, Apple’s review rules cannot be challenged; so, it is necessary to modify the Python standard library for an app to pass App Store review.</p> <p>The Python source tree contains <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Mac/Resources/app-store-compliance.patch">a patch file</a> that will remove all code that is known to cause issues with the App Store review process. This patch is applied automatically when building for iOS.</p> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2024 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.13/using/ios.html" class="_attribution-link">https://docs.python.org/3.13/using/ios.html</a>
  </p>
</div>
