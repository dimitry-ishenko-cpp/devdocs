<h1 id="class-ActiveRecord::Relation" class="class"> class ActiveRecord::Relation </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="../enumerable.html">Enumerable</a></dd>
</dl> <section class="description"> <h1 id="class-ActiveRecord::Relation-label-Active+Record+Relation">Active Record Relation</h1> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="CLAUSE_METHODS">CLAUSE_METHODS </dt>

<dt id="INVALID_METHODS_FOR_DELETE_ALL">INVALID_METHODS_FOR_DELETE_ALL </dt>

<dt id="MULTI_VALUE_METHODS">MULTI_VALUE_METHODS </dt>

<dt id="SINGLE_VALUE_METHODS">SINGLE_VALUE_METHODS </dt>

<dt id="VALUE_METHODS">VALUE_METHODS </dt>

</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-klass"> <span class="method-name">klass</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-loaded"> <span class="method-name">loaded</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-loaded-3F"> <span class="method-name">loaded?</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-model"> <span class="method-name">model</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-predicate_builder"> <span class="method-name">predicate_builder</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-skip_preloading_value"> <span class="method-name">skip_preloading_value</span><span class="attribute-access-type">[RW]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-table"> <span class="method-name">table</span><span class="attribute-access-type">[R]</span> </div>  </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(klass, table: klass.arel_table, predicate_builder: klass.predicate_builder, values: {})</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 28
def initialize(klass, table: klass.arel_table, predicate_builder: klass.predicate_builder, values: {})
  @klass  = klass
  @table  = table
  @values = values
  @loaded = false
  @predicate_builder = predicate_builder
  @delegate_to_klass = false
  @future_result = nil
  @records = nil
  @async = false
  @none = false
end</pre> </div>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-name">==</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 798
def ==(other)
  case other
  when Associations::CollectionProxy, AssociationRelation
    self == other.records
  when Relation
    other.to_sql == to_sql
  when Array
    records == other
  end
end</pre> </div> <p>Compares two relations for equality.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-any-3F"> <span class="method-name">any?</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="any-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 302
def any?(*args)
  return false if @none

  return super if args.present? || block_given?
  !empty?
end</pre> </div> <p>Returns true if there are any records.</p> <div class="method-calls-super"> Calls superclass method </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-blank-3F"> <span class="method-name">blank?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="blank-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 819
def blank?
  records.blank?
end</pre> </div> <p>Returns true if relation is blank.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-build"> <span class="method-name">build</span><span class="method-args">(attributes = nil, &amp;block)</span> </div> </div>  <div class="aliases"> Alias for: <a href="relation.html#method-i-new">new</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-cache_key"> <span class="method-name">cache_key</span><span class="method-args">(timestamp_column = "updated_at")</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="cache_key-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 344
def cache_key(timestamp_column = "updated_at")
  @cache_keys ||= {}
  @cache_keys[timestamp_column] ||= klass.collection_cache_key(self, timestamp_column)
end</pre> </div> <p>Returns a stable cache key that can be used to identify this query. The cache key is built with a fingerprint of the SQL query.</p> <pre class="ruby" data-language="ruby">Product.where("name like ?", "%Cosmic Encounter%").cache_key
# =&gt; "products/query-1850ab3d302391b85b8693e941286659"
</pre> <p>If <a href="integration.html#method-c-collection_cache_versioning"><code>ActiveRecord::Base.collection_cache_versioning</code></a> is turned off, as it was in Rails 6.0 and earlier, the cache key will also include a version.</p> <pre class="ruby" data-language="ruby">ActiveRecord::Base.collection_cache_versioning = false
Product.where("name like ?", "%Cosmic Encounter%").cache_key
# =&gt; "products/query-1850ab3d302391b85b8693e941286659-1-20150714212553907087000"
</pre> <p>You can also pass a custom timestamp column to fetch the timestamp of the last updated record.</p> <pre class="ruby" data-language="ruby">Product.where("name like ?", "%Game%").cache_key(:last_reviewed_at)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-cache_key_with_version"> <span class="method-name">cache_key_with_version</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="cache_key_with_version-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 423
def cache_key_with_version
  if version = cache_version
    "#{cache_key}-#{version}"
  else
    cache_key
  end
end</pre> </div> <p>Returns a cache key along with the version.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-cache_version"> <span class="method-name">cache_version</span><span class="method-args">(timestamp_column = :updated_at)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="cache_version-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 371
def cache_version(timestamp_column = :updated_at)
  if collection_cache_versioning
    @cache_versions ||= {}
    @cache_versions[timestamp_column] ||= compute_cache_version(timestamp_column)
  end
end</pre> </div> <p>Returns a cache version that can be used together with the cache key to form a recyclable caching scheme. The cache version is built with the number of records matching the query, and the timestamp of the last updated record. When a new record comes to match the query, or any of the existing records is updated or deleted, the cache version changes.</p> <p>If the collection is loaded, the method will iterate through the records to generate the timestamp, otherwise it will trigger one SQL query like:</p> <pre>SELECT COUNT(*), MAX("products"."updated_at") FROM "products" WHERE (name like '%Cosmic Encounter%')</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-create"> <span class="method-name">create</span><span class="method-args">(attributes = nil, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="create-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 98
def create(attributes = nil, &amp;block)
  if attributes.is_a?(Array)
    attributes.collect { |attr| create(attr, &amp;block) }
  else
    block = current_scope_restoring_block(&amp;block)
    scoping { _create(attributes, &amp;block) }
  end
end</pre> </div> <p>Tries to create a new record with the same scoped attributes defined in the relation. Returns the initialized object if validation fails.</p> <p>Expects arguments in the same format as <a href="persistence/classmethods.html#method-i-create">ActiveRecord::Base.create</a>.</p> <h4 id="method-i-create-label-Examples">Examples</h4> <pre class="ruby" data-language="ruby">users = User.where(name: 'Oscar')
users.create # =&gt; #&lt;User id: 3, name: "Oscar", ...&gt;

users.create(name: 'fxn')
users.create # =&gt; #&lt;User id: 4, name: "fxn", ...&gt;

users.create { |user| user.name = 'tenderlove' }
# =&gt; #&lt;User id: 5, name: "tenderlove", ...&gt;

users.create(name: nil) # validation on name
# =&gt; #&lt;User id: nil, name: nil, ...&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-create-21"> <span class="method-name">create!</span><span class="method-args">(attributes = nil, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="create-21-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 113
def create!(attributes = nil, &amp;block)
  if attributes.is_a?(Array)
    attributes.collect { |attr| create!(attr, &amp;block) }
  else
    block = current_scope_restoring_block(&amp;block)
    scoping { _create!(attributes, &amp;block) }
  end
end</pre> </div> <p>Similar to <a href="relation.html#method-i-create"><code>create</code></a>, but calls <a href="persistence/classmethods.html#method-i-create-21">create!</a> on the base class. Raises an exception if a validation error occurs.</p> <p>Expects arguments in the same format as <a href="persistence/classmethods.html#method-i-create-21">ActiveRecord::Base.create!</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-create_or_find_by"> <span class="method-name">create_or_find_by</span><span class="method-args">(attributes, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="create_or_find_by-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 215
def create_or_find_by(attributes, &amp;block)
  transaction(requires_new: true) { create(attributes, &amp;block) }
rescue ActiveRecord::RecordNotUnique
  if connection.transaction_open?
    where(attributes).lock.find_by!(attributes)
  else
    find_by!(attributes)
  end
end</pre> </div> <p>Attempts to create a record with the given attributes in a table that has a unique database constraint on one or several of its columns. If a row already exists with one or several of these unique constraints, the exception such an insertion would normally raise is caught, and the existing record with those attributes is found using find_by!.</p> <p>This is similar to <a href="relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a>, but tries to create the record first. As such it is better suited for cases where the record is most likely not to exist yet.</p> <p>There are several drawbacks to <a href="relation.html#method-i-create_or_find_by"><code>create_or_find_by</code></a>, though:</p> <ul>
<li> <p>The underlying table must have the relevant columns defined with unique database constraints.</p> </li>
<li> <p>A unique constraint violation may be triggered by only one, or at least less than all, of the given attributes. This means that the subsequent find_by! may fail to find a matching record, which will then raise an <a href="recordnotfound.html"><code>ActiveRecord::RecordNotFound</code></a> exception, rather than a record with the given attributes.</p> </li>
<li> <p>While we avoid the race condition between SELECT -&gt; INSERT from <a href="relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a>, we actually have another race condition between INSERT -&gt; SELECT, which can be triggered if a DELETE between those two statements is run by another client. But for most applications, that’s a significantly less likely condition to hit.</p> </li>
<li> <p>It relies on exception handling to handle control flow, which may be marginally slower.</p> </li>
<li> <p>The primary key may auto-increment on each create, even if it fails. This can accelerate the problem of running out of integers, if the underlying table is still stuck on a primary key of type int (note: All Rails apps since 5.1+ have defaulted to bigint, which is not liable to this problem).</p> </li>
</ul> <p>This method will return a record if all given attributes are covered by unique constraints (unless the INSERT -&gt; DELETE -&gt; SELECT race condition is triggered), but if creation was attempted and failed due to validation errors it won’t be persisted, you get what <a href="relation.html#method-i-create"><code>create</code></a> returns in such situation.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-create_or_find_by-21"> <span class="method-name">create_or_find_by!</span><span class="method-args">(attributes, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="create_or_find_by-21-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 228
def create_or_find_by!(attributes, &amp;block)
  transaction(requires_new: true) { create!(attributes, &amp;block) }
rescue ActiveRecord::RecordNotUnique
  if connection.transaction_open?
    where(attributes).lock.find_by!(attributes)
  else
    find_by!(attributes)
  end
end</pre> </div> <p>Like <a href="relation.html#method-i-create_or_find_by"><code>create_or_find_by</code></a>, but calls <a href="persistence/classmethods.html#method-i-create-21">create!</a> so an exception is raised if the created record is invalid.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_all"> <span class="method-name">delete_all</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_all-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 631
def delete_all
  return 0 if @none

  invalid_methods = INVALID_METHODS_FOR_DELETE_ALL.select do |method|
    value = @values[method]
    method == :distinct ? value : value&amp;.any?
  end
  if invalid_methods.any?
    raise ActiveRecordError.new("delete_all doesn't support #{invalid_methods.join(', ')}")
  end

  arel = eager_loading? ? apply_join_dependency.arel : build_arel
  arel.source.left = table

  group_values_arel_columns = arel_columns(group_values.uniq)
  having_clause_ast = having_clause.ast unless having_clause.empty?
  stmt = arel.compile_delete(table[primary_key], having_clause_ast, group_values_arel_columns)

  klass.connection.delete(stmt, "#{klass} Delete All").tap { reset }
end</pre> </div> <p>Deletes the records without instantiating the records first, and hence not calling the <a href="persistence.html#method-i-destroy">#destroy</a> method nor invoking callbacks. This is a single SQL DELETE statement that goes straight to the database, much more efficient than <a href="relation.html#method-i-destroy_all"><code>destroy_all</code></a>. Be careful with relations though, in particular <code>:dependent</code> rules defined on associations are not honored. Returns the number of rows affected.</p> <pre class="ruby" data-language="ruby">Post.where(person_id: 5).where(category: ['Something', 'Else']).delete_all
</pre> <p>Both calls delete the affected posts all at once with a single DELETE statement. If you need to destroy dependent associations or call your <code>before_*</code> or <code>after_destroy</code> callbacks, use the <a href="relation.html#method-i-destroy_all"><code>destroy_all</code></a> method instead.</p> <p>If an invalid method is supplied, <a href="relation.html#method-i-delete_all"><code>delete_all</code></a> raises an ActiveRecordError:</p> <pre class="ruby" data-language="ruby">Post.distinct.delete_all
# =&gt; ActiveRecord::ActiveRecordError: delete_all doesn't support distinct
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_by"> <span class="method-name">delete_by</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_by-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 674
def delete_by(*args)
  where(*args).delete_all
end</pre> </div> <p>Finds and deletes all records matching the specified conditions. This is short-hand for <code>relation.where(condition).delete_all</code>. Returns the number of rows affected.</p> <p>If no record is found, returns <code>0</code> as zero rows were affected.</p> <pre class="ruby" data-language="ruby">Person.delete_by(id: 13)
Person.delete_by(name: 'Spartacus', rating: 4)
Person.delete_by("published_at &lt; ?", 2.weeks.ago)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-destroy_all"> <span class="method-name">destroy_all</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="destroy_all-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 609
def destroy_all
  records.each(&amp;:destroy).tap { reset }
end</pre> </div> <p>Destroys the records by instantiating each record and calling its <a href="persistence.html#method-i-destroy">#destroy</a> method. Each object’s callbacks are executed (including <code>:dependent</code> association options). Returns the collection of objects that were destroyed; each will be frozen, to reflect that no changes should be made (since they can’t be persisted).</p> <p>Note: Instantiation, callback execution, and deletion of each record can be time consuming when you’re removing many records at once. It generates at least one SQL <code>DELETE</code> query per record (or possibly more, to enforce your callbacks). If you want to delete many rows quickly, without concern for their associations or callbacks, use <a href="relation.html#method-i-delete_all"><code>delete_all</code></a> instead.</p> <h4 id="method-i-destroy_all-label-Examples">Examples</h4> <pre class="ruby" data-language="ruby">Person.where(age: 0..18).destroy_all
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-destroy_by"> <span class="method-name">destroy_by</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="destroy_by-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 661
def destroy_by(*args)
  where(*args).destroy_all
end</pre> </div> <p>Finds and destroys all records matching the specified conditions. This is short-hand for <code>relation.where(condition).destroy_all</code>. Returns the collection of objects that were destroyed.</p> <p>If no record is found, returns empty array.</p> <pre class="ruby" data-language="ruby">Person.destroy_by(id: 13)
Person.destroy_by(name: 'Spartacus', rating: 4)
Person.destroy_by("published_at &lt; ?", 2.weeks.ago)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-eager_loading-3F"> <span class="method-name">eager_loading?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="eager_loading-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 783
def eager_loading?
  @should_eager_load ||=
    eager_load_values.any? ||
    includes_values.any? &amp;&amp; (joined_includes_values.any? || references_eager_loaded_tables?)
end</pre> </div> <p>Returns true if relation needs eager loading.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-empty-3F"> <span class="method-name">empty?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="empty-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 283
def empty?
  return true if @none

  if loaded?
    records.empty?
  else
    !exists?
  end
end</pre> </div> <p>Returns true if there are no records.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-encode_with"> <span class="method-name">encode_with</span><span class="method-args">(coder)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="encode_with-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 269
def encode_with(coder)
  coder.represent_seq(nil, records)
end</pre> </div> <p>Serializes the relation objects <a href="../array.html"><code>Array</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-explain"> <span class="method-name">explain</span><span class="method-args">(*options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="explain-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 253
def explain(*options)
  exec_explain(collecting_queries_for_explain { exec_queries }, options)
end</pre> </div> <p>Runs EXPLAIN on the query or queries triggered by this relation and returns the result as a string. The string is formatted imitating the ones printed by the database shell.</p> <p>Note that this method actually runs the queries, since the results of some are needed by the next ones when eager loading is going on.</p> <p>Please see further details in the <a href="https://guides.rubyonrails.org/active_record_querying.html#running-explain">Active Record Query Interface guide</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-find_or_create_by"> <span class="method-name">find_or_create_by</span><span class="method-args">(attributes, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="find_or_create_by-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 175
def find_or_create_by(attributes, &amp;block)
  find_by(attributes) || create_or_find_by(attributes, &amp;block)
end</pre> </div> <p>Finds the first record with the given attributes, or creates a record with the attributes if one is not found:</p> <pre class="ruby" data-language="ruby"># Find the first user named "Penélope" or create a new one.
User.find_or_create_by(first_name: 'Penélope')
# =&gt; #&lt;User id: 1, first_name: "Penélope", last_name: nil&gt;

# Find the first user named "Penélope" or create a new one.
# We already have one so the existing record will be returned.
User.find_or_create_by(first_name: 'Penélope')
# =&gt; #&lt;User id: 1, first_name: "Penélope", last_name: nil&gt;

# Find the first user named "Scarlett" or create a new one with
# a particular last name.
User.create_with(last_name: 'Johansson').find_or_create_by(first_name: 'Scarlett')
# =&gt; #&lt;User id: 2, first_name: "Scarlett", last_name: "Johansson"&gt;
</pre> <p>This method accepts a block, which is passed down to <a href="relation.html#method-i-create"><code>create</code></a>. The last example above can be alternatively written this way:</p> <pre class="ruby" data-language="ruby"># Find the first user named "Scarlett" or create a new one with a
# particular last name.
User.find_or_create_by(first_name: 'Scarlett') do |user|
  user.last_name = 'Johansson'
end
# =&gt; #&lt;User id: 2, first_name: "Scarlett", last_name: "Johansson"&gt;
</pre> <p>This method always returns a record, but if creation was attempted and failed due to validation errors it won’t be persisted, you get what <a href="relation.html#method-i-create"><code>create</code></a> returns in such situation.</p> <p>If creation failed because of a unique constraint, this method will assume it encountered a race condition and will try finding the record once more If somehow the second find still find no record because a concurrent DELETE happened, it will then raise an <a href="recordnotfound.html"><code>ActiveRecord::RecordNotFound</code></a> exception.</p> <p>Please note <strong>this method is not atomic</strong>, it runs first a SELECT, and if there are no results an INSERT is attempted. So if the table doesn’t have a relevant unique constraint it could be the case that you end up with two or more similar records.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-find_or_create_by-21"> <span class="method-name">find_or_create_by!</span><span class="method-args">(attributes, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="find_or_create_by-21-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 182
def find_or_create_by!(attributes, &amp;block)
  find_by(attributes) || create_or_find_by!(attributes, &amp;block)
end</pre> </div> <p>Like <a href="relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a>, but calls <a href="persistence/classmethods.html#method-i-create-21">create!</a> so an exception is raised if the created record is invalid.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-find_or_initialize_by"> <span class="method-name">find_or_initialize_by</span><span class="method-args">(attributes, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="find_or_initialize_by-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 240
def find_or_initialize_by(attributes, &amp;block)
  find_by(attributes) || new(attributes, &amp;block)
end</pre> </div> <p>Like <a href="relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a>, but calls new instead of <a href="persistence/classmethods.html#method-i-create">create</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-initialize_copy"> <span class="method-name">initialize_copy</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="initialize_copy-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 41
def initialize_copy(other)
  @values = @values.dup
  reset
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-name">inspect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 831
def inspect
  subject = loaded? ? records : annotate("loading for inspect")
  entries = subject.take([limit_value, 11].compact.min).map!(&amp;:inspect)

  entries[10] = "..." if entries.size == 11

  "#&lt;#{self.class.name} [#{entries.join(', ')}]&gt;"
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-joined_includes_values"> <span class="method-name">joined_includes_values</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="joined_includes_values-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 793
def joined_includes_values
  includes_values &amp; joins_values
end</pre> </div> <p>Joins that are also marked for preloading. In which case we should just eager load them. Note that this is a naive implementation because we could have strings and symbols which represent the same association, but that aren’t matched by this. Also, we could have nested hashes which partially match, e.g. <code>{ a: :b } &amp; { a: [:b, :c] }</code></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-load"> <span class="method-name">load</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="load-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 725
def load(&amp;block)
  if !loaded? || scheduled?
    @records = exec_queries(&amp;block)
    @loaded = true
  end

  self
end</pre> </div> <p>Causes the records to be loaded from the database if they have not been loaded already. You can use this if for some reason you need to explicitly load some records before actually using them. The return value is the relation itself, not the records.</p> <pre class="ruby" data-language="ruby">Post.where(published: true).load # =&gt; #&lt;ActiveRecord::Relation&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-load_async"> <span class="method-name">load_async</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="load_async-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 696
def load_async
  return load if !connection.async_enabled?

  unless loaded?
    result = exec_main_query(async: connection.current_transaction.closed?)

    if result.is_a?(Array)
      @records = result
    else
      @future_result = result
    end
    @loaded = true
  end

  self
end</pre> </div> <p>Schedule the query to be performed from a background thread pool.</p> <pre class="ruby" data-language="ruby">Post.where(published: true).load_async # =&gt; #&lt;ActiveRecord::Relation&gt;
</pre> <p>When the <code>Relation</code> is iterated, if the background query wasn’t executed yet, it will be performed by the foreground thread.</p> <p>Note that <a href="https://guides.rubyonrails.org/configuring.html#config-active-record-async-query-executor">config.active_record.async_query_executor</a> must be configured for queries to actually be executed concurrently. Otherwise it defaults to executing them in the foreground.</p> <p><code>load_async</code> will also fall back to executing in the foreground in the test environment when transactional fixtures are enabled.</p> <p>If the query was actually executed in the background, the Active Record logs will show it by prefixing the log line with <code>ASYNC</code>:</p> <pre>ASYNC Post Load (0.0ms) (db time 2ms)  SELECT "posts".* FROM "posts" LIMIT 100</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-many-3F"> <span class="method-name">many?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="many-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 319
def many?
  return false if @none

  return super if block_given?
  return records.many? if loaded?
  limited_count &gt; 1
end</pre> </div> <p>Returns true if there is more than one record.</p> <div class="method-calls-super"> Calls superclass method <a href="../enumerable.html#method-i-many-3F"><code>Enumerable#many?</code></a> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-new"> <span class="method-name">new</span><span class="method-args">(attributes = nil, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 69
def new(attributes = nil, &amp;block)
  if attributes.is_a?(Array)
    attributes.collect { |attr| new(attr, &amp;block) }
  else
    block = current_scope_restoring_block(&amp;block)
    scoping { _new(attributes, &amp;block) }
  end
end</pre> </div> <p>Initializes new record from relation while maintaining the current scope.</p> <p>Expects arguments in the same format as <a href="core.html#method-c-new">ActiveRecord::Base.new</a>.</p> <pre class="ruby" data-language="ruby">users = User.where(name: 'DHH')
user = users.new # =&gt; #&lt;User id: nil, name: "DHH", created_at: nil, updated_at: nil&gt;
</pre> <p>You can also pass a block to new with the new record as argument:</p> <pre class="ruby" data-language="ruby">user = users.new { |user| user.name = 'Oscar' }
user.name # =&gt; Oscar
</pre>  </div> <div class="aliases"> Also aliased as: <a href="relation.html#method-i-build">build</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-none-3F"> <span class="method-name">none?</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="none-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 294
def none?(*args)
  return true if @none

  return super if args.present? || block_given?
  empty?
end</pre> </div> <p>Returns true if there are no records.</p> <div class="method-calls-super"> Calls superclass method </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-one-3F"> <span class="method-name">one?</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="one-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 310
def one?(*args)
  return false if @none

  return super if args.present? || block_given?
  return records.one? if loaded?
  limited_count == 1
end</pre> </div> <p>Returns true if there is exactly one record.</p> <div class="method-calls-super"> Calls superclass method </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-pretty_print"> <span class="method-name">pretty_print</span><span class="method-args">(pp)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="pretty_print-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 809
def pretty_print(pp)
  subject = loaded? ? records : annotate("loading for pp")
  entries = subject.take([limit_value, 11].compact.min)

  entries[10] = "..." if entries.size == 11

  pp.pp(entries)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reload"> <span class="method-name">reload</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reload-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 735
def reload
  reset
  load
end</pre> </div> <p>Forces reloading of relation.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reset"> <span class="method-name">reset</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reset-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 740
def reset
  @future_result&amp;.cancel
  @future_result = nil
  @delegate_to_klass = false
  @to_sql = @arel = @loaded = @should_eager_load = nil
  @offsets = @take = nil
  @cache_keys = nil
  @cache_versions = nil
  @records = nil
  self
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-scheduled-3F"> <span class="method-name">scheduled?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="scheduled-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 715
def scheduled?
  !!@future_result
end</pre> </div> <p>Returns <code>true</code> if the relation was scheduled on the background thread pool.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-scope_for_create"> <span class="method-name">scope_for_create</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="scope_for_create-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 776
def scope_for_create
  hash = where_clause.to_h(klass.table_name, equality_only: true)
  create_with_value.each { |k, v| hash[k.to_s] = v } unless create_with_value.empty?
  hash
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-scoping"> <span class="method-name">scoping</span><span class="method-args">(all_queries: nil) { || ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="scoping-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 445
def scoping(all_queries: nil, &amp;block)
  registry = klass.scope_registry
  if global_scope?(registry) &amp;&amp; all_queries == false
    raise ArgumentError, "Scoping is set to apply to all queries and cannot be unset in a nested block."
  elsif already_in_scope?(registry)
    yield
  else
    _scoping(self, registry, all_queries, &amp;block)
  end
end</pre> </div> <p>Scope all queries to the current scope.</p> <pre class="ruby" data-language="ruby">Comment.where(post_id: 1).scoping do
  Comment.first
end
# SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 1 ORDER BY "comments"."id" ASC LIMIT 1
</pre> <p>If <code>all_queries: true</code> is passed, scoping will apply to all queries for the relation including <code>update</code> and <code>delete</code> on instances. Once <code>all_queries</code> is set to true it cannot be set to false in a nested block.</p> <p>Please check unscoped if you want to remove all previous scopes (including the default_scope) during the execution of a block.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-size"> <span class="method-name">size</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 274
def size
  if loaded?
    records.length
  else
    count(:all)
  end
end</pre> </div> <p>Returns size of the records.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <span class="method-name">to_a</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="relation.html#method-i-to_ary">to_ary</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_ary"> <span class="method-name">to_ary</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_ary-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 258
def to_ary
  records.dup
end</pre> </div> <p>Converts relation objects to <a href="../array.html"><code>Array</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="relation.html#method-i-to_a">to_a</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_sql"> <span class="method-name">to_sql</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_sql-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 756
def to_sql
  @to_sql ||= if eager_loading?
    apply_join_dependency do |relation, join_dependency|
      relation = join_dependency.apply_column_aliases(relation)
      relation.to_sql
    end
  else
    conn = klass.connection
    conn.unprepared_statement { conn.to_sql(arel) }
  end
end</pre> </div> <p>Returns sql statement for the relation.</p> <pre class="ruby" data-language="ruby">User.where(name: 'Oscar').to_sql
# SELECT "users".* FROM "users"  WHERE "users"."name" = 'Oscar'
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-touch_all"> <span class="method-name">touch_all</span><span class="method-args">(*names, time: nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="touch_all-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 589
def touch_all(*names, time: nil)
  update_all klass.touch_attributes_with_time(*names, time: time)
end</pre> </div> <p>Touches all records in the current relation, setting the <code>updated_at</code>/<code>updated_on</code> attributes to the current time or the time specified. It does not instantiate the involved models, and it does not trigger Active Record callbacks or validations. This method can be passed attribute names and an optional time argument. If attribute names are passed, they are updated along with <code>updated_at</code>/<code>updated_on</code> attributes. If no time argument is passed, the current time is used as default.</p> <h3 id="method-i-touch_all-label-Examples">Examples</h3> <pre class="ruby" data-language="ruby"># Touch all records
Person.all.touch_all
# =&gt; "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670'"

# Touch multiple records with a custom attribute
Person.all.touch_all(:created_at)
# =&gt; "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670', \"created_at\" = '2018-01-04 22:55:23.132670'"

# Touch multiple records with a specified time
Person.all.touch_all(time: Time.new(2020, 5, 16, 0, 0, 0))
# =&gt; "UPDATE \"people\" SET \"updated_at\" = '2020-05-16 00:00:00'"

# Touch records with scope
Person.where(name: 'David').touch_all
# =&gt; "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670' WHERE \"people\".\"name\" = 'David'"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-update_all"> <span class="method-name">update_all</span><span class="method-args">(updates)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="update_all-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 492
def update_all(updates)
  raise ArgumentError, "Empty list of attributes to change" if updates.blank?

  return 0 if @none

  if updates.is_a?(Hash)
    if klass.locking_enabled? &amp;&amp;
        !updates.key?(klass.locking_column) &amp;&amp;
        !updates.key?(klass.locking_column.to_sym)
      attr = table[klass.locking_column]
      updates[attr.name] = _increment_attribute(attr)
    end
    values = _substitute_values(updates)
  else
    values = Arel.sql(klass.sanitize_sql_for_assignment(updates, table.name))
  end

  arel = eager_loading? ? apply_join_dependency.arel : build_arel
  arel.source.left = table

  group_values_arel_columns = arel_columns(group_values.uniq)
  having_clause_ast = having_clause.ast unless having_clause.empty?
  stmt = arel.compile_update(values, table[primary_key], having_clause_ast, group_values_arel_columns)
  klass.connection.update(stmt, "#{klass} Update All").tap { reset }
end</pre> </div> <p>Updates all records in the current relation with details given. This method constructs a single SQL UPDATE statement and sends it straight to the database. It does not instantiate the involved models and it does not trigger Active Record callbacks or validations. However, values passed to <a href="relation.html#method-i-update_all"><code>update_all</code></a> will still go through Active Record’s normal type casting and serialization. Returns the number of rows affected.</p> <p>Note: As Active Record callbacks are not triggered, this method will not automatically update <code>updated_at</code>/<code>updated_on</code> columns.</p> <h4 id="method-i-update_all-label-Parameters">Parameters</h4> <ul><li> <p><code>updates</code> - A string, array, or hash representing the SET part of an SQL statement. Any strings provided will be type cast, unless you use <code>Arel.sql</code>. (Don’t pass user-provided values to <code>Arel.sql</code>.)</p> </li></ul> <h4 id="method-i-update_all-label-Examples">Examples</h4> <pre class="ruby" data-language="ruby"># Update all customers with the given attributes
Customer.update_all wants_email: true

# Update all books with 'Rails' in their title
Book.where('title LIKE ?', '%Rails%').update_all(author: 'David')

# Update all books that match conditions, but limit it to 5 ordered by date
Book.where('title LIKE ?', '%Rails%').order(:created_at).limit(5).update_all(author: 'David')

# Update all invoices and set the number column to its id value.
Invoice.update_all('number = id')

# Update all books with 'Rails' in their title
Book.where('title LIKE ?', '%Rails%').update_all(title: Arel.sql("title + ' - volume 1'"))
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-update_counters"> <span class="method-name">update_counters</span><span class="method-args">(counters)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="update_counters-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 546
def update_counters(counters)
  touch = counters.delete(:touch)

  updates = {}
  counters.each do |counter_name, value|
    attr = table[counter_name]
    updates[attr.name] = _increment_attribute(attr, value)
  end

  if touch
    names = touch if touch != true
    names = Array.wrap(names)
    options = names.extract_options!
    touch_updates = klass.touch_attributes_with_time(*names, **options)
    updates.merge!(touch_updates) unless touch_updates.empty?
  end

  update_all updates
end</pre> </div> <p>Updates the counters of the records in the current relation.</p> <h4 id="method-i-update_counters-label-Parameters">Parameters</h4> <ul>
<li> <p><code>counter</code> - A <a href="../hash.html"><code>Hash</code></a> containing the names of the fields to update as keys and the amount to update as values.</p> </li>
<li> <p><code>:touch</code> option - Touch the timestamp columns when updating.</p> </li>
<li> <p>If attributes names are passed, they are updated along with update_at/on attributes.</p> </li>
</ul> <h4 id="method-i-update_counters-label-Examples">Examples</h4> <pre class="ruby" data-language="ruby"># For Posts by a given author increment the comment_count by 1.
Post.where(author_id: author.id).update_counters(comment_count: 1)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-values"> <span class="method-name">values</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="values-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 823
def values
  @values.dup
end</pre> </div>  </div> </div> </section> <section id="protected-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Protected Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-load_records"> <span class="method-name">load_records</span><span class="method-args">(records)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="load_records-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation.rb, line 872
def load_records(records)
  @records = records.freeze
  @loaded = true
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2021 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>
