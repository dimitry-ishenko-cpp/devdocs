<h1>Caching with Rails: An Overview</h1>
<div class="_simple"> <p>This guide is an introduction to speeding up your Rails application with caching.</p>
<p>Caching means to store content generated during the request-response cycle and to reuse it when responding to similar requests.</p>
<p>Caching is often the most effective way to boost an application's performance. Through caching, websites running on a single server with a single database can sustain a load of thousands of concurrent users.</p>
<p>Rails provides a set of caching features out of the box. This guide will teach you the scope and purpose of each one of them. Master these techniques and your Rails applications can serve millions of views without exorbitant response times or server bills.</p>
<p>After reading this guide, you will know:</p> <ul> <li>Fragment and Russian doll caching.</li> <li>How to manage the caching dependencies.</li> <li>Alternative cache stores.</li> <li>Conditional GET support.</li> </ul>  <h2 class="chapter">Chapters</h2> <ol class="chapters"> <li>
<a href="#basic-caching">Basic Caching</a> <ul> <li><a href="#page-caching">Page Caching</a></li> <li><a href="#action-caching">Action Caching</a></li> <li><a href="#fragment-caching">Fragment Caching</a></li> <li><a href="#russian-doll-caching">Russian Doll Caching</a></li> <li><a href="#shared-partial-caching">Shared Partial Caching</a></li> <li><a href="#managing-dependencies">Managing Dependencies</a></li> <li><a href="#low-level-caching">Low-Level Caching</a></li> <li><a href="#sql-caching">SQL Caching</a></li> </ul>
</li> <li>
<a href="#cache-stores">Cache Stores</a> <ul> <li><a href="#configuration">Configuration</a></li> <li><a href="#activesupport-cache-store"><code>ActiveSupport::Cache::Store</code></a></li> <li><a href="#activesupport-cache-memorystore"><code>ActiveSupport::Cache::MemoryStore</code></a></li> <li><a href="#activesupport-cache-filestore"><code>ActiveSupport::Cache::FileStore</code></a></li> <li><a href="#activesupport-cache-memcachestore"><code>ActiveSupport::Cache::MemCacheStore</code></a></li> <li><a href="#activesupport-cache-rediscachestore"><code>ActiveSupport::Cache::RedisCacheStore</code></a></li> <li><a href="#activesupport-cache-nullstore"><code>ActiveSupport::Cache::NullStore</code></a></li> <li><a href="#custom-cache-stores">Custom Cache Stores</a></li> </ul>
</li> <li><a href="#cache-keys">Cache Keys</a></li> <li>
<a href="#conditional-get-support">Conditional GET Support</a> <ul> <li><a href="#strong-v-s-weak-etags">Strong v/s Weak ETags</a></li> </ul>
</li> <li><a href="#caching-in-development">Caching in Development</a></li> <li><a href="#references">References</a></li> </ol>   <h1 id="basic-caching"><a class="anchorlink" href="#basic-caching">1 Basic Caching</a></h1>
<p>This is an introduction to three types of caching techniques: page, action and fragment caching. By default Rails provides fragment caching. In order to use page and action caching you will need to add <code>actionpack-page_caching</code> and <code>actionpack-action_caching</code> to your <code>Gemfile</code>.</p>
<p>By default, caching is only enabled in your production environment. You can play around with caching locally by running <code>rails dev:cache</code>, or by setting <a href="configuring.html#config-action-controller-perform-caching"><code>config.action_controller.perform_caching</code></a> to <code>true</code> in <code>config/environments/development.rb</code>.</p>
<div class="note"><p>Changing the value of <code>config.action_controller.perform_caching</code> will only have an effect on the caching provided by Action Controller. For instance, it will not impact low-level caching, that we address <a href="#low-level-caching">below</a>.</p></div>
<h2 id="page-caching"><a class="anchorlink" href="#page-caching">1.1 Page Caching</a></h2>
<p>Page caching is a Rails mechanism which allows the request for a generated page to be fulfilled by the web server (i.e. Apache or NGINX) without having to go through the entire Rails stack. While this is super fast it can't be applied to every situation (such as pages that need authentication). Also, because the web server is serving a file directly from the filesystem you will need to implement cache expiration.</p>
<div class="info"><p>Page Caching has been removed from Rails 4. See the <a href="https://github.com/rails/actionpack-page_caching">actionpack-page_caching gem</a>.</p></div>
<h2 id="action-caching"><a class="anchorlink" href="#action-caching">1.2 Action Caching</a></h2>
<p>Page Caching cannot be used for actions that have before filters - for example, pages that require authentication. This is where Action Caching comes in. Action Caching works like Page Caching except the incoming web request hits the Rails stack so that before filters can be run on it before the cache is served. This allows authentication and other restrictions to be run while still serving the result of the output from a cached copy.</p>
<div class="info"><p>Action Caching has been removed from Rails 4. See the <a href="https://github.com/rails/actionpack-action_caching">actionpack-action_caching gem</a>. See <a href="https://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works">DHH's key-based cache expiration overview</a> for the newly-preferred method.</p></div>
<h2 id="fragment-caching"><a class="anchorlink" href="#fragment-caching">1.3 Fragment Caching</a></h2>
<p>Dynamic web applications usually build pages with a variety of components not all of which have the same caching characteristics. When different parts of the page need to be cached and expired separately you can use Fragment Caching.</p>
<p>Fragment Caching allows a fragment of view logic to be wrapped in a cache block and served out of the cache store when the next request comes in.</p>
<p>For example, if you wanted to cache each product on a page, you could use this code:</p> <pre data-language="erb">&lt;% @products.each do |product| %&gt;
  &lt;% cache product do %&gt;
    &lt;%= render product %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;% @products.each do |product| %&gt;
  &lt;% cache product do %&gt;
    &lt;%= render product %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
">Copy</button>  <p>When your application receives its first request to this page, Rails will write a new cache entry with a unique key. A key looks something like this:</p> <pre data-language="plaintext">views/products/index:bea67108094918eeba42cd4a6e786901/products/1</pre> <button class="clipboard-button" data-clipboard-text="views/products/index:bea67108094918eeba42cd4a6e786901/products/1
">Copy</button>  <p>The string of characters in the middle is a template tree digest. It is a hash digest computed based on the contents of the view fragment you are caching. If you change the view fragment (e.g., the HTML changes), the digest will change, expiring the existing file.</p>
<p>A cache version, derived from the product record, is stored in the cache entry. When the product is touched, the cache version changes, and any cached fragments that contain the previous version are ignored.</p>
<div class="info"><p>Cache stores like Memcached will automatically delete old cache files.</p></div>
<p>If you want to cache a fragment under certain conditions, you can use <code>cache_if</code> or <code>cache_unless</code>:</p> <pre data-language="erb">&lt;% cache_if admin?, product do %&gt;
  &lt;%= render product %&gt;
&lt;% end %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;% cache_if admin?, product do %&gt;
  &lt;%= render product %&gt;
&lt;% end %&gt;
">Copy</button>  <h3 id="collection-caching"><a class="anchorlink" href="#collection-caching">1.3.1 Collection Caching</a></h3>
<p>The <code>render</code> helper can also cache individual templates rendered for a collection. It can even one up the previous example with <code>each</code> by reading all cache templates at once instead of one by one. This is done by passing <code>cached: true</code> when rendering the collection:</p> <pre data-language="erb">&lt;%= render partial: 'products/product', collection: @products, cached: true %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%= render partial: 'products/product', collection: @products, cached: true %&gt;
">Copy</button>  <p>All cached templates from previous renders will be fetched at once with much greater speed. Additionally, the templates that haven't yet been cached will be written to cache and multi fetched on the next render.</p>
<h2 id="russian-doll-caching"><a class="anchorlink" href="#russian-doll-caching">1.4 Russian Doll Caching</a></h2>
<p>You may want to nest cached fragments inside other cached fragments. This is called Russian doll caching.</p>
<p>The advantage of Russian doll caching is that if a single product is updated, all the other inner fragments can be reused when regenerating the outer fragment.</p>
<p>As explained in the previous section, a cached file will expire if the value of <code>updated_at</code> changes for a record on which the cached file directly depends. However, this will not expire any cache the fragment is nested within.</p>
<p>For example, take the following view:</p> <pre data-language="erb">&lt;% cache product do %&gt;
  &lt;%= render product.games %&gt;
&lt;% end %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;% cache product do %&gt;
  &lt;%= render product.games %&gt;
&lt;% end %&gt;
">Copy</button>  <p>Which in turn renders this view:</p> <pre data-language="erb">&lt;% cache game do %&gt;
  &lt;%= render game %&gt;
&lt;% end %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;% cache game do %&gt;
  &lt;%= render game %&gt;
&lt;% end %&gt;
">Copy</button>  <p>If any attribute of game is changed, the <code>updated_at</code> value will be set to the current time, thereby expiring the cache. However, because <code>updated_at</code> will not be changed for the product object, that cache will not be expired and your app will serve stale data. To fix this, we tie the models together with the <code>touch</code> method:</p> <pre data-language="ruby">class Product &lt; ApplicationRecord
  has_many :games
end

class Game &lt; ApplicationRecord
  belongs_to :product, touch: true
end</pre> <button class="clipboard-button" data-clipboard-text="class Product &lt; ApplicationRecord
  has_many :games
end

class Game &lt; ApplicationRecord
  belongs_to :product, touch: true
end
">Copy</button>  <p>With <code>touch</code> set to <code>true</code>, any action which changes <code>updated_at</code> for a game record will also change it for the associated product, thereby expiring the cache.</p>
<h2 id="shared-partial-caching"><a class="anchorlink" href="#shared-partial-caching">1.5 Shared Partial Caching</a></h2>
<p>It is possible to share partials and associated caching between files with different MIME types. For example shared partial caching allows template writers to share a partial between HTML and JavaScript files. When templates are collected in the template resolver file paths they only include the template language extension and not the MIME type. Because of this templates can be used for multiple MIME types. Both HTML and JavaScript requests will respond to the following code:</p> <pre data-language="ruby">render(partial: 'hotels/hotel', collection: @hotels, cached: true)</pre> <button class="clipboard-button" data-clipboard-text="render(partial: 'hotels/hotel', collection: @hotels, cached: true)
">Copy</button>  <p>Will load a file named <code>hotels/hotel.erb</code>.</p>
<p>Another option is to include the full filename of the partial to render.</p> <pre data-language="ruby">render(partial: 'hotels/hotel.html.erb', collection: @hotels, cached: true)</pre> <button class="clipboard-button" data-clipboard-text="render(partial: 'hotels/hotel.html.erb', collection: @hotels, cached: true)
">Copy</button>  <p>Will load a file named <code>hotels/hotel.html.erb</code> in any file MIME type, for example you could include this partial in a JavaScript file.</p>
<h2 id="managing-dependencies"><a class="anchorlink" href="#managing-dependencies">1.6 Managing Dependencies</a></h2>
<p>In order to correctly invalidate the cache, you need to properly define the caching dependencies. Rails is clever enough to handle common cases so you don't have to specify anything. However, sometimes, when you're dealing with custom helpers for instance, you need to explicitly define them.</p>
<h3 id="implicit-dependencies"><a class="anchorlink" href="#implicit-dependencies">1.6.1 Implicit Dependencies</a></h3>
<p>Most template dependencies can be derived from calls to <code>render</code> in the template itself. Here are some examples of render calls that <code>ActionView::Digestor</code> knows how to decode:</p> <pre data-language="ruby">render partial: "comments/comment", collection: commentable.comments
render "comments/comments"
render 'comments/comments'
render('comments/comments')

render "header" # translates to render("comments/header")

render(@topic)         # translates to render("topics/topic")
render(topics)         # translates to render("topics/topic")
render(message.topics) # translates to render("topics/topic")</pre> <button class="clipboard-button" data-clipboard-text="render partial: &quot;comments/comment&quot;, collection: commentable.comments
render &quot;comments/comments&quot;
render 'comments/comments'
render('comments/comments')

render &quot;header&quot; # translates to render(&quot;comments/header&quot;)

render(@topic)         # translates to render(&quot;topics/topic&quot;)
render(topics)         # translates to render(&quot;topics/topic&quot;)
render(message.topics) # translates to render(&quot;topics/topic&quot;)
">Copy</button>  <p>On the other hand, some calls need to be changed to make caching work properly. For instance, if you're passing a custom collection, you'll need to change:</p> <pre data-language="ruby">render @project.documents.where(published: true)</pre> <button class="clipboard-button" data-clipboard-text="render @project.documents.where(published: true)
">Copy</button>  <p>to:</p> <pre data-language="ruby">render partial: "documents/document", collection: @project.documents.where(published: true)</pre> <button class="clipboard-button" data-clipboard-text='render partial: "documents/document", collection: @project.documents.where(published: true)
'>Copy</button>  <h3 id="explicit-dependencies"><a class="anchorlink" href="#explicit-dependencies">1.6.2 Explicit Dependencies</a></h3>
<p>Sometimes you'll have template dependencies that can't be derived at all. This is typically the case when rendering happens in helpers. Here's an example:</p> <pre data-language="erb">&lt;%= render_sortable_todolists @project.todolists %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%= render_sortable_todolists @project.todolists %&gt;
">Copy</button>  <p>You'll need to use a special comment format to call those out:</p> <pre data-language="erb">&lt;%# Template Dependency: todolists/todolist %&gt;
&lt;%= render_sortable_todolists @project.todolists %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%# Template Dependency: todolists/todolist %&gt;
&lt;%= render_sortable_todolists @project.todolists %&gt;
">Copy</button>  <p>In some cases, like a single table inheritance setup, you might have a bunch of explicit dependencies. Instead of writing every template out, you can use a wildcard to match any template in a directory:</p> <pre data-language="erb">&lt;%# Template Dependency: events/* %&gt;
&lt;%= render_categorizable_events @person.events %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%# Template Dependency: events/* %&gt;
&lt;%= render_categorizable_events @person.events %&gt;
">Copy</button>  <p>As for collection caching, if the partial template doesn't start with a clean cache call, you can still benefit from collection caching by adding a special comment format anywhere in the template, like:</p> <pre data-language="erb">&lt;%# Template Collection: notification %&gt;
&lt;% my_helper_that_calls_cache(some_arg, notification) do %&gt;
  &lt;%= notification.name %&gt;
&lt;% end %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%# Template Collection: notification %&gt;
&lt;% my_helper_that_calls_cache(some_arg, notification) do %&gt;
  &lt;%= notification.name %&gt;
&lt;% end %&gt;
">Copy</button>  <h3 id="external-dependencies"><a class="anchorlink" href="#external-dependencies">1.6.3 External Dependencies</a></h3>
<p>If you use a helper method, for example, inside a cached block and you then update that helper, you'll have to bump the cache as well. It doesn't really matter how you do it, but the MD5 of the template file must change. One recommendation is to simply be explicit in a comment, like:</p> <pre data-language="erb">&lt;%# Helper Dependency Updated: Jul 28, 2015 at 7pm %&gt;
&lt;%= some_helper_method(person) %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%# Helper Dependency Updated: Jul 28, 2015 at 7pm %&gt;
&lt;%= some_helper_method(person) %&gt;
">Copy</button>  <h2 id="low-level-caching"><a class="anchorlink" href="#low-level-caching">1.7 Low-Level Caching</a></h2>
<p>Sometimes you need to cache a particular value or query result instead of caching view fragments. Rails' caching mechanism works great for storing any serializable information.</p>
<p>The most efficient way to implement low-level caching is using the <code>Rails.cache.fetch</code> method. This method does both reading and writing to the cache. When passed only a single argument, the key is fetched and value from the cache is returned. If a block is passed, that block will be executed in the event of a cache miss. The return value of the block will be written to the cache under the given cache key, and that return value will be returned. In case of cache hit, the cached value will be returned without executing the block.</p>
<p>Consider the following example. An application has a <code>Product</code> model with an instance method that looks up the product's price on a competing website. The data returned by this method would be perfect for low-level caching:</p> <pre data-language="ruby">class Product &lt; ApplicationRecord
  def competing_price
    Rails.cache.fetch("#{cache_key_with_version}/competing_price", expires_in: 12.hours) do
      Competitor::API.find_price(id)
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class Product &lt; ApplicationRecord
  def competing_price
    Rails.cache.fetch("#{cache_key_with_version}/competing_price", expires_in: 12.hours) do
      Competitor::API.find_price(id)
    end
  end
end
'>Copy</button>  <div class="note"><p>Notice that in this example we used the <code>cache_key_with_version</code> method, so the resulting cache key will be something like <code>products/233-20140225082222765838000/competing_price</code>. <code>cache_key_with_version</code> generates a string based on the model's class name, <code>id</code>, and <code>updated_at</code> attributes. This is a common convention and has the benefit of invalidating the cache whenever the product is updated. In general, when you use low-level caching, you need to generate a cache key.</p></div>
<h3 id="avoid-caching-instances-of-active-record-objects"><a class="anchorlink" href="#avoid-caching-instances-of-active-record-objects">1.7.1 Avoid Caching Instances of Active Record Objects</a></h3>
<p>Consider this example, which stores a list of Active Record objects representing superusers in the cache:</p> <pre data-language="ruby"># super_admins is an expensive SQL query, so don't run it too often
Rails.cache.fetch("super_admin_users", expires_in: 12.hours) do
  User.super_admins.to_a
end</pre> <button class="clipboard-button" data-clipboard-text="# super_admins is an expensive SQL query, so don't run it too often
Rails.cache.fetch(&quot;super_admin_users&quot;, expires_in: 12.hours) do
  User.super_admins.to_a
end
">Copy</button>  <p>You should <strong>avoid</strong> this pattern. Why? Because the instance could change. In production, attributes on it could differ, or the record could be deleted. And in development, it works unreliably with cache stores that reload code when you make changes.</p>
<p>Instead, cache the ID or some other primitive data type. For example:</p> <pre data-language="ruby"># super_admins is an expensive SQL query, so don't run it too often
ids = Rails.cache.fetch("super_admin_user_ids", expires_in: 12.hours) do
  User.super_admins.pluck(:id)
end
User.where(id: ids).to_a</pre> <button class="clipboard-button" data-clipboard-text="# super_admins is an expensive SQL query, so don't run it too often
ids = Rails.cache.fetch(&quot;super_admin_user_ids&quot;, expires_in: 12.hours) do
  User.super_admins.pluck(:id)
end
User.where(id: ids).to_a
">Copy</button>  <h2 id="sql-caching"><a class="anchorlink" href="#sql-caching">1.8 SQL Caching</a></h2>
<p>Query caching is a Rails feature that caches the result set returned by each query. If Rails encounters the same query again for that request, it will use the cached result set as opposed to running the query against the database again.</p>
<p>For example:</p> <pre data-language="ruby">class ProductsController &lt; ApplicationController
  def index
    # Run a find query
    @products = Product.all

    # ...

    # Run the same query again
    @products = Product.all
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ProductsController &lt; ApplicationController
  def index
    # Run a find query
    @products = Product.all

    # ...

    # Run the same query again
    @products = Product.all
  end
end
">Copy</button>  <p>The second time the same query is run against the database, it's not actually going to hit the database. The first time the result is returned from the query it is stored in the query cache (in memory) and the second time it's pulled from memory.</p>
<p>However, it's important to note that query caches are created at the start of an action and destroyed at the end of that action and thus persist only for the duration of the action. If you'd like to store query results in a more persistent fashion, you can with low-level caching.</p>
<h1 id="cache-stores"><a class="anchorlink" href="#cache-stores">2 Cache Stores</a></h1>
<p>Rails provides different stores for the cached data (apart from SQL and page caching).</p>
<h2 id="configuration"><a class="anchorlink" href="#configuration">2.1 Configuration</a></h2>
<p>You can set up your application's default cache store by setting the <code>config.cache_store</code> configuration option. Other parameters can be passed as arguments to the cache store's constructor:</p> <pre data-language="ruby">config.cache_store = :memory_store, { size: 64.megabytes }</pre> <button class="clipboard-button" data-clipboard-text="config.cache_store = :memory_store, { size: 64.megabytes }
">Copy</button>  <p>Alternatively, you can set <code>ActionController::Base.cache_store</code> outside of a configuration block.</p>
<p>You can access the cache by calling <code>Rails.cache</code>.</p>
<h3 id="connection-pool-options"><a class="anchorlink" href="#connection-pool-options">2.1.1 Connection Pool Options</a></h3>
<p>By default, <a href="#activesupport-cache-memcachestore"><code>:mem_cache_store</code></a> and <a href="#activesupport-cache-rediscachestore"><code>:redis_cache_store</code></a> are configured to use connection pooling. This means that if you're using Puma, or another threaded server, you can have multiple threads performing queries to the cache store at the same time.</p>
<p>If you want to disable connection pooling, set <code>:pool</code> option to <code>false</code> when configuring the cache store:</p> <pre data-language="ruby">config.cache_store = :mem_cache_store, "cache.example.com", { pool: false }</pre> <button class="clipboard-button" data-clipboard-text='config.cache_store = :mem_cache_store, "cache.example.com", { pool: false }
'>Copy</button>  <p>You can also override default pool settings by providing individual options to the <code>:pool</code> option:</p> <pre data-language="ruby">config.cache_store = :mem_cache_store, "cache.example.com", { pool: { size: 32, timeout: 1 } }</pre> <button class="clipboard-button" data-clipboard-text='config.cache_store = :mem_cache_store, "cache.example.com", { pool: { size: 32, timeout: 1 } }
'>Copy</button>  <ul> <li><p><code>:size</code> - This option sets the number of connections per process (defaults to 5).</p></li> <li><p><code>:timeout</code> - This option sets the number of seconds to wait for a connection (defaults to 5). If no connection is available within the timeout, a <code>Timeout::Error</code> will be raised.</p></li> </ul> <h2 id="activesupport-cache-store"><a class="anchorlink" href="#activesupport-cache-store">2.2 <code>ActiveSupport::Cache::Store</code></a></h2>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/Store.html"><code>ActiveSupport::Cache::Store</code></a> provides the foundation for interacting with the cache in Rails. This is an abstract class, and you cannot use it on its own. Instead, you must use a concrete implementation of the class tied to a storage engine. Rails ships with several implementations, documented below.</p>
<p>The main API methods are <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-read"><code>read</code></a>, <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-write"><code>write</code></a>, <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-delete"><code>delete</code></a>, <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-exist-3F"><code>exist?</code></a>, and <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-fetch"><code>fetch</code></a>.</p>
<p>Options passed to the cache store's constructor will be treated as default options for the appropriate API methods.</p>
<h2 id="activesupport-cache-memorystore"><a class="anchorlink" href="#activesupport-cache-memorystore">2.3 <code>ActiveSupport::Cache::MemoryStore</code></a></h2>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/MemoryStore.html"><code>ActiveSupport::Cache::MemoryStore</code></a> keeps entries in memory in the same Ruby process. The cache store has a bounded size specified by sending the <code>:size</code> option to the initializer (default is 32Mb). When the cache exceeds the allotted size, a cleanup will occur and the least recently used entries will be removed.</p> <pre data-language="ruby">config.cache_store = :memory_store, { size: 64.megabytes }</pre> <button class="clipboard-button" data-clipboard-text="config.cache_store = :memory_store, { size: 64.megabytes }
">Copy</button>  <p>If you're running multiple Ruby on Rails server processes (which is the case if you're using Phusion Passenger or puma clustered mode), then your Rails server process instances won't be able to share cache data with each other. This cache store is not appropriate for large application deployments. However, it can work well for small, low traffic sites with only a couple of server processes, as well as development and test environments.</p>
<p>New Rails projects are configured to use this implementation in the development environment by default.</p>
<div class="note"><p>Since processes will not share cache data when using <code>:memory_store</code>, it will not be possible to manually read, write, or expire the cache via the Rails console.</p></div>
<h2 id="activesupport-cache-filestore"><a class="anchorlink" href="#activesupport-cache-filestore">2.4 <code>ActiveSupport::Cache::FileStore</code></a></h2>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/FileStore.html"><code>ActiveSupport::Cache::FileStore</code></a> uses the file system to store entries. The path to the directory where the store files will be stored must be specified when initializing the cache.</p> <pre data-language="ruby">config.cache_store = :file_store, "/path/to/cache/directory"</pre> <button class="clipboard-button" data-clipboard-text='config.cache_store = :file_store, "/path/to/cache/directory"
'>Copy</button>  <p>With this cache store, multiple server processes on the same host can share a cache. This cache store is appropriate for low to medium traffic sites that are served off one or two hosts. Server processes running on different hosts could share a cache by using a shared file system, but that setup is not recommended.</p>
<p>As the cache will grow until the disk is full, it is recommended to periodically clear out old entries.</p>
<p>This is the default cache store implementation (at <code>"#{root}/tmp/cache/"</code>) if no explicit <code>config.cache_store</code> is supplied.</p>
<h2 id="activesupport-cache-memcachestore"><a class="anchorlink" href="#activesupport-cache-memcachestore">2.5 <code>ActiveSupport::Cache::MemCacheStore</code></a></h2>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/MemCacheStore.html"><code>ActiveSupport::Cache::MemCacheStore</code></a> uses Danga's <code>memcached</code> server to provide a centralized cache for your application. Rails uses the bundled <code>dalli</code> gem by default. This is currently the most popular cache store for production websites. It can be used to provide a single, shared cache cluster with very high performance and redundancy.</p>
<p>When initializing the cache, you should specify the addresses for all memcached servers in your cluster, or ensure the <code>MEMCACHE_SERVERS</code> environment variable has been set appropriately.</p> <pre data-language="ruby">config.cache_store = :mem_cache_store, "cache-1.example.com", "cache-2.example.com"</pre> <button class="clipboard-button" data-clipboard-text='config.cache_store = :mem_cache_store, "cache-1.example.com", "cache-2.example.com"
'>Copy</button>  <p>If neither are specified, it will assume memcached is running on localhost on the default port (<code>127.0.0.1:11211</code>), but this is not an ideal setup for larger sites.</p> <pre data-language="ruby">config.cache_store = :mem_cache_store # Will fallback to $MEMCACHE_SERVERS, then 127.0.0.1:11211</pre> <button class="clipboard-button" data-clipboard-text="config.cache_store = :mem_cache_store # Will fallback to $MEMCACHE_SERVERS, then 127.0.0.1:11211
">Copy</button>  <p>See the <a href="https://www.rubydoc.info/gems/dalli/Dalli/Client#initialize-instance_method"><code>Dalli::Client</code> documentation</a> for supported address types.</p>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/MemCacheStore.html#method-i-write"><code>write</code></a> (and <code>fetch</code>) method on this cache accepts additional options that take advantage of features specific to memcached.</p>
<h2 id="activesupport-cache-rediscachestore"><a class="anchorlink" href="#activesupport-cache-rediscachestore">2.6 <code>ActiveSupport::Cache::RedisCacheStore</code></a></h2>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/RedisCacheStore.html"><code>ActiveSupport::Cache::RedisCacheStore</code></a> takes advantage of Redis support for automatic eviction when it reaches max memory, allowing it to behave much like a Memcached cache server.</p>
<p>Deployment note: Redis doesn't expire keys by default, so take care to use a dedicated Redis cache server. Don't fill up your persistent-Redis server with volatile cache data! Read the <a href="https://redis.io/topics/lru-cache">Redis cache server setup guide</a> in detail.</p>
<p>For a cache-only Redis server, set <code>maxmemory-policy</code> to one of the variants of allkeys. Redis 4+ supports least-frequently-used eviction (<code>allkeys-lfu</code>), an excellent default choice. Redis 3 and earlier should use least-recently-used eviction (<code>allkeys-lru</code>).</p>
<p>Set cache read and write timeouts relatively low. Regenerating a cached value is often faster than waiting more than a second to retrieve it. Both read and write timeouts default to 1 second, but may be set lower if your network is consistently low-latency.</p>
<p>By default, the cache store will attempt to reconnect to Redis once if the connection fails during a request.</p>
<p>Cache reads and writes never raise exceptions; they just return <code>nil</code> instead, behaving as if there was nothing in the cache. To gauge whether your cache is hitting exceptions, you may provide an <code>error_handler</code> to report to an exception gathering service. It must accept three keyword arguments: <code>method</code>, the cache store method that was originally called; <code>returning</code>, the value that was returned to the user, typically <code>nil</code>; and <code>exception</code>, the exception that was rescued.</p>
<p>To get started, add the redis gem to your Gemfile:</p> <pre data-language="ruby">gem 'redis'</pre> <button class="clipboard-button" data-clipboard-text="gem 'redis'
">Copy</button>  <p>Finally, add the configuration in the relevant <code>config/environments/*.rb</code> file:</p> <pre data-language="ruby">config.cache_store = :redis_cache_store, { url: ENV['REDIS_URL'] }</pre> <button class="clipboard-button" data-clipboard-text="config.cache_store = :redis_cache_store, { url: ENV['REDIS_URL'] }
">Copy</button>  <p>A more complex, production Redis cache store may look something like this:</p> <pre data-language="ruby">cache_servers = %w(redis://cache-01:6379/0 redis://cache-02:6379/0)
config.cache_store = :redis_cache_store, { url: cache_servers,

  connect_timeout:    30,  # Defaults to 1 second
  read_timeout:       0.2, # Defaults to 1 second
  write_timeout:      0.2, # Defaults to 1 second
  reconnect_attempts: 2,   # Defaults to 1

  error_handler: -&gt; (method:, returning:, exception:) {
    # Report errors to Sentry as warnings
    Sentry.capture_exception exception, level: 'warning',
      tags: { method: method, returning: returning }
  }
}</pre> <button class="clipboard-button" data-clipboard-text="cache_servers = %w(redis://cache-01:6379/0 redis://cache-02:6379/0)
config.cache_store = :redis_cache_store, { url: cache_servers,

  connect_timeout:    30,  # Defaults to 1 second
  read_timeout:       0.2, # Defaults to 1 second
  write_timeout:      0.2, # Defaults to 1 second
  reconnect_attempts: 2,   # Defaults to 1

  error_handler: -&gt; (method:, returning:, exception:) {
    # Report errors to Sentry as warnings
    Sentry.capture_exception exception, level: 'warning',
      tags: { method: method, returning: returning }
  }
}
">Copy</button>  <h2 id="activesupport-cache-nullstore"><a class="anchorlink" href="#activesupport-cache-nullstore">2.7 <code>ActiveSupport::Cache::NullStore</code></a></h2>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Cache/NullStore.html"><code>ActiveSupport::Cache::NullStore</code></a> is scoped to each web request, and clears stored values at the end of a request. It is meant for use in development and test environments. It can be very useful when you have code that interacts directly with <code>Rails.cache</code> but caching interferes with seeing the results of code changes.</p> <pre data-language="ruby">config.cache_store = :null_store</pre> <button class="clipboard-button" data-clipboard-text="config.cache_store = :null_store
">Copy</button>  <h2 id="custom-cache-stores"><a class="anchorlink" href="#custom-cache-stores">2.8 Custom Cache Stores</a></h2>
<p>You can create your own custom cache store by simply extending <code>ActiveSupport::Cache::Store</code> and implementing the appropriate methods. This way, you can swap in any number of caching technologies into your Rails application.</p>
<p>To use a custom cache store, simply set the cache store to a new instance of your custom class.</p> <pre data-language="ruby">config.cache_store = MyCacheStore.new</pre> <button class="clipboard-button" data-clipboard-text="config.cache_store = MyCacheStore.new
">Copy</button>  <h1 id="cache-keys"><a class="anchorlink" href="#cache-keys">3 Cache Keys</a></h1>
<p>The keys used in a cache can be any object that responds to either <code>cache_key</code> or <code>to_param</code>. You can implement the <code>cache_key</code> method on your classes if you need to generate custom keys. Active Record will generate keys based on the class name and record id.</p>
<p>You can use Hashes and Arrays of values as cache keys.</p> <pre data-language="ruby"># This is a legal cache key
Rails.cache.read(site: "mysite", owners: [owner_1, owner_2])</pre> <button class="clipboard-button" data-clipboard-text='# This is a legal cache key
Rails.cache.read(site: "mysite", owners: [owner_1, owner_2])
'>Copy</button>  <p>The keys you use on <code>Rails.cache</code> will not be the same as those actually used with the storage engine. They may be modified with a namespace or altered to fit technology backend constraints. This means, for instance, that you can't save values with <code>Rails.cache</code> and then try to pull them out with the <code>dalli</code> gem. However, you also don't need to worry about exceeding the memcached size limit or violating syntax rules.</p>
<h1 id="conditional-get-support"><a class="anchorlink" href="#conditional-get-support">4 Conditional GET Support</a></h1>
<p>Conditional GETs are a feature of the HTTP specification that provide a way for web servers to tell browsers that the response to a GET request hasn't changed since the last request and can be safely pulled from the browser cache.</p>
<p>They work by using the <code>HTTP_IF_NONE_MATCH</code> and <code>HTTP_IF_MODIFIED_SINCE</code> headers to pass back and forth both a unique content identifier and the timestamp of when the content was last changed. If the browser makes a request where the content identifier (ETag) or last modified since timestamp matches the server's version then the server only needs to send back an empty response with a not modified status.</p>
<p>It is the server's (i.e. our) responsibility to look for a last modified timestamp and the if-none-match header and determine whether or not to send back the full response. With conditional-get support in Rails this is a pretty easy task:</p> <pre data-language="ruby">class ProductsController &lt; ApplicationController
  def show
    @product = Product.find(params[:id])

    # If the request is stale according to the given timestamp and etag value
    # (i.e. it needs to be processed again) then execute this block
    if stale?(last_modified: @product.updated_at.utc, etag: @product.cache_key_with_version)
      respond_to do |wants|
        # ... normal response processing
      end
    end

    # If the request is fresh (i.e. it's not modified) then you don't need to do
    # anything. The default render checks for this using the parameters
    # used in the previous call to stale? and will automatically send a
    # :not_modified. So that's it, you're done.
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ProductsController &lt; ApplicationController
  def show
    @product = Product.find(params[:id])

    # If the request is stale according to the given timestamp and etag value
    # (i.e. it needs to be processed again) then execute this block
    if stale?(last_modified: @product.updated_at.utc, etag: @product.cache_key_with_version)
      respond_to do |wants|
        # ... normal response processing
      end
    end

    # If the request is fresh (i.e. it's not modified) then you don't need to do
    # anything. The default render checks for this using the parameters
    # used in the previous call to stale? and will automatically send a
    # :not_modified. So that's it, you're done.
  end
end
">Copy</button>  <p>Instead of an options hash, you can also simply pass in a model. Rails will use the <code>updated_at</code> and <code>cache_key_with_version</code> methods for setting <code>last_modified</code> and <code>etag</code>:</p> <pre data-language="ruby">class ProductsController &lt; ApplicationController
  def show
    @product = Product.find(params[:id])

    if stale?(@product)
      respond_to do |wants|
        # ... normal response processing
      end
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ProductsController &lt; ApplicationController
  def show
    @product = Product.find(params[:id])

    if stale?(@product)
      respond_to do |wants|
        # ... normal response processing
      end
    end
  end
end
">Copy</button>  <p>If you don't have any special response processing and are using the default rendering mechanism (i.e. you're not using <code>respond_to</code> or calling render yourself) then you've got an easy helper in <code>fresh_when</code>:</p> <pre data-language="ruby">class ProductsController &lt; ApplicationController
  # This will automatically send back a :not_modified if the request is fresh,
  # and will render the default template (product.*) if it's stale.

  def show
    @product = Product.find(params[:id])
    fresh_when last_modified: @product.published_at.utc, etag: @product
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ProductsController &lt; ApplicationController
  # This will automatically send back a :not_modified if the request is fresh,
  # and will render the default template (product.*) if it's stale.

  def show
    @product = Product.find(params[:id])
    fresh_when last_modified: @product.published_at.utc, etag: @product
  end
end
">Copy</button>  <p>Sometimes we want to cache response, for example a static page, that never gets expired. To achieve this, we can use <code>http_cache_forever</code> helper and by doing so browser and proxies will cache it indefinitely.</p>
<p>By default cached responses will be private, cached only on the user's web browser. To allow proxies to cache the response, set <code>public: true</code> to indicate that they can serve the cached response to all users.</p>
<p>Using this helper, <code>last_modified</code> header is set to <code>Time.new(2011, 1, 1).utc</code> and <code>expires</code> header is set to a 100 years.</p>
<div class="warning"><p>Use this method carefully as browser/proxy won't be able to invalidate the cached response unless browser cache is forcefully cleared.</p></div> <pre data-language="ruby">class HomeController &lt; ApplicationController
  def index
    http_cache_forever(public: true) do
      render
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class HomeController &lt; ApplicationController
  def index
    http_cache_forever(public: true) do
      render
    end
  end
end
">Copy</button>  <h2 id="strong-v-s-weak-etags"><a class="anchorlink" href="#strong-v-s-weak-etags">4.1 Strong v/s Weak ETags</a></h2>
<p>Rails generates weak ETags by default. Weak ETags allow semantically equivalent responses to have the same ETags, even if their bodies do not match exactly. This is useful when we don't want the page to be regenerated for minor changes in response body.</p>
<p>Weak ETags have a leading <code>W/</code> to differentiate them from strong ETags.</p> <pre data-language="plaintext">W/"618bbc92e2d35ea1945008b42799b0e7" → Weak ETag
"618bbc92e2d35ea1945008b42799b0e7" → Strong ETag</pre> <button class="clipboard-button" data-clipboard-text='W/"618bbc92e2d35ea1945008b42799b0e7" → Weak ETag
"618bbc92e2d35ea1945008b42799b0e7" → Strong ETag
'>Copy</button>  <p>Unlike weak ETag, strong ETag implies that response should be exactly the same and byte by byte identical. Useful when doing Range requests within a large video or PDF file. Some CDNs support only strong ETags, like Akamai. If you absolutely need to generate a strong ETag, it can be done as follows.</p> <pre data-language="ruby">class ProductsController &lt; ApplicationController
  def show
    @product = Product.find(params[:id])
    fresh_when last_modified: @product.published_at.utc, strong_etag: @product
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ProductsController &lt; ApplicationController
  def show
    @product = Product.find(params[:id])
    fresh_when last_modified: @product.published_at.utc, strong_etag: @product
  end
end
">Copy</button>  <p>You can also set the strong ETag directly on the response.</p> <pre data-language="ruby">response.strong_etag = response.body # =&gt; "618bbc92e2d35ea1945008b42799b0e7"</pre> <button class="clipboard-button" data-clipboard-text='response.strong_etag = response.body # =&gt; "618bbc92e2d35ea1945008b42799b0e7"
'>Copy</button>  <h1 id="caching-in-development"><a class="anchorlink" href="#caching-in-development">5 Caching in Development</a></h1>
<p>It's common to want to test the caching strategy of your application in development mode. Rails provides the rails command <code>dev:cache</code> to easily toggle caching on/off.</p> <pre data-language="console">$ bin/rails dev:cache
Development mode is now being cached.
$ bin/rails dev:cache
Development mode is no longer being cached.</pre> <button class="clipboard-button" data-clipboard-text="bin/rails dev:cache
bin/rails dev:cache
">Copy</button>  <p>By default, when development mode caching is <em>off</em>, Rails uses <a href="#activesupport-cache-nullstore"><code>:null_store</code></a>.</p>
<h1 id="references"><a class="anchorlink" href="#references">6 References</a></h1> <ul> <li><a href="https://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works">DHH's article on key-based expiration</a></li> <li><a href="http://railscasts.com/episodes/387-cache-digests">Ryan Bates' Railscast on cache digests</a></li> </ul> <h2>Feedback</h2> <p> You're encouraged to help improve the quality of this guide. </p> <p> Please contribute if you see any typos or factual errors. To get started, you can read our <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a> section. </p> <p> You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check <a href="https://edgeguides.rubyonrails.org">Edge Guides</a> first to verify if the issues are already fixed or not on the main branch. Check the <span>Ruby on Rails Guides Guidelines</span> for style and conventions. </p> <p> If for whatever reason you spot something to fix but cannot patch it yourself, please <a href="https://github.com/rails/rails/issues">open an issue</a>. </p> <p>And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">official Ruby on Rails Forum</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2021 David Heinemeier Hansson<br>Licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.<br>
    
  </p>
</div>
