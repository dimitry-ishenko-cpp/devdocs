<h1>Action Mailer Basics</h1>
<div class="_simple"> <p>This guide provides you with all you need to get started in sending emails from your application, and many internals of Action Mailer. It also covers how to test your mailers.</p>
<p>After reading this guide, you will know:</p> <ul> <li>How to send email within a Rails application.</li> <li>How to generate and edit an Action Mailer class and mailer view.</li> <li>How to configure Action Mailer for your environment.</li> <li>How to test your Action Mailer classes.</li> </ul>  <h2 class="chapter">Chapters</h2> <ol class="chapters"> <li>
<a href="#what-is-action-mailer-questionmark">What is Action Mailer?</a> <ul> <li><a href="#mailers-are-similar-to-controllers">Mailers are Similar to Controllers</a></li> </ul>
</li> <li>
<a href="#sending-emails">Sending Emails</a> <ul> <li><a href="#walkthrough-to-generating-a-mailer">Walkthrough to Generating a Mailer</a></li> <li><a href="#auto-encoding-header-values">Auto Encoding Header Values</a></li> <li><a href="#complete-list-of-action-mailer-methods">Complete List of Action Mailer Methods</a></li> <li><a href="#mailer-views">Mailer Views</a></li> <li><a href="#action-mailer-layouts">Action Mailer Layouts</a></li> <li><a href="#previewing-emails">Previewing Emails</a></li> <li><a href="#generating-urls-in-action-mailer-views">Generating URLs in Action Mailer Views</a></li> <li><a href="#adding-images-in-action-mailer-views">Adding Images in Action Mailer Views</a></li> <li><a href="#sending-multipart-emails">Sending Multipart Emails</a></li> <li><a href="#sending-emails-with-dynamic-delivery-options">Sending Emails with Dynamic Delivery Options</a></li> <li><a href="#sending-emails-without-template-rendering">Sending Emails without Template Rendering</a></li> </ul>
</li> <li><a href="#action-mailer-callbacks">Action Mailer Callbacks</a></li> <li><a href="#using-action-mailer-helpers">Using Action Mailer Helpers</a></li> <li>
<a href="#action-mailer-configuration">Action Mailer Configuration</a> <ul> <li><a href="#example-action-mailer-configuration">Example Action Mailer Configuration</a></li> <li><a href="#action-mailer-configuration-for-gmail">Action Mailer Configuration for Gmail</a></li> </ul>
</li> <li><a href="#mailer-testing">Mailer Testing</a></li> <li>
<a href="#intercepting-and-observing-emails">Intercepting and Observing Emails</a> <ul> <li><a href="#intercepting-emails">Intercepting Emails</a></li> <li><a href="#observing-emails">Observing Emails</a></li> </ul>
</li> </ol>   <h1 id="what-is-action-mailer-questionmark"><a class="anchorlink" href="#what-is-action-mailer-questionmark">1 What is Action Mailer?</a></h1>
<p>Action Mailer allows you to send emails from your application using mailer classes and views.</p>
<h2 id="mailers-are-similar-to-controllers"><a class="anchorlink" href="#mailers-are-similar-to-controllers">1.1 Mailers are Similar to Controllers</a></h2>
<p>They inherit from <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Base.html"><code>ActionMailer::Base</code></a> and live in <code>app/mailers</code>. Mailers also work very similarly to controllers. Some examples of similarities are enumerated below. Mailers have:</p> <ul> <li>Actions, and also, associated views that appear in <code>app/views</code>.</li> <li>Instance variables that are accessible in views.</li> <li>The ability to utilise layouts and partials.</li> <li>The ability to access a params hash.</li> </ul> <h1 id="sending-emails"><a class="anchorlink" href="#sending-emails">2 Sending Emails</a></h1>
<p>This section will provide a step-by-step guide to creating a mailer and its views.</p>
<h2 id="walkthrough-to-generating-a-mailer"><a class="anchorlink" href="#walkthrough-to-generating-a-mailer">2.1 Walkthrough to Generating a Mailer</a></h2>
<h3 id="create-the-mailer"><a class="anchorlink" href="#create-the-mailer">2.1.1 Create the Mailer</a></h3> <pre data-language="console">$ bin/rails generate mailer User
create  app/mailers/user_mailer.rb
create  app/mailers/application_mailer.rb
invoke  erb
create    app/views/user_mailer
create    app/views/layouts/mailer.text.erb
create    app/views/layouts/mailer.html.erb
invoke  test_unit
create    test/mailers/user_mailer_test.rb
create    test/mailers/previews/user_mailer_preview.rb</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate mailer User
">Copy</button>   <pre data-language="ruby"># app/mailers/application_mailer.rb
class ApplicationMailer &lt; ActionMailer::Base
  default from: "from@example.com"
  layout 'mailer'
end</pre> <button class="clipboard-button" data-clipboard-text="# app/mailers/application_mailer.rb
class ApplicationMailer &lt; ActionMailer::Base
  default from: &quot;from@example.com&quot;
  layout 'mailer'
end
">Copy</button>   <pre data-language="ruby"># app/mailers/user_mailer.rb
class UserMailer &lt; ApplicationMailer
end</pre> <button class="clipboard-button" data-clipboard-text="# app/mailers/user_mailer.rb
class UserMailer &lt; ApplicationMailer
end
">Copy</button>  <p>As you can see, you can generate mailers just like you use other generators with Rails.</p>
<p>If you didn't want to use a generator, you could create your own file inside of <code>app/mailers</code>, just make sure that it inherits from <code>ActionMailer::Base</code>:</p> <pre data-language="ruby">class MyMailer &lt; ActionMailer::Base
end</pre> <button class="clipboard-button" data-clipboard-text="class MyMailer &lt; ActionMailer::Base
end
">Copy</button>  <h3 id="edit-the-mailer"><a class="anchorlink" href="#edit-the-mailer">2.1.2 Edit the Mailer</a></h3>
<p>Mailers have methods called "actions" and they use views to structure their content. Where a controller generates content like HTML to send back to the client, a Mailer creates a message to be delivered via email.</p>
<p><code>app/mailers/user_mailer.rb</code> contains an empty mailer:</p> <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
end</pre> <button class="clipboard-button" data-clipboard-text="class UserMailer &lt; ApplicationMailer
end
">Copy</button>  <p>Let's add a method called <code>welcome_email</code>, that will send an email to the user's registered email address:</p> <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email, subject: 'Welcome to My Awesome Site')
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class UserMailer &lt; ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email, subject: 'Welcome to My Awesome Site')
  end
end
">Copy</button>  <p>Here is a quick explanation of the items presented in the preceding method. For a full list of all available options, please have a look further down at the Complete List of Action Mailer user-settable attributes section.</p> <ul> <li>The <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Base.html#method-c-default"><code>default</code></a> method sets default values for all emails sent from this mailer. In this case, we use it to set the <code>:from</code> header value for all messages in this class. This can be overridden on a per-email basis.</li> <li>The <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Base.html#method-i-mail"><code>mail</code></a> method creates the actual email message. We use it to specify the values of headers like <code>:to</code> and <code>:subject</code> per email.</li> </ul> <h3 id="create-a-mailer-view"><a class="anchorlink" href="#create-a-mailer-view">2.1.3 Create a Mailer View</a></h3>
<p>Create a file called <code>welcome_email.html.erb</code> in <code>app/views/user_mailer/</code>. This will be the template used for the email, formatted in HTML:</p> <pre data-language="erb">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content='text/html; charset=UTF-8' http-equiv='Content-Type' /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to example.com, &lt;%= @user.name %&gt;&lt;/h1&gt;
    &lt;p&gt;
      You have successfully signed up to example.com,
      your username is: &lt;%= @user.login %&gt;.&lt;br&gt;
    &lt;/p&gt;
    &lt;p&gt;
      To login to the site, just follow this link: &lt;%= @url %&gt;.
    &lt;/p&gt;
    &lt;p&gt;Thanks for joining and have a great day!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content='text/html; charset=UTF-8' http-equiv='Content-Type' /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to example.com, &lt;%= @user.name %&gt;&lt;/h1&gt;
    &lt;p&gt;
      You have successfully signed up to example.com,
      your username is: &lt;%= @user.login %&gt;.&lt;br&gt;
    &lt;/p&gt;
    &lt;p&gt;
      To login to the site, just follow this link: &lt;%= @url %&gt;.
    &lt;/p&gt;
    &lt;p&gt;Thanks for joining and have a great day!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
">Copy</button>  <p>Let's also make a text part for this email. Not all clients prefer HTML emails, and so sending both is best practice. To do this, create a file called <code>welcome_email.text.erb</code> in <code>app/views/user_mailer/</code>:</p> <pre data-language="erb">Welcome to example.com, &lt;%= @user.name %&gt;
===============================================

You have successfully signed up to example.com,
your username is: &lt;%= @user.login %&gt;.

To login to the site, just follow this link: &lt;%= @url %&gt;.

Thanks for joining and have a great day!</pre> <button class="clipboard-button" data-clipboard-text="Welcome to example.com, &lt;%= @user.name %&gt;
===============================================

You have successfully signed up to example.com,
your username is: &lt;%= @user.login %&gt;.

To login to the site, just follow this link: &lt;%= @url %&gt;.

Thanks for joining and have a great day!
">Copy</button>  <p>When you call the <code>mail</code> method now, Action Mailer will detect the two templates (text and HTML) and automatically generate a <code>multipart/alternative</code> email.</p>
<h3 id="calling-the-mailer"><a class="anchorlink" href="#calling-the-mailer">2.1.4 Calling the Mailer</a></h3>
<p>Mailers are really just another way to render a view. Instead of rendering a view and sending it over the HTTP protocol, they are sending it out through the email protocols instead. Due to this, it makes sense to have your controller tell the Mailer to send an email when a user is successfully created.</p>
<p>Setting this up is simple.</p>
<p>First, let's create a <code>User</code> scaffold:</p> <pre data-language="console">$ bin/rails generate scaffold user name email login
$ bin/rails db:migrate</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate scaffold user name email login
bin/rails db:migrate
">Copy</button>  <p>Now that we have a user model to play with, we will edit the <code>app/controllers/users_controller.rb</code> file, make it instruct the <code>UserMailer</code> to deliver an email to the newly created user by editing the create action and inserting a call to <code>UserMailer.with(user: @user).welcome_email</code> right after the user is successfully saved.</p>
<p>We will enqueue the email to be sent by using <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/MessageDelivery.html#method-i-deliver_later"><code>deliver_later</code></a>, which is backed by Active Job. That way, the controller action can continue without waiting for the send to complete.</p> <pre data-language="ruby">class UsersController &lt; ApplicationController
  # ...

  # POST /users or /users.json
  def create
    @user = User.new(user_params)

    respond_to do |format|
      if @user.save
        # Tell the UserMailer to send a welcome email after save
        UserMailer.with(user: @user).welcome_email.deliver_later

        format.html { redirect_to(@user, notice: 'User was successfully created.') }
        format.json { render json: @user, status: :created, location: @user }
      else
        format.html { render action: 'new' }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # ...
end</pre> <button class="clipboard-button" data-clipboard-text="class UsersController &lt; ApplicationController
  # ...

  # POST /users or /users.json
  def create
    @user = User.new(user_params)

    respond_to do |format|
      if @user.save
        # Tell the UserMailer to send a welcome email after save
        UserMailer.with(user: @user).welcome_email.deliver_later

        format.html { redirect_to(@user, notice: 'User was successfully created.') }
        format.json { render json: @user, status: :created, location: @user }
      else
        format.html { render action: 'new' }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # ...
end
">Copy</button>  <div class="note"><p>Active Job's default behavior is to execute jobs via the <code>:async</code> adapter. So, you can use <code>deliver_later</code> to send emails asynchronously. Active Job's default adapter runs jobs with an in-process thread pool. It's well-suited for the development/test environments, since it doesn't require any external infrastructure, but it's a poor fit for production since it drops pending jobs on restart. If you need a persistent backend, you will need to use an Active Job adapter that has a persistent backend (Sidekiq, Resque, etc).</p></div>
<p>If you want to send emails right away (from a cronjob for example) just call <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/MessageDelivery.html#method-i-deliver_now"><code>deliver_now</code></a>:</p> <pre data-language="ruby">class SendWeeklySummary
  def run
    User.find_each do |user|
      UserMailer.with(user: user).weekly_summary.deliver_now
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class SendWeeklySummary
  def run
    User.find_each do |user|
      UserMailer.with(user: user).weekly_summary.deliver_now
    end
  end
end
">Copy</button>  <p>Any key-value pair passed to <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Parameterized/ClassMethods.html#method-i-with"><code>with</code></a> just becomes the <code>params</code> for the mailer action. So <code>with(user: @user, account: @user.account)</code> makes <code>params[:user]</code> and <code>params[:account]</code> available in the mailer action. Just like controllers have params.</p>
<p>The method <code>weekly_summary</code> returns an <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/MessageDelivery.html"><code>ActionMailer::MessageDelivery</code></a> object which can then be told to <code>deliver_now</code> or <code>deliver_later</code> to send itself out. The <code>ActionMailer::MessageDelivery</code> object is a wrapper around a <a href="https://edgeapi.rubyonrails.org/classes/Mail/Message.html"><code>Mail::Message</code></a>. If you want to inspect, alter, or do anything else with the <code>Mail::Message</code> object you can access it with the <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/MessageDelivery.html#method-i-message"><code>message</code></a> method on the <code>ActionMailer::MessageDelivery</code> object.</p>
<h2 id="auto-encoding-header-values"><a class="anchorlink" href="#auto-encoding-header-values">2.2 Auto Encoding Header Values</a></h2>
<p>Action Mailer handles the auto encoding of multibyte characters inside of headers and bodies.</p>
<p>For more complex examples such as defining alternate character sets or self-encoding text first, please refer to the <a href="https://github.com/mikel/mail">Mail</a> library.</p>
<h2 id="complete-list-of-action-mailer-methods"><a class="anchorlink" href="#complete-list-of-action-mailer-methods">2.3 Complete List of Action Mailer Methods</a></h2>
<p>There are just three methods that you need to send pretty much any email message:</p> <ul> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Base.html#method-i-headers"><code>headers</code></a> - Specifies any header on the email you want. You can pass a hash of header field names and value pairs, or you can call <code>headers[:field_name] =
'value'</code>.</li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Base.html#method-i-attachments"><code>attachments</code></a> - Allows you to add attachments to your email. For example, <code>attachments['file-name.jpg'] = File.read('file-name.jpg')</code>.</li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Base.html#method-i-mail"><code>mail</code></a> - Creates the actual email itself. You can pass in headers as a hash to the <code>mail</code> method as a parameter. <code>mail</code> will create an email — either plain text or multipart — depending on what email templates you have defined.</li> </ul> <h3 id="adding-attachments"><a class="anchorlink" href="#adding-attachments">2.3.1 Adding Attachments</a></h3>
<p>Action Mailer makes it very easy to add attachments.</p> <ul> <li>
<p>Pass the file name and content and Action Mailer and the <a href="https://github.com/mikel/mail">Mail gem</a> will automatically guess the <code>mime_type</code>, set the <code>encoding</code>, and create the attachment.</p> <pre data-language="ruby">attachments['filename.jpg'] = File.read('/path/to/filename.jpg')</pre> <button class="clipboard-button" data-clipboard-text="attachments['filename.jpg'] = File.read('/path/to/filename.jpg')
">Copy</button> </li> </ul> <p> When the <code>mail</code> method will be triggered, it will send a multipart email with an attachment, properly nested with the top level being <code>multipart/mixed</code> and the first part being a <code>multipart/alternative</code> containing the plain text and HTML email messages.</p>
<div class="note"><p>Mail will automatically Base64 encode an attachment. If you want something different, encode your content and pass in the encoded content and encoding in a <code>Hash</code> to the <code>attachments</code> method.</p></div> <ul> <li>
<p>Pass the file name and specify headers and content and Action Mailer and Mail will use the settings you pass in.</p> <pre data-language="ruby">encoded_content = SpecialEncode(File.read('/path/to/filename.jpg'))
attachments['filename.jpg'] = {
  mime_type: 'application/gzip',
  encoding: 'SpecialEncoding',
  content: encoded_content
}</pre> <button class="clipboard-button" data-clipboard-text="encoded_content = SpecialEncode(File.read('/path/to/filename.jpg'))
attachments['filename.jpg'] = {
  mime_type: 'application/gzip',
  encoding: 'SpecialEncoding',
  content: encoded_content
}
">Copy</button> </li> </ul> <div class="note"><p>If you specify an encoding, Mail will assume that your content is already encoded and not try to Base64 encode it.</p></div>
<h3 id="making-inline-attachments"><a class="anchorlink" href="#making-inline-attachments">2.3.2 Making Inline Attachments</a></h3>
<p>Action Mailer 3.0 makes inline attachments, which involved a lot of hacking in pre 3.0 versions, much simpler and trivial as they should be.</p> <ul> <li>
<p>First, to tell Mail to turn an attachment into an inline attachment, you just call <code>#inline</code> on the attachments method within your Mailer:</p> <pre data-language="ruby">def welcome
  attachments.inline['image.jpg'] = File.read('/path/to/image.jpg')
end</pre> <button class="clipboard-button" data-clipboard-text="def welcome
  attachments.inline['image.jpg'] = File.read('/path/to/image.jpg')
end
">Copy</button> </li> <li>
<p>Then in your view, you can just reference <code>attachments</code> as a hash and specify which attachment you want to show, calling <code>url</code> on it and then passing the result into the <code>image_tag</code> method:</p> <pre data-language="erb">&lt;p&gt;Hello there, this is our image&lt;/p&gt;

&lt;%= image_tag attachments['image.jpg'].url %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;p&gt;Hello there, this is our image&lt;/p&gt;

&lt;%= image_tag attachments['image.jpg'].url %&gt;
">Copy</button> </li> <li>
<p>As this is a standard call to <code>image_tag</code> you can pass in an options hash after the attachment URL as you could for any other image:</p> <pre data-language="erb">&lt;p&gt;Hello there, this is our image&lt;/p&gt;

&lt;%= image_tag attachments['image.jpg'].url, alt: 'My Photo', class: 'photos' %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;p&gt;Hello there, this is our image&lt;/p&gt;

&lt;%= image_tag attachments['image.jpg'].url, alt: 'My Photo', class: 'photos' %&gt;
">Copy</button> </li> </ul> <h3 id="sending-email-to-multiple-recipients"><a class="anchorlink" href="#sending-email-to-multiple-recipients">2.3.3 Sending Email to Multiple Recipients</a></h3>
<p>It is possible to send email to one or more recipients in one email (e.g., informing all admins of a new signup) by setting the list of emails to the <code>:to</code> key. The list of emails can be an array of email addresses or a single string with the addresses separated by commas.</p> <pre data-language="ruby">class AdminMailer &lt; ApplicationMailer
  default to: -&gt; { Admin.pluck(:email) },
          from: 'notification@example.com'

  def new_registration(user)
    @user = user
    mail(subject: "New User Signup: #{@user.email}")
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class AdminMailer &lt; ApplicationMailer
  default to: -&gt; { Admin.pluck(:email) },
          from: 'notification@example.com'

  def new_registration(user)
    @user = user
    mail(subject: &quot;New User Signup: #{@user.email}&quot;)
  end
end
">Copy</button>  <p>The same format can be used to set carbon copy (Cc:) and blind carbon copy (Bcc:) recipients, by using the <code>:cc</code> and <code>:bcc</code> keys respectively.</p>
<h3 id="sending-email-with-name"><a class="anchorlink" href="#sending-email-with-name">2.3.4 Sending Email with Name</a></h3>
<p>Sometimes you wish to show the name of the person instead of just their email address when they receive the email. You can use <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Base.html#method-i-email_address_with_name"><code>email_address_with_name</code></a> for that:</p> <pre data-language="ruby">def welcome_email
  @user = params[:user]
  mail(
    to: email_address_with_name(@user.email, @user.name),
    subject: 'Welcome to My Awesome Site'
  )
end</pre> <button class="clipboard-button" data-clipboard-text="def welcome_email
  @user = params[:user]
  mail(
    to: email_address_with_name(@user.email, @user.name),
    subject: 'Welcome to My Awesome Site'
  )
end
">Copy</button>  <p>The same technique works to specify a sender name:</p> <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  default from: email_address_with_name('notification@example.com', 'Example Company Notifications')
end</pre> <button class="clipboard-button" data-clipboard-text="class UserMailer &lt; ApplicationMailer
  default from: email_address_with_name('notification@example.com', 'Example Company Notifications')
end
">Copy</button>  <p>If the name is a blank string, it returns just the address.</p>
<h2 id="mailer-views"><a class="anchorlink" href="#mailer-views">2.4 Mailer Views</a></h2>
<p>Mailer views are located in the <code>app/views/name_of_mailer_class</code> directory. The specific mailer view is known to the class because its name is the same as the mailer method. In our example from above, our mailer view for the <code>welcome_email</code> method will be in <code>app/views/user_mailer/welcome_email.html.erb</code> for the HTML version and <code>welcome_email.text.erb</code> for the plain text version.</p>
<p>To change the default mailer view for your action you do something like:</p> <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site',
         template_path: 'notifications',
         template_name: 'another')
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class UserMailer &lt; ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site',
         template_path: 'notifications',
         template_name: 'another')
  end
end
">Copy</button>  <p>In this case, it will look for templates at <code>app/views/notifications</code> with name <code>another</code>. You can also specify an array of paths for <code>template_path</code>, and they will be searched in order.</p>
<p>If you want more flexibility you can also pass a block and render specific templates or even render inline or text without using a template file:</p> <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site') do |format|
      format.html { render 'another_template' }
      format.text { render plain: 'Render text' }
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class UserMailer &lt; ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site') do |format|
      format.html { render 'another_template' }
      format.text { render plain: 'Render text' }
    end
  end
end
">Copy</button>  <p>This will render the template 'another_template.html.erb' for the HTML part and use the rendered text for the text part. The render command is the same one used inside of Action Controller, so you can use all the same options, such as <code>:text</code>, <code>:inline</code>, etc.</p>
<p>If you would like to render a template located outside of the default <code>app/views/mailer_name/</code> directory, you can apply the <a href="https://edgeapi.rubyonrails.org/classes/ActionView/ViewPaths/ClassMethods.html#method-i-prepend_view_path"><code>prepend_view_path</code></a>, like so:</p> <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  prepend_view_path "custom/path/to/mailer/view"

  # This will try to load "custom/path/to/mailer/view/welcome_email" template
  def welcome_email
    # ...
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class UserMailer &lt; ApplicationMailer
  prepend_view_path "custom/path/to/mailer/view"

  # This will try to load "custom/path/to/mailer/view/welcome_email" template
  def welcome_email
    # ...
  end
end
'>Copy</button>  <p>You can also consider using the <a href="https://edgeapi.rubyonrails.org/classes/ActionView/ViewPaths/ClassMethods.html#method-i-append_view_path"><code>append_view_path</code></a> method.</p>
<h3 id="caching-mailer-view"><a class="anchorlink" href="#caching-mailer-view">2.4.1 Caching Mailer View</a></h3>
<p>You can perform fragment caching in mailer views like in application views using the <a href="https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/CacheHelper.html#method-i-cache"><code>cache</code></a> method.</p> <pre data-language="erb">&lt;% cache do %&gt;
  &lt;%= @company.name %&gt;
&lt;% end %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;% cache do %&gt;
  &lt;%= @company.name %&gt;
&lt;% end %&gt;
">Copy</button>  <p>And to use this feature, you need to configure your application with this:</p> <pre data-language="ruby">config.action_mailer.perform_caching = true</pre> <button class="clipboard-button" data-clipboard-text="config.action_mailer.perform_caching = true
">Copy</button>  <p>Fragment caching is also supported in multipart emails. Read more about caching in the <a href="caching_with_rails.html">Rails caching guide</a>.</p>
<h2 id="action-mailer-layouts"><a class="anchorlink" href="#action-mailer-layouts">2.5 Action Mailer Layouts</a></h2>
<p>Just like controller views, you can also have mailer layouts. The layout name needs to be the same as your mailer, such as <code>user_mailer.html.erb</code> and <code>user_mailer.text.erb</code> to be automatically recognized by your mailer as a layout.</p>
<p>To use a different file, call <a href="https://edgeapi.rubyonrails.org/classes/ActionView/Layouts/ClassMethods.html#method-i-layout"><code>layout</code></a> in your mailer:</p> <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  layout 'awesome' # use awesome.(html|text).erb as the layout
end</pre> <button class="clipboard-button" data-clipboard-text="class UserMailer &lt; ApplicationMailer
  layout 'awesome' # use awesome.(html|text).erb as the layout
end
">Copy</button>  <p>Just like with controller views, use <code>yield</code> to render the view inside the layout.</p>
<p>You can also pass in a <code>layout: 'layout_name'</code> option to the render call inside the format block to specify different layouts for different formats:</p> <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  def welcome_email
    mail(to: params[:user].email) do |format|
      format.html { render layout: 'my_layout' }
      format.text
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class UserMailer &lt; ApplicationMailer
  def welcome_email
    mail(to: params[:user].email) do |format|
      format.html { render layout: 'my_layout' }
      format.text
    end
  end
end
">Copy</button>  <p>Will render the HTML part using the <code>my_layout.html.erb</code> file and the text part with the usual <code>user_mailer.text.erb</code> file if it exists.</p>
<h2 id="previewing-emails"><a class="anchorlink" href="#previewing-emails">2.6 Previewing Emails</a></h2>
<p>Action Mailer previews provide a way to see how emails look by visiting a special URL that renders them. In the above example, the preview class for <code>UserMailer</code> should be named <code>UserMailerPreview</code> and located in <code>test/mailers/previews/user_mailer_preview.rb</code>. To see the preview of <code>welcome_email</code>, implement a method that has the same name and call <code>UserMailer.welcome_email</code>:</p> <pre data-language="ruby">class UserMailerPreview &lt; ActionMailer::Preview
  def welcome_email
    UserMailer.with(user: User.first).welcome_email
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class UserMailerPreview &lt; ActionMailer::Preview
  def welcome_email
    UserMailer.with(user: User.first).welcome_email
  end
end
">Copy</button>  <p>Then the preview will be available in <span>http://localhost:3000/rails/mailers/user_mailer/welcome_email</span>.</p>
<p>If you change something in <code>app/views/user_mailer/welcome_email.html.erb</code> or the mailer itself, it'll automatically reload and render it so you can visually see the new style instantly. A list of previews are also available in <span>http://localhost:3000/rails/mailers</span>.</p>
<p>By default, these preview classes live in <code>test/mailers/previews</code>. This can be configured using the <code>preview_paths</code> option. For example, if you want to add <code>lib/mailer_previews</code> to it, you can configure it in <code>config/application.rb</code>:</p> <pre data-language="ruby">config.action_mailer.preview_paths &lt;&lt; "#{Rails.root}/lib/mailer_previews"</pre> <button class="clipboard-button" data-clipboard-text='config.action_mailer.preview_paths &lt;&lt; "#{Rails.root}/lib/mailer_previews"
'>Copy</button>  <h2 id="generating-urls-in-action-mailer-views"><a class="anchorlink" href="#generating-urls-in-action-mailer-views">2.7 Generating URLs in Action Mailer Views</a></h2>
<p>Unlike controllers, the mailer instance doesn't have any context about the incoming request so you'll need to provide the <code>:host</code> parameter yourself.</p>
<p>As the <code>:host</code> usually is consistent across the application you can configure it globally in <code>config/application.rb</code>:</p> <pre data-language="ruby">config.action_mailer.default_url_options = { host: 'example.com' }</pre> <button class="clipboard-button" data-clipboard-text="config.action_mailer.default_url_options = { host: 'example.com' }
">Copy</button>  <p>Because of this behavior, you cannot use any of the <code>*_path</code> helpers inside of an email. Instead, you will need to use the associated <code>*_url</code> helper. For example instead of using</p> <pre data-language="erb">&lt;%= link_to 'welcome', welcome_path %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%= link_to 'welcome', welcome_path %&gt;
">Copy</button>  <p>You will need to use:</p> <pre data-language="erb">&lt;%= link_to 'welcome', welcome_url %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%= link_to 'welcome', welcome_url %&gt;
">Copy</button>  <p>By using the full URL, your links will now work in your emails.</p>
<h3 id="generating-urls-with-url-for"><a class="anchorlink" href="#generating-urls-with-url-for">2.7.1 Generating URLs with <code>url_for</code></a></h3>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActionView/RoutingUrlFor.html#method-i-url_for"><code>url_for</code></a> generates a full URL by default in templates.</p>
<p>If you did not configure the <code>:host</code> option globally make sure to pass it to <code>url_for</code>.</p> <pre data-language="erb">&lt;%= url_for(host: 'example.com',
            controller: 'welcome',
            action: 'greeting') %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%= url_for(host: 'example.com',
            controller: 'welcome',
            action: 'greeting') %&gt;
">Copy</button>  <h3 id="generating-urls-with-named-routes"><a class="anchorlink" href="#generating-urls-with-named-routes">2.7.2 Generating URLs with Named Routes</a></h3>
<p>Email clients have no web context and so paths have no base URL to form complete web addresses. Thus, you should always use the <code>*_url</code> variant of named route helpers.</p>
<p>If you did not configure the <code>:host</code> option globally make sure to pass it to the URL helper.</p> <pre data-language="erb">&lt;%= user_url(@user, host: 'example.com') %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%= user_url(@user, host: 'example.com') %&gt;
">Copy</button>  <div class="note"><p>non-<code>GET</code> links require <a href="https://github.com/rails/rails/blob/main/actionview/app/assets/javascripts">rails-ujs</a> or <a href="https://github.com/rails/jquery-ujs">jQuery UJS</a>, and won't work in mailer templates. They will result in normal <code>GET</code> requests.</p></div>
<h2 id="adding-images-in-action-mailer-views"><a class="anchorlink" href="#adding-images-in-action-mailer-views">2.8 Adding Images in Action Mailer Views</a></h2>
<p>Unlike controllers, the mailer instance doesn't have any context about the incoming request so you'll need to provide the <code>:asset_host</code> parameter yourself.</p>
<p>As the <code>:asset_host</code> usually is consistent across the application you can configure it globally in <code>config/application.rb</code>:</p> <pre data-language="ruby">config.action_mailer.asset_host = 'http://example.com'</pre> <button class="clipboard-button" data-clipboard-text="config.action_mailer.asset_host = 'http://example.com'
">Copy</button>  <div class="note"><p>Because we can't infer the protocol from the request, you'll need to specify a protocol such as <code>http://</code> or <code>https://</code> in the <code>:asset_host</code> config.</p></div>
<p>Now you can display an image inside your email.</p> <pre data-language="erb">&lt;%= image_tag 'image.jpg' %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%= image_tag 'image.jpg' %&gt;
">Copy</button>  <h2 id="sending-multipart-emails"><a class="anchorlink" href="#sending-multipart-emails">2.9 Sending Multipart Emails</a></h2>
<p>Action Mailer will automatically send multipart emails if you have different templates for the same action. So, for our <code>UserMailer</code> example, if you have <code>welcome_email.text.erb</code> and <code>welcome_email.html.erb</code> in <code>app/views/user_mailer</code>, Action Mailer will automatically send a multipart email with the HTML and text versions setup as different parts.</p>
<p>The order of the parts getting inserted is determined by the <code>:parts_order</code> inside of the <code>ActionMailer::Base.default</code> method.</p>
<h2 id="sending-emails-with-dynamic-delivery-options"><a class="anchorlink" href="#sending-emails-with-dynamic-delivery-options">2.10 Sending Emails with Dynamic Delivery Options</a></h2>
<p>If you wish to override the default delivery options (e.g. SMTP credentials) while delivering emails, you can do this using <code>delivery_method_options</code> in the mailer action.</p> <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  def welcome_email
    @user = params[:user]
    @url  = user_url(@user)
    delivery_options = { user_name: params[:company].smtp_user,
                         password: params[:company].smtp_password,
                         address: params[:company].smtp_host }
    mail(to: @user.email,
         subject: "Please see the Terms and Conditions attached",
         delivery_method_options: delivery_options)
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class UserMailer &lt; ApplicationMailer
  def welcome_email
    @user = params[:user]
    @url  = user_url(@user)
    delivery_options = { user_name: params[:company].smtp_user,
                         password: params[:company].smtp_password,
                         address: params[:company].smtp_host }
    mail(to: @user.email,
         subject: "Please see the Terms and Conditions attached",
         delivery_method_options: delivery_options)
  end
end
'>Copy</button>  <h2 id="sending-emails-without-template-rendering"><a class="anchorlink" href="#sending-emails-without-template-rendering">2.11 Sending Emails without Template Rendering</a></h2>
<p>There may be cases in which you want to skip the template rendering step and supply the email body as a string. You can achieve this using the <code>:body</code> option. In such cases don't forget to add the <code>:content_type</code> option. Rails will default to <code>text/plain</code> otherwise.</p> <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  def welcome_email
    mail(to: params[:user].email,
         body: params[:email_body],
         content_type: "text/html",
         subject: "Already rendered!")
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class UserMailer &lt; ApplicationMailer
  def welcome_email
    mail(to: params[:user].email,
         body: params[:email_body],
         content_type: "text/html",
         subject: "Already rendered!")
  end
end
'>Copy</button>  <h1 id="action-mailer-callbacks"><a class="anchorlink" href="#action-mailer-callbacks">3 Action Mailer Callbacks</a></h1>
<p>Action Mailer allows for you to specify a <a href="https://edgeapi.rubyonrails.org/classes/AbstractController/Callbacks/ClassMethods.html#method-i-before_action"><code>before_action</code></a>, <a href="https://edgeapi.rubyonrails.org/classes/AbstractController/Callbacks/ClassMethods.html#method-i-after_action"><code>after_action</code></a> and <a href="https://edgeapi.rubyonrails.org/classes/AbstractController/Callbacks/ClassMethods.html#method-i-around_action"><code>around_action</code></a> to configure the message, and <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Callbacks/ClassMethods.html#method-i-before_deliver"><code>before_deliver</code></a>, <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Callbacks/ClassMethods.html#method-i-after_deliver"><code>after_deliver</code></a> and <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Callbacks/ClassMethods.html#method-i-around_deliver"><code>around_deliver</code></a> to control the delivery.</p> <ul> <li><p>Callbacks can be specified with a block or a symbol to a method in the mailer class similar to controllers.</p></li> <li><p>You could use a <code>before_action</code> to set instance variables, populate the mail object with defaults, or insert default headers and attachments.</p></li> </ul>  <pre data-language="ruby">class InvitationsMailer &lt; ApplicationMailer
  before_action :set_inviter_and_invitee
  before_action { @account = params[:inviter].account }

  default to:       -&gt; { @invitee.email_address },
          from:     -&gt; { common_address(@inviter) },
          reply_to: -&gt; { @inviter.email_address_with_name }

  def account_invitation
    mail subject: "#{@inviter.name} invited you to their Basecamp (#{@account.name})"
  end

  def project_invitation
    @project    = params[:project]
    @summarizer = ProjectInvitationSummarizer.new(@project.bucket)

    mail subject: "#{@inviter.name.familiar} added you to a project in Basecamp (#{@account.name})"
  end

  private
    def set_inviter_and_invitee
      @inviter = params[:inviter]
      @invitee = params[:invitee]
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class InvitationsMailer &lt; ApplicationMailer
  before_action :set_inviter_and_invitee
  before_action { @account = params[:inviter].account }

  default to:       -&gt; { @invitee.email_address },
          from:     -&gt; { common_address(@inviter) },
          reply_to: -&gt; { @inviter.email_address_with_name }

  def account_invitation
    mail subject: "#{@inviter.name} invited you to their Basecamp (#{@account.name})"
  end

  def project_invitation
    @project    = params[:project]
    @summarizer = ProjectInvitationSummarizer.new(@project.bucket)

    mail subject: "#{@inviter.name.familiar} added you to a project in Basecamp (#{@account.name})"
  end

  private
    def set_inviter_and_invitee
      @inviter = params[:inviter]
      @invitee = params[:invitee]
    end
end
'>Copy</button>  <ul> <li><p>You could use an <code>after_action</code> to do similar setup as a <code>before_action</code> but using instance variables set in your mailer action.</p></li> <li><p>Using an <code>after_action</code> callback also enables you to override delivery method settings by updating <code>mail.delivery_method.settings</code>.</p></li> </ul>  <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  before_action { @business, @user = params[:business], params[:user] }

  after_action :set_delivery_options,
               :prevent_delivery_to_guests,
               :set_business_headers

  def feedback_message
  end

  def campaign_message
  end

  private
    def set_delivery_options
      # You have access to the mail instance,
      # @business and @user instance variables here
      if @business &amp;&amp; @business.has_smtp_settings?
        mail.delivery_method.settings.merge!(@business.smtp_settings)
      end
    end

    def prevent_delivery_to_guests
      if @user &amp;&amp; @user.guest?
        mail.perform_deliveries = false
      end
    end

    def set_business_headers
      if @business
        headers["X-SMTPAPI-CATEGORY"] = @business.code
      end
    end
end</pre> <button class="clipboard-button" data-clipboard-text='class UserMailer &lt; ApplicationMailer
  before_action { @business, @user = params[:business], params[:user] }

  after_action :set_delivery_options,
               :prevent_delivery_to_guests,
               :set_business_headers

  def feedback_message
  end

  def campaign_message
  end

  private
    def set_delivery_options
      # You have access to the mail instance,
      # @business and @user instance variables here
      if @business &amp;&amp; @business.has_smtp_settings?
        mail.delivery_method.settings.merge!(@business.smtp_settings)
      end
    end

    def prevent_delivery_to_guests
      if @user &amp;&amp; @user.guest?
        mail.perform_deliveries = false
      end
    end

    def set_business_headers
      if @business
        headers["X-SMTPAPI-CATEGORY"] = @business.code
      end
    end
end
'>Copy</button>  <ul> <li>You could use an <code>after_deliver</code> to record the delivery of the message. It also allows observer/interceptor-like behaviors, but with access to the full mailer context.</li> </ul>  <pre data-language="ruby">class UserMailer &lt; ApplicationMailer
  after_deliver :mark_delivered
  before_deliver :sandbox_staging
  after_deliver :observe_delivery

  def feedback_message
    @feedback = params[:feedback]
  end

  private
    def mark_delivered
      params[:feedback].touch(:delivered_at)
    end

    # An Interceptor alternative.
    def sandbox_staging
      message.to = ['sandbox@example.com'] if Rails.env.staging?
    end

    # A callback has more context than the comparable Observer example.
    def observe_delivery
      EmailDelivery.log(message, self.class, action_name, params)
    end
end</pre> <button class="clipboard-button" data-clipboard-text="class UserMailer &lt; ApplicationMailer
  after_deliver :mark_delivered
  before_deliver :sandbox_staging
  after_deliver :observe_delivery

  def feedback_message
    @feedback = params[:feedback]
  end

  private
    def mark_delivered
      params[:feedback].touch(:delivered_at)
    end

    # An Interceptor alternative.
    def sandbox_staging
      message.to = ['sandbox@example.com'] if Rails.env.staging?
    end

    # A callback has more context than the comparable Observer example.
    def observe_delivery
      EmailDelivery.log(message, self.class, action_name, params)
    end
end
">Copy</button>  <ul> <li>Mailer callbacks abort further processing if body is set to a non-nil value. <code>before_deliver</code> can abort with <code>throw :abort</code>.</li> </ul> <h1 id="using-action-mailer-helpers"><a class="anchorlink" href="#using-action-mailer-helpers">4 Using Action Mailer Helpers</a></h1>
<p>Action Mailer inherits from <code>AbstractController</code>, so you have access to most of the same helpers as you do in Action Controller.</p>
<p>There are also some Action Mailer-specific helper methods available in <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/MailHelper.html"><code>ActionMailer::MailHelper</code></a>. For example, these allow accessing the mailer instance from your view with <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/MailHelper.html#method-i-mailer"><code>mailer</code></a>, and accessing the message as <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/MailHelper.html#method-i-message"><code>message</code></a>:</p> <pre data-language="erb">&lt;%= stylesheet_link_tag mailer.name.underscore %&gt;
&lt;h1&gt;&lt;%= message.subject %&gt;&lt;/h1&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%= stylesheet_link_tag mailer.name.underscore %&gt;
&lt;h1&gt;&lt;%= message.subject %&gt;&lt;/h1&gt;
">Copy</button>  <h1 id="action-mailer-configuration"><a class="anchorlink" href="#action-mailer-configuration">5 Action Mailer Configuration</a></h1>
<p>The following configuration options are best made in one of the environment files (environment.rb, production.rb, etc...)</p> <table>
<thead> <tr> <th>Configuration</th> <th>Description</th> </tr> </thead>
<tbody> <tr> <td><code>logger</code></td> <td>Generates information on the mailing run if available. Can be set to <code>nil</code> for no logging. Compatible with both Ruby's own <code>Logger</code> and <code>Log4r</code> loggers.</td> </tr> <tr> <td><code>smtp_settings</code></td> <td>Allows detailed configuration for <code>:smtp</code> delivery method:<ul>
<li>
<code>:address</code> - Allows you to use a remote mail server. Just change it from its default <code>"localhost"</code> setting.</li>
<li>
<code>:port</code> - On the off chance that your mail server doesn't run on port 25, you can change it.</li>
<li>
<code>:domain</code> - If you need to specify a HELO domain, you can do it here.</li>
<li>
<code>:user_name</code> - If your mail server requires authentication, set the username in this setting.</li>
<li>
<code>:password</code> - If your mail server requires authentication, set the password in this setting.</li>
<li>
<code>:authentication</code> - If your mail server requires authentication, you need to specify the authentication type here. This is a symbol and one of <code>:plain</code> (will send the password in the clear), <code>:login</code> (will send password Base64 encoded) or <code>:cram_md5</code> (combines a Challenge/Response mechanism to exchange information and a cryptographic Message Digest 5 algorithm to hash important information)</li>
<li>
<code>:enable_starttls</code> - Use STARTTLS when connecting to your SMTP server and fail if unsupported. Defaults to <code>false</code>.</li>
<li>
<code>:enable_starttls_auto</code> - Detects if STARTTLS is enabled in your SMTP server and starts to use it. Defaults to <code>true</code>.</li>
<li>
<code>:openssl_verify_mode</code> - When using TLS, you can set how OpenSSL checks the certificate. This is really useful if you need to validate a self-signed and/or a wildcard certificate. You can use the name of an OpenSSL verify constant ('none' or 'peer') or directly the constant (<code>OpenSSL::SSL::VERIFY_NONE</code> or <code>OpenSSL::SSL::VERIFY_PEER</code>).</li>
<li>
<code>:ssl/:tls</code> - Enables the SMTP connection to use SMTP/TLS (SMTPS: SMTP over direct TLS connection)</li>
<li>
<code>:open_timeout</code> - Number of seconds to wait while attempting to open a connection.</li>
<li>
<code>:read_timeout</code> - Number of seconds to wait until timing-out a read(2) call.</li>
</ul>
</td> </tr> <tr> <td><code>sendmail_settings</code></td> <td>Allows you to override options for the <code>:sendmail</code> delivery method.<ul>
<li>
<code>:location</code> - The location of the sendmail executable. Defaults to <code>/usr/sbin/sendmail</code>.</li>
<li>
<code>:arguments</code> - The command line arguments to be passed to sendmail. Defaults to <code>["-i"]</code>.</li>
</ul>
</td> </tr> <tr> <td><code>raise_delivery_errors</code></td> <td>Whether or not errors should be raised if the email fails to be delivered. This only works if the external email server is configured for immediate delivery. Defaults to <code>true</code>.</td> </tr> <tr> <td><code>delivery_method</code></td> <td>Defines a delivery method. Possible values are:<ul>
<li>
<code>:smtp</code> (default), can be configured by using <a href="configuring.html#config-action-mailer-smtp-settings"><code>config.action_mailer.smtp_settings</code></a>.</li>
<li>
<code>:sendmail</code>, can be configured by using <a href="configuring.html#config-action-mailer-sendmail-settings"><code>config.action_mailer.sendmail_settings</code></a>.</li>
<li>
<code>:file</code>: save emails to files; can be configured by using <code>config.action_mailer.file_settings</code>.</li>
<li>
<code>:test</code>: save emails to <code>ActionMailer::Base.deliveries</code> array.</li>
</ul>See <a href="https://edgeapi.rubyonrails.org/classes/ActionMailer/Base.html">API docs</a> for more info.</td> </tr> <tr> <td><code>perform_deliveries</code></td> <td>Determines whether deliveries are actually carried out when the <code>deliver</code> method is invoked on the Mail message. By default they are, but this can be turned off to help functional testing. If this value is <code>false</code>, <code>deliveries</code> array will not be populated even if <code>delivery_method</code> is <code>:test</code>.</td> </tr> <tr> <td><code>deliveries</code></td> <td>Keeps an array of all the emails sent out through the Action Mailer with delivery_method :test. Most useful for unit and functional testing.</td> </tr> <tr> <td><code>delivery_job</code></td> <td>The job class used with <code>deliver_later</code>. Defaults to <code>ActionMailer::MailDeliveryJob</code>.</td> </tr> <tr> <td><code>deliver_later_queue_name</code></td> <td>The name of the queue used with the default <code>delivery_job</code>. Defaults to the default Active Job queue.</td> </tr> <tr> <td><code>default_options</code></td> <td>Allows you to set default values for the <code>mail</code> method options (<code>:from</code>, <code>:reply_to</code>, etc.).</td> </tr> </tbody>
</table> <p>For a complete writeup of possible configurations see the <a href="configuring.html#configuring-action-mailer">Configuring Action Mailer</a> in our Configuring Rails Applications guide.</p>
<h2 id="example-action-mailer-configuration"><a class="anchorlink" href="#example-action-mailer-configuration">5.1 Example Action Mailer Configuration</a></h2>
<p>An example would be adding the following to your appropriate <code>config/environments/$RAILS_ENV.rb</code> file:</p> <pre data-language="ruby">config.action_mailer.delivery_method = :sendmail
# Defaults to:
# config.action_mailer.sendmail_settings = {
#   location: '/usr/sbin/sendmail',
#   arguments: %w[ -i ]
# }
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = true
config.action_mailer.default_options = { from: 'no-reply@example.com' }</pre> <button class="clipboard-button" data-clipboard-text="config.action_mailer.delivery_method = :sendmail
# Defaults to:
# config.action_mailer.sendmail_settings = {
#   location: '/usr/sbin/sendmail',
#   arguments: %w[ -i ]
# }
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = true
config.action_mailer.default_options = { from: 'no-reply@example.com' }
">Copy</button>  <h2 id="action-mailer-configuration-for-gmail"><a class="anchorlink" href="#action-mailer-configuration-for-gmail">5.2 Action Mailer Configuration for Gmail</a></h2>
<p>Action Mailer uses the <a href="https://github.com/mikel/mail">Mail gem</a> and accepts similar configuration. Add this to your <code>config/environments/$RAILS_ENV.rb</code> file to send via Gmail:</p> <pre data-language="ruby">config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
  address:         'smtp.gmail.com',
  port:            587,
  domain:          'example.com',
  user_name:       '&lt;username&gt;',
  password:        '&lt;password&gt;',
  authentication:  'plain',
  enable_starttls: true,
  open_timeout:    5,
  read_timeout:    5 }</pre> <button class="clipboard-button" data-clipboard-text="config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
  address:         'smtp.gmail.com',
  port:            587,
  domain:          'example.com',
  user_name:       '&lt;username&gt;',
  password:        '&lt;password&gt;',
  authentication:  'plain',
  enable_starttls: true,
  open_timeout:    5,
  read_timeout:    5 }
">Copy</button>  <p>If you are using an old version of the Mail gem (2.6.x or earlier), use <code>enable_starttls_auto</code> instead of <code>enable_starttls</code>.</p>
<div class="note"><p>Google <a href="https://support.google.com/accounts/answer/6010255">blocks sign-ins</a> from apps it deems less secure. You can change your Gmail settings <a href="https://www.google.com/settings/security/lesssecureapps">here</a> to allow the attempts. If your Gmail account has 2-factor authentication enabled, then you will need to set an <a href="https://myaccount.google.com/apppasswords">app password</a> and use that instead of your regular password.</p></div>
<h1 id="mailer-testing"><a class="anchorlink" href="#mailer-testing">6 Mailer Testing</a></h1>
<p>You can find detailed instructions on how to test your mailers in the <a href="testing.html#testing-your-mailers">testing guide</a>.</p>
<h1 id="intercepting-and-observing-emails"><a class="anchorlink" href="#intercepting-and-observing-emails">7 Intercepting and Observing Emails</a></h1>
<p>Action Mailer provides hooks into the Mail observer and interceptor methods. These allow you to register classes that are called during the mail delivery life cycle of every email sent.</p>
<h2 id="intercepting-emails"><a class="anchorlink" href="#intercepting-emails">7.1 Intercepting Emails</a></h2>
<p>Interceptors allow you to make modifications to emails before they are handed off to the delivery agents. An interceptor class must implement the <code>::delivering_email(message)</code> method which will be called before the email is sent.</p> <pre data-language="ruby">class SandboxEmailInterceptor
  def self.delivering_email(message)
    message.to = ['sandbox@example.com']
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class SandboxEmailInterceptor
  def self.delivering_email(message)
    message.to = ['sandbox@example.com']
  end
end
">Copy</button>  <p>Before the interceptor can do its job you need to register it using the <code>interceptors</code> config option. You can do this in an initializer file like <code>config/initializers/mail_interceptors.rb</code>:</p> <pre data-language="ruby">Rails.application.configure do
  if Rails.env.staging?
    config.action_mailer.interceptors = %w[SandboxEmailInterceptor]
  end
end</pre> <button class="clipboard-button" data-clipboard-text="Rails.application.configure do
  if Rails.env.staging?
    config.action_mailer.interceptors = %w[SandboxEmailInterceptor]
  end
end
">Copy</button>  <div class="note"><p>The example above uses a custom environment called "staging" for a production-like server but for testing purposes. You can read <a href="configuring.html#creating-rails-environments">Creating Rails Environments</a> for more information about custom Rails environments.</p></div>
<h2 id="observing-emails"><a class="anchorlink" href="#observing-emails">7.2 Observing Emails</a></h2>
<p>Observers give you access to the email message after it has been sent. An observer class must implement the <code>:delivered_email(message)</code> method, which will be called after the email is sent.</p> <pre data-language="ruby">class EmailDeliveryObserver
  def self.delivered_email(message)
    EmailDelivery.log(message)
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class EmailDeliveryObserver
  def self.delivered_email(message)
    EmailDelivery.log(message)
  end
end
">Copy</button>  <p>Similar to interceptors, you must register observers using the <code>observers</code> config option. You can do this in an initializer file like <code>config/initializers/mail_observers.rb</code>:</p> <pre data-language="ruby">Rails.application.configure do
  config.action_mailer.observers = %w[EmailDeliveryObserver]
end</pre> <button class="clipboard-button" data-clipboard-text="Rails.application.configure do
  config.action_mailer.observers = %w[EmailDeliveryObserver]
end
">Copy</button>  <h2>Feedback</h2> <p> You're encouraged to help improve the quality of this guide. </p> <p> Please contribute if you see any typos or factual errors. To get started, you can read our <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a> section. </p> <p> You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check <a href="https://edgeguides.rubyonrails.org">Edge Guides</a> first to verify if the issues are already fixed or not on the main branch. Check the <span>Ruby on Rails Guides Guidelines</span> for style and conventions. </p> <p> If for whatever reason you spot something to fix but cannot patch it yourself, please <a href="https://github.com/rails/rails/issues">open an issue</a>. </p> <p>And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">official Ruby on Rails Forum</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2021 David Heinemeier Hansson<br>Licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.<br>
    
  </p>
</div>
