<h1 class="break-words">Loading UI and Streaming</h1>
<p>The special file <code>loading.js</code> helps you create meaningful Loading UI with <a href="https://react.dev/reference/react/Suspense" rel="noopener noreferrer nofollow" target="_blank">React Suspense</a>. With this convention, you can show an <a href="#instant-loading-states">instant loading state</a> from the server while the content of a route segment loads. The new content is automatically swapped in once rendering is complete.</p> <figure><img alt="Loading UI" loading="lazy" width="1600" height="691" decoding="async" data-nimg="1" class="block rounded-md border border-gray-200 bg-gray-100 dark:hidden" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Flight%2Floading-ui.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Flight%2Floading-ui.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Floading-ui.png&amp;w=3840&amp;q=75"><img alt="Loading UI" loading="lazy" width="1600" height="691" decoding="async" data-nimg="1" class="hidden rounded-md border border-gray-200 bg-gray-100 dark:block" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Fdark%2Floading-ui.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Fdark%2Floading-ui.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Floading-ui.png&amp;w=3840&amp;q=75"></figure> <h2 id="instant-loading-states" data-docs-heading="">Instant Loading States     </h2> <p>An instant loading state is fallback UI that is shown immediately upon navigation. You can pre-render loading indicators such as skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. This helps users understand the app is responding and provides a better user experience.</p> <p>Create a loading state by adding a <code>loading.js</code> file inside a folder.</p> <figure><img alt="loading.js special file" loading="lazy" width="1600" height="606" decoding="async" data-nimg="1" class="block rounded-md border border-gray-200 bg-gray-100 dark:hidden" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Flight%2Floading-special-file.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Flight%2Floading-special-file.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Floading-special-file.png&amp;w=3840&amp;q=75"><img alt="loading.js special file" loading="lazy" width="1600" height="606" decoding="async" data-nimg="1" class="hidden rounded-md border border-gray-200 bg-gray-100 dark:block" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Fdark%2Floading-special-file.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Fdark%2Floading-special-file.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Floading-special-file.png&amp;w=3840&amp;q=75"></figure> <div class="code-block_wrapper__t6FCO code-block_hasFileName__ezlBD not-prose"><pre class="code-block_pre___OLfy" data-language="typescript">export default function Loading() {
  // You can add any UI inside Loading, including a Skeleton.
  return &lt;LoadingSkeleton /&gt;
}</pre></div>  <p>In the same folder, <code>loading.js</code> will be nested inside <code>layout.js</code>. It will automatically wrap the <code>page.js</code> file and any children below in a <code>&lt;Suspense&gt;</code> boundary.</p> <figure><img alt="loading.js overview" loading="lazy" width="1600" height="768" decoding="async" data-nimg="1" class="block rounded-md border border-gray-200 bg-gray-100 dark:hidden" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Flight%2Floading-overview.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Flight%2Floading-overview.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Floading-overview.png&amp;w=3840&amp;q=75"><img alt="loading.js overview" loading="lazy" width="1600" height="768" decoding="async" data-nimg="1" class="hidden rounded-md border border-gray-200 bg-gray-100 dark:block" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Fdark%2Floading-overview.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Fdark%2Floading-overview.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Floading-overview.png&amp;w=3840&amp;q=75"></figure> <blockquote class="p-3 text-sm"> <p><strong>Good to know</strong>:</p> <ul> <li>Navigation is immediate, even with <a href="linking-and-navigating.html#how-routing-and-navigation-works">server-centric routing</a>.</li> <li>Navigation is interruptible, meaning changing routes does not need to wait for the content of the route to fully load before navigating to another route.</li> <li>Shared layouts remain interactive while new route segments load.</li> </ul> </blockquote> <blockquote class="p-3 text-sm"> <p><strong>Recommendation:</strong> Use the <code>loading.js</code> convention for route segments (layouts and pages) as Next.js optimizes this functionality.</p> </blockquote> <h2 id="streaming-with-suspense" data-docs-heading="">Streaming with Suspense     </h2> <p>In addition to <code>loading.js</code>, you can also manually create Suspense Boundaries for your own UI components. The App Router supports streaming with <a href="https://react.dev/reference/react/Suspense" rel="noopener noreferrer nofollow" target="_blank">Suspense</a> for both <a href="../rendering/edge-and-nodejs-runtimes.html">Node.js and Edge runtimes</a>.</p> <blockquote class="p-3 text-sm"> <p><strong>Good to know</strong>:</p> <ul> <li>
<a href="https://bugs.webkit.org/show_bug.cgi?id=252413" rel="noopener noreferrer nofollow" target="_blank">Some browsers</a> buffer a streaming response. You may not see the streamed response until the exceeds 1024 bytes. This typically only affects “hello world” applications, but not real applications.</li> </ul> </blockquote> <h3 id="what-is-streaming" data-docs-heading="">What is Streaming?     </h3> <p>To learn how Streaming works in React and Next.js, it's helpful to understand <strong>Server-Side Rendering (SSR)</strong> and its limitations.</p> <p>With SSR, there's a series of steps that need to be completed before a user can see and interact with a page:</p> <ol> <li>First, all data for a given page is fetched on the server.</li> <li>The server then renders the HTML for the page.</li> <li>The HTML, CSS, and JavaScript for the page are sent to the client.</li> <li>A non-interactive user interface is shown using the generated HTML, and CSS.</li> <li>Finally, React <a href="https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-server-rendered-html" rel="noopener noreferrer nofollow" target="_blank">hydrates</a> the user interface to make it interactive.</li> </ol> <figure><img alt="Chart showing Server Rendering without Streaming" loading="lazy" width="1600" height="612" decoding="async" data-nimg="1" class="block rounded-md border border-gray-200 bg-gray-100 dark:hidden" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-without-streaming-chart.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-without-streaming-chart.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-without-streaming-chart.png&amp;w=3840&amp;q=75"><img alt="Chart showing Server Rendering without Streaming" loading="lazy" width="1600" height="612" decoding="async" data-nimg="1" class="hidden rounded-md border border-gray-200 bg-gray-100 dark:block" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-without-streaming-chart.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-without-streaming-chart.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-without-streaming-chart.png&amp;w=3840&amp;q=75"></figure> <p>These steps are sequential and blocking, meaning the server can only render the HTML for a page once all the data has been fetched. And, on the client, React can only hydrate the UI once the code for all components in the page has been downloaded.</p> <p>SSR with React and Next.js helps improve the perceived loading performance by showing a non-interactive page to the user as soon as possible.</p> <figure><img alt="Server Rendering without Streaming" loading="lazy" width="1600" height="748" decoding="async" data-nimg="1" class="block rounded-md border border-gray-200 bg-gray-100 dark:hidden" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-without-streaming.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-without-streaming.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-without-streaming.png&amp;w=3840&amp;q=75"><img alt="Server Rendering without Streaming" loading="lazy" width="1600" height="748" decoding="async" data-nimg="1" class="hidden rounded-md border border-gray-200 bg-gray-100 dark:block" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-without-streaming.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-without-streaming.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-without-streaming.png&amp;w=3840&amp;q=75"></figure> <p>However, it can still be slow as all data fetching on server needs to be completed before the page can be shown to the user.</p> <p><strong>Streaming</strong> allows you to break down the page's HTML into smaller chunks and progressively send those chunks from the server to the client.</p> <figure><img alt="How Server Rendering with Streaming Works" loading="lazy" width="1600" height="785" decoding="async" data-nimg="1" class="block rounded-md border border-gray-200 bg-gray-100 dark:hidden" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-with-streaming.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-with-streaming.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-with-streaming.png&amp;w=3840&amp;q=75"><img alt="How Server Rendering with Streaming Works" loading="lazy" width="1600" height="785" decoding="async" data-nimg="1" class="hidden rounded-md border border-gray-200 bg-gray-100 dark:block" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-streaming.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-streaming.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-streaming.png&amp;w=3840&amp;q=75"></figure> <p>This enables parts of the page to be displayed sooner, without waiting for all the data to load before any UI can be rendered.</p> <p>Streaming works well with React's component model because each component can be considered a chunk. Components that have higher priority (e.g. product information) or that don't rely on data can be sent first (e.g. layout), and React can start hydration earlier. Components that have lower priority (e.g. reviews, related products) can be sent in the same server request after their data has been fetched.</p> <figure><img alt="Chart showing Server Rendering with Streaming" loading="lazy" width="1600" height="730" decoding="async" data-nimg="1" class="block rounded-md border border-gray-200 bg-gray-100 dark:hidden" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-with-streaming-chart.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-with-streaming-chart.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-with-streaming-chart.png&amp;w=3840&amp;q=75"><img alt="Chart showing Server Rendering with Streaming" loading="lazy" width="1600" height="730" decoding="async" data-nimg="1" class="hidden rounded-md border border-gray-200 bg-gray-100 dark:block" style="color:transparent" srcset="/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-streaming-chart.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-streaming-chart.png&amp;w=3840&amp;q=75 2x" src="https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-streaming-chart.png&amp;w=3840&amp;q=75"></figure> <p>Streaming is particularly beneficial when you want to prevent long data requests from blocking the page from rendering as it can reduce the <a href="https://web.dev/ttfb/" rel="noopener noreferrer nofollow" target="_blank">Time To First Byte (TTFB)</a> and <a href="https://web.dev/first-contentful-paint/" rel="noopener noreferrer nofollow" target="_blank">First Contentful Paint (FCP)</a>. It also helps improve <a href="https://developer.chrome.com/en/docs/lighthouse/performance/interactive/" rel="noopener noreferrer nofollow" target="_blank">Time to Interactive (TTI)</a>, especially on slower devices.</p> <h3 id="example" data-docs-heading="">Example     </h3> <p><code>&lt;Suspense&gt;</code> works by wrapping a component that performs an asynchronous action (e.g. fetch data), showing fallback UI (e.g. skeleton, spinner) while it's happening, and then swapping in your component once the action completes.</p> <div class="code-block_wrapper__t6FCO code-block_hasFileName__ezlBD not-prose"><pre class="code-block_pre___OLfy" data-language="typescript">import { Suspense } from 'react'
import { PostFeed, Weather } from './Components'
 
export default function Posts() {
  return (
    &lt;section&gt;
      &lt;Suspense fallback={&lt;p&gt;Loading feed...&lt;/p&gt;}&gt;
        &lt;PostFeed /&gt;
      &lt;/Suspense&gt;
      &lt;Suspense fallback={&lt;p&gt;Loading weather...&lt;/p&gt;}&gt;
        &lt;Weather /&gt;
      &lt;/Suspense&gt;
    &lt;/section&gt;
  )
}</pre></div>  <p>By using Suspense, you get the benefits of:</p> <ol> <li>
<strong>Streaming Server Rendering</strong> - Progressively rendering HTML from the server to the client.</li> <li>
<strong>Selective Hydration</strong> - React prioritizes what components to make interactive first based on user interaction.</li> </ol> <p>For more Suspense examples and use cases, please see the <a href="https://react.dev/reference/react/Suspense" rel="noopener noreferrer nofollow" target="_blank">React Documentation</a>.</p> <h3 id="seo" data-docs-heading="">SEO     </h3> <ul> <li>Next.js will wait for data fetching inside <a href="../../api-reference/functions/generate-metadata.html"><code>generateMetadata</code></a> to complete before streaming UI to the client. This guarantees the first part of a streamed response includes <code>&lt;head&gt;</code> tags.</li> <li>Since streaming is server-rendered, it does not impact SEO. You can use the <a href="https://search.google.com/test/rich-results" rel="noopener noreferrer nofollow" target="_blank">Rich Results Test</a> tool from Google to see how your page appears to Google's web crawlers and view the serialized HTML (<a href="https://web.dev/rendering-on-the-web/#seo-considerations" rel="noopener noreferrer nofollow" target="_blank">source</a>).</li> </ul> <h3 id="status-codes" data-docs-heading="">Status Codes     </h3> <p>When streaming, a <code>200</code> status code will be returned to signal that the request was successful.</p> <p>The server can still communicate errors or issues to the client within the streamed content itself, for example, when using <a href="../../api-reference/functions/redirect.html"><code>redirect</code></a> or <a href="../../api-reference/functions/not-found.html"><code>notFound</code></a>. Since the response headers have already been sent to the client, the status code of the response cannot be updated. This does not affect SEO.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024 Vercel, Inc.<br>Licensed under the MIT License.<br>
    <a href="https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming" class="_attribution-link">https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming</a>
  </p>
</div>
