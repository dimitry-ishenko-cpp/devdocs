<h1 id="statsmodels-tsa-filters-filtertools-convolution-filter">statsmodels.tsa.filters.filtertools.convolution_filter</h1> <dl class="function"> <dt id="statsmodels.tsa.filters.filtertools.convolution_filter">
<code>statsmodels.tsa.filters.filtertools.convolution_filter(x, filt, nsides=2)</code> <a class="reference internal" href="http://www.statsmodels.org/stable/_modules/statsmodels/tsa/filters/filtertools.html#convolution_filter"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Linear filtering via convolution. Centered and backward displaced moving weighted average.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>x</strong> (<em>array_like</em>) – data array, 1d or 2d, if 2d then observations in rows</li> <li>
<strong>filt</strong> (<em>array_like</em>) – Linear filter coefficients in reverse time-order. Should have the same number of dimensions as x though if 1d and <code>x</code> is 2d will be coerced to 2d.</li> <li>
<strong>nsides</strong> (<em>int</em><em>, </em><em>optional</em>) – If 2, a centered moving average is computed using the filter coefficients. If 1, the filter coefficients are for past values only. Both methods use scipy.signal.convolve.</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>y</strong> – Filtered array, number of columns determined by x and filt. If a pandas object is given, a pandas object is returned. The index of the return is the exact same as the time period in <code>x</code></p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">ndarray, 2d</p> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>In nsides == 1, x is filtered</p> <pre data-language="python">y[n] = filt[0]*x[n-1] + ... + filt[n_filt-1]*x[n-n_filt]
</pre> <p>where n_filt is len(filt).</p> <p>If nsides == 2, x is filtered around lag 0</p> <pre data-language="python">y[n] = filt[0]*x[n - n_filt/2] + ... + filt[n_filt / 2] * x[n]
       + ... + x[n + n_filt/2]
</pre> <p>where n_filt is len(filt). If n_filt is even, then more of the filter is forward in time than backward.</p> <p>If filt is 1d or (nlags,1) one lag polynomial is applied to all variables (columns of x). If filt is 2d, (nlags, nvars) each series is independently filtered with its own lag polynomial, uses loop over nvar. This is different than the usual 2d vs 2d convolution.</p> <p>Filtering is done with scipy.signal.convolve, so it will be reasonably fast for medium sized data. For large data fft convolution would be faster.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;2012 Statsmodels Developers<br>&copy; 2006&ndash;2008 Scipy Developers<br>&copy; 2006 Jonathan E. Taylor<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://www.statsmodels.org/stable/generated/statsmodels.tsa.filters.filtertools.convolution_filter.html" class="_attribution-link">http://www.statsmodels.org/stable/generated/statsmodels.tsa.filters.filtertools.convolution_filter.html</a>
  </p>
</div>
