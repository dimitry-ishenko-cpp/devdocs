<section id="metrics-and-scoring-quantifying-the-quality-of-predictions"> <h1 id="model-evaluation">3.4. Metrics and scoring: quantifying the quality of predictions</h1> <section id="which-scoring-function-should-i-use"> <h2 id="which-scoring-function">
<span class="section-number">3.4.1. </span>Which scoring function should I use?</h2> <p>Before we take a closer look into the details of the many scores and <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-evaluation-metrics"><span class="xref std std-term">evaluation metrics</span></a>, we want to give some guidance, inspired by statistical decision theory, on the choice of <strong>scoring functions</strong> for <strong>supervised learning</strong>, see <a class="reference internal" href="#gneiting2009" id="id1"><span>[Gneiting2009]</span></a>:</p> <ul class="simple"> <li><em>Which scoring function should I use?</em></li> <li><em>Which scoring function is a good one for my task?</em></li> </ul> <p>In a nutshell, if the scoring function is given, e.g. in a kaggle competition or in a business context, use that one. If you are free to choose, it starts by considering the ultimate goal and application of the prediction. It is useful to distinguish two steps:</p> <ul class="simple"> <li>Predicting</li> <li>Decision making</li> </ul> <p><strong>Predicting:</strong> Usually, the response variable <span class="math notranslate nohighlight">\(Y\)</span> is a random variable, in the sense that there is <em>no deterministic</em> function <span class="math notranslate nohighlight">\(Y = g(X)\)</span> of the features <span class="math notranslate nohighlight">\(X\)</span>. Instead, there is a probability distribution <span class="math notranslate nohighlight">\(F\)</span> of <span class="math notranslate nohighlight">\(Y\)</span>. One can aim to predict the whole distribution, known as <em>probabilistic prediction</em>, or—more the focus of scikit-learn—issue a <em>point prediction</em> (or point forecast) by choosing a property or functional of that distribution <span class="math notranslate nohighlight">\(F\)</span>. Typical examples are the mean (expected value), the median or a quantile of the response variable <span class="math notranslate nohighlight">\(Y\)</span> (conditionally on <span class="math notranslate nohighlight">\(X\)</span>).</p> <p>Once that is settled, use a <strong>strictly consistent</strong> scoring function for that (target) functional, see <a class="reference internal" href="#gneiting2009" id="id2"><span>[Gneiting2009]</span></a>. This means using a scoring function that is aligned with <em>measuring the distance between predictions</em> <code>y_pred</code> <em>and the true target functional using observations of</em> <span class="math notranslate nohighlight">\(Y\)</span>, i.e. <code>y_true</code>. For classification <strong>strictly proper scoring rules</strong>, see <a class="reference external" href="https://en.wikipedia.org/wiki/Scoring_rule">Wikipedia entry for Scoring rule</a> and <a class="reference internal" href="#gneiting2007" id="id3"><span>[Gneiting2007]</span></a>, coincide with strictly consistent scoring functions. The table further below provides examples. One could say that consistent scoring functions act as <em>truth serum</em> in that they guarantee <em>“that truth telling […] is an optimal strategy in expectation”</em> <a class="reference internal" href="#gneiting2014" id="id4"><span>[Gneiting2014]</span></a>.</p> <p>Once a strictly consistent scoring function is chosen, it is best used for both: as loss function for model training and as metric/score in model evaluation and model comparison.</p> <p>Note that for regressors, the prediction is done with <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-predict"><span class="xref std std-term">predict</span></a> while for classifiers it is usually <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-predict_proba"><span class="xref std std-term">predict_proba</span></a>.</p> <p><strong>Decision Making:</strong> The most common decisions are done on binary classification tasks, where the result of <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-predict_proba"><span class="xref std std-term">predict_proba</span></a> is turned into a single outcome, e.g., from the predicted probability of rain a decision is made on how to act (whether to take mitigating measures like an umbrella or not). For classifiers, this is what <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-predict"><span class="xref std std-term">predict</span></a> returns. See also <a class="reference internal" href="classification_threshold.html#tunedthresholdclassifiercv"><span class="std std-ref">Tuning the decision threshold for class prediction</span></a>. There are many scoring functions which measure different aspects of such a decision, most of them are covered with or derived from the <a class="reference internal" href="generated/sklearn.metrics.confusion_matrix.html#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><code>metrics.confusion_matrix</code></a>.</p> <p><strong>List of strictly consistent scoring functions:</strong> Here, we list some of the most relevant statistical functionals and corresponding strictly consistent scoring functions for tasks in practice. Note that the list is not complete and that there are more of them. For further criteria on how to select a specific one, see <a class="reference internal" href="#fissler2022" id="id5"><span>[Fissler2022]</span></a>.</p> <div class="pst-scrollable-table-container">
<table class="table"> <thead> <tr>
<th class="head"><p>functional</p></th> <th class="head"><p>scoring or loss function</p></th> <th class="head"><p>response <code>y</code></p></th> <th class="head"><p>prediction</p></th> </tr> </thead>  <tr>
<td><p><strong>Classification</strong></p></td> <td></td> <td></td> <td></td> </tr> <tr>
<td><p>mean</p></td> <td><p><a class="reference internal" href="#brier-score-loss"><span class="std std-ref">Brier score</span></a> <sup>1</sup></p></td> <td><p>multi-class</p></td> <td><p><code>predict_proba</code></p></td> </tr> <tr>
<td><p>mean</p></td> <td><p><a class="reference internal" href="#log-loss"><span class="std std-ref">log loss</span></a></p></td> <td><p>multi-class</p></td> <td><p><code>predict_proba</code></p></td> </tr> <tr>
<td><p>mode</p></td> <td><p><a class="reference internal" href="#zero-one-loss"><span class="std std-ref">zero-one loss</span></a> <sup>2</sup></p></td> <td><p>multi-class</p></td> <td><p><code>predict</code>, categorical</p></td> </tr> <tr>
<td><p><strong>Regression</strong></p></td> <td></td> <td></td> <td></td> </tr> <tr>
<td><p>mean</p></td> <td><p><a class="reference internal" href="#mean-squared-error"><span class="std std-ref">squared error</span></a> <sup>3</sup></p></td> <td><p>all reals</p></td> <td><p><code>predict</code>, all reals</p></td> </tr> <tr>
<td><p>mean</p></td> <td><p><a class="reference internal" href="#mean-tweedie-deviance"><span class="std std-ref">Poisson deviance</span></a></p></td> <td><p>non-negative</p></td> <td><p><code>predict</code>, strictly positive</p></td> </tr> <tr>
<td><p>mean</p></td> <td><p><a class="reference internal" href="#mean-tweedie-deviance"><span class="std std-ref">Gamma deviance</span></a></p></td> <td><p>strictly positive</p></td> <td><p><code>predict</code>, strictly positive</p></td> </tr> <tr>
<td><p>mean</p></td> <td><p><a class="reference internal" href="#mean-tweedie-deviance"><span class="std std-ref">Tweedie deviance</span></a></p></td> <td><p>depends on <code>power</code></p></td> <td><p><code>predict</code>, depends on <code>power</code></p></td> </tr> <tr>
<td><p>median</p></td> <td><p><a class="reference internal" href="#mean-absolute-error"><span class="std std-ref">absolute error</span></a></p></td> <td><p>all reals</p></td> <td><p><code>predict</code>, all reals</p></td> </tr> <tr>
<td><p>quantile</p></td> <td><p><a class="reference internal" href="#pinball-loss"><span class="std std-ref">pinball loss</span></a></p></td> <td><p>all reals</p></td> <td><p><code>predict</code>, all reals</p></td> </tr> <tr>
<td><p>mode</p></td> <td><p>no consistent one exists</p></td> <td><p>reals</p></td> <td></td> </tr>  </table> </div> <p><sup>1</sup> The Brier score is just a different name for the squared error in case of classification.</p> <p><sup>2</sup> The zero-one loss is only consistent but not strictly consistent for the mode. The zero-one loss is equivalent to one minus the accuracy score, meaning it gives different score values but the same ranking.</p> <p><sup>3</sup> R² gives the same ranking as squared error.</p> <p><strong>Fictitious Example:</strong> Let’s make the above arguments more tangible. Consider a setting in network reliability engineering, such as maintaining stable internet or Wi-Fi connections. As provider of the network, you have access to the dataset of log entries of network connections containing network load over time and many interesting features. Your goal is to improve the reliability of the connections. In fact, you promise your customers that on at least 99% of all days there are no connection discontinuities larger than 1 minute. Therefore, you are interested in a prediction of the 99% quantile (of longest connection interruption duration per day) in order to know in advance when to add more bandwidth and thereby satisfy your customers. So the <em>target functional</em> is the 99% quantile. From the table above, you choose the pinball loss as scoring function (fair enough, not much choice given), for model training (e.g. <code>HistGradientBoostingRegressor(loss="quantile", quantile=0.99)</code>) as well as model evaluation (<code>mean_pinball_loss(..., alpha=0.99)</code> - we apologize for the different argument names, <code>quantile</code> and <code>alpha</code>) be it in grid search for finding hyperparameters or in comparing to other models like <code>QuantileRegressor(quantile=0.99)</code>.</p> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="gneiting2007" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">Gneiting2007</a><span class="fn-bracket">]</span></span> <p>T. Gneiting and A. E. Raftery. <a class="reference external" href="https://doi.org/10.1198/016214506000001437">Strictly Proper Scoring Rules, Prediction, and Estimation</a> In: Journal of the American Statistical Association 102 (2007), pp. 359– 378. <a class="reference external" href="www.stat.washington.edu/people/raftery/research/pdf/gneiting2007jasa.pdf.html">link to pdf</a></p> </div> <div class="citation" id="gneiting2009" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>Gneiting2009<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>)</span> <p>T. Gneiting. <a class="reference external" href="https://arxiv.org/abs/0912.0902">Making and Evaluating Point Forecasts</a> Journal of the American Statistical Association 106 (2009): 746 - 762.</p> </div> <div class="citation" id="gneiting2014" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">Gneiting2014</a><span class="fn-bracket">]</span></span> <p>T. Gneiting and M. Katzfuss. <a class="reference external" href="https://doi.org/10.1146/annurev-st%20atistics-062713-085831">Probabilistic Forecasting</a>. In: Annual Review of Statistics and Its Application 1.1 (2014), pp. 125–151.</p> </div> <div class="citation" id="fissler2022" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">Fissler2022</a><span class="fn-bracket">]</span></span> <p>T. Fissler, C. Lorentzen and M. Mayer. <a class="reference external" href="https://arxiv.org/abs/2202.12780">Model Comparison and Calibration Assessment: User Guide for Consistent Scoring Functions in Machine Learning and Actuarial Practice.</a></p> </div> </div> </section> <section id="scoring-api-overview"> <h2 id="id6">
<span class="section-number">3.4.2. </span>Scoring API overview</h2> <p>There are 3 different APIs for evaluating the quality of a model’s predictions:</p> <ul class="simple"> <li>
<strong>Estimator score method</strong>: Estimators have a <code>score</code> method providing a default evaluation criterion for the problem they are designed to solve. Most commonly this is <a class="reference internal" href="#accuracy-score"><span class="std std-ref">accuracy</span></a> for classifiers and the <a class="reference internal" href="#r2-score"><span class="std std-ref">coefficient of determination</span></a> (<span class="math notranslate nohighlight">\(R^2\)</span>) for regressors. Details for each estimator can be found in its documentation.</li> <li>
<strong>Scoring parameter</strong>: Model-evaluation tools that use <a class="reference internal" href="cross_validation.html#cross-validation"><span class="std std-ref">cross-validation</span></a> (such as <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>model_selection.GridSearchCV</code></a>, <a class="reference internal" href="generated/sklearn.model_selection.validation_curve.html#sklearn.model_selection.validation_curve" title="sklearn.model_selection.validation_curve"><code>model_selection.validation_curve</code></a> and <a class="reference internal" href="generated/sklearn.linear_model.logisticregressioncv.html#sklearn.linear_model.LogisticRegressionCV" title="sklearn.linear_model.LogisticRegressionCV"><code>linear_model.LogisticRegressionCV</code></a>) rely on an internal <em>scoring</em> strategy. This can be specified using the <code>scoring</code> parameter of that tool and is discussed in the section <a class="reference internal" href="#scoring-parameter"><span class="std std-ref">The scoring parameter: defining model evaluation rules</span></a>.</li> <li>
<strong>Metric functions</strong>: The <a class="reference internal" href="https://scikit-learn.org/1.6/api/sklearn.metrics.html#module-sklearn.metrics" title="sklearn.metrics"><code>sklearn.metrics</code></a> module implements functions assessing prediction error for specific purposes. These metrics are detailed in sections on <a class="reference internal" href="#classification-metrics"><span class="std std-ref">Classification metrics</span></a>, <a class="reference internal" href="#multilabel-ranking-metrics"><span class="std std-ref">Multilabel ranking metrics</span></a>, <a class="reference internal" href="#regression-metrics"><span class="std std-ref">Regression metrics</span></a> and <a class="reference internal" href="#clustering-metrics"><span class="std std-ref">Clustering metrics</span></a>.</li> </ul> <p>Finally, <a class="reference internal" href="#dummy-estimators"><span class="std std-ref">Dummy estimators</span></a> are useful to get a baseline value of those metrics for random predictions.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>For “pairwise” metrics, between <em>samples</em> and not estimators or predictions, see the <a class="reference internal" href="metrics.html#metrics"><span class="std std-ref">Pairwise metrics, Affinities and Kernels</span></a> section.</p> </div> </section> <section id="the-scoring-parameter-defining-model-evaluation-rules"> <h2 id="scoring-parameter">
<span class="section-number">3.4.3. </span>The <code>scoring</code> parameter: defining model evaluation rules</h2> <p>Model selection and evaluation tools that internally use <a class="reference internal" href="cross_validation.html#cross-validation"><span class="std std-ref">cross-validation</span></a> (such as <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>model_selection.GridSearchCV</code></a>, <a class="reference internal" href="generated/sklearn.model_selection.validation_curve.html#sklearn.model_selection.validation_curve" title="sklearn.model_selection.validation_curve"><code>model_selection.validation_curve</code></a> and <a class="reference internal" href="generated/sklearn.linear_model.logisticregressioncv.html#sklearn.linear_model.LogisticRegressionCV" title="sklearn.linear_model.LogisticRegressionCV"><code>linear_model.LogisticRegressionCV</code></a>) take a <code>scoring</code> parameter that controls what metric they apply to the estimators evaluated.</p> <p>They can be specified in several ways:</p> <ul class="simple"> <li>
<code>None</code>: the estimator’s default evaluation criterion (i.e., the metric used in the estimator’s <code>score</code> method) is used.</li> <li>
<a class="reference internal" href="#scoring-string-names"><span class="std std-ref">String name</span></a>: common metrics can be passed via a string name.</li> <li>
<a class="reference internal" href="#scoring-callable"><span class="std std-ref">Callable</span></a>: more complex metrics can be passed via a custom metric callable (e.g., function).</li> </ul> <p>Some tools do also accept multiple metric evaluation. See <a class="reference internal" href="#multimetric-scoring"><span class="std std-ref">Using multiple metric evaluation</span></a> for details.</p> <section id="string-name-scorers"> <h3 id="scoring-string-names">
<span class="section-number">3.4.3.1. </span>String name scorers</h3> <p>For the most common use cases, you can designate a scorer object with the <code>scoring</code> parameter via a string name; the table below shows all possible values. All scorer objects follow the convention that <strong>higher return values are better than lower return values</strong>. Thus metrics which measure the distance between the model and the data, like <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>metrics.mean_squared_error</code></a>, are available as ‘neg_mean_squared_error’ which return the negated value of the metric.</p> <div class="pst-scrollable-table-container">
<table class="table"> <thead> <tr>
<th class="head"><p>Scoring string name</p></th> <th class="head"><p>Function</p></th> <th class="head"><p>Comment</p></th> </tr> </thead>  <tr>
<td><p><strong>Classification</strong></p></td> <td></td> <td></td> </tr> <tr>
<td><p>‘accuracy’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code>metrics.accuracy_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘balanced_accuracy’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.balanced_accuracy_score.html#sklearn.metrics.balanced_accuracy_score" title="sklearn.metrics.balanced_accuracy_score"><code>metrics.balanced_accuracy_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘top_k_accuracy’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.top_k_accuracy_score.html#sklearn.metrics.top_k_accuracy_score" title="sklearn.metrics.top_k_accuracy_score"><code>metrics.top_k_accuracy_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘average_precision’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>metrics.average_precision_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_brier_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.brier_score_loss.html#sklearn.metrics.brier_score_loss" title="sklearn.metrics.brier_score_loss"><code>metrics.brier_score_loss</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘f1’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>metrics.f1_score</code></a></p></td> <td><p>for binary targets</p></td> </tr> <tr>
<td><p>‘f1_micro’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>metrics.f1_score</code></a></p></td> <td><p>micro-averaged</p></td> </tr> <tr>
<td><p>‘f1_macro’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>metrics.f1_score</code></a></p></td> <td><p>macro-averaged</p></td> </tr> <tr>
<td><p>‘f1_weighted’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>metrics.f1_score</code></a></p></td> <td><p>weighted average</p></td> </tr> <tr>
<td><p>‘f1_samples’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>metrics.f1_score</code></a></p></td> <td><p>by multilabel sample</p></td> </tr> <tr>
<td><p>‘neg_log_loss’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.log_loss.html#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><code>metrics.log_loss</code></a></p></td> <td><p>requires <code>predict_proba</code> support</p></td> </tr> <tr>
<td><p>‘precision’ etc.</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code>metrics.precision_score</code></a></p></td> <td><p>suffixes apply as with ‘f1’</p></td> </tr> <tr>
<td><p>‘recall’ etc.</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code>metrics.recall_score</code></a></p></td> <td><p>suffixes apply as with ‘f1’</p></td> </tr> <tr>
<td><p>‘jaccard’ etc.</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.jaccard_score.html#sklearn.metrics.jaccard_score" title="sklearn.metrics.jaccard_score"><code>metrics.jaccard_score</code></a></p></td> <td><p>suffixes apply as with ‘f1’</p></td> </tr> <tr>
<td><p>‘roc_auc’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>metrics.roc_auc_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘roc_auc_ovr’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>metrics.roc_auc_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘roc_auc_ovo’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>metrics.roc_auc_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘roc_auc_ovr_weighted’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>metrics.roc_auc_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘roc_auc_ovo_weighted’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>metrics.roc_auc_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘d2_log_loss_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.d2_log_loss_score.html#sklearn.metrics.d2_log_loss_score" title="sklearn.metrics.d2_log_loss_score"><code>metrics.d2_log_loss_score</code></a></p></td> <td></td> </tr> <tr>
<td><p><strong>Clustering</strong></p></td> <td></td> <td></td> </tr> <tr>
<td><p>‘adjusted_mutual_info_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.adjusted_mutual_info_score.html#sklearn.metrics.adjusted_mutual_info_score" title="sklearn.metrics.adjusted_mutual_info_score"><code>metrics.adjusted_mutual_info_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘adjusted_rand_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.adjusted_rand_score.html#sklearn.metrics.adjusted_rand_score" title="sklearn.metrics.adjusted_rand_score"><code>metrics.adjusted_rand_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘completeness_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.completeness_score.html#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><code>metrics.completeness_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘fowlkes_mallows_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.fowlkes_mallows_score.html#sklearn.metrics.fowlkes_mallows_score" title="sklearn.metrics.fowlkes_mallows_score"><code>metrics.fowlkes_mallows_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘homogeneity_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.homogeneity_score.html#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><code>metrics.homogeneity_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘mutual_info_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.mutual_info_score.html#sklearn.metrics.mutual_info_score" title="sklearn.metrics.mutual_info_score"><code>metrics.mutual_info_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘normalized_mutual_info_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.normalized_mutual_info_score.html#sklearn.metrics.normalized_mutual_info_score" title="sklearn.metrics.normalized_mutual_info_score"><code>metrics.normalized_mutual_info_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘rand_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.rand_score.html#sklearn.metrics.rand_score" title="sklearn.metrics.rand_score"><code>metrics.rand_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘v_measure_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.v_measure_score.html#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><code>metrics.v_measure_score</code></a></p></td> <td></td> </tr> <tr>
<td><p><strong>Regression</strong></p></td> <td></td> <td></td> </tr> <tr>
<td><p>‘explained_variance’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>metrics.explained_variance_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_max_error’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.max_error.html#sklearn.metrics.max_error" title="sklearn.metrics.max_error"><code>metrics.max_error</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_mean_absolute_error’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code>metrics.mean_absolute_error</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_mean_squared_error’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>metrics.mean_squared_error</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_root_mean_squared_error’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.root_mean_squared_error.html#sklearn.metrics.root_mean_squared_error" title="sklearn.metrics.root_mean_squared_error"><code>metrics.root_mean_squared_error</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_mean_squared_log_error’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.mean_squared_log_error.html#sklearn.metrics.mean_squared_log_error" title="sklearn.metrics.mean_squared_log_error"><code>metrics.mean_squared_log_error</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_root_mean_squared_log_error’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.root_mean_squared_log_error.html#sklearn.metrics.root_mean_squared_log_error" title="sklearn.metrics.root_mean_squared_log_error"><code>metrics.root_mean_squared_log_error</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_median_absolute_error’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.median_absolute_error.html#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code>metrics.median_absolute_error</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘r2’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>metrics.r2_score</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_mean_poisson_deviance’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.mean_poisson_deviance.html#sklearn.metrics.mean_poisson_deviance" title="sklearn.metrics.mean_poisson_deviance"><code>metrics.mean_poisson_deviance</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_mean_gamma_deviance’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.mean_gamma_deviance.html#sklearn.metrics.mean_gamma_deviance" title="sklearn.metrics.mean_gamma_deviance"><code>metrics.mean_gamma_deviance</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘neg_mean_absolute_percentage_error’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.mean_absolute_percentage_error.html#sklearn.metrics.mean_absolute_percentage_error" title="sklearn.metrics.mean_absolute_percentage_error"><code>metrics.mean_absolute_percentage_error</code></a></p></td> <td></td> </tr> <tr>
<td><p>‘d2_absolute_error_score’</p></td> <td><p><a class="reference internal" href="generated/sklearn.metrics.d2_absolute_error_score.html#sklearn.metrics.d2_absolute_error_score" title="sklearn.metrics.d2_absolute_error_score"><code>metrics.d2_absolute_error_score</code></a></p></td> <td></td> </tr>  </table> </div> <p>Usage examples:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import svm, datasets
&gt;&gt;&gt; from sklearn.model_selection import cross_val_score
&gt;&gt;&gt; X, y = datasets.load_iris(return_X_y=True)
&gt;&gt;&gt; clf = svm.SVC(random_state=0)
&gt;&gt;&gt; cross_val_score(clf, X, y, cv=5, scoring='recall_macro')
array([0.96..., 0.96..., 0.96..., 0.93..., 1.        ])
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If a wrong scoring name is passed, an <code>InvalidParameterError</code> is raised. You can retrieve the names of all available scorers by calling <a class="reference internal" href="generated/sklearn.metrics.get_scorer_names.html#sklearn.metrics.get_scorer_names" title="sklearn.metrics.get_scorer_names"><code>get_scorer_names</code></a>.</p> </div> </section> <section id="callable-scorers"> <h3 id="scoring-callable">
<span class="section-number">3.4.3.2. </span>Callable scorers</h3> <p>For more complex use cases and more flexibility, you can pass a callable to the <code>scoring</code> parameter. This can be done by:</p> <ul class="simple"> <li><a class="reference internal" href="#scoring-adapt-metric"><span class="std std-ref">Adapting predefined metrics via make_scorer</span></a></li> <li>
<a class="reference internal" href="#scoring-custom"><span class="std std-ref">Creating a custom scorer object</span></a> (most flexible)</li> </ul> <section id="adapting-predefined-metrics-via-make-scorer"> <h4 id="scoring-adapt-metric">
<span class="section-number">3.4.3.2.1. </span>Adapting predefined metrics via <code>make_scorer</code>
</h4> <p>The following metric functions are not implemented as named scorers, sometimes because they require additional parameters, such as <a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code>fbeta_score</code></a>. They cannot be passed to the <code>scoring</code> parameters; instead their callable needs to be passed to <a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code>make_scorer</code></a> together with the value of the user-settable parameters.</p> <div class="pst-scrollable-table-container">
<table class="table"> <thead> <tr>
<th class="head"><p>Function</p></th> <th class="head"><p>Parameter</p></th> <th class="head"><p>Example usage</p></th> </tr> </thead>  <tr>
<td><p><strong>Classification</strong></p></td> <td></td> <td></td> </tr> <tr>
<td><p><code>metrics.fbeta_score</code></p></td> <td><p><code>beta</code></p></td> <td><p><code>make_scorer(fbeta_score, beta=2)</code></p></td> </tr> <tr>
<td><p><strong>Regression</strong></p></td> <td></td> <td></td> </tr> <tr>
<td><p><code>metrics.mean_tweedie_deviance</code></p></td> <td><p><code>power</code></p></td> <td><p><code>make_scorer(mean_tweedie_deviance, power=1.5)</code></p></td> </tr> <tr>
<td><p><code>metrics.mean_pinball_loss</code></p></td> <td><p><code>alpha</code></p></td> <td><p><code>make_scorer(mean_pinball_loss, alpha=0.95)</code></p></td> </tr> <tr>
<td><p><code>metrics.d2_tweedie_score</code></p></td> <td><p><code>power</code></p></td> <td><p><code>make_scorer(d2_tweedie_score, power=1.5)</code></p></td> </tr> <tr>
<td><p><code>metrics.d2_pinball_score</code></p></td> <td><p><code>alpha</code></p></td> <td><p><code>make_scorer(d2_pinball_score, alpha=0.95)</code></p></td> </tr>  </table> </div> <p>One typical use case is to wrap an existing metric function from the library with non-default values for its parameters, such as the <code>beta</code> parameter for the <a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code>fbeta_score</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import fbeta_score, make_scorer
&gt;&gt;&gt; ftwo_scorer = make_scorer(fbeta_score, beta=2)
&gt;&gt;&gt; from sklearn.model_selection import GridSearchCV
&gt;&gt;&gt; from sklearn.svm import LinearSVC
&gt;&gt;&gt; grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]},
...                     scoring=ftwo_scorer, cv=5)
</pre> <p>The module <a class="reference internal" href="https://scikit-learn.org/1.6/api/sklearn.metrics.html#module-sklearn.metrics" title="sklearn.metrics"><code>sklearn.metrics</code></a> also exposes a set of simple functions measuring a prediction error given ground truth and prediction:</p> <ul class="simple"> <li>functions ending with <code>_score</code> return a value to maximize, the higher the better.</li> <li>functions ending with <code>_error</code>, <code>_loss</code>, or <code>_deviance</code> return a value to minimize, the lower the better. When converting into a scorer object using <a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code>make_scorer</code></a>, set the <code>greater_is_better</code> parameter to <code>False</code> (<code>True</code> by default; see the parameter description below).</li> </ul> </section> <section id="creating-a-custom-scorer-object"> <h4 id="scoring-custom">
<span class="section-number">3.4.3.2.2. </span>Creating a custom scorer object</h4> <p>You can create your own custom scorer object using <a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code>make_scorer</code></a> or for the most flexibility, from scratch. See below for details.</p> <details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="custom-scorer-objects-using-make_scorer"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">Custom scorer objects using <code>make_scorer</code></span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">You can build a completely custom scorer object from a simple python function using <a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code>make_scorer</code></a>, which can take several parameters:</p> <ul class="simple"> <li>the python function you want to use (<code>my_custom_loss_func</code> in the example below)</li> <li>whether the python function returns a score (<code>greater_is_better=True</code>, the default) or a loss (<code>greater_is_better=False</code>). If a loss, the output of the python function is negated by the scorer object, conforming to the cross validation convention that scorers return higher values for better models.</li> <li>for classification metrics only: whether the python function you provided requires continuous decision certainties. If the scoring function only accepts probability estimates (e.g. <code>metrics.log_loss</code>), then one needs to set the parameter <code>response_method="predict_proba"</code>. Some scoring functions do not necessarily require probability estimates but rather non-thresholded decision values (e.g. <code>metrics.roc_auc_score</code>). In this case, one can provide a list (e.g., <code>response_method=["decision_function", "predict_proba"]</code>), and scorer will use the first available method, in the order given in the list, to compute the scores.</li> <li>any additional parameters of the scoring function, such as <code>beta</code> or <code>labels</code>.</li> </ul> <p class="sd-card-text">Here is an example of building custom scorers, and of using the <code>greater_is_better</code> parameter:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; def my_custom_loss_func(y_true, y_pred):
...     diff = np.abs(y_true - y_pred).max()
...     return np.log1p(diff)
...
&gt;&gt;&gt; # score will negate the return value of my_custom_loss_func,
&gt;&gt;&gt; # which will be np.log(2), 0.693, given the values for X
&gt;&gt;&gt; # and y defined below.
&gt;&gt;&gt; score = make_scorer(my_custom_loss_func, greater_is_better=False)
&gt;&gt;&gt; X = [[1], [1]]
&gt;&gt;&gt; y = [0, 1]
&gt;&gt;&gt; from sklearn.dummy import DummyClassifier
&gt;&gt;&gt; clf = DummyClassifier(strategy='most_frequent', random_state=0)
&gt;&gt;&gt; clf = clf.fit(X, y)
&gt;&gt;&gt; my_custom_loss_func(y, clf.predict(X))
0.69...
&gt;&gt;&gt; score(clf, X, y)
-0.69...
</pre> </div> </details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="custom-scorer-objects-from-scratch"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">Custom scorer objects from scratch</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">You can generate even more flexible model scorers by constructing your own scoring object from scratch, without using the <a class="reference internal" href="generated/sklearn.metrics.make_scorer.html#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code>make_scorer</code></a> factory.</p> <p class="sd-card-text">For a callable to be a scorer, it needs to meet the protocol specified by the following two rules:</p> <ul class="simple"> <li>It can be called with parameters <code>(estimator, X, y)</code>, where <code>estimator</code> is the model that should be evaluated, <code>X</code> is validation data, and <code>y</code> is the ground truth target for <code>X</code> (in the supervised case) or <code>None</code> (in the unsupervised case).</li> <li>It returns a floating point number that quantifies the <code>estimator</code> prediction quality on <code>X</code>, with reference to <code>y</code>. Again, by convention higher numbers are better, so if your scorer returns loss, that value should be negated.</li> <li>Advanced: If it requires extra metadata to be passed to it, it should expose a <code>get_metadata_routing</code> method returning the requested metadata. The user should be able to set the requested metadata via a <code>set_score_request</code> method. Please see <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> and <a class="reference internal" href="../auto_examples/miscellaneous/plot_metadata_routing.html#sphx-glr-auto-examples-miscellaneous-plot-metadata-routing-py"><span class="std std-ref">Developer Guide</span></a> for more details.</li> </ul> </div> </details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="using-custom-scorers-in-functions-where-n_jobs-&gt;-1"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">Using custom scorers in functions where n_jobs &gt; 1</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">While defining the custom scoring function alongside the calling function should work out of the box with the default joblib backend (loky), importing it from another module will be a more robust approach and work independently of the joblib backend.</p> <p class="sd-card-text">For example, to use <code>n_jobs</code> greater than 1 in the example below, <code>custom_scoring_function</code> function is saved in a user-created module (<code>custom_scorer_module.py</code>) and imported:</p> <pre data-language="python">&gt;&gt;&gt; from custom_scorer_module import custom_scoring_function 
&gt;&gt;&gt; cross_val_score(model,
...  X_train,
...  y_train,
...  scoring=make_scorer(custom_scoring_function, greater_is_better=False),
...  cv=5,
...  n_jobs=-1) 
</pre> </div> </details></section> </section> <section id="using-multiple-metric-evaluation"> <h3 id="multimetric-scoring">
<span class="section-number">3.4.3.3. </span>Using multiple metric evaluation</h3> <p>Scikit-learn also permits evaluation of multiple metrics in <code>GridSearchCV</code>, <code>RandomizedSearchCV</code> and <code>cross_validate</code>.</p> <p>There are three ways to specify multiple scoring metrics for the <code>scoring</code> parameter:</p> <ul> <li>
<p>As an iterable of string metrics:</p> <pre data-language="python">&gt;&gt;&gt; scoring = ['accuracy', 'precision']
</pre> </li> <li>
<p>As a <code>dict</code> mapping the scorer name to the scoring function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import accuracy_score
&gt;&gt;&gt; from sklearn.metrics import make_scorer
&gt;&gt;&gt; scoring = {'accuracy': make_scorer(accuracy_score),
...            'prec': 'precision'}
</pre> <p>Note that the dict values can either be scorer functions or one of the predefined metric strings.</p> </li> <li>
<p>As a callable that returns a dictionary of scores:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import cross_validate
&gt;&gt;&gt; from sklearn.metrics import confusion_matrix
&gt;&gt;&gt; # A sample toy binary classification dataset
&gt;&gt;&gt; X, y = datasets.make_classification(n_classes=2, random_state=0)
&gt;&gt;&gt; svm = LinearSVC(random_state=0)
&gt;&gt;&gt; def confusion_matrix_scorer(clf, X, y):
...      y_pred = clf.predict(X)
...      cm = confusion_matrix(y, y_pred)
...      return {'tn': cm[0, 0], 'fp': cm[0, 1],
...              'fn': cm[1, 0], 'tp': cm[1, 1]}
&gt;&gt;&gt; cv_results = cross_validate(svm, X, y, cv=5,
...                             scoring=confusion_matrix_scorer)
&gt;&gt;&gt; # Getting the test set true positive scores
&gt;&gt;&gt; print(cv_results['test_tp'])
[10  9  8  7  8]
&gt;&gt;&gt; # Getting the test set false negative scores
&gt;&gt;&gt; print(cv_results['test_fn'])
[0 1 2 3 2]
</pre> </li> </ul> </section> </section> <section id="classification-metrics"> <h2 id="id7">
<span class="section-number">3.4.4. </span>Classification metrics</h2> <p>The <a class="reference internal" href="https://scikit-learn.org/1.6/api/sklearn.metrics.html#module-sklearn.metrics" title="sklearn.metrics"><code>sklearn.metrics</code></a> module implements several loss, score, and utility functions to measure classification performance. Some metrics might require probability estimates of the positive class, confidence values, or binary decisions values. Most implementations allow each sample to provide a weighted contribution to the overall score, through the <code>sample_weight</code> parameter.</p> <p>Some of these are restricted to the binary classification case:</p> <div class="pst-scrollable-table-container">
<table class="autosummary longtable table autosummary">  <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a>(y_true[, y_score, ...])</p></td> <td><p>Compute precision-recall pairs for different probability thresholds.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><code>roc_curve</code></a>(y_true, y_score, *[, pos_label, ...])</p></td> <td><p>Compute Receiver operating characteristic (ROC).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.class_likelihood_ratios.html#sklearn.metrics.class_likelihood_ratios" title="sklearn.metrics.class_likelihood_ratios"><code>class_likelihood_ratios</code></a>(y_true, y_pred, *[, ...])</p></td> <td><p>Compute binary classification positive and negative likelihood ratios.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.det_curve.html#sklearn.metrics.det_curve" title="sklearn.metrics.det_curve"><code>det_curve</code></a>(y_true, y_score[, pos_label, ...])</p></td> <td><p>Compute error rates for different probability thresholds.</p></td> </tr>  </table> </div> <p>Others also work in the multiclass case:</p> <div class="pst-scrollable-table-container">
<table class="autosummary longtable table autosummary">  <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.balanced_accuracy_score.html#sklearn.metrics.balanced_accuracy_score" title="sklearn.metrics.balanced_accuracy_score"><code>balanced_accuracy_score</code></a>(y_true, y_pred, *[, ...])</p></td> <td><p>Compute the balanced accuracy.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.cohen_kappa_score.html#sklearn.metrics.cohen_kappa_score" title="sklearn.metrics.cohen_kappa_score"><code>cohen_kappa_score</code></a>(y1, y2, *[, labels, ...])</p></td> <td><p>Compute Cohen's kappa: a statistic that measures inter-annotator agreement.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.confusion_matrix.html#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><code>confusion_matrix</code></a>(y_true, y_pred, *[, ...])</p></td> <td><p>Compute confusion matrix to evaluate the accuracy of a classification.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code>hinge_loss</code></a>(y_true, pred_decision, *[, ...])</p></td> <td><p>Average hinge loss (non-regularized).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef.html#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><code>matthews_corrcoef</code></a>(y_true, y_pred, *[, ...])</p></td> <td><p>Compute the Matthews correlation coefficient (MCC).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a>(y_true, y_score, *[, average, ...])</p></td> <td><p>Compute Area Under the Receiver Operating Characteristic Curve (ROC AUC) from prediction scores.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.top_k_accuracy_score.html#sklearn.metrics.top_k_accuracy_score" title="sklearn.metrics.top_k_accuracy_score"><code>top_k_accuracy_score</code></a>(y_true, y_score, *[, ...])</p></td> <td><p>Top-k Accuracy classification score.</p></td> </tr>  </table> </div> <p>Some also work in the multilabel case:</p> <div class="pst-scrollable-table-container">
<table class="autosummary longtable table autosummary">  <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code>accuracy_score</code></a>(y_true, y_pred, *[, ...])</p></td> <td><p>Accuracy classification score.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.classification_report.html#sklearn.metrics.classification_report" title="sklearn.metrics.classification_report"><code>classification_report</code></a>(y_true, y_pred, *[, ...])</p></td> <td><p>Build a text report showing the main classification metrics.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>f1_score</code></a>(y_true, y_pred, *[, labels, ...])</p></td> <td><p>Compute the F1 score, also known as balanced F-score or F-measure.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code>fbeta_score</code></a>(y_true, y_pred, *, beta[, ...])</p></td> <td><p>Compute the F-beta score.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.hamming_loss.html#sklearn.metrics.hamming_loss" title="sklearn.metrics.hamming_loss"><code>hamming_loss</code></a>(y_true, y_pred, *[, sample_weight])</p></td> <td><p>Compute the average Hamming loss.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.jaccard_score.html#sklearn.metrics.jaccard_score" title="sklearn.metrics.jaccard_score"><code>jaccard_score</code></a>(y_true, y_pred, *[, labels, ...])</p></td> <td><p>Jaccard similarity coefficient score.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.log_loss.html#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><code>log_loss</code></a>(y_true, y_pred, *[, normalize, ...])</p></td> <td><p>Log loss, aka logistic loss or cross-entropy loss.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.multilabel_confusion_matrix.html#sklearn.metrics.multilabel_confusion_matrix" title="sklearn.metrics.multilabel_confusion_matrix"><code>multilabel_confusion_matrix</code></a>(y_true, y_pred, *)</p></td> <td><p>Compute a confusion matrix for each class or sample.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code>precision_recall_fscore_support</code></a>(y_true, ...)</p></td> <td><p>Compute precision, recall, F-measure and support for each class.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code>precision_score</code></a>(y_true, y_pred, *[, labels, ...])</p></td> <td><p>Compute the precision.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code>recall_score</code></a>(y_true, y_pred, *[, labels, ...])</p></td> <td><p>Compute the recall.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a>(y_true, y_score, *[, average, ...])</p></td> <td><p>Compute Area Under the Receiver Operating Characteristic Curve (ROC AUC) from prediction scores.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.zero_one_loss.html#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><code>zero_one_loss</code></a>(y_true, y_pred, *[, ...])</p></td> <td><p>Zero-one classification loss.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.d2_log_loss_score.html#sklearn.metrics.d2_log_loss_score" title="sklearn.metrics.d2_log_loss_score"><code>d2_log_loss_score</code></a>(y_true, y_pred, *[, ...])</p></td> <td><p><span class="math notranslate nohighlight">\(D^2\)</span> score function, fraction of log loss explained.</p></td> </tr>  </table> </div> <p>And some work with binary and multilabel (but not multiclass) problems:</p> <div class="pst-scrollable-table-container">
<table class="autosummary longtable table autosummary">  <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a>(y_true, y_score, *)</p></td> <td><p>Compute average precision (AP) from prediction scores.</p></td> </tr>  </table> </div> <p>In the following sub-sections, we will describe each of those functions, preceded by some notes on common API and metric definition.</p> <section id="from-binary-to-multiclass-and-multilabel"> <h3 id="average">
<span class="section-number">3.4.4.1. </span>From binary to multiclass and multilabel</h3> <p>Some metrics are essentially defined for binary classification tasks (e.g. <a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>f1_score</code></a>, <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a>). In these cases, by default only the positive label is evaluated, assuming by default that the positive class is labelled <code>1</code> (though this may be configurable through the <code>pos_label</code> parameter).</p> <p>In extending a binary metric to multiclass or multilabel problems, the data is treated as a collection of binary problems, one for each class. There are then a number of ways to average binary metric calculations across the set of classes, each of which may be useful in some scenario. Where available, you should select among these using the <code>average</code> parameter.</p> <ul class="simple"> <li>
<code>"macro"</code> simply calculates the mean of the binary metrics, giving equal weight to each class. In problems where infrequent classes are nonetheless important, macro-averaging may be a means of highlighting their performance. On the other hand, the assumption that all classes are equally important is often untrue, such that macro-averaging will over-emphasize the typically low performance on an infrequent class.</li> <li>
<code>"weighted"</code> accounts for class imbalance by computing the average of binary metrics in which each class’s score is weighted by its presence in the true data sample.</li> <li>
<code>"micro"</code> gives each sample-class pair an equal contribution to the overall metric (except as a result of sample-weight). Rather than summing the metric per class, this sums the dividends and divisors that make up the per-class metrics to calculate an overall quotient. Micro-averaging may be preferred in multilabel settings, including multiclass classification where a majority class is to be ignored.</li> <li>
<code>"samples"</code> applies only to multilabel problems. It does not calculate a per-class measure, instead calculating the metric over the true and predicted classes for each sample in the evaluation data, and returning their (<code>sample_weight</code>-weighted) average.</li> <li>Selecting <code>average=None</code> will return an array with the score for each class.</li> </ul> <p>While multiclass data is provided to the metric, like binary targets, as an array of class labels, multilabel data is specified as an indicator matrix, in which cell <code>[i, j]</code> has value 1 if sample <code>i</code> has label <code>j</code> and value 0 otherwise.</p> </section> <section id="accuracy-score"> <h3 id="id8">
<span class="section-number">3.4.4.2. </span>Accuracy score</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code>accuracy_score</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Accuracy_and_precision">accuracy</a>, either the fraction (default) or the count (normalize=False) of correct predictions.</p> <p>In multilabel classification, the function returns the subset accuracy. If the entire set of predicted labels for a sample strictly match with the true set of labels, then the subset accuracy is 1.0; otherwise it is 0.0.</p> <p>If <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> is the predicted value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value, then the fraction of correct predictions over <span class="math notranslate nohighlight">\(n_\text{samples}\)</span> is defined as</p> <div class="math notranslate nohighlight"> \[\texttt{accuracy}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} 1(\hat{y}_i = y_i)\]</div> <p>where <span class="math notranslate nohighlight">\(1(x)\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">indicator function</a>.</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import accuracy_score
&gt;&gt;&gt; y_pred = [0, 2, 1, 3]
&gt;&gt;&gt; y_true = [0, 1, 2, 3]
&gt;&gt;&gt; accuracy_score(y_true, y_pred)
0.5
&gt;&gt;&gt; accuracy_score(y_true, y_pred, normalize=False)
2.0
</pre> <p>In the multilabel case with binary label indicators:</p> <pre data-language="python">&gt;&gt;&gt; accuracy_score(np.array([[0, 1], [1, 1]]), np.ones((2, 2)))
0.5
</pre> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_permutation_tests_for_classification.html#sphx-glr-auto-examples-model-selection-plot-permutation-tests-for-classification-py"><span class="std std-ref">Test with permutations the significance of a classification score</span></a> for an example of accuracy score usage using permutations of the dataset.</li> </ul> </section> <section id="top-k-accuracy-score"> <h3 id="id9">
<span class="section-number">3.4.4.3. </span>Top-k accuracy score</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.top_k_accuracy_score.html#sklearn.metrics.top_k_accuracy_score" title="sklearn.metrics.top_k_accuracy_score"><code>top_k_accuracy_score</code></a> function is a generalization of <a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code>accuracy_score</code></a>. The difference is that a prediction is considered correct as long as the true label is associated with one of the <code>k</code> highest predicted scores. <a class="reference internal" href="generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code>accuracy_score</code></a> is the special case of <code>k = 1</code>.</p> <p>The function covers the binary and multiclass classification cases but not the multilabel case.</p> <p>If <span class="math notranslate nohighlight">\(\hat{f}_{i,j}\)</span> is the predicted class for the <span class="math notranslate nohighlight">\(i\)</span>-th sample corresponding to the <span class="math notranslate nohighlight">\(j\)</span>-th largest predicted score and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value, then the fraction of correct predictions over <span class="math notranslate nohighlight">\(n_\text{samples}\)</span> is defined as</p> <div class="math notranslate nohighlight"> \[\texttt{top-k accuracy}(y, \hat{f}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} \sum_{j=1}^{k} 1(\hat{f}_{i,j} = y_i)\]</div> <p>where <span class="math notranslate nohighlight">\(k\)</span> is the number of guesses allowed and <span class="math notranslate nohighlight">\(1(x)\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">indicator function</a>.</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import top_k_accuracy_score
&gt;&gt;&gt; y_true = np.array([0, 1, 2, 2])
&gt;&gt;&gt; y_score = np.array([[0.5, 0.2, 0.2],
...                     [0.3, 0.4, 0.2],
...                     [0.2, 0.4, 0.3],
...                     [0.7, 0.2, 0.1]])
&gt;&gt;&gt; top_k_accuracy_score(y_true, y_score, k=2)
0.75
&gt;&gt;&gt; # Not normalizing gives the number of "correctly" classified samples
&gt;&gt;&gt; top_k_accuracy_score(y_true, y_score, k=2, normalize=False)
3
</pre> </section> <section id="balanced-accuracy-score"> <h3 id="id11">
<span class="section-number">3.4.4.4. </span>Balanced accuracy score</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.balanced_accuracy_score.html#sklearn.metrics.balanced_accuracy_score" title="sklearn.metrics.balanced_accuracy_score"><code>balanced_accuracy_score</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Accuracy_and_precision">balanced accuracy</a>, which avoids inflated performance estimates on imbalanced datasets. It is the macro-average of recall scores per class or, equivalently, raw accuracy where each sample is weighted according to the inverse prevalence of its true class. Thus for balanced datasets, the score is equal to accuracy.</p> <p>In the binary case, balanced accuracy is equal to the arithmetic mean of <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">sensitivity</a> (true positive rate) and <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">specificity</a> (true negative rate), or the area under the ROC curve with binary predictions rather than scores:</p> <div class="math notranslate nohighlight"> \[\texttt{balanced-accuracy} = \frac{1}{2}\left( \frac{TP}{TP + FN} + \frac{TN}{TN + FP}\right )\]</div> <p>If the classifier performs equally well on either class, this term reduces to the conventional accuracy (i.e., the number of correct predictions divided by the total number of predictions).</p> <p>In contrast, if the conventional accuracy is above chance only because the classifier takes advantage of an imbalanced test set, then the balanced accuracy, as appropriate, will drop to <span class="math notranslate nohighlight">\(\frac{1}{n\_classes}\)</span>.</p> <p>The score ranges from 0 to 1, or when <code>adjusted=True</code> is used, it rescaled to the range <span class="math notranslate nohighlight">\(\frac{1}{1 - n\_classes}\)</span> to 1, inclusive, with performance at random scoring 0.</p> <p>If <span class="math notranslate nohighlight">\(y_i\)</span> is the true value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample, and <span class="math notranslate nohighlight">\(w_i\)</span> is the corresponding sample weight, then we adjust the sample weight to:</p> <div class="math notranslate nohighlight"> \[\hat{w}_i = \frac{w_i}{\sum_j{1(y_j = y_i) w_j}}\]</div> <p>where <span class="math notranslate nohighlight">\(1(x)\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">indicator function</a>. Given predicted <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> for sample <span class="math notranslate nohighlight">\(i\)</span>, balanced accuracy is defined as:</p> <div class="math notranslate nohighlight"> \[\texttt{balanced-accuracy}(y, \hat{y}, w) = \frac{1}{\sum{\hat{w}_i}} \sum_i 1(\hat{y}_i = y_i) \hat{w}_i\]</div> <p>With <code>adjusted=True</code>, balanced accuracy reports the relative increase from <span class="math notranslate nohighlight">\(\texttt{balanced-accuracy}(y, \mathbf{0}, w) = \frac{1}{n\_classes}\)</span>. In the binary case, this is also known as <a class="reference external" href="https://en.wikipedia.org/wiki/Youden%27s_J_statistic">*Youden’s J statistic*</a>, or <em>informedness</em>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The multiclass definition here seems the most reasonable extension of the metric used in binary classification, though there is no certain consensus in the literature:</p> <ul class="simple"> <li>Our definition: <a class="reference internal" href="#mosley2013" id="id13"><span>[Mosley2013]</span></a>, <a class="reference internal" href="#kelleher2015" id="id14"><span>[Kelleher2015]</span></a> and <a class="reference internal" href="#guyon2015" id="id15"><span>[Guyon2015]</span></a>, where <a class="reference internal" href="#guyon2015" id="id16"><span>[Guyon2015]</span></a> adopt the adjusted version to ensure that random predictions have a score of <span class="math notranslate nohighlight">\(0\)</span> and perfect predictions have a score of <span class="math notranslate nohighlight">\(1\)</span>..</li> <li>Class balanced accuracy as described in <a class="reference internal" href="#mosley2013" id="id17"><span>[Mosley2013]</span></a>: the minimum between the precision and the recall for each class is computed. Those values are then averaged over the total number of classes to get the balanced accuracy.</li> <li>Balanced Accuracy as described in <a class="reference internal" href="#urbanowicz2015" id="id18"><span>[Urbanowicz2015]</span></a>: the average of sensitivity and specificity is computed for each class and then averaged over total number of classes.</li> </ul> </div> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="guyon2015" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>Guyon2015<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id15">1</a>,<a role="doc-backlink" href="#id16">2</a>)</span> <p>I. Guyon, K. Bennett, G. Cawley, H.J. Escalante, S. Escalera, T.K. Ho, N. Macià, B. Ray, M. Saeed, A.R. Statnikov, E. Viegas, <a class="reference external" href="https://ieeexplore.ieee.org/document/7280767">Design of the 2015 ChaLearn AutoML Challenge</a>, IJCNN 2015.</p> </div> <div class="citation" id="mosley2013" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>Mosley2013<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id13">1</a>,<a role="doc-backlink" href="#id17">2</a>)</span> <p>L. Mosley, <a class="reference external" href="https://lib.dr.iastate.edu/etd/13537/">A balanced approach to the multi-class imbalance problem</a>, IJCV 2010.</p> </div> <div class="citation" id="kelleher2015" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">Kelleher2015</a><span class="fn-bracket">]</span></span> <p>John. D. Kelleher, Brian Mac Namee, Aoife D’Arcy, <a class="reference external" href="https://mitpress.mit.edu/books/fundamentals-machine-learning-predictive-data-analytics">Fundamentals of Machine Learning for Predictive Data Analytics: Algorithms, Worked Examples, and Case Studies</a>, 2015.</p> </div> <div class="citation" id="urbanowicz2015" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">Urbanowicz2015</a><span class="fn-bracket">]</span></span> <p>Urbanowicz R.J., Moore, J.H. <a class="reference external" href="https://doi.org/10.1007/s12065-015-0128-8">ExSTraCS 2.0: description and evaluation of a scalable learning classifier system</a>, Evol. Intel. (2015) 8: 89.</p> </div> </div> </section> <section id="cohen-s-kappa"> <h3 id="cohen-kappa">
<span class="section-number">3.4.4.5. </span>Cohen’s kappa</h3> <p>The function <a class="reference internal" href="generated/sklearn.metrics.cohen_kappa_score.html#sklearn.metrics.cohen_kappa_score" title="sklearn.metrics.cohen_kappa_score"><code>cohen_kappa_score</code></a> computes <a class="reference external" href="https://en.wikipedia.org/wiki/Cohen%27s_kappa">Cohen’s kappa</a> statistic. This measure is intended to compare labelings by different human annotators, not a classifier versus a ground truth.</p> <p>The kappa score is a number between -1 and 1. Scores above .8 are generally considered good agreement; zero or lower means no agreement (practically random labels).</p> <p>Kappa scores can be computed for binary or multiclass problems, but not for multilabel problems (except by manually computing a per-label score) and not for more than two annotators.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import cohen_kappa_score
&gt;&gt;&gt; labeling1 = [2, 0, 2, 2, 0, 1]
&gt;&gt;&gt; labeling2 = [0, 0, 2, 2, 0, 2]
&gt;&gt;&gt; cohen_kappa_score(labeling1, labeling2)
0.4285714285714286
</pre> </section> <section id="confusion-matrix"> <h3 id="id20">
<span class="section-number">3.4.4.6. </span>Confusion matrix</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.confusion_matrix.html#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><code>confusion_matrix</code></a> function evaluates classification accuracy by computing the <a class="reference external" href="https://en.wikipedia.org/wiki/Confusion_matrix">confusion matrix</a> with each row corresponding to the true class (Wikipedia and other references may use different convention for axes).</p> <p>By definition, entry <span class="math notranslate nohighlight">\(i, j\)</span> in a confusion matrix is the number of observations actually in group <span class="math notranslate nohighlight">\(i\)</span>, but predicted to be in group <span class="math notranslate nohighlight">\(j\)</span>. Here is an example:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import confusion_matrix
&gt;&gt;&gt; y_true = [2, 0, 2, 2, 0, 1]
&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 0, 2]
&gt;&gt;&gt; confusion_matrix(y_true, y_pred)
array([[2, 0, 0],
       [0, 0, 1],
       [1, 0, 2]])
</pre> <p><a class="reference internal" href="generated/sklearn.metrics.confusionmatrixdisplay.html#sklearn.metrics.ConfusionMatrixDisplay" title="sklearn.metrics.ConfusionMatrixDisplay"><code>ConfusionMatrixDisplay</code></a> can be used to visually represent a confusion matrix as shown in the <a class="reference internal" href="../auto_examples/model_selection/plot_confusion_matrix.html#sphx-glr-auto-examples-model-selection-plot-confusion-matrix-py"><span class="std std-ref">Confusion matrix</span></a> example, which creates the following figure:</p> <a class="reference external image-reference" href="../auto_examples/model_selection/plot_confusion_matrix.html"><img alt="../_images/sphx_glr_plot_confusion_matrix_001.png" class="align-center" src="data:image/png;base64,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" style="width: 480.0px; height: 360.0px;"> </a> <p>The parameter <code>normalize</code> allows to report ratios instead of counts. The confusion matrix can be normalized in 3 different ways: <code>'pred'</code>, <code>'true'</code>, and <code>'all'</code> which will divide the counts by the sum of each columns, rows, or the entire matrix, respectively.</p> <pre data-language="python">&gt;&gt;&gt; y_true = [0, 0, 0, 1, 1, 1, 1, 1]
&gt;&gt;&gt; y_pred = [0, 1, 0, 1, 0, 1, 0, 1]
&gt;&gt;&gt; confusion_matrix(y_true, y_pred, normalize='all')
array([[0.25 , 0.125],
       [0.25 , 0.375]])
</pre> <p>For binary problems, we can get counts of true negatives, false positives, false negatives and true positives as follows:</p> <pre data-language="python">&gt;&gt;&gt; y_true = [0, 0, 0, 1, 1, 1, 1, 1]
&gt;&gt;&gt; y_pred = [0, 1, 0, 1, 0, 1, 0, 1]
&gt;&gt;&gt; tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
&gt;&gt;&gt; tn, fp, fn, tp
(2, 1, 2, 3)
</pre> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_confusion_matrix.html#sphx-glr-auto-examples-model-selection-plot-confusion-matrix-py"><span class="std std-ref">Confusion matrix</span></a> for an example of using a confusion matrix to evaluate classifier output quality.</li> <li>See <a class="reference internal" href="../auto_examples/classification/plot_digits_classification.html#sphx-glr-auto-examples-classification-plot-digits-classification-py"><span class="std std-ref">Recognizing hand-written digits</span></a> for an example of using a confusion matrix to classify hand-written digits.</li> <li>See <a class="reference internal" href="../auto_examples/text/plot_document_classification_20newsgroups.html#sphx-glr-auto-examples-text-plot-document-classification-20newsgroups-py"><span class="std std-ref">Classification of text documents using sparse features</span></a> for an example of using a confusion matrix to classify text documents.</li> </ul> </section> <section id="classification-report"> <h3 id="id22">
<span class="section-number">3.4.4.7. </span>Classification report</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.classification_report.html#sklearn.metrics.classification_report" title="sklearn.metrics.classification_report"><code>classification_report</code></a> function builds a text report showing the main classification metrics. Here is a small example with custom <code>target_names</code> and inferred labels:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import classification_report
&gt;&gt;&gt; y_true = [0, 1, 2, 2, 0]
&gt;&gt;&gt; y_pred = [0, 0, 2, 1, 0]
&gt;&gt;&gt; target_names = ['class 0', 'class 1', 'class 2']
&gt;&gt;&gt; print(classification_report(y_true, y_pred, target_names=target_names))
              precision    recall  f1-score   support

     class 0       0.67      1.00      0.80         2
     class 1       0.00      0.00      0.00         1
     class 2       1.00      0.50      0.67         2

    accuracy                           0.60         5
   macro avg       0.56      0.50      0.49         5
weighted avg       0.67      0.60      0.59         5
</pre> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/classification/plot_digits_classification.html#sphx-glr-auto-examples-classification-plot-digits-classification-py"><span class="std std-ref">Recognizing hand-written digits</span></a> for an example of classification report usage for hand-written digits.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_grid_search_digits.html#sphx-glr-auto-examples-model-selection-plot-grid-search-digits-py"><span class="std std-ref">Custom refit strategy of a grid search with cross-validation</span></a> for an example of classification report usage for grid search with nested cross-validation.</li> </ul> </section> <section id="hamming-loss"> <h3 id="id23">
<span class="section-number">3.4.4.8. </span>Hamming loss</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.hamming_loss.html#sklearn.metrics.hamming_loss" title="sklearn.metrics.hamming_loss"><code>hamming_loss</code></a> computes the average Hamming loss or <a class="reference external" href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a> between two sets of samples.</p> <p>If <span class="math notranslate nohighlight">\(\hat{y}_{i,j}\)</span> is the predicted value for the <span class="math notranslate nohighlight">\(j\)</span>-th label of a given sample <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(y_{i,j}\)</span> is the corresponding true value, <span class="math notranslate nohighlight">\(n_\text{samples}\)</span> is the number of samples and <span class="math notranslate nohighlight">\(n_\text{labels}\)</span> is the number of labels, then the Hamming loss <span class="math notranslate nohighlight">\(L_{Hamming}\)</span> is defined as:</p> <div class="math notranslate nohighlight"> \[L_{Hamming}(y, \hat{y}) = \frac{1}{n_\text{samples} * n_\text{labels}} \sum_{i=0}^{n_\text{samples}-1} \sum_{j=0}^{n_\text{labels} - 1} 1(\hat{y}_{i,j} \not= y_{i,j})\]</div> <p>where <span class="math notranslate nohighlight">\(1(x)\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">indicator function</a>.</p> <p>The equation above does not hold true in the case of multiclass classification. Please refer to the note below for more information.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import hamming_loss
&gt;&gt;&gt; y_pred = [1, 2, 3, 4]
&gt;&gt;&gt; y_true = [2, 2, 3, 4]
&gt;&gt;&gt; hamming_loss(y_true, y_pred)
0.25
</pre> <p>In the multilabel case with binary label indicators:</p> <pre data-language="python">&gt;&gt;&gt; hamming_loss(np.array([[0, 1], [1, 1]]), np.zeros((2, 2)))
0.75
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In multiclass classification, the Hamming loss corresponds to the Hamming distance between <code>y_true</code> and <code>y_pred</code> which is similar to the <a class="reference internal" href="#zero-one-loss"><span class="std std-ref">Zero one loss</span></a> function. However, while zero-one loss penalizes prediction sets that do not strictly match true sets, the Hamming loss penalizes individual labels. Thus the Hamming loss, upper bounded by the zero-one loss, is always between zero and one, inclusive; and predicting a proper subset or superset of the true labels will give a Hamming loss between zero and one, exclusive.</p> </div> </section> <section id="precision-recall-and-f-measures"> <h3 id="precision-recall-f-measure-metrics">
<span class="section-number">3.4.4.9. </span>Precision, recall and F-measures</h3> <p>Intuitively, <a class="reference external" href="https://en.wikipedia.org/wiki/Precision_and_recall#Precision">precision</a> is the ability of the classifier not to label as positive a sample that is negative, and <a class="reference external" href="https://en.wikipedia.org/wiki/Precision_and_recall#Recall">recall</a> is the ability of the classifier to find all the positive samples.</p> <p>The <a class="reference external" href="https://en.wikipedia.org/wiki/F1_score">F-measure</a> (<span class="math notranslate nohighlight">\(F_\beta\)</span> and <span class="math notranslate nohighlight">\(F_1\)</span> measures) can be interpreted as a weighted harmonic mean of the precision and recall. A <span class="math notranslate nohighlight">\(F_\beta\)</span> measure reaches its best value at 1 and its worst score at 0. With <span class="math notranslate nohighlight">\(\beta = 1\)</span>, <span class="math notranslate nohighlight">\(F_\beta\)</span> and <span class="math notranslate nohighlight">\(F_1\)</span> are equivalent, and the recall and the precision are equally important.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a> computes a precision-recall curve from the ground truth label and a score given by the classifier by varying a decision threshold.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/w/index.php?title=Information_retrieval&amp;oldid=793358396#Average_precision">average precision</a> (AP) from prediction scores. The value is between 0 and 1 and higher is better. AP is defined as</p> <div class="math notranslate nohighlight"> \[\text{AP} = \sum_n (R_n - R_{n-1}) P_n\]</div> <p>where <span class="math notranslate nohighlight">\(P_n\)</span> and <span class="math notranslate nohighlight">\(R_n\)</span> are the precision and recall at the nth threshold. With random predictions, the AP is the fraction of positive samples.</p> <p>References <a class="reference internal" href="#manning2008" id="id25"><span>[Manning2008]</span></a> and <a class="reference internal" href="#everingham2010" id="id26"><span>[Everingham2010]</span></a> present alternative variants of AP that interpolate the precision-recall curve. Currently, <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a> does not implement any interpolated variant. References <a class="reference internal" href="#davis2006" id="id27"><span>[Davis2006]</span></a> and <a class="reference internal" href="#flach2015" id="id28"><span>[Flach2015]</span></a> describe why a linear interpolation of points on the precision-recall curve provides an overly-optimistic measure of classifier performance. This linear interpolation is used when computing area under the curve with the trapezoidal rule in <a class="reference internal" href="generated/sklearn.metrics.auc.html#sklearn.metrics.auc" title="sklearn.metrics.auc"><code>auc</code></a>.</p> <p>Several functions allow you to analyze the precision, recall and F-measures score:</p> <div class="pst-scrollable-table-container">
<table class="autosummary longtable table autosummary">  <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a>(y_true, y_score, *)</p></td> <td><p>Compute average precision (AP) from prediction scores.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>f1_score</code></a>(y_true, y_pred, *[, labels, ...])</p></td> <td><p>Compute the F1 score, also known as balanced F-score or F-measure.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code>fbeta_score</code></a>(y_true, y_pred, *, beta[, ...])</p></td> <td><p>Compute the F-beta score.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a>(y_true[, y_score, ...])</p></td> <td><p>Compute precision-recall pairs for different probability thresholds.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code>precision_recall_fscore_support</code></a>(y_true, ...)</p></td> <td><p>Compute precision, recall, F-measure and support for each class.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code>precision_score</code></a>(y_true, y_pred, *[, labels, ...])</p></td> <td><p>Compute the precision.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code>recall_score</code></a>(y_true, y_pred, *[, labels, ...])</p></td> <td><p>Compute the recall.</p></td> </tr>  </table> </div> <p>Note that the <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a> function is restricted to the binary case. The <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a> function supports multiclass and multilabel formats by computing each class score in a One-vs-the-rest (OvR) fashion and averaging them or not depending of its <code>average</code> argument value.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.precisionrecalldisplay.html#sklearn.metrics.PrecisionRecallDisplay.from_estimator" title="sklearn.metrics.PrecisionRecallDisplay.from_estimator"><code>PrecisionRecallDisplay.from_estimator</code></a> and <a class="reference internal" href="generated/sklearn.metrics.precisionrecalldisplay.html#sklearn.metrics.PrecisionRecallDisplay.from_predictions" title="sklearn.metrics.PrecisionRecallDisplay.from_predictions"><code>PrecisionRecallDisplay.from_predictions</code></a> functions will plot the precision-recall curve as follows.</p> <a class="reference external image-reference" href="../auto_examples/model_selection/plot_precision_recall.html#plot-the-precision-recall-curve"><img alt="../_images/sphx_glr_plot_precision_recall_001.png" class="align-center" src="data:image/png;base64,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" style="width: 480.0px; height: 360.0px;"> </a> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_grid_search_digits.html#sphx-glr-auto-examples-model-selection-plot-grid-search-digits-py"><span class="std std-ref">Custom refit strategy of a grid search with cross-validation</span></a> for an example of <a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code>precision_score</code></a> and <a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code>recall_score</code></a> usage to estimate parameters using grid search with nested cross-validation.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_precision_recall.html#sphx-glr-auto-examples-model-selection-plot-precision-recall-py"><span class="std std-ref">Precision-Recall</span></a> for an example of <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a> usage to evaluate classifier output quality.</li> </ul> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="manning2008" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id25">Manning2008</a><span class="fn-bracket">]</span></span> <p>C.D. Manning, P. Raghavan, H. Schütze, <a class="reference external" href="https://nlp.stanford.edu/IR-book/html/htmledition/evaluation-of-ranked-retrieval-results-1.html">Introduction to Information Retrieval</a>, 2008.</p> </div> <div class="citation" id="everingham2010" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">Everingham2010</a><span class="fn-bracket">]</span></span> <p>M. Everingham, L. Van Gool, C.K.I. Williams, J. Winn, A. Zisserman, <a class="reference external" href="https://citeseerx.ist.psu.edu/doc_view/pid/b6bebfd529b233f00cb854b7d8070319600cf59d">The Pascal Visual Object Classes (VOC) Challenge</a>, IJCV 2010.</p> </div> <div class="citation" id="davis2006" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id27">Davis2006</a><span class="fn-bracket">]</span></span> <p>J. Davis, M. Goadrich, <a class="reference external" href="https://www.biostat.wisc.edu/~page/rocpr.pdf">The Relationship Between Precision-Recall and ROC Curves</a>, ICML 2006.</p> </div> <div class="citation" id="flach2015" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id28">Flach2015</a><span class="fn-bracket">]</span></span> <p>P.A. Flach, M. Kull, <a class="reference external" href="https://papers.nips.cc/paper/5867-precision-recall-gain-curves-pr-analysis-done-right.pdf">Precision-Recall-Gain Curves: PR Analysis Done Right</a>, NIPS 2015.</p> </div> </div> <section id="binary-classification"> <h4>
<span class="section-number">3.4.4.9.1. </span>Binary classification</h4> <p>In a binary classification task, the terms ‘’positive’’ and ‘’negative’’ refer to the classifier’s prediction, and the terms ‘’true’’ and ‘’false’’ refer to whether that prediction corresponds to the external judgment (sometimes known as the ‘’observation’’). Given these definitions, we can formulate the following table:</p> <div class="pst-scrollable-table-container">
<table class="table">  <tr>
<td></td> <td colspan="2"><p>Actual class (observation)</p></td> </tr> <tr>
<td rowspan="2"><p>Predicted class (expectation)</p></td> <td><p>tp (true positive) Correct result</p></td> <td><p>fp (false positive) Unexpected result</p></td> </tr> <tr>
<td><p>fn (false negative) Missing result</p></td> <td><p>tn (true negative) Correct absence of result</p></td> </tr>  </table> </div> <p>In this context, we can define the notions of precision and recall:</p> <div class="math notranslate nohighlight"> \[\text{precision} = \frac{\text{tp}}{\text{tp} + \text{fp}},\]</div> <div class="math notranslate nohighlight"> \[\text{recall} = \frac{\text{tp}}{\text{tp} + \text{fn}},\]</div> <p>(Sometimes recall is also called ‘’sensitivity’’)</p> <p>F-measure is the weighted harmonic mean of precision and recall, with precision’s contribution to the mean weighted by some parameter <span class="math notranslate nohighlight">\(\beta\)</span>:</p> <div class="math notranslate nohighlight"> \[F_\beta = (1 + \beta^2) \frac{\text{precision} \times \text{recall}}{\beta^2 \text{precision} + \text{recall}}\]</div> <p>To avoid division by zero when precision and recall are zero, Scikit-Learn calculates F-measure with this otherwise-equivalent formula:</p> <div class="math notranslate nohighlight"> \[F_\beta = \frac{(1 + \beta^2) \text{tp}}{(1 + \beta^2) \text{tp} + \text{fp} + \beta^2 \text{fn}}\]</div> <p>Note that this formula is still undefined when there are no true positives, false positives, or false negatives. By default, F-1 for a set of exclusively true negatives is calculated as 0, however this behavior can be changed using the <code>zero_division</code> parameter. Here are some small examples in binary classification:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; y_pred = [0, 1, 0, 0]
&gt;&gt;&gt; y_true = [0, 1, 0, 1]
&gt;&gt;&gt; metrics.precision_score(y_true, y_pred)
1.0
&gt;&gt;&gt; metrics.recall_score(y_true, y_pred)
0.5
&gt;&gt;&gt; metrics.f1_score(y_true, y_pred)
0.66...
&gt;&gt;&gt; metrics.fbeta_score(y_true, y_pred, beta=0.5)
0.83...
&gt;&gt;&gt; metrics.fbeta_score(y_true, y_pred, beta=1)
0.66...
&gt;&gt;&gt; metrics.fbeta_score(y_true, y_pred, beta=2)
0.55...
&gt;&gt;&gt; metrics.precision_recall_fscore_support(y_true, y_pred, beta=0.5)
(array([0.66..., 1.        ]), array([1. , 0.5]), array([0.71..., 0.83...]), array([2, 2]))


&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import precision_recall_curve
&gt;&gt;&gt; from sklearn.metrics import average_precision_score
&gt;&gt;&gt; y_true = np.array([0, 0, 1, 1])
&gt;&gt;&gt; y_scores = np.array([0.1, 0.4, 0.35, 0.8])
&gt;&gt;&gt; precision, recall, threshold = precision_recall_curve(y_true, y_scores)
&gt;&gt;&gt; precision
array([0.5       , 0.66..., 0.5       , 1.        , 1.        ])
&gt;&gt;&gt; recall
array([1. , 1. , 0.5, 0.5, 0. ])
&gt;&gt;&gt; threshold
array([0.1 , 0.35, 0.4 , 0.8 ])
&gt;&gt;&gt; average_precision_score(y_true, y_scores)
0.83...
</pre> </section> <section id="multiclass-and-multilabel-classification"> <h4>
<span class="section-number">3.4.4.9.2. </span>Multiclass and multilabel classification</h4> <p>In a multiclass and multilabel classification task, the notions of precision, recall, and F-measures can be applied to each label independently. There are a few ways to combine results across labels, specified by the <code>average</code> argument to the <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a>, <a class="reference internal" href="generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>f1_score</code></a>, <a class="reference internal" href="generated/sklearn.metrics.fbeta_score.html#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code>fbeta_score</code></a>, <a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code>precision_recall_fscore_support</code></a>, <a class="reference internal" href="generated/sklearn.metrics.precision_score.html#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code>precision_score</code></a> and <a class="reference internal" href="generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code>recall_score</code></a> functions, as described <a class="reference internal" href="#average"><span class="std std-ref">above</span></a>.</p> <p>Note the following behaviors when averaging:</p> <ul class="simple"> <li>If all labels are included, “micro”-averaging in a multiclass setting will produce precision, recall and <span class="math notranslate nohighlight">\(F\)</span> that are all identical to accuracy.</li> <li>“weighted” averaging may produce a F-score that is not between precision and recall.</li> <li>“macro” averaging for F-measures is calculated as the arithmetic mean over per-label/class F-measures, not the harmonic mean over the arithmetic precision and recall means. Both calculations can be seen in the literature but are not equivalent, see <a class="reference internal" href="#ob2019" id="id29"><span>[OB2019]</span></a> for details.</li> </ul> <p>To make this more explicit, consider the following notation:</p> <ul class="simple"> <li>
<span class="math notranslate nohighlight">\(y\)</span> the set of <em>true</em> <span class="math notranslate nohighlight">\((sample, label)\)</span> pairs</li> <li>
<span class="math notranslate nohighlight">\(\hat{y}\)</span> the set of <em>predicted</em> <span class="math notranslate nohighlight">\((sample, label)\)</span> pairs</li> <li>
<span class="math notranslate nohighlight">\(L\)</span> the set of labels</li> <li>
<span class="math notranslate nohighlight">\(S\)</span> the set of samples</li> <li>
<span class="math notranslate nohighlight">\(y_s\)</span> the subset of <span class="math notranslate nohighlight">\(y\)</span> with sample <span class="math notranslate nohighlight">\(s\)</span>, i.e. <span class="math notranslate nohighlight">\(y_s := \left\{(s', l) \in y | s' = s\right\}\)</span>
</li> <li>
<span class="math notranslate nohighlight">\(y_l\)</span> the subset of <span class="math notranslate nohighlight">\(y\)</span> with label <span class="math notranslate nohighlight">\(l\)</span>
</li> <li>similarly, <span class="math notranslate nohighlight">\(\hat{y}_s\)</span> and <span class="math notranslate nohighlight">\(\hat{y}_l\)</span> are subsets of <span class="math notranslate nohighlight">\(\hat{y}\)</span>
</li> <li>
<span class="math notranslate nohighlight">\(P(A, B) := \frac{\left| A \cap B \right|}{\left|B\right|}\)</span> for some sets <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>
</li> <li>
<span class="math notranslate nohighlight">\(R(A, B) := \frac{\left| A \cap B \right|}{\left|A\right|}\)</span> (Conventions vary on handling <span class="math notranslate nohighlight">\(A = \emptyset\)</span>; this implementation uses <span class="math notranslate nohighlight">\(R(A, B):=0\)</span>, and similar for <span class="math notranslate nohighlight">\(P\)</span>.)</li> <li><span class="math notranslate nohighlight">\(F_\beta(A, B) := \left(1 + \beta^2\right) \frac{P(A, B) \times R(A, B)}{\beta^2 P(A, B) + R(A, B)}\)</span></li> </ul> <p>Then the metrics are defined as:</p> <div class="pst-scrollable-table-container">
<table class="table"> <thead> <tr>
<th class="head"><p><code>average</code></p></th> <th class="head"><p>Precision</p></th> <th class="head"><p>Recall</p></th> <th class="head"><p>F_beta</p></th> </tr> </thead>  <tr>
<td><p><code>"micro"</code></p></td> <td><p><span class="math notranslate nohighlight">\(P(y, \hat{y})\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(R(y, \hat{y})\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(F_\beta(y, \hat{y})\)</span></p></td> </tr> <tr>
<td><p><code>"samples"</code></p></td> <td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|S\right|} \sum_{s \in S} P(y_s, \hat{y}_s)\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|S\right|} \sum_{s \in S} R(y_s, \hat{y}_s)\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|S\right|} \sum_{s \in S} F_\beta(y_s, \hat{y}_s)\)</span></p></td> </tr> <tr>
<td><p><code>"macro"</code></p></td> <td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|L\right|} \sum_{l \in L} P(y_l, \hat{y}_l)\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|L\right|} \sum_{l \in L} R(y_l, \hat{y}_l)\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(\frac{1}{\left|L\right|} \sum_{l \in L} F_\beta(y_l, \hat{y}_l)\)</span></p></td> </tr> <tr>
<td><p><code>"weighted"</code></p></td> <td><p><span class="math notranslate nohighlight">\(\frac{1}{\sum_{l \in L} \left|y_l\right|} \sum_{l \in L} \left|y_l\right| P(y_l, \hat{y}_l)\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(\frac{1}{\sum_{l \in L} \left|y_l\right|} \sum_{l \in L} \left|y_l\right| R(y_l, \hat{y}_l)\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(\frac{1}{\sum_{l \in L} \left|y_l\right|} \sum_{l \in L} \left|y_l\right| F_\beta(y_l, \hat{y}_l)\)</span></p></td> </tr> <tr>
<td><p><code>None</code></p></td> <td><p><span class="math notranslate nohighlight">\(\langle P(y_l, \hat{y}_l) | l \in L \rangle\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(\langle R(y_l, \hat{y}_l) | l \in L \rangle\)</span></p></td> <td><p><span class="math notranslate nohighlight">\(\langle F_\beta(y_l, \hat{y}_l) | l \in L \rangle\)</span></p></td> </tr>  </table> </div> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; y_true = [0, 1, 2, 0, 1, 2]
&gt;&gt;&gt; y_pred = [0, 2, 1, 0, 0, 1]
&gt;&gt;&gt; metrics.precision_score(y_true, y_pred, average='macro')
0.22...
&gt;&gt;&gt; metrics.recall_score(y_true, y_pred, average='micro')
0.33...
&gt;&gt;&gt; metrics.f1_score(y_true, y_pred, average='weighted')
0.26...
&gt;&gt;&gt; metrics.fbeta_score(y_true, y_pred, average='macro', beta=0.5)
0.23...
&gt;&gt;&gt; metrics.precision_recall_fscore_support(y_true, y_pred, beta=0.5, average=None)
(array([0.66..., 0.        , 0.        ]), array([1., 0., 0.]), array([0.71..., 0.        , 0.        ]), array([2, 2, 2]...))
</pre> <p>For multiclass classification with a “negative class”, it is possible to exclude some labels:</p> <pre data-language="python">&gt;&gt;&gt; metrics.recall_score(y_true, y_pred, labels=[1, 2], average='micro')
... # excluding 0, no labels were correctly recalled
0.0
</pre> <p>Similarly, labels not present in the data sample may be accounted for in macro-averaging.</p> <pre data-language="python">&gt;&gt;&gt; metrics.precision_score(y_true, y_pred, labels=[0, 1, 2, 3], average='macro')
0.166...
</pre> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="ob2019" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id29">OB2019</a><span class="fn-bracket">]</span></span> <p><a class="reference external" href="https://arxiv.org/abs/1911.03347">Opitz, J., &amp; Burst, S. (2019). “Macro f1 and macro f1.”</a></p> </div> </div> </section> </section> <section id="jaccard-similarity-coefficient-score"> <h3 id="jaccard-similarity-score">
<span class="section-number">3.4.4.10. </span>Jaccard similarity coefficient score</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.jaccard_score.html#sklearn.metrics.jaccard_score" title="sklearn.metrics.jaccard_score"><code>jaccard_score</code></a> function computes the average of <a class="reference external" href="https://en.wikipedia.org/wiki/Jaccard_index">Jaccard similarity coefficients</a>, also called the Jaccard index, between pairs of label sets.</p> <p>The Jaccard similarity coefficient with a ground truth label set <span class="math notranslate nohighlight">\(y\)</span> and predicted label set <span class="math notranslate nohighlight">\(\hat{y}\)</span>, is defined as</p> <div class="math notranslate nohighlight"> \[J(y, \hat{y}) = \frac{|y \cap \hat{y}|}{|y \cup \hat{y}|}.\]</div> <p>The <a class="reference internal" href="generated/sklearn.metrics.jaccard_score.html#sklearn.metrics.jaccard_score" title="sklearn.metrics.jaccard_score"><code>jaccard_score</code></a> (like <a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support.html#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code>precision_recall_fscore_support</code></a>) applies natively to binary targets. By computing it set-wise it can be extended to apply to multilabel and multiclass through the use of <code>average</code> (see <a class="reference internal" href="#average"><span class="std std-ref">above</span></a>).</p> <p>In the binary case:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import jaccard_score
&gt;&gt;&gt; y_true = np.array([[0, 1, 1],
...                    [1, 1, 0]])
&gt;&gt;&gt; y_pred = np.array([[1, 1, 1],
...                    [1, 0, 0]])
&gt;&gt;&gt; jaccard_score(y_true[0], y_pred[0])
0.6666...
</pre> <p>In the 2D comparison case (e.g. image similarity):</p> <pre data-language="python">&gt;&gt;&gt; jaccard_score(y_true, y_pred, average="micro")
0.6
</pre> <p>In the multilabel case with binary label indicators:</p> <pre data-language="python">&gt;&gt;&gt; jaccard_score(y_true, y_pred, average='samples')
0.5833...
&gt;&gt;&gt; jaccard_score(y_true, y_pred, average='macro')
0.6666...
&gt;&gt;&gt; jaccard_score(y_true, y_pred, average=None)
array([0.5, 0.5, 1. ])
</pre> <p>Multiclass problems are binarized and treated like the corresponding multilabel problem:</p> <pre data-language="python">&gt;&gt;&gt; y_pred = [0, 2, 1, 2]
&gt;&gt;&gt; y_true = [0, 1, 2, 2]
&gt;&gt;&gt; jaccard_score(y_true, y_pred, average=None)
array([1. , 0. , 0.33...])
&gt;&gt;&gt; jaccard_score(y_true, y_pred, average='macro')
0.44...
&gt;&gt;&gt; jaccard_score(y_true, y_pred, average='micro')
0.33...
</pre> </section> <section id="hinge-loss"> <h3 id="id30">
<span class="section-number">3.4.4.11. </span>Hinge loss</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code>hinge_loss</code></a> function computes the average distance between the model and the data using <a class="reference external" href="https://en.wikipedia.org/wiki/Hinge_loss">hinge loss</a>, a one-sided metric that considers only prediction errors. (Hinge loss is used in maximal margin classifiers such as support vector machines.)</p> <p>If the true label <span class="math notranslate nohighlight">\(y_i\)</span> of a binary classification task is encoded as <span class="math notranslate nohighlight">\(y_i=\left\{-1, +1\right\}\)</span> for every sample <span class="math notranslate nohighlight">\(i\)</span>; and <span class="math notranslate nohighlight">\(w_i\)</span> is the corresponding predicted decision (an array of shape (<code>n_samples</code>,) as output by the <code>decision_function</code> method), then the hinge loss is defined as:</p> <div class="math notranslate nohighlight"> \[L_\text{Hinge}(y, w) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} \max\left\{1 - w_i y_i, 0\right\}\]</div> <p>If there are more than two labels, <a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code>hinge_loss</code></a> uses a multiclass variant due to Crammer &amp; Singer. <a class="reference external" href="https://jmlr.csail.mit.edu/papers/volume2/crammer01a/crammer01a.pdf">Here</a> is the paper describing it.</p> <p>In this case the predicted decision is an array of shape (<code>n_samples</code>, <code>n_labels</code>). If <span class="math notranslate nohighlight">\(w_{i, y_i}\)</span> is the predicted decision for the true label <span class="math notranslate nohighlight">\(y_i\)</span> of the <span class="math notranslate nohighlight">\(i\)</span>-th sample; and <span class="math notranslate nohighlight">\(\hat{w}_{i, y_i} = \max\left\{w_{i, y_j}~|~y_j \ne y_i \right\}\)</span> is the maximum of the predicted decisions for all the other labels, then the multi-class hinge loss is defined by:</p> <div class="math notranslate nohighlight"> \[L_\text{Hinge}(y, w) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} \max\left\{1 + \hat{w}_{i, y_i} - w_{i, y_i}, 0\right\}\]</div> <p>Here is a small example demonstrating the use of the <a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code>hinge_loss</code></a> function with a svm classifier in a binary class problem:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import svm
&gt;&gt;&gt; from sklearn.metrics import hinge_loss
&gt;&gt;&gt; X = [[0], [1]]
&gt;&gt;&gt; y = [-1, 1]
&gt;&gt;&gt; est = svm.LinearSVC(random_state=0)
&gt;&gt;&gt; est.fit(X, y)
LinearSVC(random_state=0)
&gt;&gt;&gt; pred_decision = est.decision_function([[-2], [3], [0.5]])
&gt;&gt;&gt; pred_decision
array([-2.18...,  2.36...,  0.09...])
&gt;&gt;&gt; hinge_loss([-1, 1, 1], pred_decision)
0.3...
</pre> <p>Here is an example demonstrating the use of the <a class="reference internal" href="generated/sklearn.metrics.hinge_loss.html#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code>hinge_loss</code></a> function with a svm classifier in a multiclass problem:</p> <pre data-language="python">&gt;&gt;&gt; X = np.array([[0], [1], [2], [3]])
&gt;&gt;&gt; Y = np.array([0, 1, 2, 3])
&gt;&gt;&gt; labels = np.array([0, 1, 2, 3])
&gt;&gt;&gt; est = svm.LinearSVC()
&gt;&gt;&gt; est.fit(X, Y)
LinearSVC()
&gt;&gt;&gt; pred_decision = est.decision_function([[-1], [2], [3]])
&gt;&gt;&gt; y_true = [0, 2, 3]
&gt;&gt;&gt; hinge_loss(y_true, pred_decision, labels=labels)
0.56...
</pre> </section> <section id="log-loss"> <h3 id="id32">
<span class="section-number">3.4.4.12. </span>Log loss</h3> <p>Log loss, also called logistic regression loss or cross-entropy loss, is defined on probability estimates. It is commonly used in (multinomial) logistic regression and neural networks, as well as in some variants of expectation-maximization, and can be used to evaluate the probability outputs (<code>predict_proba</code>) of a classifier instead of its discrete predictions.</p> <p>For binary classification with a true label <span class="math notranslate nohighlight">\(y \in \{0,1\}\)</span> and a probability estimate <span class="math notranslate nohighlight">\(p = \operatorname{Pr}(y = 1)\)</span>, the log loss per sample is the negative log-likelihood of the classifier given the true label:</p> <div class="math notranslate nohighlight"> \[L_{\log}(y, p) = -\log \operatorname{Pr}(y|p) = -(y \log (p) + (1 - y) \log (1 - p))\]</div> <p>This extends to the multiclass case as follows. Let the true labels for a set of samples be encoded as a 1-of-K binary indicator matrix <span class="math notranslate nohighlight">\(Y\)</span>, i.e., <span class="math notranslate nohighlight">\(y_{i,k} = 1\)</span> if sample <span class="math notranslate nohighlight">\(i\)</span> has label <span class="math notranslate nohighlight">\(k\)</span> taken from a set of <span class="math notranslate nohighlight">\(K\)</span> labels. Let <span class="math notranslate nohighlight">\(P\)</span> be a matrix of probability estimates, with <span class="math notranslate nohighlight">\(p_{i,k} = \operatorname{Pr}(y_{i,k} = 1)\)</span>. Then the log loss of the whole set is</p> <div class="math notranslate nohighlight"> \[L_{\log}(Y, P) = -\log \operatorname{Pr}(Y|P) = - \frac{1}{N} \sum_{i=0}^{N-1} \sum_{k=0}^{K-1} y_{i,k} \log p_{i,k}\]</div> <p>To see how this generalizes the binary log loss given above, note that in the binary case, <span class="math notranslate nohighlight">\(p_{i,0} = 1 - p_{i,1}\)</span> and <span class="math notranslate nohighlight">\(y_{i,0} = 1 - y_{i,1}\)</span>, so expanding the inner sum over <span class="math notranslate nohighlight">\(y_{i,k} \in \{0,1\}\)</span> gives the binary log loss.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.log_loss.html#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><code>log_loss</code></a> function computes log loss given a list of ground-truth labels and a probability matrix, as returned by an estimator’s <code>predict_proba</code> method.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import log_loss
&gt;&gt;&gt; y_true = [0, 0, 1, 1]
&gt;&gt;&gt; y_pred = [[.9, .1], [.8, .2], [.3, .7], [.01, .99]]
&gt;&gt;&gt; log_loss(y_true, y_pred)
0.1738...
</pre> <p>The first <code>[.9, .1]</code> in <code>y_pred</code> denotes 90% probability that the first sample has label 0. The log loss is non-negative.</p> </section> <section id="matthews-correlation-coefficient"> <h3 id="matthews-corrcoef">
<span class="section-number">3.4.4.13. </span>Matthews correlation coefficient</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef.html#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><code>matthews_corrcoef</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Matthews_correlation_coefficient">Matthew’s correlation coefficient (MCC)</a> for binary classes. Quoting Wikipedia:</p>  <p>“The Matthews correlation coefficient is used in machine learning as a measure of the quality of binary (two-class) classifications. It takes into account true and false positives and negatives and is generally regarded as a balanced measure which can be used even if the classes are of very different sizes. The MCC is in essence a correlation coefficient value between -1 and +1. A coefficient of +1 represents a perfect prediction, 0 an average random prediction and -1 an inverse prediction. The statistic is also known as the phi coefficient.”</p>  <p>In the binary (two-class) case, <span class="math notranslate nohighlight">\(tp\)</span>, <span class="math notranslate nohighlight">\(tn\)</span>, <span class="math notranslate nohighlight">\(fp\)</span> and <span class="math notranslate nohighlight">\(fn\)</span> are respectively the number of true positives, true negatives, false positives and false negatives, the MCC is defined as</p> <div class="math notranslate nohighlight"> \[MCC = \frac{tp \times tn - fp \times fn}{\sqrt{(tp + fp)(tp + fn)(tn + fp)(tn + fn)}}.\]</div> <p>In the multiclass case, the Matthews correlation coefficient can be <a class="reference external" href="http://rk.kvl.dk/introduction/index.html">defined</a> in terms of a <a class="reference internal" href="generated/sklearn.metrics.confusion_matrix.html#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><code>confusion_matrix</code></a> <span class="math notranslate nohighlight">\(C\)</span> for <span class="math notranslate nohighlight">\(K\)</span> classes. To simplify the definition consider the following intermediate variables:</p> <ul class="simple"> <li>
<span class="math notranslate nohighlight">\(t_k=\sum_{i}^{K} C_{ik}\)</span> the number of times class <span class="math notranslate nohighlight">\(k\)</span> truly occurred,</li> <li>
<span class="math notranslate nohighlight">\(p_k=\sum_{i}^{K} C_{ki}\)</span> the number of times class <span class="math notranslate nohighlight">\(k\)</span> was predicted,</li> <li>
<span class="math notranslate nohighlight">\(c=\sum_{k}^{K} C_{kk}\)</span> the total number of samples correctly predicted,</li> <li>
<span class="math notranslate nohighlight">\(s=\sum_{i}^{K} \sum_{j}^{K} C_{ij}\)</span> the total number of samples.</li> </ul> <p>Then the multiclass MCC is defined as:</p> <div class="math notranslate nohighlight"> \[MCC = \frac{ c \times s - \sum_{k}^{K} p_k \times t_k }{\sqrt{ (s^2 - \sum_{k}^{K} p_k^2) \times (s^2 - \sum_{k}^{K} t_k^2) }}\]</div> <p>When there are more than two labels, the value of the MCC will no longer range between -1 and +1. Instead the minimum value will be somewhere between -1 and 0 depending on the number and distribution of ground true labels. The maximum value is always +1. For additional information, see <a class="reference internal" href="#wikipediamcc2021" id="id33"><span>[WikipediaMCC2021]</span></a>.</p> <p>Here is a small example illustrating the usage of the <a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef.html#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><code>matthews_corrcoef</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import matthews_corrcoef
&gt;&gt;&gt; y_true = [+1, +1, +1, -1]
&gt;&gt;&gt; y_pred = [+1, -1, +1, +1]
&gt;&gt;&gt; matthews_corrcoef(y_true, y_pred)
-0.33...
</pre> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="wikipediamcc2021" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id33">WikipediaMCC2021</a><span class="fn-bracket">]</span></span> <p>Wikipedia contributors. Phi coefficient. Wikipedia, The Free Encyclopedia. April 21, 2021, 12:21 CEST. Available at: <a class="reference external" href="https://en.wikipedia.org/wiki/Phi_coefficient">https://en.wikipedia.org/wiki/Phi_coefficient</a> Accessed April 21, 2021.</p> </div> </div> </section> <section id="multi-label-confusion-matrix"> <h3 id="multilabel-confusion-matrix">
<span class="section-number">3.4.4.14. </span>Multi-label confusion matrix</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.multilabel_confusion_matrix.html#sklearn.metrics.multilabel_confusion_matrix" title="sklearn.metrics.multilabel_confusion_matrix"><code>multilabel_confusion_matrix</code></a> function computes class-wise (default) or sample-wise (samplewise=True) multilabel confusion matrix to evaluate the accuracy of a classification. multilabel_confusion_matrix also treats multiclass data as if it were multilabel, as this is a transformation commonly applied to evaluate multiclass problems with binary classification metrics (such as precision, recall, etc.).</p> <p>When calculating class-wise multilabel confusion matrix <span class="math notranslate nohighlight">\(C\)</span>, the count of true negatives for class <span class="math notranslate nohighlight">\(i\)</span> is <span class="math notranslate nohighlight">\(C_{i,0,0}\)</span>, false negatives is <span class="math notranslate nohighlight">\(C_{i,1,0}\)</span>, true positives is <span class="math notranslate nohighlight">\(C_{i,1,1}\)</span> and false positives is <span class="math notranslate nohighlight">\(C_{i,0,1}\)</span>.</p> <p>Here is an example demonstrating the use of the <a class="reference internal" href="generated/sklearn.metrics.multilabel_confusion_matrix.html#sklearn.metrics.multilabel_confusion_matrix" title="sklearn.metrics.multilabel_confusion_matrix"><code>multilabel_confusion_matrix</code></a> function with <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-multilabel-indicator-matrix"><span class="xref std std-term">multilabel indicator matrix</span></a> input:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import multilabel_confusion_matrix
&gt;&gt;&gt; y_true = np.array([[1, 0, 1],
...                    [0, 1, 0]])
&gt;&gt;&gt; y_pred = np.array([[1, 0, 0],
...                    [0, 1, 1]])
&gt;&gt;&gt; multilabel_confusion_matrix(y_true, y_pred)
array([[[1, 0],
        [0, 1]],

       [[1, 0],
        [0, 1]],

       [[0, 1],
        [1, 0]]])
</pre> <p>Or a confusion matrix can be constructed for each sample’s labels:</p> <pre data-language="python">&gt;&gt;&gt; multilabel_confusion_matrix(y_true, y_pred, samplewise=True)
array([[[1, 0],
        [1, 1]],

       [[1, 1],
        [0, 1]]])
</pre> <p>Here is an example demonstrating the use of the <a class="reference internal" href="generated/sklearn.metrics.multilabel_confusion_matrix.html#sklearn.metrics.multilabel_confusion_matrix" title="sklearn.metrics.multilabel_confusion_matrix"><code>multilabel_confusion_matrix</code></a> function with <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-multiclass"><span class="xref std std-term">multiclass</span></a> input:</p> <pre data-language="python">&gt;&gt;&gt; y_true = ["cat", "ant", "cat", "cat", "ant", "bird"]
&gt;&gt;&gt; y_pred = ["ant", "ant", "cat", "cat", "ant", "cat"]
&gt;&gt;&gt; multilabel_confusion_matrix(y_true, y_pred,
...                             labels=["ant", "bird", "cat"])
array([[[3, 1],
        [0, 2]],

       [[5, 0],
        [1, 0]],

       [[2, 1],
        [1, 2]]])
</pre> <p>Here are some examples demonstrating the use of the <a class="reference internal" href="generated/sklearn.metrics.multilabel_confusion_matrix.html#sklearn.metrics.multilabel_confusion_matrix" title="sklearn.metrics.multilabel_confusion_matrix"><code>multilabel_confusion_matrix</code></a> function to calculate recall (or sensitivity), specificity, fall out and miss rate for each class in a problem with multilabel indicator matrix input.</p> <p>Calculating <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">recall</a> (also called the true positive rate or the sensitivity) for each class:</p> <pre data-language="python">&gt;&gt;&gt; y_true = np.array([[0, 0, 1],
...                    [0, 1, 0],
...                    [1, 1, 0]])
&gt;&gt;&gt; y_pred = np.array([[0, 1, 0],
...                    [0, 0, 1],
...                    [1, 1, 0]])
&gt;&gt;&gt; mcm = multilabel_confusion_matrix(y_true, y_pred)
&gt;&gt;&gt; tn = mcm[:, 0, 0]
&gt;&gt;&gt; tp = mcm[:, 1, 1]
&gt;&gt;&gt; fn = mcm[:, 1, 0]
&gt;&gt;&gt; fp = mcm[:, 0, 1]
&gt;&gt;&gt; tp / (tp + fn)
array([1. , 0.5, 0. ])
</pre> <p>Calculating <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">specificity</a> (also called the true negative rate) for each class:</p> <pre data-language="python">&gt;&gt;&gt; tn / (tn + fp)
array([1. , 0. , 0.5])
</pre> <p>Calculating <a class="reference external" href="https://en.wikipedia.org/wiki/False_positive_rate">fall out</a> (also called the false positive rate) for each class:</p> <pre data-language="python">&gt;&gt;&gt; fp / (fp + tn)
array([0. , 1. , 0.5])
</pre> <p>Calculating <a class="reference external" href="https://en.wikipedia.org/wiki/False_positives_and_false_negatives">miss rate</a> (also called the false negative rate) for each class:</p> <pre data-language="python">&gt;&gt;&gt; fn / (fn + tp)
array([0. , 0.5, 1. ])
</pre> </section> <section id="receiver-operating-characteristic-roc"> <h3 id="roc-metrics">
<span class="section-number">3.4.4.15. </span>Receiver operating characteristic (ROC)</h3> <p>The function <a class="reference internal" href="generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><code>roc_curve</code></a> computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">receiver operating characteristic curve, or ROC curve</a>. Quoting Wikipedia :</p>  <p>“A receiver operating characteristic (ROC), or simply ROC curve, is a graphical plot which illustrates the performance of a binary classifier system as its discrimination threshold is varied. It is created by plotting the fraction of true positives out of the positives (TPR = true positive rate) vs. the fraction of false positives out of the negatives (FPR = false positive rate), at various threshold settings. TPR is also known as sensitivity, and FPR is one minus the specificity or true negative rate.”</p>  <p>This function requires the true binary value and the target scores, which can either be probability estimates of the positive class, confidence values, or binary decisions. Here is a small example of how to use the <a class="reference internal" href="generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><code>roc_curve</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import roc_curve
&gt;&gt;&gt; y = np.array([1, 1, 2, 2])
&gt;&gt;&gt; scores = np.array([0.1, 0.4, 0.35, 0.8])
&gt;&gt;&gt; fpr, tpr, thresholds = roc_curve(y, scores, pos_label=2)
&gt;&gt;&gt; fpr
array([0. , 0. , 0.5, 0.5, 1. ])
&gt;&gt;&gt; tpr
array([0. , 0.5, 0.5, 1. , 1. ])
&gt;&gt;&gt; thresholds
array([ inf, 0.8 , 0.4 , 0.35, 0.1 ])
</pre> <p>Compared to metrics such as the subset accuracy, the Hamming loss, or the F1 score, ROC doesn’t require optimizing a threshold for each label.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a> function, denoted by ROC-AUC or AUROC, computes the area under the ROC curve. By doing so, the curve information is summarized in one number.</p> <p>The following figure shows the ROC curve and ROC-AUC score for a classifier aimed to distinguish the virginica flower from the rest of the species in the <a class="reference internal" href="https://scikit-learn.org/1.6/datasets/toy_dataset.html#iris-dataset"><span class="std std-ref">Iris plants dataset</span></a>:</p> <a class="reference external image-reference" href="../auto_examples/model_selection/plot_roc.html"><img alt="../_images/sphx_glr_plot_roc_001.png" class="align-center" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAMAAAACDyzWAAAArlBMVEX//////v5tbW2dnZ3/+vT39/fW1tYAAADx8fH/jAAKCgoEBATAwMAgICAnJydfX1+vr69/f38HBwcODg4uLi41NTTg4OD8/Pzq6upoZ2caGhpBQUGfn5+VlZXGxsbm5ubu7u709PTe3t6qqqpRUVFKSkrLy8sUFBS6urqFhYX6+vp5eXmQkJB0dHS1tbVZWVk9PDukpKTT09OKioqamprb29vQ0ND/9en/pjqnWwCiB//IAAAgAElEQVR42uydaXuiSBeGS20th31zAVxiC4IgIkEz7/z/P/bWqWK10+vVcTqT83xQQTat27PVISEEhUKhUCgUCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCoVAoFAqFQqFQKBQKhfrztAk8OQo2v7i3Qpmi8PCVY5tPzWuTbSh77pYv7I6OJDnHHV8Yry+27AUKjsVH1InOCqWY0fWvAnjcKKdIur36bkk/dwCMN3FGtYS93jpSGsep5ACOy5nsGkqRyy84Gh/Q/tEQiEhCuvlFAPfscUXNHwBwyR51CoYulLm5U+SQL8R8g8P8O+fa4XD99xTKYtjnwIJJn3M70qdsebB2LDuo8UmiHJ6erIwsjpplO6c+gBPqssdbHlkaWNJ6G/C6lCpdANe0YKjxzZlcemgXGo1NzYr8DflMV7AIcJv0ENjeiXJDm8nsSLFvSxcgd+l6VnSJcSjfpRbSrHo1kxZsmDUzPlk6oCFncaFF2+rdTJpyep7JUTbj+GT2ATzTklFoOwXzseytepv5kBqbzbQLYMaQI0d6FuvO9Ngu1Ep8OTsbadEHUE1jY2mlcM1eQEhBA+PMbWcYXRXD3MOlmDig701bmlevcsaHCRwR1xowzwyv5lJWvftMrwApozV07l1wMt5oGks2Qg9QG1pP7TZ9F7xNnvZSzg3fRKwDy9ks1Cr4uZh6AHK4Am8B1J7JLgLnvXDYBUnD+lJkBPDdAwgsXOmWpHSZMDHiBvDM2LsALmtAwY25TYP1A5EFU49xNpaHsArwaLbpAwi6JN8FMLcWrwD4IixmLCiMGfdMKd0R3z5uEhzJ/4gLXvKM4jOjQkhlS0zgfSckY8aNJKVDZf/A6ODhnULLg5JSZ8xYrlQ029xnwYc44AHft12wr5JXAFzyy/VyHogyK1lpTpZDlUr6FsfyP5GE1ACmdHMAPZMlPEH+kcLocz3ttWiXwPppFQMemcfeyTrf5bBstvkyCx74EAN+OwlpLOCW++JlB0D4DcBPgVnAtTgZt33ztRTiUL7bMgwM94KXYVoAN5yrHhaeQeO2eDjpJSGJFk2J7/Q8IWxz6rhXcfBbVXnZfL0MU9CReDGwAM1RF0AWBUAwQHZ2n9ogwqF8pxKF6As9kS6AxJWys1K4bXk6ph5kACRM90qhqkkPQLJnvnRiz1aKcfI72yjU3Rx6WTAzesoXhWjLNZR9U4jmWfDZLCAdKuOj0wWQXDyRohQ03yt70yVTpzwrpZVjEvJubWAQ1VNxHQDJaCZJqt5OsS08mvK84hJZqj7vl2FYCGlPyWfdk6PLsbtN6t3VAclS8sn9VNyJT8Wd7+uAZOpGUjjvAXilkgBaCSPZC/dk7Dq2pJk7LMOgUCgUCoVCoVAo1EdXYD2JF7m8XXVqwq1M2ltU6C91hd4slrIOCpb7euG198569aPHGKeqpbbFvSSa1dm38/WddPUn1ifqCZF4rM5Vm+lUCshyM35li3m/C3Bat678JOhQT06paygrvT8l4fg/eoyhXMbrWbucVTXsmH4Dm9vLz4C5spfIxEO18MSIrnvTrb+9r3MCUyRj3sXFzvmLAEb5/UFFJ05u3VMzHnz3YK8BOGZW9YhMPFYpfYanmbcQ5WXfUS5STuaBZOcHmOrnLlgNz46ljRoXvAkjSx0y+6Jrkhc+NzBdBNQBI9qRJC1tjBdMkSxp2jq7o2ZFOgNHFQ0NZA6tqiWwWe+5dDUp8jsO35vdcXWJYLblyWKnO4S25YjO61iP6LjpQeWgLU6OZc8M9qKE085rAJlTlz33iX9Aw4FWQlcdIBMP1Y0OuTFJq/kNP/LWirLTonWcqS2AnlbEAbDHAYxlZ6WMYG4r2ytGINXTuaIf+UwNUtBhHF/rPjyicuOl2eVEjO8ilMx45Glj8qI6m80LWXrRNR5C00Gz58TdK2e9E3KaNOtf+4idCIx3TBTrso91uNwV9dzzftH0oHLQdOb7z8cTzPIN42vkLcX6QSibcSk5Y/iA6kg5wIThMzLxWPlgRjIgRwDI+wmER3ZbAC1mNcaRWwGoqp1ocZFoNRiiHzlnRxza3XMsefMqOTBzZ4fFACgDdA4QgAoXnEILDDvhrb/nIvGDJvoMtI4J5ZGCFFTGW+NdDiE349zPNz2oAJpS7yfuCzjAIqyP+WXtYepYlW/V73GNSDxWBd2z0OdCagD5+Oe2yHgbAHmkOAsFgDd6bD2pzFxok1ZAJ2jVjZcbbWT2UnWvJHEaSjQcsONDs2gC3VsCwJlGKiLbPdeOxY6t1QcJZ+MjzOXO61YYRpG8Jc9s3Y2WcDhow1pxtNseVAAtpVUv4JpjTrSZWJ/x6eMBtGCrVSI9vWMc9eYa2yExeF+nAJAPuHicdGJAvtYXAG7gtiER29E0PhzaPAL6kXk3HhldZDqrm7PaHZg19Jl19atmUb8GUOWPcyC73rOk7nlzCOtk4QA9DUBgITetpXBbQMZbwyop7ENwxpoeVADNlavA7kjn9aeD9bpM6nOr1W8ouXfzqDeXK28De9cA6LxqAXsAthbQ5v7O89ukOue3hXAHeZ5Zc/KlYzMYNXkkmkUn9xbw2u4p3riojaUGnEtqap0+P01LIp+HsOJ40xpAUveg/qgFrADcUkyDH60DzWQ+ph0Av4gBewASVatiQIgKmdlrKymppdBri1pV20n4rUvJsjJDBaOpqS4KXkUMOKS3dk9w+Mx51wA+i3tTjtTuFCJLmnHjqjVBQAug6EEVMaBZx4DDfgx4amLAsLapBhLxaDlU4NAB8IssuA8gz4JXDAjdOsVl1FpAZus83o3nDvfK3mnKuj7EmEtJL5RzZmk7lgVH5jle6QYcYg9t/Z5XZcHNniY147WnNvU6lwb7+KR6dNjJbmRqw29BscJCMY5BDWDbg9pkwXH5zSy4ArCUnxCIR+tUBfodAHkdMIB6yqsAkk1oWyqzak96JF0Uv1NLvghDtfIjy8ubksYI4rakDFXL0jIY4qR0LElzmcGbh3ZVB5R5HbDZM8k8a2a0BePBaCZZTrkru2FaUN0u8sJ29/xrDWDbg9rWAS9nXgeUo/zVOmB1+XjnyB+kKmb/HZlOVL6Tqij+/YQ/Q+t1zJyl/vuOF72LP9ui+zj0f4ZGjiSr5u+7m3txfA8zDMnxhkOPQqFQKBQKhUKhUH+WlNBr54uUmaViAxHqkTqnRgPgZ2k4ucp7/FJQD1UDYAaTaO4Mv5GvafDpbTX44ABeYGLekEXBeDxlWuI9DV3+/vfXW+qfvz59cAA16F7bVO1u4i/cThG7Vp/elL8L/QcB7AAIFnCOAN4B+PebuV+X0iu64I4LBk0RwDsA38xGHWl7cwomIQjgwwHcah+Uv93LCz29zEmqQxkmm4y6ZRgE8GEAkvEH/VLF/93QRe+a4vQL0QjgQwAcDAv8cl8VAvgIAAdDKn/GbxcB/JcAZPx93PwDAfzXAUT+EMD/s3evW4krWxiGkwiEnUDCKSBB5CCInAQUcN//le0E6Va77d5iE2al8n5jNKN1rfUneVaqZlGZJQkQfwAUBVjBHwBln4D4A6AUQJNjXwH4NSmHr2tfzgzQtMZ5ri0AvyDl5z6s3Fn92bROAOAXx97X/Nc8rz/mfwD8IsCXc29Zxh8AJctf/AFQFODOwR8ABQEapRuuKwCFAJpNrikA5QCa1mTPRQWgFMC4/mAHKgClAFL/AlASIP4AKAkQfwAUBZhf408rgEn3Czr7NphBBVcaAUy4X9BbzgLQfMSUZgBzF/J3lm0w0fyvCirtAL5cYhA+kz/mfxoCTEtPM/wBEH8AzCxA/AFQNF38AVA0BTwBUGr+99wHEwAl64+AV9ABSP0LwCwCxB8A8QfAzAKs4k8zgGZSG6WSyS7En1YAf9uApfoccIAjrQDmktgoldT/LEs2AOoI8CUlR5xG9UethyL9ALL/BYAAxB8A8QdAAP4pG/wBUDItH38AFBt/W9Ef/ABQbP63aqEHgJL1Rwk9AKT+BWAGAeJPV4BmKva/4E9XgMmcl3X2PNXwpyfAXBr2v0R5xJ+2AF+U3//C5hetAaq//hLuUANAyfqD8xcASP0LwCwCxB8A8QfAzAIcNPAHQMn0K4ABoNT4y+aXb6dbrgU/Lt+m4YT+NQC/Mf/rIul7uXO3Bct5PUC5ZC+GpcYIgNQfl0vQjj68+eHvz+XoYxECEH8Xy8yNp87W+vDDbe3R7K3bygA0c2noQ4S/f0nPvo0+p95xPHZce3RsJpsvFotNUYC/nwOXw5/WAAvh8/6h4b/+k6odRxJg7j+p6ENUxd+5huDV6FCJ9BR5Av52Dpyi+7D2MDpTETJaxRNBu6fIHDAN+68WdP/7x9y5V4dlmHk08t643eFtEBgA/Pr8r8MLwP+Y40K034n+vvCccNUDIPWHIgEg/gCIPwAC8JPM8QdAyewn+AOg6NUBCACl5n9LNgACULT+qF/DQyOAH/e9qH4MF/WvbgB/3/eichsi/GkHMPcHf0puf8GflgBfPhuEldz+ssWfjgBzqbko+RH+ACg2/pqcvwBAyfmfBT8AitYft7AAIPUvADMIEH8AxB8AMwvwHn8AFM0GfwAUG3/7aACg5PzP4wQQAIrWH3dwACD1LwAzCBB/AMQfADMLsO/hD4CS6VF/AFBs/L1HAQBF538cfwlA6g8AZhIg/gCIPwBmFSD+ACgNEH8AlBTI+0f6AzQVbUNkbvPc/gwAfOtKpBbAaPgd8QJwBgDm1GxDRP2RIYAv6rUhwl+WALL+QgD4IUv8JZbZw7Zo9AYA/FtKdfwllKbnuEPDagPwr6H/eFIZrWbO0Ch5APzj/G/O6b8JZlIwIoBDB4B/rj8mnD+TXOoHgKUJAKl/RbJqRwAHHR+A+BNJz/PcYOJdAxB/MslfWe0TvmbPFsAu/pJOaRZ/zkoA/CyDDv4Sjn0YfK9tAP4+/kZ/Wgi5CMBdHYC/z/+q8Eg6o5E9HkUpjwH4Sf3BCnTS8X175ft+e0oVTP0rk+rgtH8/IwDxp2qyARB/l8vdKGhEAeD7lPB3qSwcq9bu1OcA/JAu/i4UbxNvRqhaAHwbf9n8csE4TWOyN3bshnk3/2v0cXGxlO+NYGs8sBD9vv6o4OJi8atG1+nU2Y5F/SuT1iwqhK3F7MMMvFwLfuxOyM/LtfJVZgDiTyjvT526c7cFK5obHjIKHob3t1kBiD8hflbt3U9B/Iqc97ow81jvJzAEv/Yf+jyiXYl6If4umv5qEi5aVSd413d75sZzcGt9+KHdmYfe8rhfNV8sFptnAPjWf+jzCA7BOxqQXzTtcNmwx50P21F7djziTl9f1BzXxveP5WOJUrXj/DvA3N/9SXUlMp8AcemUH4yh/csi9AeAnVrkrWLnz/oE/Nl/6PNI+bNqj4i4cNyo+HB++R//wxDsl6OPgr076xyQ/kPkmHg/tDP85Zfvi5CtM3h7AuoMEH8yAMejkXvYE/1hGebqsAwzj6Z+g3BUKHltQ3eA+JOJ/zPvf3tciPY78fDbccJlXneA+EtN9ATY8vEHQFGBJW4tAKXG3w1v/wJQdP7nc/4CAKk/SBYB4k86m3XYNBaVjALEn3S6k6kzNG46lwGo3DlwnL8gHa8Sfxf3dJmXktQ7B+6xhj/Z1JoxwF3tIgAVPAeuBwEVnoCL4FIAFToHzqzuuP/iuQrvnM3U2VwKoFLrL+EAAOLZlm07/PpESBuA1L/K5PqUc6h0AYg/RXLqPEgTgPhTJQ076GbwCfiMP1XyNC+7480gYwD7Af7UyW17Us8YQGPGbVcn+2VYyxBA0+pyz9XJcOq5nW0xOwDj+qPAfVclgd14PuXrqNQDpP5VK/MT+1F8E6Ay22Dwl/J8D6Ay22Dwp1SWA2N5TLIAldkG84g/ldLpG51jEgeoyDaYKf6yOAQrsv6S5/4pF//gaeBnAKBprdl+pVyOB1a7+gPk/AUVB9SivSsWi/2bUHuA1L9KPv+Ocae6A8SfkimV7EqpVLr9+nchKQWIP1XTPHFhJKUAmxP8KZh9y9gfo/sQvOf8BTVL4B+zQJ0Bmrx+qe742zxGY4Cm5dB+UpukD2Bcf9xw41TNzaNhLOtrfZ+A1L9qx3swbp3teKQrQPwpHqdpLP3Eu2OJAcSf6pnsjcaNsXM0BTgb40/trALfuTYqDV2H4PwD91jp9K1RVIZUtfwu2KzQ/V67pAhgNP+zuGHqPwKf/fZzUUOA1B+pyP0kHI3Cyb12APGXjqz9WVQr+mvdAOIvJakdulQUtFuGwV9KMjksUzxotxC9cfGXiljhXbO5CS3dABpD7m0qMrNqtl2z8joBNKec/pGiDJ72J7wueyLA16ZEl+1KFNUfHq+gpwRfO5ysTmkRfSLAt6ZElwNI/ZuiLJ22NRklB/BnU6LLdSXCX5pS3hjGvdtKEuBrU6Ic/sgncePZeq2ZJMALV79T/KUph84wzlAjgD0Pf2kCOB6NRm78oQtAg/o3TfF/RgeApsXb59pHYYBR/eHy/QcApQBS/wJQEiD+ACgJEH8apVuuBW/dVG7dRgoAVvCnTe7cbcFyfqxOF8vjNAA0l/hLZzbrsGksKu9+E7SjD29+/Gk1ryoP0OTw1fQOt5OpMzRu3h1UM3Njjdb69aerYKY8QNMas/yc1niV+Ku4971hevZt9Dn1Dj/sJjvjJ8B8sVhsqgcwrj/of5DW1JoxwF3tc4CtoGu8AaweeqmqBpD6V4Mn4CL4fAju267r2rb7oO4TEH/pzlV452ymzubzIqT1FKXtPQ2UnQPiL+3Zlm07/HAL79yrwzLM/LhDQekiZOfgL+25/vWlkONCtN9JAUCjRP/nTEUpgGaTG5L2lI9JI0DTmuy5gynPIsrzajJNIUDOX9An3RTuiKb+1SjDeuoA4k+nPKduDog/TdKIE7rbtAHMr/GnRapxugXj3ADNpJsSDR65eRpkdnNiJ7MvAnzrSpQEQBN82sRpJgIwl2RTomj+V+XOaZJOJSmAL0k1JaL+0Cl35e7tPsr5AbL+Qv5v/KJ9TGoA4k+n2NfNY1IDEH96ATz1vxAH2MUfAEXngAVum0YA6z+SCoDm8zX3TC+Ai5tj0gAwqj8CXkFnCJYCSP0LQEmA+AOgJED8EVGAVfwRSYC7Mv6I5BxwwMUnQgDNJRsAiRzAqP6ocQIwkQJI/UskAeKPSALEHxEFuMEfkQTY8vFHpACaregPF50IATStVYtLTqQAxvVHiUtOhABS/xJJgPgj3wF4rq5E+CPfAXi2rkRPNfyR0wGeryvRI/7ItwCeoSuRyeYX8m2A51h/CXdcaiIFMK4/NlxqIgSQ+pdIAsQfkQSIPyIKcNDAH5EcgvsVrjIRAmiy+YUIAozmf10uMZECSP1BJAHij0gCxB+RBIg/IvsErOKPiM4B91xdIgTQXND9j8gBjOZ/HV4AJlIAqT+IJED8EUmA+COiAOf4I5IA9xP8Eck5YJGrSj6kW64Fx415lc6kHjwkBtBcsgGQ/Jo7d1uwnObh79bz/W7u7hMCGNUfdU4AJr8kaEcf3vztF171KwBP70pE/Us+ycytxI++9f/YO9MuRXkmDAcdhQOyCLiAC4oguK/4nuf//7E3CatrK6DO6an7Q0/rdJd0eVmVhEoleaJjRmXKNY7j2vcAfL0rEfAHuiWLHeKvMyl54uBFabLJEnF3c+9rXYmAP9BTAO74eBLyMAK+3JXoCPyBnkjBE/7soEDuAYCvrb/MHeAP9OMkZKcq6A0AMgycvwC6o4lQpcswCxnzJwwsy+LKBpCpVAA/0D1FC9FyD6EenXfIJQNI5h9D8DMoh8oAEOa/oG8CCPyBvgkg8Af6KoBT4A/01RS8A/5A3wKQGYELQd8DkKlIcAII6GsAkvnHBHwI+hKAMP8FfRNA4A/0TQCBP9BXARxJwB/omynYgvkH6FsAMlNwHeh7AOLxHxx/CfoagDD/AH0TwMf8dWqgW4KOnWUB+JA/xqqDbsuCXQulAPg4/ln1LgS7m+rW4bZ5WQA+yL916A1zT906ZOFyUvCD/Ue1eg18Cr7JB2DYjSjW7a5EzLEGTgYA3wJg2o3oflcinH4dBpwMAL4DwD+X/F13Jfp5/S+nk5v65TMNdpQ+kJ1XDYrLPJexMN7gYecAAD4L4P/OknAO/vI6eXw1dZlnFy240fOm+tprANps0q7T0mzyz5B1Mx8BnTRTPDmeKhnBHROZDrRIpjv/SSeopaSalRrpmc0BgE8CWLz+qqCT58X/oB8AZOb3AZy5IUNhO9kMgGvV9e3hanPbZLYDLeIsy2p7TdKEZ2f7ZgU/1RoAgKUAuHri/ttrTj6aZGHClWkKlp2ZKaKhrrYUzAR5+/uaL/GuFabgzkFUzRm+CokXFxFFLdJxqSs00EBSPSdK3VhNJM5k3jySqLbRPMeO07rfEhoMNqRPEBptcFSrIvLzvfD/dUrKWKtvmmcAjiPbd+LwVQdahcU0VojR1ZaML7YAYCkADrWf7/9SJ59Pp6+U5taR6odfKIC8vN9z3qa+lmIAhd50Km1CAFdaP2hgpGZDW/EOce7DtgZmZyrs2qcw5s2XmmWNkegNghlbR2NJ3tc30jwCUPeD7kLy7b7aQBV9avsKmrK+FZI1CvvbVFtoTeymACrnjW8MPlIY9K460CKXsLfTpsiW8CcGx88aAFgGgOiJNWbq5KvpzN3JtSOHYZAC6GFMBl6NtLqMAGQD8gwFkFOP6a8dWtEF4eCHtiukaNxlCsbYMt4AVSWM0jxqydlgMSpjldAkb0jgPU/BJ5YStV2iuednATywZ7GvG0QKsb7qQGsJtFByKQiskbELABYBkFk8d/rviwBOtBraVsJZMGneFSauUwwgT/MZBXDKRnl0svV41YtjjUEB4nRvsxufAXgI2TEEEqrYQQSgRRo5kGcEHOZ4fTXMAjhkySesLuAfqmweAHihKwBn5JOEGt5xr5gklwc4EgOAxQDE8w+PexrAp1MwqmlKm51GADpXAGopgPsIwKEwmwZNLfr9nTefkRWcub8SpdHlJIQA2KKxikuXdoZsgzyDg1K3v1FXGQADEnDxSFfAoUsdYVLbkaXXUjAjVWggXZHr4zsx2ABgAQCfr/971cmyc5BQBkCagqs3AKzxYQo+iOS3YgDHvEKHWeRbygF5z7MAHjPJOQSQUzOltEcNB7C4uLujYQtz77DHkgbYMxOaT9eXk5CLFHw5CWmwe/osBVDFAFZNmIQUA/CF+tNXneyrFKAEQM6T6750A0DUxJOQYRUpwi5YejGAaKOTOLVentqD8H3H8cbvjhMAx1KvYTcq7RRAtPD6wWnQR00l2LstPECcxR1jHcyMotIHC3xBhqjYw56OMVME17en95dhwg60tAUtvqRwgNrUdrZPhqJIlgHAQgC+Uv/8qpM7Jk2tCYB0GWaHB01XAHZmoiCSZRiP3ywTANcsSX2Nnsbr8RYpwyPLMBGAyJI9VTQyKRgxS0nw3AYetfF0geZoxsswPp4OueFa4BTHxVpT4kWZ1lBNn1qIpqNYLgrV86aomsaIDDOGAGAhAAcv1N+X4uSd8J13imm9Y6PLoIcAwEIAjnvP7/8o7OR+w1bMzZeccXoHgMc6AFgAQDJlfaGOsrCTD6IqVsa/0tUAYA4AmUoTnAwAfg1AMv84gZMBwC8B+Pr+X3Ay+KY8AHPsPwcng29KAzBP/wNwMvimNAAbOfpvgJPBN+Wl4EEVnAwAfglAhvusk0mp3vPqaw/+M93P5EvlbQVf6x0A8HMAMhW9+wknWxVRNV3/TQCGt9ZqmlZLGacFX8nL3jbQUsVB8skgIo/0HQD4MQDJ/EP5gJNtU5oEe1KR9Q4AhyF4u+12dw5g+rI3L4qv1I9CXNvA9i3LInaWLQDwUwDm7//3opNdk951w8CwR4eXMCEdWVQlUsoiOwfTM+bY5Mokm4dQ3eW9TTcDoIIDVXOONuTO8dyroni3UQJgJSzj6x3DeoAUwPRlb2lFwDRal2ODdlyTDQC+G8AC/ScjJ49D1W59m/npETtLMp25Cyr8CM2bU3vHT0jRqVFfk9KmjanY/gRZ3qJ+6vVSAH2tb/tiE635Mdn4w6F4t1ECoE73LgXqaKTaWQAzL0sjZFzhHOVYskcAKcI8vjCvNaDDP68PAH4EwCL9TyMns6FIbR0ffkvI8eh3mZ+epomXXWBA2XX4wMChSxbxu+5sUMCGQ7WmS6NQkAC4JRTtTBz8MDgbJ91tlACoUaIW2JizyAI4Pc/3XFzhHHmClsgO2aiZ2mx4OvAUWL0JAH4EQMvM33/3NQCHGQDJmEvDMWbQ8siWISS7IS2TKBS54faidQIgr+LHKjtGhktK89PdRgmAKrHZMfHXCdmAnAA4fDzgPAeQ6ECHnHSXBwD4gRQc7Io6OUcKVkIAJ+rgFBiZPUpxLnQdGqXGCYDqgT7RQUOhu/Pm6W6jBEC6M31NNhkJBFyNplBs96UUjBIapQMA+H4Amf0nnZyZhEQA0lWSXgZAO0rBC2l+PgveyvGUSVy6Rma3UQKgS0hyNmSTEU7RqEUeMvrqchJymYLPJyFEA7K1vCb4AODbAWQq6vqDTqbrIfWllAK41PxgoWV3acp4EtIgkxBnavtyJ52ECM19fbKgbJIN6sluowRAsnDSFejf4wtdElyDk0F2D6Uve3sZZlWvkmUYBf+ActwHR42g2+DHAOC7ASx8/kKuhWinkQJYkzXNWGQBjJdhAkfjpQqTLsP4W15rkSxbZ0krjWS3UQLgiK/j4RsNnHPSzWPS0jx3evaytxcS9XAhus+SGyA8ry+JDaNo7zYA8GcAC5//8Xc5eVViv7+uZwOA7wbQKHz+zN/lZG5W3r3gaeGT8QDAnwDcFj//CJwMvskPYKv4+VvgZPBNgRTsg5MBwC8ByOx+7g8ITgbfvAtApsJuygAQTkp6MI/+Z09KynZxPyu2TAAk63/HMgCEs+LgrAVLHcoAAATnSURBVLgrZbu4nxdbxgDS9edSUjCclgmnZV4p20Dx6j4nATC8/1EOgHBeMJwXfKGzFrJXlR4YQJp/7x0OBwIVHZVlm2if1brVOI5rs9yf/4T/7h0OBwK9D8AmLRDl/tw/HA4EemMKJhGQ6zLMn9qdw+FAoHdPQujMlQN9Sv/ihzzu4k6auCfFlmcrpCzoU/on1+mjhWjaxD0utkRni9HtUj7d7ZLslGboL7wgDjLytbiS3FKWHbggABDebwAQAIQL+kdUa9b+KjtwQSAQCAQCgUAgEAgEeoMe1erntKP0PK3ll3FBCA0FvQQ7tYWoitUSDO103pTz3UpruGbaEq6Ip3+XHtbq57RTOUyDhXAqfkEIcaKrl2DHafn2dFjcUINd2g3dyWVnvVASAIt4+pfpxzKZHHaopCYqwdBm0dSL21lro3I8dBDxl6WZ11QCYBFP/y49rtXPaYeoYw6KXxCqtuY5ATyzY/QWprSqFTc0VNeMtTUKA1jA079M90ulC9ihscLrFr+gwAvQ/9s71+ZEYTCMZu1IOuEigtegIqJoKYo3+P8/bZMgbal23AV3Zqd9zoe2U8xlyJk3JiShpoCVfFbOKtqZneYZkZDpdBk3FrDBnYaAfyTggW2aV2jYF1H0EQJ6zrMIOLTdOCONn/JNrwMB//cuOGS7B1RoLo92prTWsbiVCnXkVzftcrp+k4zkKb9iJOI3FRBd8L8dhBwc+xEVGsqTncfWMWhaobM8WbdmBKxktEwbRS4MQm5NMtxZq18jn4M+9X3/uXmFJN1e83wCvtQMa9w8o4k+Xcz69cQJ8pwmefM7/d24t1a/Rj6e2vnQeUCFGghYyUfzGN+2H5BRYjGe1guAxuWuNL7TAAAAAAAAAAAAAAAAAGqj3j/4F5jJ5Y/as9XgZ9NRTweyewJOxIf48vpFgaPg8nw1+Grtl0y5Xh0bSA6+tYArXzC8K6Dr+4bVu3nE9/s+i69SRp4ZQ0BwU8Bie8Wpx/g4KOTIPeb2I0Jme4e3gg/SHKhGpqZuyXeid7m4qLpgU4Q4U3bBG2dOimVTVyltenwrQz2R7ZJ4y1nfQANAQPUrMRYbuVhF6tJLtSzMyZEl2axc+llqZOvT7KQbJHR3g+isBBzRiT+SAg7XT0T8OF+nnKdC3bKMOBExMSDp3shOToYW+OkC6oyxQsJwXejiToorcvGUcVnCJ/8/6PNY7cZYrsjJit8GIaoLloMQ+WZ1GQarKSljlJbb2MoySKaW9HmvaIGfLqCXZZlPDI8zhwZKjq7uvYjIZDlCTSZDV6mR6JeVnIlJBpyP7fiTgJGQSkbUako3086mtO1jGSSk8jN6ihZAFywYOK1Z9kTnl+iUeI5NrFYmiUuNFvJLXSkgadstvo+rAhLr1HZD8jmlvLr/XEaoa5lSH0BAqYMY376UcgjSFUm9G1MnZRcs0WikBFTripWA3X7oio73OuWza7+XcWCqC8YABLwJmNNkceCFgO2WMZiZW5KzcZ7ZraqA5SBk8nRcvLKREtAa+/NCwIyqoceNlNver7cyZnQzEoMQ015Epx1aAAKqUTBnq0MhYJzKGRYRyCKPsd5LVcByGsbuu0wePiMFtC3dvDwJ6Rdx7TrlQITJsgwyXstpmK6p8+URLQAAAAAAAAAAAAAAAAAAAAAAAAAA8AB+A7dqtUxjbObaAAAAAElFTkSuQmCC" style="width: 480.0px; height: 360.0px;"> </a> <p>For more information see the <a class="reference external" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve">Wikipedia article on AUC</a>.</p> <section id="binary-case"> <h4 id="roc-auc-binary">
<span class="section-number">3.4.4.15.1. </span>Binary case</h4> <p>In the <strong>binary case</strong>, you can either provide the probability estimates, using the <code>classifier.predict_proba()</code> method, or the non-thresholded decision values given by the <code>classifier.decision_function()</code> method. In the case of providing the probability estimates, the probability of the class with the “greater label” should be provided. The “greater label” corresponds to <code>classifier.classes_[1]</code> and thus <code>classifier.predict_proba(X)[:, 1]</code>. Therefore, the <code>y_score</code> parameter is of size (n_samples,).</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import load_breast_cancer
&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression
&gt;&gt;&gt; from sklearn.metrics import roc_auc_score
&gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True)
&gt;&gt;&gt; clf = LogisticRegression(solver="liblinear").fit(X, y)
&gt;&gt;&gt; clf.classes_
array([0, 1])
</pre> <p>We can use the probability estimates corresponding to <code>clf.classes_[1]</code>.</p> <pre data-language="python">&gt;&gt;&gt; y_score = clf.predict_proba(X)[:, 1]
&gt;&gt;&gt; roc_auc_score(y, y_score)
0.99...
</pre> <p>Otherwise, we can use the non-thresholded decision values</p> <pre data-language="python">&gt;&gt;&gt; roc_auc_score(y, clf.decision_function(X))
0.99...
</pre> </section> <section id="multi-class-case"> <h4 id="roc-auc-multiclass">
<span class="section-number">3.4.4.15.2. </span>Multi-class case</h4> <p>The <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a> function can also be used in <strong>multi-class classification</strong>. Two averaging strategies are currently supported: the one-vs-one algorithm computes the average of the pairwise ROC AUC scores, and the one-vs-rest algorithm computes the average of the ROC AUC scores for each class against all other classes. In both cases, the predicted labels are provided in an array with values from 0 to <code>n_classes</code>, and the scores correspond to the probability estimates that a sample belongs to a particular class. The OvO and OvR algorithms support weighting uniformly (<code>average='macro'</code>) and by prevalence (<code>average='weighted'</code>).</p> <details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="one-vs-one-algorithm"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">One-vs-one Algorithm</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">Computes the average AUC of all possible pairwise combinations of classes. <a class="reference internal" href="#ht2001" id="id34"><span>[HT2001]</span></a> defines a multiclass AUC metric weighted uniformly:</p> <div class="math notranslate nohighlight"> \[\frac{1}{c(c-1)}\sum_{j=1}^{c}\sum_{k &gt; j}^c (\text{AUC}(j | k) + \text{AUC}(k | j))\]</div> <p class="sd-card-text">where <span class="math notranslate nohighlight">\(c\)</span> is the number of classes and <span class="math notranslate nohighlight">\(\text{AUC}(j | k)\)</span> is the AUC with class <span class="math notranslate nohighlight">\(j\)</span> as the positive class and class <span class="math notranslate nohighlight">\(k\)</span> as the negative class. In general, <span class="math notranslate nohighlight">\(\text{AUC}(j | k) \neq \text{AUC}(k | j))\)</span> in the multiclass case. This algorithm is used by setting the keyword argument <code>multiclass</code> to <code>'ovo'</code> and <code>average</code> to <code>'macro'</code>.</p> <p class="sd-card-text">The <a class="reference internal" href="#ht2001" id="id35"><span>[HT2001]</span></a> multiclass AUC metric can be extended to be weighted by the prevalence:</p> <div class="math notranslate nohighlight"> \[\frac{1}{c(c-1)}\sum_{j=1}^{c}\sum_{k &gt; j}^c p(j \cup k)( \text{AUC}(j | k) + \text{AUC}(k | j))\]</div> <p class="sd-card-text">where <span class="math notranslate nohighlight">\(c\)</span> is the number of classes. This algorithm is used by setting the keyword argument <code>multiclass</code> to <code>'ovo'</code> and <code>average</code> to <code>'weighted'</code>. The <code>'weighted'</code> option returns a prevalence-weighted average as described in <a class="reference internal" href="#fc2009" id="id36"><span>[FC2009]</span></a>.</p> </div> </details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="one-vs-rest-algorithm"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">One-vs-rest Algorithm</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">Computes the AUC of each class against the rest <a class="reference internal" href="#pd2000" id="id37"><span>[PD2000]</span></a>. The algorithm is functionally the same as the multilabel case. To enable this algorithm set the keyword argument <code>multiclass</code> to <code>'ovr'</code>. Additionally to <code>'macro'</code> <a class="reference internal" href="#f2006" id="id38"><span>[F2006]</span></a> and <code>'weighted'</code> <a class="reference internal" href="#f2001" id="id39"><span>[F2001]</span></a> averaging, OvR supports <code>'micro'</code> averaging.</p> <p class="sd-card-text">In applications where a high false positive rate is not tolerable the parameter <code>max_fpr</code> of <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a> can be used to summarize the ROC curve up to the given limit.</p> <p class="sd-card-text">The following figure shows the micro-averaged ROC curve and its corresponding ROC-AUC score for a classifier aimed to distinguish the different species in the <a class="reference internal" href="https://scikit-learn.org/1.6/datasets/toy_dataset.html#iris-dataset"><span class="std std-ref">Iris plants dataset</span></a>:</p> <a class="reference external image-reference" href="../auto_examples/model_selection/plot_roc.html"><img alt="../_images/sphx_glr_plot_roc_002.png" class="align-center" src="data:image/png;base64,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" style="width: 480.0px; height: 360.0px;"> </a> </div> </details></section> <section id="multi-label-case"> <h4 id="roc-auc-multilabel">
<span class="section-number">3.4.4.15.3. </span>Multi-label case</h4> <p>In <strong>multi-label classification</strong>, the <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a> function is extended by averaging over the labels as <a class="reference internal" href="#average"><span class="std std-ref">above</span></a>. In this case, you should provide a <code>y_score</code> of shape <code>(n_samples, n_classes)</code>. Thus, when using the probability estimates, one needs to select the probability of the class with the greater label for each output.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import make_multilabel_classification
&gt;&gt;&gt; from sklearn.multioutput import MultiOutputClassifier
&gt;&gt;&gt; X, y = make_multilabel_classification(random_state=0)
&gt;&gt;&gt; inner_clf = LogisticRegression(solver="liblinear", random_state=0)
&gt;&gt;&gt; clf = MultiOutputClassifier(inner_clf).fit(X, y)
&gt;&gt;&gt; y_score = np.transpose([y_pred[:, 1] for y_pred in clf.predict_proba(X)])
&gt;&gt;&gt; roc_auc_score(y, y_score, average=None)
array([0.82..., 0.86..., 0.94..., 0.85... , 0.94...])
</pre> <p>And the decision values do not require such processing.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.linear_model import RidgeClassifierCV
&gt;&gt;&gt; clf = RidgeClassifierCV().fit(X, y)
&gt;&gt;&gt; y_score = clf.decision_function(X)
&gt;&gt;&gt; roc_auc_score(y, y_score, average=None)
array([0.81..., 0.84... , 0.93..., 0.87..., 0.94...])
</pre> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_roc.html#sphx-glr-auto-examples-model-selection-plot-roc-py"><span class="std std-ref">Multiclass Receiver Operating Characteristic (ROC)</span></a> for an example of using ROC to evaluate the quality of the output of a classifier.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_roc_crossval.html#sphx-glr-auto-examples-model-selection-plot-roc-crossval-py"><span class="std std-ref">Receiver Operating Characteristic (ROC) with cross validation</span></a> for an example of using ROC to evaluate classifier output quality, using cross-validation.</li> <li>See <a class="reference internal" href="../auto_examples/applications/plot_species_distribution_modeling.html#sphx-glr-auto-examples-applications-plot-species-distribution-modeling-py"><span class="std std-ref">Species distribution modeling</span></a> for an example of using ROC to model species distribution.</li> </ul> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="ht2001" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>HT2001<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id34">1</a>,<a role="doc-backlink" href="#id35">2</a>)</span> <p>Hand, D.J. and Till, R.J., (2001). <a class="reference external" href="http://link.springer.com/article/10.1023/A:1010920819831">A simple generalisation of the area under the ROC curve for multiple class classification problems.</a> Machine learning, 45(2), pp. 171-186.</p> </div> <div class="citation" id="fc2009" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id36">FC2009</a><span class="fn-bracket">]</span></span> <p>Ferri, Cèsar &amp; Hernandez-Orallo, Jose &amp; Modroiu, R. (2009). <a class="reference external" href="https://www.math.ucdavis.edu/~saito/data/roc/ferri-class-perf-metrics.pdf">An Experimental Comparison of Performance Measures for Classification.</a> Pattern Recognition Letters. 30. 27-38.</p> </div> <div class="citation" id="pd2000" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id37">PD2000</a><span class="fn-bracket">]</span></span> <p>Provost, F., Domingos, P. (2000). <a class="reference external" href="https://fosterprovost.com/publication/well-trained-pets-improving-probability-estimation-trees/">Well-trained PETs: Improving probability estimation trees</a> (Section 6.2), CeDER Working Paper #IS-00-04, Stern School of Business, New York University.</p> </div> <div class="citation" id="f2006" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id38">F2006</a><span class="fn-bracket">]</span></span> <p>Fawcett, T., 2006. <a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S016786550500303X">An introduction to ROC analysis.</a> Pattern Recognition Letters, 27(8), pp. 861-874.</p> </div> <div class="citation" id="f2001" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id39">F2001</a><span class="fn-bracket">]</span></span> <p>Fawcett, T., 2001. <a class="reference external" href="https://ieeexplore.ieee.org/document/989510/">Using rule sets to maximize ROC performance</a> In Data Mining, 2001. Proceedings IEEE International Conference, pp. 131-138.</p> </div> </div> </section> </section> <section id="detection-error-tradeoff-det"> <h3 id="det-curve">
<span class="section-number">3.4.4.16. </span>Detection error tradeoff (DET)</h3> <p>The function <a class="reference internal" href="generated/sklearn.metrics.det_curve.html#sklearn.metrics.det_curve" title="sklearn.metrics.det_curve"><code>det_curve</code></a> computes the detection error tradeoff curve (DET) curve <a class="reference internal" href="#wikipediadet2017" id="id40"><span>[WikipediaDET2017]</span></a>. Quoting Wikipedia:</p>  <p>“A detection error tradeoff (DET) graph is a graphical plot of error rates for binary classification systems, plotting false reject rate vs. false accept rate. The x- and y-axes are scaled non-linearly by their standard normal deviates (or just by logarithmic transformation), yielding tradeoff curves that are more linear than ROC curves, and use most of the image area to highlight the differences of importance in the critical operating region.”</p>  <p>DET curves are a variation of receiver operating characteristic (ROC) curves where False Negative Rate is plotted on the y-axis instead of True Positive Rate. DET curves are commonly plotted in normal deviate scale by transformation with <span class="math notranslate nohighlight">\(\phi^{-1}\)</span> (with <span class="math notranslate nohighlight">\(\phi\)</span> being the cumulative distribution function). The resulting performance curves explicitly visualize the tradeoff of error types for given classification algorithms. See <a class="reference internal" href="#martin1997" id="id41"><span>[Martin1997]</span></a> for examples and further motivation.</p> <p>This figure compares the ROC and DET curves of two example classifiers on the same classification task:</p> <a class="reference external image-reference" href="../auto_examples/model_selection/plot_det.html"><img alt="../_images/sphx_glr_plot_det_001.png" class="align-center" src="data:image/png;base64,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" style="width: 825.0px; height: 375.0px;"> </a> <details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="properties"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">Properties</span></summary><div class="sd-summary-content sd-card-body docutils"> <ul class="simple"> <li>DET curves form a linear curve in normal deviate scale if the detection scores are normally (or close-to normally) distributed. It was shown by <a class="reference internal" href="#navratil2007" id="id42"><span>[Navratil2007]</span></a> that the reverse is not necessarily true and even more general distributions are able to produce linear DET curves.</li> <li>The normal deviate scale transformation spreads out the points such that a comparatively larger space of plot is occupied. Therefore curves with similar classification performance might be easier to distinguish on a DET plot.</li> <li>With False Negative Rate being “inverse” to True Positive Rate the point of perfection for DET curves is the origin (in contrast to the top left corner for ROC curves).</li> </ul> </div> </details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="applications-and-limitations"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">Applications and limitations</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">DET curves are intuitive to read and hence allow quick visual assessment of a classifier’s performance. Additionally DET curves can be consulted for threshold analysis and operating point selection. This is particularly helpful if a comparison of error types is required.</p> <p class="sd-card-text">On the other hand DET curves do not provide their metric as a single number. Therefore for either automated evaluation or comparison to other classification tasks metrics like the derived area under ROC curve might be better suited.</p> </div> </details><h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_det.html#sphx-glr-auto-examples-model-selection-plot-det-py"><span class="std std-ref">Detection error tradeoff (DET) curve</span></a> for an example comparison between receiver operating characteristic (ROC) curves and Detection error tradeoff (DET) curves.</li> </ul> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="wikipediadet2017" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id40">WikipediaDET2017</a><span class="fn-bracket">]</span></span> <p>Wikipedia contributors. Detection error tradeoff. Wikipedia, The Free Encyclopedia. September 4, 2017, 23:33 UTC. Available at: <a class="reference external" href="https://en.wikipedia.org/w/index.php?title=Detection_error_tradeoff&amp;oldid=798982054">https://en.wikipedia.org/w/index.php?title=Detection_error_tradeoff&amp;oldid=798982054</a>. Accessed February 19, 2018.</p> </div> <div class="citation" id="martin1997" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id41">Martin1997</a><span class="fn-bracket">]</span></span> <p>A. Martin, G. Doddington, T. Kamm, M. Ordowski, and M. Przybocki, <a class="reference external" href="https://ccc.inaoep.mx/~villasen/bib/martin97det.pdf">The DET Curve in Assessment of Detection Task Performance</a>, NIST 1997.</p> </div> <div class="citation" id="navratil2007" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id42">Navratil2007</a><span class="fn-bracket">]</span></span> <p>J. Navractil and D. Klusacek, <a class="reference external" href="https://ieeexplore.ieee.org/document/4218079">“On Linear DETs”</a>, 2007 IEEE International Conference on Acoustics, Speech and Signal Processing - ICASSP ‘07, Honolulu, HI, 2007, pp. IV-229-IV-232.</p> </div> </div> </section> <section id="zero-one-loss"> <h3 id="id43">
<span class="section-number">3.4.4.17. </span>Zero one loss</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.zero_one_loss.html#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><code>zero_one_loss</code></a> function computes the sum or the average of the 0-1 classification loss (<span class="math notranslate nohighlight">\(L_{0-1}\)</span>) over <span class="math notranslate nohighlight">\(n_{\text{samples}}\)</span>. By default, the function normalizes over the sample. To get the sum of the <span class="math notranslate nohighlight">\(L_{0-1}\)</span>, set <code>normalize</code> to <code>False</code>.</p> <p>In multilabel classification, the <a class="reference internal" href="generated/sklearn.metrics.zero_one_loss.html#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><code>zero_one_loss</code></a> scores a subset as one if its labels strictly match the predictions, and as a zero if there are any errors. By default, the function returns the percentage of imperfectly predicted subsets. To get the count of such subsets instead, set <code>normalize</code> to <code>False</code></p> <p>If <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> is the predicted value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value, then the 0-1 loss <span class="math notranslate nohighlight">\(L_{0-1}\)</span> is defined as:</p> <div class="math notranslate nohighlight"> \[L_{0-1}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} 1(\hat{y}_i \not= y_i)\]</div> <p>where <span class="math notranslate nohighlight">\(1(x)\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">indicator function</a>. The zero one loss can also be computed as <span class="math notranslate nohighlight">\(zero-one loss = 1 - accuracy\)</span>.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import zero_one_loss
&gt;&gt;&gt; y_pred = [1, 2, 3, 4]
&gt;&gt;&gt; y_true = [2, 2, 3, 4]
&gt;&gt;&gt; zero_one_loss(y_true, y_pred)
0.25
&gt;&gt;&gt; zero_one_loss(y_true, y_pred, normalize=False)
1.0
</pre> <p>In the multilabel case with binary label indicators, where the first label set [0,1] has an error:</p> <pre data-language="python">&gt;&gt;&gt; zero_one_loss(np.array([[0, 1], [1, 1]]), np.ones((2, 2)))
0.5

&gt;&gt;&gt; zero_one_loss(np.array([[0, 1], [1, 1]]), np.ones((2, 2)),  normalize=False)
1.0
</pre> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/feature_selection/plot_rfe_with_cross_validation.html#sphx-glr-auto-examples-feature-selection-plot-rfe-with-cross-validation-py"><span class="std std-ref">Recursive feature elimination with cross-validation</span></a> for an example of zero one loss usage to perform recursive feature elimination with cross-validation.</li> </ul> </section> <section id="brier-score-loss"> <h3 id="id45">
<span class="section-number">3.4.4.18. </span>Brier score loss</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.brier_score_loss.html#sklearn.metrics.brier_score_loss" title="sklearn.metrics.brier_score_loss"><code>brier_score_loss</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Brier_score">Brier score</a> for binary classes <a class="reference internal" href="#brier1950" id="id46"><span>[Brier1950]</span></a>. Quoting Wikipedia:</p>  <p>“The Brier score is a proper score function that measures the accuracy of probabilistic predictions. It is applicable to tasks in which predictions must assign probabilities to a set of mutually exclusive discrete outcomes.”</p>  <p>This function returns the mean squared error of the actual outcome <span class="math notranslate nohighlight">\(y \in \{0,1\}\)</span> and the predicted probability estimate <span class="math notranslate nohighlight">\(p = \operatorname{Pr}(y = 1)\)</span> (<a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-predict_proba"><span class="xref std std-term">predict_proba</span></a>) as outputted by:</p> <div class="math notranslate nohighlight"> \[BS = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}} - 1}(y_i - p_i)^2\]</div> <p>The Brier score loss is also between 0 to 1 and the lower the value (the mean square difference is smaller), the more accurate the prediction is.</p> <p>Here is a small example of usage of this function:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import brier_score_loss
&gt;&gt;&gt; y_true = np.array([0, 1, 1, 0])
&gt;&gt;&gt; y_true_categorical = np.array(["spam", "ham", "ham", "spam"])
&gt;&gt;&gt; y_prob = np.array([0.1, 0.9, 0.8, 0.4])
&gt;&gt;&gt; y_pred = np.array([0, 1, 1, 0])
&gt;&gt;&gt; brier_score_loss(y_true, y_prob)
0.055
&gt;&gt;&gt; brier_score_loss(y_true, 1 - y_prob, pos_label=0)
0.055
&gt;&gt;&gt; brier_score_loss(y_true_categorical, y_prob, pos_label="ham")
0.055
&gt;&gt;&gt; brier_score_loss(y_true, y_prob &gt; 0.5)
0.0
</pre> <p>The Brier score can be used to assess how well a classifier is calibrated. However, a lower Brier score loss does not always mean a better calibration. This is because, by analogy with the bias-variance decomposition of the mean squared error, the Brier score loss can be decomposed as the sum of calibration loss and refinement loss <a class="reference internal" href="#bella2012" id="id47"><span>[Bella2012]</span></a>. Calibration loss is defined as the mean squared deviation from empirical probabilities derived from the slope of ROC segments. Refinement loss can be defined as the expected optimal loss as measured by the area under the optimal cost curve. Refinement loss can change independently from calibration loss, thus a lower Brier score loss does not necessarily mean a better calibrated model. “Only when refinement loss remains the same does a lower Brier score loss always mean better calibration” <a class="reference internal" href="#bella2012" id="id48"><span>[Bella2012]</span></a>, <a class="reference internal" href="#flach2008" id="id49"><span>[Flach2008]</span></a>.</p> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/calibration/plot_calibration.html#sphx-glr-auto-examples-calibration-plot-calibration-py"><span class="std std-ref">Probability calibration of classifiers</span></a> for an example of Brier score loss usage to perform probability calibration of classifiers.</li> </ul> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="brier1950" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id46">Brier1950</a><span class="fn-bracket">]</span></span> <p>G. Brier, <a class="reference external" href="ftp://ftp.library.noaa.gov/docs.lib/htdocs/rescue/mwr/078/mwr-078-01-0001.pdf.html">Verification of forecasts expressed in terms of probability</a>, Monthly weather review 78.1 (1950)</p> </div> <div class="citation" id="bella2012" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>Bella2012<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id47">1</a>,<a role="doc-backlink" href="#id48">2</a>)</span> <p>Bella, Ferri, Hernández-Orallo, and Ramírez-Quintana <a class="reference external" href="http://dmip.webs.upv.es/papers/BFHRHandbook2010.pdf">“Calibration of Machine Learning Models”</a> in Khosrow-Pour, M. “Machine learning: concepts, methodologies, tools and applications.” Hershey, PA: Information Science Reference (2012).</p> </div> <div class="citation" id="flach2008" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id49">Flach2008</a><span class="fn-bracket">]</span></span> <p>Flach, Peter, and Edson Matsubara. <a class="reference external" href="https://drops.dagstuhl.de/opus/volltexte/2008/1382/">“On classification, ranking, and probability estimation.”</a> Dagstuhl Seminar Proceedings. Schloss Dagstuhl-Leibniz-Zentrum fr Informatik (2008).</p> </div> </div> </section> <section id="class-likelihood-ratios"> <h3 id="id50">
<span class="section-number">3.4.4.19. </span>Class likelihood ratios</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.class_likelihood_ratios.html#sklearn.metrics.class_likelihood_ratios" title="sklearn.metrics.class_likelihood_ratios"><code>class_likelihood_ratios</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Likelihood_ratios_in_diagnostic_testing">positive and negative likelihood ratios</a> <span class="math notranslate nohighlight">\(LR_\pm\)</span> for binary classes, which can be interpreted as the ratio of post-test to pre-test odds as explained below. As a consequence, this metric is invariant w.r.t. the class prevalence (the number of samples in the positive class divided by the total number of samples) and <strong>can be extrapolated between populations regardless of any possible class imbalance.</strong></p> <p>The <span class="math notranslate nohighlight">\(LR_\pm\)</span> metrics are therefore very useful in settings where the data available to learn and evaluate a classifier is a study population with nearly balanced classes, such as a case-control study, while the target application, i.e. the general population, has very low prevalence.</p> <p>The positive likelihood ratio <span class="math notranslate nohighlight">\(LR_+\)</span> is the probability of a classifier to correctly predict that a sample belongs to the positive class divided by the probability of predicting the positive class for a sample belonging to the negative class:</p> <div class="math notranslate nohighlight"> \[LR_+ = \frac{\text{PR}(P+|T+)}{\text{PR}(P+|T-)}.\]</div> <p>The notation here refers to predicted (<span class="math notranslate nohighlight">\(P\)</span>) or true (<span class="math notranslate nohighlight">\(T\)</span>) label and the sign <span class="math notranslate nohighlight">\(+\)</span> and <span class="math notranslate nohighlight">\(-\)</span> refer to the positive and negative class, respectively, e.g. <span class="math notranslate nohighlight">\(P+\)</span> stands for “predicted positive”.</p> <p>Analogously, the negative likelihood ratio <span class="math notranslate nohighlight">\(LR_-\)</span> is the probability of a sample of the positive class being classified as belonging to the negative class divided by the probability of a sample of the negative class being correctly classified:</p> <div class="math notranslate nohighlight"> \[LR_- = \frac{\text{PR}(P-|T+)}{\text{PR}(P-|T-)}.\]</div> <p>For classifiers above chance <span class="math notranslate nohighlight">\(LR_+\)</span> above 1 <strong>higher is better</strong>, while <span class="math notranslate nohighlight">\(LR_-\)</span> ranges from 0 to 1 and <strong>lower is better</strong>. Values of <span class="math notranslate nohighlight">\(LR_\pm\approx 1\)</span> correspond to chance level.</p> <p>Notice that probabilities differ from counts, for instance <span class="math notranslate nohighlight">\(\operatorname{PR}(P+|T+)\)</span> is not equal to the number of true positive counts <code>tp</code> (see <a class="reference external" href="https://en.wikipedia.org/wiki/Likelihood_ratios_in_diagnostic_testing">the wikipedia page</a> for the actual formulas).</p> <h4 class="rubric">Examples</h4> <ul class="simple"> <li><a class="reference internal" href="../auto_examples/model_selection/plot_likelihood_ratios.html#sphx-glr-auto-examples-model-selection-plot-likelihood-ratios-py"><span class="std std-ref">Class Likelihood Ratios to measure classification performance</span></a></li> </ul> <details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="interpretation-across-varying-prevalence"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">Interpretation across varying prevalence</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">Both class likelihood ratios are interpretable in terms of an odds ratio (pre-test and post-tests):</p> <div class="math notranslate nohighlight"> \[\text{post-test odds} = \text{Likelihood ratio} \times \text{pre-test odds}.\]</div> <p class="sd-card-text">Odds are in general related to probabilities via</p> <div class="math notranslate nohighlight"> \[\text{odds} = \frac{\text{probability}}{1 - \text{probability}},\]</div> <p class="sd-card-text">or equivalently</p> <div class="math notranslate nohighlight"> \[\text{probability} = \frac{\text{odds}}{1 + \text{odds}}.\]</div> <p class="sd-card-text">On a given population, the pre-test probability is given by the prevalence. By converting odds to probabilities, the likelihood ratios can be translated into a probability of truly belonging to either class before and after a classifier prediction:</p> <div class="math notranslate nohighlight"> \[\text{post-test odds} = \text{Likelihood ratio} \times \frac{\text{pre-test probability}}{1 - \text{pre-test probability}},\]</div> <div class="math notranslate nohighlight"> \[\text{post-test probability} = \frac{\text{post-test odds}}{1 + \text{post-test odds}}.\]</div> </div> </details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="mathematical-divergences"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">Mathematical divergences</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">The positive likelihood ratio is undefined when <span class="math notranslate nohighlight">\(fp = 0\)</span>, which can be interpreted as the classifier perfectly identifying positive cases. If <span class="math notranslate nohighlight">\(fp = 0\)</span> and additionally <span class="math notranslate nohighlight">\(tp = 0\)</span>, this leads to a zero/zero division. This happens, for instance, when using a <code>DummyClassifier</code> that always predicts the negative class and therefore the interpretation as a perfect classifier is lost.</p> <p class="sd-card-text">The negative likelihood ratio is undefined when <span class="math notranslate nohighlight">\(tn = 0\)</span>. Such divergence is invalid, as <span class="math notranslate nohighlight">\(LR_- &gt; 1\)</span> would indicate an increase in the odds of a sample belonging to the positive class after being classified as negative, as if the act of classifying caused the positive condition. This includes the case of a <code>DummyClassifier</code> that always predicts the positive class (i.e. when <span class="math notranslate nohighlight">\(tn=fn=0\)</span>).</p> <p class="sd-card-text">Both class likelihood ratios are undefined when <span class="math notranslate nohighlight">\(tp=fn=0\)</span>, which means that no samples of the positive class were present in the testing set. This can also happen when cross-validating highly imbalanced data.</p> <p class="sd-card-text">In all the previous cases the <a class="reference internal" href="generated/sklearn.metrics.class_likelihood_ratios.html#sklearn.metrics.class_likelihood_ratios" title="sklearn.metrics.class_likelihood_ratios"><code>class_likelihood_ratios</code></a> function raises by default an appropriate warning message and returns <code>nan</code> to avoid pollution when averaging over cross-validation folds.</p> <p class="sd-card-text">For a worked-out demonstration of the <a class="reference internal" href="generated/sklearn.metrics.class_likelihood_ratios.html#sklearn.metrics.class_likelihood_ratios" title="sklearn.metrics.class_likelihood_ratios"><code>class_likelihood_ratios</code></a> function, see the example below.</p> </div> </details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="references"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">References</span></summary><div class="sd-summary-content sd-card-body docutils"> <ul class="simple"> <li><a class="reference external" href="https://en.wikipedia.org/wiki/Likelihood_ratios_in_diagnostic_testing">Wikipedia entry for Likelihood ratios in diagnostic testing</a></li> <li>Brenner, H., &amp; Gefeller, O. (1997). Variation of sensitivity, specificity, likelihood ratios and predictive values with disease prevalence. Statistics in medicine, 16(9), 981-991.</li> </ul> </div> </details></section> <section id="d2-score-for-classification"> <h3 id="d2-score-classification">
<span class="section-number">3.4.4.20. </span>D² score for classification</h3> <p>The D² score computes the fraction of deviance explained. It is a generalization of R², where the squared error is generalized and replaced by a classification deviance of choice <span class="math notranslate nohighlight">\(\text{dev}(y, \hat{y})\)</span> (e.g., Log loss). D² is a form of a <em>skill score</em>. It is calculated as</p> <div class="math notranslate nohighlight"> \[D^2(y, \hat{y}) = 1 - \frac{\text{dev}(y, \hat{y})}{\text{dev}(y, y_{\text{null}})} \,.\]</div> <p>Where <span class="math notranslate nohighlight">\(y_{\text{null}}\)</span> is the optimal prediction of an intercept-only model (e.g., the per-class proportion of <code>y_true</code> in the case of the Log loss).</p> <p>Like R², the best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts <span class="math notranslate nohighlight">\(y_{\text{null}}\)</span>, disregarding the input features, would get a D² score of 0.0.</p> <details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="d2-log-loss-score"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">D2 log loss score</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">The <a class="reference internal" href="generated/sklearn.metrics.d2_log_loss_score.html#sklearn.metrics.d2_log_loss_score" title="sklearn.metrics.d2_log_loss_score"><code>d2_log_loss_score</code></a> function implements the special case of D² with the log loss, see <a class="reference internal" href="#log-loss"><span class="std std-ref">Log loss</span></a>, i.e.:</p> <div class="math notranslate nohighlight"> \[\text{dev}(y, \hat{y}) = \text{log_loss}(y, \hat{y}).\]</div> <p class="sd-card-text">Here are some usage examples of the <a class="reference internal" href="generated/sklearn.metrics.d2_log_loss_score.html#sklearn.metrics.d2_log_loss_score" title="sklearn.metrics.d2_log_loss_score"><code>d2_log_loss_score</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import d2_log_loss_score
&gt;&gt;&gt; y_true = [1, 1, 2, 3]
&gt;&gt;&gt; y_pred = [
...    [0.5, 0.25, 0.25],
...    [0.5, 0.25, 0.25],
...    [0.5, 0.25, 0.25],
...    [0.5, 0.25, 0.25],
... ]
&gt;&gt;&gt; d2_log_loss_score(y_true, y_pred)
0.0
&gt;&gt;&gt; y_true = [1, 2, 3]
&gt;&gt;&gt; y_pred = [
...     [0.98, 0.01, 0.01],
...     [0.01, 0.98, 0.01],
...     [0.01, 0.01, 0.98],
... ]
&gt;&gt;&gt; d2_log_loss_score(y_true, y_pred)
0.981...
&gt;&gt;&gt; y_true = [1, 2, 3]
&gt;&gt;&gt; y_pred = [
...     [0.1, 0.6, 0.3],
...     [0.1, 0.6, 0.3],
...     [0.4, 0.5, 0.1],
... ]
&gt;&gt;&gt; d2_log_loss_score(y_true, y_pred)
-0.552...
</pre> </div> </details></section> </section> <section id="multilabel-ranking-metrics"> <h2 id="id51">
<span class="section-number">3.4.5. </span>Multilabel ranking metrics</h2> <p>In multilabel learning, each sample can have any number of ground truth labels associated with it. The goal is to give high scores and better rank to the ground truth labels.</p> <section id="coverage-error"> <h3 id="id52">
<span class="section-number">3.4.5.1. </span>Coverage error</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.coverage_error.html#sklearn.metrics.coverage_error" title="sklearn.metrics.coverage_error"><code>coverage_error</code></a> function computes the average number of labels that have to be included in the final prediction such that all true labels are predicted. This is useful if you want to know how many top-scored-labels you have to predict in average without missing any true one. The best value of this metrics is thus the average number of true labels.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Our implementation’s score is 1 greater than the one given in Tsoumakas et al., 2010. This extends it to handle the degenerate case in which an instance has 0 true labels.</p> </div> <p>Formally, given a binary indicator matrix of the ground truth labels <span class="math notranslate nohighlight">\(y \in \left\{0, 1\right\}^{n_\text{samples} \times n_\text{labels}}\)</span> and the score associated with each label <span class="math notranslate nohighlight">\(\hat{f} \in \mathbb{R}^{n_\text{samples} \times n_\text{labels}}\)</span>, the coverage is defined as</p> <div class="math notranslate nohighlight"> \[coverage(y, \hat{f}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}} - 1} \max_{j:y_{ij} = 1} \text{rank}_{ij}\]</div> <p>with <span class="math notranslate nohighlight">\(\text{rank}_{ij} = \left|\left\{k: \hat{f}_{ik} \geq \hat{f}_{ij} \right\}\right|\)</span>. Given the rank definition, ties in <code>y_scores</code> are broken by giving the maximal rank that would have been assigned to all tied values.</p> <p>Here is a small example of usage of this function:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import coverage_error
&gt;&gt;&gt; y_true = np.array([[1, 0, 0], [0, 0, 1]])
&gt;&gt;&gt; y_score = np.array([[0.75, 0.5, 1], [1, 0.2, 0.1]])
&gt;&gt;&gt; coverage_error(y_true, y_score)
2.5
</pre> </section> <section id="label-ranking-average-precision"> <h3 id="id53">
<span class="section-number">3.4.5.2. </span>Label ranking average precision</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.label_ranking_average_precision_score.html#sklearn.metrics.label_ranking_average_precision_score" title="sklearn.metrics.label_ranking_average_precision_score"><code>label_ranking_average_precision_score</code></a> function implements label ranking average precision (LRAP). This metric is linked to the <a class="reference internal" href="generated/sklearn.metrics.average_precision_score.html#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a> function, but is based on the notion of label ranking instead of precision and recall.</p> <p>Label ranking average precision (LRAP) averages over the samples the answer to the following question: for each ground truth label, what fraction of higher-ranked labels were true labels? This performance measure will be higher if you are able to give better rank to the labels associated with each sample. The obtained score is always strictly greater than 0, and the best value is 1. If there is exactly one relevant label per sample, label ranking average precision is equivalent to the <a class="reference external" href="https://en.wikipedia.org/wiki/Mean_reciprocal_rank">mean reciprocal rank</a>.</p> <p>Formally, given a binary indicator matrix of the ground truth labels <span class="math notranslate nohighlight">\(y \in \left\{0, 1\right\}^{n_\text{samples} \times n_\text{labels}}\)</span> and the score associated with each label <span class="math notranslate nohighlight">\(\hat{f} \in \mathbb{R}^{n_\text{samples} \times n_\text{labels}}\)</span>, the average precision is defined as</p> <div class="math notranslate nohighlight"> \[LRAP(y, \hat{f}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}} - 1} \frac{1}{||y_i||_0} \sum_{j:y_{ij} = 1} \frac{|\mathcal{L}_{ij}|}{\text{rank}_{ij}}\]</div> <p>where <span class="math notranslate nohighlight">\(\mathcal{L}_{ij} = \left\{k: y_{ik} = 1, \hat{f}_{ik} \geq \hat{f}_{ij} \right\}\)</span>, <span class="math notranslate nohighlight">\(\text{rank}_{ij} = \left|\left\{k: \hat{f}_{ik} \geq \hat{f}_{ij} \right\}\right|\)</span>, <span class="math notranslate nohighlight">\(|\cdot|\)</span> computes the cardinality of the set (i.e., the number of elements in the set), and <span class="math notranslate nohighlight">\(||\cdot||_0\)</span> is the <span class="math notranslate nohighlight">\(\ell_0\)</span> “norm” (which computes the number of nonzero elements in a vector).</p> <p>Here is a small example of usage of this function:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import label_ranking_average_precision_score
&gt;&gt;&gt; y_true = np.array([[1, 0, 0], [0, 0, 1]])
&gt;&gt;&gt; y_score = np.array([[0.75, 0.5, 1], [1, 0.2, 0.1]])
&gt;&gt;&gt; label_ranking_average_precision_score(y_true, y_score)
0.416...
</pre> </section> <section id="ranking-loss"> <h3 id="label-ranking-loss">
<span class="section-number">3.4.5.3. </span>Ranking loss</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.label_ranking_loss.html#sklearn.metrics.label_ranking_loss" title="sklearn.metrics.label_ranking_loss"><code>label_ranking_loss</code></a> function computes the ranking loss which averages over the samples the number of label pairs that are incorrectly ordered, i.e. true labels have a lower score than false labels, weighted by the inverse of the number of ordered pairs of false and true labels. The lowest achievable ranking loss is zero.</p> <p>Formally, given a binary indicator matrix of the ground truth labels <span class="math notranslate nohighlight">\(y \in \left\{0, 1\right\}^{n_\text{samples} \times n_\text{labels}}\)</span> and the score associated with each label <span class="math notranslate nohighlight">\(\hat{f} \in \mathbb{R}^{n_\text{samples} \times n_\text{labels}}\)</span>, the ranking loss is defined as</p> <div class="math notranslate nohighlight"> \[ranking\_loss(y, \hat{f}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}} - 1} \frac{1}{||y_i||_0(n_\text{labels} - ||y_i||_0)} \left|\left\{(k, l): \hat{f}_{ik} \leq \hat{f}_{il}, y_{ik} = 1, y_{il} = 0 \right\}\right|\]</div> <p>where <span class="math notranslate nohighlight">\(|\cdot|\)</span> computes the cardinality of the set (i.e., the number of elements in the set) and <span class="math notranslate nohighlight">\(||\cdot||_0\)</span> is the <span class="math notranslate nohighlight">\(\ell_0\)</span> “norm” (which computes the number of nonzero elements in a vector).</p> <p>Here is a small example of usage of this function:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import label_ranking_loss
&gt;&gt;&gt; y_true = np.array([[1, 0, 0], [0, 0, 1]])
&gt;&gt;&gt; y_score = np.array([[0.75, 0.5, 1], [1, 0.2, 0.1]])
&gt;&gt;&gt; label_ranking_loss(y_true, y_score)
0.75...
&gt;&gt;&gt; # With the following prediction, we have perfect and minimal loss
&gt;&gt;&gt; y_score = np.array([[1.0, 0.1, 0.2], [0.1, 0.2, 0.9]])
&gt;&gt;&gt; label_ranking_loss(y_true, y_score)
0.0
</pre> <details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="references-2"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">References</span></summary><div class="sd-summary-content sd-card-body docutils"> <ul class="simple"> <li>Tsoumakas, G., Katakis, I., &amp; Vlahavas, I. (2010). Mining multi-label data. In Data mining and knowledge discovery handbook (pp. 667-685). Springer US.</li> </ul> </div> </details></section> <section id="normalized-discounted-cumulative-gain"> <h3 id="ndcg">
<span class="section-number">3.4.5.4. </span>Normalized Discounted Cumulative Gain</h3> <p>Discounted Cumulative Gain (DCG) and Normalized Discounted Cumulative Gain (NDCG) are ranking metrics implemented in <a class="reference internal" href="generated/sklearn.metrics.dcg_score.html#sklearn.metrics.dcg_score" title="sklearn.metrics.dcg_score"><code>dcg_score</code></a> and <a class="reference internal" href="generated/sklearn.metrics.ndcg_score.html#sklearn.metrics.ndcg_score" title="sklearn.metrics.ndcg_score"><code>ndcg_score</code></a> ; they compare a predicted order to ground-truth scores, such as the relevance of answers to a query.</p> <p>From the Wikipedia page for Discounted Cumulative Gain:</p> <p>“Discounted cumulative gain (DCG) is a measure of ranking quality. In information retrieval, it is often used to measure effectiveness of web search engine algorithms or related applications. Using a graded relevance scale of documents in a search-engine result set, DCG measures the usefulness, or gain, of a document based on its position in the result list. The gain is accumulated from the top of the result list to the bottom, with the gain of each result discounted at lower ranks”</p> <p>DCG orders the true targets (e.g. relevance of query answers) in the predicted order, then multiplies them by a logarithmic decay and sums the result. The sum can be truncated after the first <span class="math notranslate nohighlight">\(K\)</span> results, in which case we call it DCG@K. NDCG, or NDCG@K is DCG divided by the DCG obtained by a perfect prediction, so that it is always between 0 and 1. Usually, NDCG is preferred to DCG.</p> <p>Compared with the ranking loss, NDCG can take into account relevance scores, rather than a ground-truth ranking. So if the ground-truth consists only of an ordering, the ranking loss should be preferred; if the ground-truth consists of actual usefulness scores (e.g. 0 for irrelevant, 1 for relevant, 2 for very relevant), NDCG can be used.</p> <p>For one sample, given the vector of continuous ground-truth values for each target <span class="math notranslate nohighlight">\(y \in \mathbb{R}^{M}\)</span>, where <span class="math notranslate nohighlight">\(M\)</span> is the number of outputs, and the prediction <span class="math notranslate nohighlight">\(\hat{y}\)</span>, which induces the ranking function <span class="math notranslate nohighlight">\(f\)</span>, the DCG score is</p> <div class="math notranslate nohighlight"> \[\sum_{r=1}^{\min(K, M)}\frac{y_{f(r)}}{\log(1 + r)}\]</div> <p>and the NDCG score is the DCG score divided by the DCG score obtained for <span class="math notranslate nohighlight">\(y\)</span>.</p> <details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="references-3"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">References</span></summary><div class="sd-summary-content sd-card-body docutils"> <ul class="simple"> <li><a class="reference external" href="https://en.wikipedia.org/wiki/Discounted_cumulative_gain">Wikipedia entry for Discounted Cumulative Gain</a></li> <li>Jarvelin, K., &amp; Kekalainen, J. (2002). Cumulated gain-based evaluation of IR techniques. ACM Transactions on Information Systems (TOIS), 20(4), 422-446.</li> <li>Wang, Y., Wang, L., Li, Y., He, D., Chen, W., &amp; Liu, T. Y. (2013, May). A theoretical analysis of NDCG ranking measures. In Proceedings of the 26th Annual Conference on Learning Theory (COLT 2013)</li> <li>McSherry, F., &amp; Najork, M. (2008, March). Computing information retrieval performance measures efficiently in the presence of tied scores. In European conference on information retrieval (pp. 414-421). Springer, Berlin, Heidelberg.</li> </ul> </div> </details></section> </section> <section id="regression-metrics"> <h2 id="id54">
<span class="section-number">3.4.6. </span>Regression metrics</h2> <p>The <a class="reference internal" href="https://scikit-learn.org/1.6/api/sklearn.metrics.html#module-sklearn.metrics" title="sklearn.metrics"><code>sklearn.metrics</code></a> module implements several loss, score, and utility functions to measure regression performance. Some of those have been enhanced to handle the multioutput case: <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>mean_squared_error</code></a>, <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code>mean_absolute_error</code></a>, <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>, <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>explained_variance_score</code></a>, <a class="reference internal" href="generated/sklearn.metrics.mean_pinball_loss.html#sklearn.metrics.mean_pinball_loss" title="sklearn.metrics.mean_pinball_loss"><code>mean_pinball_loss</code></a>, <a class="reference internal" href="generated/sklearn.metrics.d2_pinball_score.html#sklearn.metrics.d2_pinball_score" title="sklearn.metrics.d2_pinball_score"><code>d2_pinball_score</code></a> and <a class="reference internal" href="generated/sklearn.metrics.d2_absolute_error_score.html#sklearn.metrics.d2_absolute_error_score" title="sklearn.metrics.d2_absolute_error_score"><code>d2_absolute_error_score</code></a>.</p> <p>These functions have a <code>multioutput</code> keyword argument which specifies the way the scores or losses for each individual target should be averaged. The default is <code>'uniform_average'</code>, which specifies a uniformly weighted mean over outputs. If an <code>ndarray</code> of shape <code>(n_outputs,)</code> is passed, then its entries are interpreted as weights and an according weighted average is returned. If <code>multioutput</code> is <code>'raw_values'</code>, then all unaltered individual scores or losses will be returned in an array of shape <code>(n_outputs,)</code>.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a> and <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>explained_variance_score</code></a> accept an additional value <code>'variance_weighted'</code> for the <code>multioutput</code> parameter. This option leads to a weighting of each individual score by the variance of the corresponding target variable. This setting quantifies the globally captured unscaled variance. If the target variables are of different scale, then this score puts more importance on explaining the higher variance variables.</p> <section id="r2-score-the-coefficient-of-determination"> <h3 id="r2-score">
<span class="section-number">3.4.6.1. </span>R² score, the coefficient of determination</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Coefficient_of_determination">coefficient of determination</a>, usually denoted as <span class="math notranslate nohighlight">\(R^2\)</span>.</p> <p>It represents the proportion of variance (of y) that has been explained by the independent variables in the model. It provides an indication of goodness of fit and therefore a measure of how well unseen samples are likely to be predicted by the model, through the proportion of explained variance.</p> <p>As such variance is dataset dependent, <span class="math notranslate nohighlight">\(R^2\)</span> may not be meaningfully comparable across different datasets. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected (average) value of y, disregarding the input features, would get an <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <p>Note: when the prediction residuals have zero mean, the <span class="math notranslate nohighlight">\(R^2\)</span> score and the <a class="reference internal" href="#explained-variance-score"><span class="std std-ref">Explained variance score</span></a> are identical.</p> <p>If <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> is the predicted value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value for total <span class="math notranslate nohighlight">\(n\)</span> samples, the estimated <span class="math notranslate nohighlight">\(R^2\)</span> is defined as:</p> <div class="math notranslate nohighlight"> \[R^2(y, \hat{y}) = 1 - \frac{\sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{\sum_{i=1}^{n} (y_i - \bar{y})^2}\]</div> <p>where <span class="math notranslate nohighlight">\(\bar{y} = \frac{1}{n} \sum_{i=1}^{n} y_i\)</span> and <span class="math notranslate nohighlight">\(\sum_{i=1}^{n} (y_i - \hat{y}_i)^2 = \sum_{i=1}^{n} \epsilon_i^2\)</span>.</p> <p>Note that <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a> calculates unadjusted <span class="math notranslate nohighlight">\(R^2\)</span> without correcting for bias in sample variance of y.</p> <p>In the particular case where the true target is constant, the <span class="math notranslate nohighlight">\(R^2\)</span> score is not finite: it is either <code>NaN</code> (perfect predictions) or <code>-Inf</code> (imperfect predictions). Such non-finite scores may prevent correct model optimization such as grid-search cross-validation to be performed correctly. For this reason the default behaviour of <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a> is to replace them with 1.0 (perfect predictions) or 0.0 (imperfect predictions). If <code>force_finite</code> is set to <code>False</code>, this score falls back on the original <span class="math notranslate nohighlight">\(R^2\)</span> definition.</p> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import r2_score
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; r2_score(y_true, y_pred)
0.948...
&gt;&gt;&gt; y_true = [[0.5, 1], [-1, 1], [7, -6]]
&gt;&gt;&gt; y_pred = [[0, 2], [-1, 2], [8, -5]]
&gt;&gt;&gt; r2_score(y_true, y_pred, multioutput='variance_weighted')
0.938...
&gt;&gt;&gt; y_true = [[0.5, 1], [-1, 1], [7, -6]]
&gt;&gt;&gt; y_pred = [[0, 2], [-1, 2], [8, -5]]
&gt;&gt;&gt; r2_score(y_true, y_pred, multioutput='uniform_average')
0.936...
&gt;&gt;&gt; r2_score(y_true, y_pred, multioutput='raw_values')
array([0.965..., 0.908...])
&gt;&gt;&gt; r2_score(y_true, y_pred, multioutput=[0.3, 0.7])
0.925...
&gt;&gt;&gt; y_true = [-2, -2, -2]
&gt;&gt;&gt; y_pred = [-2, -2, -2]
&gt;&gt;&gt; r2_score(y_true, y_pred)
1.0
&gt;&gt;&gt; r2_score(y_true, y_pred, force_finite=False)
nan
&gt;&gt;&gt; y_true = [-2, -2, -2]
&gt;&gt;&gt; y_pred = [-2, -2, -2 + 1e-8]
&gt;&gt;&gt; r2_score(y_true, y_pred)
0.0
&gt;&gt;&gt; r2_score(y_true, y_pred, force_finite=False)
-inf
</pre> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/linear_model/plot_lasso_and_elasticnet.html#sphx-glr-auto-examples-linear-model-plot-lasso-and-elasticnet-py"><span class="std std-ref">L1-based models for Sparse Signals</span></a> for an example of R² score usage to evaluate Lasso and Elastic Net on sparse signals.</li> </ul> </section> <section id="mean-absolute-error"> <h3 id="id55">
<span class="section-number">3.4.6.2. </span>Mean absolute error</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code>mean_absolute_error</code></a> function computes <a class="reference external" href="https://en.wikipedia.org/wiki/Mean_absolute_error">mean absolute error</a>, a risk metric corresponding to the expected value of the absolute error loss or <span class="math notranslate nohighlight">\(l1\)</span>-norm loss.</p> <p>If <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> is the predicted value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample, and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value, then the mean absolute error (MAE) estimated over <span class="math notranslate nohighlight">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math notranslate nohighlight"> \[\text{MAE}(y, \hat{y}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}}-1} \left| y_i - \hat{y}_i \right|.\]</div> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code>mean_absolute_error</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import mean_absolute_error
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; mean_absolute_error(y_true, y_pred)
0.5
&gt;&gt;&gt; y_true = [[0.5, 1], [-1, 1], [7, -6]]
&gt;&gt;&gt; y_pred = [[0, 2], [-1, 2], [8, -5]]
&gt;&gt;&gt; mean_absolute_error(y_true, y_pred)
0.75
&gt;&gt;&gt; mean_absolute_error(y_true, y_pred, multioutput='raw_values')
array([0.5, 1. ])
&gt;&gt;&gt; mean_absolute_error(y_true, y_pred, multioutput=[0.3, 0.7])
0.85...
</pre> </section> <section id="mean-squared-error"> <h3 id="id57">
<span class="section-number">3.4.6.3. </span>Mean squared error</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>mean_squared_error</code></a> function computes <a class="reference external" href="https://en.wikipedia.org/wiki/Mean_squared_error">mean squared error</a>, a risk metric corresponding to the expected value of the squared (quadratic) error or loss.</p> <p>If <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> is the predicted value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample, and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value, then the mean squared error (MSE) estimated over <span class="math notranslate nohighlight">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math notranslate nohighlight"> \[\text{MSE}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples} - 1} (y_i - \hat{y}_i)^2.\]</div> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>mean_squared_error</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import mean_squared_error
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; mean_squared_error(y_true, y_pred)
0.375
&gt;&gt;&gt; y_true = [[0.5, 1], [-1, 1], [7, -6]]
&gt;&gt;&gt; y_pred = [[0, 2], [-1, 2], [8, -5]]
&gt;&gt;&gt; mean_squared_error(y_true, y_pred)
0.7083...
</pre> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_regression.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-regression-py"><span class="std std-ref">Gradient Boosting regression</span></a> for an example of mean squared error usage to evaluate gradient boosting regression.</li> </ul> <p>Taking the square root of the MSE, called the root mean squared error (RMSE), is another common metric that provides a measure in the same units as the target variable. RSME is available through the <a class="reference internal" href="generated/sklearn.metrics.root_mean_squared_error.html#sklearn.metrics.root_mean_squared_error" title="sklearn.metrics.root_mean_squared_error"><code>root_mean_squared_error</code></a> function.</p> </section> <section id="mean-squared-logarithmic-error"> <h3 id="mean-squared-log-error">
<span class="section-number">3.4.6.4. </span>Mean squared logarithmic error</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.mean_squared_log_error.html#sklearn.metrics.mean_squared_log_error" title="sklearn.metrics.mean_squared_log_error"><code>mean_squared_log_error</code></a> function computes a risk metric corresponding to the expected value of the squared logarithmic (quadratic) error or loss.</p> <p>If <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> is the predicted value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample, and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value, then the mean squared logarithmic error (MSLE) estimated over <span class="math notranslate nohighlight">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math notranslate nohighlight"> \[\text{MSLE}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples} - 1} (\log_e (1 + y_i) - \log_e (1 + \hat{y}_i) )^2.\]</div> <p>Where <span class="math notranslate nohighlight">\(\log_e (x)\)</span> means the natural logarithm of <span class="math notranslate nohighlight">\(x\)</span>. This metric is best to use when targets having exponential growth, such as population counts, average sales of a commodity over a span of years etc. Note that this metric penalizes an under-predicted estimate greater than an over-predicted estimate.</p> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.mean_squared_log_error.html#sklearn.metrics.mean_squared_log_error" title="sklearn.metrics.mean_squared_log_error"><code>mean_squared_log_error</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import mean_squared_log_error
&gt;&gt;&gt; y_true = [3, 5, 2.5, 7]
&gt;&gt;&gt; y_pred = [2.5, 5, 4, 8]
&gt;&gt;&gt; mean_squared_log_error(y_true, y_pred)
0.039...
&gt;&gt;&gt; y_true = [[0.5, 1], [1, 2], [7, 6]]
&gt;&gt;&gt; y_pred = [[0.5, 2], [1, 2.5], [8, 8]]
&gt;&gt;&gt; mean_squared_log_error(y_true, y_pred)
0.044...
</pre> <p>The root mean squared logarithmic error (RMSLE) is available through the <a class="reference internal" href="generated/sklearn.metrics.root_mean_squared_log_error.html#sklearn.metrics.root_mean_squared_log_error" title="sklearn.metrics.root_mean_squared_log_error"><code>root_mean_squared_log_error</code></a> function.</p> </section> <section id="mean-absolute-percentage-error"> <h3 id="id59">
<span class="section-number">3.4.6.5. </span>Mean absolute percentage error</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_percentage_error.html#sklearn.metrics.mean_absolute_percentage_error" title="sklearn.metrics.mean_absolute_percentage_error"><code>mean_absolute_percentage_error</code></a> (MAPE), also known as mean absolute percentage deviation (MAPD), is an evaluation metric for regression problems. The idea of this metric is to be sensitive to relative errors. It is for example not changed by a global scaling of the target variable.</p> <p>If <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> is the predicted value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value, then the mean absolute percentage error (MAPE) estimated over <span class="math notranslate nohighlight">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math notranslate nohighlight"> \[\text{MAPE}(y, \hat{y}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}}-1} \frac{{}\left| y_i - \hat{y}_i \right|}{\max(\epsilon, \left| y_i \right|)}\]</div> <p>where <span class="math notranslate nohighlight">\(\epsilon\)</span> is an arbitrary small yet strictly positive number to avoid undefined results when y is zero.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_percentage_error.html#sklearn.metrics.mean_absolute_percentage_error" title="sklearn.metrics.mean_absolute_percentage_error"><code>mean_absolute_percentage_error</code></a> function supports multioutput.</p> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_percentage_error.html#sklearn.metrics.mean_absolute_percentage_error" title="sklearn.metrics.mean_absolute_percentage_error"><code>mean_absolute_percentage_error</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import mean_absolute_percentage_error
&gt;&gt;&gt; y_true = [1, 10, 1e6]
&gt;&gt;&gt; y_pred = [0.9, 15, 1.2e6]
&gt;&gt;&gt; mean_absolute_percentage_error(y_true, y_pred)
0.2666...
</pre> <p>In above example, if we had used <code>mean_absolute_error</code>, it would have ignored the small magnitude values and only reflected the error in prediction of highest magnitude value. But that problem is resolved in case of MAPE because it calculates relative percentage error with respect to actual output.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The MAPE formula here does not represent the common “percentage” definition: the percentage in the range [0, 100] is converted to a relative value in the range [0, 1] by dividing by 100. Thus, an error of 200% corresponds to a relative error of 2. The motivation here is to have a range of values that is more consistent with other error metrics in scikit-learn, such as <code>accuracy_score</code>.</p> <p>To obtain the mean absolute percentage error as per the Wikipedia formula, multiply the <code>mean_absolute_percentage_error</code> computed here by 100.</p> </div> <details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="references-4"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">References</span></summary><div class="sd-summary-content sd-card-body docutils"> <ul class="simple"> <li><a class="reference external" href="https://en.wikipedia.org/wiki/Mean_absolute_percentage_error">Wikipedia entry for Mean Absolute Percentage Error</a></li> </ul> </div> </details></section> <section id="median-absolute-error"> <h3 id="id60">
<span class="section-number">3.4.6.6. </span>Median absolute error</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.median_absolute_error.html#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code>median_absolute_error</code></a> is particularly interesting because it is robust to outliers. The loss is calculated by taking the median of all absolute differences between the target and the prediction.</p> <p>If <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> is the predicted value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value, then the median absolute error (MedAE) estimated over <span class="math notranslate nohighlight">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math notranslate nohighlight"> \[\text{MedAE}(y, \hat{y}) = \text{median}(\mid y_1 - \hat{y}_1 \mid, \ldots, \mid y_n - \hat{y}_n \mid).\]</div> <p>The <a class="reference internal" href="generated/sklearn.metrics.median_absolute_error.html#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code>median_absolute_error</code></a> does not support multioutput.</p> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.median_absolute_error.html#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code>median_absolute_error</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import median_absolute_error
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; median_absolute_error(y_true, y_pred)
0.5
</pre> </section> <section id="max-error"> <h3 id="id61">
<span class="section-number">3.4.6.7. </span>Max error</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.max_error.html#sklearn.metrics.max_error" title="sklearn.metrics.max_error"><code>max_error</code></a> function computes the maximum <a class="reference external" href="https://en.wikipedia.org/wiki/Errors_and_residuals">residual error</a> , a metric that captures the worst case error between the predicted value and the true value. In a perfectly fitted single output regression model, <code>max_error</code> would be <code>0</code> on the training set and though this would be highly unlikely in the real world, this metric shows the extent of error that the model had when it was fitted.</p> <p>If <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> is the predicted value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample, and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value, then the max error is defined as</p> <div class="math notranslate nohighlight"> \[\text{Max Error}(y, \hat{y}) = \max(| y_i - \hat{y}_i |)\]</div> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.max_error.html#sklearn.metrics.max_error" title="sklearn.metrics.max_error"><code>max_error</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import max_error
&gt;&gt;&gt; y_true = [3, 2, 7, 1]
&gt;&gt;&gt; y_pred = [9, 2, 7, 1]
&gt;&gt;&gt; max_error(y_true, y_pred)
6
</pre> <p>The <a class="reference internal" href="generated/sklearn.metrics.max_error.html#sklearn.metrics.max_error" title="sklearn.metrics.max_error"><code>max_error</code></a> does not support multioutput.</p> </section> <section id="explained-variance-score"> <h3 id="id62">
<span class="section-number">3.4.6.8. </span>Explained variance score</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>explained_variance_score</code></a> computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Explained_variation">explained variance regression score</a>.</p> <p>If <span class="math notranslate nohighlight">\(\hat{y}\)</span> is the estimated target output, <span class="math notranslate nohighlight">\(y\)</span> the corresponding (correct) target output, and <span class="math notranslate nohighlight">\(Var\)</span> is <a class="reference external" href="https://en.wikipedia.org/wiki/Variance">Variance</a>, the square of the standard deviation, then the explained variance is estimated as follow:</p> <div class="math notranslate nohighlight"> \[explained\_{}variance(y, \hat{y}) = 1 - \frac{Var\{ y - \hat{y}\}}{Var\{y\}}\]</div> <p>The best possible score is 1.0, lower values are worse.</p> <aside class="topic"> <p class="topic-title">Link to <a class="reference internal" href="#r2-score"><span class="std std-ref">R² score, the coefficient of determination</span></a></p> <p>The difference between the explained variance score and the <a class="reference internal" href="#r2-score"><span class="std std-ref">R² score, the coefficient of determination</span></a> is that the explained variance score does not account for systematic offset in the prediction. For this reason, the <a class="reference internal" href="#r2-score"><span class="std std-ref">R² score, the coefficient of determination</span></a> should be preferred in general.</p> </aside> <p>In the particular case where the true target is constant, the Explained Variance score is not finite: it is either <code>NaN</code> (perfect predictions) or <code>-Inf</code> (imperfect predictions). Such non-finite scores may prevent correct model optimization such as grid-search cross-validation to be performed correctly. For this reason the default behaviour of <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>explained_variance_score</code></a> is to replace them with 1.0 (perfect predictions) or 0.0 (imperfect predictions). You can set the <code>force_finite</code> parameter to <code>False</code> to prevent this fix from happening and fallback on the original Explained Variance score.</p> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score.html#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>explained_variance_score</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import explained_variance_score
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; explained_variance_score(y_true, y_pred)
0.957...
&gt;&gt;&gt; y_true = [[0.5, 1], [-1, 1], [7, -6]]
&gt;&gt;&gt; y_pred = [[0, 2], [-1, 2], [8, -5]]
&gt;&gt;&gt; explained_variance_score(y_true, y_pred, multioutput='raw_values')
array([0.967..., 1.        ])
&gt;&gt;&gt; explained_variance_score(y_true, y_pred, multioutput=[0.3, 0.7])
0.990...
&gt;&gt;&gt; y_true = [-2, -2, -2]
&gt;&gt;&gt; y_pred = [-2, -2, -2]
&gt;&gt;&gt; explained_variance_score(y_true, y_pred)
1.0
&gt;&gt;&gt; explained_variance_score(y_true, y_pred, force_finite=False)
nan
&gt;&gt;&gt; y_true = [-2, -2, -2]
&gt;&gt;&gt; y_pred = [-2, -2, -2 + 1e-8]
&gt;&gt;&gt; explained_variance_score(y_true, y_pred)
0.0
&gt;&gt;&gt; explained_variance_score(y_true, y_pred, force_finite=False)
-inf
</pre> </section> <section id="mean-poisson-gamma-and-tweedie-deviances"> <h3 id="mean-tweedie-deviance">
<span class="section-number">3.4.6.9. </span>Mean Poisson, Gamma, and Tweedie deviances</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.mean_tweedie_deviance.html#sklearn.metrics.mean_tweedie_deviance" title="sklearn.metrics.mean_tweedie_deviance"><code>mean_tweedie_deviance</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Tweedie_distribution#The_Tweedie_deviance">mean Tweedie deviance error</a> with a <code>power</code> parameter (<span class="math notranslate nohighlight">\(p\)</span>). This is a metric that elicits predicted expectation values of regression targets.</p> <p>Following special cases exist,</p> <ul class="simple"> <li>when <code>power=0</code> it is equivalent to <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error.html#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>mean_squared_error</code></a>.</li> <li>when <code>power=1</code> it is equivalent to <a class="reference internal" href="generated/sklearn.metrics.mean_poisson_deviance.html#sklearn.metrics.mean_poisson_deviance" title="sklearn.metrics.mean_poisson_deviance"><code>mean_poisson_deviance</code></a>.</li> <li>when <code>power=2</code> it is equivalent to <a class="reference internal" href="generated/sklearn.metrics.mean_gamma_deviance.html#sklearn.metrics.mean_gamma_deviance" title="sklearn.metrics.mean_gamma_deviance"><code>mean_gamma_deviance</code></a>.</li> </ul> <p>If <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> is the predicted value of the <span class="math notranslate nohighlight">\(i\)</span>-th sample, and <span class="math notranslate nohighlight">\(y_i\)</span> is the corresponding true value, then the mean Tweedie deviance error (D) for power <span class="math notranslate nohighlight">\(p\)</span>, estimated over <span class="math notranslate nohighlight">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math notranslate nohighlight"> \[\begin{split}\text{D}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples} - 1} \begin{cases} (y_i-\hat{y}_i)^2, &amp; \text{for }p=0\text{ (Normal)}\\ 2(y_i \log(y_i/\hat{y}_i) + \hat{y}_i - y_i), &amp; \text{for }p=1\text{ (Poisson)}\\ 2(\log(\hat{y}_i/y_i) + y_i/\hat{y}_i - 1), &amp; \text{for }p=2\text{ (Gamma)}\\ 2\left(\frac{\max(y_i,0)^{2-p}}{(1-p)(2-p)}- \frac{y_i\,\hat{y}_i^{1-p}}{1-p}+\frac{\hat{y}_i^{2-p}}{2-p}\right), &amp; \text{otherwise} \end{cases}\end{split}\]</div> <p>Tweedie deviance is a homogeneous function of degree <code>2-power</code>. Thus, Gamma distribution with <code>power=2</code> means that simultaneously scaling <code>y_true</code> and <code>y_pred</code> has no effect on the deviance. For Poisson distribution <code>power=1</code> the deviance scales linearly, and for Normal distribution (<code>power=0</code>), quadratically. In general, the higher <code>power</code> the less weight is given to extreme deviations between true and predicted targets.</p> <p>For instance, let’s compare the two predictions 1.5 and 150 that are both 50% larger than their corresponding true value.</p> <p>The mean squared error (<code>power=0</code>) is very sensitive to the prediction difference of the second point,:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import mean_tweedie_deviance
&gt;&gt;&gt; mean_tweedie_deviance([1.0], [1.5], power=0)
0.25
&gt;&gt;&gt; mean_tweedie_deviance([100.], [150.], power=0)
2500.0
</pre> <p>If we increase <code>power</code> to 1,:</p> <pre data-language="python">&gt;&gt;&gt; mean_tweedie_deviance([1.0], [1.5], power=1)
0.18...
&gt;&gt;&gt; mean_tweedie_deviance([100.], [150.], power=1)
18.9...
</pre> <p>the difference in errors decreases. Finally, by setting, <code>power=2</code>:</p> <pre data-language="python">&gt;&gt;&gt; mean_tweedie_deviance([1.0], [1.5], power=2)
0.14...
&gt;&gt;&gt; mean_tweedie_deviance([100.], [150.], power=2)
0.14...
</pre> <p>we would get identical errors. The deviance when <code>power=2</code> is thus only sensitive to relative errors.</p> </section> <section id="pinball-loss"> <h3 id="id63">
<span class="section-number">3.4.6.10. </span>Pinball loss</h3> <p>The <a class="reference internal" href="generated/sklearn.metrics.mean_pinball_loss.html#sklearn.metrics.mean_pinball_loss" title="sklearn.metrics.mean_pinball_loss"><code>mean_pinball_loss</code></a> function is used to evaluate the predictive performance of <a class="reference external" href="https://en.wikipedia.org/wiki/Quantile_regression">quantile regression</a> models.</p> <div class="math notranslate nohighlight"> \[\text{pinball}(y, \hat{y}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}}-1} \alpha \max(y_i - \hat{y}_i, 0) + (1 - \alpha) \max(\hat{y}_i - y_i, 0)\]</div> <p>The value of pinball loss is equivalent to half of <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error.html#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code>mean_absolute_error</code></a> when the quantile parameter <code>alpha</code> is set to 0.5.</p> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.mean_pinball_loss.html#sklearn.metrics.mean_pinball_loss" title="sklearn.metrics.mean_pinball_loss"><code>mean_pinball_loss</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import mean_pinball_loss
&gt;&gt;&gt; y_true = [1, 2, 3]
&gt;&gt;&gt; mean_pinball_loss(y_true, [0, 2, 3], alpha=0.1)
0.03...
&gt;&gt;&gt; mean_pinball_loss(y_true, [1, 2, 4], alpha=0.1)
0.3...
&gt;&gt;&gt; mean_pinball_loss(y_true, [0, 2, 3], alpha=0.9)
0.3...
&gt;&gt;&gt; mean_pinball_loss(y_true, [1, 2, 4], alpha=0.9)
0.03...
&gt;&gt;&gt; mean_pinball_loss(y_true, y_true, alpha=0.1)
0.0
&gt;&gt;&gt; mean_pinball_loss(y_true, y_true, alpha=0.9)
0.0
</pre> <p>It is possible to build a scorer object with a specific choice of <code>alpha</code>:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import make_scorer
&gt;&gt;&gt; mean_pinball_loss_95p = make_scorer(mean_pinball_loss, alpha=0.95)
</pre> <p>Such a scorer can be used to evaluate the generalization performance of a quantile regressor via cross-validation:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import make_regression
&gt;&gt;&gt; from sklearn.model_selection import cross_val_score
&gt;&gt;&gt; from sklearn.ensemble import GradientBoostingRegressor
&gt;&gt;&gt;
&gt;&gt;&gt; X, y = make_regression(n_samples=100, random_state=0)
&gt;&gt;&gt; estimator = GradientBoostingRegressor(
...     loss="quantile",
...     alpha=0.95,
...     random_state=0,
... )
&gt;&gt;&gt; cross_val_score(estimator, X, y, cv=5, scoring=mean_pinball_loss_95p)
array([13.6..., 9.7..., 23.3..., 9.5..., 10.4...])
</pre> <p>It is also possible to build scorer objects for hyper-parameter tuning. The sign of the loss must be switched to ensure that greater means better as explained in the example linked below.</p> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_quantile.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-quantile-py"><span class="std std-ref">Prediction Intervals for Gradient Boosting Regression</span></a> for an example of using the pinball loss to evaluate and tune the hyper-parameters of quantile regression models on data with non-symmetric noise and outliers.</li> </ul> </section> <section id="d2-score"> <h3 id="id64">
<span class="section-number">3.4.6.11. </span>D² score</h3> <p>The D² score computes the fraction of deviance explained. It is a generalization of R², where the squared error is generalized and replaced by a deviance of choice <span class="math notranslate nohighlight">\(\text{dev}(y, \hat{y})\)</span> (e.g., Tweedie, pinball or mean absolute error). D² is a form of a <em>skill score</em>. It is calculated as</p> <div class="math notranslate nohighlight"> \[D^2(y, \hat{y}) = 1 - \frac{\text{dev}(y, \hat{y})}{\text{dev}(y, y_{\text{null}})} \,.\]</div> <p>Where <span class="math notranslate nohighlight">\(y_{\text{null}}\)</span> is the optimal prediction of an intercept-only model (e.g., the mean of <code>y_true</code> for the Tweedie case, the median for absolute error and the alpha-quantile for pinball loss).</p> <p>Like R², the best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts <span class="math notranslate nohighlight">\(y_{\text{null}}\)</span>, disregarding the input features, would get a D² score of 0.0.</p> <details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="d²-tweedie-score"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">D² Tweedie score</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">The <a class="reference internal" href="generated/sklearn.metrics.d2_tweedie_score.html#sklearn.metrics.d2_tweedie_score" title="sklearn.metrics.d2_tweedie_score"><code>d2_tweedie_score</code></a> function implements the special case of D² where <span class="math notranslate nohighlight">\(\text{dev}(y, \hat{y})\)</span> is the Tweedie deviance, see <a class="reference internal" href="#mean-tweedie-deviance"><span class="std std-ref">Mean Poisson, Gamma, and Tweedie deviances</span></a>. It is also known as D² Tweedie and is related to McFadden’s likelihood ratio index.</p> <p class="sd-card-text">The argument <code>power</code> defines the Tweedie power as for <a class="reference internal" href="generated/sklearn.metrics.mean_tweedie_deviance.html#sklearn.metrics.mean_tweedie_deviance" title="sklearn.metrics.mean_tweedie_deviance"><code>mean_tweedie_deviance</code></a>. Note that for <code>power=0</code>, <a class="reference internal" href="generated/sklearn.metrics.d2_tweedie_score.html#sklearn.metrics.d2_tweedie_score" title="sklearn.metrics.d2_tweedie_score"><code>d2_tweedie_score</code></a> equals <a class="reference internal" href="generated/sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a> (for single targets).</p> <p class="sd-card-text">A scorer object with a specific choice of <code>power</code> can be built by:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import d2_tweedie_score, make_scorer
&gt;&gt;&gt; d2_tweedie_score_15 = make_scorer(d2_tweedie_score, power=1.5)
</pre> </div> </details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="d²-pinball-score"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">D² pinball score</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">The <a class="reference internal" href="generated/sklearn.metrics.d2_pinball_score.html#sklearn.metrics.d2_pinball_score" title="sklearn.metrics.d2_pinball_score"><code>d2_pinball_score</code></a> function implements the special case of D² with the pinball loss, see <a class="reference internal" href="#pinball-loss"><span class="std std-ref">Pinball loss</span></a>, i.e.:</p> <div class="math notranslate nohighlight"> \[\text{dev}(y, \hat{y}) = \text{pinball}(y, \hat{y}).\]</div> <p class="sd-card-text">The argument <code>alpha</code> defines the slope of the pinball loss as for <a class="reference internal" href="generated/sklearn.metrics.mean_pinball_loss.html#sklearn.metrics.mean_pinball_loss" title="sklearn.metrics.mean_pinball_loss"><code>mean_pinball_loss</code></a> (<a class="reference internal" href="#pinball-loss"><span class="std std-ref">Pinball loss</span></a>). It determines the quantile level <code>alpha</code> for which the pinball loss and also D² are optimal. Note that for <code>alpha=0.5</code> (the default) <a class="reference internal" href="generated/sklearn.metrics.d2_pinball_score.html#sklearn.metrics.d2_pinball_score" title="sklearn.metrics.d2_pinball_score"><code>d2_pinball_score</code></a> equals <a class="reference internal" href="generated/sklearn.metrics.d2_absolute_error_score.html#sklearn.metrics.d2_absolute_error_score" title="sklearn.metrics.d2_absolute_error_score"><code>d2_absolute_error_score</code></a>.</p> <p class="sd-card-text">A scorer object with a specific choice of <code>alpha</code> can be built by:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import d2_pinball_score, make_scorer
&gt;&gt;&gt; d2_pinball_score_08 = make_scorer(d2_pinball_score, alpha=0.8)
</pre> </div> </details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3" id="d²-absolute-error-score"> <summary class="sd-summary-title sd-card-header"> <span class="sd-summary-text">D² absolute error score</span></summary><div class="sd-summary-content sd-card-body docutils"> <p class="sd-card-text">The <a class="reference internal" href="generated/sklearn.metrics.d2_absolute_error_score.html#sklearn.metrics.d2_absolute_error_score" title="sklearn.metrics.d2_absolute_error_score"><code>d2_absolute_error_score</code></a> function implements the special case of the <a class="reference internal" href="#mean-absolute-error"><span class="std std-ref">Mean absolute error</span></a>:</p> <div class="math notranslate nohighlight"> \[\text{dev}(y, \hat{y}) = \text{MAE}(y, \hat{y}).\]</div> <p class="sd-card-text">Here are some usage examples of the <a class="reference internal" href="generated/sklearn.metrics.d2_absolute_error_score.html#sklearn.metrics.d2_absolute_error_score" title="sklearn.metrics.d2_absolute_error_score"><code>d2_absolute_error_score</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import d2_absolute_error_score
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; d2_absolute_error_score(y_true, y_pred)
0.764...
&gt;&gt;&gt; y_true = [1, 2, 3]
&gt;&gt;&gt; y_pred = [1, 2, 3]
&gt;&gt;&gt; d2_absolute_error_score(y_true, y_pred)
1.0
&gt;&gt;&gt; y_true = [1, 2, 3]
&gt;&gt;&gt; y_pred = [2, 2, 2]
&gt;&gt;&gt; d2_absolute_error_score(y_true, y_pred)
0.0
</pre> </div> </details></section> <section id="visual-evaluation-of-regression-models"> <h3 id="visualization-regression-evaluation">
<span class="section-number">3.4.6.12. </span>Visual evaluation of regression models</h3> <p>Among methods to assess the quality of regression models, scikit-learn provides the <a class="reference internal" href="generated/sklearn.metrics.predictionerrordisplay.html#sklearn.metrics.PredictionErrorDisplay" title="sklearn.metrics.PredictionErrorDisplay"><code>PredictionErrorDisplay</code></a> class. It allows to visually inspect the prediction errors of a model in two different manners.</p> <a class="reference external image-reference" href="../auto_examples/model_selection/plot_cv_predict.html"><img alt="../_images/sphx_glr_plot_cv_predict_001.png" class="align-center" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAGQCAMAAABh+/QGAAABOFBMVEX///8zg7vS4/BcnMg5hrxDjcD9/f7x8fEAAABMksPF2+sofLdMTEwjerU/ir5LkcLA2eofd7RKkMIheLT4+PjBwcEme7X7+/0zg7ovgbkfHx8HBwdfX19/f38DAwOfn58LCws0hLv+/v4aGhqawdyuzeQQEBCRkZGwsLDPz8/k5OQVFRUvLy/g4ODLy8vp6ek+Pj/6+vppaWlXV1fX19dwcHHGx8fT09Pu7u69vb3b29t4eHiNjY0kJCSkpKWTvdpkZGRQUFApKSm1tbWIiIg1NTXi4uL09PVFRUVBQkOtra2Dg4OcnJyoqKmZmZrd3d0sfreWlpb8/P06Ojq5ubkXLTxJSUknfLYOJjckVXikx+De3t40bJNJjr8bSGhKkcK81ON9sNSIttZ2gop4rdFEhbNZmMNWkryhysTNAAAgAElEQVR42uydXXOqOhfHc9Xmwss6zhBBpsygFYpWBKWio1CLSnWPlelNv//3OFnhRbTaffZ5+uzd7q7fhS8YYkjWP1lZzLAIQRAEQRAEQRAEQRAEQRAEQRAEQf5CGpRSRau3CfGoV/7BlYfwtm3A6ytt/N9bIv6jQV/z793uwc9x6+xJ/xIqH9TPCWXxJtXRDpCzAmm4nsyk6FggfmpKgTDTK7fzewTSca/OCEStf4RASvVzelS83dyjHSBnBWLxV5lO3hXIL/F89d8FUuJ/FEh0UiCHZAJBkJ8IJKRxJpDWjqkLFyQDeBK8SqkdynRg60b9kpcaTnX15cfe4oaOxIyXPi/3EEtKWNRCOlONGbuEz9IVg2kvj2nxG/okPBzaIvf1MdMqgwMX6/pBYmYIArlyTF3fgXMlmtMVFSqSXONH2raq224hkAZN6rpa+QHSCqo7ZpNLR1I0B4RyyZu76O9drHCps+CB1EWlr6mLdWsbLPAvoB2+L6k7aP0Pm7d+eYNW8u0F0qSbVCATumit56xKHh26ct3Lm7Hpuje5QAI58Rm3posde0jkcSGQy0CNk5Xj8XLacpW8FrWQhbGptuQ1iYz5urru9bMTzB282kaNVJ1VtTVj/bJAZDoNN5rG5XBZn3iJo/AfXPbiugPSkaSNF0MbokBvJo5UEojEzzIkvnPq6lLTq0am4XtNfXlNrpcszpor6n+i3Ym37ZF7m7ou97lAIB3N2CQ92oN2SC+tlqnziSAYT6pwWch3Fohbi0JD7QiBXGgmn0MjY3fkYmUCeQC3hF3zqX/LPz0UAolpkns84ztSrkV10h8serDHblKuiCHLfny+GzslgQzZDIIENHOxnmtTs3CxeuqtcP8GZCtqnJYEkp4Vc4GItfBBAemvaMib2xSNzAQS6bvrAxcLBDISE0WPwipoPkOD12QozkO+fRSLUtNNo1h9oQHSU6KTAoEFYEM73JogwnVbCGQ3LrYEYPOlWpZ67N7BGqMHW/CjyEWtVnvmGhgRbuL8SC0OFN6Al5JAQroSZgv/vN6p/FdWCESr8PNrAy5QW4XvXkkg6VlLWEFEo0woGtFR1tzXXCAJ33C9Ecg8SHW85eVGEJbg13A91vybC7SRby6QiXXTTm3NI9XUdmLaPimQDklNbKqI0FYhkPGyEAhIo1RLhztBap2fx7cvVJPvhN/Pq7S1ZzKf80KOMkosy+yWBDKh4P+TeRfmf7vlWlNaCEShKTFZClH2SwJJzzJhDyIalRWdlpub1l99K5D0Eh55xXwPkm/pb6cG1Z1LtJJvvwfJBfKTFSQXSGlKPl5B/MMVBBaaprqA9+sbhx9/tSyrD/vzcCD8ND1dGLqnV5CZBM6QvReItrAE7XdXkCBdQdKir7+0gmzKAoFriZUeWgkKJBMI3z1cZ7sHsU3g2+n5CYG83YN4ZYGUahHMjOyDbhehYM12GEzNek+Es7qn9yAzMNuOSotzp9owq+G9PYgw9ljN7wm+2YN0sz2IQ6NTexD/ICic9gCCAkmjWC9Z/MmjPde6JHW2tgbHAhFRrPgoitUSUSxhXEUtl6YfVn1mk/BlkyQ9Pj/njJghLL7OfO/BOFhBIIqVPIkoVoP2vMZ4DALpGi2+9LSlYOuF28ojicb69jiKlTwZIKBUIJGp+UnyZLvkolsE3bIo1nLtbXrwTXatPIqlbRInjWLlArnpNkNvpIzQSlAguUBIa87UpfDmR5rCj9wu1P19kFwgZFjX1YW7D/IMHUkxKsXsW9Ry1TN1FsgR6dtjps9LN/XuaRr5Gk4NdVftdk/fByH8U/Akg0Bu+HadH+GbGkWfj/jM356p6uzoPgh7gZviqUBIJAdMN53OifsgXVUNuBt4xfcYpfsgSn4fJBNIpx6oquk/o5Ug/4VsM/3plI4gf1wb3HmJ1S5BgSDICcK5rkifK/6JAkEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEHO06TB4YG2fD6T0VE2snPAk9PZWD6bAS17PmL50MQ/WfL9tJZfOullmrXUPpOWsNQ7Z69S/sXEbR8/LC3xbGROQksF69LfJBCTHj2X0HonHeW/FQhz3bBO7XdH4vHgbyvS9xNIw/ViZgxP/lrqnY8TyIcPS03LHqhtK52/VCAWrdDphwtEFYVpO/0anRyJQ76jQNKspT/NjvtxAvn4YRlRkY0ofQ7+XymQHh3sVNFV7ammaLOOJ5K9yJkWxLXKc101n67LAplJIuERZIlZz3V2NIbpSIz40iRVViYbncx4mQ7vZKfyuvmoAYRcxQEzIM8NuRsZbGflFd8Z9XQgnFI+TTFO6VOg0wdeJ0uV7eBDkbLz0wskFClMrIrOzDUYrSMxfT7JemffB2lniWtdLzQWwEOz04Nel3f/LPozw0L6IpMX2dKQbLuGGjzcZUaTiU08d/8e0pKCL3YRj5lufql0cpE+J0/iWtqa4Xvraf8SHsXvPpYFUn9KkpjJZYG0xCPR+7RJXGqHXuPUSMzoPZG0ccOzTma8FCMh09kq8WUy2Gmu65KLF1VOnrQgAod5lPianlecJvGAZGn7fJrHApnwysKK4u1Tdn5+gWwh3Y7HuuukDp3SU30vfGhmvbPvg5JAYj+sbiA9jzj4yhat6qQ+/EPDQnYGSGKuPRNnm3i+mMeOBDLQzQkfMBmyNcpe0pS/kkAmdEMi8fDnqdI/cLFKAgHt12LjuiSQmkiqMWJD4tPLE2t5rdZpUu6fSqLWkxkvxfAq9sFavhbZmSBBXzo1TWg+EgOR0mOeubxZPs1DgUR6BVoKeWbylJ2fWyBuLUq0Lp/AAxNm8Yp2QYJZyX0q9UFJIJzrWpXepAdXtBxS+e3DkubTGtBRZiUTZfhGIAsNmtLjjaqYX87D6sLEXOdzCtEW5JxAvKUOK22nvAeBGf1ZsyEP4GLdPhEuofSFH5ZEl5zMeAkjsSkCBOlI2PodlOT1bsX8WlOKkZjvwGJgod7n0zwUSEJXcPKI7lN2fvYoFqXBEFKU+NDwLe2TKRt5US6QUh+UBPLDNuDEdXrwns0bP/aV/vZhidQKJMi6hwT0wkrcY4FcKQ6cHHIvLKa95GslWryn9nA4DGECUKbnBGIpy7VrjWBw9gKBGR2umS/rS0aDyVG4xLIGoiekF3g9mfESRiKmjwcjscgKLkXiTY5RjASYD0yN5XyahwKZZCfzOouUnZ9aIBPL60FaXTdveBVy7VA2u897p+iDvUAibfxUtVaFN1StqHTc/GPDwj2PTs3gZnGrmpOqtQVX91Ag7fzqJqTmm1RZfqWH34+ytnMX8ngFWezyDnLYlSh6IBDwdiBDLHBVXRyGilNnV4xERUxVpzJenpyqjLRg/+1UNWQjMTWW82mCQNYiheFKrCDN9GwR6M9Tdn7yPciUuyh9OkobLoy30zCCNyvIA70iacr4lkiNm5RuWTy79j/snftX2koQx9fWStrS3rYSvSYQKGkjMbwK8hKhvJSHgkfx+Iv3//87bjY8FEgwr11CmDnneryXq6UzfHbmO7vZYYabCotKdyeBh5GeMrheu50BktFK4rIKSFcIT35a00nlQU3qbg0fD2Ktgq2grjlzDTIZ+opykhqSsoQBianVSpdbAuSeYfn50Dx5tmGkHwndiZeTYnfm6cl8zZdZUSvFrhr3iQR9NU8TA1LUPhxhTYMsjoGdj+z0MiBlqXWAak8Lr+CRnksaZKj9z1kNkKK2Prze0wsw1Y2FBbVaQfyRP8UlePxqBkicz2m8YA2SXNiaPJ10hrfCJj1G9ePGN3EX67QyaJyjLj+uqItKkck/1pMchxeW/OPwqrYESIAXtbU7Eq6zib6g/qWFvlEkdCdeTtsl+UEF9zUizH06jR6epAhuvgxW2yXqoimKB2hhniYG5KHF1dsNTutiCfkBO4jkXkZ2eh8QNTfUUYXvqU7sqO/36ibBjvBU3qUuVkBKJtpNvEiVpeSgna/NPHifj1baeeZxY2FR0xqeOIrO+Wx70KvNAFHV1GWl05p0sa6ilcSl+jaC1QFb57g/WwNIk5+W6Xgj9Brvg+TV/zBsCdqYyRbfGmp/V/W7Wud2CRB1EdOKsPaTyCtPOO0zWaNI6E68nDbcr/hYUv23cl7CDXe1SuVjrZxahIcKCj8uvurkH3DTdfJlnqb26kVPUgptbR+EDUqCGBy8jOzcAkBCXO0ByXlFEPtqUVK9kvhaoTz1zisfpMcxMaLFoDiOKQ155sFik+OVbGJzYVFX18lfpJ3kxWp7DkigocSCKW0f5Fn9ZCnjG5WlscJzjRQCAwMDAwMDAwMDAwMDAwMDA6NlbFDUNg+08xv4iFgop8SC1+AYMDBs7epgAshTJpPBG2458VHuJx/AMx63g+sAmHW7PrDu6gkg0/O3AWGI0JnwCIHYQCSs2DUDZseu7QIiKbVGBp83wGkkGYFAbCASVizAwMplY9liAjYBGbZLiWQrhOr4/D3qNbRXQtqvhEDQioQ1QAJQZ9LxGjM74XEmDGaATM5LRrSlEALhxc8vAEIfEFTrLJZYIRpLIUQCANkSQMp8dFWkQyAAkF0OS1eWmUs51S0Unytj/NR1TqwstHkhEADILodlcj1SuNtTBC6MGy+hnMS/3iiEQAAgEBYIBAACYfFhIA7efXt3AICAASC69un9/t7++08ACBgAosfH138//Piw9/UTAAIGgKzWV+///efjx4//7L0/AEDAAJBle7f/4SO2D/vvABAwAGTZvu390AD58fMbAAIGgEAGAUAAEEsaZA80CBgAYmifvu5BFwsMADEm5P3+T9gHAQNADKssv+6k3ydjsXFb+7ahTd4dZWNM2c+A0AklnMXyCSCJ9vl5Fd/ZjRJJEQNy2en4GhBKhyIAED/lcukWz9wscZPZ7RU/A0LrUAQA4h9AHoZ8CR30T9EOAOL4UMQfAGTHACnFBEnVIJ1eXAcQ3z0K7XRLi21kAJDdAiR0ka4qpbSCR5WuAOK7yzQcHopgg8E6ALJ7GqTfuGQEQWAEzg8ZZF2bylkGUfk4jQMgOwhIuFxSTaye+0CDrG1TOToUcZwzzQcA4hdAquxzqTq9W0YrsTLyLcPK5a2NyxttKkeHIjL1OAJAdguQBscr/endSxogE9kR3da4vNmmsn0oorzpTzMA4k23bVdc3hYZNnfS2SYLgAAgWx8XUs/uqPr8HgABQHYgg9jlw7Q+B0AAEC9rEBLP7ljmAwABQDxqJJ7dsc4HAAKAeJYQ95/dGVnmAwAxl+8pPHoAgJD3epyNIwCEyFpG/tEDAISwlY494jXfBYLOowcACFljgzfHAAiRTE/nPkYAhDAf1vWHvtfilZtGvhC9hkBMjdJtWgCIF/lY8Vr3RuSvmvknTngqQiA0o3QfIwDiRT5WvCY225OHEVMdbgSBgAxCqm6leruMfT5WvFZ6+TZ0AYBMNMgeaBC3+x5r+4Ku01Nq2uUDRLqZaFK5j3GXAFnfFyTQVb+Ou+U1+cUAkFcR+wn7IG7m5HV9QZNdddNphk256TVGwA81awaAUK2YdwiQtarOZFfddJphg/mMi15LpVKJ2kiWR7UEAELVdgiQtX1Bcz0R05u3DvS5kdeutBte20kABADZQAYx1VU3vXnrlA89r/HalRjnPAACgJDSIGv6gqYyiNnWu2M+9LyWzIcQCuWThn+myODyKx4R+SzuCodySix47UNA6Pbqd6uLZdwXNNVVN7l5m3bMh57X0orS7ytK2uAn2tWBBkgnNijlRfWnc+Kj3E8++A4QyjPVd20fxLAvaKarbjKDdKtO+dD1WndUKIy6a34IAxIXO2rykEYoIAwROpveyOQjQGjPVIeddDP0WEkzuLqJb8RrGJA7Bm+UBMPT+/uSEZ8BQn2mOpzFslLbmkgz7ICU1+pjMYUuE+sBKTJn6neNHqprar7XmBDrm1vEqU/EBUAscfJmmlH1eZqM1+6VG/4ORbPWAMlpr7x5i7h3R6AtvTvqM9UBEGsa8I1PkvP+laHXWgkUu0MlxU6J9VYGoSx8HYQEMsiGM4YzDegWH7r7ICkMyAVPQKS7InyJJaGFd0d9pvrOA7K4eDrTgK7xYZxBTo32QbqyzFzKKdSR5m3eisk2ryvCl1gSWnp3tGeq7zogS4unowx+5hofel6LisPY8CY2NPiJiiYzwq83CiXe3EahG2ULue7r8rujPFN9xwFZXjydacCEW3zoem3EMYx4SyAQLghfgt3XlXcHO+kUbXl5crCY4pjFyXotkyESCBcyCEHtTF2WAyBrlif7GpAtdMl6ra9NGAn03Q+EC8KXYPeVuiwHQNYtT3Y1oKrPh2S9xmjpI0PigSnnwpfkMk9blgMga5cnexrQvf6VgddkmangB247HIlAOBa+RJd5yrIcAFm/PNnRgG7zseo1RhC0NlXslkggHAtfosv8Jvf5YR9kzfJkNjCu87HqtdQzk06lUmcPXg3ERpd5AIRklWVIgdm9r1DYbT628dofbx/nAkBIVF9m977OonHyXutoxdVtZ/cCAYB4VL+b2/sKUPIap13KW+QAEKpJDgAxMpOdSzYv0/Ea/4y/3sGlDU5kkvXjYgCIkZnb+7I639m+12p1/LUOGYR8yQyAuJZB3O9fGWsQJZpK3SqgQQiXzACIaYe+vfdFig89r8WrvCDEIggAIVoyAyAWUvJbe1/E+ND3WjddCiEAxKbotnlcDABZK+rW731dkuIDxh+4L7ohg9BfoR4e45S81gyg5tT8Fojj339/25oEbFF02zwuBoDYtfM4Ra+FAyg8NZ8F4tfJ4eHhyS8KotvecTEAxKaxxMqrnSqxfn35/uVI/cc6IdZLJlvHxRy6rXMVU5qTa8eDUuwqhVAWnznN+x4Qcvp8pwA5Pvl+9Pnz56PvJ5arLBuiewM76b1oSQ5yXYQupKp8186ogDQymUzA74AQ5mPFa8kX8xUgvw+/fMb25fA3+QyyKbdlGBah/Kw2zhZ2oMQizceK1yKRSFUaFwpjqeorQP4eHmmAHB3+ta5BtmXK7QVTQgexm55yhe+NzSpKqzD9nf65EpYyH3phaWh7hBF/iXQHGWRrptzGg2OcRWKXcgenktFjacj1puveW1fCbqkVm4T50AuLpM1Hv5BAgzgS3fTdluOuETrTdHlwKs7TTNrXGQRdEOZDLyxKFH+NKr4CxEEXC23JlNuciI9hh4Qb9Wt1PE0qwtC/GqSYofCH6B1W5HP1eo735mFF+x9V2/sglMyh2+I5Ucv8aIxr4+Y0g5RwreVTQNhguLyZsAzHkjQeIi8C4uRiXts76VsBSE5iM5lMF6GBMLo4FVh0EUk/t1s+HI1HTZ+T8hrBQNAei7ZFgGgqnMHV8W2NTyYQus5KfK1QRv4BZKF6oMSHrtfKt9UySp95DxDqY9G2CJBt1YY2qwdafOh5TVZqwp0n27wbvj0XANlQtlitHtK0+NC9m7eK54N48dKG9Yc+tvw6oJ0GZDl282wxf2GxegjkKPFhsA+iApLy4KUNazOIt6e7ASBWei/zbPHywlLsu/HNhUWRMSCPohc1iPGhj63X7zsMyHLs5tni48sLr6oHtr3ZsDSaf2LPqWTBg4EwPvSx/fp9dwFZid08WxydzF94ySDDYLC00bAExpLACdmuFwNheOjDmX73gnyx4rauGpzU5eO2ArK0I7USu1m2+Hq4P39hXj38t6TPCcdO12uVy86jR1cqI3fYvClh8us8IV+suK13j8qKyN9vJyCLZxoO3v09WYrdjJj9w68vL0yrh//6i3yQjt2q146FEr1Ik9DvFlaUiXd/eUK+WHGbUkL/k3clzGnrWlhts0DB5FJCCiW4vnBLoWErSwhZaEIWJ2makGZt09vJvDvz3v//B0+yDXiRjWUkI3M1nYyGgjHf0XdW6fiivPStH0iCGHfFQRGkE5GYwYIMrUVa0JsWxXuw8IO17HCdFUsBJMjIAocJNIqKbuohzUP4QgJbpgKaWXCSCSJBjPuqFRFE4kLM+HApLdYMG5Iy0Nxvmv0r5qEn7jHQ91uBIojq0WqYLvzpXqNo6MYSER7KjySwlT+eFDZBdSOIBDGczFFFEBPiEaPQtFjTkpRZ6hnrH+xLxxjUylJmL0BHbocerYppmECjaOjGBNWSE4YvsyTIuSieAnB0H0SCGM52DkUQSaSNZl+LNY1JGciNXI5G6DkdalltBIMgY48WYUqkUTR0F4VELGAWBNRKcPVUW4G3IKMFnv6CDxz1SZlkdtUh9ORBLBwKwnRSkEijaOiuRBSCBCkGAWD7VgY5EESCGCRmXODOGdtkNFq0DT39jEGgaur1qhM/qRxzhl5wLpvP1DuzEoTprPlwzS+kP0xGbIju4IFyJsRTap4Etq2zkHgF9ttBJIghi2VY4M4ZW/z+Xeb9AjCondyECoXQzckkgvRrcEBPWDrvNPOz6r9k6laiAg5dWsFNJmuI7l90z5x7S82TwLZ+eoJ2AwUzzWuog+gWuHPG1m5/O+t+ARjUTo+hb9u6OZ1EEDWKz+WPAFgtXPJhQRTAY1A9xVxplSG65Crf4RMeU/NEdRBlu9yTFEyCGCrpmgggnI4ZW/vzH2ZJUK6s4x7BptRBqpOS7Fkp/655Ba5C6O1R7fSI790zLN1KIOCCUnhy5Zd6RdPBSHhNzZOsX0nZcF0tBJQgFhEgOFNrC/bxttx0e/6DdmUdVyhU4o/q3oRPHp53busbW5shdPRwf2b9lyzdSpY+pBZY1zWcjITXxArJ+r3PAulpqXkwDwQZwrmQEGL2+ZXti9zUkqFFkOJxNQeqN0UXn5Y3do0EmUH/JUu3Eva5cUcj4fXrSdZvZ+M+0+xvbM8HQVQ4F4XEwKRYhvZdpiMZWgQpZMQM/FeAY+LHTxtGF2sWgjB3K2GfG3f8Bj8sCKhlo/c7n8B8EERFbGWQQAVb/YYTzVtKNltUJEOLIO/HY9KnV/PZGQfpWC3COjfuaCS8fv2/9zyIBmdMiC/ovaOht9SLRi+pSMZn1NrJp82oVAFHhVmmefF+KOPcuLOe8vj1JLAltTFPFiQcXhDS6dQr87HCX3cE/Rl8sSAuRzMv5g86vhUKl8h2sTPNjU8wEt6+ngQ2JRUiiuK8xCBawTadSr8Y4aat9V93j//kaEmGD7vLRBBk2TvWJwQnGAnmlfRlOGq3x925yWIhOAdCWg+q6i39urv7/Qc9ycwtQXhrycDARpHDlizPCUFUONPGYzmKBVn5ffeDzFuiLRk/CDK9Pmd9LoZqJd03SbSkeSEIgvODKXxQvaW/f6VezVQyeNR6MsVLUqhtMs7cBu5MegmNw/rN3BAEYBJQr2O/uD0JLV3RuyQN74ht7c/pDv3rd0IUpIsoSr/h8TyIZ8CsSrB39yPFqd6iSBAq3hFTC+J0hz7aFpL1W4HjZJWH5Ak9wCwJqGQ0+g+v3ZgoEoTG2n77ITZ4wywG0d+hSf/5mRuYi0LhNICZElC+9W/3glpyldolKXhHf6UT8Xg8xWql6u7QpP98bdfoev1+HA/eCDIdYIYEFCf8YJ/Fmt6CaPt14xFGvs74Dn+a9J+vj1twLYl348EbQaYETGe/eeEHe4JMXdscnfiIMPJHx3do1n/s9wXPmYtFD7AuJ/zwoQ4ybW1zmieckzm/P836j08LwjFBKALW4oMffhQKp6xtmk6dezcUDodk1Tu06D/2+4K9SuLkeqcNB38xCBXANrcAN4P/SjolC+KYf1Tv0Kr/mO8L9iiJrtQXy4XCGW8EoQNYMtpY5pYgXlMk7ARhOXXuUXKT848Y/cd6X7BH2I6zQLqSoxx2d7cAhnTPWyINyU18jkXNa4qEkiBwzzK3nDr3ZPvd5B8x+o/PSrq0DQodUHrHH0EslSTUjiGderEQ/uISR774wdluXsv5codXWUSPPhqMqWDb6IB+EZQkDgliNdyoC9OfkUQi5QpYzvjBF0HsbAXOrpCpNLf5R2eDwdSckMB2cAl29r6Wz3gniGK4B8JaIp5YS0RSLkKTTc74gUXNS4qEhiDoRBvY4Pwnjfwj241ZJLBdlYDcKB9UeCcIMtyLwtpaPC5E1oTY+Dkftnqmts8XP3CoeUqR0BAEi4rHMDgPu80/2kuP8caseWzagAx3THhQCPIgxEZPinLQM8t88QOHmqcUCQ1B0Kp44ILzsMv8o730WG/MIurN280FgiCaBRHi0DVYExYVB9dBzxB2oZgVQTylSDi1ILp9Vq7ibwfpsS6rk8AWzeTbpQAQREmcDwRIkIcHYaA9rdZWz8D4vBUEgnhKkXAag+iCczcRtpOVYL0xiwi2rcu62P/6xDtBhr3E4wlBEGKm552/5Dx/ZYuapxQJ0ywWDQvyctq382RBlFTKUT8AbX9Q4jyVHiQSEa3fvq2e4ZMfONQ8pUjoCIJCxQNj490HDk5WgvXGLELYPhcPMnnD+sqHUDtluZHP9FH8uH2wITVrsyaIVkn/Eh46uHZ6hlN+8Nb2Z6qKh52Nd596crQSjDdmEcHW3S8U1m/1TD3cOVcIsr/XfboUi0DeO+h0Do6XZkcQgyxHDq6NntnmlB/MCeLfVg0HG++6eOFsJdjW2Ukkkc8cfLMe+lQI0v8K/5Sz4FaEl9sK3c6MIHbeAF7P5K755AcONdTTUiTta2lzSQ4a6hBR1NlKcFNJv8TuB1cI0jj+lOtKSVAUIYNkMTsrgtjEkxBCTD7R+nxnnglShON8J39B4ZK8NUSkbHA4s+UKQVbXQ2KmB0Ct0JblRmhf/S+/ntsyUiE2GUltX4NJzySP3nK7IGzF0otOf0lfmx7MwuBwSJDdvWLpowQ9q9u9kLhebqj/5dOTv8YOA76mhVeYMD4/DB5BtqXpL+nrkdWg84kOQWQRrTX1gV+1LbBx5KcF0a1/7K4IvMLkNX/lLBa5vTf9JX1tenfY/A0AACAASURBVDArj4xWjEWHIMuhMUEA6IZaPsYg+vWPtSBYhck3P7CPYENDlIrTX9LJglhVL/UUrw/8oBhjTbl+5VIptFuqgHq/+/Q+cw3A+83tXqENfCSIXtzYGASnMDnnh90j2HqHWxQu6ZA1tape6kVCH/wrmjGW6/VbHA/dq10lylgHtfV8pr8Ll9zOhri3m/OTIIb1j8tiYRTmcpNvfuBQq6g3TKOSbps1tape+ttM2A+qMZbr9RsaDc62mhjhwCg8nMLsXHPNDxxqorI/YYtWHQSXNbWqXiaHpVgPqjFW8M+DmNY/xmU2K8xV/mWMKxQqBKlIVC6Jz/JYVS/79nBzY0G4/QIXm3GMCjO5XpkcmvJGkHZbbKADt8c3tAWh++1W1cvgsBRl9YiRHNX9i0TrVz685rF59eQyqx5GGJ9fTAxNuSNIvR66qdfrp/vblCWt/+1ULIivygYvOZr7F4meMJUviBshib+2PyQyweSvONx5gUFtfZmFpA2/3ap6yWMQX5WNneQo7kwhWb/1/e/S1Un9nDuCEAwMP3jceYFBbVnJ8G4tU5W06bdbVS9pFgu/ZBlZFXvJzaaSXmihf5v9ABMEV//gcecFBrV7pV3D9T1VSZt/u1X1ktVB8EuWlVXxQ3JEjeNaYO8WtDLBJUhuB1P/4HHnBa6SrmxPaBXcX+T6XaacdBaEtXP6dJV07JJl5sL6ITmS9XvaA43j3ulxgC2IfJ4bLoNR696AWBCpg/523Kunb+JFqy1ViCzItHEebsmyc2F5syDVLqjdS+VSUAlyojf5Sutexez7+rgJ76jVlS3SDfdp3mP0gf7OhBjE5W936SXhliy7ZeyH5OaxcZxt/PFtbPJR616toYOvj5vwjtpmpp7N1jOum3itiiib0q7bXHJVHc/wty/GBgvPcD5+1TJ9XhjEFmMQIrs3aNOlV4O/0Rj89zsAn7WvSL0Jo9cWB8+r0H6/1d6rmy5hp98N0+/a9K1++jqGbgvePXx1afyGnHX6GTvF/4x/KUFG8Tky+SsDYU0YDHXPLLuHu0et1Owfr7svg3wKbcK/X5Xt8ZhzB1F1ZOFvv3u8O4NTZGua6qtt6FBpU2SGGlH4FjjCL1611Veb8NUddXoAp1ntahDK3+idj49ncJntqi+eDRbDP9DHH8+iNQAutPdW0OkvdcAfda5NoR95qE2r6JF46kgq4lNGF3oy2vQQvhd+Fbr7c6W/gDJ6AFS06QUANW16DTHVprsQD216pAMCTg+Gv8Lj+uX1IZ6E+Sut8SJqujg0+/xX0smHRhAl54g5uTZaF0svT8+UqY4g69ChulNYoxLkTOHHHYRrfwJBQFtbsmOCRP/3YgUR5PEuSpsguU707AzdJh8EQVX03WbhyCdRU121uvyu2rp3DbXt5fbMEB41GRoC12jqXSyMBXFyMp4XUotvNL9LefV5sIicJAjXM+Zjbz/856c8elV+/fxaVjwozcVahS5sTHPjKLtYer+KGxfret0fglBNnuvrHxgLEgSCyI0Nsq4mboJ0m9jXnHZyjLMnV0r4c2FZrt8ryReC0E2eF3X1D5T7MMYggRBLo3+eef8136Oa5sWaaisdnNJFbmrt3LmwLNfvkS8xCO3keSmn594LQxYrGGJ510UN3nsElXQXhUKjqdZqgqNiRnr0ADv7RF8gT4wwWr9lNPLipR8EoZk8r8oYk59Kpzg2+7hCYQXkq+BJoi3psake+koa9rFIIj1CCEKWSq38tGqrQJ4YYbR+s3D8n71rbWsiWcKDJCG3GRhDsrlICMQTEsNlEYIgoECUOxiibABZeXR3n/P//8Hp7rl2T88tmcl0c3b8oK6ZuFb1W2+91dVdFzebwjgAEsz0OlV/dE6Ij/kfghu9WwAZnHaEpXrAnjaoWs+VlIQKcGzGRBqJh6cJmiZk/sRI9PXEKBnEg5KH+py9Ax/+rba3JOxUKtWg56Qbhu7puRJKqDIgBzXluHaacAQG4UKZ+Fm/Q52KHlqDTHiaoO2q5BE+uLtq08ZqK+etoL9Sp+qebKx0EFBKuYxkilC2mnB4DcJH1PKzfpVT0W/G083rpf/Dg5KH+OibP8ZHQWV84w90BlEIRM2VEi8+lrAc157Rh733hJOo5d0TS0vVC7hTeLg8Hld7KJ6734CG5jubP8ZJskVa7cr45fFWwBpEpeq4jOVKhG0dNOFwN2fxckGw9/VbLidhn8n+6dZ4AOIh1jt4TQXCm1dLi+aP8ZJskVb7/egTKo5MdTfazWA9rVH1DJ4rETmuUywa6u5FXi4I9nXkdjvkvyA4I+tA2F7EPsbLveYWq3VPq7X9o3q1vrsWtKc1qiZyJTzHDaaz3AQlXi4I5rqbNzHZK8aeKF5T+PvxUfkDw7nc3GtOsdp2c+nT5WoiBEckXvz6CdctkSvhOa7PMwFU+jf/BbauYEwk+lm/h6hN8dMGMwB53ZNlOVe0eg1Z//H2tqdYX3cuN/eaj3VGob5uTQHeulPkq6GKKvUwirKjJNZEoq8z6cqhzzYrAIEGBwiRrVENAgHg414DguZcnhkktK+klaFoy9RHaKdKPaIgTKck5kSiH09UlGsDWLm0ARl8AFxrrcADIEB8TOtAUJ3L4unaqAFC28gYcZnSK1TkliKNktirbfnxxGc0enBumRGAOOzhJiYRPqx2ZvB0bdQAoZhx1GVKJ2pLUwqFktijeD+eaFZfzc+/qjYZAYhTF1D37u6efsE/H0cTxggQihlHXaZ0qeelKYU9kejLE92vtfZZXmAEIE4G7+/eQyDMWCv0XO+k91vbgXuaYsaZkhSfHmGZ0gHmpSmFbwZRH1au/XE0eL8PgMDhdCR7q3Uuhf7XZG0ndA2SeIjnRLEnDb9MMalnRCQPTSmmNxmJZH7X79TNMjMDdEiDaybNq6cHvTiEUT6hWK2+KjTrm7uBjz+wbBCmYGlQFEVpeKlsknrmepiHgKW/yUq519/63dmoHO2yc3EcbnDNpHl09YUnSme2M4titcqxcNAJ4cAUYca0JOYAXGQxlykOX8vQpR5eD/PQlKK+GXa513Nk9LF+jy/K7bfVd9HLTVN6YDK4ZtIP2v0M7qIwLZVibJ67pR25/dYvd4V3jeABgm0QTpZEEFYAQnK5VHrkBThEPQy9GXa513tk9L5+/6htdPsCWwDBsldk0j8fb7X7GVzPuiVSIJEAyTbNCxEPP6ZYba5xVJ4VLr+GABBMJcdExLtirBRAIcmP6DYH9ZDFug9+8r5+qx14qx+zAFFN+nh799eie5ULPQ8gmRgURDFm9ULU8p5mtfO9Y0GYb4YLkJkJCQFkQLOK/8dH2RYL6uGWe/3wk/f1u3XQ+Ly0xixAFJP+c3v7Y8ZLlQuaaTqnLIXMxIyL/Ge+dhIgg8R7ECEFsRREduOdCfCgTn0vsIqKH37y44mTy6/V6tIUmwDRGOTe+Ee7LPMXRRQrwVqYIOwU/VU2pNWWjCdcgCQmAYWIhUJODESZee7tIYI67b3gKip++Mnn+t3crVeyjGqQiek/CZOSiRIegmaKGSXdlp8I70V/lQ1ptbLxhExKaWkiBv7hYiqYyoXX3h7LqCvLewHWtcJiEPT0m2wCBBjw8fYfwoC41CZCENSjIFaCYPlA4Cf6q2wiS7EcbsAaul7kpbfHEtTJ94Ksa/npWX1G4w8+3N7d27oCLP4HIgTBbKIH61ipBIEf9hhknF8Z8Oapt6+jXHeKvxdoXctHz+rzAUg+m/3L1hVw8RfgPU/msIGuII2VVDOZKJw9DQKf45vdDnjYj1ShBPVg61ree1afDUBo82ux/FUCibWEhyCzmTAKZ7GKtVM7qi43GmfPEyCuQT3gnZEwdtKZ8IvdBp6GD20HF/v3o8Uvwfvcp4n5ksbHcAcwuA/yeU6ofTnJ3jxTgLgF9ajOunEGELuF2+8o+FB1hEWOg8UfB4JcjNuGIILC2dtJr70XGu+EVvm5AsQtqEd01o0vgNinPlNXi4aOWFjA5biy+OFIEMk2BLF1EoFitfY74agptGpROSLyxudozrqNaLZ8tp6EzQ/np+0k6vI92K+0s5shAcROPK+ZU6lU6kkUX2JsrCx+JEJsQxBbx9UpVju8Fnb3L5aj0iAMND5HAtERzdbdPUcA+TB3qQDkOv99NVvuhwMQm/Jr/rCLsUBcFOMYGYDF/xSXgEwXi/Y+Zuq4OsVqX1rCydvlw5XxeJpcjPzd/81MBpRU2ue+J/VzIq3k+3AAQt/A2/n9c2fdrCMkpVxlkuPpBRHQh7jw4BSCWDquHuU+CMYXqhazbNNxPFQtcoCcdMrqoFDKcNXgGWTp7u6HrOh2OwZBAAHPQprtLJsZgOh8QQydMjpB9ITruSMlcIDc1JJHGoFQxnMHrkH+C/Ahqrpd1REWDQLi30uQYr3kJ/5R3JKsVv1NuR3e0zpfSDm1KELU+IyEayRpwgO4AgfI1Pt8djkkBqFUsXYAPgo6ZlQdEVvA5YR9/OPILU3wnO/WL8fgad1eOS0g4RY0Eq6RpAkXoyjC0CCztQ9hJQuWfZC/ED70rEs70YzJid9+ZWJP1PjHn1s+ZMfgaY0vYnJOS2mxGp8Bl9QIHYR86P5QAFKZDy2bJjfwPt6LmG6n7KQDUMlyLkaJfwn+3PK+NkYGKcm6cbEanzEnuui8eeSUQ3EyQWfE9XvSaiX3WivCdqubvGqtCV8+ra5sHTbWQpWb+tOa9dB4q11xHbPGvxfM5sB2Vjvp7I9Fgyh8QYwt1ElZt2Cp5NhB6JhDcXKR+IjrdwfJ8FfCPPp5TnjzR7ta3whro5B48tndWdfGW/SBAhyTYI1/08zmwBSrNeBTrTXH4WmNL3om45rYQN9UTTkucuccyqT7WRbrHHfzKv2Jbo23CsUUQJZVIuJfTCwxmwNTrDYPng/d7fE4QuULO+PqCZdT+4FLDmUwyAPLYp1fgGj9uy6Nt+rm4kCUf+Lxz1IMfh5uKUMq3wW/WMnW2p3ZYb9SDep2xtUSLqf2A5ccyqAhpsU6VwAxK3Tj/Idz4y1FpCheLYkxdnNg0mot43EDyMXa2tqJIPSPzlrf6m9HdYSdcbWsyKH9wO2IkwauFNNinSeAmMOZ4/koiwYh58NArz71GB7HRlotWU163Cgs7yk/d6tvBOGqMhW2p+31g6sKT6eKpdjkA9tinSOAYAnx+w1v+KC3yEOvMl1FIa22srLS3L9uta733UR6ud5YvphV5xxtJ5XL4APfsfXCOQ790egzIEyVSinW50byAxCCCtYWPQOLnkczPY6NdqIQtSx33eZ77eVbl+0DQTg4hb+rKFu2Qff8eLO2rUBBn+mVFOnxL4P4/gvorG2IiV/nm57fh79ex4e3JshSDB9ucZoQqQAAPKvot+fJbRUg1aswGMRB9WF8rQsU3KPqZ+QFJT6xPTeSQYDYbC+p5aiCLN/f3T54fJ/4Lvy3DI9jo1hteQMkTrMbVAZZ21QfpWr1JrmFp1gB57r2dUOC5lVg4GZXPgP8mHtSqrxMz41kDyB220vqhgbCxw8Ha2rvw7MfxHeRX53gaSd9td0+O2u3Vz283U2uhCjSbXeegDn/zokDS2MDYXbFkSJqbkDSg+m5kcwBxHZ7SZn6nIP4uH9pz8fq+5JYAEErRVz4WuRjCDTdaifXnc71icuLW3ut71f1rFLm3Rm9zOtKEmbmLsJVj4jefKRtPY56RXWzK6kAbG5YUKXHvzvpPh774hKMXCLAx939tIOiM58/J7Y6OOn+Gcktq58blaM5CKOVbKXxdjZ4T9t1v6WlnpjLwa63AvaHr3uy0iuqmV35AhDqIIMwH62YA4hD1Q+25T4CfEhS3L4miN6fVm4wkeTMtOm7GC8oOlmtuY7Og8Anak/bXFwM6DkjFiAvyLmBiV5eo05RCAbN7CoFgf/OpPQg6IwjBoHVk5+DHz8yoihmio4MEhdBMJPIs7ccM0hyTVDrVNWoAWLDIOpoKgQHk0ABaIDj3KAi182uipicxKL0IEtEDGoQp6pfYjKDbmSXB2mn90uyQuuZnOQydOL/h9hD1iDaaCokQ4wSF4ATTKZgPqWYPWGM5/YiPcYtTywlIharWBN2pab8/GJ6IItwbJr9/CPwflFWaZ1o2E0zXVD0YrVtBjBnrWIpjQnqcMNcqffxNywhQ3mXnEFmVwL0jMd7KxMPTxNjbfS11nHY3AdZwDYrNBPls9n8i2IGDd50SJPSk8ghMG4VU3gFkemCoovVPl0Jwkay3oocIJZ9EMVFKTSPaACyX3PsQgkZPGwgx9OC32O2cGS7mImNMaJZs3DWd9JNFkX9iUBox6W4s9AGTlGVYTFNUDQvl9TQxkBvCd8a35QN8oizNmIukXbfa0/MgR8lfIQRSsgGotxbF/wW2tHIdpAtSOPLia11HMZ7sUwWVfp3vQhtROuo4Pi3wOlDazU5FjoHwmaDAYDQXZSaLAJ8FAmCxhIyX2USdWT7QOyNr6rCB4NQ/4evlP52J6GtBTZE61CoRDYgKgyr1beE/Sths8YaQLAj/v+xErQ5IfNVaDdGtktePh4Q2ifY1yBUyiucqec/7IW27onoB0SFYbW35dP2iXC1zBpAXBe9KSHzxSABj2wfrkTECYNMx0o32vkPO6Ft4vLIB0SFYbX1vQ4Q6HuXrAHEz6L3VWgPeGT7UCUiDjQItKhUyImx1EeVvelCG6ONqAdERWy1MWsQH4veT6E94JHtw5SI2AeIMmjz/vZ/7F0LUxrLEp4YlE0EcxXIARbWDXsuiotAUFwBUV6CT8RokpMilVTuTd3//xPuzuxDiKCzK48Z6K8qkaSqbbZ7v+mZnpnu9Q+rgUB4WILWep7BDd7RNxb4yGMNs9rxnbKLjrZZI4iz3SUnifYxt2xnzGzjUqBbFJ9P9OtL7tXwYyfY2ySUvc25qAc71Gq36qV4gzZz7Hna0e6SkwFqzC3b55MgaKWj82PV/xVnMx6F8YdtErre5rz0gRlitfo2km+QpjLo6YlFZQbCPXsE+dMoofN/vq0Zi7VH++d92yQfu+v4rs7TqStuboQM2wfZxQQpicx6ej7BHEH+nAOFfOc/ltfIu+9/dMq9rzrfm6/4GOkzqStuzvOOjCBbaSDIQhPEngOZceSvvG/rNUmI4y7ngy/2ytKJVTzZuqvzTOqKmxshw0qPKtfy9aV8PfcEYSuNwhhBrDlQJGLFkexxQifNagCfyRmcGuG6SoHVNaORBT7jGwi8X/74pJ15jiCoExUE9/1zuCEIY2kUxghivsFr/oAHx5F/WzYLB3QqDC6uSaxZXcf9On/6SZ3+r/7Vhxd/qJ25uREy3GrZLEI7c04Q1tIojBHEnAN1SZ/aje+fi2aT1aVfa+HBFs5GrFnzr69uLEcCZkkgf+RfT9uZlxsho6yWzc/5Ip25NAqTEWTZT+7Kfv/8zw9jRxyHg1c/BxLiVqxZDUQ8P1f9Rgn3QHjpGTtzciPkkdUO91RlayUunh7PN0GYmwQztwYhR0sCge47wg/jTNXvIeHgoQ3OydKSx2CIP/Bm5Tk7c7qTnlcKdenLeYhhT48FzKVR2Mti6XMgD55hff/8+ce6USvOH3kcDvopsPK6+8dNdY4KmNBZLXqPboQC054eS+YKIghFEuODJ9J9R/ixbpTpIxXG7B6cZpvOh/X2ytKJp7vq9we+/s1duorWarhOoqjNK0EeMirMpVHY3EnX48i3zz/8Vhfi9VcP4cC2pb3exv8TjkRwKX3+0lXUBMkiJPfmlCD9GRXW0iiMnsV6+zryDRdU8hsEiawtvzPCQZ8trZ7o5H/CnpOBpQU/BUzorCZ8qdWks5oOPglC3xCasTQKmwTR/nrr6Xo2AoQh78kZki7ZJhywJTH6qHwVNwVM6KwWs8ElQZw0hIad9GcR8l3+D7/2HuN4lf4Hl8vo6uHg8dpi5GqDlwIm03LLLAlC3RB6ITzxYgUhn++/xmvvMYryBfBtkEDk7YAtzTtRvOerFoEg1A2hl4AgdPzYsl/77uuIUUrRQ27uP9jyl3mrlvd81SIQhLYh9Hw15J6UAlL/6sGkb7pmcSQSImxbrgXMugy856sWgSC0DaEncClx/ghi1IfTX/sNfZG98eqNXRzJqP1i2bJrl2jgPF8FEWR0RmU4E6Z73Jc5gmg1Ut/nLSnQvh45ebVhhJBA9/VHs3mwbsv/9F2w5TtftRhrkOei/FAqDGfClI/7sjfFapH6V38HjArUvzzLpPaLP+D53Vc0f6BEA9f5qkUgiLtdqeFMmPZxX7YIEto1P+AqV+9xw6KIPvisdf3+QOR3fzU4uhINQBBGCOImyo9gwrSTMkwRJOTbyxqf+pqik9OL3fBJt7+e6BxUF10ogriI8iOYMO20/pjMdpuW5bsGMvuENd0pMNbnBH1TKDz4hCPhrnXuxIgZ/FcXXSyCOMcIJnAaQbYb+/tlSUNZHZvCjSsFffwYmELhw7rh5Q/rBkOswnDcVxcFgriKINNO64/TbEmjokDt3JWCfn4MTqHIbNRjtuC2Vx1/UbbxAoLwSZBRTJhyWn98Zvt0bdxXyEr2rdCg1+ttUSrI9PNjcApFxpJ3ftKBe25XHUCQRwv7EUwYtuCf3Gg5LrNpspRskE/NpN29Pk5WJHQK2uV+fgxMoYzZqIeiMBwQZI4IMjL19XjBP8H59rjMFixlyiqJIPU8chNBUDCBRgwKS30nFyMLwQ/nbrm8E43mbLs+WS3gIUrLiUo8wTNBqFNfk8zYjNNs51W8lBBS41ZgzUbDy3O86nihW+JHBUKQT/Xz1L2ij1FedU+7kI+4JgglJprzHytB8GWe2On4Fczlcatxu2WTEKSBL69fi150i2e6TSWxAASZ6K7xmMxWDvW0snSv/z75dgIK5vG41WQIEsfFrQ+FIor59A8pobcABKFsDTNTglSjonqu8wN1RO8kFMzhcavJEMTooy4eozM8390RDpwvBiGCTDW3AVX3J2c1I0uoI/MHQaTrQYI4SScyvyTndw0CBJmy1bL7JoLPTLF4iCAvuObBSxYLCAKL9BckYl5wzYODfRAgyGyttpuKy6lUm6R5i3aaN8lNmveF1zzY30kHgszWajGyyijijUIxmedvo5DZ2htAkHmZYvHtCGarNwFBgCAQQYAgQBDm1yCMVm8CggBBmACrx4mAIEAQRhjC5nEiIAgQhJVZFpPHiYAgQBAAEATcAo4AgoBbwBFAEHALOAIIAm4BggBBAEAQIIiuoOUFOEVrEgQBR7DhiUG0BIAbtMAR8+qJQay0aJnacs3x1pQFp6CytTJhR7h/+FnYbYZft7XC+1zPtSRXKhmaW8/Abrx9XSAIEAQIAgQBggBBmEEwHpy2JFcq2bH3LOzG29cFAAAAAAAAAAAAAF4xukHuUwj5FGFb/3lxphoNSaoVUfXt0wu284pYx5XoSzVVtrpPP4XmqazWiIJ9X1I+3UUoh7/wHv0T4m8p4FJunZwsHM7K3qROr4pQIq6IOY1azLKbLRbMq7Kv5UCSlO46dSJpm9y5UlvUsVbLW851TgijG+Q+hUb5glj9OH5lEKQT6mV80U/UgtVKsdeRtlG7UtO02unz26Vnm1rKF23rjEqWUzcNnVK5qv6VvfRPqH9KK5ggR83mDAlSx5bWXyH5QttTqPOYlt1ssbxynzpPf6KXjH3R9eLHppa0Te5cqS3qWKvlLec6J4mhDXKfAbE6Qr2HllYpoUQtWL/U/0rH0b3kxdWe76lUZoUQQnsx81+5gsMn3FG0qFEMtDhDgqTJj4SiB+tgsuPQ4LaYV7rWH0i6p3dVrGb8w5EkMbk7pYa33GlNXrnUORkMaZDrhiDtQjRILZg/3UkU5RDalnSZthSnUlkSNLQiX56pp/hX5FS1XvDSP+HK+RZigCCyEt27QTfEbL6YQ4PbYsYTpOMOCJJUK9UsciZJTO5OKRF1pRV7y6XOSWBog1znBLmVhXqJXjAYEyRR52M2WWi380KVRjDhu8PjknyUauLBqXOvXUfP6J+weZZggCCNC+0+px4eCDvIaifiwOC22LFIZjJVeotfN7TtdD3oTJKY3J1SIupCq+EtdzongqENcp0TxFsK+dL0EeSosp3akvXAeV8RpFiaSnM+2sJNafC63GcuzjOkeQ3VE2ZU3eSzJwiJterRmAiSd+IqPFW5cCZJTO5OKRF1odXwljudE8PQBrmO1yBB+ZhWsC017PdDX8OpNNmzvILb0QQlvHop35nDFJ6h0j3hkSBJkiBFGSCI7u/pT7EIKk1HkobJXSk1RF1pxd5iaIpFvtCwBrnOCSJu0gp6hUbfAFoUnk8QJ/KKMYO7w9+1ZkYQDc+16J7wUNOhlPcZIEhQiU9/kY5xqHuIXtIyuQultrecazW8xc4ifXSD3CcnCamUcJTaRYephnCdyqKbZmb3oJbMUgvm6sXepqhr3DwoHScp8lH5ZCibzbYRupA6pS0phErxTK9Rp8j/2U+IzClWNnUlhFIzokgh1Dvwybv6gs9Rmteymy2WV4p02U9Tsl046BXvHEnaJneu1BJ1rtXylnOdE8LoBrlPoUi2FWNok/yMo50vqqTs7dMLZmOKWD9K6AZRpcpRgmIUJMAh6qoipvUhsZVLipXCoYMntAgSt3/VDLCnSEpNc7xRaNmtb/8sKVLtn5mS7TNVisZaTiRtkztXaok612p5y7lOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AP4epB1Z2Y4eiOPSD4csQOAI3hGTBCkaKE9yi/ew6ecAH4BR8y9X75kW8eicWL/42O/PO0E8As4Yu79gkN3VdGdcBUVEt6qKp9jWzdVuVo2I/tKsyJGL8kZthxCm3WjokkmLZ5emH4pk8P26TjKnKnJXMbwCzmWnhJ6CB3kRAWPjbcVUa2BycER3PmloKK4fJZKJe58mVJBPUTX4tV+WTb9Uk5ulkJXKCMUI1nbTAAAAgRJREFUs4eoo1z0LpKbqK3uaY2K6RcNV3zQhH1UPN7fr6reQb9o8lHpIB1DGel4N7UFJgdH8OaXjLqH4hK+nU8utlc66A6H+lPDL17xqi+MR/HFw8s71EnikciK7On/t3dHu6nCAACGeycPoFlCtWtmwg6DCVPARcWco84ZdEu2md34/u+xFsSNvQE5/3dp0Iv+SUtJqPt69hLiXa+bXfp/zac91S08/umPEK3rorRU/yIxyO16rrSh5sKzL1ykVZeRc/ruEjnSXCEDkdpThvy6y2YlblwzJ0Xj3NPOW7PLyn5FO0knDPrLZ4acEK3qspvdP9Qbwc1wZkWNLtNml6W94vSry9YZZXbm+3xaT2fBouzSs11s1FVa/mpXXB3nef7ImBOibbe+dZejOr+sX67sH1WX7nllvysPIRnuqyvKlf318vAkTsf2HXV78sPWqbok9milV9Nl8uNIu2dVMOaEaGuXm4/weMrmo3JvOKj3hgOzN8wO4kruo444yNtker1o7g3N+A8De08c7pIsllWXB3eSrFemiy/H/uzPWKxv/fs3NWXMCdHWLqKTDpU72ZrdX6D7l6eLe1e5GyEOroqFWIbSi83sk4UyLC5dHqW2N7X+k8wLd3E+ByqUcWFvC0Y7rc3usRd7MnxhyAkBAAAAAAAAAAAAAAAAAAAAAAAAAAD+C1/J9xP4utBGtQAAAABJRU5ErkJggg==" style="width: 600.0px; height: 300.0px;"> </a> <p>The plot on the left shows the actual values vs predicted values. For a noise-free regression task aiming to predict the (conditional) expectation of <code>y</code>, a perfect regression model would display data points on the diagonal defined by predicted equal to actual values. The further away from this optimal line, the larger the error of the model. In a more realistic setting with irreducible noise, that is, when not all the variations of <code>y</code> can be explained by features in <code>X</code>, then the best model would lead to a cloud of points densely arranged around the diagonal.</p> <p>Note that the above only holds when the predicted values is the expected value of <code>y</code> given <code>X</code>. This is typically the case for regression models that minimize the mean squared error objective function or more generally the <a class="reference internal" href="#mean-tweedie-deviance"><span class="std std-ref">mean Tweedie deviance</span></a> for any value of its “power” parameter.</p> <p>When plotting the predictions of an estimator that predicts a quantile of <code>y</code> given <code>X</code>, e.g. <a class="reference internal" href="generated/sklearn.linear_model.quantileregressor.html#sklearn.linear_model.QuantileRegressor" title="sklearn.linear_model.QuantileRegressor"><code>QuantileRegressor</code></a> or any other model minimizing the <a class="reference internal" href="#pinball-loss"><span class="std std-ref">pinball loss</span></a>, a fraction of the points are either expected to lie above or below the diagonal depending on the estimated quantile level.</p> <p>All in all, while intuitive to read, this plot does not really inform us on what to do to obtain a better model.</p> <p>The right-hand side plot shows the residuals (i.e. the difference between the actual and the predicted values) vs. the predicted values.</p> <p>This plot makes it easier to visualize if the residuals follow and <a class="reference external" href="https://en.wikipedia.org/wiki/Homoscedasticity_and_heteroscedasticity">homoscedastic or heteroschedastic</a> distribution.</p> <p>In particular, if the true distribution of <code>y|X</code> is Poisson or Gamma distributed, it is expected that the variance of the residuals of the optimal model would grow with the predicted value of <code>E[y|X]</code> (either linearly for Poisson or quadratically for Gamma).</p> <p>When fitting a linear least squares regression model (see <a class="reference internal" href="generated/sklearn.linear_model.linearregression.html#sklearn.linear_model.LinearRegression" title="sklearn.linear_model.LinearRegression"><code>LinearRegression</code></a> and <a class="reference internal" href="generated/sklearn.linear_model.ridge.html#sklearn.linear_model.Ridge" title="sklearn.linear_model.Ridge"><code>Ridge</code></a>), we can use this plot to check if some of the <a class="reference external" href="https://en.wikipedia.org/wiki/Ordinary_least_squares#Assumptions">model assumptions</a> are met, in particular that the residuals should be uncorrelated, their expected value should be null and that their variance should be constant (homoschedasticity).</p> <p>If this is not the case, and in particular if the residuals plot show some banana-shaped structure, this is a hint that the model is likely mis-specified and that non-linear feature engineering or switching to a non-linear regression model might be useful.</p> <p>Refer to the example below to see a model evaluation that makes use of this display.</p> <h4 class="rubric">Examples</h4> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/compose/plot_transformed_target.html#sphx-glr-auto-examples-compose-plot-transformed-target-py"><span class="std std-ref">Effect of transforming the targets in regression model</span></a> for an example on how to use <a class="reference internal" href="generated/sklearn.metrics.predictionerrordisplay.html#sklearn.metrics.PredictionErrorDisplay" title="sklearn.metrics.PredictionErrorDisplay"><code>PredictionErrorDisplay</code></a> to visualize the prediction quality improvement of a regression model obtained by transforming the target before learning.</li> </ul> </section> </section> <section id="clustering-metrics"> <h2 id="id65">
<span class="section-number">3.4.7. </span>Clustering metrics</h2> <p>The <a class="reference internal" href="https://scikit-learn.org/1.6/api/sklearn.metrics.html#module-sklearn.metrics" title="sklearn.metrics"><code>sklearn.metrics</code></a> module implements several loss, score, and utility functions to measure clustering performance. For more information see the <a class="reference internal" href="clustering.html#clustering-evaluation"><span class="std std-ref">Clustering performance evaluation</span></a> section for instance clustering, and <a class="reference internal" href="biclustering.html#biclustering-evaluation"><span class="std std-ref">Biclustering evaluation</span></a> for biclustering.</p> </section> <section id="dummy-estimators"> <h2 id="id66">
<span class="section-number">3.4.8. </span>Dummy estimators</h2> <p>When doing supervised learning, a simple sanity check consists of comparing one’s estimator against simple rules of thumb. <a class="reference internal" href="generated/sklearn.dummy.dummyclassifier.html#sklearn.dummy.DummyClassifier" title="sklearn.dummy.DummyClassifier"><code>DummyClassifier</code></a> implements several such simple strategies for classification:</p> <ul class="simple"> <li>
<code>stratified</code> generates random predictions by respecting the training set class distribution.</li> <li>
<code>most_frequent</code> always predicts the most frequent label in the training set.</li> <li>
<code>prior</code> always predicts the class that maximizes the class prior (like <code>most_frequent</code>) and <code>predict_proba</code> returns the class prior.</li> <li>
<code>uniform</code> generates predictions uniformly at random.</li> <li>
<dl class="simple"> <dt>
<code>constant</code> always predicts a constant label that is provided by the user.</dt>
<dd>
<p>A major motivation of this method is F1-scoring, when the positive class is in the minority.</p> </dd> </dl> </li> </ul> <p>Note that with all these strategies, the <code>predict</code> method completely ignores the input data!</p> <p>To illustrate <a class="reference internal" href="generated/sklearn.dummy.dummyclassifier.html#sklearn.dummy.DummyClassifier" title="sklearn.dummy.DummyClassifier"><code>DummyClassifier</code></a>, first let’s create an imbalanced dataset:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import load_iris
&gt;&gt;&gt; from sklearn.model_selection import train_test_split
&gt;&gt;&gt; X, y = load_iris(return_X_y=True)
&gt;&gt;&gt; y[y != 1] = -1
&gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)
</pre> <p>Next, let’s compare the accuracy of <code>SVC</code> and <code>most_frequent</code>:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.dummy import DummyClassifier
&gt;&gt;&gt; from sklearn.svm import SVC
&gt;&gt;&gt; clf = SVC(kernel='linear', C=1).fit(X_train, y_train)
&gt;&gt;&gt; clf.score(X_test, y_test)
0.63...
&gt;&gt;&gt; clf = DummyClassifier(strategy='most_frequent', random_state=0)
&gt;&gt;&gt; clf.fit(X_train, y_train)
DummyClassifier(random_state=0, strategy='most_frequent')
&gt;&gt;&gt; clf.score(X_test, y_test)
0.57...
</pre> <p>We see that <code>SVC</code> doesn’t do much better than a dummy classifier. Now, let’s change the kernel:</p> <pre data-language="python">&gt;&gt;&gt; clf = SVC(kernel='rbf', C=1).fit(X_train, y_train)
&gt;&gt;&gt; clf.score(X_test, y_test)
0.94...
</pre> <p>We see that the accuracy was boosted to almost 100%. A cross validation strategy is recommended for a better estimate of the accuracy, if it is not too CPU costly. For more information see the <a class="reference internal" href="cross_validation.html#cross-validation"><span class="std std-ref">Cross-validation: evaluating estimator performance</span></a> section. Moreover if you want to optimize over the parameter space, it is highly recommended to use an appropriate methodology; see the <a class="reference internal" href="grid_search.html#grid-search"><span class="std std-ref">Tuning the hyper-parameters of an estimator</span></a> section for details.</p> <p>More generally, when the accuracy of a classifier is too close to random, it probably means that something went wrong: features are not helpful, a hyperparameter is not correctly tuned, the classifier is suffering from class imbalance, etc…</p> <p><a class="reference internal" href="generated/sklearn.dummy.dummyregressor.html#sklearn.dummy.DummyRegressor" title="sklearn.dummy.DummyRegressor"><code>DummyRegressor</code></a> also implements four simple rules of thumb for regression:</p> <ul class="simple"> <li>
<code>mean</code> always predicts the mean of the training targets.</li> <li>
<code>median</code> always predicts the median of the training targets.</li> <li>
<code>quantile</code> always predicts a user provided quantile of the training targets.</li> <li>
<code>constant</code> always predicts a constant value that is provided by the user.</li> </ul> <p>In all these strategies, the <code>predict</code> method completely ignores the input data.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/model_evaluation.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/model_evaluation.html</a>
  </p>
</div>
