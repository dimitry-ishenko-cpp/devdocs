<section id="preprocessing-data"> <h1 id="preprocessing">6.3. Preprocessing data</h1> <p>The <code>sklearn.preprocessing</code> package provides several common utility functions and transformer classes to change raw feature vectors into a representation that is more suitable for the downstream estimators.</p> <p>In general, learning algorithms benefit from standardization of the data set. If some outliers are present in the set, robust scalers or transformers are more appropriate. The behaviors of the different scalers, transformers, and normalizers on a dataset containing marginal outliers is highlighted in <a class="reference internal" href="../auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py"><span class="std std-ref">Compare the effect of different scalers on data with outliers</span></a>.</p> <section id="standardization-or-mean-removal-and-variance-scaling"> <h2 id="preprocessing-scaler">
<span class="section-number">6.3.1. </span>Standardization, or mean removal and variance scaling</h2> <p><strong>Standardization</strong> of datasets is a <strong>common requirement for many machine learning estimators</strong> implemented in scikit-learn; they might behave badly if the individual features do not more or less look like standard normally distributed data: Gaussian with <strong>zero mean and unit variance</strong>.</p> <p>In practice we often ignore the shape of the distribution and just transform the data to center it by removing the mean value of each feature, then scale it by dividing non-constant features by their standard deviation.</p> <p>For instance, many elements used in the objective function of a learning algorithm (such as the RBF kernel of Support Vector Machines or the l1 and l2 regularizers of linear models) may assume that all features are centered around zero or have variance in the same order. If a feature has a variance that is orders of magnitude larger than others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected.</p> <p>The <a class="reference internal" href="classes.html#module-sklearn.preprocessing" title="sklearn.preprocessing"><code>preprocessing</code></a> module provides the <a class="reference internal" href="generated/sklearn.preprocessing.standardscaler.html#sklearn.preprocessing.StandardScaler" title="sklearn.preprocessing.StandardScaler"><code>StandardScaler</code></a> utility class, which is a quick and easy way to perform the following operation on an array-like dataset:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import preprocessing
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X_train = np.array([[ 1., -1.,  2.],
...                     [ 2.,  0.,  0.],
...                     [ 0.,  1., -1.]])
&gt;&gt;&gt; scaler = preprocessing.StandardScaler().fit(X_train)
&gt;&gt;&gt; scaler
StandardScaler()

&gt;&gt;&gt; scaler.mean_
array([1. ..., 0. ..., 0.33...])

&gt;&gt;&gt; scaler.scale_
array([0.81..., 0.81..., 1.24...])

&gt;&gt;&gt; X_scaled = scaler.transform(X_train)
&gt;&gt;&gt; X_scaled
array([[ 0.  ..., -1.22...,  1.33...],
       [ 1.22...,  0.  ..., -0.26...],
       [-1.22...,  1.22..., -1.06...]])
</pre> <p>Scaled data has zero mean and unit variance:</p> <pre data-language="python">&gt;&gt;&gt; X_scaled.mean(axis=0)
array([0., 0., 0.])

&gt;&gt;&gt; X_scaled.std(axis=0)
array([1., 1., 1.])
</pre> <p>This class implements the <code>Transformer</code> API to compute the mean and standard deviation on a training set so as to be able to later re-apply the same transformation on the testing set. This class is hence suitable for use in the early steps of a <a class="reference internal" href="generated/sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import make_classification
&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression
&gt;&gt;&gt; from sklearn.model_selection import train_test_split
&gt;&gt;&gt; from sklearn.pipeline import make_pipeline
&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler

&gt;&gt;&gt; X, y = make_classification(random_state=42)
&gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)
&gt;&gt;&gt; pipe = make_pipeline(StandardScaler(), LogisticRegression())
&gt;&gt;&gt; pipe.fit(X_train, y_train)  # apply scaling on training data
Pipeline(steps=[('standardscaler', StandardScaler()),
                ('logisticregression', LogisticRegression())])

&gt;&gt;&gt; pipe.score(X_test, y_test)  # apply scaling on testing data, without leaking training data.
0.96
</pre> <p>It is possible to disable either centering or scaling by either passing <code>with_mean=False</code> or <code>with_std=False</code> to the constructor of <a class="reference internal" href="generated/sklearn.preprocessing.standardscaler.html#sklearn.preprocessing.StandardScaler" title="sklearn.preprocessing.StandardScaler"><code>StandardScaler</code></a>.</p> <section id="scaling-features-to-a-range"> <h3>
<span class="section-number">6.3.1.1. </span>Scaling features to a range</h3> <p>An alternative standardization is scaling features to lie between a given minimum and maximum value, often between zero and one, or so that the maximum absolute value of each feature is scaled to unit size. This can be achieved using <a class="reference internal" href="generated/sklearn.preprocessing.minmaxscaler.html#sklearn.preprocessing.MinMaxScaler" title="sklearn.preprocessing.MinMaxScaler"><code>MinMaxScaler</code></a> or <a class="reference internal" href="generated/sklearn.preprocessing.maxabsscaler.html#sklearn.preprocessing.MaxAbsScaler" title="sklearn.preprocessing.MaxAbsScaler"><code>MaxAbsScaler</code></a>, respectively.</p> <p>The motivation to use this scaling include robustness to very small standard deviations of features and preserving zero entries in sparse data.</p> <p>Here is an example to scale a toy data matrix to the <code>[0, 1]</code> range:</p> <pre data-language="python">&gt;&gt;&gt; X_train = np.array([[ 1., -1.,  2.],
...                     [ 2.,  0.,  0.],
...                     [ 0.,  1., -1.]])
...
&gt;&gt;&gt; min_max_scaler = preprocessing.MinMaxScaler()
&gt;&gt;&gt; X_train_minmax = min_max_scaler.fit_transform(X_train)
&gt;&gt;&gt; X_train_minmax
array([[0.5       , 0.        , 1.        ],
       [1.        , 0.5       , 0.33333333],
       [0.        , 1.        , 0.        ]])
</pre> <p>The same instance of the transformer can then be applied to some new test data unseen during the fit call: the same scaling and shifting operations will be applied to be consistent with the transformation performed on the train data:</p> <pre data-language="python">&gt;&gt;&gt; X_test = np.array([[-3., -1.,  4.]])
&gt;&gt;&gt; X_test_minmax = min_max_scaler.transform(X_test)
&gt;&gt;&gt; X_test_minmax
array([[-1.5       ,  0.        ,  1.66666667]])
</pre> <p>It is possible to introspect the scaler attributes to find about the exact nature of the transformation learned on the training data:</p> <pre data-language="python">&gt;&gt;&gt; min_max_scaler.scale_
array([0.5       , 0.5       , 0.33...])

&gt;&gt;&gt; min_max_scaler.min_
array([0.        , 0.5       , 0.33...])
</pre> <p>If <a class="reference internal" href="generated/sklearn.preprocessing.minmaxscaler.html#sklearn.preprocessing.MinMaxScaler" title="sklearn.preprocessing.MinMaxScaler"><code>MinMaxScaler</code></a> is given an explicit <code>feature_range=(min, max)</code> the full formula is:</p> <pre data-language="python">X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))

X_scaled = X_std * (max - min) + min
</pre> <p><a class="reference internal" href="generated/sklearn.preprocessing.maxabsscaler.html#sklearn.preprocessing.MaxAbsScaler" title="sklearn.preprocessing.MaxAbsScaler"><code>MaxAbsScaler</code></a> works in a very similar fashion, but scales in a way that the training data lies within the range <code>[-1, 1]</code> by dividing through the largest maximum value in each feature. It is meant for data that is already centered at zero or sparse data.</p> <p>Here is how to use the toy data from the previous example with this scaler:</p> <pre data-language="python">&gt;&gt;&gt; X_train = np.array([[ 1., -1.,  2.],
...                     [ 2.,  0.,  0.],
...                     [ 0.,  1., -1.]])
...
&gt;&gt;&gt; max_abs_scaler = preprocessing.MaxAbsScaler()
&gt;&gt;&gt; X_train_maxabs = max_abs_scaler.fit_transform(X_train)
&gt;&gt;&gt; X_train_maxabs
array([[ 0.5, -1. ,  1. ],
       [ 1. ,  0. ,  0. ],
       [ 0. ,  1. , -0.5]])
&gt;&gt;&gt; X_test = np.array([[ -3., -1.,  4.]])
&gt;&gt;&gt; X_test_maxabs = max_abs_scaler.transform(X_test)
&gt;&gt;&gt; X_test_maxabs
array([[-1.5, -1. ,  2. ]])
&gt;&gt;&gt; max_abs_scaler.scale_
array([2.,  1.,  2.])
</pre> </section> <section id="scaling-sparse-data"> <h3>
<span class="section-number">6.3.1.2. </span>Scaling sparse data</h3> <p>Centering sparse data would destroy the sparseness structure in the data, and thus rarely is a sensible thing to do. However, it can make sense to scale sparse inputs, especially if features are on different scales.</p> <p><a class="reference internal" href="generated/sklearn.preprocessing.maxabsscaler.html#sklearn.preprocessing.MaxAbsScaler" title="sklearn.preprocessing.MaxAbsScaler"><code>MaxAbsScaler</code></a> was specifically designed for scaling sparse data, and is the recommended way to go about this. However, <a class="reference internal" href="generated/sklearn.preprocessing.standardscaler.html#sklearn.preprocessing.StandardScaler" title="sklearn.preprocessing.StandardScaler"><code>StandardScaler</code></a> can accept <code>scipy.sparse</code> matrices as input, as long as <code>with_mean=False</code> is explicitly passed to the constructor. Otherwise a <code>ValueError</code> will be raised as silently centering would break the sparsity and would often crash the execution by allocating excessive amounts of memory unintentionally. <a class="reference internal" href="generated/sklearn.preprocessing.robustscaler.html#sklearn.preprocessing.RobustScaler" title="sklearn.preprocessing.RobustScaler"><code>RobustScaler</code></a> cannot be fitted to sparse inputs, but you can use the <code>transform</code> method on sparse inputs.</p> <p>Note that the scalers accept both Compressed Sparse Rows and Compressed Sparse Columns format (see <code>scipy.sparse.csr_matrix</code> and <code>scipy.sparse.csc_matrix</code>). Any other sparse input will be <strong>converted to the Compressed Sparse Rows representation</strong>. To avoid unnecessary memory copies, it is recommended to choose the CSR or CSC representation upstream.</p> <p>Finally, if the centered data is expected to be small enough, explicitly converting the input to an array using the <code>toarray</code> method of sparse matrices is another option.</p> </section> <section id="scaling-data-with-outliers"> <h3>
<span class="section-number">6.3.1.3. </span>Scaling data with outliers</h3> <p>If your data contains many outliers, scaling using the mean and variance of the data is likely to not work very well. In these cases, you can use <a class="reference internal" href="generated/sklearn.preprocessing.robustscaler.html#sklearn.preprocessing.RobustScaler" title="sklearn.preprocessing.RobustScaler"><code>RobustScaler</code></a> as a drop-in replacement instead. It uses more robust estimates for the center and range of your data.</p> <aside class="topic"> <p class="topic-title">References:</p> <p>Further discussion on the importance of centering and scaling data is available on this FAQ: <a class="reference external" href="http://www.faqs.org/faqs/ai-faq/neural-nets/part2/section-16.html">Should I normalize/standardize/rescale the data?</a></p> </aside> <aside class="topic"> <p class="topic-title">Scaling vs Whitening</p> <p>It is sometimes not enough to center and scale the features independently, since a downstream model can further make some assumption on the linear independence of the features.</p> <p>To address this issue you can use <a class="reference internal" href="generated/sklearn.decomposition.pca.html#sklearn.decomposition.PCA" title="sklearn.decomposition.PCA"><code>PCA</code></a> with <code>whiten=True</code> to further remove the linear correlation across features.</p> </aside> </section> <section id="centering-kernel-matrices"> <h3 id="kernel-centering">
<span class="section-number">6.3.1.4. </span>Centering kernel matrices</h3> <p>If you have a kernel matrix of a kernel <span class="math notranslate nohighlight">\(K\)</span> that computes a dot product in a feature space (possibly implicitly) defined by a function <span class="math notranslate nohighlight">\(\phi(\cdot)\)</span>, a <a class="reference internal" href="generated/sklearn.preprocessing.kernelcenterer.html#sklearn.preprocessing.KernelCenterer" title="sklearn.preprocessing.KernelCenterer"><code>KernelCenterer</code></a> can transform the kernel matrix so that it contains inner products in the feature space defined by <span class="math notranslate nohighlight">\(\phi\)</span> followed by the removal of the mean in that space. In other words, <a class="reference internal" href="generated/sklearn.preprocessing.kernelcenterer.html#sklearn.preprocessing.KernelCenterer" title="sklearn.preprocessing.KernelCenterer"><code>KernelCenterer</code></a> computes the centered Gram matrix associated to a positive semidefinite kernel <span class="math notranslate nohighlight">\(K\)</span>.</p> <p><strong>Mathematical formulation</strong></p> <p>We can have a look at the mathematical formulation now that we have the intuition. Let <span class="math notranslate nohighlight">\(K\)</span> be a kernel matrix of shape <code>(n_samples, n_samples)</code> computed from <span class="math notranslate nohighlight">\(X\)</span>, a data matrix of shape <code>(n_samples, n_features)</code>, during the <code>fit</code> step. <span class="math notranslate nohighlight">\(K\)</span> is defined by</p> <div class="math notranslate nohighlight"> \[K(X, X) = \phi(X) . \phi(X)^{T}\]</div> <p><span class="math notranslate nohighlight">\(\phi(X)\)</span> is a function mapping of <span class="math notranslate nohighlight">\(X\)</span> to a Hilbert space. A centered kernel <span class="math notranslate nohighlight">\(\tilde{K}\)</span> is defined as:</p> <div class="math notranslate nohighlight"> \[\tilde{K}(X, X) = \tilde{\phi}(X) . \tilde{\phi}(X)^{T}\]</div> <p>where <span class="math notranslate nohighlight">\(\tilde{\phi}(X)\)</span> results from centering <span class="math notranslate nohighlight">\(\phi(X)\)</span> in the Hilbert space.</p> <p>Thus, one could compute <span class="math notranslate nohighlight">\(\tilde{K}\)</span> by mapping <span class="math notranslate nohighlight">\(X\)</span> using the function <span class="math notranslate nohighlight">\(\phi(\cdot)\)</span> and center the data in this new space. However, kernels are often used because they allows some algebra calculations that avoid computing explicitly this mapping using <span class="math notranslate nohighlight">\(\phi(\cdot)\)</span>. Indeed, one can implicitly center as shown in Appendix B in <a class="reference internal" href="#scholkopf1998" id="id1"><span>[Scholkopf1998]</span></a>:</p> <div class="math notranslate nohighlight"> \[\tilde{K} = K - 1_{\text{n}_{samples}} K - K 1_{\text{n}_{samples}} + 1_{\text{n}_{samples}} K 1_{\text{n}_{samples}}\]</div> <p><span class="math notranslate nohighlight">\(1_{\text{n}_{samples}}\)</span> is a matrix of <code>(n_samples, n_samples)</code> where all entries are equal to <span class="math notranslate nohighlight">\(\frac{1}{\text{n}_{samples}}\)</span>. In the <code>transform</code> step, the kernel becomes <span class="math notranslate nohighlight">\(K_{test}(X, Y)\)</span> defined as:</p> <div class="math notranslate nohighlight"> \[K_{test}(X, Y) = \phi(Y) . \phi(X)^{T}\]</div> <p><span class="math notranslate nohighlight">\(Y\)</span> is the test dataset of shape <code>(n_samples_test, n_features)</code> and thus <span class="math notranslate nohighlight">\(K_{test}\)</span> is of shape <code>(n_samples_test, n_samples)</code>. In this case, centering <span class="math notranslate nohighlight">\(K_{test}\)</span> is done as:</p> <div class="math notranslate nohighlight"> \[\tilde{K}_{test}(X, Y) = K_{test} - 1'_{\text{n}_{samples}} K - K_{test} 1_{\text{n}_{samples}} + 1'_{\text{n}_{samples}} K 1_{\text{n}_{samples}}\]</div> <p><span class="math notranslate nohighlight">\(1'_{\text{n}_{samples}}\)</span> is a matrix of shape <code>(n_samples_test, n_samples)</code> where all entries are equal to <span class="math notranslate nohighlight">\(\frac{1}{\text{n}_{samples}}\)</span>.</p> <aside class="topic"> <p class="topic-title">References</p> <div role="list" class="citation-list"> <div class="citation" id="scholkopf1998" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Scholkopf1998</a><span class="fn-bracket">]</span></span> <p>B. Schölkopf, A. Smola, and K.R. Müller, <a class="reference external" href="https://www.mlpack.org/papers/kpca.pdf">“Nonlinear component analysis as a kernel eigenvalue problem.”</a> Neural computation 10.5 (1998): 1299-1319.</p> </div> </div> </aside> </section> </section> <section id="non-linear-transformation"> <h2 id="preprocessing-transformer">
<span class="section-number">6.3.2. </span>Non-linear transformation</h2> <p>Two types of transformations are available: quantile transforms and power transforms. Both quantile and power transforms are based on monotonic transformations of the features and thus preserve the rank of the values along each feature.</p> <p>Quantile transforms put all features into the same desired distribution based on the formula <span class="math notranslate nohighlight">\(G^{-1}(F(X))\)</span> where <span class="math notranslate nohighlight">\(F\)</span> is the cumulative distribution function of the feature and <span class="math notranslate nohighlight">\(G^{-1}\)</span> the <a class="reference external" href="https://en.wikipedia.org/wiki/Quantile_function">quantile function</a> of the desired output distribution <span class="math notranslate nohighlight">\(G\)</span>. This formula is using the two following facts: (i) if <span class="math notranslate nohighlight">\(X\)</span> is a random variable with a continuous cumulative distribution function <span class="math notranslate nohighlight">\(F\)</span> then <span class="math notranslate nohighlight">\(F(X)\)</span> is uniformly distributed on <span class="math notranslate nohighlight">\([0,1]\)</span>; (ii) if <span class="math notranslate nohighlight">\(U\)</span> is a random variable with uniform distribution on <span class="math notranslate nohighlight">\([0,1]\)</span> then <span class="math notranslate nohighlight">\(G^{-1}(U)\)</span> has distribution <span class="math notranslate nohighlight">\(G\)</span>. By performing a rank transformation, a quantile transform smooths out unusual distributions and is less influenced by outliers than scaling methods. It does, however, distort correlations and distances within and across features.</p> <p>Power transforms are a family of parametric transformations that aim to map data from any distribution to as close to a Gaussian distribution.</p> <section id="mapping-to-a-uniform-distribution"> <h3>
<span class="section-number">6.3.2.1. </span>Mapping to a Uniform distribution</h3> <p><a class="reference internal" href="generated/sklearn.preprocessing.quantiletransformer.html#sklearn.preprocessing.QuantileTransformer" title="sklearn.preprocessing.QuantileTransformer"><code>QuantileTransformer</code></a> provides a non-parametric transformation to map the data to a uniform distribution with values between 0 and 1:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import load_iris
&gt;&gt;&gt; from sklearn.model_selection import train_test_split
&gt;&gt;&gt; X, y = load_iris(return_X_y=True)
&gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)
&gt;&gt;&gt; quantile_transformer = preprocessing.QuantileTransformer(random_state=0)
&gt;&gt;&gt; X_train_trans = quantile_transformer.fit_transform(X_train)
&gt;&gt;&gt; X_test_trans = quantile_transformer.transform(X_test)
&gt;&gt;&gt; np.percentile(X_train[:, 0], [0, 25, 50, 75, 100]) 
array([ 4.3,  5.1,  5.8,  6.5,  7.9])
</pre> <p>This feature corresponds to the sepal length in cm. Once the quantile transformation applied, those landmarks approach closely the percentiles previously defined:</p> <pre data-language="python">&gt;&gt;&gt; np.percentile(X_train_trans[:, 0], [0, 25, 50, 75, 100])
... 
array([ 0.00... ,  0.24...,  0.49...,  0.73...,  0.99... ])
</pre> <p>This can be confirmed on a independent testing set with similar remarks:</p> <pre data-language="python">&gt;&gt;&gt; np.percentile(X_test[:, 0], [0, 25, 50, 75, 100])
... 
array([ 4.4  ,  5.125,  5.75 ,  6.175,  7.3  ])
&gt;&gt;&gt; np.percentile(X_test_trans[:, 0], [0, 25, 50, 75, 100])
... 
array([ 0.01...,  0.25...,  0.46...,  0.60... ,  0.94...])
</pre> </section> <section id="mapping-to-a-gaussian-distribution"> <h3>
<span class="section-number">6.3.2.2. </span>Mapping to a Gaussian distribution</h3> <p>In many modeling scenarios, normality of the features in a dataset is desirable. Power transforms are a family of parametric, monotonic transformations that aim to map data from any distribution to as close to a Gaussian distribution as possible in order to stabilize variance and minimize skewness.</p> <p><a class="reference internal" href="generated/sklearn.preprocessing.powertransformer.html#sklearn.preprocessing.PowerTransformer" title="sklearn.preprocessing.PowerTransformer"><code>PowerTransformer</code></a> currently provides two such power transformations, the Yeo-Johnson transform and the Box-Cox transform.</p> <p>The Yeo-Johnson transform is given by:</p> <div class="math notranslate nohighlight"> \[\begin{split}x_i^{(\lambda)} = \begin{cases} [(x_i + 1)^\lambda - 1] / \lambda &amp; \text{if } \lambda \neq 0, x_i \geq 0, \\[8pt] \ln{(x_i + 1)} &amp; \text{if } \lambda = 0, x_i \geq 0 \\[8pt] -[(-x_i + 1)^{2 - \lambda} - 1] / (2 - \lambda) &amp; \text{if } \lambda \neq 2, x_i &lt; 0, \\[8pt] - \ln (- x_i + 1) &amp; \text{if } \lambda = 2, x_i &lt; 0 \end{cases}\end{split}\]</div> <p>while the Box-Cox transform is given by:</p> <div class="math notranslate nohighlight"> \[\begin{split}x_i^{(\lambda)} = \begin{cases} \dfrac{x_i^\lambda - 1}{\lambda} &amp; \text{if } \lambda \neq 0, \\[8pt] \ln{(x_i)} &amp; \text{if } \lambda = 0, \end{cases}\end{split}\]</div> <p>Box-Cox can only be applied to strictly positive data. In both methods, the transformation is parameterized by <span class="math notranslate nohighlight">\(\lambda\)</span>, which is determined through maximum likelihood estimation. Here is an example of using Box-Cox to map samples drawn from a lognormal distribution to a normal distribution:</p> <pre data-language="python">&gt;&gt;&gt; pt = preprocessing.PowerTransformer(method='box-cox', standardize=False)
&gt;&gt;&gt; X_lognormal = np.random.RandomState(616).lognormal(size=(3, 3))
&gt;&gt;&gt; X_lognormal
array([[1.28..., 1.18..., 0.84...],
       [0.94..., 1.60..., 0.38...],
       [1.35..., 0.21..., 1.09...]])
&gt;&gt;&gt; pt.fit_transform(X_lognormal)
array([[ 0.49...,  0.17..., -0.15...],
       [-0.05...,  0.58..., -0.57...],
       [ 0.69..., -0.84...,  0.10...]])
</pre> <p>While the above example sets the <code>standardize</code> option to <code>False</code>, <a class="reference internal" href="generated/sklearn.preprocessing.powertransformer.html#sklearn.preprocessing.PowerTransformer" title="sklearn.preprocessing.PowerTransformer"><code>PowerTransformer</code></a> will apply zero-mean, unit-variance normalization to the transformed output by default.</p> <p>Below are examples of Box-Cox and Yeo-Johnson applied to various probability distributions. Note that when applied to certain distributions, the power transforms achieve very Gaussian-like results, but with others, they are ineffective. This highlights the importance of visualizing the data before and after transformation.</p> <figure class="align-center"> <a class="reference external image-reference" href="../auto_examples/preprocessing/plot_map_data_to_normal.html"><img alt="../_images/sphx_glr_plot_map_data_to_normal_001.png" src="data:image/png;base64,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" style="width: 400.0px; height: 800.0px;"></a> </figure> <p>It is also possible to map data to a normal distribution using <a class="reference internal" href="generated/sklearn.preprocessing.quantiletransformer.html#sklearn.preprocessing.QuantileTransformer" title="sklearn.preprocessing.QuantileTransformer"><code>QuantileTransformer</code></a> by setting <code>output_distribution='normal'</code>. Using the earlier example with the iris dataset:</p> <pre data-language="python">&gt;&gt;&gt; quantile_transformer = preprocessing.QuantileTransformer(
...     output_distribution='normal', random_state=0)
&gt;&gt;&gt; X_trans = quantile_transformer.fit_transform(X)
&gt;&gt;&gt; quantile_transformer.quantiles_
array([[4.3, 2. , 1. , 0.1],
       [4.4, 2.2, 1.1, 0.1],
       [4.4, 2.2, 1.2, 0.1],
       ...,
       [7.7, 4.1, 6.7, 2.5],
       [7.7, 4.2, 6.7, 2.5],
       [7.9, 4.4, 6.9, 2.5]])
</pre> <p>Thus the median of the input becomes the mean of the output, centered at 0. The normal output is clipped so that the input’s minimum and maximum — corresponding to the 1e-7 and 1 - 1e-7 quantiles respectively — do not become infinite under the transformation.</p> </section> </section> <section id="normalization"> <h2 id="preprocessing-normalization">
<span class="section-number">6.3.3. </span>Normalization</h2> <p><strong>Normalization</strong> is the process of <strong>scaling individual samples to have unit norm</strong>. This process can be useful if you plan to use a quadratic form such as the dot-product or any other kernel to quantify the similarity of any pair of samples.</p> <p>This assumption is the base of the <a class="reference external" href="https://en.wikipedia.org/wiki/Vector_Space_Model">Vector Space Model</a> often used in text classification and clustering contexts.</p> <p>The function <a class="reference internal" href="generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" title="sklearn.preprocessing.normalize"><code>normalize</code></a> provides a quick and easy way to perform this operation on a single array-like dataset, either using the <code>l1</code>, <code>l2</code>, or <code>max</code> norms:</p> <pre data-language="python">&gt;&gt;&gt; X = [[ 1., -1.,  2.],
...      [ 2.,  0.,  0.],
...      [ 0.,  1., -1.]]
&gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm='l2')

&gt;&gt;&gt; X_normalized
array([[ 0.40..., -0.40...,  0.81...],
       [ 1.  ...,  0.  ...,  0.  ...],
       [ 0.  ...,  0.70..., -0.70...]])
</pre> <p>The <code>preprocessing</code> module further provides a utility class <a class="reference internal" href="generated/sklearn.preprocessing.normalizer.html#sklearn.preprocessing.Normalizer" title="sklearn.preprocessing.Normalizer"><code>Normalizer</code></a> that implements the same operation using the <code>Transformer</code> API (even though the <code>fit</code> method is useless in this case: the class is stateless as this operation treats samples independently).</p> <p>This class is hence suitable for use in the early steps of a <a class="reference internal" href="generated/sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; normalizer = preprocessing.Normalizer().fit(X)  # fit does nothing
&gt;&gt;&gt; normalizer
Normalizer()
</pre> <p>The normalizer instance can then be used on sample vectors as any transformer:</p> <pre data-language="python">&gt;&gt;&gt; normalizer.transform(X)
array([[ 0.40..., -0.40...,  0.81...],
       [ 1.  ...,  0.  ...,  0.  ...],
       [ 0.  ...,  0.70..., -0.70...]])

&gt;&gt;&gt; normalizer.transform([[-1.,  1., 0.]])
array([[-0.70...,  0.70...,  0.  ...]])
</pre> <p>Note: L2 normalization is also known as spatial sign preprocessing.</p> <aside class="topic"> <p class="topic-title">Sparse input</p> <p><a class="reference internal" href="generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" title="sklearn.preprocessing.normalize"><code>normalize</code></a> and <a class="reference internal" href="generated/sklearn.preprocessing.normalizer.html#sklearn.preprocessing.Normalizer" title="sklearn.preprocessing.Normalizer"><code>Normalizer</code></a> accept <strong>both dense array-like and sparse matrices from scipy.sparse as input</strong>.</p> <p>For sparse input the data is <strong>converted to the Compressed Sparse Rows representation</strong> (see <code>scipy.sparse.csr_matrix</code>) before being fed to efficient Cython routines. To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream.</p> </aside> </section> <section id="encoding-categorical-features"> <h2 id="preprocessing-categorical-features">
<span class="section-number">6.3.4. </span>Encoding categorical features</h2> <p>Often features are not given as continuous values but categorical. For example a person could have features <code>["male", "female"]</code>, <code>["from Europe", "from US", "from Asia"]</code>, <code>["uses Firefox", "uses Chrome", "uses Safari", "uses Internet Explorer"]</code>. Such features can be efficiently coded as integers, for instance <code>["male", "from US", "uses Internet Explorer"]</code> could be expressed as <code>[0, 1, 3]</code> while <code>["female", "from Asia", "uses Chrome"]</code> would be <code>[1, 2, 1]</code>.</p> <p>To convert categorical features to such integer codes, we can use the <a class="reference internal" href="generated/sklearn.preprocessing.ordinalencoder.html#sklearn.preprocessing.OrdinalEncoder" title="sklearn.preprocessing.OrdinalEncoder"><code>OrdinalEncoder</code></a>. This estimator transforms each categorical feature to one new feature of integers (0 to n_categories - 1):</p> <pre data-language="python">&gt;&gt;&gt; enc = preprocessing.OrdinalEncoder()
&gt;&gt;&gt; X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
&gt;&gt;&gt; enc.fit(X)
OrdinalEncoder()
&gt;&gt;&gt; enc.transform([['female', 'from US', 'uses Safari']])
array([[0., 1., 1.]])
</pre> <p>Such integer representation can, however, not be used directly with all scikit-learn estimators, as these expect continuous input, and would interpret the categories as being ordered, which is often not desired (i.e. the set of browsers was ordered arbitrarily).</p> <p>By default, <a class="reference internal" href="generated/sklearn.preprocessing.ordinalencoder.html#sklearn.preprocessing.OrdinalEncoder" title="sklearn.preprocessing.OrdinalEncoder"><code>OrdinalEncoder</code></a> will also passthrough missing values that are indicated by <code>np.nan</code>.</p> <pre data-language="python">&gt;&gt;&gt; enc = preprocessing.OrdinalEncoder()
&gt;&gt;&gt; X = [['male'], ['female'], [np.nan], ['female']]
&gt;&gt;&gt; enc.fit_transform(X)
array([[ 1.],
       [ 0.],
       [nan],
       [ 0.]])
</pre> <p><a class="reference internal" href="generated/sklearn.preprocessing.ordinalencoder.html#sklearn.preprocessing.OrdinalEncoder" title="sklearn.preprocessing.OrdinalEncoder"><code>OrdinalEncoder</code></a> provides a parameter <code>encoded_missing_value</code> to encode the missing values without the need to create a pipeline and using <a class="reference internal" href="generated/sklearn.impute.simpleimputer.html#sklearn.impute.SimpleImputer" title="sklearn.impute.SimpleImputer"><code>SimpleImputer</code></a>.</p> <pre data-language="python">&gt;&gt;&gt; enc = preprocessing.OrdinalEncoder(encoded_missing_value=-1)
&gt;&gt;&gt; X = [['male'], ['female'], [np.nan], ['female']]
&gt;&gt;&gt; enc.fit_transform(X)
array([[ 1.],
       [ 0.],
       [-1.],
       [ 0.]])
</pre> <p>The above processing is equivalent to the following pipeline:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.pipeline import Pipeline
&gt;&gt;&gt; from sklearn.impute import SimpleImputer
&gt;&gt;&gt; enc = Pipeline(steps=[
...     ("encoder", preprocessing.OrdinalEncoder()),
...     ("imputer", SimpleImputer(strategy="constant", fill_value=-1)),
... ])
&gt;&gt;&gt; enc.fit_transform(X)
array([[ 1.],
       [ 0.],
       [-1.],
       [ 0.]])
</pre> <p>Another possibility to convert categorical features to features that can be used with scikit-learn estimators is to use a one-of-K, also known as one-hot or dummy encoding. This type of encoding can be obtained with the <a class="reference internal" href="generated/sklearn.preprocessing.onehotencoder.html#sklearn.preprocessing.OneHotEncoder" title="sklearn.preprocessing.OneHotEncoder"><code>OneHotEncoder</code></a>, which transforms each categorical feature with <code>n_categories</code> possible values into <code>n_categories</code> binary features, with one of them 1, and all others 0.</p> <p>Continuing the example above:</p> <pre data-language="python">&gt;&gt;&gt; enc = preprocessing.OneHotEncoder()
&gt;&gt;&gt; X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
&gt;&gt;&gt; enc.fit(X)
OneHotEncoder()
&gt;&gt;&gt; enc.transform([['female', 'from US', 'uses Safari'],
...                ['male', 'from Europe', 'uses Safari']]).toarray()
array([[1., 0., 0., 1., 0., 1.],
       [0., 1., 1., 0., 0., 1.]])
</pre> <p>By default, the values each feature can take is inferred automatically from the dataset and can be found in the <code>categories_</code> attribute:</p> <pre data-language="python">&gt;&gt;&gt; enc.categories_
[array(['female', 'male'], dtype=object), array(['from Europe', 'from US'], dtype=object), array(['uses Firefox', 'uses Safari'], dtype=object)]
</pre> <p>It is possible to specify this explicitly using the parameter <code>categories</code>. There are two genders, four possible continents and four web browsers in our dataset:</p> <pre data-language="python">&gt;&gt;&gt; genders = ['female', 'male']
&gt;&gt;&gt; locations = ['from Africa', 'from Asia', 'from Europe', 'from US']
&gt;&gt;&gt; browsers = ['uses Chrome', 'uses Firefox', 'uses IE', 'uses Safari']
&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(categories=[genders, locations, browsers])
&gt;&gt;&gt; # Note that for there are missing categorical values for the 2nd and 3rd
&gt;&gt;&gt; # feature
&gt;&gt;&gt; X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
&gt;&gt;&gt; enc.fit(X)
OneHotEncoder(categories=[['female', 'male'],
                          ['from Africa', 'from Asia', 'from Europe',
                           'from US'],
                          ['uses Chrome', 'uses Firefox', 'uses IE',
                           'uses Safari']])
&gt;&gt;&gt; enc.transform([['female', 'from Asia', 'uses Chrome']]).toarray()
array([[1., 0., 0., 1., 0., 0., 1., 0., 0., 0.]])
</pre> <p>If there is a possibility that the training data might have missing categorical features, it can often be better to specify <code>handle_unknown='infrequent_if_exist'</code> instead of setting the <code>categories</code> manually as above. When <code>handle_unknown='infrequent_if_exist'</code> is specified and unknown categories are encountered during transform, no error will be raised but the resulting one-hot encoded columns for this feature will be all zeros or considered as an infrequent category if enabled. (<code>handle_unknown='infrequent_if_exist'</code> is only supported for one-hot encoding):</p> <pre data-language="python">&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(handle_unknown='infrequent_if_exist')
&gt;&gt;&gt; X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
&gt;&gt;&gt; enc.fit(X)
OneHotEncoder(handle_unknown='infrequent_if_exist')
&gt;&gt;&gt; enc.transform([['female', 'from Asia', 'uses Chrome']]).toarray()
array([[1., 0., 0., 0., 0., 0.]])
</pre> <p>It is also possible to encode each column into <code>n_categories - 1</code> columns instead of <code>n_categories</code> columns by using the <code>drop</code> parameter. This parameter allows the user to specify a category for each feature to be dropped. This is useful to avoid co-linearity in the input matrix in some classifiers. Such functionality is useful, for example, when using non-regularized regression (<a class="reference internal" href="generated/sklearn.linear_model.linearregression.html#sklearn.linear_model.LinearRegression" title="sklearn.linear_model.LinearRegression"><code>LinearRegression</code></a>), since co-linearity would cause the covariance matrix to be non-invertible:</p> <pre data-language="python">&gt;&gt;&gt; X = [['male', 'from US', 'uses Safari'],
...      ['female', 'from Europe', 'uses Firefox']]
&gt;&gt;&gt; drop_enc = preprocessing.OneHotEncoder(drop='first').fit(X)
&gt;&gt;&gt; drop_enc.categories_
[array(['female', 'male'], dtype=object), array(['from Europe', 'from US'], dtype=object),
 array(['uses Firefox', 'uses Safari'], dtype=object)]
&gt;&gt;&gt; drop_enc.transform(X).toarray()
array([[1., 1., 1.],
       [0., 0., 0.]])
</pre> <p>One might want to drop one of the two columns only for features with 2 categories. In this case, you can set the parameter <code>drop='if_binary'</code>.</p> <pre data-language="python">&gt;&gt;&gt; X = [['male', 'US', 'Safari'],
...      ['female', 'Europe', 'Firefox'],
...      ['female', 'Asia', 'Chrome']]
&gt;&gt;&gt; drop_enc = preprocessing.OneHotEncoder(drop='if_binary').fit(X)
&gt;&gt;&gt; drop_enc.categories_
[array(['female', 'male'], dtype=object), array(['Asia', 'Europe', 'US'], dtype=object),
 array(['Chrome', 'Firefox', 'Safari'], dtype=object)]
&gt;&gt;&gt; drop_enc.transform(X).toarray()
array([[1., 0., 0., 1., 0., 0., 1.],
       [0., 0., 1., 0., 0., 1., 0.],
       [0., 1., 0., 0., 1., 0., 0.]])
</pre> <p>In the transformed <code>X</code>, the first column is the encoding of the feature with categories “male”/”female”, while the remaining 6 columns is the encoding of the 2 features with respectively 3 categories each.</p> <p>When <code>handle_unknown='ignore'</code> and <code>drop</code> is not None, unknown categories will be encoded as all zeros:</p> <pre data-language="python">&gt;&gt;&gt; drop_enc = preprocessing.OneHotEncoder(drop='first',
...                                        handle_unknown='ignore').fit(X)
&gt;&gt;&gt; X_test = [['unknown', 'America', 'IE']]
&gt;&gt;&gt; drop_enc.transform(X_test).toarray()
array([[0., 0., 0., 0., 0.]])
</pre> <p>All the categories in <code>X_test</code> are unknown during transform and will be mapped to all zeros. This means that unknown categories will have the same mapping as the dropped category. :meth`OneHotEncoder.inverse_transform` will map all zeros to the dropped category if a category is dropped and <code>None</code> if a category is not dropped:</p> <pre data-language="python">&gt;&gt;&gt; drop_enc = preprocessing.OneHotEncoder(drop='if_binary', sparse=False,
...                                        handle_unknown='ignore').fit(X)
&gt;&gt;&gt; X_test = [['unknown', 'America', 'IE']]
&gt;&gt;&gt; X_trans = drop_enc.transform(X_test)
&gt;&gt;&gt; X_trans
array([[0., 0., 0., 0., 0., 0., 0.]])
&gt;&gt;&gt; drop_enc.inverse_transform(X_trans)
array([['female', None, None]], dtype=object)
</pre> <p><a class="reference internal" href="generated/sklearn.preprocessing.onehotencoder.html#sklearn.preprocessing.OneHotEncoder" title="sklearn.preprocessing.OneHotEncoder"><code>OneHotEncoder</code></a> supports categorical features with missing values by considering the missing values as an additional category:</p> <pre data-language="python">&gt;&gt;&gt; X = [['male', 'Safari'],
...      ['female', None],
...      [np.nan, 'Firefox']]
&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(handle_unknown='error').fit(X)
&gt;&gt;&gt; enc.categories_
[array(['female', 'male', nan], dtype=object),
 array(['Firefox', 'Safari', None], dtype=object)]
&gt;&gt;&gt; enc.transform(X).toarray()
array([[0., 1., 0., 0., 1., 0.],
       [1., 0., 0., 0., 0., 1.],
       [0., 0., 1., 1., 0., 0.]])
</pre> <p>If a feature contains both <code>np.nan</code> and <code>None</code>, they will be considered separate categories:</p> <pre data-language="python">&gt;&gt;&gt; X = [['Safari'], [None], [np.nan], ['Firefox']]
&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(handle_unknown='error').fit(X)
&gt;&gt;&gt; enc.categories_
[array(['Firefox', 'Safari', None, nan], dtype=object)]
&gt;&gt;&gt; enc.transform(X).toarray()
array([[0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.],
       [1., 0., 0., 0.]])
</pre> <p>See <a class="reference internal" href="feature_extraction.html#dict-feature-extraction"><span class="std std-ref">Loading features from dicts</span></a> for categorical features that are represented as a dict, not as scalars.</p> <section id="infrequent-categories"> <h3 id="one-hot-encoder-infrequent-categories">
<span class="section-number">6.3.4.1. </span>Infrequent categories</h3> <p><a class="reference internal" href="generated/sklearn.preprocessing.onehotencoder.html#sklearn.preprocessing.OneHotEncoder" title="sklearn.preprocessing.OneHotEncoder"><code>OneHotEncoder</code></a> supports aggregating infrequent categories into a single output for each feature. The parameters to enable the gathering of infrequent categories are <code>min_frequency</code> and <code>max_categories</code>.</p> <ol class="arabic simple"> <li>
<code>min_frequency</code> is either an integer greater or equal to 1, or a float in the interval <code>(0.0, 1.0)</code>. If <code>min_frequency</code> is an integer, categories with a cardinality smaller than <code>min_frequency</code> will be considered infrequent. If <code>min_frequency</code> is a float, categories with a cardinality smaller than this fraction of the total number of samples will be considered infrequent. The default value is 1, which means every category is encoded separately.</li> <li>
<code>max_categories</code> is either <code>None</code> or any integer greater than 1. This parameter sets an upper limit to the number of output features for each input feature. <code>max_categories</code> includes the feature that combines infrequent categories.</li> </ol> <p>In the following example, the categories, <code>'dog', 'snake'</code> are considered infrequent:</p> <pre data-language="python">&gt;&gt;&gt; X = np.array([['dog'] * 5 + ['cat'] * 20 + ['rabbit'] * 10 +
...               ['snake'] * 3], dtype=object).T
&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(min_frequency=6, sparse=False).fit(X)
&gt;&gt;&gt; enc.infrequent_categories_
[array(['dog', 'snake'], dtype=object)]
&gt;&gt;&gt; enc.transform(np.array([['dog'], ['cat'], ['rabbit'], ['snake']]))
array([[0., 0., 1.],
       [1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
</pre> <p>By setting handle_unknown to <code>'infrequent_if_exist'</code>, unknown categories will be considered infrequent:</p> <pre data-language="python">&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(
...    handle_unknown='infrequent_if_exist', sparse=False, min_frequency=6)
&gt;&gt;&gt; enc = enc.fit(X)
&gt;&gt;&gt; enc.transform(np.array([['dragon']]))
array([[0., 0., 1.]])
</pre> <p><a class="reference internal" href="generated/sklearn.preprocessing.onehotencoder.html#sklearn.preprocessing.OneHotEncoder.get_feature_names_out" title="sklearn.preprocessing.OneHotEncoder.get_feature_names_out"><code>OneHotEncoder.get_feature_names_out</code></a> uses ‘infrequent’ as the infrequent feature name:</p> <pre data-language="python">&gt;&gt;&gt; enc.get_feature_names_out()
array(['x0_cat', 'x0_rabbit', 'x0_infrequent_sklearn'], dtype=object)
</pre> <p>When <code>'handle_unknown'</code> is set to <code>'infrequent_if_exist'</code> and an unknown category is encountered in transform:</p> <ol class="arabic simple"> <li>If infrequent category support was not configured or there was no infrequent category during training, the resulting one-hot encoded columns for this feature will be all zeros. In the inverse transform, an unknown category will be denoted as <code>None</code>.</li> <li>If there is an infrequent category during training, the unknown category will be considered infrequent. In the inverse transform, ‘infrequent_sklearn’ will be used to represent the infrequent category.</li> </ol> <p>Infrequent categories can also be configured using <code>max_categories</code>. In the following example, we set <code>max_categories=2</code> to limit the number of features in the output. This will result in all but the <code>'cat'</code> category to be considered infrequent, leading to two features, one for <code>'cat'</code> and one for infrequent categories - which are all the others:</p> <pre data-language="python">&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(max_categories=2, sparse=False)
&gt;&gt;&gt; enc = enc.fit(X)
&gt;&gt;&gt; enc.transform([['dog'], ['cat'], ['rabbit'], ['snake']])
array([[0., 1.],
       [1., 0.],
       [0., 1.],
       [0., 1.]])
</pre> <p>If both <code>max_categories</code> and <code>min_frequency</code> are non-default values, then categories are selected based on <code>min_frequency</code> first and <code>max_categories</code> categories are kept. In the following example, <code>min_frequency=4</code> considers only <code>snake</code> to be infrequent, but <code>max_categories=3</code>, forces <code>dog</code> to also be infrequent:</p> <pre data-language="python">&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(min_frequency=4, max_categories=3, sparse=False)
&gt;&gt;&gt; enc = enc.fit(X)
&gt;&gt;&gt; enc.transform([['dog'], ['cat'], ['rabbit'], ['snake']])
array([[0., 0., 1.],
       [1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
</pre> <p>If there are infrequent categories with the same cardinality at the cutoff of <code>max_categories</code>, then then the first <code>max_categories</code> are taken based on lexicon ordering. In the following example, “b”, “c”, and “d”, have the same cardinality and with <code>max_categories=2</code>, “b” and “c” are infrequent because they have a higher lexicon order.</p> <pre data-language="python">&gt;&gt;&gt; X = np.asarray([["a"] * 20 + ["b"] * 10 + ["c"] * 10 + ["d"] * 10], dtype=object).T
&gt;&gt;&gt; enc = preprocessing.OneHotEncoder(max_categories=3).fit(X)
&gt;&gt;&gt; enc.infrequent_categories_
[array(['b', 'c'], dtype=object)]
</pre> </section> </section> <section id="discretization"> <h2 id="preprocessing-discretization">
<span class="section-number">6.3.5. </span>Discretization</h2> <p><a class="reference external" href="https://en.wikipedia.org/wiki/Discretization_of_continuous_features">Discretization</a> (otherwise known as quantization or binning) provides a way to partition continuous features into discrete values. Certain datasets with continuous features may benefit from discretization, because discretization can transform the dataset of continuous attributes to one with only nominal attributes.</p> <p>One-hot encoded discretized features can make a model more expressive, while maintaining interpretability. For instance, pre-processing with a discretizer can introduce nonlinearity to linear models. For more advanced possibilities, in particular smooth ones, see <a class="reference internal" href="#generating-polynomial-features"><span class="std std-ref">Generating polynomial features</span></a> further below.</p> <section id="k-bins-discretization"> <h3>
<span class="section-number">6.3.5.1. </span>K-bins discretization</h3> <p><a class="reference internal" href="generated/sklearn.preprocessing.kbinsdiscretizer.html#sklearn.preprocessing.KBinsDiscretizer" title="sklearn.preprocessing.KBinsDiscretizer"><code>KBinsDiscretizer</code></a> discretizes features into <code>k</code> bins:</p> <pre data-language="python">&gt;&gt;&gt; X = np.array([[ -3., 5., 15 ],
...               [  0., 6., 14 ],
...               [  6., 3., 11 ]])
&gt;&gt;&gt; est = preprocessing.KBinsDiscretizer(n_bins=[3, 2, 2], encode='ordinal').fit(X)
</pre> <p>By default the output is one-hot encoded into a sparse matrix (See <a class="reference internal" href="#preprocessing-categorical-features"><span class="std std-ref">Encoding categorical features</span></a>) and this can be configured with the <code>encode</code> parameter. For each feature, the bin edges are computed during <code>fit</code> and together with the number of bins, they will define the intervals. Therefore, for the current example, these intervals are defined as:</p>  <ul class="simple"> <li>feature 1: <span class="math notranslate nohighlight">\({[-\infty, -1), [-1, 2), [2, \infty)}\)</span>
</li> <li>feature 2: <span class="math notranslate nohighlight">\({[-\infty, 5), [5, \infty)}\)</span>
</li> <li>feature 3: <span class="math notranslate nohighlight">\({[-\infty, 14), [14, \infty)}\)</span>
</li> </ul>  <p>Based on these bin intervals, <code>X</code> is transformed as follows:</p> <pre data-language="python">&gt;&gt;&gt; est.transform(X)                      
array([[ 0., 1., 1.],
       [ 1., 1., 1.],
       [ 2., 0., 0.]])
</pre> <p>The resulting dataset contains ordinal attributes which can be further used in a <a class="reference internal" href="generated/sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>.</p> <p>Discretization is similar to constructing histograms for continuous data. However, histograms focus on counting features which fall into particular bins, whereas discretization focuses on assigning feature values to these bins.</p> <p><a class="reference internal" href="generated/sklearn.preprocessing.kbinsdiscretizer.html#sklearn.preprocessing.KBinsDiscretizer" title="sklearn.preprocessing.KBinsDiscretizer"><code>KBinsDiscretizer</code></a> implements different binning strategies, which can be selected with the <code>strategy</code> parameter. The ‘uniform’ strategy uses constant-width bins. The ‘quantile’ strategy uses the quantiles values to have equally populated bins in each feature. The ‘kmeans’ strategy defines bins based on a k-means clustering procedure performed on each feature independently.</p> <p>Be aware that one can specify custom bins by passing a callable defining the discretization strategy to <a class="reference internal" href="generated/sklearn.preprocessing.functiontransformer.html#sklearn.preprocessing.FunctionTransformer" title="sklearn.preprocessing.FunctionTransformer"><code>FunctionTransformer</code></a>. For instance, we can use the Pandas function <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.cut.html#pandas.cut" title="(in pandas v1.5.1)"><code>pandas.cut</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; bins = [0, 1, 13, 20, 60, np.inf]
&gt;&gt;&gt; labels = ['infant', 'kid', 'teen', 'adult', 'senior citizen']
&gt;&gt;&gt; transformer = preprocessing.FunctionTransformer(
...     pd.cut, kw_args={'bins': bins, 'labels': labels, 'retbins': False}
... )
&gt;&gt;&gt; X = np.array([0.2, 2, 15, 25, 97])
&gt;&gt;&gt; transformer.fit_transform(X)
['infant', 'kid', 'teen', 'adult', 'senior citizen']
Categories (5, object): ['infant' &lt; 'kid' &lt; 'teen' &lt; 'adult' &lt; 'senior citizen']
</pre> <aside class="topic"> <p class="topic-title">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../auto_examples/preprocessing/plot_discretization.html#sphx-glr-auto-examples-preprocessing-plot-discretization-py"><span class="std std-ref">Using KBinsDiscretizer to discretize continuous features</span></a></li> <li><a class="reference internal" href="../auto_examples/preprocessing/plot_discretization_classification.html#sphx-glr-auto-examples-preprocessing-plot-discretization-classification-py"><span class="std std-ref">Feature discretization</span></a></li> <li><a class="reference internal" href="../auto_examples/preprocessing/plot_discretization_strategies.html#sphx-glr-auto-examples-preprocessing-plot-discretization-strategies-py"><span class="std std-ref">Demonstrating the different strategies of KBinsDiscretizer</span></a></li> </ul> </aside> </section> <section id="feature-binarization"> <h3 id="preprocessing-binarization">
<span class="section-number">6.3.5.2. </span>Feature binarization</h3> <p><strong>Feature binarization</strong> is the process of <strong>thresholding numerical features to get boolean values</strong>. This can be useful for downstream probabilistic estimators that make assumption that the input data is distributed according to a multi-variate <a class="reference external" href="https://en.wikipedia.org/wiki/Bernoulli_distribution">Bernoulli distribution</a>. For instance, this is the case for the <a class="reference internal" href="generated/sklearn.neural_network.bernoullirbm.html#sklearn.neural_network.BernoulliRBM" title="sklearn.neural_network.BernoulliRBM"><code>BernoulliRBM</code></a>.</p> <p>It is also common among the text processing community to use binary feature values (probably to simplify the probabilistic reasoning) even if normalized counts (a.k.a. term frequencies) or TF-IDF valued features often perform slightly better in practice.</p> <p>As for the <a class="reference internal" href="generated/sklearn.preprocessing.normalizer.html#sklearn.preprocessing.Normalizer" title="sklearn.preprocessing.Normalizer"><code>Normalizer</code></a>, the utility class <a class="reference internal" href="generated/sklearn.preprocessing.binarizer.html#sklearn.preprocessing.Binarizer" title="sklearn.preprocessing.Binarizer"><code>Binarizer</code></a> is meant to be used in the early stages of <a class="reference internal" href="generated/sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>. The <code>fit</code> method does nothing as each sample is treated independently of others:</p> <pre data-language="python">&gt;&gt;&gt; X = [[ 1., -1.,  2.],
...      [ 2.,  0.,  0.],
...      [ 0.,  1., -1.]]

&gt;&gt;&gt; binarizer = preprocessing.Binarizer().fit(X)  # fit does nothing
&gt;&gt;&gt; binarizer
Binarizer()

&gt;&gt;&gt; binarizer.transform(X)
array([[1., 0., 1.],
       [1., 0., 0.],
       [0., 1., 0.]])
</pre> <p>It is possible to adjust the threshold of the binarizer:</p> <pre data-language="python">&gt;&gt;&gt; binarizer = preprocessing.Binarizer(threshold=1.1)
&gt;&gt;&gt; binarizer.transform(X)
array([[0., 0., 1.],
       [1., 0., 0.],
       [0., 0., 0.]])
</pre> <p>As for the <a class="reference internal" href="generated/sklearn.preprocessing.normalizer.html#sklearn.preprocessing.Normalizer" title="sklearn.preprocessing.Normalizer"><code>Normalizer</code></a> class, the preprocessing module provides a companion function <a class="reference internal" href="generated/sklearn.preprocessing.binarize.html#sklearn.preprocessing.binarize" title="sklearn.preprocessing.binarize"><code>binarize</code></a> to be used when the transformer API is not necessary.</p> <p>Note that the <a class="reference internal" href="generated/sklearn.preprocessing.binarizer.html#sklearn.preprocessing.Binarizer" title="sklearn.preprocessing.Binarizer"><code>Binarizer</code></a> is similar to the <a class="reference internal" href="generated/sklearn.preprocessing.kbinsdiscretizer.html#sklearn.preprocessing.KBinsDiscretizer" title="sklearn.preprocessing.KBinsDiscretizer"><code>KBinsDiscretizer</code></a> when <code>k = 2</code>, and when the bin edge is at the value <code>threshold</code>.</p> <aside class="topic"> <p class="topic-title">Sparse input</p> <p><a class="reference internal" href="generated/sklearn.preprocessing.binarize.html#sklearn.preprocessing.binarize" title="sklearn.preprocessing.binarize"><code>binarize</code></a> and <a class="reference internal" href="generated/sklearn.preprocessing.binarizer.html#sklearn.preprocessing.Binarizer" title="sklearn.preprocessing.Binarizer"><code>Binarizer</code></a> accept <strong>both dense array-like and sparse matrices from scipy.sparse as input</strong>.</p> <p>For sparse input the data is <strong>converted to the Compressed Sparse Rows representation</strong> (see <code>scipy.sparse.csr_matrix</code>). To avoid unnecessary memory copies, it is recommended to choose the CSR representation upstream.</p> </aside> </section> </section> <section id="imputation-of-missing-values"> <h2 id="imputation">
<span class="section-number">6.3.6. </span>Imputation of missing values</h2> <p>Tools for imputing missing values are discussed at <a class="reference internal" href="impute.html#impute"><span class="std std-ref">Imputation of missing values</span></a>.</p> </section> <section id="generating-polynomial-features"> <h2 id="id3">
<span class="section-number">6.3.7. </span>Generating polynomial features</h2> <p>Often it’s useful to add complexity to a model by considering nonlinear features of the input data. We show two possibilities that are both based on polynomials: The first one uses pure polynomials, the second one uses splines, i.e. piecewise polynomials.</p> <section id="polynomial-features"> <h3 id="id4">
<span class="section-number">6.3.7.1. </span>Polynomial features</h3> <p>A simple and common method to use is polynomial features, which can get features’ high-order and interaction terms. It is implemented in <a class="reference internal" href="generated/sklearn.preprocessing.polynomialfeatures.html#sklearn.preprocessing.PolynomialFeatures" title="sklearn.preprocessing.PolynomialFeatures"><code>PolynomialFeatures</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures
&gt;&gt;&gt; X = np.arange(6).reshape(3, 2)
&gt;&gt;&gt; X
array([[0, 1],
       [2, 3],
       [4, 5]])
&gt;&gt;&gt; poly = PolynomialFeatures(2)
&gt;&gt;&gt; poly.fit_transform(X)
array([[ 1.,  0.,  1.,  0.,  0.,  1.],
       [ 1.,  2.,  3.,  4.,  6.,  9.],
       [ 1.,  4.,  5., 16., 20., 25.]])
</pre> <p>The features of X have been transformed from <span class="math notranslate nohighlight">\((X_1, X_2)\)</span> to <span class="math notranslate nohighlight">\((1, X_1, X_2, X_1^2, X_1X_2, X_2^2)\)</span>.</p> <p>In some cases, only interaction terms among features are required, and it can be gotten with the setting <code>interaction_only=True</code>:</p> <pre data-language="python">&gt;&gt;&gt; X = np.arange(9).reshape(3, 3)
&gt;&gt;&gt; X
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
&gt;&gt;&gt; poly = PolynomialFeatures(degree=3, interaction_only=True)
&gt;&gt;&gt; poly.fit_transform(X)
array([[  1.,   0.,   1.,   2.,   0.,   0.,   2.,   0.],
       [  1.,   3.,   4.,   5.,  12.,  15.,  20.,  60.],
       [  1.,   6.,   7.,   8.,  42.,  48.,  56., 336.]])
</pre> <p>The features of X have been transformed from <span class="math notranslate nohighlight">\((X_1, X_2, X_3)\)</span> to <span class="math notranslate nohighlight">\((1, X_1, X_2, X_3, X_1X_2, X_1X_3, X_2X_3, X_1X_2X_3)\)</span>.</p> <p>Note that polynomial features are used implicitly in <a class="reference external" href="https://en.wikipedia.org/wiki/Kernel_method">kernel methods</a> (e.g., <a class="reference internal" href="generated/sklearn.svm.svc.html#sklearn.svm.SVC" title="sklearn.svm.SVC"><code>SVC</code></a>, <a class="reference internal" href="generated/sklearn.decomposition.kernelpca.html#sklearn.decomposition.KernelPCA" title="sklearn.decomposition.KernelPCA"><code>KernelPCA</code></a>) when using polynomial <a class="reference internal" href="svm.html#svm-kernels"><span class="std std-ref">Kernel functions</span></a>.</p> <p>See <a class="reference internal" href="../auto_examples/linear_model/plot_polynomial_interpolation.html#sphx-glr-auto-examples-linear-model-plot-polynomial-interpolation-py"><span class="std std-ref">Polynomial and Spline interpolation</span></a> for Ridge regression using created polynomial features.</p> </section> <section id="spline-transformer"> <h3 id="id5">
<span class="section-number">6.3.7.2. </span>Spline transformer</h3> <p>Another way to add nonlinear terms instead of pure polynomials of features is to generate spline basis functions for each feature with the <a class="reference internal" href="generated/sklearn.preprocessing.splinetransformer.html#sklearn.preprocessing.SplineTransformer" title="sklearn.preprocessing.SplineTransformer"><code>SplineTransformer</code></a>. Splines are piecewise polynomials, parametrized by their polynomial degree and the positions of the knots. The <a class="reference internal" href="generated/sklearn.preprocessing.splinetransformer.html#sklearn.preprocessing.SplineTransformer" title="sklearn.preprocessing.SplineTransformer"><code>SplineTransformer</code></a> implements a B-spline basis, cf. the references below.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="generated/sklearn.preprocessing.splinetransformer.html#sklearn.preprocessing.SplineTransformer" title="sklearn.preprocessing.SplineTransformer"><code>SplineTransformer</code></a> treats each feature separately, i.e. it won’t give you interaction terms.</p> </div> <p>Some of the advantages of splines over polynomials are:</p>  <ul class="simple"> <li>B-splines are very flexible and robust if you keep a fixed low degree, usually 3, and parsimoniously adapt the number of knots. Polynomials would need a higher degree, which leads to the next point.</li> <li>B-splines do not have oscillatory behaviour at the boundaries as have polynomials (the higher the degree, the worse). This is known as <a class="reference external" href="https://en.wikipedia.org/wiki/Runge%27s_phenomenon">Runge’s phenomenon</a>.</li> <li>B-splines provide good options for extrapolation beyond the boundaries, i.e. beyond the range of fitted values. Have a look at the option <code>extrapolation</code>.</li> <li>B-splines generate a feature matrix with a banded structure. For a single feature, every row contains only <code>degree + 1</code> non-zero elements, which occur consecutively and are even positive. This results in a matrix with good numerical properties, e.g. a low condition number, in sharp contrast to a matrix of polynomials, which goes under the name <a class="reference external" href="https://en.wikipedia.org/wiki/Vandermonde_matrix">Vandermonde matrix</a>. A low condition number is important for stable algorithms of linear models.</li> </ul>  <p>The following code snippet shows splines in action:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.preprocessing import SplineTransformer
&gt;&gt;&gt; X = np.arange(5).reshape(5, 1)
&gt;&gt;&gt; X
array([[0],
       [1],
       [2],
       [3],
       [4]])
&gt;&gt;&gt; spline = SplineTransformer(degree=2, n_knots=3)
&gt;&gt;&gt; spline.fit_transform(X)
array([[0.5  , 0.5  , 0.   , 0.   ],
       [0.125, 0.75 , 0.125, 0.   ],
       [0.   , 0.5  , 0.5  , 0.   ],
       [0.   , 0.125, 0.75 , 0.125],
       [0.   , 0.   , 0.5  , 0.5  ]])
</pre> <p>As the <code>X</code> is sorted, one can easily see the banded matrix output. Only the three middle diagonals are non-zero for <code>degree=2</code>. The higher the degree, the more overlapping of the splines.</p> <p>Interestingly, a <a class="reference internal" href="generated/sklearn.preprocessing.splinetransformer.html#sklearn.preprocessing.SplineTransformer" title="sklearn.preprocessing.SplineTransformer"><code>SplineTransformer</code></a> of <code>degree=0</code> is the same as <a class="reference internal" href="generated/sklearn.preprocessing.kbinsdiscretizer.html#sklearn.preprocessing.KBinsDiscretizer" title="sklearn.preprocessing.KBinsDiscretizer"><code>KBinsDiscretizer</code></a> with <code>encode='onehot-dense'</code> and <code>n_bins = n_knots - 1</code> if <code>knots = strategy</code>.</p> <aside class="topic"> <p class="topic-title">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../auto_examples/linear_model/plot_polynomial_interpolation.html#sphx-glr-auto-examples-linear-model-plot-polynomial-interpolation-py"><span class="std std-ref">Polynomial and Spline interpolation</span></a></li> <li><a class="reference internal" href="../auto_examples/applications/plot_cyclical_feature_engineering.html#sphx-glr-auto-examples-applications-plot-cyclical-feature-engineering-py"><span class="std std-ref">Time-related feature engineering</span></a></li> </ul> </aside> <aside class="topic"> <p class="topic-title">References:</p> <ul class="simple"> <li>Eilers, P., &amp; Marx, B. (1996). <a class="reference external" href="https://doi.org/10.1214/ss/1038425655">Flexible Smoothing with B-splines and Penalties</a>. Statist. Sci. 11 (1996), no. 2, 89–121.</li> <li>Perperoglou, A., Sauerbrei, W., Abrahamowicz, M. et al. <a class="reference external" href="https://doi.org/10.1186/s12874-019-0666-3">A review of spline function procedures in R</a>. BMC Med Res Methodol 19, 46 (2019).</li> </ul> </aside> </section> </section> <section id="custom-transformers"> <h2 id="function-transformer">
<span class="section-number">6.3.8. </span>Custom transformers</h2> <p>Often, you will want to convert an existing Python function into a transformer to assist in data cleaning or processing. You can implement a transformer from an arbitrary function with <a class="reference internal" href="generated/sklearn.preprocessing.functiontransformer.html#sklearn.preprocessing.FunctionTransformer" title="sklearn.preprocessing.FunctionTransformer"><code>FunctionTransformer</code></a>. For example, to build a transformer that applies a log transformation in a pipeline, do:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.preprocessing import FunctionTransformer
&gt;&gt;&gt; transformer = FunctionTransformer(np.log1p, validate=True)
&gt;&gt;&gt; X = np.array([[0, 1], [2, 3]])
&gt;&gt;&gt; # Since FunctionTransformer is no-op during fit, we can call transform directly
&gt;&gt;&gt; transformer.transform(X)
array([[0.        , 0.69314718],
       [1.09861229, 1.38629436]])
</pre> <p>You can ensure that <code>func</code> and <code>inverse_func</code> are the inverse of each other by setting <code>check_inverse=True</code> and calling <code>fit</code> before <code>transform</code>. Please note that a warning is raised and can be turned into an error with a <code>filterwarnings</code>:</p> <pre data-language="python">&gt;&gt;&gt; import warnings
&gt;&gt;&gt; warnings.filterwarnings("error", message=".*check_inverse*.",
...                         category=UserWarning, append=False)
</pre> <p>For a full code example that demonstrates using a <a class="reference internal" href="generated/sklearn.preprocessing.functiontransformer.html#sklearn.preprocessing.FunctionTransformer" title="sklearn.preprocessing.FunctionTransformer"><code>FunctionTransformer</code></a> to extract features from text data see <a class="reference internal" href="../auto_examples/compose/plot_column_transformer.html#sphx-glr-auto-examples-compose-plot-column-transformer-py"><span class="std std-ref">Column Transformer with Heterogeneous Data Sources</span></a> and <a class="reference internal" href="../auto_examples/applications/plot_cyclical_feature_engineering.html#sphx-glr-auto-examples-applications-plot-cyclical-feature-engineering-py"><span class="std std-ref">Time-related feature engineering</span></a>.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/preprocessing.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/preprocessing.html</a>
  </p>
</div>
