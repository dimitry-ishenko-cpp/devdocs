<section id="linearsvr"> <h1>LinearSVR</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.svm.LinearSVR"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.svm.</span><span class="sig-name descname">LinearSVR</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">C</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">loss</span><span class="o">=</span><span class="default_value">'epsilon_insensitive'</span></em>, <em class="sig-param"><span class="n">fit_intercept</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">intercept_scaling</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">dual</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/svm/_classes.py#L358"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Linear Support Vector Regression.</p> <p>Similar to SVR with parameter kernel=’linear’, but implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples.</p> <p>The main differences between <a class="reference internal" href="#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a> and <a class="reference internal" href="sklearn.svm.svr.html#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>SVR</code></a> lie in the loss function used by default, and in the handling of intercept regularization between those two implementations.</p> <p>This class supports both dense and sparse input.</p> <p>Read more in the <a class="reference internal" href="../svm.html#svm-regression"><span class="std std-ref">User Guide</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.16.</span></p> </div> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>epsilon</strong><span class="classifier">float, default=0.0</span>
</dt>
<dd>
<p>Epsilon parameter in the epsilon-insensitive loss function. Note that the value of this parameter depends on the scale of the target variable y. If unsure, set <code>epsilon=0</code>.</p> </dd> <dt>
<strong>tol</strong><span class="classifier">float, default=1e-4</span>
</dt>
<dd>
<p>Tolerance for stopping criteria.</p> </dd> <dt>
<strong>C</strong><span class="classifier">float, default=1.0</span>
</dt>
<dd>
<p>Regularization parameter. The strength of the regularization is inversely proportional to C. Must be strictly positive.</p> </dd> <dt>
<strong>loss</strong><span class="classifier">{‘epsilon_insensitive’, ‘squared_epsilon_insensitive’}, default=’epsilon_insensitive’</span>
</dt>
<dd>
<p>Specifies the loss function. The epsilon-insensitive loss (standard SVR) is the L1 loss, while the squared epsilon-insensitive loss (‘squared_epsilon_insensitive’) is the L2 loss.</p> </dd> <dt>
<strong>fit_intercept</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether or not to fit an intercept. If set to True, the feature vector is extended to include an intercept term: <code>[x_1, ..., x_n, 1]</code>, where 1 corresponds to the intercept. If set to False, no intercept will be used in calculations (i.e. data is expected to be already centered).</p> </dd> <dt>
<strong>intercept_scaling</strong><span class="classifier">float, default=1.0</span>
</dt>
<dd>
<p>When <code>fit_intercept</code> is True, the instance vector x becomes <code>[x_1, ...,
x_n, intercept_scaling]</code>, i.e. a “synthetic” feature with a constant value equal to <code>intercept_scaling</code> is appended to the instance vector. The intercept becomes intercept_scaling * synthetic feature weight. Note that liblinear internally penalizes the intercept, treating it like any other term in the feature vector. To reduce the impact of the regularization on the intercept, the <code>intercept_scaling</code> parameter can be set to a value greater than 1; the higher the value of <code>intercept_scaling</code>, the lower the impact of regularization on it. Then, the weights become <code>[w_x_1, ..., w_x_n,
w_intercept*intercept_scaling]</code>, where <code>w_x_1, ..., w_x_n</code> represent the feature weights and the intercept weight is scaled by <code>intercept_scaling</code>. This scaling allows the intercept term to have a different regularization behavior compared to the other features.</p> </dd> <dt>
<strong>dual</strong><span class="classifier">“auto” or bool, default=”auto”</span>
</dt>
<dd>
<p>Select the algorithm to either solve the dual or primal optimization problem. Prefer dual=False when n_samples &gt; n_features. <code>dual="auto"</code> will choose the value of the parameter automatically, based on the values of <code>n_samples</code>, <code>n_features</code> and <code>loss</code>. If <code>n_samples</code> &lt; <code>n_features</code> and optimizer supports chosen <code>loss</code>, then dual will be set to True, otherwise it will be set to False.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.3: </span>The <code>"auto"</code> option is added in version 1.3 and will be the default in version 1.5.</p> </div> </dd> <dt>
<strong>verbose</strong><span class="classifier">int, default=0</span>
</dt>
<dd>
<p>Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in liblinear that, if enabled, may not work properly in a multithreaded context.</p> </dd> <dt>
<strong>random_state</strong><span class="classifier">int, RandomState instance or None, default=None</span>
</dt>
<dd>
<p>Controls the pseudo random number generation for shuffling the data. Pass an int for reproducible output across multiple function calls. See <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-random_state"><span class="xref std std-term">Glossary</span></a>.</p> </dd> <dt>
<strong>max_iter</strong><span class="classifier">int, default=1000</span>
</dt>
<dd>
<p>The maximum number of iterations to be run.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>coef_</strong><span class="classifier">ndarray of shape (n_features) if n_classes == 2 else (n_classes, n_features)</span>
</dt>
<dd>
<p>Weights assigned to the features (coefficients in the primal problem).</p> <p><code>coef_</code> is a readonly property derived from <code>raw_coef_</code> that follows the internal memory layout of liblinear.</p> </dd> <dt>
<strong>intercept_</strong><span class="classifier">ndarray of shape (1) if n_classes == 2 else (n_classes)</span>
</dt>
<dd>
<p>Constants in decision function.</p> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.24.</span></p> </div> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.0.</span></p> </div> </dd> <dt>
<strong>n_iter_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Maximum number of iterations run across all classes.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.svm.linearsvc.html#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code>LinearSVC</code></a></dt>
<dd>
<p>Implementation of Support Vector Machine classifier using the same library as this class (liblinear).</p> </dd> <dt><a class="reference internal" href="sklearn.svm.svr.html#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>SVR</code></a></dt>
<dd>
<p>Implementation of Support Vector Machine regression using libsvm: the kernel can be non-linear but its SMO algorithm does not scale to large number of samples as <a class="reference internal" href="#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a> does.</p> </dd> <dt><a class="reference internal" href="sklearn.linear_model.sgdregressor.html#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><code>sklearn.linear_model.SGDRegressor</code></a></dt>
<dd>
<p>SGDRegressor can optimize the same cost function as LinearSVR by adjusting the penalty and loss parameters. In addition it requires less memory, allows incremental (online) learning, and implements various loss functions and regularization regimes.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.svm import LinearSVR
&gt;&gt;&gt; from sklearn.pipeline import make_pipeline
&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler
&gt;&gt;&gt; from sklearn.datasets import make_regression
&gt;&gt;&gt; X, y = make_regression(n_features=4, random_state=0)
&gt;&gt;&gt; regr = make_pipeline(StandardScaler(),
...                      LinearSVR(random_state=0, tol=1e-5))
&gt;&gt;&gt; regr.fit(X, y)
Pipeline(steps=[('standardscaler', StandardScaler()),
                ('linearsvr', LinearSVR(random_state=0, tol=1e-05))])
</pre> <pre data-language="python">&gt;&gt;&gt; print(regr.named_steps['linearsvr'].coef_)
[18.582... 27.023... 44.357... 64.522...]
&gt;&gt;&gt; print(regr.named_steps['linearsvr'].intercept_)
[-4...]
&gt;&gt;&gt; print(regr.predict([[0, 0, 0, 0]]))
[-2.384...]
</pre> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.LinearSVR.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/svm/_classes.py#L544"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit the model according to the given training data.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Training vector, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of features.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,)</span>
</dt>
<dd>
<p>Target vector relative to X.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.18.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>An instance of the estimator.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.LinearSVR.get_metadata_routing"> <span class="sig-name descname">get_metadata_routing</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1497"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get metadata routing of this object.</p> <p>Please check <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>routing</strong><span class="classifier">MetadataRequest</span>
</dt>
<dd>
<p>A <a class="reference internal" href="sklearn.utils.metadata_routing.metadatarequest.html#sklearn.utils.metadata_routing.MetadataRequest" title="sklearn.utils.metadata_routing.MetadataRequest"><code>MetadataRequest</code></a> encapsulating routing information.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.LinearSVR.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L231"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.LinearSVR.predict"> <span class="sig-name descname">predict</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/linear_model/_base.py#L283"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict using the linear model.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like or sparse matrix, shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Samples.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>C</strong><span class="classifier">array, shape (n_samples,)</span>
</dt>
<dd>
<p>Returns predicted values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.LinearSVR.score"> <span class="sig-name descname">score</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L619"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the coefficient of determination of the prediction.</p> <p>The coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> is defined as <span class="math notranslate nohighlight">\((1 - \frac{u}{v})\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is the residual sum of squares <code>((y_true - y_pred)** 2).sum()</code> and <span class="math notranslate nohighlight">\(v\)</span> is the total sum of squares <code>((y_true - y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape <code>(n_samples, n_samples_fitted)</code>, where <code>n_samples_fitted</code> is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs)</span>
</dt>
<dd>
<p>True values for <code>X</code>.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>score</strong><span class="classifier">float</span>
</dt>
<dd>
<p><span class="math notranslate nohighlight">\(R^2\)</span> of <code>self.predict(X)</code> w.r.t. <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <span class="math notranslate nohighlight">\(R^2\)</span> score used when calling <code>score</code> on a regressor uses <code>multioutput='uniform_average'</code> from version 0.23 to keep consistent with default value of <a class="reference internal" href="sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>. This influences the <code>score</code> method of all the multioutput regressors (except for <a class="reference internal" href="sklearn.multioutput.multioutputregressor.html#sklearn.multioutput.MultiOutputRegressor" title="sklearn.multioutput.MultiOutputRegressor"><code>MultiOutputRegressor</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.LinearSVR.set_fit_request"> <span class="sig-name descname">set_fit_request</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="p">:</span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)">None</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a></span><span class="o">=</span><span class="default_value">'$UNCHANGED$'</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">→</span> <span class="sig-return-typehint"><a class="reference internal" href="#sklearn.svm.LinearSVR" title="sklearn.svm._classes.LinearSVR">LinearSVR</a></span></span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1251"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Request metadata passed to the <code>fit</code> method.</p> <p>Note that this method is only relevant if <code>enable_metadata_routing=True</code> (see <a class="reference internal" href="sklearn.set_config.html#sklearn.set_config" title="sklearn.set_config"><code>sklearn.set_config</code></a>). Please see <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <p>The options for each parameter are:</p> <ul class="simple"> <li>
<code>True</code>: metadata is requested, and passed to <code>fit</code> if provided. The request is ignored if metadata is not provided.</li> <li>
<code>False</code>: metadata is not requested and the meta-estimator will not pass it to <code>fit</code>.</li> <li>
<code>None</code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</li> <li>
<code>str</code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</li> </ul> <p>The default (<code>sklearn.utils.metadata_routing.UNCHANGED</code>) retains the existing request. This allows you to change the request for some parameters and not others.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.3.</span></p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>. Otherwise it has no effect.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>sample_weight</strong><span class="classifier">str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED</span>
</dt>
<dd>
<p>Metadata routing for <code>sample_weight</code> parameter in <code>fit</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>The updated object.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.LinearSVR.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L255"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.LinearSVR.set_score_request"> <span class="sig-name descname">set_score_request</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="p">:</span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)">None</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a></span><span class="o">=</span><span class="default_value">'$UNCHANGED$'</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">→</span> <span class="sig-return-typehint"><a class="reference internal" href="#sklearn.svm.LinearSVR" title="sklearn.svm._classes.LinearSVR">LinearSVR</a></span></span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1251"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Request metadata passed to the <code>score</code> method.</p> <p>Note that this method is only relevant if <code>enable_metadata_routing=True</code> (see <a class="reference internal" href="sklearn.set_config.html#sklearn.set_config" title="sklearn.set_config"><code>sklearn.set_config</code></a>). Please see <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <p>The options for each parameter are:</p> <ul class="simple"> <li>
<code>True</code>: metadata is requested, and passed to <code>score</code> if provided. The request is ignored if metadata is not provided.</li> <li>
<code>False</code>: metadata is not requested and the meta-estimator will not pass it to <code>score</code>.</li> <li>
<code>None</code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</li> <li>
<code>str</code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</li> </ul> <p>The default (<code>sklearn.utils.metadata_routing.UNCHANGED</code>) retains the existing request. This allows you to change the request for some parameters and not others.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.3.</span></p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>. Otherwise it has no effect.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>sample_weight</strong><span class="classifier">str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED</span>
</dt>
<dd>
<p>Metadata routing for <code>sample_weight</code> parameter in <code>score</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>The updated object.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/generated/sklearn.svm.LinearSVR.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/generated/sklearn.svm.LinearSVR.html</a>
  </p>
</div>
