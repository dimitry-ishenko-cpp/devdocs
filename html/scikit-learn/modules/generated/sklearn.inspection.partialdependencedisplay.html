<section id="sklearn-inspection-partialdependencedisplay"> <h1>sklearn.inspection.PartialDependenceDisplay</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.inspection.PartialDependenceDisplay"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.inspection.</span><span class="sig-name descname">PartialDependenceDisplay</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">pd_results</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">features</span></em>, <em class="sig-param"><span class="n">feature_names</span></em>, <em class="sig-param"><span class="n">target_idx</span></em>, <em class="sig-param"><span class="n">deciles</span></em>, <em class="sig-param"><span class="n">pdp_lim</span><span class="o">=</span><span class="default_value">'deprecated'</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">'average'</span></em>, <em class="sig-param"><span class="n">subsample</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/inspection/_plot/partial_dependence.py#L551"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Partial Dependence Plot (PDP).</p> <p>This can also display individual partial dependencies which are often referred to as: Individual Condition Expectation (ICE).</p> <p>It is recommended to use <a class="reference internal" href="#sklearn.inspection.PartialDependenceDisplay.from_estimator" title="sklearn.inspection.PartialDependenceDisplay.from_estimator"><code>from_estimator</code></a> to create a <a class="reference internal" href="#sklearn.inspection.PartialDependenceDisplay" title="sklearn.inspection.PartialDependenceDisplay"><code>PartialDependenceDisplay</code></a>. All parameters are stored as attributes.</p> <p>Read more in <a class="reference internal" href="../../auto_examples/miscellaneous/plot_partial_dependence_visualization_api.html#sphx-glr-auto-examples-miscellaneous-plot-partial-dependence-visualization-api-py"><span class="std std-ref">Advanced Plotting With Partial Dependence</span></a> and the <a class="reference internal" href="../partial_dependence.html#partial-dependence"><span class="std std-ref">User Guide</span></a>.</p>  <div class="versionadded"> <p><span class="versionmodified added">New in version 0.22.</span></p> </div>  <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>pd_results</strong><span class="classifier">list of Bunch</span>
</dt>
<dd>
<p>Results of <a class="reference internal" href="sklearn.inspection.partial_dependence.html#sklearn.inspection.partial_dependence" title="sklearn.inspection.partial_dependence"><code>partial_dependence</code></a> for <code>features</code>.</p> </dd> <dt>
<strong>features</strong><span class="classifier">list of (int,) or list of (int, int)</span>
</dt>
<dd>
<p>Indices of features for a given plot. A tuple of one integer will plot a partial dependence curve of one feature. A tuple of two integers will plot a two-way partial dependence curve as a contour plot.</p> </dd> <dt>
<strong>feature_names</strong><span class="classifier">list of str</span>
</dt>
<dd>
<p>Feature names corresponding to the indices in <code>features</code>.</p> </dd> <dt>
<strong>target_idx</strong><span class="classifier">int</span>
</dt>
<dd>
<ul class="simple"> <li>In a multiclass setting, specifies the class for which the PDPs should be computed. Note that for binary classification, the positive class (index 1) is always used.</li> <li>In a multioutput setting, specifies the task for which the PDPs should be computed.</li> </ul> <p>Ignored in binary classification or classical regression settings.</p> </dd> <dt>
<strong>deciles</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Deciles for feature indices in <code>features</code>.</p> </dd> <dt>
<strong>pdp_lim</strong><span class="classifier">dict or None</span>
</dt>
<dd>
<p>Global min and max average predictions, such that all plots will have the same scale and y limits. <code>pdp_lim[1]</code> is the global min and max for single partial dependence curves. <code>pdp_lim[2]</code> is the global min and max for two-way partial dependence curves. If <code>None</code>, the limit will be inferred from the global minimum and maximum of all predictions.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.1: </span>Pass the parameter <code>pdp_lim</code> to <a class="reference internal" href="#sklearn.inspection.PartialDependenceDisplay.plot" title="sklearn.inspection.PartialDependenceDisplay.plot"><code>plot</code></a> instead. It will be removed in 1.3.</p> </div> </dd> <dt>
<strong>kind</strong><span class="classifier">{‘average’, ‘individual’, ‘both’} or list of such str, default=’average’</span>
</dt>
<dd>
<p>Whether to plot the partial dependence averaged across all the samples in the dataset or one line per sample or both.</p> <ul class="simple"> <li>
<code>kind='average'</code> results in the traditional PD plot;</li> <li>
<code>kind='individual'</code> results in the ICE plot;</li> <li>
<code>kind='both'</code> results in plotting both the ICE and PD on the same plot.</li> </ul> <p>A list of such strings can be provided to specify <code>kind</code> on a per-plot basis. The length of the list should be the same as the number of interaction requested in <code>features</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>ICE (‘individual’ or ‘both’) is not a valid option for 2-ways interactions plot. As a result, an error will be raised. 2-ways interaction plots should always be configured to use the ‘average’ kind instead.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The fast <code>method='recursion'</code> option is only available for <code>kind='average'</code>. Plotting individual dependencies requires using the slower <code>method='brute'</code> option.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.24: </span>Add <code>kind</code> parameter with <code>'average'</code>, <code>'individual'</code>, and <code>'both'</code> options.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1: </span>Add the possibility to pass a list of string specifying <code>kind</code> for each plot.</p> </div> </dd> <dt>
<strong>subsample</strong><span class="classifier">float, int or None, default=1000</span>
</dt>
<dd>
<p>Sampling for ICE curves when <code>kind</code> is ‘individual’ or ‘both’. If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to be used to plot ICE curves. If int, represents the maximum absolute number of samples to use.</p> <p>Note that the full dataset is still used to calculate partial dependence when <code>kind='both'</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.24.</span></p> </div> </dd> <dt>
<strong>random_state</strong><span class="classifier">int, RandomState instance or None, default=None</span>
</dt>
<dd>
<p>Controls the randomness of the selected samples when subsamples is not <code>None</code>. See <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-random_state"><span class="xref std std-term">Glossary</span></a> for details.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.24.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>bounding_ax_</strong><span class="classifier">matplotlib Axes or None</span>
</dt>
<dd>
<p>If <code>ax</code> is an axes or None, the <code>bounding_ax_</code> is the axes where the grid of partial dependence plots are drawn. If <code>ax</code> is a list of axes or a numpy array of axes, <code>bounding_ax_</code> is None.</p> </dd> <dt>
<strong>axes_</strong><span class="classifier">ndarray of matplotlib Axes</span>
</dt>
<dd>
<p>If <code>ax</code> is an axes or None, <code>axes_[i, j]</code> is the axes on the i-th row and j-th column. If <code>ax</code> is a list of axes, <code>axes_[i]</code> is the i-th item in <code>ax</code>. Elements that are None correspond to a nonexisting axes in that position.</p> </dd> <dt>
<strong>lines_</strong><span class="classifier">ndarray of matplotlib Artists</span>
</dt>
<dd>
<p>If <code>ax</code> is an axes or None, <code>lines_[i, j]</code> is the partial dependence curve on the i-th row and j-th column. If <code>ax</code> is a list of axes, <code>lines_[i]</code> is the partial dependence curve corresponding to the i-th item in <code>ax</code>. Elements that are None correspond to a nonexisting axes or an axes that does not include a line plot.</p> </dd> <dt>
<strong>deciles_vlines_</strong><span class="classifier">ndarray of matplotlib LineCollection</span>
</dt>
<dd>
<p>If <code>ax</code> is an axes or None, <code>vlines_[i, j]</code> is the line collection representing the x axis deciles of the i-th row and j-th column. If <code>ax</code> is a list of axes, <code>vlines_[i]</code> corresponds to the i-th item in <code>ax</code>. Elements that are None correspond to a nonexisting axes or an axes that does not include a PDP plot.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.23.</span></p> </div> </dd> <dt>
<strong>deciles_hlines_</strong><span class="classifier">ndarray of matplotlib LineCollection</span>
</dt>
<dd>
<p>If <code>ax</code> is an axes or None, <code>vlines_[i, j]</code> is the line collection representing the y axis deciles of the i-th row and j-th column. If <code>ax</code> is a list of axes, <code>vlines_[i]</code> corresponds to the i-th item in <code>ax</code>. Elements that are None correspond to a nonexisting axes or an axes that does not include a 2-way plot.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.23.</span></p> </div> </dd> <dt>
<strong>contours_</strong><span class="classifier">ndarray of matplotlib Artists</span>
</dt>
<dd>
<p>If <code>ax</code> is an axes or None, <code>contours_[i, j]</code> is the partial dependence plot on the i-th row and j-th column. If <code>ax</code> is a list of axes, <code>contours_[i]</code> is the partial dependence plot corresponding to the i-th item in <code>ax</code>. Elements that are None correspond to a nonexisting axes or an axes that does not include a contour plot.</p> </dd> <dt>
<strong>figure_</strong><span class="classifier">matplotlib Figure</span>
</dt>
<dd>
<p>Figure containing partial dependence plots.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.inspection.partial_dependence.html#sklearn.inspection.partial_dependence" title="sklearn.inspection.partial_dependence"><code>partial_dependence</code></a></dt>
<dd>
<p>Compute Partial Dependence values.</p> </dd> <dt><a class="reference internal" href="#sklearn.inspection.PartialDependenceDisplay.from_estimator" title="sklearn.inspection.PartialDependenceDisplay.from_estimator"><code>PartialDependenceDisplay.from_estimator</code></a></dt>
<dd>
<p>Plot Partial Dependence.</p> </dd> </dl> </div> <h4 class="rubric">Methods</h4> <table class="autosummary longtable docutils align-default">  <tr>
<td><p><a class="reference internal" href="#sklearn.inspection.PartialDependenceDisplay.from_estimator" title="sklearn.inspection.PartialDependenceDisplay.from_estimator"><code>from_estimator</code></a>(estimator, X, features, *[, ...])</p></td> <td><p>Partial dependence (PD) and individual conditional expectation (ICE) plots.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.inspection.PartialDependenceDisplay.plot" title="sklearn.inspection.PartialDependenceDisplay.plot"><code>plot</code></a>(*[, ax, n_cols, line_kw, ice_lines_kw, ...])</p></td> <td><p>Plot partial dependence plots.</p></td> </tr>  </table> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.inspection.PartialDependenceDisplay.from_estimator"> <em class="property">classmethod</em><span class="sig-name descname">from_estimator</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">estimator</span></em>, <em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">features</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">feature_names</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">response_method</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">n_cols</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">grid_resolution</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">percentiles</span><span class="o">=</span><span class="default_value">(0.05, 0.95)</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">line_kw</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ice_lines_kw</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pd_line_kw</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">contour_kw</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">'average'</span></em>, <em class="sig-param"><span class="n">centered</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">subsample</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/inspection/_plot/partial_dependence.py#L734"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Partial dependence (PD) and individual conditional expectation (ICE) plots.</p> <p>Partial dependence plots, individual conditional expectation plots or an overlay of both of them can be plotted by setting the <code>kind</code> parameter. The <code>len(features)</code> plots are arranged in a grid with <code>n_cols</code> columns. Two-way partial dependence plots are plotted as contour plots. The deciles of the feature values will be shown with tick marks on the x-axes for one-way plots, and on both axes for two-way plots.</p> <p>Read more in the <a class="reference internal" href="../partial_dependence.html#partial-dependence"><span class="std std-ref">User Guide</span></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#sklearn.inspection.PartialDependenceDisplay.from_estimator" title="sklearn.inspection.PartialDependenceDisplay.from_estimator"><code>PartialDependenceDisplay.from_estimator</code></a> does not support using the same axes with multiple calls. To plot the partial dependence for multiple estimators, please pass the axes created by the first call to the second call:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.inspection import PartialDependenceDisplay
&gt;&gt;&gt; from sklearn.datasets import make_friedman1
&gt;&gt;&gt; from sklearn.linear_model import LinearRegression
&gt;&gt;&gt; from sklearn.ensemble import RandomForestRegressor
&gt;&gt;&gt; X, y = make_friedman1()
&gt;&gt;&gt; est1 = LinearRegression().fit(X, y)
&gt;&gt;&gt; est2 = RandomForestRegressor().fit(X, y)
&gt;&gt;&gt; disp1 = PartialDependenceDisplay.from_estimator(est1, X,
...                                                 [1, 2])
&gt;&gt;&gt; disp2 = PartialDependenceDisplay.from_estimator(est2, X, [1, 2],
...                                                 ax=disp1.axes_)
</pre> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>For <a class="reference internal" href="sklearn.ensemble.gradientboostingclassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code>GradientBoostingClassifier</code></a> and <a class="reference internal" href="sklearn.ensemble.gradientboostingregressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code>GradientBoostingRegressor</code></a>, the <code>'recursion'</code> method (used by default) will not account for the <code>init</code> predictor of the boosting process. In practice, this will produce the same values as <code>'brute'</code> up to a constant offset in the target response, provided that <code>init</code> is a constant estimator (which is the default). However, if <code>init</code> is not a constant estimator, the partial dependence values are incorrect for <code>'recursion'</code> because the offset will be sample-dependent. It is preferable to use the <code>'brute'</code> method. Note that this only applies to <a class="reference internal" href="sklearn.ensemble.gradientboostingclassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code>GradientBoostingClassifier</code></a> and <a class="reference internal" href="sklearn.ensemble.gradientboostingregressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code>GradientBoostingRegressor</code></a>, not to <a class="reference internal" href="sklearn.ensemble.histgradientboostingclassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code>HistGradientBoostingClassifier</code></a> and <a class="reference internal" href="sklearn.ensemble.histgradientboostingregressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code>HistGradientBoostingRegressor</code></a>.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>estimator</strong><span class="classifier">BaseEstimator</span>
</dt>
<dd>
<p>A fitted estimator object implementing <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-predict"><span class="xref std std-term">predict</span></a>, <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-predict_proba"><span class="xref std std-term">predict_proba</span></a>, or <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-decision_function"><span class="xref std std-term">decision_function</span></a>. Multioutput-multiclass classifiers are not supported.</p> </dd> <dt>
<strong>X</strong><span class="classifier">{array-like, dataframe} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p><code>X</code> is used to generate a grid of values for the target <code>features</code> (where the partial dependence will be evaluated), and also to generate values for the complement features when the <code>method</code> is <code>'brute'</code>.</p> </dd> <dt>
<strong>features</strong><span class="classifier">list of {int, str, pair of int, pair of str}</span>
</dt>
<dd>
<p>The target features for which to create the PDPs. If <code>features[i]</code> is an integer or a string, a one-way PDP is created; if <code>features[i]</code> is a tuple, a two-way PDP is created (only supported with <code>kind='average'</code>). Each tuple must be of size 2. if any entry is a string, then it must be in <code>feature_names</code>.</p> </dd> <dt>
<strong>feature_names</strong><span class="classifier">array-like of shape (n_features,), dtype=str, default=None</span>
</dt>
<dd>
<p>Name of each feature; <code>feature_names[i]</code> holds the name of the feature with index <code>i</code>. By default, the name of the feature corresponds to their numerical index for NumPy array and their column name for pandas dataframe.</p> </dd> <dt>
<strong>target</strong><span class="classifier">int, default=None</span>
</dt>
<dd>
<ul class="simple"> <li>In a multiclass setting, specifies the class for which the PDPs should be computed. Note that for binary classification, the positive class (index 1) is always used.</li> <li>In a multioutput setting, specifies the task for which the PDPs should be computed.</li> </ul> <p>Ignored in binary classification or classical regression settings.</p> </dd> <dt>
<strong>response_method</strong><span class="classifier">{‘auto’, ‘predict_proba’, ‘decision_function’}, default=’auto’</span>
</dt>
<dd>
<p>Specifies whether to use <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-predict_proba"><span class="xref std std-term">predict_proba</span></a> or <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-decision_function"><span class="xref std std-term">decision_function</span></a> as the target response. For regressors this parameter is ignored and the response is always the output of <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-predict"><span class="xref std std-term">predict</span></a>. By default, <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-predict_proba"><span class="xref std std-term">predict_proba</span></a> is tried first and we revert to <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-decision_function"><span class="xref std std-term">decision_function</span></a> if it doesn’t exist. If <code>method</code> is <code>'recursion'</code>, the response is always the output of <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-decision_function"><span class="xref std std-term">decision_function</span></a>.</p> </dd> <dt>
<strong>n_cols</strong><span class="classifier">int, default=3</span>
</dt>
<dd>
<p>The maximum number of columns in the grid plot. Only active when <code>ax</code> is a single axis or <code>None</code>.</p> </dd> <dt>
<strong>grid_resolution</strong><span class="classifier">int, default=100</span>
</dt>
<dd>
<p>The number of equally spaced points on the axes of the plots, for each target feature.</p> </dd> <dt>
<strong>percentiles</strong><span class="classifier">tuple of float, default=(0.05, 0.95)</span>
</dt>
<dd>
<p>The lower and upper percentile used to create the extreme values for the PDP axes. Must be in [0, 1].</p> </dd> <dt>
<strong>method</strong><span class="classifier">str, default=’auto’</span>
</dt>
<dd>
<p>The method used to calculate the averaged predictions:</p> <ul class="simple"> <li>
<code>'recursion'</code> is only supported for some tree-based estimators (namely <a class="reference internal" href="sklearn.ensemble.gradientboostingclassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code>GradientBoostingClassifier</code></a>, <a class="reference internal" href="sklearn.ensemble.gradientboostingregressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code>GradientBoostingRegressor</code></a>, <a class="reference internal" href="sklearn.ensemble.histgradientboostingclassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code>HistGradientBoostingClassifier</code></a>, <a class="reference internal" href="sklearn.ensemble.histgradientboostingregressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code>HistGradientBoostingRegressor</code></a>, <a class="reference internal" href="sklearn.tree.decisiontreeregressor.html#sklearn.tree.DecisionTreeRegressor" title="sklearn.tree.DecisionTreeRegressor"><code>DecisionTreeRegressor</code></a>, <a class="reference internal" href="sklearn.ensemble.randomforestregressor.html#sklearn.ensemble.RandomForestRegressor" title="sklearn.ensemble.RandomForestRegressor"><code>RandomForestRegressor</code></a> but is more efficient in terms of speed. With this method, the target response of a classifier is always the decision function, not the predicted probabilities. Since the <code>'recursion'</code> method implicitly computes the average of the ICEs by design, it is not compatible with ICE and thus <code>kind</code> must be <code>'average'</code>.</li> <li>
<code>'brute'</code> is supported for any estimator, but is more computationally intensive.</li> <li>
<code>'auto'</code>: the <code>'recursion'</code> is used for estimators that support it, and <code>'brute'</code> is used otherwise.</li> </ul> <p>Please see <a class="reference internal" href="../partial_dependence.html#pdp-method-differences"><span class="std std-ref">this note</span></a> for differences between the <code>'brute'</code> and <code>'recursion'</code> method.</p> </dd> <dt>
<strong>n_jobs</strong><span class="classifier">int, default=None</span>
</dt>
<dd>
<p>The number of CPUs to use to compute the partial dependences. Computation is parallelized over features specified by the <code>features</code> parameter.</p> <p><code>None</code> means 1 unless in a <a class="reference external" href="https://joblib.readthedocs.io/en/latest/parallel.html#joblib.parallel_backend" title="(in joblib v1.3.0.dev0)"><code>joblib.parallel_backend</code></a> context. <code>-1</code> means using all processors. See <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-n_jobs"><span class="xref std std-term">Glossary</span></a> for more details.</p> </dd> <dt>
<strong>verbose</strong><span class="classifier">int, default=0</span>
</dt>
<dd>
<p>Verbose output during PD computations.</p> </dd> <dt>
<strong>line_kw</strong><span class="classifier">dict, default=None</span>
</dt>
<dd>
<p>Dict with keywords passed to the <code>matplotlib.pyplot.plot</code> call. For one-way partial dependence plots. It can be used to define common properties for both <code>ice_lines_kw</code> and <code>pdp_line_kw</code>.</p> </dd> <dt>
<strong>ice_lines_kw</strong><span class="classifier">dict, default=None</span>
</dt>
<dd>
<p>Dictionary with keywords passed to the <code>matplotlib.pyplot.plot</code> call. For ICE lines in the one-way partial dependence plots. The key value pairs defined in <code>ice_lines_kw</code> takes priority over <code>line_kw</code>.</p> </dd> <dt>
<strong>pd_line_kw</strong><span class="classifier">dict, default=None</span>
</dt>
<dd>
<p>Dictionary with keywords passed to the <code>matplotlib.pyplot.plot</code> call. For partial dependence in one-way partial dependence plots. The key value pairs defined in <code>pd_line_kw</code> takes priority over <code>line_kw</code>.</p> </dd> <dt>
<strong>contour_kw</strong><span class="classifier">dict, default=None</span>
</dt>
<dd>
<p>Dict with keywords passed to the <code>matplotlib.pyplot.contourf</code> call. For two-way partial dependence plots.</p> </dd> <dt>
<strong>ax</strong><span class="classifier">Matplotlib axes or array-like of Matplotlib axes, default=None</span>
</dt>
<dd>
<ul class="simple"> <li>If a single axis is passed in, it is treated as a bounding axes and a grid of partial dependence plots will be drawn within these bounds. The <code>n_cols</code> parameter controls the number of columns in the grid.</li> <li>If an array-like of axes are passed in, the partial dependence plots will be drawn directly into these axes.</li> <li>If <code>None</code>, a figure and a bounding axes is created and treated as the single axes case.</li> </ul> </dd> <dt>
<strong>kind</strong><span class="classifier">{‘average’, ‘individual’, ‘both’}, default=’average’</span>
</dt>
<dd> <p>Whether to plot the partial dependence averaged across all the samples in the dataset or one line per sample or both.</p> <ul class="simple"> <li>
<code>kind='average'</code> results in the traditional PD plot;</li> <li>
<code>kind='individual'</code> results in the ICE plot.</li> </ul>  <p>Note that the fast <code>method='recursion'</code> option is only available for <code>kind='average'</code>. Plotting individual dependencies requires using the slower <code>method='brute'</code> option.</p> </dd> <dt>
<strong>centered</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>If <code>True</code>, the ICE and PD lines will start at the origin of the y-axis. By default, no centering is done.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1.</span></p> </div> </dd> <dt>
<strong>subsample</strong><span class="classifier">float, int or None, default=1000</span>
</dt>
<dd>
<p>Sampling for ICE curves when <code>kind</code> is ‘individual’ or ‘both’. If <code>float</code>, should be between 0.0 and 1.0 and represent the proportion of the dataset to be used to plot ICE curves. If <code>int</code>, represents the absolute number samples to use.</p> <p>Note that the full dataset is still used to calculate averaged partial dependence when <code>kind='both'</code>.</p> </dd> <dt>
<strong>random_state</strong><span class="classifier">int, RandomState instance or None, default=None</span>
</dt>
<dd>
<p>Controls the randomness of the selected samples when subsamples is not <code>None</code> and <code>kind</code> is either <code>'both'</code> or <code>'individual'</code>. See <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-random_state"><span class="xref std std-term">Glossary</span></a> for details.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>display</strong><span class="classifier"><a class="reference internal" href="#sklearn.inspection.PartialDependenceDisplay" title="sklearn.inspection.PartialDependenceDisplay"><code>PartialDependenceDisplay</code></a></span>
</dt>
 </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.inspection.partial_dependence.html#sklearn.inspection.partial_dependence" title="sklearn.inspection.partial_dependence"><code>partial_dependence</code></a></dt>
<dd>
<p>Compute Partial Dependence values.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from sklearn.datasets import make_friedman1
&gt;&gt;&gt; from sklearn.ensemble import GradientBoostingRegressor
&gt;&gt;&gt; from sklearn.inspection import PartialDependenceDisplay
&gt;&gt;&gt; X, y = make_friedman1()
&gt;&gt;&gt; clf = GradientBoostingRegressor(n_estimators=10).fit(X, y)
&gt;&gt;&gt; PartialDependenceDisplay.from_estimator(clf, X, [0, (0, 1)])
&lt;...&gt;
&gt;&gt;&gt; plt.show()
</pre> <figure class="align-default"> <img alt="../../_images/sklearn-inspection-PartialDependenceDisplay-1.png" class="plot-directive" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAGACAMAAADs/iqNAAAACXBIWXMAAAxOAAAMTgF/d4wjAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8qNh9FAAACZ1BMVEXb6FUbGxt2VJEqKipixZ1vdaZZrKmW24D///9ikqofd7QPGBwJDxIMDBJVYxcXGQkSExt3rmUCAwNHhEIFDhMVFRUVQEH+/v4JCQz7/Pw4ODhhw5vf3980NDTAwMAvLy9AQEAQFgyqqqq2wUfq6uo+b5QkJCSgoKBra2sODg50hiAwWi0YTTtXqaZWpqMbMEAxXC719fU3ZjMyMjJWrYkfHyDY2NhSlsXB3zUaVEA9czkSDhhkZGRLSYk0hLtuzWdHj8FAi7/b29shY2QjcVdeXl7y8vLMzMxmbJn3+fofOEvC2uuDg4MpSmJyqdCjx+BhaCQmeF11dXWMzHeNjY2XwNxloszV1dVVVVXu9fosjWwka20ndndKb4FrcaAshYetzeRPdoseX0kqVkVdi6MvlnS41OctUm4qfoBQnJqxsbEsf7h+sdQyWncWQ0ROTk5IjIkQJCLM4O7m8Pcpg2U1YIDV5fHd6/QfXF3l5eUkQVZISEgYLyExMkqKioosLCweKRNISlMZTU4cVVcxkZOOutkynno4sIheY4w0pYBcnMmHttcfJDY1ORNGSG45Z4kmaFEkeraP0XpMlJI8OViTk5MxJUAnJydFhoQRHxY7Ozt8fHyamppZhZtat5FOnH1fwZlVWX/BzEvHx8eWlpZUfZIwMC62trZdvJY+fWNhd3QoPEZAfnszVl0aR0hRpIOBvW7Ozs5dQnMfRjlOVxhOgo5POGI3blwuiox0fCtFi24vTCmJnyVSm01Oc0KnuzQjOB4VNi9xUItyp2EUHiPR3lGYoTvR0dFfslleilCNlTY1qoNnwWBBxEHtAAAa0klEQVR42uydjU9TWRrGIcXObWWHnSq2lY8iECyjjFZgGU1jQG0V6SCiQhFnxq8RR9QKKMJAhOggMziNsJuN4geyqFGyq5hAgiirkBmdzew/tfcWFlBauPf23HNvz32eIDFK5Hruj/Oc9z3ve04cB+lacRgCAAABAAgAQAAAAgAQAIAAAAQAIAAAAQAIAEAAAAIAEACAAAAEACAAAAEACABAAAACABAAgAAABAAgAAABAAgAQAAAAgAQAIAAAAQAIAAAAQAIAEAAAAIAEACAAAAEACAAAAEACABAAACKYQAs8YpotSKa/cctYv5fiYtkS0y02NZJVdK6JGqyqABAvCJcNpoPKUi9mGdONC3SGqNx46rPPpGoLyviqCmeGQDKzPu0B8BOo/FnAEAHgFPmo5oEADMAJQCOmk/BArQFwI61OWnVwm/SbQ6Hw6UwAPvMZdoDoFbXFpCxnstcGwIgn8IMcMjcqD0AWvQ8A2Tn2jlrciotALrMl2EBmgJgt4H/lJYuAJCbn/ZIaQDOmptgARoFwOvlWjsyQ394MD4+PleRV1RuroEFaNQCBPmcCs8AVWY7LECji8BWK+e9c09hAHr6OO0BcETXUcBf1ubkV3PuM9zfDQ7DXavCABRt1yAA15AIopYIKi7hNGkBWwEAHQBKirVpAdcBAB0AthfBAnQNQH2PNi3gOACgAoDVXKVNC/gOAFABoNRcrkEArsICaAHQZD4LC9AzAJfNNzQIwGmj8TAAoAGAtVnRkkC5ADyHBdCaAZQtCYzCAnoBABUAlC0JlAvAt7AAWgAoWxIoF4DzsABaAChbEijqmS0rBcEC1AFA2ZJAuQDwFnARAFABoMvcrM1FICyADgA3FC0JjAKAXTIAeA8AJOcBzipaEhhFFCDHAuIAgGSVm0vZsQAAIF1VipYERgHAfgCgNAA1ZbyK6zltWgAAUByAIrOgEi0CUCvTAoaysoYAgNgJwFy0j1ezFgH4UdYM8DaY29mZGxwCACKTwIruAqgAQPAP4dX8EQQA4pZ/ygaA0QIgwwKSZt5NJwAQI3t9EaddAMbl5AE6QzPAe8wAy6usvLzK3KVhABrkZALfBpOC/EcWABAVAPRd1jQA8qKAt28RBYhRcUlpqZ3TMADPLvRukwzAGPIAYrWdhv/LB+Bxg21loqXzhUQAJgGA2C2gvipNA/BbSx5vAW+mkAlUCACFu0GiBmDlj6GawH6pAExUZMW9fw8AlpXC3SDRzwA7hZKwN+1S1wDBiWBFZ7ACACznAAo3A0QNwLGGxIZEm+Q1QGdc3DvbOySCRKQBlG0GIBAF/O32LulRgPDmk5AJFDEDnFK2FpxIKlhGb2BwIqsiWDGBTOCyUrgWPNIzz52Ba600dGTsiAzAP+XtBbwNJo29qxjDbuCyM8AhZUuBIz3z3PFnZ9LsnM8fGYCvf5R3PgDCQJFS9nTQSM88fwDiGYfXWllJ3AK+jAtOAAAxUrgSNMIzzx+BanXakvO9kQE4efX5hY2b30gHIGmCzlZQrANQ1WdVFYDdbfwM4BH+TDgC17Z4DdDwbHp0XecW6QDEZVGaBGIbAGUPh1zeApxXOK66cMlM4BeWVZ91Sl0EDiUNDQ2NIQpYVsqeDbj8IvBgm5270rZ0KlgGAOvWWUK3hwGA5URtM/DDZ547A7fUfaujLTUyAL9cvXCif2rzlAwLwCJQTBhIbTNQ9nZw4ujGqakXkgF4BwDEqIbaZiDdolDkAURK4ZPBogfg69PCcfG/vgAAygDQSG0zUG49wEthBvi1EwAoAwC9zcAoCkJs0qMAALBYXUVhVEJtM1DmETE8AHkyAJgcAgAfq75vexiVNGkbgE1rbj9PbH/9WiIAn2cBgI9FL+AjaQEnp397tnHq9QEAEC0AdnoBH+kwUMalUQBAzYhfA3kAALBI9Mp/iQOwFQAQAIBiyoc0ANcBAAEA6NV/wwLIATBXO8ndy8lx26MBoDE2AThWK6skjBUA5rbNU+OzrYFH0QBAMedHdC9gp6yiUEYAmC+cueLkuCcZ0QBwisY5QOQBuP+tni1gvnTuw8opOQAcpZf0hQUoCoBQPJkr/XvS6wAhbgGHYQEELEDh2wAUSwXr2gLmF4E7ol4E0msBIj4D9OoXgLnaST4MLIwuDLxhvgwL0HMiiF4PGFkLeIm9ADIAlNM4DRQWoGUASmMVgIsAgAAA9JoAYQGaBKCnnovVGWAXACAAAL0uUFiAJgEoLuFgAXoGgF4bMPEZYD8AIAAAvTZgAKBJAOp7YAG6BkDttgCZjSGYAQgBoHpbAABQF4CamAAA28GKAaB6WwDyAOoCoHpbgFwAapEJJAJAM5WbwWABmgVA9bYAWIC6AKjeFhBFVTDqAQgAoHpbAPoClgLA6wxw1ZlKAqB6WwBqApcCwO8zcC6HkgCo3hYAC1gKgHyOf/uKAqB6W4BcCzitCwtYy799V4eyADTHrAXooDm00mdID9xVEoAutdsC0Bu4FAB2X1qaz05mMO09JWFUr3ZbACyAVhjYZK4vDqMqKyxAuwC4szku201mMNXP+hO1gCO6sADHTChACIAuhgB4rA8LEAIAq4HMYDYzBYBgATo4JcztbG11ukkBcIilGeCILs4J9HqSk91eMoPZyBwAiAJ0DIBgAXo4K/jhel5kBlP9jV/MAJIBcBYG/H6/jgCYPwHz94xbtzJ1D0COi9hPkzUmAJg7/MiVk87Zs3VvAXcITqfql34s/8zzx5/d8yz8msV9ATqZASr9mU+ePNEPAPMHIFa62xyeuRnAYlu92rb6h03nQh+X9m66/7g2dGuYZAAmYwuAjJDIAKB+7Y8UAJzxrda7odVP6PbwFR/pkmkNbwEjrzeE1ev/RCRgLCsra+idLsPAWABgwQmYnoVn4P7pYwA2mXgLuL0rIbwGNkQE4MDnvD6d0aT2AbAfdHI70vUDwIJj0G95uYOBiADUnTuy05i3NQIACZv/KsYPxmIgDHTf4rxpZABQv/pPxDPPn4C53uBoa40IwJ5Lx1qMxu8iAbBF1G1in8bCbiC5msCYACCCFgHwj69CrUHMAyDUBNoJ1QSqX/5JEICfzh3baTQeZx4A93pHqtsJAHRrAS43ud1A9et/yVrASz1YAMnB7GIJAN4CWti3gEezIgXAZYYsIATAYcYB8HgCuYFArp/MYN5gCQC9WEAgleNSiQHQxJoF9OogD8ARywOcZQ+Aw8wDkOFrbfVlAADdWkCrPznZ30pmMFW/GoT8InAXwkBJAJSyZgEX2QeAYFEoUwDoxQJIFoVWme0MWcAlfVgAwaJQHgArQxZQJ2wGsW8BJItCq/o4pixAF9vB4YtCXf6cnNmSeUuHw5EubjB7WAJgxgL2s58HCFsU6vNwqckzFbMWr+jBVP16MPIWsF+nYaBhN8f510sFoKgeFhBzAIQvCs3NFo6PmgEg31HpEgnAduYs4Gf2w8APikLvJIeUugCAVM7lcc78rVA/n6sXAH6qe8xbQLdOi0IXWICQK+oQN5iqXxBI1gKEY8K6dVoUenduEZjt4qxOjw4B2HNTsIBunRaFzoaBj+7yP/0Ow3wH3dKDqfoNkURngDqhOZB9ALxCUaiLzGCyBcCMBYxjN1D8YKp+RShJAL65eewaD0D/IOth4JW2toOlAGAxAHtPClFA+9PwAKz6txgAKoY0D4AncOZMwA0AFgGwYpOp9gtjd++rVw8KwgBQsE0MAJOTmgfAYOVnAUIHRap+STBRAG6aWq7tnE5saO9veJWyCICUDWIAOFCh/b0AfgHoamMfgBzJAOy9bzKtDjWGjPSHmQO2hT85YsMWiv3hRMJAh8+X7xTfGrLU91T9luhwqq6uTuZ/xUsGoK6OB2CmN7ChIEG0tnxwdsj/T4pQRBNE1gCzIgGAWYsAWAoL+Y9Cy3Jf9mdBH4YBJlPDs+sDAwXD0xIAGNjyCTVpLAy0ahKAwtbQM8dLBmDPXpNpzaiwBmgfEf/+E1I2xxYABK+NK1X9mvBwcqaHntkp2QIEAFry/jsyMpCQwDAABK+N0yYAsqMAPgzgA0EhF5zCMgAEr42rYQsAYQZouN0t6e3HIAAEr42rMZ9lCoAfTKar33cnMA4AwWvjmtgC4JtLvAXkCQAMDjIMAMFr4xgDIGQB/+rmVwAFwwXsAkBwMLV6aVgUFtBg2S+sAUeHWQWgclaEAOhizQKmR6eFgoAT46wC4PN5Cp3OQjK7gc1sASBYwMrx6+29A0/ZnQE4rk24OLKNEACHWLOA6WfdI9Pt06MMrwEMc5+iHsxGtgBYcc5kOi8sAl8ND7CcCXQ/fOj2A4DwFnA+lAlMSBlkeC+gMj+/ksxJoVq9MkjuIvCr2TxASsKDVwgDdQgAbwHXvg8BMH4CACw/mNYyjV4ZFE0iyHb8wdPBhGEAIGYwT7EFgGABR25PJ7aPF2AG0CUAdbwF5HUPDrf3948CABGDqdUrg6KOAgbYzQQmzwoARLCAmShASk1IbAGQOitCAJQxaAGhl5oCCxAxmPvYAmBBIojlgpAdgXhSFrCPvRngdB7zAGRkGn53+4gMplbvjIp0fTznMuQvNQPUCSVh11kHIJ/r4KwZOgJg7ubQ/7F3Lk5NHXscHxqiGwIzeHpDDggEmQBhrHDTXOqgIBZDFAbsQFEeKlQK5WERUKhFnoO3XKwMUKEgr7aOOsXh+p5x7tjRcVpmqNP+UXc3DwIk55zNyQH37Nnf/Ewg+Z0155cP+93dc3YXbR/tkJKA/5bTDkASSEi05ygEwDfkA+DfOxgkdyQ7pCTgTjf1N4VaM0wRNkUA+E4NAPh3D7c7esUBKNOEBKC+4DpQCIBragLAtgS8AATdPl4bElAM7G5TBIBbagDALwFDOTkmTidSA7QbDPWdlEuAA3BuUwiAq+QDsLkRCCQl4PK0FiRAqT7116oAwL99/BYAgs8O1kAvwLbxoAAANSoAQMCCrA8AJeB/nbX0jwMApSaHnlYzAEHGAdwS0EQ3AKnVmdXV1X0LCgFQTBUAWpCA9YycjIyMNhcDIPjMoPpp2iUgHi0OZFYmmaTuGRXGxBDqJQD2ipRL5tkowCRAdQBUDlqVGggiddMwJgFiACg4EPQ9XQB4JKCWDQThA3CJOgl4TL8EwHagMhJw9fSxYxRKAPWNwHtDykiA+bOoqO/pkwD6RwIT7llcpZUKJPNM1BUzdRIwQr8EoFvCgBK3hBF7O0g4C0W20C8BSSDlmTVHEQCuAepqAA1IQKX110x+UIFk3qIRAPolYD21EMS7lEgmsXcDhCMB51spl4D7mUmZbcokk9i7AZgEiACg6wXrwa4FLw1xP/r6iZb0lF6MZJ6mEYAbtEuABQS/G2S9qsgLgDk9GQxWYwFQTKMEUH5PoK6qqgr9Cwz0AYBuo3bx8dLJJPZisOyRQCQBMiaGHFQTADleEwYgFS0iaUrEAIDUS0Gya4Bsg+HEnYZaZ1M38tFy5DehO51/OZ3CC8cdVFc3cKsteNaLSAwOAJpAkam6S0HhSUDrdOeGZ3VueC2lAIQhAYcvUVgD3OjcE9ycPwvvG3ebKgCwG4GHj9EGAGwDnGvVKAAZEXxmxDNwfxG/G3icOgB6kAQIAPDXL7TXACEn8/inTAI0DcCnx5kEaBqAY+oGIHBqGJOAEAE4TBsATAJCSiape8eHJQHnmQRgJ/MH6gBoF2kD3GQSEADAWdoAYBIQSjLJ3Ds+LACui0hAOQNgmxG7dfgOScAKA2Cr1dAHwK5LwNO388NP0Q9/DM8Pv4HPb4aH+/epBoCvNSUBT3YAgLfv9r57i37Y93TvbfjLvgO3974bVgcA5qv0AdAMJWBaAIDRHZCAz3n4cOCp97eP30AAPt/75jeV1ADE7hwdlgScOCcAQFODIACvDyL758fIXocCwL55+DD8h5eGA7Duf8MdmH+qEgCI3ThYPgBlBsNyiwAAh5wSe0is/ITsw9+OYNnfBdBez8OH4dfox4K/h48UFPzZ/2fBkf4CYSMLgDMUSoBhZI+QNZTfdCIfdXZ7vMlZC712633kK//CMvew0k/8L5H7o93bFK/0T8FHtFnZCucm7dWXwYwkAK7QBwCUAEOcIADTd7LuQO+E3op82uPTLyJlW//DyFf9/u8/8mHXSuTDeZEDSAKA2G1Dw5IAQ8ueUO2mfACe9M93PYl88Spyiuvq6pqK3P/lfFf/zwwAMiVAyD6K3D0jCQBid43cKQlgAFAPwK5LgKoBIHbXyPAAeMxqAO0CwCQglGQSu2lgeI3AeiYBmNcCPiN1z7jwJOAyqwEwk3mGPgDkSUCuRmuAM+QuEra7EjCq0RqA4EXCwrgfgDUCsZN5iz4AmASEkkyCFwkL455AGRLQpFkAapgEaFkCTqsFgI3t45OTdLpFs4QEhN4NbNAsAMXqAGBj59BnhcC+kMEkQCEACF4kTGj7eGi2UiYBSgFA7iJhAruHQ+s1nZSQgMdMAjABIHiRMEEAXEmejRKCbx+P1geQcTm4VqMAHFYJAJskwJVQKtoLKGESEAoAx9QBgL8R6FoolR4ICv2WsCmNAkDwGlEC28eXchaLRawRyCSASgAELMgSMfIk4MV+bQJA8CJhYawRZBg5FCoA3aMf5SJvmGpqcDblTtXmOrtzy6GX53ZDd+bWTiFvaoAhuaO5uTd9PprbAN19BOZB/yEJAILXiMICgM/fZnr95KTB8O8bcedH4lqgP46rvxxXH+fxyy2XW0UxOJTV2oo8K+sQ8kMbnrXd9/g84C3pgxgACgIw+/Il8ufQZ2afP4cEoB0jBG35xLm4b8/FnTgRd+5b5OdvuD2AlPq4kZa4kfNxN6D7jthyUDC8MA+6QRIABC8ShgfAB9ss39MIINpIAuAH6gCYcHcDGAC4AJylDYBYdyuQAYCXTJIXCZMNAJMA/GSSvEgYk4BdAKCGNgBm89FAwIVVBgBeMkleI0oWADH56IaA5WgGAF4ySV4jShYAXExMDB8dzTEA8JJJ8hpRsgDgJ8bGxi8+uMgAwEsmyUsEyQLgaL7nnjAGAF4ySV4hRvZIYDsDIAQAvqAPADYQhJ/MrwheH0J2N5BJAHYyzV/QBsDLfM/0YI0CsDTEeXcOBdyQxZIsmUySFwhhEhA6AOtVRRsAuHCSSfL6ELIA+B0BsPpIuxIQIgDfEbw+hNxu4Izx0fgqA4BzWCrskskkeXkAuQDEZjc2GjUGwILJbYmbAEgE9iKb50c0gyYz+IEkLw8gF4C1sp5sI6sBoN0bkkwmybPDZQEwc3RiZnxijUmA1Q7MtiIMAOIp6wXMrPF8bPYDjQKQEcFnRjwD9xfhX79FV2SVTCbJk4NldwP1+rILbCAIL5kkTw6WOxBUNzbWzADATCbJc0PlNgJPcTzP7gfATCbJUwPxpoYdReYHIBZKwJq+zMgAwEsmyVMDZQGAaoA1fTsDADOZJM8Mk3c1cG1ifIYBgJ1MkmeGybsWMAu/f31ZOwMAL5kkTwwKoxvYs8wAwEom0RODwgCg+QEDACuZRE8MYgNBOw6AmeTN45kE7EINcJXkeSHhSACbFyCWTJ3OVwNcC5gXsvEekH5j60uCRwa8GRDpe2HbG9gAbB4IGKgLkACjcKcw6FvbXjRK9Cmlw30v+Z6JASDI3uGqB2C2LkACGACCNcCVgHkhqgdgIlACGACCNUDgvBAmAZqqAb6iD4BxBMAkkwC8GiBwXgiTAE0BEDgvhEmAwDe6Gs15qbpgNBpXGw2GR0bj+LLKAQicF0KJBDQqDsCF5WgvAKjs8UeQg0bD9VXVA/ANdRJwCtUAzTsgAdF+XWmEADyCX/5FXuUABM4LUT0AH4zDVkBd9k4C8MDIZTfCGmDZsMotqxuAwHkh6gfg9xkoAmll2c3Xs9vd3sPzPSXZk9kbXtKD/Ho7dJ5vzi6DXoa82XsQH12SjY5AB5WkpUVHp7ntH+1pPptcK0tLu240lnCT/ve9tu3XzS/5nskBIHBeiPoBgHXAbP6W9eO3LScv+da2F2NjJ6Dr9TFj/tcmxt1Pd2M84XcHJiYG7no8hh+bGfD4qQGP87HocWaM58fg48AESQAUqx0AtFR4DO9bLRy6GwFlAfA8+wAYq9PXjQ/o9afg04xweJCXfM/vEYDiGmhzczVeC9w1UPU1wMwOATAQw/FH9frZCT2sD2JRZzM29uiMXm0AnI6CZjRG+ewSoA2A2Y1rwkrXAJhlEAoAF4GmCEdgGwmhHO55KfB/7moU9x4AwP6TUmGoEgXtfhQDgAHAAGAA7C4AlXSGKlHQ7ke9DwCYqdYYAAwAZgwAWVaYkJ5U5f5pKT09Lx6Atrn0apd4aHKSTrdoBolon+ZCiVAextixSs2AkaYOsVJtOdw6wPusIZy492yk0gPsOod0EtdT5uZSpaLMFbqhlEJCANjYdz0xwmruuA9cpk+ArUI89FkhsC9kgESTdKnJnqThlIpsKFWs1OTeHA8A0p81hBP3ng2Q+nQVeQ7JsuzpySDeKhXVlhQPSqvJAMCaGQ/MaAVBMGgD4NcUkNoHQFWOeKj7r7FU5Kvyh3oBwCz1nileDAAAvABIftZQTtx7NlJRyR3JDsmylopw/sc2i8tcUUEGACfR+HoSWjbaNujOZiXMrZ0zi4ZC6zWdhJV1kqM0XrzU5ExH0n2AW2oezIpwqX4AJD9rKCfuPRuJKLujVxAAf1RFXp+lyCoVZbbxJodL1QC4kmBvttgKrCmD4qW6XKAX1ut4pdozq8RK3TEA3GcjlZ4lgAGALaLXvFgtFXWyD9YARWqWAFeCr8pM7ZCuX0ttmBKQkSBa6k5JgP9sRKKGcnJMnE4yiUXCn8gf5eWXsEZgIX4j0LXgzpg1HhRXL4qH9pph9BJmIzBlSbzUDQAKlWwEes9GshEoXANsaknPuUBlh1RUZV88GOwjBIBPEtIdVSCvDXWtcrxdqw6XeGgp6qmVglSdRWcrFg/9EcagPhZGqaAwE0WIlGqL4EzpeJ81hBP3no1UesQA8Edl6Cx9vVJRxXlzQ32JbCCIGQOAGQOAGQOA2f/bs4MTgGEYCIL9d51HPlEHy2WmA8FiG0sACIDBAD7LtC2xwbIBnFXfkthg1QDul/CQ2mDVAM7KbUltMAEIwEnpCvBW8giseRdgg2KD+Qj6OQEIAAEgAASAABAAAkAACAABMO8B46d+Fg74/BoAAAAASUVORK5CYII="> </figure> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.inspection.PartialDependenceDisplay.plot"> <span class="sig-name descname">plot</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n_cols</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">line_kw</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ice_lines_kw</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pd_line_kw</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">contour_kw</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pdp_lim</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">centered</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/inspection/_plot/partial_dependence.py#L1291"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Plot partial dependence plots.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>ax</strong><span class="classifier">Matplotlib axes or array-like of Matplotlib axes, default=None</span>
</dt>
<dd>
<ul class="simple"> <li>
<dl class="simple"> <dt>If a single axis is passed in, it is treated as a bounding axes</dt>
<dd>
<p>and a grid of partial dependence plots will be drawn within these bounds. The <code>n_cols</code> parameter controls the number of columns in the grid.</p> </dd> </dl> </li> <li>
<dl class="simple"> <dt>If an array-like of axes are passed in, the partial dependence</dt>
<dd>
<p>plots will be drawn directly into these axes.</p> </dd> </dl> </li> <li>
<dl class="simple"> <dt>If <code>None</code>, a figure and a bounding axes is created and treated</dt>
<dd>
<p>as the single axes case.</p> </dd> </dl> </li> </ul> </dd> <dt>
<strong>n_cols</strong><span class="classifier">int, default=3</span>
</dt>
<dd>
<p>The maximum number of columns in the grid plot. Only active when <code>ax</code> is a single axes or <code>None</code>.</p> </dd> <dt>
<strong>line_kw</strong><span class="classifier">dict, default=None</span>
</dt>
<dd>
<p>Dict with keywords passed to the <code>matplotlib.pyplot.plot</code> call. For one-way partial dependence plots.</p> </dd> <dt>
<strong>ice_lines_kw</strong><span class="classifier">dict, default=None</span>
</dt>
<dd>
<p>Dictionary with keywords passed to the <code>matplotlib.pyplot.plot</code> call. For ICE lines in the one-way partial dependence plots. The key value pairs defined in <code>ice_lines_kw</code> takes priority over <code>line_kw</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </dd> <dt>
<strong>pd_line_kw</strong><span class="classifier">dict, default=None</span>
</dt>
<dd>
<p>Dictionary with keywords passed to the <code>matplotlib.pyplot.plot</code> call. For partial dependence in one-way partial dependence plots. The key value pairs defined in <code>pd_line_kw</code> takes priority over <code>line_kw</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </dd> <dt>
<strong>contour_kw</strong><span class="classifier">dict, default=None</span>
</dt>
<dd>
<p>Dict with keywords passed to the <code>matplotlib.pyplot.contourf</code> call for two-way partial dependence plots.</p> </dd> <dt>
<strong>pdp_lim</strong><span class="classifier">dict, default=None</span>
</dt>
<dd>
<p>Global min and max average predictions, such that all plots will have the same scale and y limits. <code>pdp_lim[1]</code> is the global min and max for single partial dependence curves. <code>pdp_lim[2]</code> is the global min and max for two-way partial dependence curves. If <code>None</code> (default), the limit will be inferred from the global minimum and maximum of all predictions.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1.</span></p> </div> </dd> <dt>
<strong>centered</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>If <code>True</code>, the ICE and PD lines will start at the origin of the y-axis. By default, no centering is done.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>display</strong><span class="classifier"><a class="reference internal" href="#sklearn.inspection.PartialDependenceDisplay" title="sklearn.inspection.PartialDependenceDisplay"><code>PartialDependenceDisplay</code></a></span>
</dt>
 </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="examples-using-sklearn-inspection-partialdependencedisplay"> <h2>Examples using <code>sklearn.inspection.PartialDependenceDisplay</code>
</h2> <div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="    See also sphx_glr_auto_examples_miscellaneous_plot_roc_curve_visualization_api.py">
<img alt="Advanced Plotting With Partial Dependence" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/miscellaneous/plot_partial_dependence_visualization_api.html#sphx-glr-auto-examples-miscellaneous-plot-partial-dependence-visualization-api-py"><span class="std std-ref">Advanced Plotting With Partial Dependence</span></a></p>  </div></div>
</section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.inspection.PartialDependenceDisplay.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.inspection.PartialDependenceDisplay.html</a>
  </p>
</div>
