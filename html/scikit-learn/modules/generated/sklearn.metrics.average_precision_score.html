<section id="average-precision-score"> <h1>average_precision_score</h1> <dl class="py function"> <dt class="sig sig-object py" id="sklearn.metrics.average_precision_score"> <span class="sig-prename descclassname">sklearn.metrics.</span><span class="sig-name descname">average_precision_score</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_true</span></em>, <em class="sig-param"><span class="n">y_score</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">average</span><span class="o">=</span><span class="default_value">'macro'</span></em>, <em class="sig-param"><span class="n">pos_label</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/metrics/_ranking.py#L109"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute average precision (AP) from prediction scores.</p> <p>AP summarizes a precision-recall curve as the weighted mean of precisions achieved at each threshold, with the increase in recall from the previous threshold used as the weight:</p> <div class="math notranslate nohighlight"> \[\text{AP} = \sum_n (R_n - R_{n-1}) P_n\]</div> <p>where <span class="math notranslate nohighlight">\(P_n\)</span> and <span class="math notranslate nohighlight">\(R_n\)</span> are the precision and recall at the nth threshold <a class="reference internal" href="#rcdf8f32d7f9d-1" id="id1">[1]</a>. This implementation is not interpolated and is different from computing the area under the precision-recall curve with the trapezoidal rule, which uses linear interpolation and can be too optimistic.</p> <p>Read more in the <a class="reference internal" href="../model_evaluation.html#precision-recall-f-measure-metrics"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>y_true</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_classes)</span>
</dt>
<dd>
<p>True binary labels or binary label indicators.</p> </dd> <dt>
<strong>y_score</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_classes)</span>
</dt>
<dd>
<p>Target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions (as returned by <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-decision_function"><span class="xref std std-term">decision_function</span></a> on some classifiers). For <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-decision_function"><span class="xref std std-term">decision_function</span></a> scores, values greater than or equal to zero should indicate the positive class.</p> </dd> <dt>
<strong>average</strong><span class="classifier">{‘micro’, ‘samples’, ‘weighted’, ‘macro’} or None, default=’macro’</span>
</dt>
<dd>
<p>If <code>None</code>, the scores for each class are returned. Otherwise, this determines the type of averaging performed on the data:</p> <dl class="simple"> <dt>
<code>'micro'</code>:</dt>
<dd>
<p>Calculate metrics globally by considering each element of the label indicator matrix as a label.</p> </dd> <dt>
<code>'macro'</code>:</dt>
<dd>
<p>Calculate metrics for each label, and find their unweighted mean. This does not take label imbalance into account.</p> </dd> <dt>
<code>'weighted'</code>:</dt>
<dd>
<p>Calculate metrics for each label, and find their average, weighted by support (the number of true instances for each label).</p> </dd> <dt>
<code>'samples'</code>:</dt>
<dd>
<p>Calculate metrics for each instance, and find their average.</p> </dd> </dl> <p>Will be ignored when <code>y_true</code> is binary.</p> </dd> <dt>
<strong>pos_label</strong><span class="classifier">int, float, bool or str, default=1</span>
</dt>
<dd>
<p>The label of the positive class. Only applied to binary <code>y_true</code>. For multilabel-indicator <code>y_true</code>, <code>pos_label</code> is fixed to 1.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>average_precision</strong><span class="classifier">float</span>
</dt>
<dd>
<p>Average precision score.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.metrics.roc_auc_score.html#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a></dt>
<dd>
<p>Compute the area under the ROC curve.</p> </dd> <dt><a class="reference internal" href="sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a></dt>
<dd>
<p>Compute precision-recall pairs for different probability thresholds.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.19: </span>Instead of linearly interpolating between operating points, precisions are weighted by the change in recall since the last operating point.</p> </div> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="rcdf8f32d7f9d-1" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span> <p><a class="reference external" href="https://en.wikipedia.org/w/index.php?title=Information_retrieval&amp;oldid=793358396#Average_precision">Wikipedia entry for the Average precision</a></p> </div> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import average_precision_score
&gt;&gt;&gt; y_true = np.array([0, 0, 1, 1])
&gt;&gt;&gt; y_scores = np.array([0.1, 0.4, 0.35, 0.8])
&gt;&gt;&gt; average_precision_score(y_true, y_scores)
np.float64(0.83...)
&gt;&gt;&gt; y_true = np.array([0, 0, 1, 1, 2, 2])
&gt;&gt;&gt; y_scores = np.array([
...     [0.7, 0.2, 0.1],
...     [0.4, 0.3, 0.3],
...     [0.1, 0.8, 0.1],
...     [0.2, 0.3, 0.5],
...     [0.4, 0.4, 0.2],
...     [0.1, 0.2, 0.7],
... ])
&gt;&gt;&gt; average_precision_score(y_true, y_scores)
np.float64(0.77...)
</pre> </dd>
</dl> <section id="gallery-examples"> <h2>Gallery examples</h2> <div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Example of Precision-Recall metric to evaluate classifier output quality.">
<img alt="" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/model_selection/plot_precision_recall.html#sphx-glr-auto-examples-model-selection-plot-precision-recall-py"><span class="std std-ref">Precision-Recall</span></a></p>  </div></div></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/generated/sklearn.metrics.average_precision_score.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/generated/sklearn.metrics.average_precision_score.html</a>
  </p>
</div>
