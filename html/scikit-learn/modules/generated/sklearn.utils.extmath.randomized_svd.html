<section id="sklearn-utils-extmath-randomized-svd"> <h1>sklearn.utils.extmath.randomized_svd</h1> <dl class="py function"> <dt class="sig sig-object py" id="sklearn.utils.extmath.randomized_svd"> <span class="sig-prename descclassname">sklearn.utils.extmath.</span><span class="sig-name descname">randomized_svd</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">n_components</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">n_oversamples</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">n_iter</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">power_iteration_normalizer</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">transpose</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">flip_sign</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">'warn'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/utils/extmath.py#L250"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Computes a truncated randomized SVD.</p> <p>This method solves the fixed-rank approximation problem described in the Halko et al paper (problem (1.5), p5).</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>M</strong><span class="classifier">{ndarray, sparse matrix}</span>
</dt>
<dd>
<p>Matrix to decompose.</p> </dd> <dt>
<strong>n_components</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of singular values and vectors to extract.</p> </dd> <dt>
<strong>n_oversamples</strong><span class="classifier">int, default=10</span>
</dt>
<dd>
<p>Additional number of random vectors to sample the range of M so as to ensure proper conditioning. The total number of random vectors used to find the range of M is n_components + n_oversamples. Smaller number can improve speed but can negatively impact the quality of approximation of singular vectors and singular values. Users might wish to increase this parameter up to <code>2*k - n_components</code> where k is the effective rank, for large matrices, noisy problems, matrices with slowly decaying spectrums, or to increase precision accuracy. See Halko et al (pages 5, 23 and 26).</p> </dd> <dt>
<strong>n_iter</strong><span class="classifier">int or ‘auto’, default=’auto’</span>
</dt>
<dd>
<p>Number of power iterations. It can be used to deal with very noisy problems. When ‘auto’, it is set to 4, unless <code>n_components</code> is small (&lt; .1 * min(X.shape)) in which case <code>n_iter</code> is set to 7. This improves precision with few components. Note that in general users should rather increase <code>n_oversamples</code> before increasing <code>n_iter</code> as the principle of the randomized method is to avoid usage of these more costly power iterations steps. When <code>n_components</code> is equal or greater to the effective matrix rank and the spectrum does not present a slow decay, <code>n_iter=0</code> or <code>1</code> should even work fine in theory (see Halko et al paper, page 9).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.18.</span></p> </div> </dd> <dt>
<strong>power_iteration_normalizer</strong><span class="classifier">{‘auto’, ‘QR’, ‘LU’, ‘none’}, default=’auto’</span>
</dt>
<dd>
<p>Whether the power iterations are normalized with step-by-step QR factorization (the slowest but most accurate), ‘none’ (the fastest but numerically unstable when <code>n_iter</code> is large, e.g. typically 5 or larger), or ‘LU’ factorization (numerically stable but can lose slightly in accuracy). The ‘auto’ mode applies no normalization if <code>n_iter</code> &lt;= 2 and switches to LU otherwise.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.18.</span></p> </div> </dd> <dt>
<strong>transpose</strong><span class="classifier">bool or ‘auto’, default=’auto’</span>
</dt>
<dd>
<p>Whether the algorithm should be applied to M.T instead of M. The result should approximately be the same. The ‘auto’ mode will trigger the transposition if M.shape[1] &gt; M.shape[0] since this implementation of randomized SVD tend to be a little faster in that case.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.18.</span></p> </div> </dd> <dt>
<strong>flip_sign</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>The output of a singular value decomposition is only unique up to a permutation of the signs of the singular vectors. If <code>flip_sign</code> is set to <code>True</code>, the sign ambiguity is resolved by making the largest loadings for each component in the left singular vectors positive.</p> </dd> <dt>
<strong>random_state</strong><span class="classifier">int, RandomState instance or None, default=’warn’</span>
</dt>
<dd>
<p>The seed of the pseudo random number generator to use when shuffling the data, i.e. getting the random vectors to initialize the algorithm. Pass an int for reproducible results across multiple function calls. See <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-random_state"><span class="xref std std-term">Glossary</span></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.2: </span>The previous behavior (<code>random_state=0</code>) is deprecated, and from v1.2 the default value will be <code>random_state=None</code>. Set the value of <code>random_state</code> explicitly to suppress the deprecation warning.</p> </div> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This algorithm finds a (usually very good) approximate truncated singular value decomposition using randomization to speed up the computations. It is particularly fast on large matrices on which you wish to extract only a small number of components. In order to obtain further speed up, <code>n_iter</code> can be set &lt;=2 (at the cost of loss of precision). To increase the precision it is recommended to increase <code>n_oversamples</code>, up to <code>2*k-n_components</code> where k is the effective rank. Usually, <code>n_components</code> is chosen to be greater than k so increasing <code>n_oversamples</code> up to <code>n_components</code> should be enough.</p> <h4 class="rubric">References</h4> <ul class="simple"> <li>
<a class="reference external" href="https://arxiv.org/abs/0909.4061">“Finding structure with randomness: Stochastic algorithms for constructing approximate matrix decompositions”</a> Halko, et al. (2009)</li> <li>A randomized algorithm for the decomposition of matrices Per-Gunnar Martinsson, Vladimir Rokhlin and Mark Tygert</li> <li>An implementation of a randomized algorithm for principal component analysis A. Szlam et al. 2014</li> </ul> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.utils.extmath.randomized_svd.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.utils.extmath.randomized_svd.html</a>
  </p>
</div>
