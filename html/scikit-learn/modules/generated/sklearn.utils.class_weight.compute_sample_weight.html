<section id="compute-sample-weight"> <h1>compute_sample_weight</h1> <dl class="py function"> <dt class="sig sig-object py" id="sklearn.utils.class_weight.compute_sample_weight"> <span class="sig-prename descclassname">sklearn.utils.class_weight.</span><span class="sig-name descname">compute_sample_weight</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">class_weight</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/class_weight.py#L95"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate sample weights by class for unbalanced datasets.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>class_weight</strong><span class="classifier">dict, list of dicts, “balanced”, or None</span>
</dt>
<dd>
<p>Weights associated with classes in the form <code>{class_label: weight}</code>. If not given, all classes are supposed to have weight one. For multi-output problems, a list of dicts can be provided in the same order as the columns of y.</p> <p>Note that for multioutput (including multilabel) weights should be defined for each class of every column in its own dict. For example, for four-class multilabel classification weights should be <code>[{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}]</code> instead of <code>[{1:1}, {2:5}, {3:1}, {4:1}]</code>.</p> <p>The <code>"balanced"</code> mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data: <code>n_samples / (n_classes * np.bincount(y))</code>.</p> <p>For multi-output, the weights of each column of y will be multiplied.</p> </dd> <dt>
<strong>y</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples,) or (n_samples, n_outputs)</span>
</dt>
<dd>
<p>Array of original class labels per sample.</p> </dd> <dt>
<strong>indices</strong><span class="classifier">array-like of shape (n_subsample,), default=None</span>
</dt>
<dd>
<p>Array of indices to be used in a subsample. Can be of length less than <code>n_samples</code> in the case of a subsample, or equal to <code>n_samples</code> in the case of a bootstrap subsample with repeated indices. If <code>None</code>, the sample weight will be calculated over the full sample. Only <code>"balanced"</code> is supported for <code>class_weight</code> if this is provided.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>sample_weight_vect</strong><span class="classifier">ndarray of shape (n_samples,)</span>
</dt>
<dd>
<p>Array with sample weights as applied to the original <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.utils.class_weight import compute_sample_weight
&gt;&gt;&gt; y = [1, 1, 1, 1, 0, 0]
&gt;&gt;&gt; compute_sample_weight(class_weight="balanced", y=y)
array([0.75, 0.75, 0.75, 0.75, 1.5 , 1.5 ])
</pre> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/generated/sklearn.utils.class_weight.compute_sample_weight.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/generated/sklearn.utils.class_weight.compute_sample_weight.html</a>
  </p>
</div>
