<section id="sklearn-svm-nusvr"> <h1>sklearn.svm.NuSVR</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.svm.NuSVR"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.svm.</span><span class="sig-name descname">NuSVR</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">nu</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">C</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">kernel</span><span class="o">=</span><span class="default_value">'rbf'</span></em>, <em class="sig-param"><span class="n">degree</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">gamma</span><span class="o">=</span><span class="default_value">'scale'</span></em>, <em class="sig-param"><span class="n">coef0</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">shrinking</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">cache_size</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">-1</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/svm/_classes.py#L1261"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Nu Support Vector Regression.</p> <p>Similar to NuSVC, for regression, uses a parameter nu to control the number of support vectors. However, unlike NuSVC, where nu replaces C, here nu replaces the parameter epsilon of epsilon-SVR.</p> <p>The implementation is based on libsvm.</p> <p>Read more in the <a class="reference internal" href="../svm.html#svm-regression"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>nu</strong><span class="classifier">float, default=0.5</span>
</dt>
<dd>
<p>An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1]. By default 0.5 will be taken.</p> </dd> <dt>
<strong>C</strong><span class="classifier">float, default=1.0</span>
</dt>
<dd>
<p>Penalty parameter C of the error term.</p> </dd> <dt>
<strong>kernel</strong><span class="classifier">{‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’} or callable, default=’rbf’</span>
</dt>
<dd>
<p>Specifies the kernel type to be used in the algorithm. If none is given, ‘rbf’ will be used. If a callable is given it is used to precompute the kernel matrix.</p> </dd> <dt>
<strong>degree</strong><span class="classifier">int, default=3</span>
</dt>
<dd>
<p>Degree of the polynomial kernel function (‘poly’). Ignored by all other kernels.</p> </dd> <dt>
<strong>gamma</strong><span class="classifier">{‘scale’, ‘auto’} or float, default=’scale’</span>
</dt>
<dd>
<p>Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.</p> <ul class="simple"> <li>if <code>gamma='scale'</code> (default) is passed then it uses 1 / (n_features * X.var()) as value of gamma,</li> <li>if ‘auto’, uses 1 / n_features.</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.22: </span>The default value of <code>gamma</code> changed from ‘auto’ to ‘scale’.</p> </div> </dd> <dt>
<strong>coef0</strong><span class="classifier">float, default=0.0</span>
</dt>
<dd>
<p>Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.</p> </dd> <dt>
<strong>shrinking</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to use the shrinking heuristic. See the <a class="reference internal" href="../svm.html#shrinking-svm"><span class="std std-ref">User Guide</span></a>.</p> </dd> <dt>
<strong>tol</strong><span class="classifier">float, default=1e-3</span>
</dt>
<dd>
<p>Tolerance for stopping criterion.</p> </dd> <dt>
<strong>cache_size</strong><span class="classifier">float, default=200</span>
</dt>
<dd>
<p>Specify the size of the kernel cache (in MB).</p> </dd> <dt>
<strong>verbose</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.</p> </dd> <dt>
<strong>max_iter</strong><span class="classifier">int, default=-1</span>
</dt>
<dd>
<p>Hard limit on iterations within solver, or -1 for no limit.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>class_weight_</strong><span class="classifier">ndarray of shape (n_classes,)</span>
</dt>
<dd>
<p>Multipliers of parameter C for each class. Computed based on the <code>class_weight</code> parameter.</p> </dd> <dt>
<a class="reference internal" href="#sklearn.svm.NuSVR.coef_" title="sklearn.svm.NuSVR.coef_"><code>coef_</code></a><span class="classifier">ndarray of shape (1, n_features)</span>
</dt>
<dd>
<p>Weights assigned to the features when <code>kernel="linear"</code>.</p> </dd> <dt>
<strong>dual_coef_</strong><span class="classifier">ndarray of shape (1, n_SV)</span>
</dt>
<dd>
<p>Coefficients of the support vector in the decision function.</p> </dd> <dt>
<strong>fit_status_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>0 if correctly fitted, 1 otherwise (will raise warning)</p> </dd> <dt>
<strong>intercept_</strong><span class="classifier">ndarray of shape (1,)</span>
</dt>
<dd>
<p>Constants in decision function.</p> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.24.</span></p> </div> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.1/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </dd> <dt>
<strong>n_iter_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of iterations run by the optimization routine to fit the model.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1.</span></p> </div> </dd> <dt>
<a class="reference internal" href="#sklearn.svm.NuSVR.n_support_" title="sklearn.svm.NuSVR.n_support_"><code>n_support_</code></a><span class="classifier">ndarray of shape (1,), dtype=int32</span>
</dt>
<dd>
<p>Number of support vectors for each class.</p> </dd> <dt>
<strong>shape_fit_</strong><span class="classifier">tuple of int of shape (n_dimensions_of_X,)</span>
</dt>
<dd>
<p>Array dimensions of training vector <code>X</code>.</p> </dd> <dt>
<strong>support_</strong><span class="classifier">ndarray of shape (n_SV,)</span>
</dt>
<dd>
<p>Indices of support vectors.</p> </dd> <dt>
<strong>support_vectors_</strong><span class="classifier">ndarray of shape (n_SV, n_features)</span>
</dt>
<dd>
<p>Support vectors.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.svm.nusvc.html#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a></dt>
<dd>
<p>Support Vector Machine for classification implemented with libsvm with a parameter to control the number of support vectors.</p> </dd> <dt><a class="reference internal" href="sklearn.svm.svr.html#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>SVR</code></a></dt>
<dd>
<p>Epsilon Support Vector Machine for regression implemented with libsvm.</p> </dd> </dl> </div> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="r495acb08bb55-1" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span> <p><a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf">LIBSVM: A Library for Support Vector Machines</a></p> </div> <div class="citation" id="r495acb08bb55-2" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span> <p><a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.1639">Platt, John (1999). “Probabilistic outputs for support vector machines and comparison to regularizedlikelihood methods.”</a></p> </div> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.svm import NuSVR
&gt;&gt;&gt; from sklearn.pipeline import make_pipeline
&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; n_samples, n_features = 10, 5
&gt;&gt;&gt; np.random.seed(0)
&gt;&gt;&gt; y = np.random.randn(n_samples)
&gt;&gt;&gt; X = np.random.randn(n_samples, n_features)
&gt;&gt;&gt; regr = make_pipeline(StandardScaler(), NuSVR(C=1.0, nu=0.1))
&gt;&gt;&gt; regr.fit(X, y)
Pipeline(steps=[('standardscaler', StandardScaler()),
                ('nusvr', NuSVR(nu=0.1))])
</pre> <h4 class="rubric">Methods</h4> <table class="autosummary longtable docutils align-default">  <tr>
<td><p><a class="reference internal" href="#sklearn.svm.NuSVR.fit" title="sklearn.svm.NuSVR.fit"><code>fit</code></a>(X, y[, sample_weight])</p></td> <td><p>Fit the SVM model according to the given training data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.NuSVR.get_params" title="sklearn.svm.NuSVR.get_params"><code>get_params</code></a>([deep])</p></td> <td><p>Get parameters for this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.NuSVR.predict" title="sklearn.svm.NuSVR.predict"><code>predict</code></a>(X)</p></td> <td><p>Perform regression on samples in X.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.NuSVR.score" title="sklearn.svm.NuSVR.score"><code>score</code></a>(X, y[, sample_weight])</p></td> <td><p>Return the coefficient of determination of the prediction.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.NuSVR.set_params" title="sklearn.svm.NuSVR.set_params"><code>set_params</code></a>(**params)</p></td> <td><p>Set the parameters of this estimator.</p></td> </tr>  </table> <dl class="py property"> <dt class="sig sig-object py" id="sklearn.svm.NuSVR.coef_"> <em class="property">property</em><span class="sig-name descname">coef_</span>
</dt> <dd>
<p>Weights assigned to the features when <code>kernel="linear"</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>ndarray of shape (n_features, n_classes)</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.NuSVR.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/svm/_base.py#L122"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit the SVM model according to the given training data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features) or (n_samples, n_samples)</span>
</dt>
<dd>
<p>Training vectors, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of features. For kernel=”precomputed”, the expected shape of X is (n_samples, n_samples).</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,)</span>
</dt>
<dd>
<p>Target values (class labels in classification, real numbers in regression).</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Fitted estimator.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>If X and y are not C-ordered and contiguous arrays of np.float64 and X is not a scipy.sparse.csr_matrix, X and/or y may be copied.</p> <p>If X is a dense array, then the other methods will not support sparse matrices as input.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.NuSVR.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L194"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="sklearn.svm.NuSVR.n_support_"> <em class="property">property</em><span class="sig-name descname">n_support_</span>
</dt> <dd>
<p>Number of support vectors for each class.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.NuSVR.predict"> <span class="sig-name descname">predict</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/svm/_base.py#L417"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform regression on samples in X.</p> <p>For an one-class model, +1 (inlier) or -1 (outlier) is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>For kernel=”precomputed”, the expected shape of X is (n_samples_test, n_samples_train).</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>y_pred</strong><span class="classifier">ndarray of shape (n_samples,)</span>
</dt>
<dd>
<p>The predicted values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.NuSVR.score"> <span class="sig-name descname">score</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L677"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the coefficient of determination of the prediction.</p> <p>The coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> is defined as <span class="math notranslate nohighlight">\((1 - \frac{u}{v})\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is the residual sum of squares <code>((y_true - y_pred)** 2).sum()</code> and <span class="math notranslate nohighlight">\(v\)</span> is the total sum of squares <code>((y_true - y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape <code>(n_samples, n_samples_fitted)</code>, where <code>n_samples_fitted</code> is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs)</span>
</dt>
<dd>
<p>True values for <code>X</code>.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>score</strong><span class="classifier">float</span>
</dt>
<dd>
<p><span class="math notranslate nohighlight">\(R^2\)</span> of <code>self.predict(X)</code> wrt. <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <span class="math notranslate nohighlight">\(R^2\)</span> score used when calling <code>score</code> on a regressor uses <code>multioutput='uniform_average'</code> from version 0.23 to keep consistent with default value of <a class="reference internal" href="sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>. This influences the <code>score</code> method of all the multioutput regressors (except for <a class="reference internal" href="sklearn.multioutput.multioutputregressor.html#sklearn.multioutput.MultiOutputRegressor" title="sklearn.multioutput.MultiOutputRegressor"><code>MultiOutputRegressor</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.NuSVR.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/f3f51f9b6/sklearn/base.py#L218"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="examples-using-sklearn-svm-nusvr"> <h2>Examples using <code>sklearn.svm.NuSVR</code>
</h2> <div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Demonstrate how model complexity influences both prediction accuracy and computational performa...">
<img alt="Model Complexity Influence" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/applications/plot_model_complexity_influence.html#sphx-glr-auto-examples-applications-plot-model-complexity-influence-py"><span class="std std-ref">Model Complexity Influence</span></a></p>  </div></div>
</section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/modules/generated/sklearn.svm.NuSVR.html" class="_attribution-link">https://scikit-learn.org/1.1/modules/generated/sklearn.svm.NuSVR.html</a>
  </p>
</div>
