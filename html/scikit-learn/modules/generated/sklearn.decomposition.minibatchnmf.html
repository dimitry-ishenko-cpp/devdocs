<section id="minibatchnmf"> <h1>MiniBatchNMF</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.decomposition.</span><span class="sig-name descname">MiniBatchNMF</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_components</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">init</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">batch_size</span><span class="o">=</span><span class="default_value">1024</span></em>, <em class="sig-param"><span class="n">beta_loss</span><span class="o">=</span><span class="default_value">'frobenius'</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">max_no_improvement</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">alpha_W</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">alpha_H</span><span class="o">=</span><span class="default_value">'same'</span></em>, <em class="sig-param"><span class="n">l1_ratio</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">forget_factor</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">fresh_restarts</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">fresh_restarts_max_iter</span><span class="o">=</span><span class="default_value">30</span></em>, <em class="sig-param"><span class="n">transform_max_iter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/decomposition/_nmf.py#L1780"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Mini-Batch Non-Negative Matrix Factorization (NMF).</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.1.</span></p> </div> <p>Find two non-negative matrices, i.e. matrices with all non-negative elements, (<code>W</code>, <code>H</code>) whose product approximates the non-negative matrix <code>X</code>. This factorization can be used for example for dimensionality reduction, source separation or topic extraction.</p> <p>The objective function is:</p> <div class="math notranslate nohighlight"> \[ \begin{align}\begin{aligned}L(W, H) &amp;= 0.5 * ||X - WH||_{loss}^2\\ &amp;+ alpha\_W * l1\_ratio * n\_features * ||vec(W)||_1\\ &amp;+ alpha\_H * l1\_ratio * n\_samples * ||vec(H)||_1\\ &amp;+ 0.5 * alpha\_W * (1 - l1\_ratio) * n\_features * ||W||_{Fro}^2\\ &amp;+ 0.5 * alpha\_H * (1 - l1\_ratio) * n\_samples * ||H||_{Fro}^2,\end{aligned}\end{align} \]</div> <p>where <span class="math notranslate nohighlight">\(||A||_{Fro}^2 = \sum_{i,j} A_{ij}^2\)</span> (Frobenius norm) and <span class="math notranslate nohighlight">\(||vec(A)||_1 = \sum_{i,j} abs(A_{ij})\)</span> (Elementwise L1 norm).</p> <p>The generic norm <span class="math notranslate nohighlight">\(||X - WH||_{loss}^2\)</span> may represent the Frobenius norm or another supported beta-divergence loss. The choice between options is controlled by the <code>beta_loss</code> parameter.</p> <p>The objective function is minimized with an alternating minimization of <code>W</code> and <code>H</code>.</p> <p>Note that the transformed data is named <code>W</code> and the components matrix is named <code>H</code>. In the NMF literature, the naming convention is usually the opposite since the data matrix <code>X</code> is transposed.</p> <p>Read more in the <a class="reference internal" href="../decomposition.html#minibatchnmf"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>n_components</strong><span class="classifier">int or {‘auto’} or None, default=’auto’</span>
</dt>
<dd>
<p>Number of components. If <code>None</code>, all features are kept. If <code>n_components='auto'</code>, the number of components is automatically inferred from W or H shapes.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.4: </span>Added <code>'auto'</code> value.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.6: </span>Default value changed from <code>None</code> to <code>'auto'</code>.</p> </div> </dd> <dt>
<strong>init</strong><span class="classifier">{‘random’, ‘nndsvd’, ‘nndsvda’, ‘nndsvdar’, ‘custom’}, default=None</span>
</dt>
<dd>
<p>Method used to initialize the procedure. Valid options:</p> <ul class="simple"> <li>
<code>None</code>: ‘nndsvda’ if <code>n_components &lt;= min(n_samples, n_features)</code>, otherwise random.</li> <li>
<code>'random'</code>: non-negative random matrices, scaled with: <code>sqrt(X.mean() / n_components)</code>
</li> <li>
<code>'nndsvd'</code>: Nonnegative Double Singular Value Decomposition (NNDSVD) initialization (better for sparseness).</li> <li>
<code>'nndsvda'</code>: NNDSVD with zeros filled with the average of X (better when sparsity is not desired).</li> <li>
<code>'nndsvdar'</code> NNDSVD with zeros filled with small random values (generally faster, less accurate alternative to NNDSVDa for when sparsity is not desired).</li> <li>
<code>'custom'</code>: Use custom matrices <code>W</code> and <code>H</code> which must both be provided.</li> </ul> </dd> <dt>
<strong>batch_size</strong><span class="classifier">int, default=1024</span>
</dt>
<dd>
<p>Number of samples in each mini-batch. Large batch sizes give better long-term convergence at the cost of a slower start.</p> </dd> <dt>
<strong>beta_loss</strong><span class="classifier">float or {‘frobenius’, ‘kullback-leibler’, ‘itakura-saito’}, default=’frobenius’</span>
</dt>
<dd>
<p>Beta divergence to be minimized, measuring the distance between <code>X</code> and the dot product <code>WH</code>. Note that values different from ‘frobenius’ (or 2) and ‘kullback-leibler’ (or 1) lead to significantly slower fits. Note that for <code>beta_loss &lt;= 0</code> (or ‘itakura-saito’), the input matrix <code>X</code> cannot contain zeros.</p> </dd> <dt>
<strong>tol</strong><span class="classifier">float, default=1e-4</span>
</dt>
<dd>
<p>Control early stopping based on the norm of the differences in <code>H</code> between 2 steps. To disable early stopping based on changes in <code>H</code>, set <code>tol</code> to 0.0.</p> </dd> <dt>
<strong>max_no_improvement</strong><span class="classifier">int, default=10</span>
</dt>
<dd>
<p>Control early stopping based on the consecutive number of mini batches that does not yield an improvement on the smoothed cost function. To disable convergence detection based on cost function, set <code>max_no_improvement</code> to None.</p> </dd> <dt>
<strong>max_iter</strong><span class="classifier">int, default=200</span>
</dt>
<dd>
<p>Maximum number of iterations over the complete dataset before timing out.</p> </dd> <dt>
<strong>alpha_W</strong><span class="classifier">float, default=0.0</span>
</dt>
<dd>
<p>Constant that multiplies the regularization terms of <code>W</code>. Set it to zero (default) to have no regularization on <code>W</code>.</p> </dd> <dt>
<strong>alpha_H</strong><span class="classifier">float or “same”, default=”same”</span>
</dt>
<dd>
<p>Constant that multiplies the regularization terms of <code>H</code>. Set it to zero to have no regularization on <code>H</code>. If “same” (default), it takes the same value as <code>alpha_W</code>.</p> </dd> <dt>
<strong>l1_ratio</strong><span class="classifier">float, default=0.0</span>
</dt>
<dd>
<p>The regularization mixing parameter, with 0 &lt;= l1_ratio &lt;= 1. For l1_ratio = 0 the penalty is an elementwise L2 penalty (aka Frobenius Norm). For l1_ratio = 1 it is an elementwise L1 penalty. For 0 &lt; l1_ratio &lt; 1, the penalty is a combination of L1 and L2.</p> </dd> <dt>
<strong>forget_factor</strong><span class="classifier">float, default=0.7</span>
</dt>
<dd>
<p>Amount of rescaling of past information. Its value could be 1 with finite datasets. Choosing values &lt; 1 is recommended with online learning as more recent batches will weight more than past batches.</p> </dd> <dt>
<strong>fresh_restarts</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>Whether to completely solve for W at each step. Doing fresh restarts will likely lead to a better solution for a same number of iterations but it is much slower.</p> </dd> <dt>
<strong>fresh_restarts_max_iter</strong><span class="classifier">int, default=30</span>
</dt>
<dd>
<p>Maximum number of iterations when solving for W at each step. Only used when doing fresh restarts. These iterations may be stopped early based on a small change of W controlled by <code>tol</code>.</p> </dd> <dt>
<strong>transform_max_iter</strong><span class="classifier">int, default=None</span>
</dt>
<dd>
<p>Maximum number of iterations when solving for W at transform time. If None, it defaults to <code>max_iter</code>.</p> </dd> <dt>
<strong>random_state</strong><span class="classifier">int, RandomState instance or None, default=None</span>
</dt>
<dd>
<p>Used for initialisation (when <code>init</code> == ‘nndsvdar’ or ‘random’), and in Coordinate Descent. Pass an int for reproducible results across multiple function calls. See <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-random_state"><span class="xref std std-term">Glossary</span></a>.</p> </dd> <dt>
<strong>verbose</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>Whether to be verbose.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>components_</strong><span class="classifier">ndarray of shape (n_components, n_features)</span>
</dt>
<dd>
<p>Factorization matrix, sometimes called ‘dictionary’.</p> </dd> <dt>
<strong>n_components_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The number of components. It is same as the <code>n_components</code> parameter if it was given. Otherwise, it will be same as the number of features.</p> </dd> <dt>
<strong>reconstruction_err_</strong><span class="classifier">float</span>
</dt>
<dd>
<p>Frobenius norm of the matrix difference, or beta-divergence, between the training data <code>X</code> and the reconstructed data <code>WH</code> from the fitted model.</p> </dd> <dt>
<strong>n_iter_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Actual number of started iterations over the whole dataset.</p> </dd> <dt>
<strong>n_steps_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of mini-batches processed.</p> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.decomposition.nmf.html#sklearn.decomposition.NMF" title="sklearn.decomposition.NMF"><code>NMF</code></a></dt>
<dd>
<p>Non-negative matrix factorization.</p> </dd> <dt><a class="reference internal" href="sklearn.decomposition.minibatchdictionarylearning.html#sklearn.decomposition.MiniBatchDictionaryLearning" title="sklearn.decomposition.MiniBatchDictionaryLearning"><code>MiniBatchDictionaryLearning</code></a></dt>
<dd>
<p>Finds a dictionary that can best be used to represent data using a sparse code.</p> </dd> </dl> </div> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="r71fa4a5f61b6-1" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span> <p><a class="reference external" href="https://doi.org/10.1587/transfun.E92.A.708">“Fast local algorithms for large scale nonnegative matrix and tensor factorizations”</a> Cichocki, Andrzej, and P. H. A. N. Anh-Huy. IEICE transactions on fundamentals of electronics, communications and computer sciences 92.3: 708-721, 2009.</p> </div> <div class="citation" id="r71fa4a5f61b6-2" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span> <p><a class="reference external" href="https://doi.org/10.1162/NECO_a_00168">“Algorithms for nonnegative matrix factorization with the beta-divergence”</a> Fevotte, C., &amp; Idier, J. (2011). Neural Computation, 23(9).</p> </div> <div class="citation" id="r71fa4a5f61b6-3" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span> <p><a class="reference external" href="https://doi.org/10.1109/ASPAA.2011.6082314">“Online algorithms for nonnegative matrix factorization with the Itakura-Saito divergence”</a> Lefevre, A., Bach, F., Fevotte, C. (2011). WASPA.</p> </div> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X = np.array([[1, 1], [2, 1], [3, 1.2], [4, 1], [5, 0.8], [6, 1]])
&gt;&gt;&gt; from sklearn.decomposition import MiniBatchNMF
&gt;&gt;&gt; model = MiniBatchNMF(n_components=2, init='random', random_state=0)
&gt;&gt;&gt; W = model.fit_transform(X)
&gt;&gt;&gt; H = model.components_
</pre> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/decomposition/_nmf.py#L1273"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Learn a NMF model for the data X.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Training vector, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of features.</p> </dd> <dt>
<strong>y</strong><span class="classifier">Ignored</span>
</dt>
<dd>
<p>Not used, present for API consistency by convention.</p> </dd> <dt>
<strong>**params</strong><span class="classifier">kwargs</span>
</dt>
<dd>
<p>Parameters (keyword arguments) and values passed to the fit_transform instance.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Returns the instance itself.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF.fit_transform"> <span class="sig-name descname">fit_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">W</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">H</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/decomposition/_nmf.py#L2196"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Learn a NMF model for the data X and returns the transformed data.</p> <p>This is more efficient than calling fit followed by transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Data matrix to be decomposed.</p> </dd> <dt>
<strong>y</strong><span class="classifier">Ignored</span>
</dt>
<dd>
<p>Not used, present here for API consistency by convention.</p> </dd> <dt>
<strong>W</strong><span class="classifier">array-like of shape (n_samples, n_components), default=None</span>
</dt>
<dd>
<p>If <code>init='custom'</code>, it is used as initial guess for the solution. If <code>None</code>, uses the initialisation method specified in <code>init</code>.</p> </dd> <dt>
<strong>H</strong><span class="classifier">array-like of shape (n_components, n_features), default=None</span>
</dt>
<dd>
<p>If <code>init='custom'</code>, it is used as initial guess for the solution. If <code>None</code>, uses the initialisation method specified in <code>init</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>W</strong><span class="classifier">ndarray of shape (n_samples, n_components)</span>
</dt>
<dd>
<p>Transformed data.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF.get_feature_names_out"> <span class="sig-name descname">get_feature_names_out</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_features</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L995"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get output feature names for transformation.</p> <p>The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: <code>["class_name0", "class_name1", "class_name2"]</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>input_features</strong><span class="classifier">array-like of str or None, default=None</span>
</dt>
<dd>
<p>Only used to validate feature names with the names seen in <code>fit</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>feature_names_out</strong><span class="classifier">ndarray of str objects</span>
</dt>
<dd>
<p>Transformed feature names.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF.get_metadata_routing"> <span class="sig-name descname">get_metadata_routing</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1497"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get metadata routing of this object.</p> <p>Please check <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>routing</strong><span class="classifier">MetadataRequest</span>
</dt>
<dd>
<p>A <a class="reference internal" href="sklearn.utils.metadata_routing.metadatarequest.html#sklearn.utils.metadata_routing.MetadataRequest" title="sklearn.utils.metadata_routing.MetadataRequest"><code>MetadataRequest</code></a> encapsulating routing information.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L231"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF.inverse_transform"> <span class="sig-name descname">inverse_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">Xt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/decomposition/_nmf.py#L1299"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform data back to its original space.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.18.</span></p> </div> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>X</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_components)</span>
</dt>
<dd>
<p>Transformed data matrix.</p> </dd> <dt>
<strong>Xt</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_components)</span>
</dt>
<dd>
<p>Transformed data matrix.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.5: </span><code>Xt</code> was deprecated in 1.5 and will be removed in 1.7. Use <code>X</code> instead.</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">ndarray of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Returns a data matrix of the original shape.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF.partial_fit"> <span class="sig-name descname">partial_fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">W</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">H</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/decomposition/_nmf.py#L2364"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Update the model using the data in <code>X</code> as a mini-batch.</p> <p>This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.</p> <p>This is especially useful when the whole dataset is too big to fit in memory at once (see <a class="reference internal" href="https://scikit-learn.org/1.6/computing/scaling_strategies.html#scaling-strategies"><span class="std std-ref">Strategies to scale computationally: bigger data</span></a>).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Data matrix to be decomposed.</p> </dd> <dt>
<strong>y</strong><span class="classifier">Ignored</span>
</dt>
<dd>
<p>Not used, present here for API consistency by convention.</p> </dd> <dt>
<strong>W</strong><span class="classifier">array-like of shape (n_samples, n_components), default=None</span>
</dt>
<dd>
<p>If <code>init='custom'</code>, it is used as initial guess for the solution. Only used for the first call to <code>partial_fit</code>.</p> </dd> <dt>
<strong>H</strong><span class="classifier">array-like of shape (n_components, n_features), default=None</span>
</dt>
<dd>
<p>If <code>init='custom'</code>, it is used as initial guess for the solution. Only used for the first call to <code>partial_fit</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>self</dt>
<dd>
<p>Returns the instance itself.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF.set_output"> <span class="sig-name descname">set_output</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_set_output.py#L392"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set output container.</p> <p>See <a class="reference internal" href="../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py"><span class="std std-ref">Introducing the set_output API</span></a> for an example on how to use the API.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>transform</strong><span class="classifier">{“default”, “pandas”, “polars”}, default=None</span>
</dt>
<dd>
<p>Configure output of <code>transform</code> and <code>fit_transform</code>.</p> <ul class="simple"> <li>
<code>"default"</code>: Default output format of a transformer</li> <li>
<code>"pandas"</code>: DataFrame output</li> <li>
<code>"polars"</code>: Polars output</li> <li>
<code>None</code>: Transform configuration is unchanged</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.4: </span><code>"polars"</code> option was added.</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L255"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.decomposition.MiniBatchNMF.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/decomposition/_nmf.py#L2338"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform the data X according to the fitted MiniBatchNMF model.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Data matrix to be transformed by the model.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>W</strong><span class="classifier">ndarray of shape (n_samples, n_components)</span>
</dt>
<dd>
<p>Transformed data.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="gallery-examples"> <h2>Gallery examples</h2> <div class="sphx-glr-thumbnails">
<div class="sphx-glr-thumbcontainer" tooltip="We are pleased to announce the release of scikit-learn 1.1! Many bug fixes and improvements were added, as well as some new key features. We detail below a few of the major features of this release. For an exhaustive list of all the changes, please refer to the release notes &lt;release_notes_1_1&gt;.">
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAEYCAMAAABFglBLAAADAFBMVEVHcEy2traioqKTk5Pr6+tpaWmmpqb///+Kioq+vr7+///5/P39/f7+/v/o6Oju9fr7/f73+Pf3+/3l7/fx9/v29vb1+vzs9Pnm5ubg7PXz+Pyxz+XQ4/Dd6/TU5fHK3+7u7u6Svdr4+fvq8vmKuNiWv9yOu9l9sNTN4e/i7vbn8fe91+nC2ur//fygxuCexN+tzeSawt200ubI3u3W5vJxqdCpy+K61ejE3Ox2rNPY6PL/+/mGttimyeH09PT+uHrFxMSEtdWjyOH/lDX/iB/b6fOBs9XhYWJam8f/oExVVVX/mkD/+PPqj5D43N1qpM3+jSreUVL/8ue92e40n0dioMtbW1tSlsbZ2dnbSEn+5c44pTvV1dRUslT+3cDXLi/aPT777e3+ghVBqURgYGBHj8H64+MvoTKrq6vYNDZkZGRtbW330dGBgYF3wXny8vJycnL+7t+21Oj/pVXk5OWNj5Dx8fH2/v+6u7vJycl3d3eYmZraQ0Tj4uFKrUzNzM3zw8PfWVr/2LXql5j/q2Ggn6DnhIX8vofR0dFBQUF8fHn/sm7c3N398/Lxs7P66OeTz5Se05+xsbAomUA5h73roKHuqapqampiuGHf39/ziClkprP/yZj+zaLxu7y94r2HhYTzzM2r2K4pfbNNTU0qnTLZ7ftKo3acnJvkbGxitXJrvG2GyYbL5dp3sL/i9P3q6utVrGuWxePJMzlCpF2KxKX/1K3UJifCSFG1tLL319d5tq2o0Oqv1MqWlpYslVnMPUOhys9nsovvr3bq9e3/w41YpJozMzPtkT6+3NfR6PZMmK+lpaV2u5D5fQ+/jpxBl5G23rfS69Kh0bHnfX3Zt5Xf8d+dsL8+mnSLoLrldHXtmk+0ws7KfojKpYDhiz2qbX/XZ2uIvN/btbzh7+kuiJaHu8Lu3MvNjlOUxrnfo2rjxaPexczNVFq0Mz/gfCKbuc7K1OBpcCnJp7NAjafw0LPgz76ci6K3tMfRuHCRkEvEmWmwpZWVpajL1NdHcEyfV5o1AAABAHRSTlMA//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AJ5UbsQAAIABJREFUeNrs3G1sE/cdB3C2FX5g5/Bxvt7Nlztnzp2fjZ/t2I5NsB1HeUCKlRGCMM0Lwupq1VIlQClUCRLyxCZX2rRNgoZUqToepJRkMBGkCmWI8jAybQiCBqpSlTcIGH1BX6x9vf/ZgUbtypvGka3+vors89l5EX/yv9//yV61amkAs/JZ9YLgu4MgGARBEAyCIAgGQRAEgyAIgkEQBEEQBMEgCIJgEARBMAiCIBgEQRAEQRAMgiAIBkEQBIMgCIJBEARBEATBIMgPCWTvOsyL89LKgvxk9761mO/Ovs5/rjDIOrzevDBr1qwwyI/wPX9hfowgCIJBEARBEARBkB8QiF1GkGoKZQ4jSHVIMOV7WYcgVRFRYQEYkcUaUiXROznSPKxBBKmq6xavRRDs9iIIglR/6LDxW+fYlL6mQbR7R2iAkZFaBNGwHtu3Tup8hmd/Gl2LINuP/n0E1mzb9usaBJGVzIu4PP5aBGnc1PluY+c7L3WuLz38Wy2BcE3/d8aEcwgeVSpgrM0a0jky0gnU7p0AGzZvfr0mQAKR736u+Q1X29nU3ubmmi3q20bOdtKwezvAm2/vO/FWLYD4vV8fOwJLSwW1pXD/xo2ujo6OQk+NFvX1Jw407v5oc+cbpYdv10IL4TIM9I8v5oDCPSvndnLz6OaVayRHnrT21ybIT4+e2HZg+9HVh2qoqAdDeuhqTY/dSI89vdkiaBZP/7V7PwEZG1IL+qlPsv21esmqvXGIkYCkxzUmP8Sij4vlc4+uFB4/LhQKHVkVBJhH6TIIzSBIxSMYmY3p9zRBdQRYLJTPfb6rUCwSkMK1s0GKPB5aBGky0wiyAiEg5YNiV38phY5yt8qeSljoJSCxCIUglQvF0t8AGX86NvY0S9ICxmFWA/qEo7Q6MpQ+jDVkBcbmbYtLH83ZC+WDl79459CnQ0NDIy4qEk2yUKrw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"> <p><a class="reference internal" href="../../auto_examples/release_highlights/plot_release_highlights_1_1_0.html#sphx-glr-auto-examples-release-highlights-plot-release-highlights-1-1-0-py"><span class="std std-ref">Release Highlights for scikit-learn 1.1</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="This is an example of applying NMF and LatentDirichletAllocation on a corpus of documents and extract additive models of the topic structure of the corpus.  The output is a plot of topics, each represented as bar plot using top few words based on weights.">
<img alt="" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/applications/plot_topics_extraction_with_nmf_lda.html#sphx-glr-auto-examples-applications-plot-topics-extraction-with-nmf-lda-py"><span class="std std-ref">Topic extraction with Non-negative Matrix Factorization and Latent Dirichlet Allocation</span></a></p>  </div>
</div></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/generated/sklearn.decomposition.MiniBatchNMF.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/generated/sklearn.decomposition.MiniBatchNMF.html</a>
  </p>
</div>
