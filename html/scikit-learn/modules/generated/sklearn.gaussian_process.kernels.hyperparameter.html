<section id="hyperparameter"> <h1>Hyperparameter</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.gaussian_process.kernels.Hyperparameter"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.gaussian_process.kernels.</span><span class="sig-name descname">Hyperparameter</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">value_type</span></em>, <em class="sig-param"><span class="n">bounds</span></em>, <em class="sig-param"><span class="n">n_elements</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">fixed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/gaussian_process/kernels.py#L52"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A kernel hyperparameter’s specification in form of a namedtuple.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.18.</span></p> </div> <dl class="field-list simple"> <dt class="field-odd">Attributes<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>The name of the hyperparameter. Note that a kernel using a hyperparameter with name “x” must have the attributes self.x and self.x_bounds</p> </dd> <dt>
<strong>value_type</strong><span class="classifier">str</span>
</dt>
<dd>
<p>The type of the hyperparameter. Currently, only “numeric” hyperparameters are supported.</p> </dd> <dt>
<strong>bounds</strong><span class="classifier">pair of floats &gt;= 0 or “fixed”</span>
</dt>
<dd>
<p>The lower and upper bound on the parameter. If n_elements&gt;1, a pair of 1d array with n_elements each may be given alternatively. If the string “fixed” is passed as bounds, the hyperparameter’s value cannot be changed.</p> </dd> <dt>
<strong>n_elements</strong><span class="classifier">int, default=1</span>
</dt>
<dd>
<p>The number of elements of the hyperparameter value. Defaults to 1, which corresponds to a scalar hyperparameter. n_elements &gt; 1 corresponds to a hyperparameter which is vector-valued, such as, e.g., anisotropic length-scales.</p> </dd> <dt>
<strong>fixed</strong><span class="classifier">bool, default=None</span>
</dt>
<dd>
<p>Whether the value of this hyperparameter is fixed, i.e., cannot be changed during hyperparameter tuning. If None is passed, the “fixed” is derived based on the given bounds.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.gaussian_process.kernels import ConstantKernel
&gt;&gt;&gt; from sklearn.datasets import make_friedman2
&gt;&gt;&gt; from sklearn.gaussian_process import GaussianProcessRegressor
&gt;&gt;&gt; from sklearn.gaussian_process.kernels import Hyperparameter
&gt;&gt;&gt; X, y = make_friedman2(n_samples=50, noise=0, random_state=0)
&gt;&gt;&gt; kernel = ConstantKernel(constant_value=1.0,
...    constant_value_bounds=(0.0, 10.0))
</pre> <p>We can access each hyperparameter:</p> <pre data-language="python">&gt;&gt;&gt; for hyperparameter in kernel.hyperparameters:
...    print(hyperparameter)
Hyperparameter(name='constant_value', value_type='numeric',
bounds=array([[ 0., 10.]]), n_elements=1, fixed=False)
</pre> <pre data-language="python">&gt;&gt;&gt; params = kernel.get_params()
&gt;&gt;&gt; for key in sorted(params): print(f"{key} : {params[key]}")
constant_value : 1.0
constant_value_bounds : (0.0, 10.0)
</pre> <dl class="py attribute"> <dt class="sig sig-object py" id="sklearn.gaussian_process.kernels.Hyperparameter.bounds"> <span class="sig-name descname">bounds</span>
</dt> <dd>
<p>Alias for field number 2</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.gaussian_process.kernels.Hyperparameter.count"> <span class="sig-name descname">count</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="o">/</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Return number of occurrences of value.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="sklearn.gaussian_process.kernels.Hyperparameter.fixed"> <span class="sig-name descname">fixed</span>
</dt> <dd>
<p>Alias for field number 4</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.gaussian_process.kernels.Hyperparameter.index"> <span class="sig-name descname">index</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">stop</span><span class="o">=</span><span class="default_value">sys.maxsize</span></em>, <em class="sig-param"><span class="o">/</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Return first index of value.</p> <p>Raises ValueError if the value is not present.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="sklearn.gaussian_process.kernels.Hyperparameter.n_elements"> <span class="sig-name descname">n_elements</span>
</dt> <dd>
<p>Alias for field number 3</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="sklearn.gaussian_process.kernels.Hyperparameter.name"> <span class="sig-name descname">name</span>
</dt> <dd>
<p>Alias for field number 0</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="sklearn.gaussian_process.kernels.Hyperparameter.value_type"> <span class="sig-name descname">value_type</span>
</dt> <dd>
<p>Alias for field number 1</p> </dd>
</dl> </dd>
</dl> <section id="gallery-examples"> <h2>Gallery examples</h2> <div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example illustrates the use of Gaussian processes for regression and classification tasks on data that are not in fixed-length feature vector form. This is achieved through the use of kernel functions that operates directly on discrete structures such as variable-length sequences, trees, and graphs.">
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAEYCAMAAABFglBLAAABblBMVEVHcExEAFRHK3qG1ElAvXJRxGh+0k7////+5ySa2DwemokgkYxVxmZtzlgqsH44uXY3WYzm4eP/5yOZ2Dyh2jnj3+X35iY3WIyo10UraEbw5Cn/6SFJwmve3uQhlIz7+/v+/v47wnZNczOA2E6J20g4tHgal401Xoz/7yNoy1v/6COIfSBvz1Yor383vnjn6Ob29vaDg4NTt2l5eXqLi4txcXFHKHhEMHtFAFIjnoab2Tvz8/Pl5OXs7OxpaWmUlJQ9YYdDcThYdixngGI2bUFEvnBWx2ad3jyT0EEwDjcusntRw2hgyGIrqn8+XWVEI3xv01kijYwem4lRyWkeVFLAwMA9u3Mhk4hEA1dWxmV60VCb2DyH1EiB0ky2trbQ0NCtra3w8fDIyMhQUE6dnZ2mpqZXV1dfX19JwW2S1EEySXA/QoNCC1gih4hBvXHX19dDRUQzNjgsLCzn4i2Lfx5Kx2wfVlF5zFk/QYRHcEycsTMgAAAAenRSTlMA////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AHZwKYsAAAv9SURBVHja7N0Jc9RGGgbgYBKaIyQMsQ0YC4mAzRnUTUsQoosQIIQrgY1ICEH3YXaTnbGB7N/f7jFxMLV82pQpBDPvW4aaUWtGVfO41a0afe4PPkAQBEEQBEEQBEEQBEEQBEEQ5E2HIe9UAAIQBCAAQQACEAQgAEEAAhAEIAhAAIIABCAIQACCAAQgfca0A/Nv7M7zjYe5afKNJ57HrNe95OX3tyxmeS/tuenJ6140TSBG6IbZ39k/3vgoE6+ONranae685iXu8KXPP61Y3r70YQet9z9f5GRTCuJI9dvIjCgKmOHUNU98FhsscTLLyOoo1y0D9TTR+w6daGDEZp05w8TxWZJXDkuizFRb6iLN1pxY7ZbZaseYre9nMNupmqGVqTdI66pglliNhmWtGtSLUw1Smmlm6QMM6yrOsj9bxLSCFCO3NoMmqcOgqau1PCyYGydh4WbxWiKdoKxjo3YL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"> <p><a class="reference internal" href="../../auto_examples/gaussian_process/plot_gpr_on_structured_data.html#sphx-glr-auto-examples-gaussian-process-plot-gpr-on-structured-data-py"><span class="std std-ref">Gaussian processes on discrete data structures</span></a></p>  </div></div></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/generated/sklearn.gaussian_process.kernels.Hyperparameter.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/generated/sklearn.gaussian_process.kernels.Hyperparameter.html</a>
  </p>
</div>
