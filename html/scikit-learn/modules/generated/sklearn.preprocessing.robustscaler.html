<section id="robustscaler"> <h1>RobustScaler</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.preprocessing.</span><span class="sig-name descname">RobustScaler</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">with_centering</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">with_scaling</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">quantile_range</span><span class="o">=</span><span class="default_value">(25.0, 75.0)</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">unit_variance</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/preprocessing/_data.py#L1472"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Scale features using statistics that are robust to outliers.</p> <p>This Scaler removes the median and scales the data according to the quantile range (defaults to IQR: Interquartile Range). The IQR is the range between the 1st quartile (25th quantile) and the 3rd quartile (75th quantile).</p> <p>Centering and scaling happen independently on each feature by computing the relevant statistics on the samples in the training set. Median and interquartile range are then stored to be used on later data using the <a class="reference internal" href="#sklearn.preprocessing.RobustScaler.transform" title="sklearn.preprocessing.RobustScaler.transform"><code>transform</code></a> method.</p> <p>Standardization of a dataset is a common preprocessing for many machine learning estimators. Typically this is done by removing the mean and scaling to unit variance. However, outliers can often influence the sample mean / variance in a negative way. In such cases, using the median and the interquartile range often give better results. For an example visualization and comparison to other scalers, refer to <a class="reference internal" href="../../auto_examples/preprocessing/plot_all_scaling.html#plot-all-scaling-robust-scaler-section"><span class="std std-ref">Compare RobustScaler with other scalers</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.17.</span></p> </div> <p>Read more in the <a class="reference internal" href="../preprocessing.html#preprocessing-scaler"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>with_centering</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If <code>True</code>, center the data before scaling. This will cause <a class="reference internal" href="#sklearn.preprocessing.RobustScaler.transform" title="sklearn.preprocessing.RobustScaler.transform"><code>transform</code></a> to raise an exception when attempted on sparse matrices, because centering them entails building a dense matrix which in common use cases is likely to be too large to fit in memory.</p> </dd> <dt>
<strong>with_scaling</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If <code>True</code>, scale the data to interquartile range.</p> </dd> <dt>
<strong>quantile_range</strong><span class="classifier">tuple (q_min, q_max), 0.0 &lt; q_min &lt; q_max &lt; 100.0, default=(25.0, 75.0)</span>
</dt>
<dd>
<p>Quantile range used to calculate <code>scale_</code>. By default this is equal to the IQR, i.e., <code>q_min</code> is the first quantile and <code>q_max</code> is the third quantile.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.18.</span></p> </div> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If <code>False</code>, try to avoid a copy and do inplace scaling instead. This is not guaranteed to always work inplace; e.g. if the data is not a NumPy array or scipy.sparse CSR matrix, a copy may still be returned.</p> </dd> <dt>
<strong>unit_variance</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>If <code>True</code>, scale data so that normally distributed features have a variance of 1. In general, if the difference between the x-values of <code>q_max</code> and <code>q_min</code> for a standard normal distribution is greater than 1, the dataset will be scaled down. If less than 1, the dataset will be scaled up.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.24.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>center_</strong><span class="classifier">array of floats</span>
</dt>
<dd>
<p>The median value for each feature in the training set.</p> </dd> <dt>
<strong>scale_</strong><span class="classifier">array of floats</span>
</dt>
<dd>
<p>The (scaled) interquartile range for each feature in the training set.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.17: </span><em>scale_</em> attribute.</p> </div> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.24.</span></p> </div> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.0.</span></p> </div> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.preprocessing.robust_scale.html#sklearn.preprocessing.robust_scale" title="sklearn.preprocessing.robust_scale"><code>robust_scale</code></a></dt>
<dd>
<p>Equivalent function without the estimator API.</p> </dd> <dt><a class="reference internal" href="sklearn.decomposition.pca.html#sklearn.decomposition.PCA" title="sklearn.decomposition.PCA"><code>sklearn.decomposition.PCA</code></a></dt>
<dd>
<p>Further removes the linear correlation across features with ‘whiten=True’.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p><a class="reference external" href="https://en.wikipedia.org/wiki/Median">https://en.wikipedia.org/wiki/Median</a> <a class="reference external" href="https://en.wikipedia.org/wiki/Interquartile_range">https://en.wikipedia.org/wiki/Interquartile_range</a></p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.preprocessing import RobustScaler
&gt;&gt;&gt; X = [[ 1., -2.,  2.],
...      [ -2.,  1.,  3.],
...      [ 4.,  1., -2.]]
&gt;&gt;&gt; transformer = RobustScaler().fit(X)
&gt;&gt;&gt; transformer
RobustScaler()
&gt;&gt;&gt; transformer.transform(X)
array([[ 0. , -2. ,  0. ],
       [-1. ,  0. ,  0.4],
       [ 1. ,  0. , -1.6]])
</pre> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/preprocessing/_data.py#L1604"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the median and quantiles to be used for scaling.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>The data used to compute the median and quantiles used for later scaling along the features axis.</p> </dd> <dt>
<strong>y</strong><span class="classifier">Ignored</span>
</dt>
<dd>
<p>Not used, present here for API consistency by convention.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Fitted scaler.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.fit_transform"> <span class="sig-name descname">fit_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">fit_params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L863"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit to data, then transform it.</p> <p>Fits transformer to <code>X</code> and <code>y</code> with optional parameters <code>fit_params</code> and returns a transformed version of <code>X</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Input samples.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs), default=None</span>
</dt>
<dd>
<p>Target values (None for unsupervised transformations).</p> </dd> <dt>
<strong>**fit_params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Additional fit parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X_new</strong><span class="classifier">ndarray array of shape (n_samples, n_features_new)</span>
</dt>
<dd>
<p>Transformed array.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.get_feature_names_out"> <span class="sig-name descname">get_feature_names_out</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_features</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L943"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get output feature names for transformation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>input_features</strong><span class="classifier">array-like of str or None, default=None</span>
</dt>
<dd>
<p>Input features.</p> <ul class="simple"> <li>If <code>input_features</code> is <code>None</code>, then <code>feature_names_in_</code> is used as feature names in. If <code>feature_names_in_</code> is not defined, then the following input feature names are generated: <code>["x0", "x1", ..., "x(n_features_in_ - 1)"]</code>.</li> <li>If <code>input_features</code> is an array-like, then <code>input_features</code> must match <code>feature_names_in_</code> if <code>feature_names_in_</code> is defined.</li> </ul> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>feature_names_out</strong><span class="classifier">ndarray of str objects</span>
</dt>
<dd>
<p>Same as input features.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.get_metadata_routing"> <span class="sig-name descname">get_metadata_routing</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1497"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get metadata routing of this object.</p> <p>Please check <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>routing</strong><span class="classifier">MetadataRequest</span>
</dt>
<dd>
<p>A <a class="reference internal" href="sklearn.utils.metadata_routing.metadatarequest.html#sklearn.utils.metadata_routing.MetadataRequest" title="sklearn.utils.metadata_routing.MetadataRequest"><code>MetadataRequest</code></a> encapsulating routing information.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L231"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.inverse_transform"> <span class="sig-name descname">inverse_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/preprocessing/_data.py#L1707"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Scale back the data to the original representation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>The rescaled data to be transformed back.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X_tr</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Transformed array.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.set_output"> <span class="sig-name descname">set_output</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_set_output.py#L392"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set output container.</p> <p>See <a class="reference internal" href="../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py"><span class="std std-ref">Introducing the set_output API</span></a> for an example on how to use the API.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>transform</strong><span class="classifier">{“default”, “pandas”, “polars”}, default=None</span>
</dt>
<dd>
<p>Configure output of <code>transform</code> and <code>fit_transform</code>.</p> <ul class="simple"> <li>
<code>"default"</code>: Default output format of a transformer</li> <li>
<code>"pandas"</code>: DataFrame output</li> <li>
<code>"polars"</code>: Polars output</li> <li>
<code>None</code>: Transform configuration is unchanged</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.4: </span><code>"polars"</code> option was added.</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L255"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.preprocessing.RobustScaler.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/preprocessing/_data.py#L1672"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Center and scale the data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>The data used to scale along the specified axis.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X_tr</strong><span class="classifier">{ndarray, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Transformed array.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="gallery-examples"> <h2>Gallery examples</h2> <div class="sphx-glr-thumbnails">
<div class="sphx-glr-thumbcontainer" tooltip="This example compares two outlier detection algorithms, namely local_outlier_factor (LOF) and isolation_forest (IForest), on real-world datasets available in sklearn.datasets. The goal is to show that different algorithms perform well on different datasets and contrast their training speed and sensitivity to hyperparameters.">
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAEYCAMAAABFglBLAAABRFBMVEVHcEzr6+v9/f0feLb8/PzPz8/6+vr///8fd7TQ0ND+/v4febjl5OSNjY3h4ODW1tYcdrTb29u+vr7l5eX19fXx8fGmpqaioqK2traTk5PS0tIfebcXXIwddLAJJThZWlo8h7p0mbFhYWEbaqFSVlk0QUkge7oVaKESV4f29PMHIDAbb6hcXFwadbTU09MlerTEw8O1tLIKM1DIyMiYl5ceNEPMzMxnZ2cVX5Oxr69HS057fHxwcXFSUlKqqqq8u7p1dnZERETBwcEPQ2hrbGz49/eBgYGgn57q6uoxfrTz8/OcnJwIPGBmk7LR0dGQkJDv7++9vb06Ozvj4+M+g7MNOFWKioqFhYVRWV4QVILu7u7e3t4JSnfp6enZ2dlXjbNNibIXYpYxMjMPFRsoKCg1dJ5vjqNnfYxlhpwkUG6BfHlHcExzcAouAAAAbHRSTlMA/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBfTR0VAAATdUlEQVR42uzd/XeaaBYH8GqVO7GCVZCXbDt0WNuZzFoPHqgsr4KDmJVpMNjVrq62J0l3Z///f2BBG5PtabItqTGnud8fjGAeb8tH7gOnFB88uBzA3H4eXBPcOgiCQRAEwSAIgmAQBEEwCIIgGARBEARBEAyCIAgGQRAEgyAIgkEQBNkpSN8RBGcB0FHWy+PD9U+eJvSDi1+jZsmq8effYi7wJQC59aUl623iM2vz7cWlpdyAvqcghyckZ8Y1qC7Xy+Zg/bMzy51c2kJ+O1mV+/xb2EGK6QtfWpJRPgdSUkaXlgan0X0F8crJX9/r8zrUfI0rn8XWkhxYXbUyiiN/0memC1AGyzNPGwkVkH2Nh3mgaoN8Orjoa3pJPW3WkueuG/gV6AuaSYOqwDgAytSmddB9q5j+rhJEkg5UIFgtkinpmt+DlqWxeSLUrBS0QI4pc6CFhZWOoXl9kKeR1qv5ZB/KpiYQyVuln4vvHmQOMDujJ2Y/1isy0TSrdc9WFnaPOTWVxpRJXnekvk0u80ZtHuvduFM5DeW4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"> <p><a class="reference internal" href="../../auto_examples/miscellaneous/plot_outlier_detection_bench.html#sphx-glr-auto-examples-miscellaneous-plot-outlier-detection-bench-py"><span class="std std-ref">Evaluation of outlier detection estimators</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="Feature 0 (median income in a block) and feature 5 (average house occupancy) of the california_housing_dataset have very different scales and contain some very large outliers. These two characteristics lead to difficulties to visualize the data and, more importantly, they can degrade the predictive performance of many machine learning algorithms. Unscaled data can also slow down or even prevent the convergence of many gradient-based estimators.">
<img alt="" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/preprocessing/plot_all_scaling.html#sphx-glr-auto-examples-preprocessing-plot-all-scaling-py"><span class="std std-ref">Compare the effect of different scalers on data with outliers</span></a></p>  </div>
</div></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/generated/sklearn.preprocessing.RobustScaler.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/generated/sklearn.preprocessing.RobustScaler.html</a>
  </p>
</div>
