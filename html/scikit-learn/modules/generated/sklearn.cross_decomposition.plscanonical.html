<section id="plscanonical"> <h1>PLSCanonical</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.cross_decomposition.</span><span class="sig-name descname">PLSCanonical</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_components</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">algorithm</span><span class="o">=</span><span class="default_value">'nipals'</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/cross_decomposition/_pls.py#L726"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Partial Least Squares transformer and regressor.</p> <p>For a comparison between other cross decomposition algorithms, see <a class="reference internal" href="../../auto_examples/cross_decomposition/plot_compare_cross_decomposition.html#sphx-glr-auto-examples-cross-decomposition-plot-compare-cross-decomposition-py"><span class="std std-ref">Compare cross decomposition methods</span></a>.</p> <p>Read more in the <a class="reference internal" href="../cross_decomposition.html#cross-decomposition"><span class="std std-ref">User Guide</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.8.</span></p> </div> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>n_components</strong><span class="classifier">int, default=2</span>
</dt>
<dd>
<p>Number of components to keep. Should be in <code>[1, min(n_samples,
n_features, n_targets)]</code>.</p> </dd> <dt>
<strong>scale</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to scale <code>X</code> and <code>Y</code>.</p> </dd> <dt>
<strong>algorithm</strong><span class="classifier">{‘nipals’, ‘svd’}, default=’nipals’</span>
</dt>
<dd>
<p>The algorithm used to estimate the first singular vectors of the cross-covariance matrix. ‘nipals’ uses the power method while ‘svd’ will compute the whole SVD.</p> </dd> <dt>
<strong>max_iter</strong><span class="classifier">int, default=500</span>
</dt>
<dd>
<p>The maximum number of iterations of the power method when <code>algorithm='nipals'</code>. Ignored otherwise.</p> </dd> <dt>
<strong>tol</strong><span class="classifier">float, default=1e-06</span>
</dt>
<dd>
<p>The tolerance used as convergence criteria in the power method: the algorithm stops whenever the squared norm of <code>u_i - u_{i-1}</code> is less than <code>tol</code>, where <code>u</code> corresponds to the left singular vector.</p> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to copy <code>X</code> and <code>Y</code> in fit before applying centering, and potentially scaling. If False, these operations will be done inplace, modifying both arrays.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<strong>x_weights_</strong><span class="classifier">ndarray of shape (n_features, n_components)</span>
</dt>
<dd>
<p>The left singular vectors of the cross-covariance matrices of each iteration.</p> </dd> <dt>
<strong>y_weights_</strong><span class="classifier">ndarray of shape (n_targets, n_components)</span>
</dt>
<dd>
<p>The right singular vectors of the cross-covariance matrices of each iteration.</p> </dd> <dt>
<strong>x_loadings_</strong><span class="classifier">ndarray of shape (n_features, n_components)</span>
</dt>
<dd>
<p>The loadings of <code>X</code>.</p> </dd> <dt>
<strong>y_loadings_</strong><span class="classifier">ndarray of shape (n_targets, n_components)</span>
</dt>
<dd>
<p>The loadings of <code>Y</code>.</p> </dd> <dt>
<strong>x_rotations_</strong><span class="classifier">ndarray of shape (n_features, n_components)</span>
</dt>
<dd>
<p>The projection matrix used to transform <code>X</code>.</p> </dd> <dt>
<strong>y_rotations_</strong><span class="classifier">ndarray of shape (n_targets, n_components)</span>
</dt>
<dd>
<p>The projection matrix used to transform <code>Y</code>.</p> </dd> <dt>
<strong>coef_</strong><span class="classifier">ndarray of shape (n_targets, n_features)</span>
</dt>
<dd>
<p>The coefficients of the linear model such that <code>Y</code> is approximated as <code>Y = X @ coef_.T + intercept_</code>.</p> </dd> <dt>
<strong>intercept_</strong><span class="classifier">ndarray of shape (n_targets,)</span>
</dt>
<dd>
<p>The intercepts of the linear model such that <code>Y</code> is approximated as <code>Y = X @ coef_.T + intercept_</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.1.</span></p> </div> </dd> <dt>
<strong>n_iter_</strong><span class="classifier">list of shape (n_components,)</span>
</dt>
<dd>
<p>Number of iterations of the power method, for each component. Empty if <code>algorithm='svd'</code>.</p> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.0.</span></p> </div> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.cross_decomposition.cca.html#sklearn.cross_decomposition.CCA" title="sklearn.cross_decomposition.CCA"><code>CCA</code></a></dt>
<dd>
<p>Canonical Correlation Analysis.</p> </dd> <dt><a class="reference internal" href="sklearn.cross_decomposition.plssvd.html#sklearn.cross_decomposition.PLSSVD" title="sklearn.cross_decomposition.PLSSVD"><code>PLSSVD</code></a></dt>
<dd>
<p>Partial Least Square SVD.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.cross_decomposition import PLSCanonical
&gt;&gt;&gt; X = [[0., 0., 1.], [1.,0.,0.], [2.,2.,2.], [2.,5.,4.]]
&gt;&gt;&gt; y = [[0.1, -0.2], [0.9, 1.1], [6.2, 5.9], [11.9, 12.3]]
&gt;&gt;&gt; plsca = PLSCanonical(n_components=2)
&gt;&gt;&gt; plsca.fit(X, y)
PLSCanonical()
&gt;&gt;&gt; X_c, y_c = plsca.transform(X, y)
</pre> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/cross_decomposition/_pls.py#L236"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit model to data.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Training vectors, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of predictors.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_targets)</span>
</dt>
<dd>
<p>Target vectors, where <code>n_samples</code> is the number of samples and <code>n_targets</code> is the number of response variables.</p> </dd> <dt>
<strong>Y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_targets)</span>
</dt>
<dd>
<p>Target vectors, where <code>n_samples</code> is the number of samples and <code>n_targets</code> is the number of response variables.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.5: </span><code>Y</code> is deprecated in 1.5 and will be removed in 1.7. Use <code>y</code> instead.</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Fitted model.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.fit_transform"> <span class="sig-name descname">fit_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/cross_decomposition/_pls.py#L537"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Learn and apply the dimension reduction on the train data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Training vectors, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of predictors.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples, n_targets), default=None</span>
</dt>
<dd>
<p>Target vectors, where <code>n_samples</code> is the number of samples and <code>n_targets</code> is the number of response variables.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">ndarray of shape (n_samples, n_components)</span>
</dt>
<dd>
<p>Return <code>x_scores</code> if <code>Y</code> is not given, <code>(x_scores, y_scores)</code> otherwise.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.get_feature_names_out"> <span class="sig-name descname">get_feature_names_out</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_features</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L995"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get output feature names for transformation.</p> <p>The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: <code>["class_name0", "class_name1", "class_name2"]</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>input_features</strong><span class="classifier">array-like of str or None, default=None</span>
</dt>
<dd>
<p>Only used to validate feature names with the names seen in <code>fit</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>feature_names_out</strong><span class="classifier">ndarray of str objects</span>
</dt>
<dd>
<p>Transformed feature names.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.get_metadata_routing"> <span class="sig-name descname">get_metadata_routing</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1497"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get metadata routing of this object.</p> <p>Please check <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>routing</strong><span class="classifier">MetadataRequest</span>
</dt>
<dd>
<p>A <a class="reference internal" href="sklearn.utils.metadata_routing.metadatarequest.html#sklearn.utils.metadata_routing.MetadataRequest" title="sklearn.utils.metadata_routing.MetadataRequest"><code>MetadataRequest</code></a> encapsulating routing information.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L231"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.inverse_transform"> <span class="sig-name descname">inverse_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/cross_decomposition/_pls.py#L455"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform data back to its original space.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_components)</span>
</dt>
<dd>
<p>New data, where <code>n_samples</code> is the number of samples and <code>n_components</code> is the number of pls components.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_components)</span>
</dt>
<dd>
<p>New target, where <code>n_samples</code> is the number of samples and <code>n_components</code> is the number of pls components.</p> </dd> <dt>
<strong>Y</strong><span class="classifier">array-like of shape (n_samples, n_components)</span>
</dt>
<dd>
<p>New target, where <code>n_samples</code> is the number of samples and <code>n_components</code> is the number of pls components.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.5: </span><code>Y</code> is deprecated in 1.5 and will be removed in 1.7. Use <code>y</code> instead.</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X_reconstructed</strong><span class="classifier">ndarray of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Return the reconstructed <code>X</code> data.</p> </dd> <dt>
<strong>y_reconstructed</strong><span class="classifier">ndarray of shape (n_samples, n_targets)</span>
</dt>
<dd>
<p>Return the reconstructed <code>X</code> target. Only returned when <code>y</code> is given.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This transformation will only be exact if <code>n_components=n_features</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.predict"> <span class="sig-name descname">predict</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/cross_decomposition/_pls.py#L508"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict targets of given samples.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Samples.</p> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to copy <code>X</code> and <code>Y</code>, or perform in-place normalization.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>y_pred</strong><span class="classifier">ndarray of shape (n_samples,) or (n_samples, n_targets)</span>
</dt>
<dd>
<p>Returns predicted values.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This call requires the estimation of a matrix of shape <code>(n_features, n_targets)</code>, which may be an issue in high dimensional space.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.score"> <span class="sig-name descname">score</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L619"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the coefficient of determination of the prediction.</p> <p>The coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> is defined as <span class="math notranslate nohighlight">\((1 - \frac{u}{v})\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is the residual sum of squares <code>((y_true - y_pred)** 2).sum()</code> and <span class="math notranslate nohighlight">\(v\)</span> is the total sum of squares <code>((y_true - y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape <code>(n_samples, n_samples_fitted)</code>, where <code>n_samples_fitted</code> is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs)</span>
</dt>
<dd>
<p>True values for <code>X</code>.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>score</strong><span class="classifier">float</span>
</dt>
<dd>
<p><span class="math notranslate nohighlight">\(R^2\)</span> of <code>self.predict(X)</code> w.r.t. <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <span class="math notranslate nohighlight">\(R^2\)</span> score used when calling <code>score</code> on a regressor uses <code>multioutput='uniform_average'</code> from version 0.23 to keep consistent with default value of <a class="reference internal" href="sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>. This influences the <code>score</code> method of all the multioutput regressors (except for <a class="reference internal" href="sklearn.multioutput.multioutputregressor.html#sklearn.multioutput.MultiOutputRegressor" title="sklearn.multioutput.MultiOutputRegressor"><code>MultiOutputRegressor</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.set_output"> <span class="sig-name descname">set_output</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_set_output.py#L392"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set output container.</p> <p>See <a class="reference internal" href="../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py"><span class="std std-ref">Introducing the set_output API</span></a> for an example on how to use the API.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>transform</strong><span class="classifier">{“default”, “pandas”, “polars”}, default=None</span>
</dt>
<dd>
<p>Configure output of <code>transform</code> and <code>fit_transform</code>.</p> <ul class="simple"> <li>
<code>"default"</code>: Default output format of a transformer</li> <li>
<code>"pandas"</code>: DataFrame output</li> <li>
<code>"polars"</code>: Polars output</li> <li>
<code>None</code>: Transform configuration is unchanged</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.4: </span><code>"polars"</code> option was added.</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L255"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.set_predict_request"> <span class="sig-name descname">set_predict_request</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">copy</span><span class="p">:</span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)">None</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a></span><span class="o">=</span><span class="default_value">'$UNCHANGED$'</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">→</span> <span class="sig-return-typehint"><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical" title="sklearn.cross_decomposition._pls.PLSCanonical">PLSCanonical</a></span></span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1251"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Request metadata passed to the <code>predict</code> method.</p> <p>Note that this method is only relevant if <code>enable_metadata_routing=True</code> (see <a class="reference internal" href="sklearn.set_config.html#sklearn.set_config" title="sklearn.set_config"><code>sklearn.set_config</code></a>). Please see <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <p>The options for each parameter are:</p> <ul class="simple"> <li>
<code>True</code>: metadata is requested, and passed to <code>predict</code> if provided. The request is ignored if metadata is not provided.</li> <li>
<code>False</code>: metadata is not requested and the meta-estimator will not pass it to <code>predict</code>.</li> <li>
<code>None</code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</li> <li>
<code>str</code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</li> </ul> <p>The default (<code>sklearn.utils.metadata_routing.UNCHANGED</code>) retains the existing request. This allows you to change the request for some parameters and not others.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.3.</span></p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>. Otherwise it has no effect.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>copy</strong><span class="classifier">str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED</span>
</dt>
<dd>
<p>Metadata routing for <code>copy</code> parameter in <code>predict</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>The updated object.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.set_score_request"> <span class="sig-name descname">set_score_request</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="p">:</span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)">None</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a></span><span class="o">=</span><span class="default_value">'$UNCHANGED$'</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">→</span> <span class="sig-return-typehint"><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical" title="sklearn.cross_decomposition._pls.PLSCanonical">PLSCanonical</a></span></span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1251"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Request metadata passed to the <code>score</code> method.</p> <p>Note that this method is only relevant if <code>enable_metadata_routing=True</code> (see <a class="reference internal" href="sklearn.set_config.html#sklearn.set_config" title="sklearn.set_config"><code>sklearn.set_config</code></a>). Please see <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <p>The options for each parameter are:</p> <ul class="simple"> <li>
<code>True</code>: metadata is requested, and passed to <code>score</code> if provided. The request is ignored if metadata is not provided.</li> <li>
<code>False</code>: metadata is not requested and the meta-estimator will not pass it to <code>score</code>.</li> <li>
<code>None</code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</li> <li>
<code>str</code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</li> </ul> <p>The default (<code>sklearn.utils.metadata_routing.UNCHANGED</code>) retains the existing request. This allows you to change the request for some parameters and not others.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.3.</span></p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>. Otherwise it has no effect.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>sample_weight</strong><span class="classifier">str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED</span>
</dt>
<dd>
<p>Metadata routing for <code>sample_weight</code> parameter in <code>score</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>The updated object.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.set_transform_request"> <span class="sig-name descname">set_transform_request</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">copy</span><span class="p">:</span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)">None</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a></span><span class="o">=</span><span class="default_value">'$UNCHANGED$'</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">→</span> <span class="sig-return-typehint"><a class="reference internal" href="#sklearn.cross_decomposition.PLSCanonical" title="sklearn.cross_decomposition._pls.PLSCanonical">PLSCanonical</a></span></span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1251"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Request metadata passed to the <code>transform</code> method.</p> <p>Note that this method is only relevant if <code>enable_metadata_routing=True</code> (see <a class="reference internal" href="sklearn.set_config.html#sklearn.set_config" title="sklearn.set_config"><code>sklearn.set_config</code></a>). Please see <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <p>The options for each parameter are:</p> <ul class="simple"> <li>
<code>True</code>: metadata is requested, and passed to <code>transform</code> if provided. The request is ignored if metadata is not provided.</li> <li>
<code>False</code>: metadata is not requested and the meta-estimator will not pass it to <code>transform</code>.</li> <li>
<code>None</code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</li> <li>
<code>str</code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</li> </ul> <p>The default (<code>sklearn.utils.metadata_routing.UNCHANGED</code>) retains the existing request. This allows you to change the request for some parameters and not others.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.3.</span></p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>. Otherwise it has no effect.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>copy</strong><span class="classifier">str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED</span>
</dt>
<dd>
<p>Metadata routing for <code>copy</code> parameter in <code>transform</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>The updated object.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.cross_decomposition.PLSCanonical.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/cross_decomposition/_pls.py#L408"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the dimension reduction.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Samples to transform.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples, n_targets), default=None</span>
</dt>
<dd>
<p>Target vectors.</p> </dd> <dt>
<strong>Y</strong><span class="classifier">array-like of shape (n_samples, n_targets), default=None</span>
</dt>
<dd>
<p>Target vectors.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.5: </span><code>Y</code> is deprecated in 1.5 and will be removed in 1.7. Use <code>y</code> instead.</p> </div> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to copy <code>X</code> and <code>Y</code>, or perform in-place normalization.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>x_scores, y_scores</strong><span class="classifier">array-like or tuple of array-like</span>
</dt>
<dd>
<p>Return <code>x_scores</code> if <code>Y</code> is not given, <code>(x_scores, y_scores)</code> otherwise.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="gallery-examples"> <h2>Gallery examples</h2> <div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Simple usage of various cross decomposition algorithms:">
<img alt="" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/cross_decomposition/plot_compare_cross_decomposition.html#sphx-glr-auto-examples-cross-decomposition-plot-compare-cross-decomposition-py"><span class="std std-ref">Compare cross decomposition methods</span></a></p>  </div></div></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/generated/sklearn.cross_decomposition.PLSCanonical.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/generated/sklearn.cross_decomposition.PLSCanonical.html</a>
  </p>
</div>
