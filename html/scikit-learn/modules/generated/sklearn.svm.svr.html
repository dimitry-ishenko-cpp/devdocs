<section id="svr"> <h1>SVR</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.svm.SVR"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.svm.</span><span class="sig-name descname">SVR</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">kernel</span><span class="o">=</span><span class="default_value">'rbf'</span></em>, <em class="sig-param"><span class="n">degree</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">gamma</span><span class="o">=</span><span class="default_value">'scale'</span></em>, <em class="sig-param"><span class="n">coef0</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">C</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">shrinking</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">cache_size</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">-1</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/svm/_classes.py#L1154"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Epsilon-Support Vector Regression.</p> <p>The free parameters in the model are C and epsilon.</p> <p>The implementation is based on libsvm. The fit time complexity is more than quadratic with the number of samples which makes it hard to scale to datasets with more than a couple of 10000 samples. For large datasets consider using <a class="reference internal" href="sklearn.svm.linearsvr.html#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a> or <a class="reference internal" href="sklearn.linear_model.sgdregressor.html#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><code>SGDRegressor</code></a> instead, possibly after a <a class="reference internal" href="sklearn.kernel_approximation.nystroem.html#sklearn.kernel_approximation.Nystroem" title="sklearn.kernel_approximation.Nystroem"><code>Nystroem</code></a> transformer or other <a class="reference internal" href="../kernel_approximation.html#kernel-approximation"><span class="std std-ref">Kernel Approximation</span></a>.</p> <p>Read more in the <a class="reference internal" href="../svm.html#svm-regression"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>kernel</strong><span class="classifier">{‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’} or callable, default=’rbf’</span>
</dt>
<dd>
<p>Specifies the kernel type to be used in the algorithm. If none is given, ‘rbf’ will be used. If a callable is given it is used to precompute the kernel matrix. For an intuitive visualization of different kernel types see <a class="reference internal" href="../../auto_examples/svm/plot_svm_regression.html#sphx-glr-auto-examples-svm-plot-svm-regression-py"><span class="std std-ref">Support Vector Regression (SVR) using linear and non-linear kernels</span></a></p> </dd> <dt>
<strong>degree</strong><span class="classifier">int, default=3</span>
</dt>
<dd>
<p>Degree of the polynomial kernel function (‘poly’). Must be non-negative. Ignored by all other kernels.</p> </dd> <dt>
<strong>gamma</strong><span class="classifier">{‘scale’, ‘auto’} or float, default=’scale’</span>
</dt>
<dd>
<p>Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.</p> <ul class="simple"> <li>if <code>gamma='scale'</code> (default) is passed then it uses 1 / (n_features * X.var()) as value of gamma,</li> <li>if ‘auto’, uses 1 / n_features</li> <li>if float, must be non-negative.</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.22: </span>The default value of <code>gamma</code> changed from ‘auto’ to ‘scale’.</p> </div> </dd> <dt>
<strong>coef0</strong><span class="classifier">float, default=0.0</span>
</dt>
<dd>
<p>Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.</p> </dd> <dt>
<strong>tol</strong><span class="classifier">float, default=1e-3</span>
</dt>
<dd>
<p>Tolerance for stopping criterion.</p> </dd> <dt>
<strong>C</strong><span class="classifier">float, default=1.0</span>
</dt>
<dd>
<p>Regularization parameter. The strength of the regularization is inversely proportional to C. Must be strictly positive. The penalty is a squared l2. For an intuitive visualization of the effects of scaling the regularization parameter C, see <a class="reference internal" href="../../auto_examples/svm/plot_svm_scale_c.html#sphx-glr-auto-examples-svm-plot-svm-scale-c-py"><span class="std std-ref">Scaling the regularization parameter for SVCs</span></a>.</p> </dd> <dt>
<strong>epsilon</strong><span class="classifier">float, default=0.1</span>
</dt>
<dd>
<p>Epsilon in the epsilon-SVR model. It specifies the epsilon-tube within which no penalty is associated in the training loss function with points predicted within a distance epsilon from the actual value. Must be non-negative.</p> </dd> <dt>
<strong>shrinking</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Whether to use the shrinking heuristic. See the <a class="reference internal" href="../svm.html#shrinking-svm"><span class="std std-ref">User Guide</span></a>.</p> </dd> <dt>
<strong>cache_size</strong><span class="classifier">float, default=200</span>
</dt>
<dd>
<p>Specify the size of the kernel cache (in MB).</p> </dd> <dt>
<strong>verbose</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.</p> </dd> <dt>
<strong>max_iter</strong><span class="classifier">int, default=-1</span>
</dt>
<dd>
<p>Hard limit on iterations within solver, or -1 for no limit.</p> </dd> </dl> </dd> <dt class="field-even">Attributes<span class="colon">:</span>
</dt> <dd class="field-even">
<dl> <dt>
<a class="reference internal" href="#sklearn.svm.SVR.coef_" title="sklearn.svm.SVR.coef_"><code>coef_</code></a><span class="classifier">ndarray of shape (1, n_features)</span>
</dt>
<dd>
<p>Weights assigned to the features when <code>kernel="linear"</code>.</p> </dd> <dt>
<strong>dual_coef_</strong><span class="classifier">ndarray of shape (1, n_SV)</span>
</dt>
<dd>
<p>Coefficients of the support vector in the decision function.</p> </dd> <dt>
<strong>fit_status_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>0 if correctly fitted, 1 otherwise (will raise warning)</p> </dd> <dt>
<strong>intercept_</strong><span class="classifier">ndarray of shape (1,)</span>
</dt>
<dd>
<p>Constants in decision function.</p> </dd> <dt>
<strong>n_features_in_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of features seen during <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.24.</span></p> </div> </dd> <dt>
<strong>feature_names_in_</strong><span class="classifier">ndarray of shape (<code>n_features_in_</code>,)</span>
</dt>
<dd>
<p>Names of features seen during <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-fit"><span class="xref std std-term">fit</span></a>. Defined only when <code>X</code> has feature names that are all strings.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.0.</span></p> </div> </dd> <dt>
<strong>n_iter_</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Number of iterations run by the optimization routine to fit the model.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.1.</span></p> </div> </dd> <dt>
<a class="reference internal" href="#sklearn.svm.SVR.n_support_" title="sklearn.svm.SVR.n_support_"><code>n_support_</code></a><span class="classifier">ndarray of shape (1,), dtype=int32</span>
</dt>
<dd>
<p>Number of support vectors for each class.</p> </dd> <dt>
<strong>shape_fit_</strong><span class="classifier">tuple of int of shape (n_dimensions_of_X,)</span>
</dt>
<dd>
<p>Array dimensions of training vector <code>X</code>.</p> </dd> <dt>
<strong>support_</strong><span class="classifier">ndarray of shape (n_SV,)</span>
</dt>
<dd>
<p>Indices of support vectors.</p> </dd> <dt>
<strong>support_vectors_</strong><span class="classifier">ndarray of shape (n_SV, n_features)</span>
</dt>
<dd>
<p>Support vectors.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.svm.nusvr.html#sklearn.svm.NuSVR" title="sklearn.svm.NuSVR"><code>NuSVR</code></a></dt>
<dd>
<p>Support Vector Machine for regression implemented using libsvm using a parameter to control the number of support vectors.</p> </dd> <dt><a class="reference internal" href="sklearn.svm.linearsvr.html#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a></dt>
<dd>
<p>Scalable Linear Support Vector Machine for regression implemented using liblinear.</p> </dd> </dl> </div> <h4 class="rubric">References</h4> <div role="list" class="citation-list"> <div class="citation" id="r4ae6a8049c28-1" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span> <p><a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf">LIBSVM: A Library for Support Vector Machines</a></p> </div> <div class="citation" id="r4ae6a8049c28-2" role="doc-biblioentry"> <span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span> <p><a class="reference external" href="https://citeseerx.ist.psu.edu/doc_view/pid/42e5ed832d4310ce4378c44d05570439df28a393">Platt, John (1999). “Probabilistic Outputs for Support Vector Machines and Comparisons to Regularized Likelihood Methods”</a></p> </div> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.svm import SVR
&gt;&gt;&gt; from sklearn.pipeline import make_pipeline
&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; n_samples, n_features = 10, 5
&gt;&gt;&gt; rng = np.random.RandomState(0)
&gt;&gt;&gt; y = rng.randn(n_samples)
&gt;&gt;&gt; X = rng.randn(n_samples, n_features)
&gt;&gt;&gt; regr = make_pipeline(StandardScaler(), SVR(C=1.0, epsilon=0.2))
&gt;&gt;&gt; regr.fit(X, y)
Pipeline(steps=[('standardscaler', StandardScaler()),
                ('svr', SVR(epsilon=0.2))])
</pre> <dl class="py property"> <dt class="sig sig-object py" id="sklearn.svm.SVR.coef_"> <em class="property">property</em><span class="sig-name descname">coef_</span>
</dt> <dd>
<p>Weights assigned to the features when <code>kernel="linear"</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>ndarray of shape (n_features, n_classes)</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/svm/_base.py#L153"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit the SVM model according to the given training data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features) or (n_samples, n_samples)</span>
</dt>
<dd>
<p>Training vectors, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of features. For kernel=”precomputed”, the expected shape of X is (n_samples, n_samples).</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,)</span>
</dt>
<dd>
<p>Target values (class labels in classification, real numbers in regression).</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>Fitted estimator.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>If X and y are not C-ordered and contiguous arrays of np.float64 and X is not a scipy.sparse.csr_matrix, X and/or y may be copied.</p> <p>If X is a dense array, then the other methods will not support sparse matrices as input.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.get_metadata_routing"> <span class="sig-name descname">get_metadata_routing</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1497"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get metadata routing of this object.</p> <p>Please check <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>routing</strong><span class="classifier">MetadataRequest</span>
</dt>
<dd>
<p>A <a class="reference internal" href="sklearn.utils.metadata_routing.metadatarequest.html#sklearn.utils.metadata_routing.MetadataRequest" title="sklearn.utils.metadata_routing.MetadataRequest"><code>MetadataRequest</code></a> encapsulating routing information.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L231"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="sklearn.svm.SVR.n_support_"> <em class="property">property</em><span class="sig-name descname">n_support_</span>
</dt> <dd>
<p>Number of support vectors for each class.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.predict"> <span class="sig-name descname">predict</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/svm/_base.py#L420"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform regression on samples in X.</p> <p>For an one-class model, +1 (inlier) or -1 (outlier) is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse matrix} of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>For kernel=”precomputed”, the expected shape of X is (n_samples_test, n_samples_train).</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>y_pred</strong><span class="classifier">ndarray of shape (n_samples,)</span>
</dt>
<dd>
<p>The predicted values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.score"> <span class="sig-name descname">score</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L619"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the coefficient of determination of the prediction.</p> <p>The coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> is defined as <span class="math notranslate nohighlight">\((1 - \frac{u}{v})\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is the residual sum of squares <code>((y_true - y_pred)** 2).sum()</code> and <span class="math notranslate nohighlight">\(v\)</span> is the total sum of squares <code>((y_true - y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">array-like of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape <code>(n_samples, n_samples_fitted)</code>, where <code>n_samples_fitted</code> is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<strong>y</strong><span class="classifier">array-like of shape (n_samples,) or (n_samples, n_outputs)</span>
</dt>
<dd>
<p>True values for <code>X</code>.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>score</strong><span class="classifier">float</span>
</dt>
<dd>
<p><span class="math notranslate nohighlight">\(R^2\)</span> of <code>self.predict(X)</code> w.r.t. <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <span class="math notranslate nohighlight">\(R^2\)</span> score used when calling <code>score</code> on a regressor uses <code>multioutput='uniform_average'</code> from version 0.23 to keep consistent with default value of <a class="reference internal" href="sklearn.metrics.r2_score.html#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>. This influences the <code>score</code> method of all the multioutput regressors (except for <a class="reference internal" href="sklearn.multioutput.multioutputregressor.html#sklearn.multioutput.MultiOutputRegressor" title="sklearn.multioutput.MultiOutputRegressor"><code>MultiOutputRegressor</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.set_fit_request"> <span class="sig-name descname">set_fit_request</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="p">:</span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)">None</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a></span><span class="o">=</span><span class="default_value">'$UNCHANGED$'</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">→</span> <span class="sig-return-typehint"><a class="reference internal" href="#sklearn.svm.SVR" title="sklearn.svm._classes.SVR">SVR</a></span></span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1251"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Request metadata passed to the <code>fit</code> method.</p> <p>Note that this method is only relevant if <code>enable_metadata_routing=True</code> (see <a class="reference internal" href="sklearn.set_config.html#sklearn.set_config" title="sklearn.set_config"><code>sklearn.set_config</code></a>). Please see <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <p>The options for each parameter are:</p> <ul class="simple"> <li>
<code>True</code>: metadata is requested, and passed to <code>fit</code> if provided. The request is ignored if metadata is not provided.</li> <li>
<code>False</code>: metadata is not requested and the meta-estimator will not pass it to <code>fit</code>.</li> <li>
<code>None</code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</li> <li>
<code>str</code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</li> </ul> <p>The default (<code>sklearn.utils.metadata_routing.UNCHANGED</code>) retains the existing request. This allows you to change the request for some parameters and not others.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.3.</span></p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>. Otherwise it has no effect.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>sample_weight</strong><span class="classifier">str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED</span>
</dt>
<dd>
<p>Metadata routing for <code>sample_weight</code> parameter in <code>fit</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>The updated object.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L255"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.svm.SVR.set_score_request"> <span class="sig-name descname">set_score_request</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="p">:</span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)">None</a><span class="p">|</span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a></span><span class="o">=</span><span class="default_value">'$UNCHANGED$'</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">→</span> <span class="sig-return-typehint"><a class="reference internal" href="#sklearn.svm.SVR" title="sklearn.svm._classes.SVR">SVR</a></span></span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1251"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Request metadata passed to the <code>score</code> method.</p> <p>Note that this method is only relevant if <code>enable_metadata_routing=True</code> (see <a class="reference internal" href="sklearn.set_config.html#sklearn.set_config" title="sklearn.set_config"><code>sklearn.set_config</code></a>). Please see <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <p>The options for each parameter are:</p> <ul class="simple"> <li>
<code>True</code>: metadata is requested, and passed to <code>score</code> if provided. The request is ignored if metadata is not provided.</li> <li>
<code>False</code>: metadata is not requested and the meta-estimator will not pass it to <code>score</code>.</li> <li>
<code>None</code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</li> <li>
<code>str</code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</li> </ul> <p>The default (<code>sklearn.utils.metadata_routing.UNCHANGED</code>) retains the existing request. This allows you to change the request for some parameters and not others.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.3.</span></p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>. Otherwise it has no effect.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>sample_weight</strong><span class="classifier">str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED</span>
</dt>
<dd>
<p>Metadata routing for <code>sample_weight</code> parameter in <code>score</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>The updated object.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="gallery-examples"> <h2>Gallery examples</h2> <div class="sphx-glr-thumbnails">
<div class="sphx-glr-thumbcontainer" tooltip="This is an example showing the prediction latency of various scikit-learn estimators.">
<img alt="" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/applications/plot_prediction_latency.html#sphx-glr-auto-examples-applications-plot-prediction-latency-py"><span class="std std-ref">Prediction Latency</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="Both kernel ridge regression (KRR) and SVR learn a non-linear function by employing the kernel trick, i.e., they learn a linear function in the space induced by the respective kernel which corresponds to a non-linear function in the original space. They differ in the loss functions (ridge versus epsilon-insensitive loss). In contrast to SVR, fitting a KRR can be done in closed-form and is typically faster for medium-sized datasets. On the other hand, the learned model is non-sparse and thus slower than SVR at prediction-time.">
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAEYCAMAAABFglBLAAADAFBMVEVHcEympqa2trb/AADr6+sAAABpaWn///+Kioq+vr6ioqL39/fl5eXs7Ozv7++Tk5Pt7e36+/v+/v/u7u7//f52dnb8/PxkZGT9/v1bW1vS09N7e3vg4eH5+fmysrJVVFTi4+Pf399zc3POzs5wcHBgX19+fn7Ly8vQ0NDn5+eWlpaen55ra2vAwMGAgIBXVlbDxMSvr69ZWFhiYWGRkpKztbVubW3/LzDz9PT19fXx8fG5urpjAACqq6vp6enq6+uLjIycnZ3FxsaDg4PBwsKsra14eHiPkJBHR0c6OjrIycleXV3u8/O8vLxmZmaam5vV1dVZAgGoqKgFBwVOBgb29va4AACOjY7y8vLc3d3rAACHiIdSUVHJ5MlPT09vAAAHDQjDAADq9eoIcAVqamr19vbzAAGYmZnMAADZ2dmHAQEViRQKhApLS0v9FxfZ2NjX19fa2tqlpaWFhobkAAAqAQEpKihHLCz/ICAFdgHW1tbb29umAQATFBI+Pz8lkSV9AQDWAACxAABEDQySAAA/AQA1NTUDZwEkJSU7nz2PlpYdHhz/iYneAABDQkJFFBMuMC/6AAATkBjHzs0NAADHx8f8//+cAACpqalLOTkBRQBoaGhaTEwvmTBEIiK3uLgEVgELfAag0aEGNgRKMzPy+PNTRUUZAAB3u3n/SUpRPT3/7/Dr7u5Jhzj/VlcCTQL/DxBGGxcBGAAAKgACXwH8trXg5ubC38FXrloBIACy2LG3v71ntWj/0ND/v7/94OH/oaH819b/gYGhp6j+9fXS2Nf/+PovZQv+PTz/6+z/qqrj8eORypKkTzmAwYH/X2Da7dr/yMidpKT/5uf/kJD+mZtJp0vR6dKqHRTKIA6PNxVYdifnQDm43bi4PyX6c3TnIRv7aGjYFQVxmWDeLSaEZCaMv4gnWRXtwr5oEwO0aUR0PDFSRwdsTQ98hIJ7gIBLcU6mt57ipaDckYzFamJrjmzNjoeVDxB3ICFhdmStl3G7qKWbdnbTtaXKeXg2SStdHNbrAAAAAXRSTlMAQObYZgAAIABJREFUeNrs3HlQU/kBB3AFsj9IwpFgCBACOYAHJJxJIAgsCeFIgoKcUWFJ2FguN+gKhkONchhwWRFP5FBQWLtAFUFYpVsBxe0IPayL1nWmHUe7s9Odndm67XQ6nf7T94Kd6bQECUI2wd/3jyTkHeS9z3u/Kz/YsOG/A2DMnw1LBJ4dCAIDQSAIDASBIDAQBILAQBAIAgNBIAgEgSAwEASCwEAQCAIDQSAIDASBIBYMghQXO9DjXNFXWz3Zzny8y3I3DNsGQByy6CKSwAl9FOL5zmEAEAXYW042JAiynMRp0oMoBA0eABcZQonI9CsgLHPLtCAQUrBj0UVCXS36yGzmOOszgaMBjdkaDUGWk1QF9pikAcBbCihBgNiGnUu2iAwQEfBkpZ0nE2kcLpPzTiQS7b8ZeMeRBVxuOLaNr7O/hxMg+qc5090qin0FIft2pdCBFy0tiJQj3YMZyEggOQ3sSQFCyS6FhkBXpHH87YA3N1IOQYwmSdvlTASuOjaIEAOKvXBfAVbaOMp2AJYovjWcXdDj1ZIX4K0LQEodZfGgIiRQ7+BpuOYpLX50sN0nqJaqAFoqm91cIZeGE/LF2/yK3V6BEImhHBCsAck8xLcN8AvkFS3EHg0S08qAIEbjqcjXHwAsCUNGBDR9aovY8C6FH60jxskyz4f6eslcwV4prYfk2GoHRJLNodxMzAyw9FImCGjGZyZLha1ngRfKladA2vZl+mpIBhCG1kMqcwGJPmSU27NVWLAVbJbFd6Wez0QLMgiyRKR8wG6VpKEMIkK4noi9ddYHzwNxeo4YH1DamgOAncAjebvOFYT4A0IiqwCroH05YhmztDlIzAmOlrIBU+cERPZImxj9mfDqDrF718ffAIKgv0CYbwNc9fHcCLx4oxcEMRa8OAGvTwAkjQptEPmiFQqPQsbaSfktAhCYz0G895bKokEAHknmkQoUNm0hLulIuo6OrtIVBIJkSJpILpCT0DPO1LuiBRrBLwWxQQgLlXqbENRqmWEaIAmNoWrJYmkMTRuYmG8jj3OCIEZbvXkUWgL63EMTohWKAwA7KgztUxtftLXllcdSMOzQqpopYSniwR5aCr4nOoUi2YutcR4VxKc7ObMkAWRnBnBU5IAYG+CYwqrY5uYciFVE9uguxMFe6YDAp2wMIrnjacW6eJBAo4ijIYgFhMgvjpC4w2avxYSwdZ/Dj+4BQeDQCYyZQIgOMEvHzrwgfJ7CHsZ4UkL3mRfEeSssb5ZM5kYzg9jAc750HxeCQBCYtwvkHASxJJDEiMGuLyDIWoDIfXkcgskeDfV17Rd3QJDVBxGcaM+NpdJNPB6fXFtb20YaBFl1EEJ/CXpqM3pM2717VSW6VaEPBFl1kM+yT2LXep6Jx+NRj25VFgJBVh1ky0XsWlfOmHg8p0faS8r6P4Mgq1+HpGSUHG/s+JmpBxTA7aYxAARZfRBSekcV1wu8bbHkfsg5N9hTh0MnEAQGgkAQCAJBViPn1h+IU4ChT+CIJOy1OpAwjx9j3HiNQQT5HtiTKIKfZG0gYSewceMP1xkIydMPe7Knhm9Hn8gEusJqQEKxUbFGynqrQ7YZQNiZIh4q4pi8S2Yts07c+49j48bd6w1kL+/Vi1QEO0rAt5o7JPUgNm7sv85AtntrvBy9SewDwRqGldUhhnHjKsY6A0mketBqRaS4SIrc6lpZnpHdNPMPbsJ+COwYmrPY8eWJl5gnIQziUTwhiPkSg82T8DMqIvRR5jaOhEEQc4XeUYjNk/A2tvzLWHRx7hU3CGKmkah3G4rQM97+vbEVWFjDtujEFghipggvYn07JcfY8pQj6OK6fhIEMVc+yiipbOyPN7aYUdVeWZL9JaxDTA7htNxlJQfnxumo6mIaX15KrRqccYcgpuZDTUZGVczK6pHX1NiWVVxZCQg9v/2kbclFK578tr5Azh0wTCpVxkEQC7lDvshGPWyPzEAQCwEhXKlHW6cjTAhiKZV6QEes8mISgCDmAWEmlL5uo82fCxgAgpgFxC1vJLaB9RMAYyEg4dk7bYtiP4IQlgLigf1NYN0ghDATSMI7fEMlUMF1WBwkwgDS8eZzBBkCdnwStbv7L5Ga7m6+EIIsnlqxYaJcngTJX3ySw0xGke1Jpf0bHYMT29kjtQWX1YKLLczNPnO0vlCZSgfCRPbaDlO5FFPSnayuyCrF5mWRU/cAFjYY9f/TgOjJDcps6uYVf352RYqiWYVbCNaDLNpfh30rFRysVal0tLicNfMgdigPKgfftTYQw0Q5d48dgBZuZKKcp+D0yr+zExzC/SdZKtW3L54+fTry1YsXL458r114l7pmw4fJZdj4QYjV3SE8QCaALgfgh6zBVFK6zkAx0dfZO9akVtdcWkiNuunSWG/njdEsHA5Z7r4C83gSU2b9DGJ3YskVKwOR87Qiz0i3xIhIFmHFPXXjidaP9g031dQ09Q733ZgYVWUY6pCDB0+8/KZzeAxdMNb5p98ts1HQfyS3rMqE/8lh+J8R9alWBhIoZ7O3M90BE8kBqwey0IZye3L5lrqpqbdvNCurWd+qlcXNhA4Osni6wUGJE4hEbx3VRKf68KkLn/7x/dfvk4aVQI2Ry/8QMQ0lOwsbgt/Gsaz/RebqpTafPPntsd2nbl1+eegQd8Z/47ap+T+Pj8/NTU/PjU/enhoaukcXsKhaVXPS+ze/Obb78K2fG0zIxvd6pcTQ/jbhc4QPjgwKwNsOkpPoLUUv/eELH1z49Cbae9mE/HX67oOBqPLr18urq6PQVJdft71eff/as8eTdzwXxmR+dfn3uw//4j15VwTfaDuVik1BqY8w5bO4bVmDGURWBhLcloXLujFWM3b1yTmw6fb0s/vl1VH3r919PH57an52dgjN7Pz8ncm5uw/uozRRzx8/vLdg8utjp9Q3cDitt5Fm1+kTuZW5DYlv/dCJSakVt+BGO9U1wxM4xfzcg6jq6oG747dnjaw9dGfy4wH0rrk2N4UVVeR/9qnVnaosfebiBVeYT1X353Asy5TwVbiJ3pqmPhVuv/Lr6vJrjybvvXabXz58dK28fODR1CZAwWX1NdUMj6rOGlnXImY8WA2IO2MjVlb1TqAauUVRz8dnycvddGj8edT1gel/YR16dBfDf2e6AIuNtYAgumbD5X0m+2Bd+bOHQyZtTAazkw+qq786inUjJ3o/UOvtSRDkjUBc2m40qTtH95eVlP/hbyv7dn1+eqC88NszBhL18A90CLJykOCul001naqjB3cW/mbKHWxa6cHeflZdV9Z9CCu4dl/lBkOQFYKE9fWizaOMwsqvvwt5w6nq84+iyhv347DqfawvAYKsBIRw87B6+FBsyfGy77w+efMDHpqOOl6Gkqg61YffgyAmg5B+uHqpd1RZV/mPSNEqTSaNfhy1s+ynONzov9k7E6Cm7jyOz5h9/qEcJhFCgIUIDYeA3FchSkAUkEHIBlBiawhxIxIaVw2EuEQgkCJSFokRFJdTKbALqPUAKUp1VbQFry6KoBa1ntU9Wtd2u93uvvdCZ6B1R9h5IS/Hd4ZhOMLA+/D7//6//+/4lyovtRiBzAxIy33p0SOMoqJCFR3DSTBnYSvhqtibewvKeq2MQGag23X8/azMim8kuXRMk6XV/S9EmUNnwZraps5zRiDT1ZUeZWcxj1PSGheBde66Gpw+I2p/yYaOlBZ0G4FMS5TBgrJ/3+LUwA7YRAN/eDU42SUoaYXSDwo16ElWuNpH6wmQd67zB+7mtQ8heXENXalp9QNPzIDK/8Ev05SReBaX1BQH6gOQljZl45OKzG+JpDkxCZrqW64+LuGK5Qdk6Y3ZDzVSyHUc6TrlVP4WR0CIJvbICDBTurXnTIDcrpM+43EKVZCGu3Sc/vJ9O4ergvbzOzXR7eCLNMITuEE4ArKc6WcL//Mt9U5bMn0gGX3KzhGBHHYeUMzkz6ftiNmF9TOjEkcreDnQiaMaiBKr7dBWI1YUfoCY0SxAgDsAkW+vmwDh8XogvXXC56KiZLTAx23S58PrC0tmuCBPR3Nb82FbTD+YPUjG+kc7xBeKxVm/N8MPEEvaajB3BQBhxKS18JpAtA9+7UQ52Dzu30IjaQgqXz/pGYUhF4pwKjEPG5bQ2AwxbCSPhH2Y77aIzvWHvRbiyKlTaE7AfwP6VG3fhD+cb7mm4XXeo+BpHg9NXEBrp7T8n2OhrYYa6PNPZLfKOQzXdwrKbmD+s389092Chn2Ip42zq7mzwxvM5V6h0/AhGW3KzluIl4Ulo0+tm00rRppxGY4acL6JMoghbv8so6ygV+8DQzdTBzM7clqDr9k0nHo3Yh6pOah5yH76jRSbQo4g/0CHJp5Ckse1xxfyhnJrswcpeg5kBnFIyyXUPNDyaZmz28++bhFcWUzbqqkHYRU2wslSHZH2ZBiBqHWjTPhUJFebB/TqYaARxzX4//sbWTK8Af5bQdkVIxD05Ao2D9EoGzWPncu10AHlJINyUsXfljfWdRuBgE97hA/yvjisNg/71Vp5FEh5dqEgi10rbDZ4IL11nXdEn8dNtN6YaudRpMyzjU9XwMvWI2Eb1aCBtLQJH4jar8ZO8LAx09bDIFuWw8tW0Yvbwp4WAwbSXSaEzWP3DjWO3AYzLS4YTPg3GBG9311Q9qmhAoG9+dh4yMvfsVjqcFC7U1vJfsF/PffJoa6NZQU3DBPIlevCoUN3+/emEgipMJHy3QAHOhkS8rhHS6ldLQNpVnZ+kfdJxw40ccAqf9cN4EIXu/J+4Gtns6VVIBl9iDfv33VAwUWAMBoAXpRQyMnan31pjjvZkIC0XBfeOfQ+aImTCxSZBALvwGq88CDFQskc+X5pLdueZEBArL4bDzkF3NcqkktSFVyGJBo3BhKWC0E5RZnl0oNsXwMCcrb97kXwy3q5oIhVwlEwI3DDA1Bd4A1fq5xzmN+YaEg+BOkODETmfVckp0osAY60sRzZg2cJnpTWXTEgIIjsa5CJMYr3ogGuxESjVJZ4pK7uhuEAoe4KsnNkVSF3RnTgiwd4y1kGQezgr0IudCq7DQXIW+uSucVeAaz8rPoVAHfaOs87AYDvU8cfKXv1B0joeqY5so3cvOUVV6/uYFQRqhg7HK1N0gBOtYetyuc8VzbrJhDqbgDIU6vCvL09bVIASKQv9o/4GRB0vMjsX904k6MtGpojeaAc1EUglA3+5gvdXSa/zoEWAVzsAPIWrC7I8tAtIP6Ia2cIhrIvUXQPiIX/dhcXnynVuJa0UKRQ7seJcsSl1tsmFcp5sgQEDusajoGAIDSnrKi409RH0jkgVGL0AvOpyXASbQGwhb1HgBtYCYe8pAULXCedVznYVzIqvUl4BgL83n4PJpKTeVM6SzkrTJ36nNjIpMipmyovb2tzV6qfC3Ni0OXU2t60qDSAdzUgNqK6eZN/PUPXgKSs8zOx9JryQkq4X2iKLwX47nl19Xs17nkAc7RQbNGZewOzkkXEFEiw4yo3+gwjdfzLUwalu1LB8Pij2ThGwXTJClq7Damp1jMgIM3RDkmLHBt/NgujBrANDM3dLYD+AflRJy88U97WJSAUuu1KWxsPEmZAwo6b4YrIZ11fCnt1CAiJ7mnHXB68GCMgpJj65L1BuCJy/vPR7GbdARLqQgHmwb5rMAISyaoQZBbvwhURq+FR6SBZV4CQV8W70vZEhWMDhLoXmeVdQ8eZIzk2JG2j6AgQs/Ddy5IAGSOnTpGIkdu1XXCFg/JGwJej/D4H3QCSQn+9D57BkjW3BCkN8sQVEBPkHGVoQIPHKJguWf6x1s6JmAFx2sstYdngap9luR05Rpn7UoNBO6ZAokyjF7ljF4dY/onZgMFybYnd5nkJWvuwj/zVgMaCdkwDQ3K03+IonAWGZlvqk/+A1cRqsg0CxBGAx2OaCtoxzRgupcXGuuIMSAxDLOBhNm7gF/tyd66ngigPkzENhYiYxiFeUassl+MLCElSgdwLgt3NRMQUGDIbgvaONf2djHMgZt7uLvbW+ALScpgDA8nHNJpRH8h/cF/63XmcL1lzyG6Bi3G2ZNnWEAhVLEyvNnZD87qQz0Pp/Yt4BkLZYLvQYmMAzoBsOMAtSQ7GNJJDN78QxN54O3vsNI6BWPhvj4/3wZuFgIhrTKyvBfFDL05kb3H+D3/sGH6BUC1Mw8J+0vEf7oEmzRPmBUZpC4gmhF6fyE7Olz8pHfj6LF6BvELLAiJ9kAI5l8DoiWoGD70AAsK35W4rFsPeqbh04EW/7gCxcQPWfvB7rwATpKLUIcnOukEvgMDLwS60L7JwZx9/6JQOAAn3hpXgsgkwkcOtTZsiA8xgb8j0jk0AeiL1/C7WdodL0tFh/ANJM4XltHLCQmDjmBgPt36OvgChzuVWiLNUKwFoFj6/e1E3lqxlNpE+xK2BFE9He2eSHjl1VPP9c1pVcbBvtHoofXbrqk4AQXdZ5gkgaN6y6UyU0zUbaWBung8H7j4seLN1c1gngOAgDtE4ln1ZVYSiRunI5YtGIHhQR6WAwGMoaptGQ04ZgeBAEZVVmQo5h5fb9Fx05rwRiNZFia/hIp3EvBNNA/faTxuBaD8g+aAVaQUTt/6zp+lO3jDZCETbCqVnITkX1VKHNuGDQ139RiDa1nFJIa8kR+YGwGA2Mm7KCETbsotVqXJ/BYDvzg9LC56KLvcbgWhZZm+uWAJAyk4IYtcqx+7lfUwxAsGBktDE1RHp0TuirtNGINoXEa2jgz48KvxuXPTns0YgWldiujrbXtvUyKi4cMwIROty8whGkRzhl8pGRJdPG4FoXQ7B6UiVUHqjtPPYBdGZPxqBaFvkjQ0ytW8v6x4OCfnY0ghEM4oID5/uVMhViI1s/6hHOPivb8TjX5OMQDQgUwmDIVk0zW8Od6XHOAHQXMA/kVPDab+a5Ljhf1DpOLfACOT/UYeERyDwJDOcRPjRQenBdMXNQ3JF+ruepIVJUwoofe1ddy+WsCqtQ2cPCDFI3QFKCnLU7RRudTRa9MOY4ajOrewTpdL99GQ5Jz8Hii2XxSHtTFFLY1YFzIumFbfm5CiKqjjcNbMHxN05Dj1D2OJs76q+I+W/7J1pcBP3FcDH55O9stCuutpd3feNdSFZlrAtWZZ8KJJlxsYWlsURj88YX+WoBeFmcEgNlJKYAnFLw9HQYZhOk7QEpoWmadNkmpCh9FunM51p+6n91Jn2Q2e6K/HBgKe2RbBkozeja6XVrvan/zv++/a91ZooZ0l1UWxbZlllknaCf/jaD35ecuzwls1Mc8ZmMRSkY5Vr+7Z88+C1fUyN3D3oyqmsYhszSt1xDt8seqZe1moSd6p/w3n3cue4jL2ss3e+9f2flBzb17d943e3xZDT6T4pTLX7vl2H6fst74hXAEjDBlpagG1mNia3AUkInqkot7pCvvNtbee1mYUm//rpq9/bVrLr6LcPDf39lXTqfAlziXFR+7G+oqKjF1ZCZQmsVmtgjB4hzIsKKQK22KpWWQBdZ89m2izgk5a/HHj1b7tLrh2s2nnz36nGNSXHzhQVDVw70T608apo5WwIb/b4nGvcBwqvwbTmEuWWF8Vcnn7tN//56Mb7N3cODO3av//kTNvbR49E2Ge/crhW0O2N+Sv9bFkAOOsai+GlBgJw5fL0d65/CfCLhz+69ec//Zf/0T//ocsHhtkU8srlS8M/+5DWYHfv/3Zn1f0Hn+Qj9WwLevvR8PTlHQAfP7hftXfvzV/eu5EHkmXpuTN84E4PU/zz3h++2Hur6ouHd298Iw/khYmrxmtd5ArTHZ9PD0//9Y/M048fvHmz6tbeu3kgL0pqr258e6N0sRl3tOf6peHpz3tSjuen997/NA/kRYmQ6Re01bu4gRd/eP3A8KU7tz/j523Ii5RUFbyBpfQXIIHf8/tHw8OPrl/+ksw2EIRbkdPCzbie08XtNJDD1JK9rh23r08feKKwUDaAIKJiTk5LsShTIoH2Q32H2pdXqOCznitZBsKry3XNU8fLcEXMt6f93V89z6azAYTLzXUgvMz38JUPXLCGgPDCYbZMRmu1KC/s0C32Ze4Fml1w5NkF8rySVSD8gPmib7665hKTrICEAPBE5mZaQ+XMsuLRYrQC0AqMVxxDgcNNVtPu/jgKbo68xjyIAFaHgasL9Ek6HtMPdm2ixlE0WQsoj61HxkVoHsgygHjbN2/fqJrniY82dQF0SJOgmgsrSC9NBgT2oDEZgkG1OB6xV4LJZiqtbrERON8fn6w87tcDGtFB0FOvCmoQiU0lmTzezQ4SthZZMz6LKzSyPJClA5Ex1d7OtM8rJo522kwWYBl4cXf4OHGCyZCQUAJUboPRkLhJi5pj9gkwhZ1hLFJfyYKGVKE4o9dN8cyTm5rLbKMgDivgnBorMyWbuMiIhJNXWcsA8rh8yxMVtlzhJteo2uAHh0JsmGUYOfDgGAVjFBLXQ0RL85rcRMRAI/E7YH0KCJso9/NnDDXWMSmtoDwKcAQhSUTVAFPdamUeyNKBiE71MeeV53X5LC6PShIuTH0iChIV1MbZAIP1DQmR2TM5w5/p9EhdapUlHtsgLJOyg1ZQmsdpw4GpTmtB2Dke7lB4lVGlORaLl2k6Y2ZAPGPEpjyQhf1zPraADdG0DQxstc+bHHX1B/1RgPUsFAQBgFn6/z1eKbTAOdxo7KAacS2o/EEHVG/ALSARANmqYao+1Vci4DLg/QjHi1tIQyX3HL4BqTMCasB9SB7IfBHYbSkQGqrXugAQse/qe96lZg64pUxfsUh9jschuQ2koiGR8jvt5eznDgxRbQd9v2hPpTyQhddAXLSIoS6VlwWdKoop1Mrncbrn1niknqtANtlpkYDejKbnmuVx2gPlCp3N4TyQrADho7SQwJYi0KHH3DCaSIcEhsI8kCzakCn1bkKkxElhaUiyVBsSTic0V5N5IF8/EETP1aP8anCzuxY26nXsZxxkVj+t4QAl5CRgeSArO5fVETx5knjit1c4ndKJOZNJEDthk+gUEUkeyEoCaWSyjlXzxwGLVRdvZQsMBNgGsQrB3AhnTQEh5b/uymEg/BEGyOn5u1iqBVZrp8mUQEIiKCCEzfK1BKSOONJ2fn3uAsEoBkgz8tQI6R6RBZrElBZsc4PNyTUEhN871Hdm+zui3FVZlv0lJdtm579d7HSWOlrVGhUEKImH8hOyNQSkNjWZetCXu0BAiSvKnvayHt8Ay6Lf+2KAfNDOFCcfeiOHgbxcgaF45HBR0ZZFuvvmgaygUde9u/XgqXVYHsiKANFrLl7QLvKZHwe+EuRyHLKWgNSeHxrYd8ry3JvOfSCuKHBmlecyb+s1xa5d+pl1JZIhEC+T97754ltrCwi/prfXUdjKXC2qlZbiqahwohUmKwd1pPex/04a7d3MUUMneitdXAVFO8YFdv//CYA1BZxo6onxMRdMYhcyu8AOUnqQhUpVbLJ15PH184aCDIGoN6dqAKBrC0hyhF07PhZ3wTqvRwUsJqmEjMi0pyPKmtHdlBWtphc0UHIF09PbqtKJ+C6LNApKaUyzgTTiE2l3eaI12ABWH4tdg9dgSCOLsMasoBN2C5oS5WImz1OeGGxkWn/ylCPjIEgMcoCvU/mAtOIGJBZBMgMyyRRT3n51tY6Qu28+JenGArWJxnqAiAfMg+GmdU3MUZNRGMdmZUu55gAvzCxoNEDYST864yqFG4CIgpEFWlO9WaBL/z1nNGVx7oXQlDGojYR9ivpmSZlKnyhskTkNxUoFg1IIyVBKBVLjIFeXmurob/WBIK5TIq6QPjMgsj1HD20+4lmtNuR3VU/Jw/TbbOMFFd+haLFjc9JAnEnunQoBlOpcNiSig2rmhLrXB5Ze5mCyULwA+MQU9DeCjpARQkt6hFBRcGqDEiASKmlBZAqCgQZhIdMRVlgICJMoUVAJsVDKVlBJ4IvR7k6ATiNwVLgDRShRhl5WzPme+WtomJhbKgt1QcUMp8tmC4AEhxYmy5RHVUNE2WVGCC2IGZVVo8AM3RgP/AaoLAeMGANPKVYu5LtamtIzkQkPGZoSzkGwH+1CVIVkyNqAa9UooEIJswEALcX3mEgOPZ6oGKAkGPz0CDECigialC41N+M45C2AtQZE34tHulHw7+aAAweUYHJ+8BboVXZRiME2t55RWV0mQi3jqvkitam0wq3YTWkRBUHFBE5cwZEw6fBmNYGj+Bwk7QrFmECKv15owUFjD8ol0pqUyhILCUoJveOcIL1yNKIIxTDf6zMTMRwn6lpwEl7e8yHPCFY3KKL1TkcxfeMAcBjfqd4IPDH5v/bO5Tdxe4vjYhRxAnYcbATYPGye5hkMxCAHypDwCAmIQCPRAZGmUkVLR2rEI1IXiTSbSqNRF6O5i0iRZoF6V1f9F+6y6qq7+xdd2/StVsrPo4I78XcFRocD/ti/3zm/x/EORd7GMdUQm8u98FMKiOcHQM4Dcp/sm9uADMz7mOtW/o5I9RYDQm6SBlM/CXEv0ccIoIcBkgr4MbXCB3kr9xoVUjUmh3P5rsGHQ9zpnw5gEoX3GcgyNS4pDXsv9TakNQ+hHj5H5fPLzij+XeZQ7PA+A6FCw9ilfE3S7XwmJxljWZsEQtGy5OvVLxDKg+VIiMzkg5jvmQFkM0BMkf39CAvEWV5+480BtS9nyzvHY2Oh3IaA+NSlpDsFVn5JYFzApi6VpkFEv0PsSs8cP9D8F312Gn/wZJd08F536sdveA8WDcI9wyQf0qljjT5Yp5b0dQfISe3ZXD05QWnIJPN47+d9JJXmrtLP25LXJcBM12WZl7g9++sfER37Gmpejv+cR0uTQ3U9WCkthxo2UbQBltxehQKt6/c67K0MZ1OnEmr6vQ8Ke20Cnj4eOJqtq5bvqtNQl5+WRWfwInSzdXyxqv1Lm3efOeSMcWq1MBZiUg93wdzNc4P4PbsaYfRGsy3cO8GuAAAFBElEQVSoRJdze6NDQuB+YSZDNOwtbo9eLNTIguJrR8quFCorJIAsiM0wdehZMBKRbVSwMy88xjzk04//oB/VTwkh0nSCpxk6XZJcJ/tSqTDgsDgdQmy8V8t1cI+khAkUJqwWPKatq4EQT/JJeMc1Sa5WRHRfdrlW/atJNZhMJ7YEkdmXLrHEWbdjPTnv80PFiw2YG3VsdwJegaaFIeMFV8wxsvag1lgTEOyb774TP9MLkH9/++Xv9O1/1E+Lr1/JbY+HObuS+ieOk2vlmDkKjRGE78qHgFnk69odgX5bbV86ETlrmDFDSDIuXjobhVaTo10eWH5vH+ov06mcyQNPXAPBfiHDugsD7MkmcYaAt+rGH3ECvQgN7bs2DkEL76g6YTexHiDO8AdffPFBwakTIL5P/6BVuQ975P7yBjwl4DNY275lVtK0YB3OazIQ0/ZPwyucT+KUW6fqigMEXD3oXxYhd4OVmOyvQCxBWArDebz8ExBBBpIprL6hyMVBUGsOJI4A50gf55eptt105mwXRqb1APnh638pW5Dd+h46sXFE/SrmYOEuYuNwGDXlY8kJLHgwZ+64ktpkUR5PcETtZmZfXZdvbW/C2SidSov7gSOTK7+jhAHJ0yPurpMCm6t5xMYFMcfITdZEbrKGnAnjlZV3YiEdpMtlsFwIHTrtcNQgeXY9xpKL8MT5droeIP9VtyB/UtI3EF8Ug1jsJg50tSi/3FICK9yB+WcQ24IOa88o0RLGPiEhhMfPTdbpwfm5NQoDtvEUqosqdJW69t203Kk/jcmnNVseQuA8GiNbNGVZPIeotV9V4gS6lJVg+hzqJtMe+FglWLCUCQiZOs4e71wPkLmyau7zr3/QN5A/n2h4eApSVZKdbuIdzlP86ZryEIr/8KOPPvTQ/0AgqJIG7/wV64iyyO857n+kPqKsteykfRfZHlcecuCVMF1L8h48KiBQxHWuIjwuIIZ0BGRpnHNdAWku7Fu/aKe4hS7Chm5jIzQ4Ku5swBEhWtcLhI2Mzb8ocvqbNw9U6gWDbDRmXqSQHY1PI+g/jjtBd2Q+df3Ga7u+XiC/E57SYHTcQ7fpHWtwlMLRbeojDY5c6HVM/y4gBQ1GHje6jdujwVFBw/7G+rYGR+aiXoD0tRTgc2vYuk5ogAihPrpNZarFEakXIIa0ygDyKICQi+sZqo0vW0OuJYAnRuhbzezdGqthY3YvgdpD+0e1wwN9AJkUyjnUcUapcdVAbqOtJQ65t6qU7iLopW8Gb09RY7PORcxN6gII1XZDED1x5xsafKXQn/gqRQvIRlSzocwrI+nuJLygdQHEmfNCuowe9moAUh6jD9/eHnM3qDasw8uhpkkD/22upI8mKxKFMfqVy6M3JPmUpkdIWHlk8Pv7r9Lojg5FfQBpRLaRk1Rn/rULtXSv5ZVY9iKnO6KVyaP/pyKH2odUxQT6rfg3hb2Ze+Rn7TiX56YWos3w3mRFBmLLnmvJJp1R1FraeBn9ajHyECMxNGQAMYBsWPQBZQDRk3bO1AVc/qgBRA8adPbalWgpDs8uO9JsOTWAbFa+gqNwNevuuiqjExNunbhaBpCNapaD4dUW2zzNdOR8PCNyIwPIRuVuAy4kCi0hv/RAjKvzHgPIRtWPJPjXopl9w7ovMtXL/IXDALJZ4ZOlZVBedLzAHhGWbj1qADFkADGAGDKAGEAMGUAMIAYQPQP5Pyb2Cz8uBFSoAAAAAElFTkSuQmCC"> <p><a class="reference internal" href="../../auto_examples/miscellaneous/plot_kernel_ridge_regression.html#sphx-glr-auto-examples-miscellaneous-plot-kernel-ridge-regression-py"><span class="std std-ref">Comparison of kernel ridge regression and SVR</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="Toy example of 1D regression using linear, polynomial and RBF kernels.">
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAEYCAMAAABFglBLAAADAFBMVEVHcEzs7Ozi4uLIyMj//v/5+fm/v7/////p6enCwsLv7+/c3Ny2tra9vb3Ozs7t7e25ubmvr6/n5+fExMT8/Pz//f/9/v35+Pifn5+8vLza2tr39/erq6ujpKTAwcD6//7Kysr7+/r1/f3GxsahoaH08/OlpaWysrK07Oy0s7Tw8PDo6Ojg3+Du7u5Wq1ag5+fl5uXMzMyZmZnR0dFd1tac5ub19fXW1tbh8OH+/v61tbWh0KHk5OTNzc3b29uczpympqaam5vx/Pz+//9M0tK77u74/f2+vr5dr13TUNOsrKyYmJipqKmu6+vr6+vmm+aq6urY9fVRqFHY2NjC8PDt+/vc9vaVlZWdnZ399P322PaGhob09PT/+/788fy4uLil6enS0tJ9fH23uLfg+Pje3t5l2dnN8vK93r202rSu166xsbH33ffi4eHQ0NDT9PTn8+eurq74/Pjy8vL77ftQ09Pt9u2P4+Px+PHZZdnQ6NDg4OB93t7o+vq7u7vyyPLY7Nj1+vX99/3no+f44/jzzPOqqqrk+fmn1KfXYdeQkJCG4eGGw4bUU9SSkpL66Pqnp6fDw8PsseyZ5eXc7dzpq+npp+nU1NRjsWPkkeTnnueOx4513NzV6tXJ5MmLiott29vI8fGMjIzfhN/++v7WXdbvwO/Ly8vIx8eura1V1dXN5s1qtWrD4sPtuO2CgoLvvO9Gl0ZzdXOWy5blluVwuHDbbtt1unVIn0j11PXaadp7vXvcfNzz0fPiiuLVWtXQR9BfiV/zz/PVV9Xddd09u7uOjo7xxfGBwIFDikPBP8FJSkljpGMvhy9oaWiBroH07fHXudeWYZYkcyQ6OjqAl5eUqZTAu72ZOplymXKmSqZcW1yhtbCXxsaLl4u7zcLa6Np/zc2jfaNDzMzo4ujIUchdN12+K75Be0FzqamLnIvVw9W8cLw+mZmLoaGwyLCNuo2iKKK0ibSV8fF7kpKat5rA1tYQahDp8Ombw5u9rb3ex966srL0AOwA7OJHcEwy+ESeAAABAHRSTlMA//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AJ5UbsQAAIABJREFUeNrsmu1v6tYdxxssOCTmwQ7MmAumeDhwbbDGQ6+RGaEmbceErVxVbNfeYKMGpZWKYGPcrZPSot5OygteoNBt8ptuTEhTkkltpkh70Vd9lzeTqv1JI2TJpdeZVB6ScCt/lRfn55xzvvh88Pmdc8wrrxgyZMiQIUOGDBm6BQFDKyUDiAHEkAHEAGLouw2ED7bjL1yCtwCrgb3oJCiZ/3dVPUjoGnPbBpBlq3nWYr1cIJg8ieYVdiDvV4Wvhxxz6h4hStCaL3yNl+SQJj4AMnIWRwUGTYZoqaVAmpJGwnuBPTmUTgqkAWRpIg/KrnOur1goop84H8XOy7Ci8kCx9c7E2kj19ePD/ZFyQAK5VvOencoKJJZjZ3IN78Pl4oP8qDlUIkrJALI0cSo6kus1guhHTtvUsCvKnGQjwf6/gyPpGG+YxCO5OxIgAMQHeaVsO+qhomweCi44P2zVCFzsDiXHgWoAWZrMgXonXlUFZbt0anfH6A5MOrs+ANZJpqp5EC0eYDPN6No4s3BrMUeXy5ydwBiDqHA1fhRgYx26GWVNjAFk2cp1AAt/m4rBDGessgytFBB+Vt2l17x+/CK6VyA8u+a81gbjZDZYhr2Kmcnfi9r1zenVmbJinSz7YsdjY3ZDZ7fGzjxCW7tTRhe3w0wbT5kwE1OdI3OPQEjnVMBsYnGGM3mu4vGWLuvW5+nQfPsCfndqZD1kRdeLlQQdp75daeZV7xr2vOwzkcA9tTdlsDGvqRuM6r9evLp2j0A2pgKpPOgpEYph2lVXLmPyU9C6pM+xZHe+vMtPD/Z6swm1YReUC2gFbJ2uNqtpaJSivdANQI5mdZo2gmTCtk3AD7pIk8416oPWPhJ0kbStYIo0bXKqW7Tq2ydM9wik8ulXf7/QV18AQPQschKnyRxBSfnqEOmd4rj+C0R65wTyn/deu9RnrwIvHJRt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"> <p><a class="reference internal" href="../../auto_examples/svm/plot_svm_regression.html#sphx-glr-auto-examples-svm-plot-svm-regression-py"><span class="std std-ref">Support Vector Regression (SVR) using linear and non-linear kernels</span></a></p>  </div>
</div></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/generated/sklearn.svm.SVR.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/generated/sklearn.svm.SVR.html</a>
  </p>
</div>
