<section id="dbscan"> <h1>dbscan</h1> <dl class="py function"> <dt class="sig sig-object py" id="sklearn.cluster.dbscan"> <span class="sig-prename descclassname">sklearn.cluster.</span><span class="sig-name descname">dbscan</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">min_samples</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">metric</span><span class="o">=</span><span class="default_value">'minkowski'</span></em>, <em class="sig-param"><span class="n">metric_params</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">algorithm</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">leaf_size</span><span class="o">=</span><span class="default_value">30</span></em>, <em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">sample_weight</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/cluster/_dbscan.py#L22"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform DBSCAN clustering from vector array or distance matrix.</p> <p>Read more in the <a class="reference internal" href="../clustering.html#dbscan"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>X</strong><span class="classifier">{array-like, sparse (CSR) matrix} of shape (n_samples, n_features) or (n_samples, n_samples)</span>
</dt>
<dd>
<p>A feature array, or array of distances between samples if <code>metric='precomputed'</code>.</p> </dd> <dt>
<strong>eps</strong><span class="classifier">float, default=0.5</span>
</dt>
<dd>
<p>The maximum distance between two samples for one to be considered as in the neighborhood of the other. This is not a maximum bound on the distances of points within a cluster. This is the most important DBSCAN parameter to choose appropriately for your data set and distance function.</p> </dd> <dt>
<strong>min_samples</strong><span class="classifier">int, default=5</span>
</dt>
<dd>
<p>The number of samples (or total weight) in a neighborhood for a point to be considered as a core point. This includes the point itself.</p> </dd> <dt>
<strong>metric</strong><span class="classifier">str or callable, default=’minkowski’</span>
</dt>
<dd>
<p>The metric to use when calculating distance between instances in a feature array. If metric is a string or callable, it must be one of the options allowed by <a class="reference internal" href="sklearn.metrics.pairwise_distances.html#sklearn.metrics.pairwise_distances" title="sklearn.metrics.pairwise_distances"><code>sklearn.metrics.pairwise_distances</code></a> for its metric parameter. If metric is “precomputed”, X is assumed to be a distance matrix and must be square during fit. X may be a <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-sparse-graph"><span class="xref std std-term">sparse graph</span></a>, in which case only “nonzero” elements may be considered neighbors.</p> </dd> <dt>
<strong>metric_params</strong><span class="classifier">dict, default=None</span>
</dt>
<dd>
<p>Additional keyword arguments for the metric function.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.19.</span></p> </div> </dd> <dt>
<strong>algorithm</strong><span class="classifier">{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}, default=’auto’</span>
</dt>
<dd>
<p>The algorithm to be used by the NearestNeighbors module to compute pointwise distances and find nearest neighbors. See NearestNeighbors module documentation for details.</p> </dd> <dt>
<strong>leaf_size</strong><span class="classifier">int, default=30</span>
</dt>
<dd>
<p>Leaf size passed to BallTree or cKDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.</p> </dd> <dt>
<strong>p</strong><span class="classifier">float, default=2</span>
</dt>
<dd>
<p>The power of the Minkowski metric to be used to calculate distance between points.</p> </dd> <dt>
<strong>sample_weight</strong><span class="classifier">array-like of shape (n_samples,), default=None</span>
</dt>
<dd>
<p>Weight of each sample, such that a sample with a weight of at least <code>min_samples</code> is by itself a core sample; a sample with negative weight may inhibit its eps-neighbor from being core. Note that weights are absolute, and default to 1.</p> </dd> <dt>
<strong>n_jobs</strong><span class="classifier">int, default=None</span>
</dt>
<dd>
<p>The number of parallel jobs to run for neighbors search. <code>None</code> means 1 unless in a <a class="reference external" href="https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend" title="(in joblib v1.5.dev0)"><code>joblib.parallel_backend</code></a> context. <code>-1</code> means using all processors. See <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-n_jobs"><span class="xref std std-term">Glossary</span></a> for more details. If precomputed distance are used, parallel execution is not available and thus n_jobs will have no effect.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>core_samples</strong><span class="classifier">ndarray of shape (n_core_samples,)</span>
</dt>
<dd>
<p>Indices of core samples.</p> </dd> <dt>
<strong>labels</strong><span class="classifier">ndarray of shape (n_samples,)</span>
</dt>
<dd>
<p>Cluster labels for each point. Noisy samples are given the label -1.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.cluster.dbscan.html#sklearn.cluster.DBSCAN" title="sklearn.cluster.DBSCAN"><code>DBSCAN</code></a></dt>
<dd>
<p>An estimator interface for this clustering algorithm.</p> </dd> <dt><a class="reference internal" href="sklearn.cluster.optics.html#sklearn.cluster.OPTICS" title="sklearn.cluster.OPTICS"><code>OPTICS</code></a></dt>
<dd>
<p>A similar estimator interface clustering at multiple values of eps. Our implementation is optimized for memory usage.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>For an example, see <a class="reference internal" href="../../auto_examples/cluster/plot_dbscan.html#sphx-glr-auto-examples-cluster-plot-dbscan-py"><span class="std std-ref">Demo of DBSCAN clustering algorithm</span></a>.</p> <p>This implementation bulk-computes all neighborhood queries, which increases the memory complexity to O(n.d) where d is the average number of neighbors, while original DBSCAN had memory complexity O(n). It may attract a higher memory complexity when querying these nearest neighborhoods, depending on the <code>algorithm</code>.</p> <p>One way to avoid the query complexity is to pre-compute sparse neighborhoods in chunks using <a class="reference internal" href="sklearn.neighbors.nearestneighbors.html#sklearn.neighbors.NearestNeighbors.radius_neighbors_graph" title="sklearn.neighbors.NearestNeighbors.radius_neighbors_graph"><code>NearestNeighbors.radius_neighbors_graph</code></a> with <code>mode='distance'</code>, then using <code>metric='precomputed'</code> here.</p> <p>Another way to reduce memory and computation time is to remove (near-)duplicate points and use <code>sample_weight</code> instead.</p> <p><a class="reference internal" href="sklearn.cluster.optics.html#sklearn.cluster.OPTICS" title="sklearn.cluster.OPTICS"><code>OPTICS</code></a> provides a similar clustering with lower memory usage.</p> <h4 class="rubric">References</h4> <p>Ester, M., H. P. Kriegel, J. Sander, and X. Xu, <a class="reference external" href="https://www.dbs.ifi.lmu.de/Publikationen/Papers/KDD-96.final.frame.pdf">“A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise”</a>. In: Proceedings of the 2nd International Conference on Knowledge Discovery and Data Mining, Portland, OR, AAAI Press, pp. 226-231. 1996</p> <p>Schubert, E., Sander, J., Ester, M., Kriegel, H. P., &amp; Xu, X. (2017). <a class="reference external" href="https://doi.org/10.1145/3068335">“DBSCAN revisited, revisited: why and how you should (still) use DBSCAN.”</a> ACM Transactions on Database Systems (TODS), 42(3), 19.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.cluster import dbscan
&gt;&gt;&gt; X = [[1, 2], [2, 2], [2, 3], [8, 7], [8, 8], [25, 80]]
&gt;&gt;&gt; core_samples, labels = dbscan(X, eps=3, min_samples=2)
&gt;&gt;&gt; core_samples
array([0, 1, 2, 3, 4])
&gt;&gt;&gt; labels
array([ 0,  0,  0,  1,  1, -1])
</pre> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/generated/dbscan-function.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/generated/dbscan-function.html</a>
  </p>
</div>
