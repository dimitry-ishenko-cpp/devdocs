<section id="hashingvectorizer"> <h1>HashingVectorizer</h1> <dl class="py class"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer"> <em class="property">class</em><span class="sig-prename descclassname">sklearn.feature_extraction.text.</span><span class="sig-name descname">HashingVectorizer</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">*</span></em>, <em class="sig-param"><span class="n">input='content'</span></em>, <em class="sig-param"><span class="n">encoding='utf-8'</span></em>, <em class="sig-param"><span class="n">decode_error='strict'</span></em>, <em class="sig-param"><span class="n">strip_accents=None</span></em>, <em class="sig-param"><span class="n">lowercase=True</span></em>, <em class="sig-param"><span class="n">preprocessor=None</span></em>, <em class="sig-param"><span class="n">tokenizer=None</span></em>, <em class="sig-param"><span class="n">stop_words=None</span></em>, <em class="sig-param"><span class="n">token_pattern='(?u)\\b\\w\\w+\\b'</span></em>, <em class="sig-param"><span class="n">ngram_range=(1</span></em>, <em class="sig-param"><span class="n">1)</span></em>, <em class="sig-param"><span class="n">analyzer='word'</span></em>, <em class="sig-param"><span class="n">n_features=1048576</span></em>, <em class="sig-param"><span class="n">binary=False</span></em>, <em class="sig-param"><span class="n">norm='l2'</span></em>, <em class="sig-param"><span class="n">alternate_sign=True</span></em>, <em class="sig-param"><span class="n">dtype=&lt;class 'numpy.float64'&gt;</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/feature_extraction/text.py#L558"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert a collection of text documents to a matrix of token occurrences.</p> <p>It turns a collection of text documents into a scipy.sparse matrix holding token occurrence counts (or binary occurrence information), possibly normalized as token frequencies if norm=’l1’ or projected on the euclidean unit sphere if norm=’l2’.</p> <p>This text vectorizer implementation uses the hashing trick to find the token string name to feature integer index mapping.</p> <p>This strategy has several advantages:</p> <ul class="simple"> <li>it is very low memory scalable to large datasets as there is no need to store a vocabulary dictionary in memory.</li> <li>it is fast to pickle and un-pickle as it holds no state besides the constructor parameters.</li> <li>it can be used in a streaming (partial fit) or parallel pipeline as there is no state computed during fit.</li> </ul> <p>There are also a couple of cons (vs using a CountVectorizer with an in-memory vocabulary):</p> <ul class="simple"> <li>there is no way to compute the inverse transform (from feature indices to string feature names) which can be a problem when trying to introspect which features are most important to a model.</li> <li>there can be collisions: distinct tokens can be mapped to the same feature index. However in practice this is rarely an issue if n_features is large enough (e.g. 2 ** 18 for text classification problems).</li> <li>no IDF weighting as this would render the transformer stateful.</li> </ul> <p>The hash function employed is the signed 32-bit version of Murmurhash3.</p> <p>For an efficiency comparison of the different feature extractors, see <a class="reference internal" href="../../auto_examples/text/plot_hashing_vs_dict_vectorizer.html#sphx-glr-auto-examples-text-plot-hashing-vs-dict-vectorizer-py"><span class="std std-ref">FeatureHasher and DictVectorizer Comparison</span></a>.</p> <p>For an example of document clustering and comparison with <a class="reference internal" href="sklearn.feature_extraction.text.tfidfvectorizer.html#sklearn.feature_extraction.text.TfidfVectorizer" title="sklearn.feature_extraction.text.TfidfVectorizer"><code>TfidfVectorizer</code></a>, see <a class="reference internal" href="../../auto_examples/text/plot_document_clustering.html#sphx-glr-auto-examples-text-plot-document-clustering-py"><span class="std std-ref">Clustering text documents using k-means</span></a>.</p> <p>Read more in the <a class="reference internal" href="../feature_extraction.html#text-feature-extraction"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>input</strong><span class="classifier">{‘filename’, ‘file’, ‘content’}, default=’content’</span>
</dt>
<dd>
<ul class="simple"> <li>If <code>'filename'</code>, the sequence passed as an argument to fit is expected to be a list of filenames that need reading to fetch the raw content to analyze.</li> <li>If <code>'file'</code>, the sequence items must have a ‘read’ method (file-like object) that is called to fetch the bytes in memory.</li> <li>If <code>'content'</code>, the input is expected to be a sequence of items that can be of type string or byte.</li> </ul> </dd> <dt>
<strong>encoding</strong><span class="classifier">str, default=’utf-8’</span>
</dt>
<dd>
<p>If bytes or files are given to analyze, this encoding is used to decode.</p> </dd> <dt>
<strong>decode_error</strong><span class="classifier">{‘strict’, ‘ignore’, ‘replace’}, default=’strict’</span>
</dt>
<dd>
<p>Instruction on what to do if a byte sequence is given to analyze that contains characters not of the given <code>encoding</code>. By default, it is ‘strict’, meaning that a UnicodeDecodeError will be raised. Other values are ‘ignore’ and ‘replace’.</p> </dd> <dt>
<strong>strip_accents</strong><span class="classifier">{‘ascii’, ‘unicode’} or callable, default=None</span>
</dt>
<dd>
<p>Remove accents and perform other character normalization during the preprocessing step. ‘ascii’ is a fast method that only works on characters that have a direct ASCII mapping. ‘unicode’ is a slightly slower method that works on any character. None (default) means no character normalization is performed.</p> <p>Both ‘ascii’ and ‘unicode’ use NFKD normalization from <a class="reference external" href="https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize" title="(in Python v3.13)"><code>unicodedata.normalize</code></a>.</p> </dd> <dt>
<strong>lowercase</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>Convert all characters to lowercase before tokenizing.</p> </dd> <dt>
<strong>preprocessor</strong><span class="classifier">callable, default=None</span>
</dt>
<dd>
<p>Override the preprocessing (string transformation) stage while preserving the tokenizing and n-grams generation steps. Only applies if <code>analyzer</code> is not callable.</p> </dd> <dt>
<strong>tokenizer</strong><span class="classifier">callable, default=None</span>
</dt>
<dd>
<p>Override the string tokenization step while preserving the preprocessing and n-grams generation steps. Only applies if <code>analyzer == 'word'</code>.</p> </dd> <dt>
<strong>stop_words</strong><span class="classifier">{‘english’}, list, default=None</span>
</dt>
<dd>
<p>If ‘english’, a built-in stop word list for English is used. There are several known issues with ‘english’ and you should consider an alternative (see <a class="reference internal" href="../feature_extraction.html#stop-words"><span class="std std-ref">Using stop words</span></a>).</p> <p>If a list, that list is assumed to contain stop words, all of which will be removed from the resulting tokens. Only applies if <code>analyzer == 'word'</code>.</p> </dd> <dt>
<strong>token_pattern</strong><span class="classifier">str or None, default=r”(?u)\b\w\w+\b”</span>
</dt>
<dd>
<p>Regular expression denoting what constitutes a “token”, only used if <code>analyzer == 'word'</code>. The default regexp selects tokens of 2 or more alphanumeric characters (punctuation is completely ignored and always treated as a token separator).</p> <p>If there is a capturing group in token_pattern then the captured group content, not the entire match, becomes the token. At most one capturing group is permitted.</p> </dd> <dt>
<strong>ngram_range</strong><span class="classifier">tuple (min_n, max_n), default=(1, 1)</span>
</dt>
<dd>
<p>The lower and upper boundary of the range of n-values for different n-grams to be extracted. All values of n such that min_n &lt;= n &lt;= max_n will be used. For example an <code>ngram_range</code> of <code>(1, 1)</code> means only unigrams, <code>(1, 2)</code> means unigrams and bigrams, and <code>(2, 2)</code> means only bigrams. Only applies if <code>analyzer</code> is not callable.</p> </dd> <dt>
<strong>analyzer</strong><span class="classifier">{‘word’, ‘char’, ‘char_wb’} or callable, default=’word’</span>
</dt>
<dd>
<p>Whether the feature should be made of word or character n-grams. Option ‘char_wb’ creates character n-grams only from text inside word boundaries; n-grams at the edges of words are padded with space.</p> <p>If a callable is passed it is used to extract the sequence of features out of the raw, unprocessed input.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.21: </span>Since v0.21, if <code>input</code> is <code>'filename'</code> or <code>'file'</code>, the data is first read from the file and then passed to the given callable analyzer.</p> </div> </dd> <dt>
<strong>n_features</strong><span class="classifier">int, default=(2 ** 20)</span>
</dt>
<dd>
<p>The number of features (columns) in the output matrices. Small numbers of features are likely to cause hash collisions, but large numbers will cause larger coefficient dimensions in linear learners.</p> </dd> <dt>
<strong>binary</strong><span class="classifier">bool, default=False</span>
</dt>
<dd>
<p>If True, all non zero counts are set to 1. This is useful for discrete probabilistic models that model binary events rather than integer counts.</p> </dd> <dt>
<strong>norm</strong><span class="classifier">{‘l1’, ‘l2’}, default=’l2’</span>
</dt>
<dd>
<p>Norm used to normalize term vectors. None for no normalization.</p> </dd> <dt>
<strong>alternate_sign</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>When True, an alternating sign is added to the features as to approximately conserve the inner product in the hashed space even for small n_features. This approach is similar to sparse random projection.</p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.19.</span></p> </div> </dd> <dt>
<strong>dtype</strong><span class="classifier">type, default=np.float64</span>
</dt>
<dd>
<p>Type of the matrix returned by fit_transform() or transform().</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="sklearn.feature_extraction.text.countvectorizer.html#sklearn.feature_extraction.text.CountVectorizer" title="sklearn.feature_extraction.text.CountVectorizer"><code>CountVectorizer</code></a></dt>
<dd>
<p>Convert a collection of text documents to a matrix of token counts.</p> </dd> <dt><a class="reference internal" href="sklearn.feature_extraction.text.tfidfvectorizer.html#sklearn.feature_extraction.text.TfidfVectorizer" title="sklearn.feature_extraction.text.TfidfVectorizer"><code>TfidfVectorizer</code></a></dt>
<dd>
<p>Convert a collection of raw documents to a matrix of TF-IDF features.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>This estimator is <a class="reference internal" href="https://scikit-learn.org/1.6/glossary.html#term-stateless"><span class="xref std std-term">stateless</span></a> and does not need to be fitted. However, we recommend to call <a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.fit_transform" title="sklearn.feature_extraction.text.HashingVectorizer.fit_transform"><code>fit_transform</code></a> instead of <a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.transform" title="sklearn.feature_extraction.text.HashingVectorizer.transform"><code>transform</code></a>, as parameter validation is only performed in <a class="reference internal" href="#sklearn.feature_extraction.text.HashingVectorizer.fit" title="sklearn.feature_extraction.text.HashingVectorizer.fit"><code>fit</code></a>.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.feature_extraction.text import HashingVectorizer
&gt;&gt;&gt; corpus = [
...     'This is the first document.',
...     'This document is the second document.',
...     'And this is the third one.',
...     'Is this the first document?',
... ]
&gt;&gt;&gt; vectorizer = HashingVectorizer(n_features=2**4)
&gt;&gt;&gt; X = vectorizer.fit_transform(corpus)
&gt;&gt;&gt; print(X.shape)
(4, 16)
</pre> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.build_analyzer"> <span class="sig-name descname">build_analyzer</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/feature_extraction/text.py#L415"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a callable to process input data.</p> <p>The callable handles preprocessing, tokenization, and n-grams generation.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>analyzer: callable</dt>
<dd>
<p>A function to handle preprocessing, tokenization and n-grams generation.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.build_preprocessor"> <span class="sig-name descname">build_preprocessor</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/feature_extraction/text.py#L319"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a function to preprocess the text before tokenization.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>preprocessor: callable</dt>
<dd>
<p>A function to preprocess the text before tokenization.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.build_tokenizer"> <span class="sig-name descname">build_tokenizer</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/feature_extraction/text.py#L346"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a function that splits a string into a sequence of tokens.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>tokenizer: callable</dt>
<dd>
<p>A function to split a string into a sequence of tokens.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.decode"> <span class="sig-name descname">decode</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">doc</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/feature_extraction/text.py#L206"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Decode the input into a string of unicode symbols.</p> <p>The decoding strategy depends on the vectorizer parameters.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>doc</strong><span class="classifier">bytes or str</span>
</dt>
<dd>
<p>The string to decode.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>doc: str</dt>
<dd>
<p>A string of unicode symbols.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.fit"> <span class="sig-name descname">fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/feature_extraction/text.py#L823"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Only validates estimator’s parameters.</p> <p>This method allows to: (i) validate the estimator’s parameters and (ii) be consistent with the scikit-learn transformer API.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">ndarray of shape [n_samples, n_features]</span>
</dt>
<dd>
<p>Training data.</p> </dd> <dt>
<strong>y</strong><span class="classifier">Ignored</span>
</dt>
<dd>
<p>Not used, present for API consistency by convention.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>HashingVectorizer instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.fit_transform"> <span class="sig-name descname">fit_transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/feature_extraction/text.py#L885"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform a sequence of documents to a document-term matrix.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">iterable over raw text documents, length = n_samples</span>
</dt>
<dd>
<p>Samples. Each sample must be a text document (either bytes or unicode strings, file name or file object depending on the constructor argument) which will be tokenized and hashed.</p> </dd> <dt>
<strong>y</strong><span class="classifier">any</span>
</dt>
<dd>
<p>Ignored. This parameter exists only for compatibility with sklearn.pipeline.Pipeline.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">sparse matrix of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Document-term matrix.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.get_metadata_routing"> <span class="sig-name descname">get_metadata_routing</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_metadata_requests.py#L1497"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get metadata routing of this object.</p> <p>Please check <a class="reference internal" href="https://scikit-learn.org/1.6/metadata_routing.html#metadata-routing"><span class="std std-ref">User Guide</span></a> on how the routing mechanism works.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>routing</strong><span class="classifier">MetadataRequest</span>
</dt>
<dd>
<p>A <a class="reference internal" href="sklearn.utils.metadata_routing.metadatarequest.html#sklearn.utils.metadata_routing.MetadataRequest" title="sklearn.utils.metadata_routing.MetadataRequest"><code>MetadataRequest</code></a> encapsulating routing information.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.get_params"> <span class="sig-name descname">get_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L231"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>deep</strong><span class="classifier">bool, default=True</span>
</dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.get_stop_words"> <span class="sig-name descname">get_stop_words</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/feature_extraction/text.py#L366"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Build or fetch the effective stop words list.</p> <dl class="field-list simple"> <dt class="field-odd">Returns<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>stop_words: list or None</dt>
<dd>
<p>A list of stop words.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.partial_fit"> <span class="sig-name descname">partial_fit</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/feature_extraction/text.py#L801"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Only validates estimator’s parameters.</p> <p>This method allows to: (i) validate the estimator’s parameters and (ii) be consistent with the scikit-learn transformer API.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">ndarray of shape [n_samples, n_features]</span>
</dt>
<dd>
<p>Training data.</p> </dd> <dt>
<strong>y</strong><span class="classifier">Ignored</span>
</dt>
<dd>
<p>Not used, present for API consistency by convention.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">object</span>
</dt>
<dd>
<p>HashingVectorizer instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.set_output"> <span class="sig-name descname">set_output</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/utils/_set_output.py#L392"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set output container.</p> <p>See <a class="reference internal" href="../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py"><span class="std std-ref">Introducing the set_output API</span></a> for an example on how to use the API.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>transform</strong><span class="classifier">{“default”, “pandas”, “polars”}, default=None</span>
</dt>
<dd>
<p>Configure output of <code>transform</code> and <code>fit_transform</code>.</p> <ul class="simple"> <li>
<code>"default"</code>: Default output format of a transformer</li> <li>
<code>"pandas"</code>: DataFrame output</li> <li>
<code>"polars"</code>: Polars output</li> <li>
<code>None</code>: Transform configuration is unchanged</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">Added in version 1.4: </span><code>"polars"</code> option was added.</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.set_params"> <span class="sig-name descname">set_params</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/base.py#L255"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>**params</strong><span class="classifier">dict</span>
</dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>self</strong><span class="classifier">estimator instance</span>
</dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="sklearn.feature_extraction.text.HashingVectorizer.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/99bf3d8e4/sklearn/feature_extraction/text.py#L855"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform a sequence of documents to a document-term matrix.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">iterable over raw text documents, length = n_samples</span>
</dt>
<dd>
<p>Samples. Each sample must be a text document (either bytes or unicode strings, file name or file object depending on the constructor argument) which will be tokenized and hashed.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X</strong><span class="classifier">sparse matrix of shape (n_samples, n_features)</span>
</dt>
<dd>
<p>Document-term matrix.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <section id="gallery-examples"> <h2>Gallery examples</h2> <div class="sphx-glr-thumbnails">
<div class="sphx-glr-thumbcontainer" tooltip="This is an example showing how scikit-learn can be used for classification using an out-of-core approach: learning from data that doesn't fit into main memory. We make use of an online classifier, i.e., one that supports the partial_fit method, that will be fed with batches of examples. To guarantee that the features space remains the same over time we leverage a HashingVectorizer that will project each example into the same feature space. This is especially useful in the case of text classification where new features (words) may appear in each batch.">
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAEYCAMAAABFglBLAAADAFBMVEVHcEzp6en6+vrQ0NDPz8/l5eXg4OD//////v79/P339/fR0dG+vr7v7++IiIhoaGjr6+vb29vU1NX29vbw8PCioqK2trampqbW1taTk5PX19f09PXy8vPS0tPe3t79/v719fbt7e38+/t2dnbn5+eCgoLz8/NdXV3o6OhVVVVYWFiurq7Kysru7u7Y2dllZWVsbGzi4uLq6uqrq6v4+PiLi4tSUlJ6enq5ubmxsbG/wMDFxcXMzMzHx8c3pTi7u7uWlpZgYGCdnZ1paWl/f3/XLy/x8fH/9O5zc3OgoKCNjY3CwsJDQ0PNzc1TslNBi76lpaWFhYVubm6ZmZn+hBpISEie1J89PT3bODr/iSJbWlpiYmL/lztNTU1ErEUwgbr///7a2tvcQkP//fzX5/KpqamQkJD/t3neTU5Kr0v/oU4/qD+0tLT6/fr/xI//5dHOzs46h72dw93/+PKcnJz20dKx3bPs9Pk3NzfN4e5etl/b3Nzf39/k5ORIkML87u+/2Olnu2j4+/3//PjC5MP/nEXs9+3/2ri00eb1xsXe8d/vqqv2/Pf/69mRkZFTlsPk4+P/+vjcMyHx+vKUz5Wo2ar/4MWNzI7/7+G44Ln+0qzhWFjl9ebI6MphnceVvdqSkpKpyuHka2z0+Pvrl5duvnBspc3+sW1+xX6wMiXphobW7tf+vYX9jy2np6fmjo/eY2L32NjELh7/zKPS69J4wnf1vbX/q2L/kzRwcHDws7L/plcpfbf53+Dj7vbjPikVFRXtoaExnTCHttfXKh4wMDCFyIX+yJp1rNHlf3/tZUHzmXsnJyf3rJP76ur65ub81MHmdndNmCzveVeJvYLqUDlZiTVlrF+JqcLxhWafPE6AstSulSthnU1qejPYzMdubyvhyLXXpqD4dhzu4t3kr3qBsIGQSiW6zrelc1CmuMXniizITkuFVSHLnpbdwLLHPTGox6V0Zibl18V8XSMyknm8ztrVsqermWPa49by7utSo4/O2719y4L7mExHcEweVn0cAAABAHRSTlMA//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AJ5UbsQAAIABJREFUeNrsm01P6loXx48vsFIsL/KmiLxIRWipgNpSChKqNARsTYCmaYLpwAGMGDhgQKJ+BeNH8BMwZ8bEGR/q7s05z4k5J97Dvc85mjzPXjHQbv67u12/tdfa3Ylfvrw1IPbx9uVvjHiHACFGgBAgxAgQAoQYAUKAECNACBBiBAgBQoAQIMQIEAKEGAFCgBAjQAgQYgQIAfJfA3kMRXL7wujox/aoHIDzJz7se9OWuE0CJR/8meeJK+Wf2oRtCh5H73Qov8QB1vOpN03H8rezk/A/Ht81Sv7Qsl4OoGcuRys+cFY/CoimpzuS0rScP91fLZXVjTzffAuk5IdEbf/PALG7/E9tzlISfPx7dz5wAJyab0PpqEZ9PTjl//H4p5bjhxa5uA7gYJucEw5Ljx8DJGBN0ef+sf6YFIvSNhx7Gq1HYdho7R2JWe98tjd0Aj9rTBP1VnFAafMSE/Q4YNQo1mAz/VKQl2E8LjLXANVe4wwO1YIodMLQVJMVj6eb9RS7h0BNvb2tXAdgJ4fkbrGoxuGg62We0VnSKDKb6JtS5pnq1TbsidAZposxoEKN2UZkftHeHYIQKUgOuIyke3t4wNS4wDgPrEXaDXA5z4gO9Yl5VnpMDByeBC2KXg1iL3Amdht3IDx5DXUZVHSxUYGdMWyowrlUNAR4GUvMvVEIw25aKVwmfLoD6ljj9ngZHJ+pTAVS951Mzdx0gap8DJCHxdpyquuPgTqvlCgxk9d8bdtfe8jqPtmKBc1YfLJzrlGbGl0KNyeDeEC/rU3qZ5PH+lwuLyeWUKlNTd/uZMBXA6x6TUdbT7Bmudtz+faUrnULiZBe0fK8HnVZOG6DNB9hE56LvHaIgWi1jonTYvw17DZroNkwe9XQnYxNTcvXJtUsbYOnVFPZlHdSfWLxDDDMmmhHu2wcBXDsVXv2zxU/umrb3s/rlLGgB3q0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"> <p><a class="reference internal" href="../../auto_examples/applications/plot_out_of_core_classification.html#sphx-glr-auto-examples-applications-plot-out-of-core-classification-py"><span class="std std-ref">Out-of-core classification of text documents</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="This is an example showing how the scikit-learn API can be used to cluster documents by topics using a Bag of Words approach.">
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAEYCAMAAABFglBLAAADAFBMVEVHcExZmsePu9r/fgvMzMy8vLz4+Pj///8fd7Tj4+MVcbFZeYn/fwsooS3IiBaWkB0Rc7choy05lyzJMCjhX2DXHyG1tbUYc7IkpSz87u7dHyXZODmBZCr6+fnF3OwTcbMadLIweKfufhv/fgf29/cad7fFfTny8vL+//78////fwb9/f7vghD8/Pzo5+YinCI8nSm/v7/7+voge7m4uLkVVICW0Jbh4eEdeLckpC0VdruPe2Hx8fKsrKylpqbIyMioqKjFxcWurq60tLSysrLm5ub49/igoKCpqqrr6uopaZXs7OyQkJDZJCeSYrnu8fDv7++BgoPf39+amprc3d3R0dFYgSvZ2dnBwcDG3u7Dw8PPz8+6urqRlZkgoCr7yMnv+O+bnJucGRyXFxiVk5Vegizb29uLi4s8pzzLy8vi4uLz8/P/egT1x8cVZZu7u7vVIiSjo6OXl5cHQmvS0tLX19fk2e+Rf2a5ublXmMXt7e3/9ezu9fr19fWSZ8Bqvmr/o0+Ghoe3VwR8DREMTg/GN08AN12wsLD/yY6c1pzaIyPV1dX+3b7U09T49PsvgLqNpZKbccEiZJE5lTnVdRQMWhb/7+88mymUQgCoVFbCWweenp7SKzKHcJi/MjL/iiEmZ5TnYGG7f0v7nUmvjc5me4aKZSutKiISbq4ZZ56emB/9hh3P2c/R5fJ5eXntlZYVbhbMjRmmV5fw+vBFeUpShKaAOACRwODSGBljuGFZnMuMudmEm6z/4sQbdh8HO2Dj19ERUX2YlB2kfL5uDQ+UhEz8zqRFdZdehlNFhUnHICLwgR2GYymisr5MeZjia2wLb7aSjhZjR4R/cFXobwQsVnP0kjwPYRj+7duykIXHrt5lhZquz+eAXD1mcHeVhaRAi79riqG1XRCswdCEeXTKOjZ+YCTHhg/GX2CDMDPy5dq24raXExYvkC/TsFaLuYuEtNYugr2hna2gmanp+elloMmgfFsLUIHWsrKScXYkoyqXuX+fyYr8AMcAmtpHcEwDP6EbAAABAHRSTlMA//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AJ5UbsQAAEalJREFUeNrs3H9wk3cdwPGBSb4+VRxOF4b6dL3jgT718QnmIbNV8+RXE/I8JpQnT1IT8gQkLjamQWIyouVZs1lUshkjc3POGRBuuB09DgSBTTa2sukGcnPzx8bEO3Hq1Dudv+48f//hkyZNodA2tW3ShM+rQOB6vXvou9/n+/zK97rrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlCCwoEAQCALmIcg2VQOIiaWN1cQaYWvNrlkEwVmsAfjspa3FtI2wtTHzLIJo1I0w+pnyVmJSI2ytQ9X0Qca2ElM1wtZiEASCQBAI0jhzyKyC0L/45s8aJ4jjxOOL6mb7oVoEofb0fFfTMEF0+5bVT0trrYIsn52vjqJqEuRDXW+sm7b5CUKTAo4zlX92PLh79ztn5xuj/ikWERBkpkFyYc5b0A+IVn9IFRSVIO+Yrdc/W/SvVEShgyAzDSIdDkTdqaGsO8pySQNCP/ntu2bp+UcUz//n7qL3zZzyRX+rNgg/n0G61kxt5fxM6ryYwHT+QJ/BKvrNEun4/k1zY/X/68iRI/dotX3VBGGkffMXpGv4lqk9fUo7DdcMgpBM3MEwSBbL0wdZfskf37SkrlY/9dSRewwGXzVBiIF7myGIYEh3+zSRVILflk0NEX5RUvuDXnMinVCnEfns795SX0ePHt3/maL9+/c/RzNU8++yrLaILctwhmAiZQt3o2zY7U112gw2r72bJTtWbVlRN1su8/VHH/25xxNo/kldGSH9faRZIuS0ISaiTkm0+qx5KZHGclay4++r6qc0MpSxUfqYfoQ041HWxLnlhaUr6+LA8PDWX/d3Yh3X+mHvxCBnDrTUw9JbRkZGHna7U8SMgtx7c0vdHKhJEObUE4vr47HHFg/O+OLiqcX184Rc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"> <p><a class="reference internal" href="../../auto_examples/text/plot_document_clustering.html#sphx-glr-auto-examples-text-plot-document-clustering-py"><span class="std std-ref">Clustering text documents using k-means</span></a></p>  </div>
<div class="sphx-glr-thumbcontainer" tooltip="In this example we illustrate text vectorization, which is the process of representing non-numerical input data (such as dictionaries or text documents) as vectors of real numbers.">
<img alt="" src="data:image/png;base64,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"> <p><a class="reference internal" href="../../auto_examples/text/plot_hashing_vs_dict_vectorizer.html#sphx-glr-auto-examples-text-plot-hashing-vs-dict-vectorizer-py"><span class="std std-ref">FeatureHasher and DictVectorizer Comparison</span></a></p>  </div>
</div></section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2025 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.6/modules/generated/sklearn.feature_extraction.text.HashingVectorizer.html" class="_attribution-link">https://scikit-learn.org/1.6/modules/generated/sklearn.feature_extraction.text.HashingVectorizer.html</a>
  </p>
</div>
