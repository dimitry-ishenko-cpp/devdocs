<div class="sphx-glr-download-link-note admonition note"> <p class="admonition-title">Note</p> <p>Click <a class="reference internal" href="#sphx-glr-download-auto-examples-ensemble-plot-gradient-boosting-categorical-py"><span class="std std-ref">here</span></a> to download the full example code or to run this example in your browser via Binder</p> </div> <section class="sphx-glr-example-title" id="categorical-feature-support-in-gradient-boosting"> <h1 id="sphx-glr-auto-examples-ensemble-plot-gradient-boosting-categorical-py">Categorical Feature Support in Gradient Boosting</h1> <p>In this example, we will compare the training times and prediction performances of <a class="reference internal" href="../../modules/generated/sklearn.ensemble.histgradientboostingregressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code>HistGradientBoostingRegressor</code></a> with different encoding strategies for categorical features. In particular, we will evaluate:</p> <ul class="simple"> <li>dropping the categorical features</li> <li>using a <a class="reference internal" href="../../modules/generated/sklearn.preprocessing.onehotencoder.html#sklearn.preprocessing.OneHotEncoder" title="sklearn.preprocessing.OneHotEncoder"><code>OneHotEncoder</code></a>
</li> <li>using an <a class="reference internal" href="../../modules/generated/sklearn.preprocessing.ordinalencoder.html#sklearn.preprocessing.OrdinalEncoder" title="sklearn.preprocessing.OrdinalEncoder"><code>OrdinalEncoder</code></a> and treat categories as ordered, equidistant quantities</li> <li>using an <a class="reference internal" href="../../modules/generated/sklearn.preprocessing.ordinalencoder.html#sklearn.preprocessing.OrdinalEncoder" title="sklearn.preprocessing.OrdinalEncoder"><code>OrdinalEncoder</code></a> and rely on the <a class="reference internal" href="../../modules/ensemble.html#categorical-support-gbdt"><span class="std std-ref">native category support</span></a> of the <a class="reference internal" href="../../modules/generated/sklearn.ensemble.histgradientboostingregressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code>HistGradientBoostingRegressor</code></a> estimator.</li> </ul> <p>We will work with the Ames Lowa Housing dataset which consists of numerical and categorical features, where the housesâ€™ sales prices is the target.</p> <section id="load-ames-housing-dataset"> <h2>Load Ames Housing dataset</h2> <p>First, we load the Ames Housing data as a pandas dataframe. The features are either categorical or numerical:</p> <pre data-language="python">from sklearn.datasets import fetch_openml

X, y = fetch_openml(data_id=42165, as_frame=True, return_X_y=True)

# Select only a subset of features of X to make the example faster to run
categorical_columns_subset = [
    "BldgType",
    "GarageFinish",
    "LotConfig",
    "Functional",
    "MasVnrType",
    "HouseStyle",
    "FireplaceQu",
    "ExterCond",
    "ExterQual",
    "PoolQC",
]

numerical_columns_subset = [
    "3SsnPorch",
    "Fireplaces",
    "BsmtHalfBath",
    "HalfBath",
    "GarageCars",
    "TotRmsAbvGrd",
    "BsmtFinSF1",
    "BsmtFinSF2",
    "GrLivArea",
    "ScreenPorch",
]

X = X[categorical_columns_subset + numerical_columns_subset]
X[categorical_columns_subset] = X[categorical_columns_subset].astype("category")

n_categorical_features = X.select_dtypes(include="category").shape[1]
n_numerical_features = X.select_dtypes(include="number").shape[1]

print(f"Number of samples: {X.shape[0]}")
print(f"Number of features: {X.shape[1]}")
print(f"Number of categorical features: {n_categorical_features}")
print(f"Number of numerical features: {n_numerical_features}")
</pre> <pre data-language="none">Number of samples: 1460
Number of features: 20
Number of categorical features: 10
Number of numerical features: 10
</pre> </section> <section id="gradient-boosting-estimator-with-dropped-categorical-features"> <h2>Gradient boosting estimator with dropped categorical features</h2> <p>As a baseline, we create an estimator where the categorical features are dropped:</p> <pre data-language="python">from sklearn.ensemble import HistGradientBoostingRegressor
from sklearn.pipeline import make_pipeline
from sklearn.compose import make_column_transformer
from sklearn.compose import make_column_selector

dropper = make_column_transformer(
    ("drop", make_column_selector(dtype_include="category")), remainder="passthrough"
)
hist_dropped = make_pipeline(dropper, HistGradientBoostingRegressor(random_state=42))
</pre> </section> <section id="gradient-boosting-estimator-with-one-hot-encoding"> <h2>Gradient boosting estimator with one-hot encoding</h2> <p>Next, we create a pipeline that will one-hot encode the categorical features and let the rest of the numerical data to passthrough:</p> <pre data-language="python">from sklearn.preprocessing import OneHotEncoder

one_hot_encoder = make_column_transformer(
    (
        OneHotEncoder(sparse=False, handle_unknown="ignore"),
        make_column_selector(dtype_include="category"),
    ),
    remainder="passthrough",
)

hist_one_hot = make_pipeline(
    one_hot_encoder, HistGradientBoostingRegressor(random_state=42)
)
</pre> </section> <section id="gradient-boosting-estimator-with-ordinal-encoding"> <h2>Gradient boosting estimator with ordinal encoding</h2> <p>Next, we create a pipeline that will treat categorical features as if they were ordered quantities, i.e. the categories will be encoded as 0, 1, 2, etc., and treated as continuous features.</p> <pre data-language="python">from sklearn.preprocessing import OrdinalEncoder
import numpy as np

ordinal_encoder = make_column_transformer(
    (
        OrdinalEncoder(handle_unknown="use_encoded_value", unknown_value=np.nan),
        make_column_selector(dtype_include="category"),
    ),
    remainder="passthrough",
)

hist_ordinal = make_pipeline(
    ordinal_encoder, HistGradientBoostingRegressor(random_state=42)
)
</pre> </section> <section id="gradient-boosting-estimator-with-native-categorical-support"> <h2>Gradient boosting estimator with native categorical support</h2> <p>We now create a <a class="reference internal" href="../../modules/generated/sklearn.ensemble.histgradientboostingregressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code>HistGradientBoostingRegressor</code></a> estimator that will natively handle categorical features. This estimator will not treat categorical features as ordered quantities.</p> <p>Since the <a class="reference internal" href="../../modules/generated/sklearn.ensemble.histgradientboostingregressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code>HistGradientBoostingRegressor</code></a> requires category values to be encoded in <code>[0, n_unique_categories - 1]</code>, we still rely on an <a class="reference internal" href="../../modules/generated/sklearn.preprocessing.ordinalencoder.html#sklearn.preprocessing.OrdinalEncoder" title="sklearn.preprocessing.OrdinalEncoder"><code>OrdinalEncoder</code></a> to pre-process the data.</p> <p>The main difference between this pipeline and the previous one is that in this one, we let the <a class="reference internal" href="../../modules/generated/sklearn.ensemble.histgradientboostingregressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code>HistGradientBoostingRegressor</code></a> know which features are categorical.</p> <pre data-language="python"># The ordinal encoder will first output the categorical features, and then the
# continuous (passed-through) features

categorical_mask = [True] * n_categorical_features + [False] * n_numerical_features
hist_native = make_pipeline(
    ordinal_encoder,
    HistGradientBoostingRegressor(
        random_state=42, categorical_features=categorical_mask
    ),
)
</pre> </section> <section id="model-comparison"> <h2>Model comparison</h2> <p>Finally, we evaluate the models using cross validation. Here we compare the models performance in terms of <a class="reference internal" href="../../modules/generated/sklearn.metrics.mean_absolute_percentage_error.html#sklearn.metrics.mean_absolute_percentage_error" title="sklearn.metrics.mean_absolute_percentage_error"><code>mean_absolute_percentage_error</code></a> and fit times.</p> <pre data-language="python">from sklearn.model_selection import cross_validate
import matplotlib.pyplot as plt

scoring = "neg_mean_absolute_percentage_error"
n_cv_folds = 3

dropped_result = cross_validate(hist_dropped, X, y, cv=n_cv_folds, scoring=scoring)
one_hot_result = cross_validate(hist_one_hot, X, y, cv=n_cv_folds, scoring=scoring)
ordinal_result = cross_validate(hist_ordinal, X, y, cv=n_cv_folds, scoring=scoring)
native_result = cross_validate(hist_native, X, y, cv=n_cv_folds, scoring=scoring)


def plot_results(figure_title):
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 8))

    plot_info = [
        ("fit_time", "Fit times (s)", ax1, None),
        ("test_score", "Mean Absolute Percentage Error", ax2, None),
    ]

    x, width = np.arange(4), 0.9
    for key, title, ax, y_limit in plot_info:
        items = [
            dropped_result[key],
            one_hot_result[key],
            ordinal_result[key],
            native_result[key],
        ]

        mape_cv_mean = [np.mean(np.abs(item)) for item in items]
        mape_cv_std = [np.std(item) for item in items]

        ax.bar(
            x=x,
            height=mape_cv_mean,
            width=width,
            yerr=mape_cv_std,
            color=["C0", "C1", "C2", "C3"],
        )
        ax.set(
            xlabel="Model",
            title=title,
            xticks=x,
            xticklabels=["Dropped", "One Hot", "Ordinal", "Native"],
            ylim=y_limit,
        )
    fig.suptitle(figure_title)


plot_results("Gradient Boosting on Ames Housing")
</pre> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABLAAAAMgCAMAAAAEPmswAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8qNh9FAAAAUVBMVEX///8MDAwdHR3c3Nz/fw7x8fEAAADWJygsoCwfd7ReXl7Ly8srKyttbW2srKycnJw8PDy+vr59fX1NTU2Li4vn5+f6+vryeA0plynLJCUdcKrsWjdgAAAgAElEQVR42uyb3ZKkKBBGBUMukB8B9f0fdTMTVKy2e6Z3a2M6Yr5zsTtTKlAFHjMTZxgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOA/MFutlPbz52dkQ//R9rPr89SdSeiSftXnluez4X9JMf57Fyyudm3yr8789KsCAP4w0bg1pbiY8WthzZ8dX7srs0nzHJyZfyVJE0Ue878e9maM2v8nYc0jlgUAP5JkSr3vw9Y+mZ6F9Sl3YXEr4y+d0IT1H1hNMeF/EhYA4IdSzHb9xaq5qGVIRVOOKJ9TtKTXKyWcvDbas9KMj0650LJAk3phVSeMVlPwNhxXZfZiWCj7tGRJJrdcsyRqSQSWFqVzvATIpy+ztDtaurBzqdMbjVQixGSVstNWaMzcx56dUXarzSldpidh0fesfdbeEn+BudAwy1a/ajIha7XIUFatXFoWLBYA/jC76u9DS3ZKaYhrSNG5nW/bJYRFH8KanFrTKpcYvYTEeeTmTZjn6RTWvpNbSDKb1jF5LjTtfFU2hQMrS9mnHaZo8jxvTVjaxVTEGGTAQNY4hBVMCWTMxO26TB3bLkTzNNpRjKN9Wo2lE7JhPxaVU9Q0+lGVkIK9hLUzIqxR6Rgsn34Ja1L0jYIfD2FpGwI3Q517alBDWAD8aTYjEuA7WYR1Zmr7yBnXounjSR3CWqU4FVghRk989fqaEjIqyB/5XE8Ho+RuK121mumWElZhqZHF6Vk1HBe5o71dc0w0sSmqirzq1DqSU7IIy0ugyCc4x6MLrYNwL6UtppE5lNxEbVMnrPlMMauwinzVmb6+lQYhLAB+iLAc3ccra0CEslEKJx9MdSfOHsKqQcrEt3y9TvunortUl2oGxuKw6kjFyAK1VHYTlphgKZwc1g9be6NIiJw3tc/imb5OEuVpXVPC8yLuySoJpGi4o1liVz5f9MyI5mpPbN4+wnLt9CqsKEMInBwO5zABAH8+JRznIMJSrT60knfoxm4F6rOGpVuMYrmGNZxh12vRnRo4bnBuYdFyjK8KizJc+LoJS+TBJaIqwbOGlY6TttbuVd2KZp2mKbOropnPjnn8RyBF7aWiKMcdHmpYtSfuoK9hWVVLba2GJcKKzYgDalgA/HmOovt4CWtuwUV+iLAkSOFt/y+FxY0+RVhsyFTIMM/C+irCugvrsFL5KCyrzjFSb7M9E71eWFeEFaTN0HYNZs993oWFCAuAH8PxWsNNWEE8kT/UsLI63fSVsHan9sca1lm/ehbWVzWsm7BGUxKz0Mevwor3ytV0vl/aC+uqYdUva4/BDaq8Cgs1LAB+DvXF0VBYIVVYu9Yhecc39oddQt5FjGXuhZWM73YJaw3LP+8SZhtT4K3FSS3p3CU8hfW4S7jUXcKbsHyTEuexr8KSXcIUbRhiialuP34Q1qhcTLJLuDv+sppjLT7d889wFxZ2CQH4QdR/mmPTcNawxqJUqSnc63tY/I6T41e0LmENWXfvYfEm4SLh02jV63tYQd50SrXd6z2ss0TE72H5cyvx9h5WL6waerU/fBDWvjpFYxz5vSq6PDzVsPg9LFPf/Rr5/S1OCUf+HWToL8LiL+iCK1gqAIAPVTX3E0fVCmoAANDwseWmPysEzYFSQrVhfgAAvbB0+wczPyu4WpRRBf8gGgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8CeIRvCjicMw5+k8ELL8T9tvNbf47i/Z4fd92yylOh1m+f2rnFnrPJjti7NeZjisTydlXiTaT98deL+ifkGuK9GMmG7w1a0QZ2LcZ1rUa7davKkr7lvrJ6j+1phUxA/8pllSopVk1O8LazbGfV9YRT/bJM3Jf8eWlfX3/cNdMDumG3x1K8zPy6sJ63ss98XvEWK9a5as4lDFLu73neFNqZP7FmFxE7bFeR37G4V1G+VeW56+2SH4S4TFKWENyuuatC085+WcTMhalW2ySllZQdEpVXgpzkUbXbbzmR54SXmtlAvy94Rf+D2zlDhapZBVhLVnRyEX/+qhaOUk7bJqLEr7637elRuNrSqYi6rnp0UpXej8ydPE5b0JK4pXEk3XIvPed9HZJNL8Xgd0CU7lYbNtCUiTkjUaTwuEV8Cxoq5h0tIxLlg9fNJFXYtr1ibJsDWddjTbOgR/ubB2QoS1eRPmuT7TRno6c3hehaVtimopPq3Gi818Ck5vdActIQU/nmuOL/ZqTWFd5Z7x+IXfNEuWTBXVJMIqKqeoHekmr4H+tMicuJXu8et+DjSji8RlmW74tCo6f1SF5oseOrtTfHb5IKxx0TTvfRedTTydcB3QWsc0b5qn247DxE2ukrIaTctioTaPFXUNM5oSaOno4amLXZYirUW+fqRh5xSGYnIdfOsQq+EvvxWEXYruDylhFVaRD7ysMg6c2EYbPexqSHWlE5ICunKliAt+4TcJK9HcUMbNwgqmhq+tQrgnjpKtfFiuJJxlFeWcLDPHAgtHASDK2StHwHdhtZTwpQuxyRSV3rsDWi6yx5pZpe3AbRhNntx4lXQrqg5TrEVGeupC0HJ4lw+yDGptg28dgr/8VpCi+/C1sGJNS1oQ1Z6FZKNJudgtolpgsfTk3L8qiIB/k7hrzxk2/8RWSSjCUzNSPkYEFofc5Go48yrLOeRSU0IWBn0wmqXOl5XzNlbCo7C6LjqbLGN/QIsc9fF4WhwfmLjJmolqf66oc5hj3bhc9FMXtejOQ/fDOeyWKaqzQ4AaVqthfS6scJ7J68ea82E4W9VKIVdsNXFtonT3BXjHLGXNexgsrKX9/vTAkCRJwo/6U2dzlYTCNE0S/7R7ntWSCs3XWo0xVLM8CuvqorPJdj9QVWUO4eh2xHIN61g6dUVdw6zPvoFrWB+76GpY1we2rcOlcyOAsL4jrONZWK+cvVlfM8At1qdhwTPxbbO0Gf6da4RVf/6xJmDVAq/COvzh+wiL/zdz8vgSYQWZ+NBHWEcXLzbpDlR/dBHWeeRVWNcwbxHWJ13chdVHWBAW+EJY+2fCSvfK1aCOhdQFVF7q7w5L7H2zlHkrjoV1vYpSa1LlQVjJ+MQ4vXc1LGGiv77UsGot0l7Cur3t0tukO1D9cdawsjoXz0dhncO8alifdnEXVl/DwmoCN2HRKj92CelAvnYJ78IavPK8ORiHUGJK/qyb1sxiyYH3FIdWdwXvm6VWJuT9tRRtGDblQrDuQVil3f4rzd21Sxh5vgp56WWXcHf/sHcvym0bSRRAMcBiksWbIEEn+f8PXQxIig/ZtZRDO6P43Kq4KEolOd3oYww4hMph15cJrDld1CyObz/iUZPrJ05+LGV5eZVwfbAb9+0tWKcj6uav+fAq4d2POJ231/dg3b5KCCy5A6uYy8s+rOKYrpNWXwerGNN2nqZNF1NDmN72s9chHWlz+mR/2rezqPAPAOt46ELo0m6Sdkp9eA/WEveXluxv9mG1+9Sv1M37fVjFtodrW7nV+7Dtw3r7EQ9gXT9x9mPbh5W++XbtskuNv4J1PqKuf81iLGM3bpcK3v2IeN61dQ9WfbMPy5EgL83D1vapURJ5n7p0YEgOWcLt1a1dsG9GHo6QftiNnQND8shw+3bnYVAQeTi52pcx7G1XFxERERERERERke/IcanlE2TReq2XtHtPPkUWrdd6Kero39nP8K9srLVe62U9apXjF22T1ptQ5RBgiTYphzZpvdaLcgBLTKhyCLBEm5RDm7Re65VDgCUmVDkEWKJNyqFNWq/1yiHAEhOqHAIs0Sbl0Cat13rlEGCJCVUOAZZok3Jok9ZrvXIIsMSEKocAS7RJObRJ67VeOQRYYkKVQ4Al2qQc2qT1Wq8cAiwxocohwBJtUg5t0nqtVw4BlphQ5RBgiTYphzZpvQlVjh/4F9SwLMHSGBOqHOYCWAIsYGkTsLReOYAFLAGWcpgLYAmwgKVNwDKhygGsnNo0lqHbnR4uTRf70/fo12cHYJlQ5QBWVm0a4lj1odoeV/3YbWAdp/2u2rXAMqHKAays2jQlobr57sP1rOtoSWhCleO78p+n8yXGL89/tTalc6mYFn79dA/WvmnK7nAElglVDmDl1KYlpoXfobsHqwtNO4TzadexrusFWCZUOYCVCVjzI1hpSXgoT0/NMQVYJlQ5gJXnknBKH+/i0RmWCVUOYOXUpq9edJ/TydXlDOsFrQcWsIAFrFe06bKtYW7WD9q2a9pqXSiGvhrKGVgmVDmAlVebxjKmjaNNWgVuV6vSiVU7hfL/vUr43+fzV4x/Pf/VJg1YwALWq78nsEyocvwtsD4WbQKW1n/S3LyhbDeF0B3Sc9sC4QgsRy2wgJVVbt9Q1g5VNYZxBSssa5xhOWqBBay88vDadnpvRgLLktBRCyxgZZfH3YNFW6YzrFiW+8s79l+wexBYwAIWsF6QhzeUlTGmk612bHf78zrxFe/PABawgAWsl4H19oayqh3D5eZtp/sjOcMCFrCAle2S8IpXs3cNy1ELLGBllXcX3efL+8imBliOWmABK6vcvqFs3LY1rHjNu6ptYgssRy2wgJVXbt5QduhC6Ma0RCzj9VVCYAELWMBSDmABC1jAAhawgGVClQNYwPowWB+LSQMWsIAFLBOqHMACFrCApRzAApYAC1jAApbWKwewgAUsYCkHsIAlwAKWNgFL65UDWMACFrCABSxgCbCApU3A0nrlABawgAUsYAELWAIsYGkTsLReOYAFLGABC1jAApYAC1jaBCytVw5gAQtYwAIWsIAlwAKWNgHLhCoHsIAFLGABC1jAMqECLGABy4QqB7CABSxgAQtYwDKhygEsYAHLhCoHsIAFLGABC1jAMqHKASxgAcuEKgewgCXAAhawgGVClQNYwAIWsJQDWMASYAELWMDSeuUAFrCABSzlABawBFjA0iZgab1yAAtYwAIWsIAFLAEWsLQJWFqvHMACFrCABSxgAUuABSxtApbWKwewgAUsYAELWMASYAFLm4Cl9coBLGABC1jAAhawBFjA+ve3aSxDtzs9XJou9uenh7gHlglVDmDl1aYhjlUfqu1x1Y/dGayqnIBlQpUDWJm1aUpCdfPdh0VxnMYGWCZUOYCVV5uOcVj/7KcHsOZ9ASwTqhzAyqxNS2zXPw/dPVi7crmCdazregGWCVUOYGUC1nwPVl3uiitYc0wBlglVDmBluSRs4ymVMywTqhzAyqlNX7vofmyrttpP7dE1LBOqHMDKqU2XbQ1zk06t2q5pT+dVLrqbUOUAVn5tGsuYNo42aVW4LQRLYJlQ5QDWZ24TsEyocgALWMACFrCABSwTKsACFrBMqHIAC1jAAhawgAUsE6ocwAIWsEyocgALWMACFrCABSwTqhzAAhawgPXzc3Nj790UQndIj4YudgOwHLXAAlZeub2xdztU1RjGdJORQ3XYbpcELGABC1j55OEeI0Wxb9b/9ucHwAIWsICVTx7v4la05XqGVaZ14aEElqMWWMDKKQ839i5jTCdbm2JDPJv2jdtOAgtYwALWPwHW2429q3YMwxmsMZye+9aNvYEFLGAB6x9eEm543S0JnWEBC1jAyiTvLrrP5fmWky66O2qBBazMcntj73Hb1rDitbOtwVELLGDlmJsbex+6ELpxY8zGUUctsIClHMAC1mvBqqNZBRawtAlYn8hEYAFLm4AFLJMALGABC1jAAhawgCXAAhawgAUsYAELWMACFrCABSxgAQtYwDKhwAIWsH5xsP72TwAWsLQJWMAyCcACFrCABSxgAQtYAixgAQtYwAIWsIAFLGABC1jAAhawgPXTwHq+mV9i/PKDew8skwAsYAELWMACFrCe6/3vT+ePGP94/quBBSxgAQtYwAKWNgELWCYBWMACFrCABSxgAQtYwNImYAHLJAALWMACFrCABSxgAQtY2gSsV4H129P5M8Y/n//q34AFLG0CFrBMArCABSxgAQtYwAIWsIClTcAClkkAFrCABSxgAevXBuu7ew8sYAELWMACFrCABSxgAQtY2gQsYJkEYAHr3wPWxwIsYAELWMACFrC0CVjAMgnAAhawgAUsYAELWMACljYBC1gmAVgZt2ksQ7c7PVyaLvbbc1MIUwusnwzWBwMsYP16bRriWPWh2h5X/dhtYDVjWzVhARawgAWsrNo0JaG6+e7DLccwAgtYwAJWTm06xmH9s5/eg1WHAVjAAhawcmrTEtOlqkP3Hqy+PJ5Nq+t6ARawgAWsTMCa34N1CJeL7nNMARawgAWsXJeEV6+cYQELWMDK+6L7jVeuYQELWMDKpU2XbQ1zs37Qtl3TVqtXcViWpQYWsIAFrLzaNJYxbRxt0qpwu1pVFkW5PZiBBSxgAesTtglYwDIJwAIWsIAFLGABC1gCLGABC1jAAhawgAUsYAELWMACFrCABSxgAQtYwAIWsIAFLGABC1jAAhawgAUsYAELWMACFrCABSxgAQtYwAIWsIAFLGABC1jAAhawgAUsYAELWMACFrCABSxgaROwgGUSgAUsYAHrB2UsQ7qxd8owhTClx+N2Y+8jsIAFLGBllcuvTknpD201p1+vOYZljTMsYAELWHnl4ZfTnR6PwZIQWMACVnZ5/PW/RVEe0pKwLPeX36f5rV//CyxgAQtYPzdLWgEWh+7tiUNYl4Lt2O7253ViMW8XtIAFLGABKw+w5jewhrB7Wxv2zrCABSxgZbwkHMLw9qlm7xoWsIAFrHwvut96VUwNsIAFLGBllcu2hrnZHi/Lsv6Pz7uqbWILLGABC1h5ZSxj2jjarKvCabu8vsrVl/H6KiGwgAUsYP3ykwAsYAELWMACFrCABSxgAQtYwAIWsIAFLGABC1jAAhawgAUsYAELWMACFrCABSxgAQtYwAIWsIAFLGABC1jAAhawgAUsYAELWMACFrCABSxgAQtYwNImYAELWMACFrCABSxgAQtYwAKWNgELWCYBWMACFrCABSxgAQtYwNImYAHLJAALWMACFrCABSxgAQtY2gQsYJkEYAELWMACFrCABSxgAUubgAUskwAsYAELWMACFrCAJcACFrCABSxgAQtYwAIWsIAFLGABC1jAAhawgAUsYP2PvXtdkRtHwwDsA9YPWz6WbWbm/i90Lbk7XTUbltmw9Ko7zwcxKpMEku/lwVKrLGABC1j/seamjus9PPoYxjyaYogTsIAFLGCV1aYpzO1Yt3ncjnPMYA1hb/cwAAtYwAJWUW1aklBxe/lYPR7p0gMLWMACVkltOkOa+Y3LK1jNfl32BljAAhawSmrTkSd+e3wFKys2hTfTuq47gAUsYAGrELC2n4E11/etLaQCFrCA9fuA9c9j+GcIf35eav/BlNATFrCABaxCUvvTRffeojuwgAWsAlP7vq1hSzwNQ+yHtqpW2xqABSxglZjauQlp42ifZoV5tSrNBG0cBRawgPVlUwssYAELWMACFrCABSxgAUsBC1jAAhawgAUsYAELWMACFrCABSxgAQtYwAIWsIAFLGABC1jAAhawgAUsYAELWMACFrCABSxgAQtYwAIWsIAFLGABC1jAAhawgAUsYAELWMACFrCABSxgAQtY/+3/wa/9JwALWMAC1qeH9o8Q/vgNUwssYAELWMACFrCAVUpogQUsYAELWMACFrCAJbXA0npgAQtYwAIWsIAFLGABC1hSCyytBxawgAUsYAELWMAC1u8E1tzUcb2H01LXSx5PMcQJWFILLGCVVVOY27Fu83jch3YLQ1UNYW/3NAAWsIAFrIJqGa9L3D5upPHjcQ0ePbCkFljAKqnOkGZ+4/Jxp9nvX9XevP2WrusOYAELWMD6v9eRJ357/HFjr4+qyopN4b6zhVTAAhawgFUGWNsPsKY6LbpnsObaE5bUAgtYBU8Jp3p6nxb+mBJawwIWsIBV4qL7m1dVb9FdaoEFrIK3NWx9Hh/Hcf3DV9sapBZYwCqx5iakjaP9NStc8vJ6erCycVRqgQWsL1vAAhawgAUsYAELWMACFrCABSxgAQtYwAIWsIAFLGABC1jAAhawgAUsYAELWMACFrCABSxgAQtYwAIWsIAFLGABC1jAAhawgAUsYAELWMACFrCABSxgAQtYwAIWsICl9cACFrCABSxgAQtYwAIWsKQWWFoPLGABC1jAAhawgAUsYAFLaoGl9cACFrCABSxgAQtYwAIWsKQWWMACFrBKSu3c1OkM3VxrrJs5DfZrMJ7AAhawgFVUaqcwt2Pd5nFbj+0cpguxemrXZgQWsIAFrKJSuySW4pbHW7wu43L/ui/AAhawgFVMas/0QPVuU8ZrCmc11UPVxh1YwAIWsEpK7RGGvGSVP2SihnBcN0II7zPCs+u6A1jAAhawCgFrewJrvcBam3mYmnueWG0hFbCABSxglTklzIO59oQFLGABq/xF9/x5qk9rWMACFrBK3Naw9U/bGra8raG36A4sYAGrtI2jIW0c7dOscI0hbxw9t6Zuxg5YwAIWsHw1B1jAAhawgAUsTAFLaoEFLGABC1jAAhawgAUsYClgAQtYwPptwOrCr/15YAELWMD69NT+FcJfJaUWWMACFrC+TGqBBSxgAQtYwAIWsIAFLGABC1jAAhawtB5YwAIWsIAFLGABC1jAApbUAkvrgQUsYAELWMACFrCABSxgSS2wtB5YwAIWsIAFLGABC1jAApbUAgtYwAIWsIAFLGABC1jAUsACFrCABSxgAQtYwAIWsLQeWMACFrCABSxgAQtYwAKW1AJL64EFLGABC1jAAhawgAUsYEktsLQeWMACFrCABSxgAQtYwAKW1AILWMACFrCABSxgfU7NTR3Xe3j0MYz5Xkh1AktqgQWsomoKczvWbR634xxvsOrjKk9YUgssYJVVSxIqbi8fL7BMCaUWWMAqrs4wXddx+RtYoWkeA7CkFljAKqqOkFza4ytYwzysj7d5YnV2XXcAC1jAAlYhYG1/AytXfBtueQUeWMACFrDKnBLm6h+esKQWWMAqf9H9HvbWsKQWWMAqclvDlngahtgP7TULXNuhDwOwpBZYwCpt42hIG0f7NCvMq1XNNUVsgp8SSi2wgPVFC1jAAhawgAUsYAELWFILLK0HFrCABSxgAQtYwAIWsIAltcDSemABC1jAAhawgAUsYAELWFILLK0HFrCABSxgAQtYwAIWsIAltcACFrCABSxgAQtYwAIWsIAFLGABC1haDyxgAQtYwAIWsP63qX069LtaY93M+e8Yr7sTsIAFLGAVldqXQ7/rsZ3TgSTn8ljbdQAWsIAFrKJS+3z+SD7oLR2eNDenKSGwgAWs0lL7csJbxmsKZ/Xo+ybuJ7CABSxglZTal0O/435dhnBUse6HqX479u0bHkkJLGAB6wuDtT2BtSaw0pRwb+7f8g0P/QYWsID1jaaEy5LlOj1hAQtYwCp+0X1LD1fvT1jWsIAFLGAVtq0hHfr9Y1vDcQ2mZgMWsIAFrNI2jn4c+r3GcG8cHZa68VNCYAELWL6aAyxgAQtYwAIWsIAltcACFrCABSxgAQtYwAIWsBSwgAUsYAELWMACFrCABSytBxawgAUsYAELWMACFrCAJbXA0npgAQtYwAIWsIAFLGABC1hSCyytBxawgAUsYAELWMACFrCAJbXAAhawgAUsYAELWMACFrCABSxgAQtYWg8sYAELWMACFrCABSxgAUtqgaX1wAIWsIAFLGABC1jAAhawpBZYWg8sYAELWMACFrCABSxgAUtqgaX1wAIWsIAFLGABC1jAAhawpBZYwAIWsIAFLGABC1jAApYCFrCABSxgAQtYwAIWsICl9cACFrCABSxgAQtYwAIWsKQWWFoPLGABC1jAAhawgAUsYAFLaoGl9cACFrCABSxgAQtYwAIWsP695qaO6z08+hjGPJpiiBOwpBZYwCqrpjC3Y93mcTvOMYM1hL3dwwAsqQUWsIqqJQkVt5ePVf+4Lo8eWFILLGCVVGdIM79xeQWr2a/L3gBLaoEFrJLqyBO/Pb6ClRWbwptpXdcdwAIWsIBVCFjbz8Ca6/vWFlIBC1jAAtYXmBJ6wgIWsIBl0R1YwAIWsH5tW8OWeBqG2A9tVa22NUgtsIBV5sbRkDaO9mlWmFerGhtHpRZYWv+VC1jAAhawgAUsYAELWFILLK0HFrCABSxgAQtYwAIWsIAltcDSemABC1jAAhawgAWsT0vt07sbqzXWzXwPp/AAFrCABayyUvvy7sZ6bOf8vdKqbRZgAQtYwCostc9fI83v68jfgT+XuQcWsIAFrLJS+/KijozXFM6LrkcFLGABC1iFpfbl3Y0xvVBoCEe1NscHWN/wzULAAhawvjBY2xNYazi6Zq0+wPqG724EFrCA9X2mhEO4q/WEBSxgAav0RfdzaIf2sQynNSxgAQtYJW5rSO9ufNrWUFl0BxawgFXixtGPdzeuMbxvHAUWsIAFLF/NARawgAUsYAELWMCSWmABC1jAAhawgAUsYAELWApYwAIWsIAFLGABC1jAApbWAwtYwAIWsIAFLGABC1jAklpgaT2wgAUsYAELWMACFrCABSypBZbWAwtYwAIWsIAFLGABC1jAklpgAQtYwAIWsIAFLGABC1jAAhawgAUsrQcWsIAFLGABC1jAAhawgCW1wNJ6YAELWMACFrCABSxgAQtYUgssrQcWsIAFLGABC1jAAhawgCW1wNJ6YAELWMACFrCABSxgAQtYUgssYAELWMACFrCABSxgAUsBC1jAAhawgAUsYAELWMDSemABC1jAAhawgAUsYAELWFILLK0HFrCABSxgAQtYwAIWsIAltcDSemABC8nkXW4AAAmZSURBVFjAAhawgAUsYAELWFILLGABC1jAAhawgAUsYAELWMACFrCApfXAAhawgAUsYP2rnXtbbhRJoyhMkgEXHAUIembe/0EnE6SyXOXuCNulaln+1oVCkhUg9G8vyANJWIRFWIRFWFJLWEpPWIRFWIRFWIRFWIRFWN9YWGMZuunyfOpCOeb36sxGWFJLWIT1UAz1GPsQ9+cx9HGshySssCZcYUktYRHWY3Hq00M378/nLj30pywsTUKpJSzCeji2fEG1S+oqryE1Bce6LJf2+pGqqlbCIizCIqx/nbXOXjp3+4vunB7aei3asZ2WSzuxmPcOLcIiLMIirMcQ1nwjrKm+dF51vSssqSUswnr8JuFOs+jDklrCIqzH73Q//tIQltQSFmE95LSGubmZ1jBPsW3qlrCeO7VvTsE7hXBqCYuwHnfiaJ1T25z21NZ7avuyfhklJKwnTe2bU/CasY1NWAmLsL4yhPWEqf3b3oAtjIRFWIRFWI+U2r8fb6nCQFiERViE9UipfXsKXrH3CGxPO6OFsAiLsL6wsN6YgncO1+7LJ5wzTFiERVhP1SR88ZUrLMIiLMJ67E73G1/pwyIswiKsR5vW8GoK3rke1nWtCIuwCIuwHm3i6K9T8Mq922omLMIiLMJyaw5hERZhERZhERZNEZbUEhZhERZhERZhERZhEZbSExYIi7AIi7AIi7AIi7AIS2oJS+kJi7AIi7AIi7AIi7AIi7AIS2oJS+kJi7AIi7AIi7AIi7AIi7AIS2oJS+kJi7AIi7AIi7AIi7AIi7AIS2oJi7AIi7AIi7AIi7AIi7AIi7AIi7AIi7CUnrAIi7AIi7AIi7AIi7AIi7CklrCUnrAIi7AIi7AIi7AIi7AIi7CklrCUnrAIi7AIi7AIi7AIi7AIi7CklrCUnrAIi7AIi7AIi7AIi7BAWFJLWIRFWIRFWIRFWIRFWEpPWCAswiIswiIswiIswiIsqSUspScswiIswiIswiIswiIswiIsqSUspScswiIswiIswiIswiIswiIsqSUspScswiIswiIswiIswiIswiIsqSUswiIswiIswiIswiIswiIswiIswiIswlJ6wiIswiIswiIswiIswiIswpJawlJ6wiIswiIswiIswiIswiIswpJawlJ6wiIswiIswiIswiIswiIswpJawiIswiIswiIswiIswiIswgJhERZhERZhERZhERZhERZhKT1hPTNjGbrp8nzqQjnmJ0NXdwNhPXlqv2PpCeuLM9Rj7EPcn8fQx7FOaW3rczzXLWE9dWq/ZekJ64tz6tNDN+/P5y499KeiaJb0ZGkI66lT+y1LT1hfmy2fVfekXhM81FtRntOTc3n5SFVVa71WP/O/e/Gyi7/uxMse/nMvXnbx33vxS0VSmSql/9dr//il/8Ks+9X/udtfdDmsbb0We5SH+vjIXOPLsCq90j+/sOYjtfvZdbqmdgwvp9kqVp/irdP07+X+e/gKB7EqvdJ/9ybhvcbG7z/6/uV28Uc7IpT+25b++TvdFfwJU6v0hPV1pzXMzc3Y9vTz2LaCP2FqlZ6wviBjWefZg01uGkxd/fbswU83P+bt3g2cu+/hOQ5C6ZUeAAAAAAAAwDOzD64/Pnku5WWS5Wum3zu8M32j0SKl/7alfwSauq7L03jf1K5NWZf9387qjceA/O02r7O2P7mXvJk3ZxN/NGZNnadoXm+C+fGtt1XplR5/IrXLurbnsBzDs9tdUhvL0xSnrqvumtrXe9n+eTMfTm0I1RupVXqlxx9K7VHEsajHJcz7LJ980s2vyiEnajgdC8bF9EaTTidVE8rzu2q1lDlDa+jz3W/NseTcmuq/xF9SWx1vT/m+0Pl9R/Kyl3JuQpMXulvOl3ZBs5zL0G95vtJxEB9O7dL1e2rTOT3kmU/5MqWOaXNVyD/SkEJ9e2hKr/T4/aktuqWoyzHGPI/6XKffvw5jnOuYElUOsQlrisMc2+VUFH05tUt4R2qr/Vo6n6JSakPefiyqrmlj020/p3bp0sbLbTuHdX1frm72UoZzjPuaduGa2tDHIaT/lnGK7Wn5TGqH9Fvk1J7bfW55dWrWdcub2++MSQ+vDk3plR53SG3TFXUO4mn/6dN7x6s+JSqFYSvPxZw/uNaxyreCVO9JbVsfc7DP9VqUefvpPDvm7tAtTJfUhkzdH/ldw/CBdsHNXsrlemDNNbX5FHy9165NEft4avNPdG0XLP2lXZA3l8+wVf7qt4em9EqPO6R2SanNl+v5VLTf9r+/6k8pR9Nx9lj2aNVTW+dL3u6jqc3nwm4u+mNr4yW1Q0yk+ueVB/a/fy61c3G5P/ilXXAcTZHO4Wm38TOpnep0MVJsc5c2tNykdsuJTf8drw5N6ZUed2oXDP+c2iUnK1bvT+16uWLvQ/GS2tOxtZ/aBZ9I7c1erjv5NbVVaKY4pd19IrXpl0ipPYexjcttavdTcF+8PjSlV3rcqed1uLYLmjfbBZem+fvbBa97Xq+pvKnqS2p/tAuG9w8V3fS8nn9pF1xSm1fnLMZPprat+/poZHTL0TY4NpfOv/nrvzo0pVd6/N7UXse2L8vsvtXz2uee13Jp49Rs7+95LWI4Tesx6nxNbdXlgejLzJlfe15TMqZ39rze7KU8Vg6+7Xm9pHat+zh0n0xt+l+o06/QxiYsedWEuF42V3Z5Cb1Xh6b0So/fmtofswePjoC3xrbr69h26PqPjG0X8ce8vh+X7HkAuGx+bhdcx7bz5f17x7Zf9rLv5Kex7UtHxlCG0/DZ1MaU2ir9PHN+FU9hH9vOOzi+8u2hKb3S409w6ce8JgpKD0gtlB6QWig9AAAAAAAAAAAAnolXc/+OuYJQeuDfpdlvayv6upFapVd6PHpqy7DlBYZKqVV6pcfDp3bJN7cN3dIUW1+GU57IOHThNObUtqdQ9pXUKj3wKKk9n4ridE6p7cspNnnV7NDHsUypbcM5tl0jtUoPPEpq1xBjWJdmX4rpWJspvT+n1DbHYkSb1Co98CCpLZZ5Tg/NsdhlXv0y92kMKbXdsRxtlFqlBx4ltUNZDm+ntt+Xo3WaVXrgYVK7leVWvNkuOF0+JLVKDzxIaouq2k+v157XmFe6PXpe+zYOvdQqPfA4qS2O9sDWh8vYdnkd287r9p6lVukBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC+AP8HYZMemlqHqfQAAAAASUVORK5CYII=" srcset="../../_images/sphx_glr_plot_gradient_boosting_categorical_001.png" alt="Gradient Boosting on Ames Housing, Fit times (s), Mean Absolute Percentage Error" class="sphx-glr-single-img"><p>We see that the model with one-hot-encoded data is by far the slowest. This is to be expected, since one-hot-encoding creates one additional feature per category value (for each categorical feature), and thus more split points need to be considered during fitting. In theory, we expect the native handling of categorical features to be slightly slower than treating categories as ordered quantities (â€˜Ordinalâ€™), since native handling requires <a class="reference internal" href="../../modules/ensemble.html#categorical-support-gbdt"><span class="std std-ref">sorting categories</span></a>. Fitting times should however be close when the number of categories is small, and this may not always be reflected in practice.</p> <p>In terms of prediction performance, dropping the categorical features leads to poorer performance. The three models that use categorical features have comparable error rates, with a slight edge for the native handling.</p> </section> <section id="limiting-the-number-of-splits"> <h2>Limiting the number of splits</h2> <p>In general, one can expect poorer predictions from one-hot-encoded data, especially when the tree depths or the number of nodes are limited: with one-hot-encoded data, one needs more split points, i.e. more depth, in order to recover an equivalent split that could be obtained in one single split point with native handling.</p> <p>This is also true when categories are treated as ordinal quantities: if categories are <code>A..F</code> and the best split is <code>ACF - BDE</code> the one-hot-encoder model will need 3 split points (one per category in the left node), and the ordinal non-native model will need 4 splits: 1 split to isolate <code>A</code>, 1 split to isolate <code>F</code>, and 2 splits to isolate <code>C</code> from <code>BCDE</code>.</p> <p>How strongly the modelsâ€™ performances differ in practice will depend on the dataset and on the flexibility of the trees.</p> <p>To see this, let us re-run the same analysis with under-fitting models where we artificially limit the total number of splits by both limiting the number of trees and the depth of each tree.</p> <pre data-language="python">for pipe in (hist_dropped, hist_one_hot, hist_ordinal, hist_native):
    pipe.set_params(
        histgradientboostingregressor__max_depth=3,
        histgradientboostingregressor__max_iter=15,
    )

dropped_result = cross_validate(hist_dropped, X, y, cv=n_cv_folds, scoring=scoring)
one_hot_result = cross_validate(hist_one_hot, X, y, cv=n_cv_folds, scoring=scoring)
ordinal_result = cross_validate(hist_ordinal, X, y, cv=n_cv_folds, scoring=scoring)
native_result = cross_validate(hist_native, X, y, cv=n_cv_folds, scoring=scoring)

plot_results("Gradient Boosting on Ames Housing (few and small trees)")

plt.show()
</pre> <img src="data:image/png;base64,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" srcset="../../_images/sphx_glr_plot_gradient_boosting_categorical_002.png" alt="Gradient Boosting on Ames Housing (few and small trees), Fit times (s), Mean Absolute Percentage Error" class="sphx-glr-single-img"><p>The results for these under-fitting models confirm our previous intuition: the native category handling strategy performs the best when the splitting budget is constrained. The two other strategies (one-hot encoding and treating categories as ordinal values) lead to error values comparable to the baseline model that just dropped the categorical features altogether.</p> <p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes 11.462 seconds)</p> <div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-auto-examples-ensemble-plot-gradient-boosting-categorical-py"> <div class="binder-badge docutils container"> <a class="reference external image-reference" href="https://mybinder.org/v2/gh/scikit-learn/scikit-learn/1.1.X?urlpath=lab/tree/notebooks/auto_examples/ensemble/plot_gradient_boosting_categorical.ipynb"><img alt="Launch binder" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTA5IiBoZWlnaHQ9IjIwIj48bGluZWFyR3JhZGllbnQgaWQ9ImIiIHgyPSIwIiB5Mj0iMTAwJSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjYmJiIiBzdG9wLW9wYWNpdHk9Ii4xIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLW9wYWNpdHk9Ii4xIi8+PC9saW5lYXJHcmFkaWVudD48Y2xpcFBhdGggaWQ9ImEiPjxyZWN0IHdpZHRoPSIxMDkiIGhlaWdodD0iMjAiIHJ4PSIzIiBmaWxsPSIjZmZmIi8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjYSkiPjxwYXRoIGZpbGw9IiM1NTUiIGQ9Ik0wIDBoNjR2MjBIMHoiLz48cGF0aCBmaWxsPSIjNTc5YWNhIiBkPSJNNjQgMGg0NXYyMEg2NHoiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMCAwaDEwOXYyMEgweiIvPjwvZz48ZyBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0iRGVqYVZ1IFNhbnMsVmVyZGFuYSxHZW5ldmEsc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMTAiPjxpbWFnZSB4PSI1IiB5PSIzIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRmtBQUFCWkNBTUFBQUJpMVhpZEFBQUI4bEJNVkVYLy8vOVhtc3JtWllIMW9sSlhtc3Ixb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEpYbXNybVpZSDFvbEwxb2xKWG1zcjFvbEpYbXNybVpZSDFvbEwxb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xMMW9sSlhtc3JtWllIMW9sTDFvbEwwbkZmMW9sSlhtc3JtWllIMW9sSlhtc3E4ZFpiMW9sSlhtc3JtWllIMW9sSlhtc3BYbXNwWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xMMW9sTGVhSVZYbXNybVpZSDFvbEwxb2xMMW9sSlhtc3JtWllIMW9sTG5hMzFYbXNyMW9sSlhtc3Ixb2xKWG1zcm1aWUgxb2xMcW9WcjFvbEpYbXNyMW9sSlhtc3JtWllIMW9sTDFvbEtrZmFQb2JYdnZpR2FiZ2FkWG1zcVRoS3VvZktIbVo0RG9ibnIxb2xKWG1zcjFvbEpYbXNwWG1zcjFvbEpYbXNyZlo0VHVoV24xb2xMMW9sSlhtc3FCaTdYMW9sSlhtc3BabXNsYm1NaGJtc2RlbXNWZmw4Wmdtc05pbThKcGs4RjBtN1I0bTdGNW5MQjZqYmg3amJpRGlyT0VpYk9HbkthTWhxK1BuYUNWZzZxV2c2cWVnS2FmZjZXaG5wS29mS0d0bm9teGVaeTNub0c2ZFppK24zdkNjcFBEY3BQR24zYkxiNC9NYjQ3VWJJclZhNHJZb0dqZGFJYmVhSVhob1dIbVpZSG9iWHZwY0hqcWRIWHJlSExyb1Zyc2ZHL3VoR251aDJid2oySHhrMTd5bDF2em1sanptMWowbmxYMW9sTDNBSlhXQUFBQWJYUlNUbE1BRUJBUUh4OGdJQ0F1TGpBd01EdzlQVUJBUUVwUVVGQlhWMWhnWUdCa2NIQndjWGw4Z0lDQWdvaUlrSkNRbEppY25KMmdvS0NtcUsrd3NMQzR1c0RBd01qUDBORFExTmJXM056ZzRPRGk1KzN2OFBEdzgvVDA5UFgyOXZiMzkvZjUrZnI3Ky96OC9QejkvdjcremN6Q3hnQUFCQzVKUkVGVWVBSE4xdWwzazBVVUJ2Q2IxQ1RWcG1wYWl0QUdTTFNwU3VLQ0xXcGJUS05KRkdsY1NNQUZGNjNpVW1SY2NORzZnTGJ1eGtYVTY2SkFVZWYvOUxTcG1YbnlMcjNUNUFPL3J6bDV6ajEzN3AxMzZCSVN5NDRmS0pYdUdOL2QxOVBVZlllTzY3Wm5xdGYyS0gzM0lkMXBzWG9GZFczMHNQWjFzTXZzMkQwNjBBSHF3czRGSGVKb2pMWnFudzUzY21mdmcrWFI4bUMwT0VqdXhyWEVrWDV5ZGVWSkxWSWxWMGUxMFBYazVrN2RZZUh1N0NqMWorNDl1S2c3dUxVNjF0R0x3MWxxMjd1Z1FZbGNsSEM0Ymd2N1ZRK1RBeWo1WmMvVWpzUHZzMXNkNWNXcnlXT2J0dldUMkVQYTRydG5XVzNKa3BqZ2dFcGJPc1ByN0Y3RXlOZXd0cEJJc2xBN3A0M0hDc253b29YVEVjM1VtUG1DTm41bHJxVEp4eTZuUm1jYXZHWlZ0LzNEYTJwRDVOSHZzT0hKQ3JkYzFHMnIzRElUcFU3eWljN3cvN1J4bmpjMGt0NUdDNGRqaXYyU3ozRmIyaUVaZzQxL2Rkc0ZEb3l1WXJJa21GZWh6MEhSMnRoUGdRcU15UVliMk90QjBXeHNaM0JlRzMrd3BSYjF2emwyVVlCb2c4RmZHaHR0RktqdEFjbG5aWXJSbzlyeUc5dUcvRlpRVTRBRWc4WkU5TGpHTXpUbXFLWFBMbmxXVm5JbFFRVHZ4SmY4aXA3VmdqWmp5VlByancxdGU1b3RNN1JtUDd4bStzSzJHdjlJOEdpKytCUmJFa1I5RUJ3OHpSVWNLeHdwNzN4a2FMaXFRYitrR2R1SlROSEc3MnpjVzlMb0pncVF4cFAzL1RqLy9jM3lCMHRxemFtbDA1LytvckhMa3NWTys5NWtYNy83cWdKdm5qbHJmcjJHZ3N5eDBlb3k5dVB6TjVTUGQ4NmFYZ2dPc0VLVzJQcno3ZHUzVklEMy90enMvc1NSczJ3N292VkhLdGpyWDJwZDdaTWxUeEFZZkJBTDlqaUR3ZkxrcTU1VG03aWZoTWxUR1B5Q0FzN1JGUmhuNDdKbmxjQjlSTTVUOTdBU3VaWEljVk51VURJbmRwRGJkc2ZycXNPcHBlWGw1WStYVktkakZDVGgrekdhVnVqMGQ5enkwNVBQSzNRekJhbXhkd3RUQ3J6eWcvMlJ2ZjJFc3RVam9yZEd3YS9reDltU0pMcjhtTEx0Q1c4SEhHSmMyUjVoUzIxOUlpRjZQblR1c09xY01sNTdnbTBaOGthbktNQVFnMHFTeXVaZm43ekl0c2JHeU85UWxueFkwZUN1RDFYTDJ5cy9Nc3JRaGx0RTdVZzB1Rk96dWZKRkUyUHhCby9ZQXg4WFBQZER3V04wTXJEUllJWkYwbVNNS0NOSGdhSVZGb0JiTm9MSjd0RVFES3hHRjBrY0xRaW1vakNab3B2ME9rTk95V0NDZzlYTVZBaTdBUkp6UWRNMlFVaDBnbUJvempjM1NrZzZkU0JScURHWVNVT3U2NlpnK0kyZk5acy9NMy9mL0dybC9YbnlGMUd3M1ZLQ2V6MFBONUlVZkZMcXZnVU40QzBxTnFZczVZaFBMK2FWWllERTRJcFVrNTdvU0ZuSm00RnlDcXFPRTBqaFkyU015TEZvbzU2enlvNmJlY09TNVVWRGRqN1ZpaDB6cCt0Y01od1JwQmVMeXF0SWpsSktBSVpTYkk4U0dTRjNrMHBBM21SNXRIdXdQRm9hN043cmVvcTJicUNzQWsxSHFDdTV1dkkxbjZKdVJYSStTMU1jbzU0WW1ZVHdjbjZBZWljK2tzc1hpOFhwWEM0VjN0Ny9BRHVUTkthUUpkU2NBQUFBQUVsRlRrU3VRbUNDIi8+IDx0ZXh0IHg9IjQxNSIgeT0iMTUwIiBmaWxsPSIjMDEwMTAxIiBmaWxsLW9wYWNpdHk9Ii4zIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iMzcwIj5sYXVuY2g8L3RleHQ+PHRleHQgeD0iNDE1IiB5PSIxNDAiIHRyYW5zZm9ybT0ic2NhbGUoLjEpIiB0ZXh0TGVuZ3RoPSIzNzAiPmxhdW5jaDwvdGV4dD48dGV4dCB4PSI4NTUiIHk9IjE1MCIgZmlsbD0iIzAxMDEwMSIgZmlsbC1vcGFjaXR5PSIuMyIgdHJhbnNmb3JtPSJzY2FsZSguMSkiIHRleHRMZW5ndGg9IjM1MCI+YmluZGVyPC90ZXh0Pjx0ZXh0IHg9Ijg1NSIgeT0iMTQwIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iMzUwIj5iaW5kZXI8L3RleHQ+PC9nPiA8L3N2Zz4=" width="150px"></a> </div> <div class="sphx-glr-download sphx-glr-download-python docutils container"> <p><a class="reference download internal" download="" href="https://scikit-learn.org/1.1/_downloads/acc6f0183d4b7293ae5914724f55bc28/plot_gradient_boosting_categorical.py"><code>Download Python source code: plot_gradient_boosting_categorical.py</code></a></p> </div> <div class="sphx-glr-download sphx-glr-download-jupyter docutils container"> <p><a class="reference download internal" download="" href="https://scikit-learn.org/1.1/_downloads/cd5de29451c4f8624f47d18def81839c/plot_gradient_boosting_categorical.ipynb"><code>Download Jupyter notebook: plot_gradient_boosting_categorical.ipynb</code></a></p> </div> </div>  </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/auto_examples/ensemble/plot_gradient_boosting_categorical.html" class="_attribution-link">https://scikit-learn.org/1.1/auto_examples/ensemble/plot_gradient_boosting_categorical.html</a>
  </p>
</div>
