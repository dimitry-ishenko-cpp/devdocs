<div class="sphx-glr-download-link-note admonition note"> <p class="admonition-title">Note</p> <p>Click <a class="reference internal" href="#sphx-glr-download-auto-examples-kernel-approximation-plot-scalable-poly-kernels-py"><span class="std std-ref">here</span></a> to download the full example code or to run this example in your browser via Binder</p> </div> <section class="sphx-glr-example-title" id="scalable-learning-with-polynomial-kernel-approximation"> <h1 id="sphx-glr-auto-examples-kernel-approximation-plot-scalable-poly-kernels-py">Scalable learning with polynomial kernel approximation</h1> <p>This example illustrates the use of <code>PolynomialCountSketch</code> to efficiently generate polynomial kernel feature-space approximations. This is used to train linear classifiers that approximate the accuracy of kernelized ones.</p> <p>We use the Covtype dataset [2], trying to reproduce the experiments on the original paper of Tensor Sketch [1], i.e. the algorithm implemented by <a class="reference internal" href="../../modules/generated/sklearn.kernel_approximation.polynomialcountsketch.html#sklearn.kernel_approximation.PolynomialCountSketch" title="sklearn.kernel_approximation.PolynomialCountSketch"><code>PolynomialCountSketch</code></a>.</p> <p>First, we compute the accuracy of a linear classifier on the original features. Then, we train linear classifiers on different numbers of features (<code>n_components</code>) generated by <a class="reference internal" href="../../modules/generated/sklearn.kernel_approximation.polynomialcountsketch.html#sklearn.kernel_approximation.PolynomialCountSketch" title="sklearn.kernel_approximation.PolynomialCountSketch"><code>PolynomialCountSketch</code></a>, approximating the accuracy of a kernelized classifier in a scalable manner.</p> <pre data-language="python"># Author: Daniel Lopez-Sanchez &lt;lope@usal.es&gt;
# License: BSD 3 clause
</pre> <section id="preparing-the-data"> <h2>Preparing the data</h2> <p>Load the Covtype dataset, which contains 581,012 samples with 54 features each, distributed among 6 classes. The goal of this dataset is to predict forest cover type from cartographic variables only (no remotely sensed data). After loading, we transform it into a binary classification problem to match the version of the dataset in the LIBSVM webpage [2], which was the one used in [1].</p> <pre data-language="python">from sklearn.datasets import fetch_covtype

X, y = fetch_covtype(return_X_y=True)

y[y != 2] = 0
y[y == 2] = 1  # We will try to separate class 2 from the other 6 classes.
</pre> </section> <section id="partitioning-the-data"> <h2>Partitioning the data</h2> <p>Here we select 5,000 samples for training and 10,000 for testing. To actually reproduce the results in the original Tensor Sketch paper, select 100,000 for training.</p> <pre data-language="python">from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, train_size=5_000, test_size=10_000, random_state=42
)
</pre> </section> <section id="feature-normalization"> <h2>Feature normalization</h2> <p>Now scale features to the range [0, 1] to match the format of the dataset in the LIBSVM webpage, and then normalize to unit length as done in the original Tensor Sketch paper [1].</p> <pre data-language="python">from sklearn.preprocessing import MinMaxScaler, Normalizer
from sklearn.pipeline import make_pipeline

mm = make_pipeline(MinMaxScaler(), Normalizer())
X_train = mm.fit_transform(X_train)
X_test = mm.transform(X_test)
</pre> </section> <section id="establishing-a-baseline-model"> <h2>Establishing a baseline model</h2> <p>As a baseline, train a linear SVM on the original features and print the accuracy. We also measure and store accuracies and training times to plot them later.</p> <pre data-language="python">import time
from sklearn.svm import LinearSVC

results = {}

lsvm = LinearSVC()
start = time.time()
lsvm.fit(X_train, y_train)
lsvm_time = time.time() - start
lsvm_score = 100 * lsvm.score(X_test, y_test)

results["LSVM"] = {"time": lsvm_time, "score": lsvm_score}
print(f"Linear SVM score on raw features: {lsvm_score:.2f}%")
</pre> <pre data-language="none">Linear SVM score on raw features: 75.62%
</pre> </section> <section id="establishing-the-kernel-approximation-model"> <h2>Establishing the kernel approximation model</h2> <p>Then we train linear SVMs on the features generated by <a class="reference internal" href="../../modules/generated/sklearn.kernel_approximation.polynomialcountsketch.html#sklearn.kernel_approximation.PolynomialCountSketch" title="sklearn.kernel_approximation.PolynomialCountSketch"><code>PolynomialCountSketch</code></a> with different values for <code>n_components</code>, showing that these kernel feature approximations improve the accuracy of linear classification. In typical application scenarios, <code>n_components</code> should be larger than the number of features in the input representation in order to achieve an improvement with respect to linear classification. As a rule of thumb, the optimum of evaluation score / run time cost is typically achieved at around <code>n_components</code> = 10 * <code>n_features</code>, though this might depend on the specific dataset being handled. Note that, since the original samples have 54 features, the explicit feature map of the polynomial kernel of degree four would have approximately 8.5 million features (precisely, 54^4). Thanks to <a class="reference internal" href="../../modules/generated/sklearn.kernel_approximation.polynomialcountsketch.html#sklearn.kernel_approximation.PolynomialCountSketch" title="sklearn.kernel_approximation.PolynomialCountSketch"><code>PolynomialCountSketch</code></a>, we can condense most of the discriminative information of that feature space into a much more compact representation. While we run the experiment only a single time (<code>n_runs</code> = 1) in this example, in practice one should repeat the experiment several times to compensate for the stochastic nature of <a class="reference internal" href="../../modules/generated/sklearn.kernel_approximation.polynomialcountsketch.html#sklearn.kernel_approximation.PolynomialCountSketch" title="sklearn.kernel_approximation.PolynomialCountSketch"><code>PolynomialCountSketch</code></a>.</p> <pre data-language="python">from sklearn.kernel_approximation import PolynomialCountSketch

n_runs = 1
N_COMPONENTS = [250, 500, 1000, 2000]

for n_components in N_COMPONENTS:

    ps_lsvm_time = 0
    ps_lsvm_score = 0
    for _ in range(n_runs):

        pipeline = make_pipeline(
            PolynomialCountSketch(n_components=n_components, degree=4),
            LinearSVC(),
        )

        start = time.time()
        pipeline.fit(X_train, y_train)
        ps_lsvm_time += time.time() - start
        ps_lsvm_score += 100 * pipeline.score(X_test, y_test)

    ps_lsvm_time /= n_runs
    ps_lsvm_score /= n_runs

    results[f"LSVM + PS({n_components})"] = {
        "time": ps_lsvm_time,
        "score": ps_lsvm_score,
    }
    print(
        f"Linear SVM score on {n_components} PolynomialCountSketch "
        + f"features: {ps_lsvm_score:.2f}%"
    )
</pre> <pre data-language="none">Linear SVM score on 250 PolynomialCountSketch features: 76.55%
Linear SVM score on 500 PolynomialCountSketch features: 76.92%
Linear SVM score on 1000 PolynomialCountSketch features: 77.79%
Linear SVM score on 2000 PolynomialCountSketch features: 78.59%
</pre> </section> <section id="establishing-the-kernelized-svm-model"> <h2>Establishing the kernelized SVM model</h2> <p>Train a kernelized SVM to see how well <a class="reference internal" href="../../modules/generated/sklearn.kernel_approximation.polynomialcountsketch.html#sklearn.kernel_approximation.PolynomialCountSketch" title="sklearn.kernel_approximation.PolynomialCountSketch"><code>PolynomialCountSketch</code></a> is approximating the performance of the kernel. This, of course, may take some time, as the SVC class has a relatively poor scalability. This is the reason why kernel approximators are so useful:</p> <pre data-language="python">from sklearn.svm import SVC

ksvm = SVC(C=500.0, kernel="poly", degree=4, coef0=0, gamma=1.0)

start = time.time()
ksvm.fit(X_train, y_train)
ksvm_time = time.time() - start
ksvm_score = 100 * ksvm.score(X_test, y_test)

results["KSVM"] = {"time": ksvm_time, "score": ksvm_score}
print(f"Kernel-SVM score on raw features: {ksvm_score:.2f}%")
</pre> <pre data-language="none">Kernel-SVM score on raw features: 79.78%
</pre> </section> <section id="comparing-the-results"> <h2>Comparing the results</h2> <p>Finally, plot the results of the different methods against their training times. As we can see, the kernelized SVM achieves a higher accuracy, but its training time is much larger and, most importantly, will grow much faster if the number of training samples increases.</p> <pre data-language="python">import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(7, 7))
ax.scatter(
    [
        results["LSVM"]["time"],
    ],
    [
        results["LSVM"]["score"],
    ],
    label="Linear SVM",
    c="green",
    marker="^",
)

ax.scatter(
    [
        results["LSVM + PS(250)"]["time"],
    ],
    [
        results["LSVM + PS(250)"]["score"],
    ],
    label="Linear SVM + PolynomialCountSketch",
    c="blue",
)

for n_components in N_COMPONENTS:
    ax.scatter(
        [
            results[f"LSVM + PS({n_components})"]["time"],
        ],
        [
            results[f"LSVM + PS({n_components})"]["score"],
        ],
        c="blue",
    )
    ax.annotate(
        f"n_comp.={n_components}",
        (
            results[f"LSVM + PS({n_components})"]["time"],
            results[f"LSVM + PS({n_components})"]["score"],
        ),
        xytext=(-30, 10),
        textcoords="offset pixels",
    )

ax.scatter(
    [
        results["KSVM"]["time"],
    ],
    [
        results["KSVM"]["score"],
    ],
    label="Kernel SVM",
    c="red",
    marker="x",
)

ax.set_xlabel("Training time (s)")
ax.set_ylabel("Accuracy (%)")
ax.legend()
plt.show()
</pre> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAArwAAAK8CAMAAAA6ZJxxAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8qNh9FAAAAtFBMVEX///+vr68FBQVdXV3W1tYAAP8KCgrx8fEAAAD39/ceHh4/Pz/g4OBQUFCfn5+AgIApKSnc3NwwMDBvb2/Pz88PDw+/v7/o6OiPj4/9/f6Hh4c3Nze3t7cWFhbu7u5HR0d2dnbk5OSYmJj6+vsjIyMAgABpaWnLy8vHx8enp6fa2tqrq/9jY2P/4+P/IiLDw8Ok0aQcHP+/v///AAD09PQhkSH/8PBycv+Pj///ODj/xcXD4cO2K9feAAAdDUlEQVR42uzda1faSACA4cmlISYkhEDEAEkIIAjS0nbZnrPt//9fOzMBBFululiBfd8PXlAw9DyOk4GhQhARERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERHRBZeWNaKnKtNTxlu6RE9XnjLemsvQS08OvG7ttPHWmDvReeoAL4GXwMvhETpeenjpFb24FLwncHhpadMrKlPwvvvhlXbOOPrycrsE73sfXmrnTPBeUZrbKXjf+fCu7CskvqYL/4cDL3jBC17wgvd4eF0DvOA9M7xWUL3v/Oa1rv3EGVsjw63rT6OW8N2u+qhwG+AF7xvg/ZEewnv4bHyk3trmwG72F6NRpqku3bbwvbH8qDQz8IL3DfB+vv18CK+cNtRdw3fiO2XSd7zWSogwdjKrI4dbtx+b1+rbbrz19Vpj9fuwiIXwJ9lSiG4Qgxe8x8c7+vv279Hv4I3688AbibZzM1/GlsTbb971CoU37jf18vGsMiyHYFd+sHKGEm+rtRBibIAXvG+A9/Pt7ZND7x7eUKG0hbXQM4LqdqbuSuLdnM6llpsFN+rn9BRuJ1d428nqOhuBF7zHxysH3tsnh949vFMhcjmiRqYjk4rbgaffX+9sISnDSebJT4dOTfgSsMQr4tAaCPCC9/h41cD75NC7h7e9xtua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" srcset="../../_images/sphx_glr_plot_scalable_poly_kernels_001.png" alt="plot scalable poly kernels" class="sphx-glr-single-img"><section id="references"> <h3>References</h3> <p>[1] Pham, Ninh and Rasmus Pagh. “Fast and scalable polynomial kernels via explicit feature maps.” KDD ‘13 (2013). <a class="reference external" href="https://doi.org/10.1145/2487575.2487591">https://doi.org/10.1145/2487575.2487591</a></p> <p>[2] LIBSVM binary datasets repository <a class="reference external" href="https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary.html">https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary.html</a></p> <p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes 12.357 seconds)</p> <div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-auto-examples-kernel-approximation-plot-scalable-poly-kernels-py"> <div class="binder-badge docutils container"> <a class="reference external image-reference" href="https://mybinder.org/v2/gh/scikit-learn/scikit-learn/1.1.X?urlpath=lab/tree/notebooks/auto_examples/kernel_approximation/plot_scalable_poly_kernels.ipynb"><img alt="Launch binder" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTA5IiBoZWlnaHQ9IjIwIj48bGluZWFyR3JhZGllbnQgaWQ9ImIiIHgyPSIwIiB5Mj0iMTAwJSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjYmJiIiBzdG9wLW9wYWNpdHk9Ii4xIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLW9wYWNpdHk9Ii4xIi8+PC9saW5lYXJHcmFkaWVudD48Y2xpcFBhdGggaWQ9ImEiPjxyZWN0IHdpZHRoPSIxMDkiIGhlaWdodD0iMjAiIHJ4PSIzIiBmaWxsPSIjZmZmIi8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjYSkiPjxwYXRoIGZpbGw9IiM1NTUiIGQ9Ik0wIDBoNjR2MjBIMHoiLz48cGF0aCBmaWxsPSIjNTc5YWNhIiBkPSJNNjQgMGg0NXYyMEg2NHoiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMCAwaDEwOXYyMEgweiIvPjwvZz48ZyBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0iRGVqYVZ1IFNhbnMsVmVyZGFuYSxHZW5ldmEsc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMTAiPjxpbWFnZSB4PSI1IiB5PSIzIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRmtBQUFCWkNBTUFBQUJpMVhpZEFBQUI4bEJNVkVYLy8vOVhtc3JtWllIMW9sSlhtc3Ixb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEpYbXNybVpZSDFvbEwxb2xKWG1zcjFvbEpYbXNybVpZSDFvbEwxb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xMMW9sSlhtc3JtWllIMW9sTDFvbEwwbkZmMW9sSlhtc3JtWllIMW9sSlhtc3E4ZFpiMW9sSlhtc3JtWllIMW9sSlhtc3BYbXNwWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xMMW9sTGVhSVZYbXNybVpZSDFvbEwxb2xMMW9sSlhtc3JtWllIMW9sTG5hMzFYbXNyMW9sSlhtc3Ixb2xKWG1zcm1aWUgxb2xMcW9WcjFvbEpYbXNyMW9sSlhtc3JtWllIMW9sTDFvbEtrZmFQb2JYdnZpR2FiZ2FkWG1zcVRoS3VvZktIbVo0RG9ibnIxb2xKWG1zcjFvbEpYbXNwWG1zcjFvbEpYbXNyZlo0VHVoV24xb2xMMW9sSlhtc3FCaTdYMW9sSlhtc3BabXNsYm1NaGJtc2RlbXNWZmw4Wmdtc05pbThKcGs4RjBtN1I0bTdGNW5MQjZqYmg3amJpRGlyT0VpYk9HbkthTWhxK1BuYUNWZzZxV2c2cWVnS2FmZjZXaG5wS29mS0d0bm9teGVaeTNub0c2ZFppK24zdkNjcFBEY3BQR24zYkxiNC9NYjQ3VWJJclZhNHJZb0dqZGFJYmVhSVhob1dIbVpZSG9iWHZwY0hqcWRIWHJlSExyb1Zyc2ZHL3VoR251aDJid2oySHhrMTd5bDF2em1sanptMWowbmxYMW9sTDNBSlhXQUFBQWJYUlNUbE1BRUJBUUh4OGdJQ0F1TGpBd01EdzlQVUJBUUVwUVVGQlhWMWhnWUdCa2NIQndjWGw4Z0lDQWdvaUlrSkNRbEppY25KMmdvS0NtcUsrd3NMQzR1c0RBd01qUDBORFExTmJXM056ZzRPRGk1KzN2OFBEdzgvVDA5UFgyOXZiMzkvZjUrZnI3Ky96OC9QejkvdjcremN6Q3hnQUFCQzVKUkVGVWVBSE4xdWwzazBVVUJ2Q2IxQ1RWcG1wYWl0QUdTTFNwU3VLQ0xXcGJUS05KRkdsY1NNQUZGNjNpVW1SY2NORzZnTGJ1eGtYVTY2SkFVZWYvOUxTcG1YbnlMcjNUNUFPL3J6bDV6ajEzN3AxMzZCSVN5NDRmS0pYdUdOL2QxOVBVZlllTzY3Wm5xdGYyS0gzM0lkMXBzWG9GZFczMHNQWjFzTXZzMkQwNjBBSHF3czRGSGVKb2pMWnFudzUzY21mdmcrWFI4bUMwT0VqdXhyWEVrWDV5ZGVWSkxWSWxWMGUxMFBYazVrN2RZZUh1N0NqMWorNDl1S2c3dUxVNjF0R0x3MWxxMjd1Z1FZbGNsSEM0Ymd2N1ZRK1RBeWo1WmMvVWpzUHZzMXNkNWNXcnlXT2J0dldUMkVQYTRydG5XVzNKa3BqZ2dFcGJPc1ByN0Y3RXlOZXd0cEJJc2xBN3A0M0hDc253b29YVEVjM1VtUG1DTm41bHJxVEp4eTZuUm1jYXZHWlZ0LzNEYTJwRDVOSHZzT0hKQ3JkYzFHMnIzRElUcFU3eWljN3cvN1J4bmpjMGt0NUdDNGRqaXYyU3ozRmIyaUVaZzQxL2Rkc0ZEb3l1WXJJa21GZWh6MEhSMnRoUGdRcU15UVliMk90QjBXeHNaM0JlRzMrd3BSYjF2emwyVVlCb2c4RmZHaHR0RktqdEFjbG5aWXJSbzlyeUc5dUcvRlpRVTRBRWc4WkU5TGpHTXpUbXFLWFBMbmxXVm5JbFFRVHZ4SmY4aXA3VmdqWmp5VlByancxdGU1b3RNN1JtUDd4bStzSzJHdjlJOEdpKytCUmJFa1I5RUJ3OHpSVWNLeHdwNzN4a2FMaXFRYitrR2R1SlROSEc3MnpjVzlMb0pncVF4cFAzL1RqLy9jM3lCMHRxemFtbDA1LytvckhMa3NWTys5NWtYNy83cWdKdm5qbHJmcjJHZ3N5eDBlb3k5dVB6TjVTUGQ4NmFYZ2dPc0VLVzJQcno3ZHUzVklEMy90enMvc1NSczJ3N292VkhLdGpyWDJwZDdaTWxUeEFZZkJBTDlqaUR3ZkxrcTU1VG03aWZoTWxUR1B5Q0FzN1JGUmhuNDdKbmxjQjlSTTVUOTdBU3VaWEljVk51VURJbmRwRGJkc2ZycXNPcHBlWGw1WStYVktkakZDVGgrekdhVnVqMGQ5enkwNVBQSzNRekJhbXhkd3RUQ3J6eWcvMlJ2ZjJFc3RVam9yZEd3YS9reDltU0pMcjhtTEx0Q1c4SEhHSmMyUjVoUzIxOUlpRjZQblR1c09xY01sNTdnbTBaOGthbktNQVFnMHFTeXVaZm43ekl0c2JHeU85UWxueFkwZUN1RDFYTDJ5cy9Nc3JRaGx0RTdVZzB1Rk96dWZKRkUyUHhCby9ZQXg4WFBQZER3V04wTXJEUllJWkYwbVNNS0NOSGdhSVZGb0JiTm9MSjd0RVFES3hHRjBrY0xRaW1vakNab3B2ME9rTk95V0NDZzlYTVZBaTdBUkp6UWRNMlFVaDBnbUJvempjM1NrZzZkU0JScURHWVNVT3U2NlpnK0kyZk5acy9NMy9mL0dybC9YbnlGMUd3M1ZLQ2V6MFBONUlVZkZMcXZnVU40QzBxTnFZczVZaFBMK2FWWllERTRJcFVrNTdvU0ZuSm00RnlDcXFPRTBqaFkyU015TEZvbzU2enlvNmJlY09TNVVWRGRqN1ZpaDB6cCt0Y01od1JwQmVMeXF0SWpsSktBSVpTYkk4U0dTRjNrMHBBM21SNXRIdXdQRm9hN043cmVvcTJicUNzQWsxSHFDdTV1dkkxbjZKdVJYSStTMU1jbzU0WW1ZVHdjbjZBZWljK2tzc1hpOFhwWEM0VjN0Ny9BRHVUTkthUUpkU2NBQUFBQUVsRlRrU3VRbUNDIi8+IDx0ZXh0IHg9IjQxNSIgeT0iMTUwIiBmaWxsPSIjMDEwMTAxIiBmaWxsLW9wYWNpdHk9Ii4zIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iMzcwIj5sYXVuY2g8L3RleHQ+PHRleHQgeD0iNDE1IiB5PSIxNDAiIHRyYW5zZm9ybT0ic2NhbGUoLjEpIiB0ZXh0TGVuZ3RoPSIzNzAiPmxhdW5jaDwvdGV4dD48dGV4dCB4PSI4NTUiIHk9IjE1MCIgZmlsbD0iIzAxMDEwMSIgZmlsbC1vcGFjaXR5PSIuMyIgdHJhbnNmb3JtPSJzY2FsZSguMSkiIHRleHRMZW5ndGg9IjM1MCI+YmluZGVyPC90ZXh0Pjx0ZXh0IHg9Ijg1NSIgeT0iMTQwIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iMzUwIj5iaW5kZXI8L3RleHQ+PC9nPiA8L3N2Zz4=" width="150px"></a> </div> <div class="sphx-glr-download sphx-glr-download-python docutils container"> <p><a class="reference download internal" download="" href="https://scikit-learn.org/1.1/_downloads/c557c992950d3a2cf0cc4280c9dbf39b/plot_scalable_poly_kernels.py"><code>Download Python source code: plot_scalable_poly_kernels.py</code></a></p> </div> <div class="sphx-glr-download sphx-glr-download-jupyter docutils container"> <p><a class="reference download internal" download="" href="https://scikit-learn.org/1.1/_downloads/cb5b0b55b4ddb01e9ad80e6e28417c64/plot_scalable_poly_kernels.ipynb"><code>Download Jupyter notebook: plot_scalable_poly_kernels.ipynb</code></a></p> </div> </div>  </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/auto_examples/kernel_approximation/plot_scalable_poly_kernels.html" class="_attribution-link">https://scikit-learn.org/1.1/auto_examples/kernel_approximation/plot_scalable_poly_kernels.html</a>
  </p>
</div>
