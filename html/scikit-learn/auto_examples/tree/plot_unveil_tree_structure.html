<div class="sphx-glr-download-link-note admonition note"> <p class="admonition-title">Note</p> <p>Click <a class="reference internal" href="#sphx-glr-download-auto-examples-tree-plot-unveil-tree-structure-py"><span class="std std-ref">here</span></a> to download the full example code or to run this example in your browser via Binder</p> </div> <section class="sphx-glr-example-title" id="understanding-the-decision-tree-structure"> <h1 id="sphx-glr-auto-examples-tree-plot-unveil-tree-structure-py">Understanding the decision tree structure</h1> <p>The decision tree structure can be analysed to gain further insight on the relation between the features and the target to predict. In this example, we show how to retrieve:</p> <ul class="simple"> <li>the binary tree structure;</li> <li>the depth of each node and whether or not it’s a leaf;</li> <li>the nodes that were reached by a sample using the <code>decision_path</code> method;</li> <li>the leaf that was reached by a sample using the apply method;</li> <li>the rules that were used to predict a sample;</li> <li>the decision path shared by a group of samples.</li> </ul> <pre data-language="python">import numpy as np
from matplotlib import pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.datasets import load_iris
from sklearn.tree import DecisionTreeClassifier
from sklearn import tree
</pre> <section id="train-tree-classifier"> <h2>Train tree classifier</h2> <p>First, we fit a <a class="reference internal" href="../../modules/generated/sklearn.tree.decisiontreeclassifier.html#sklearn.tree.DecisionTreeClassifier" title="sklearn.tree.DecisionTreeClassifier"><code>DecisionTreeClassifier</code></a> using the <a class="reference internal" href="../../modules/generated/sklearn.datasets.load_iris.html#sklearn.datasets.load_iris" title="sklearn.datasets.load_iris"><code>load_iris</code></a> dataset.</p> <pre data-language="python">iris = load_iris()
X = iris.data
y = iris.target
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)

clf = DecisionTreeClassifier(max_leaf_nodes=3, random_state=0)
clf.fit(X_train, y_train)
</pre> <div class="output_subarea output_html rendered_html output_result"> <div id="sk-container-id-7" class="sk-top-container">
<div class="sk-text-repr-fallback">
<pre>DecisionTreeClassifier(max_leaf_nodes=3, random_state=0)</pre>
<b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br>On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b>
</div>
<div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator sk-toggleable">
<input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-27" type="checkbox" checked><label for="sk-estimator-id-27" class="sk-toggleable__label sk-toggleable__label-arrow">DecisionTreeClassifier</label><div class="sk-toggleable__content"><pre>DecisionTreeClassifier(max_leaf_nodes=3, random_state=0)</pre></div>
</div></div></div>
</div> </div> <br> <br></section> <section id="tree-structure"> <h2>Tree structure</h2> <p>The decision classifier has an attribute called <code>tree_</code> which allows access to low level attributes such as <code>node_count</code>, the total number of nodes, and <code>max_depth</code>, the maximal depth of the tree. It also stores the entire binary tree structure, represented as a number of parallel arrays. The i-th element of each array holds information about the node <code>i</code>. Node 0 is the tree’s root. Some of the arrays only apply to either leaves or split nodes. In this case the values of the nodes of the other type is arbitrary. For example, the arrays <code>feature</code> and <code>threshold</code> only apply to split nodes. The values for leaf nodes in these arrays are therefore arbitrary.</p> <p>Among these arrays, we have:</p>  <ul class="simple"> <li>
<code>children_left[i]</code>: id of the left child of node <code>i</code> or -1 if leaf node</li> <li>
<code>children_right[i]</code>: id of the right child of node <code>i</code> or -1 if leaf node</li> <li>
<code>feature[i]</code>: feature used for splitting node <code>i</code>
</li> <li>
<code>threshold[i]</code>: threshold value at node <code>i</code>
</li> <li>
<code>n_node_samples[i]</code>: the number of training samples reaching node <code>i</code>
</li> <li>
<code>impurity[i]</code>: the impurity at node <code>i</code>
</li> </ul>  <p>Using the arrays, we can traverse the tree structure to compute various properties. Below, we will compute the depth of each node and whether or not it is a leaf.</p> <pre data-language="python">n_nodes = clf.tree_.node_count
children_left = clf.tree_.children_left
children_right = clf.tree_.children_right
feature = clf.tree_.feature
threshold = clf.tree_.threshold

node_depth = np.zeros(shape=n_nodes, dtype=np.int64)
is_leaves = np.zeros(shape=n_nodes, dtype=bool)
stack = [(0, 0)]  # start with the root node id (0) and its depth (0)
while len(stack) &gt; 0:
    # `pop` ensures each node is only visited once
    node_id, depth = stack.pop()
    node_depth[node_id] = depth

    # If the left and right child of a node is not the same we have a split
    # node
    is_split_node = children_left[node_id] != children_right[node_id]
    # If a split node, append left and right children and depth to `stack`
    # so we can loop through them
    if is_split_node:
        stack.append((children_left[node_id], depth + 1))
        stack.append((children_right[node_id], depth + 1))
    else:
        is_leaves[node_id] = True

print(
    "The binary tree structure has {n} nodes and has "
    "the following tree structure:\n".format(n=n_nodes)
)
for i in range(n_nodes):
    if is_leaves[i]:
        print(
            "{space}node={node} is a leaf node.".format(
                space=node_depth[i] * "\t", node=i
            )
        )
    else:
        print(
            "{space}node={node} is a split node: "
            "go to node {left} if X[:, {feature}] &lt;= {threshold} "
            "else to node {right}.".format(
                space=node_depth[i] * "\t",
                node=i,
                left=children_left[i],
                feature=feature[i],
                threshold=threshold[i],
                right=children_right[i],
            )
        )
</pre> <pre data-language="none">The binary tree structure has 5 nodes and has the following tree structure:

node=0 is a split node: go to node 1 if X[:, 3] &lt;= 0.800000011920929 else to node 2.
        node=1 is a leaf node.
        node=2 is a split node: go to node 3 if X[:, 2] &lt;= 4.950000047683716 else to node 4.
                node=3 is a leaf node.
                node=4 is a leaf node.
</pre> <p>We can compare the above output to the plot of the decision tree.</p> <pre data-language="python">tree.plot_tree(clf)
plt.show()
</pre> <img src="data:image/png;base64,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" srcset="../../_images/sphx_glr_plot_unveil_tree_structure_001.png" alt="plot unveil tree structure" class="sphx-glr-single-img"></section> <section id="decision-path"> <h2>Decision path</h2> <p>We can also retrieve the decision path of samples of interest. The <code>decision_path</code> method outputs an indicator matrix that allows us to retrieve the nodes the samples of interest traverse through. A non zero element in the indicator matrix at position <code>(i, j)</code> indicates that the sample <code>i</code> goes through the node <code>j</code>. Or, for one sample <code>i</code>, the positions of the non zero elements in row <code>i</code> of the indicator matrix designate the ids of the nodes that sample goes through.</p> <p>The leaf ids reached by samples of interest can be obtained with the <code>apply</code> method. This returns an array of the node ids of the leaves reached by each sample of interest. Using the leaf ids and the <code>decision_path</code> we can obtain the splitting conditions that were used to predict a sample or a group of samples. First, let’s do it for one sample. Note that <code>node_index</code> is a sparse matrix.</p> <pre data-language="python">node_indicator = clf.decision_path(X_test)
leaf_id = clf.apply(X_test)

sample_id = 0
# obtain ids of the nodes `sample_id` goes through, i.e., row `sample_id`
node_index = node_indicator.indices[
    node_indicator.indptr[sample_id] : node_indicator.indptr[sample_id + 1]
]

print("Rules used to predict sample {id}:\n".format(id=sample_id))
for node_id in node_index:
    # continue to the next node if it is a leaf node
    if leaf_id[sample_id] == node_id:
        continue

    # check if value of the split feature for sample 0 is below threshold
    if X_test[sample_id, feature[node_id]] &lt;= threshold[node_id]:
        threshold_sign = "&lt;="
    else:
        threshold_sign = "&gt;"

    print(
        "decision node {node} : (X_test[{sample}, {feature}] = {value}) "
        "{inequality} {threshold})".format(
            node=node_id,
            sample=sample_id,
            feature=feature[node_id],
            value=X_test[sample_id, feature[node_id]],
            inequality=threshold_sign,
            threshold=threshold[node_id],
        )
    )
</pre> <pre data-language="none">Rules used to predict sample 0:

decision node 0 : (X_test[0, 3] = 2.4) &gt; 0.800000011920929)
decision node 2 : (X_test[0, 2] = 5.1) &gt; 4.950000047683716)
</pre> <p>For a group of samples, we can determine the common nodes the samples go through.</p> <pre data-language="python">sample_ids = [0, 1]
# boolean array indicating the nodes both samples go through
common_nodes = node_indicator.toarray()[sample_ids].sum(axis=0) == len(sample_ids)
# obtain node ids using position in array
common_node_id = np.arange(n_nodes)[common_nodes]

print(
    "\nThe following samples {samples} share the node(s) {nodes} in the tree.".format(
        samples=sample_ids, nodes=common_node_id
    )
)
print("This is {prop}% of all nodes.".format(prop=100 * len(common_node_id) / n_nodes))
</pre> <pre data-language="none">The following samples [0, 1] share the node(s) [0 2] in the tree.
This is 40.0% of all nodes.
</pre> <p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes 0.090 seconds)</p> <div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-auto-examples-tree-plot-unveil-tree-structure-py"> <div class="binder-badge docutils container"> <a class="reference external image-reference" href="https://mybinder.org/v2/gh/scikit-learn/scikit-learn/1.1.X?urlpath=lab/tree/notebooks/auto_examples/tree/plot_unveil_tree_structure.ipynb"><img alt="Launch binder" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTA5IiBoZWlnaHQ9IjIwIj48bGluZWFyR3JhZGllbnQgaWQ9ImIiIHgyPSIwIiB5Mj0iMTAwJSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjYmJiIiBzdG9wLW9wYWNpdHk9Ii4xIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLW9wYWNpdHk9Ii4xIi8+PC9saW5lYXJHcmFkaWVudD48Y2xpcFBhdGggaWQ9ImEiPjxyZWN0IHdpZHRoPSIxMDkiIGhlaWdodD0iMjAiIHJ4PSIzIiBmaWxsPSIjZmZmIi8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjYSkiPjxwYXRoIGZpbGw9IiM1NTUiIGQ9Ik0wIDBoNjR2MjBIMHoiLz48cGF0aCBmaWxsPSIjNTc5YWNhIiBkPSJNNjQgMGg0NXYyMEg2NHoiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMCAwaDEwOXYyMEgweiIvPjwvZz48ZyBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0iRGVqYVZ1IFNhbnMsVmVyZGFuYSxHZW5ldmEsc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMTAiPjxpbWFnZSB4PSI1IiB5PSIzIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRmtBQUFCWkNBTUFBQUJpMVhpZEFBQUI4bEJNVkVYLy8vOVhtc3JtWllIMW9sSlhtc3Ixb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEpYbXNybVpZSDFvbEwxb2xKWG1zcjFvbEpYbXNybVpZSDFvbEwxb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xMMW9sSlhtc3JtWllIMW9sTDFvbEwwbkZmMW9sSlhtc3JtWllIMW9sSlhtc3E4ZFpiMW9sSlhtc3JtWllIMW9sSlhtc3BYbXNwWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xKWG1zcjFvbEwxb2xKWG1zcm1aWUgxb2xMMW9sTGVhSVZYbXNybVpZSDFvbEwxb2xMMW9sSlhtc3JtWllIMW9sTG5hMzFYbXNyMW9sSlhtc3Ixb2xKWG1zcm1aWUgxb2xMcW9WcjFvbEpYbXNyMW9sSlhtc3JtWllIMW9sTDFvbEtrZmFQb2JYdnZpR2FiZ2FkWG1zcVRoS3VvZktIbVo0RG9ibnIxb2xKWG1zcjFvbEpYbXNwWG1zcjFvbEpYbXNyZlo0VHVoV24xb2xMMW9sSlhtc3FCaTdYMW9sSlhtc3BabXNsYm1NaGJtc2RlbXNWZmw4Wmdtc05pbThKcGs4RjBtN1I0bTdGNW5MQjZqYmg3amJpRGlyT0VpYk9HbkthTWhxK1BuYUNWZzZxV2c2cWVnS2FmZjZXaG5wS29mS0d0bm9teGVaeTNub0c2ZFppK24zdkNjcFBEY3BQR24zYkxiNC9NYjQ3VWJJclZhNHJZb0dqZGFJYmVhSVhob1dIbVpZSG9iWHZwY0hqcWRIWHJlSExyb1Zyc2ZHL3VoR251aDJid2oySHhrMTd5bDF2em1sanptMWowbmxYMW9sTDNBSlhXQUFBQWJYUlNUbE1BRUJBUUh4OGdJQ0F1TGpBd01EdzlQVUJBUUVwUVVGQlhWMWhnWUdCa2NIQndjWGw4Z0lDQWdvaUlrSkNRbEppY25KMmdvS0NtcUsrd3NMQzR1c0RBd01qUDBORFExTmJXM056ZzRPRGk1KzN2OFBEdzgvVDA5UFgyOXZiMzkvZjUrZnI3Ky96OC9QejkvdjcremN6Q3hnQUFCQzVKUkVGVWVBSE4xdWwzazBVVUJ2Q2IxQ1RWcG1wYWl0QUdTTFNwU3VLQ0xXcGJUS05KRkdsY1NNQUZGNjNpVW1SY2NORzZnTGJ1eGtYVTY2SkFVZWYvOUxTcG1YbnlMcjNUNUFPL3J6bDV6ajEzN3AxMzZCSVN5NDRmS0pYdUdOL2QxOVBVZlllTzY3Wm5xdGYyS0gzM0lkMXBzWG9GZFczMHNQWjFzTXZzMkQwNjBBSHF3czRGSGVKb2pMWnFudzUzY21mdmcrWFI4bUMwT0VqdXhyWEVrWDV5ZGVWSkxWSWxWMGUxMFBYazVrN2RZZUh1N0NqMWorNDl1S2c3dUxVNjF0R0x3MWxxMjd1Z1FZbGNsSEM0Ymd2N1ZRK1RBeWo1WmMvVWpzUHZzMXNkNWNXcnlXT2J0dldUMkVQYTRydG5XVzNKa3BqZ2dFcGJPc1ByN0Y3RXlOZXd0cEJJc2xBN3A0M0hDc253b29YVEVjM1VtUG1DTm41bHJxVEp4eTZuUm1jYXZHWlZ0LzNEYTJwRDVOSHZzT0hKQ3JkYzFHMnIzRElUcFU3eWljN3cvN1J4bmpjMGt0NUdDNGRqaXYyU3ozRmIyaUVaZzQxL2Rkc0ZEb3l1WXJJa21GZWh6MEhSMnRoUGdRcU15UVliMk90QjBXeHNaM0JlRzMrd3BSYjF2emwyVVlCb2c4RmZHaHR0RktqdEFjbG5aWXJSbzlyeUc5dUcvRlpRVTRBRWc4WkU5TGpHTXpUbXFLWFBMbmxXVm5JbFFRVHZ4SmY4aXA3VmdqWmp5VlByancxdGU1b3RNN1JtUDd4bStzSzJHdjlJOEdpKytCUmJFa1I5RUJ3OHpSVWNLeHdwNzN4a2FMaXFRYitrR2R1SlROSEc3MnpjVzlMb0pncVF4cFAzL1RqLy9jM3lCMHRxemFtbDA1LytvckhMa3NWTys5NWtYNy83cWdKdm5qbHJmcjJHZ3N5eDBlb3k5dVB6TjVTUGQ4NmFYZ2dPc0VLVzJQcno3ZHUzVklEMy90enMvc1NSczJ3N292VkhLdGpyWDJwZDdaTWxUeEFZZkJBTDlqaUR3ZkxrcTU1VG03aWZoTWxUR1B5Q0FzN1JGUmhuNDdKbmxjQjlSTTVUOTdBU3VaWEljVk51VURJbmRwRGJkc2ZycXNPcHBlWGw1WStYVktkakZDVGgrekdhVnVqMGQ5enkwNVBQSzNRekJhbXhkd3RUQ3J6eWcvMlJ2ZjJFc3RVam9yZEd3YS9reDltU0pMcjhtTEx0Q1c4SEhHSmMyUjVoUzIxOUlpRjZQblR1c09xY01sNTdnbTBaOGthbktNQVFnMHFTeXVaZm43ekl0c2JHeU85UWxueFkwZUN1RDFYTDJ5cy9Nc3JRaGx0RTdVZzB1Rk96dWZKRkUyUHhCby9ZQXg4WFBQZER3V04wTXJEUllJWkYwbVNNS0NOSGdhSVZGb0JiTm9MSjd0RVFES3hHRjBrY0xRaW1vakNab3B2ME9rTk95V0NDZzlYTVZBaTdBUkp6UWRNMlFVaDBnbUJvempjM1NrZzZkU0JScURHWVNVT3U2NlpnK0kyZk5acy9NMy9mL0dybC9YbnlGMUd3M1ZLQ2V6MFBONUlVZkZMcXZnVU40QzBxTnFZczVZaFBMK2FWWllERTRJcFVrNTdvU0ZuSm00RnlDcXFPRTBqaFkyU015TEZvbzU2enlvNmJlY09TNVVWRGRqN1ZpaDB6cCt0Y01od1JwQmVMeXF0SWpsSktBSVpTYkk4U0dTRjNrMHBBM21SNXRIdXdQRm9hN043cmVvcTJicUNzQWsxSHFDdTV1dkkxbjZKdVJYSStTMU1jbzU0WW1ZVHdjbjZBZWljK2tzc1hpOFhwWEM0VjN0Ny9BRHVUTkthUUpkU2NBQUFBQUVsRlRrU3VRbUNDIi8+IDx0ZXh0IHg9IjQxNSIgeT0iMTUwIiBmaWxsPSIjMDEwMTAxIiBmaWxsLW9wYWNpdHk9Ii4zIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iMzcwIj5sYXVuY2g8L3RleHQ+PHRleHQgeD0iNDE1IiB5PSIxNDAiIHRyYW5zZm9ybT0ic2NhbGUoLjEpIiB0ZXh0TGVuZ3RoPSIzNzAiPmxhdW5jaDwvdGV4dD48dGV4dCB4PSI4NTUiIHk9IjE1MCIgZmlsbD0iIzAxMDEwMSIgZmlsbC1vcGFjaXR5PSIuMyIgdHJhbnNmb3JtPSJzY2FsZSguMSkiIHRleHRMZW5ndGg9IjM1MCI+YmluZGVyPC90ZXh0Pjx0ZXh0IHg9Ijg1NSIgeT0iMTQwIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iMzUwIj5iaW5kZXI8L3RleHQ+PC9nPiA8L3N2Zz4=" width="150px"></a> </div> <div class="sphx-glr-download sphx-glr-download-python docutils container"> <p><a class="reference download internal" download="" href="https://scikit-learn.org/1.1/_downloads/21a6ff17ef2837fe1cd49e63223a368d/plot_unveil_tree_structure.py"><code>Download Python source code: plot_unveil_tree_structure.py</code></a></p> </div> <div class="sphx-glr-download sphx-glr-download-jupyter docutils container"> <p><a class="reference download internal" download="" href="https://scikit-learn.org/1.1/_downloads/f7a387851c5762610f4e8197e52bbbca/plot_unveil_tree_structure.ipynb"><code>Download Jupyter notebook: plot_unveil_tree_structure.ipynb</code></a></p> </div> </div>  </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2022 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/1.1/auto_examples/tree/plot_unveil_tree_structure.html" class="_attribution-link">https://scikit-learn.org/1.1/auto_examples/tree/plot_unveil_tree_structure.html</a>
  </p>
</div>
