<h1 class="title">Writing RethinkDB drivers</h1> <div class="alg-content">
<div class="toc">  <ul id="markdown-toc"> <li><a href="#initial-steps" id="markdown-toc-initial-steps">Initial steps</a></li> <li><a href="#open-a-connection" id="markdown-toc-open-a-connection">Open a connection</a></li> <li><a href="#perform-a-handshake" id="markdown-toc-perform-a-handshake">Perform a handshake</a></li> <li><a href="#serializing-queries" id="markdown-toc-serializing-queries">Serializing queries</a></li> <li><a href="#send-the-message" id="markdown-toc-send-the-message">Send the message</a></li> <li><a href="#receive-responses" id="markdown-toc-receive-responses">Receive responses</a></li> <li><a href="#notes-on-connections" id="markdown-toc-notes-on-connections">Notes on connections</a></li> <li><a href="#get-help" id="markdown-toc-get-help">Get help</a></li> </ul> </div> <p>RethinkDB client drivers are responsible for serializing queries, sending them to the server using the ReQL wire protocol, and receiving responses from the server and returning them to the calling application. This process takes the following steps:</p> <ul> <li>Open a connection</li> <li>Perform a handshake</li> <li>Serialize the query</li> <li>Send the message</li> <li>Receive responses</li> </ul> <blockquote class="infobox ">
<p>For updates on protocol and behavior changes in new versions of RethinkDB and general assistance with writing drivers, join the <a href="https://groups.google.com/forum/?fromgroups#!forum/rethinkdb-dev">RethinkDB-Dev Google Group</a>.</p> </blockquote> <h2 id="initial-steps">Initial steps</h2> <p>ReQL types and commands are defined in the <a href="https://github.com/rethinkdb/rethinkdb/blob/next/src/rdb_protocol/ql2.proto">ql2.proto</a> file.</p> <p>For a JavaScript version of the file, run <code class="language-plaintext highlighter-rouge">make js-driver</code> in the <code class="language-plaintext highlighter-rouge">rethinkdb</code> repo, and retrieve the JSON version of the file in <code class="language-plaintext highlighter-rouge">build/packages/js/proto-def.js</code>. Alternatively you may grab the equivalent file from <a href="https://github.com/neumino/rethinkdbdash/blob/master/lib/protodef.js">rethinkdbdash</a>.</p> <p>The <code class="language-plaintext highlighter-rouge">ql2.proto</code> file is well-commented, showing arguments and output for each command.</p> <h2 id="open-a-connection">Open a connection</h2> <p>Open a TCP connection to the server on the driver port. The default port is <code class="language-plaintext highlighter-rouge">28015</code>.</p> <h2 id="perform-a-handshake">Perform a handshake</h2> <p>With version <code class="language-plaintext highlighter-rouge">V1_0</code> of the protocol, the handshake protocol has changed from previous versions.</p> <h3 id="version-v1_0">Version V1_0</h3> <ol> <li> <p>The client sends the “magic number” (<code class="language-plaintext highlighter-rouge">0x34c2bdc3</code>) for the protocol version, as a 32-bit little-endian integer (4 bytes).</p> <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight" data-language=""> SEND c3 bd c2 34
</pre></div> </div> </li> <li> <p>On <strong>success,</strong> the server sends a null-terminated JSON response, indicating success, minimum and maximum protocol versions, and the server version.</p> <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight" data-language=""> {
     "success": true,
     "min_protocol_version": 0,
     "max_protocol_version": 0,
     "server_version": "2.3.0"
 }
</pre></div> </div> <p>On <strong>failure,</strong> the server sends a null-terminated error string (<em>not</em> JSON).</p> <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight" data-language=""> ERROR: Received an unsupported protocol version. This port is for RethinkDB queries. Does your client driver version not match the server?
</pre></div> </div> </li> <li> <p>The client sends the protocol version, authentication method, and authentication as a null-terminated JSON response. RethinkDB currently supports only one authentication method, <code class="language-plaintext highlighter-rouge">SCRAM-SHA-256</code>, as specified in <a href="https://tools.ietf.org/html/rfc7677">IETF RFC 7677</a> and <a href="https://tools.ietf.org/html/rfc5802">RFC 5802</a>. The RFC is followed with the exception of error handling (RethinkDB uses its own higher level error reporting rather than the <code class="language-plaintext highlighter-rouge">e=</code> field). RethinkDB does not support channel binding and clients should not request this. The value of <code class="language-plaintext highlighter-rouge">"authentication"</code> is the “client-first-message” specified in RFC 5802 (the channel binding flag, optional SASL authorization identity, username (<code class="language-plaintext highlighter-rouge">n=</code>), and random nonce (<code class="language-plaintext highlighter-rouge">r=</code>).</p> <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight" data-language=""> {
     "protocol_version": 0,
     "authentication_method": "SCRAM-SHA-256",
     "authentication": "n,,n=user,r=rOprNGfwEbeRWgbNEkqO"
 }
</pre></div> </div> </li> <li> <p>The server sends a null-terminated JSON response with a <code class="language-plaintext highlighter-rouge">"success"</code> value of either <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>. On <code class="language-plaintext highlighter-rouge">true</code>, then <code class="language-plaintext highlighter-rouge">"authentication"</code> will contain the “server-first-message” containing the iteration count (<code class="language-plaintext highlighter-rouge">i=</code>), salt (<code class="language-plaintext highlighter-rouge">s=</code>) and a concatenation of the client nonce with its own nonce.</p> <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight" data-language=""> {
     "success": true,
     "authentication": "r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF$k0,
       s=W22ZaJ0SNY7soEsUEjb6gQ==,i=4096"
 }
</pre></div> </div> <p>On <code class="language-plaintext highlighter-rouge">false</code>, the server will send an error and error code.</p> <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight" data-language=""> {
     "success": false,
     "error": "You mucked up.",
     "error_code": 12
 }
</pre></div> </div> <p>A <code class="language-plaintext highlighter-rouge">ReqlAuthError</code> should be thrown if the error code is between 10 and 20 (inclusive).</p> </li> <li> <p>The client sends the null-terminated JSON “client-final-message” with the same nonce and the ClientProof computed as specified by the RFC.</p> <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight" data-language=""> {
     "authentication": "c=biws,r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF$k0,
       p=dHzbZapWIk4jUhN+Ute9ytag9zjfMHgsqmmiz7AndVQ="
 }
</pre></div> </div> </li> <li> <p>The server sends a null-terminated JSON response with a <code class="language-plaintext highlighter-rouge">"success"</code> value of either <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>. On <code class="language-plaintext highlighter-rouge">true</code>, then <code class="language-plaintext highlighter-rouge">"authentication"</code> will contain the “server-final-message” with the ServerSignature value. The client should compute a ServerSignature as specified in the RFC and verify the values are identical.</p> <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight" data-language=""> {
     "success": true,
     "authentication": "v=6rriTRBi23WpRR/wtup+mMhUZUn/dB5nLTJRsjl95G4="
 }
</pre></div> </div> <p>On <code class="language-plaintext highlighter-rouge">false</code>, the server will send an error and error code as above.</p> </li> </ol> <p><strong>Note:</strong> It is possible to optimize the handshake by sending message #3 immediately after #1 without waiting for the server response, and read messages #2 and #4 afterward, handling them as appropriate.</p> <h3 id="versions-v0_3-and-v0_4">Versions V0_3 and V0_4</h3> <p><em><strong>Note:</strong> these versions do not support RethinkDB users and permissions, and may be deprecated in a future release. When communicating with RethinkDB 2.3 or later, the authentication key will be compared to the admin user account password.</em></p> <ol> <li>Send the protocol version, as a 32-bit little-endian integer (4 bytes). <em>Note:</em> All instructions below assume a protocol of <code class="language-plaintext highlighter-rouge">V0_3</code> or higher. The current protocol as of RethinkDB 2.0 is <code class="language-plaintext highlighter-rouge">V0_4</code>.</li> <li>Send the length of the authorization key, as a 32-bit little-endian integer (4 bytes). Send <code class="language-plaintext highlighter-rouge">0</code> if there is no authorization key.</li> <li>Send the authorization key as an ASCII string. <em>If there is no authorization key, skip this step.</em>
</li> <li>Send the protocol type, as a 32-bit little-endian integer (4 bytes). Protocol types are defined in the <code class="language-plaintext highlighter-rouge">Protocol</code> enum in <code class="language-plaintext highlighter-rouge">ql2.proto</code>. New drivers should use JSON, <code class="language-plaintext highlighter-rouge">0x7e6970c7</code>.</li> </ol> <p>The server will respond with a <code class="language-plaintext highlighter-rouge">null</code>-terminated ASCII string describing the result of the handshake. If the string is <code class="language-plaintext highlighter-rouge">"SUCCESS"</code>, the client may proceed to stage 2 and begin sending queries. Any other string indicates an error. The server will close the connection, and the driver should report this error to the user.</p> <h3 id="example-1-no-auth-key">Example 1: No auth key</h3> <table> <thead> <tr> <th>Step</th> <th>Direction</th> <th>Element</th> <th>Bytes</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>SEND</td> <td><code class="language-plaintext highlighter-rouge">V0_4</code></td> <td><code class="language-plaintext highlighter-rouge">20 2d 0c 40</code></td> </tr> <tr> <td>2</td> <td>SEND</td> <td>key size</td> <td><code class="language-plaintext highlighter-rouge">00 00 00 00</code></td> </tr> <tr> <td>3</td> <td>SEND</td> <td>auth key</td> <td> </td> </tr> <tr> <td>4</td> <td>SEND</td> <td>JSON</td> <td><code class="language-plaintext highlighter-rouge">c7 70 69 7e</code></td> </tr> <tr> <td>5</td> <td>RECV</td> <td>success</td> <td><code class="language-plaintext highlighter-rouge">53 55 43 43 45 53 53</code></td> </tr> </tbody> </table> <h3 id="example-2-auth-key">Example 2: Auth key</h3> <table> <thead> <tr> <th>Step</th> <th>Direction</th> <th>Element</th> <th>Bytes</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>SEND</td> <td><code class="language-plaintext highlighter-rouge">V0_4</code></td> <td><code class="language-plaintext highlighter-rouge">20 2d 0c 40</code></td> </tr> <tr> <td>2</td> <td>SEND</td> <td>key size</td> <td><code class="language-plaintext highlighter-rouge">07 00 00 00</code></td> </tr> <tr> <td>3</td> <td>SEND</td> <td>auth key</td> <td><code class="language-plaintext highlighter-rouge">68 75 6e 74 65 72 32</code></td> </tr> <tr> <td>4</td> <td>SEND</td> <td>JSON</td> <td><code class="language-plaintext highlighter-rouge">c7 70 69 7e</code></td> </tr> <tr> <td>5</td> <td>RECV</td> <td>success</td> <td><code class="language-plaintext highlighter-rouge">53 55 43 43 45 53 53</code></td> </tr> </tbody> </table> <h2 id="serializing-queries">Serializing queries</h2> <p>Your driver should assign each query a unique 8-byte token per connection. (The official RethinkDB drivers implement this as an unsigned 8-byte little-endian counter per connection.) The server will send responses to queries using this token as an identifier so the response can be matched to its query. The token can also be used to request more data for the query if all the results were not returned in the first response.</p> <h3 id="a-simple-example">A simple example</h3> <p>The next section will explain how to build complex queries. For now, we will just send the string <code class="language-plaintext highlighter-rouge">"foo"</code> (<code class="language-plaintext highlighter-rouge">r.expr("foo")</code>) to the server.</p> <p>Sending a query to the server takes the following steps:</p> <ul> <li>Serialize the query as UTF8-encoded JSON</li> <li>Send the following data to the server: <ul> <li>The 8-byte unique query token</li> <li>The size of the JSON-serialized, UTF8-encoded query, as a 4-byte little-endian integer</li> <li>The wrapped query message (QueryType, serialized query and options)</li> </ul> </li> </ul> <p>The wrapped query message sent to the server is an array of three elements:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[ QueryType, query, options ]
</pre></div></div> <p>The next section will go into more detail, but in our example the <code class="language-plaintext highlighter-rouge">QueryType</code> is <code class="language-plaintext highlighter-rouge">1</code> (or <code class="language-plaintext highlighter-rouge">START</code>, as we’ll see later), the <code class="language-plaintext highlighter-rouge">query</code> is simply the string <code class="language-plaintext highlighter-rouge">"foo"</code> and there are no options.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[ 1, "foo", {} ]
</pre></div></div> <p>So, the data we send to the server is as follows:</p> <table> <thead> <tr> <th>Step</th> <th>Element</th> <th>Transmitted bytes</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>query token</td> <td><code class="language-plaintext highlighter-rouge">00 00 00 00 00 00 00 01</code></td> </tr> <tr> <td>2</td> <td>length</td> <td><code class="language-plaintext highlighter-rouge">0c 00 00 00</code></td> </tr> <tr> <td>3</td> <td>query</td> <td><code class="language-plaintext highlighter-rouge">[1,"foo",{}]</code></td> </tr> </tbody> </table> <p>Once the query is sent, you can read the response object back from the server. The response object takes the following form:</p> <ul> <li>The 8-byte unique query token</li> <li>The length of the response, as a 4-byte little-endian integer</li> <li>The JSON-encoded response</li> </ul> <table> <thead> <tr> <th>Step</th> <th>Element</th> <th>Bytes on wire</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>query token</td> <td><code class="language-plaintext highlighter-rouge">00 00 00 00 00 00 00 01</code></td> </tr> <tr> <td>2</td> <td>length</td> <td><code class="language-plaintext highlighter-rouge">13 00 00 00</code></td> </tr> <tr> <td>3</td> <td>response</td> <td><code class="language-plaintext highlighter-rouge">{"t":1,"r":["foo"]}</code></td> </tr> </tbody> </table> <p>When you parse the response string as JSON, you get the object:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">{
    t: 1,         // protodef.Response.ResponseType.SUCCESS_ATOM
    r: ["foo"]    // the response is the string 'foo"
}
</pre></div></div> <p>Where <code class="language-plaintext highlighter-rouge">t:1</code> means that the response is a value, and <code class="language-plaintext highlighter-rouge">r: ["foo"]</code> the string <code class="language-plaintext highlighter-rouge">"foo"</code>.</p> <h3 id="queries-in-detail">Queries in detail</h3> <p>ReQL is a <a href="http://en.wikipedia.org/wiki/Domain-specific_language">domain specific language</a> expressed in the host language. The three official drivers follow a very similar syntax; you should stick to that model as closely as your chosen language allows. Typically you are free to use either a prefix or infix notation, or mix the two.</p> <p>Internally, queries are represented as trees. A query of:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.db("blog").table("users").filter({name: "Michel"})
</pre></div></div> <p>is represented by this tree:</p> <p><img alt="Query tree illustration" src="data:image/png;base64,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"></p> <h4 id="reql-commands">ReQL commands</h4> <p>ReQL commands are represented as a list of two or three elements.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[&lt;command&gt;, [&lt;arguments&gt;], {&lt;options&gt;}]
</pre></div></div> <ul> <li>
<code class="language-plaintext highlighter-rouge">&lt;command&gt;</code> is the integer representing the command, from <code class="language-plaintext highlighter-rouge">ql2.proto</code>
</li> <li>
<code class="language-plaintext highlighter-rouge">&lt;arguments&gt;</code> is a list of all arguments. Each argument is itself a query (a command list, or data).</li> <li>
<code class="language-plaintext highlighter-rouge">&lt;options&gt;</code> are the command’s optional arguments. This element may be left out if the command has no optional arguments given.</li> </ul> <p>Thus, this is how our previous query is represented:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.db("blog").table("users").filter({name: "Michel"});

FILTER = 39     // from ql2.proto
TABLE = 15
DB = 14

r.db("blog") =&gt;
    [14, ["blog"]]

r.db("blog").table("users") =&gt;
    [15, [[14, ["blog"]], "users"]]

r.db("blog").table("users").filter({name: "Michel"}) =&gt;
    [39, [[15, [[14, ["blog"]], "users"]], {"name": "Michel"}]]
</pre></div></div> <h4 id="implementation-considerations">Implementation considerations</h4> <p>If you want to use a prefix notation, you just need to implement all the commands on a module. If you want to use an infix notation, you should implement all the functions on a class “term” and some prefix commands on the module.</p> <p>You can only check arity of the methods to a certain extent. If an <code class="language-plaintext highlighter-rouge">ARGS</code> term is one of the argument, only the server can effectively verify that enough arguments are provided (or not too many). The arity errors reported by the server suppose a prefix notation. Things may change if the solution in <a href="https://github.com/rethinkdb/rethinkdb/issues/2463#issuecomment-44584491">#2463</a> is implemented.</p> <h4 id="reql-data">ReQL data</h4> <p>A <em>datum</em> (the singular of data) is any value that can be represented in JSON: booleans, numbers, strings, objects, arrays and <code class="language-plaintext highlighter-rouge">null</code>. They are sent to the server in JSON form.</p> <p>Arrays, however, are a special case: since ReQL commands (as described above) are sent as arrays, you must send data arrays as arguments to the <code class="language-plaintext highlighter-rouge">MAKE_ARRAY</code> command. So the array</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[10, 20, 30]
</pre></div></div> <p>Would be sent to the server as</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">// MAKE_ARRAY = 2 (from ql2.proto)

[2, [10, 20, 30]]
</pre></div></div> <h4 id="reql-pseudo-types">ReQL pseudo types</h4> <p>Some native ReQL data types have no direct JSON representations. These are implemented as <em>pseudo types,</em> JSON objects with the special key <code class="language-plaintext highlighter-rouge">$reql_type$</code>. The three official ReQL drivers convert date and binary types to pseudo types.</p> <p><strong>Date pseudo type</strong></p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">{
    $reql_type: "TIME",
    epoch_time: &lt;timestamp&gt;,
    timezone: &lt;string&gt;
}
</pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">epoch_time</code> field is a Unix timestamp, the number of seconds since January 1st, 1970, with millisecond precision. The <code class="language-plaintext highlighter-rouge">timezone</code> field is a string in the format <code class="language-plaintext highlighter-rouge">[+-]HH:MM</code>, indicating the offset from UTC. UTC is <code class="language-plaintext highlighter-rouge">+00:00</code>; PST is <code class="language-plaintext highlighter-rouge">-08:00</code>; and so on.</p> <p><strong>Binary pseudo type</strong></p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">{
    $reql_type$: "BINARY",
    data: &lt;string&gt;
}
</pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">data</code> field is a Base64-encoded string of the binary object.</p> <h4 id="anonymous-functions">Anonymous functions</h4> <p>A <a href="http://www.rethinkdb.com/blog/lambda-functions/" title="All about lambda functions in RethinkDB queries">good article</a> by <a href="https://github.com/wmrowan">Bill Rowan</a> explains anonymous functions (or lambda functions) in the drivers. The article covers why anonymous functions are useful and how they work. Here, we’ll just focus on how to serialize anonymous functions.</p> <p>When the driver finds an anonymous function, it returns a query object like this one:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">// FUNC = 69, MAKE_ARRAY = 2 (from ql2.proto)

[69, [[2, [p1, p2, ...]], function body]]
</pre></div></div> <p>The parameters are represented as values <code class="language-plaintext highlighter-rouge">&lt;p1&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;p2&gt;</code>, etc.; the values are arbitrary, but must be unique per query to avoid collisions. Within the function body the values are referred to with the query term <code class="language-plaintext highlighter-rouge">VAR</code>, defined as <code class="language-plaintext highlighter-rouge">10</code> in <code class="language-plaintext highlighter-rouge">ql2.proto</code>. So the value of parameter <code class="language-plaintext highlighter-rouge">1</code> is retrieved with <code class="language-plaintext highlighter-rouge">[10, [1]]</code>.</p> <p>Take the function:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">function(x, y, z) {
    return r.add(x, y, z)
}
</pre></div></div> <p>The function would be serialized as:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[FUNC, 
 [[MAKE_ARRAY, [1, 2, 3]],
  [ADD,
   [[VAR, [1]],
    [VAR, [2]],
    [VAR, [3]]]]]]

// FUNC = 69, MAKE_ARRAY = 2, ADD = 24, VAR = 10 (from ql2.proto)

[69, [[2, [1, 2, 3]], [24, [[10, [1]], [10, [2]], [10, [3]]]]]]
</pre></div></div> <h4 id="implementation-details">Implementation details</h4> <p>Serializing functions depends heavily on your driver’s language. The JavaScript driver does it this way:</p> <ul> <li>Look at how many arguments the function takes (<code class="language-plaintext highlighter-rouge">num_args</code>)</li> <li>Create that many <code class="language-plaintext highlighter-rouge">VAR</code> terms</li> <li>Call the function with those terms</li> <li>Serialize the result as the function body</li> </ul> <p>If your driver uses infix notation, you must make sure that the <code class="language-plaintext highlighter-rouge">VAR</code> term implements all the ReQL methods.</p> <h4 id="serializing-implicit_var-rrow">Serializing IMPLICIT_VAR (r.row)</h4> <p>The <code class="language-plaintext highlighter-rouge">IMPLICIT_VAR</code> term is equivalent to the <a href="../../api/python/row/index.html">row</a> command in the official JavaScript and Python drivers. It’s useful for languages where anonymous functions are too verbose.</p> <p>If you support <code class="language-plaintext highlighter-rouge">IMPLICIT_VAR</code> in your driver, then every time you parse the argument of a function you should check if the method can take a function. If it can, you should look for an <code class="language-plaintext highlighter-rouge">IMPLICIT_VAR</code> term (i.e., <code class="language-plaintext highlighter-rouge">row</code>). If you find one, wrap the argument in a function that takes one parameter:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[69, [[2, [1]], argument]]
</pre></div></div> <p>If you do not find one, treat the argument normally.</p> <p>In the case of nested functions, the <code class="language-plaintext highlighter-rouge">IMPLICIT_VAR</code> term is ambiguous, and should not be used. Your driver should either throw an error or let the server return an error.</p> <h4 id="serializing-binary">Serializing BINARY</h4> <p>Binary objects created with <code class="language-plaintext highlighter-rouge">r.binary</code> can be serialized in two different ways.</p> <p>If the argument is a ReQL term (not including a datum), serialize it using the standard term:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[BINARY, argument]
</pre></div></div> <p>If the language’s native binary format is used, use the pseudotype serialization described above.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">{
    $reql_type$: "BINARY",
    data: &lt;base64 string&gt;
}
</pre></div></div> <h4 id="serializing-funcall-rdo">Serializing FUNCALL (r.do)</h4> <p>The <code class="language-plaintext highlighter-rouge">r.do()</code> command is serialized with the <code class="language-plaintext highlighter-rouge">FUNCALL</code> term.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[FUNCALL, [function], arguments]
</pre></div></div> <p>Take the <code class="language-plaintext highlighter-rouge">do</code> command:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.do(10, 20, function (x, y) {
  return r.add(x, y);
})
</pre></div></div> <p>This would be serialized as:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[FUNCALL,
  [FUNC,
    [[MAKE_ARRAY, [1, 2]],
      [ADD,
        [[VAR, [1]],
         [VAR, [2]]]]]],
  10,
  20]

// FUNCALL = 64, FUNC = 69, MAKE_ARRAY = 2, ADD = 24, VAR = 10

[64, [69, [[2, [1, 2]], [24, [[10, [1]], [10, [2]]]]]], 10, 20]
</pre></div></div> <p>Note that while <code class="language-plaintext highlighter-rouge">r.do()</code> takes the function as its <em>last</em> argument, <code class="language-plaintext highlighter-rouge">FUNCALL</code> serializes the function as its <em>first</em> argument.</p> <h2 id="send-the-message">Send the message</h2> <p>Because you can keep chaining commands (or calling them in prefix notation), you need a command to signify the end of the chain and send the query to the server. This command is <code class="language-plaintext highlighter-rouge">run</code> in the official drivers.</p> <h3 id="wrapping-queries">Wrapping queries</h3> <p>Once the <a href="../../api/python/run/index.html">run</a> command is processed, the serialized query needs to be wrapped in the message sent to the server. The complete message takes the form:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[ QueryType, query, options ]
</pre></div></div> <p>The query types are defined in <code class="language-plaintext highlighter-rouge">ql2.proto</code>. When a query is first sent to the server, it will be sent with a <code class="language-plaintext highlighter-rouge">QueryType</code> of <code class="language-plaintext highlighter-rouge">START</code> (<code class="language-plaintext highlighter-rouge">1</code>). The options (sometimes referred to as “global optargs”) are options passed to the <code class="language-plaintext highlighter-rouge">run</code> command itself; see the <a href="../../api/python/run/index.html">run documentation</a> for a complete list. (Commands sent to the server are snake_case, not camelCase.)</p> <p>The full list of <code class="language-plaintext highlighter-rouge">QueryType</code> values is as follows:</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">1</code> <code class="language-plaintext highlighter-rouge">START</code>: Start a new query.</li> <li>
<code class="language-plaintext highlighter-rouge">2</code> <code class="language-plaintext highlighter-rouge">CONTINUE</code>: Continue a query that returned <code class="language-plaintext highlighter-rouge">SUCCESS_PARTIAL</code> (see <a href="#receive-responses">Receive responses</a>).</li> <li>
<code class="language-plaintext highlighter-rouge">3</code> <code class="language-plaintext highlighter-rouge">STOP</code>: Stop a query that is still executing.</li> <li>
<code class="language-plaintext highlighter-rouge">4</code> <code class="language-plaintext highlighter-rouge">NOREPLY_WAIT</code>: Wait for noreply operations to finish. The server will return a <code class="language-plaintext highlighter-rouge">WAIT_COMPLETE</code> response.</li> <li>
<code class="language-plaintext highlighter-rouge">5</code> <code class="language-plaintext highlighter-rouge">SERVER_INFO</code>: Ask for server information. The server will return a <code class="language-plaintext highlighter-rouge">SERVER_INFO</code> response.</li> </ul> <p><code class="language-plaintext highlighter-rouge">CONTINUE</code> and <code class="language-plaintext highlighter-rouge">STOP</code> should be sent on the same connection with the same token generated for that query’s <code class="language-plaintext highlighter-rouge">START</code> message.</p> <h3 id="sending-queries">Sending queries</h3> <p>To recap, sending a query to the server takes the following steps:</p> <ul> <li>Serialize the query as UTF8-encoded JSON</li> <li>Send the following data to the server: <ul> <li>The 8-byte unique query token</li> <li>The size of the JSON-serialized, UTF8-encoded wrapped query, as a 4-byte little-endian integer</li> <li>The wrapped query message (QueryType, serialized query and options)</li> </ul> </li> </ul> <p>The token is a unique integer per connection. Keeping a counter per connection is a simple way to implement it.</p> <p>So, our initial example query of:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.db("blog").table("users").filter({name: "Michel"})
</pre></div></div> <p>is sent as follows on the wire:</p> <table> <thead> <tr> <th>Step</th> <th>Semantic command</th> <th>Transmitted</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>query token</td> <td><code class="language-plaintext highlighter-rouge">00 00 00 00 00 00 00 01</code></td> </tr> <tr> <td>2</td> <td>length</td> <td><code class="language-plaintext highlighter-rouge">3C 00 00 00</code></td> </tr> <tr> <td>3</td> <td>query</td> <td><code class="language-plaintext highlighter-rouge">[1,[39,[[15,[[14,["blog"]],"users"]],{"name":"Michel"}]],{}]</code></td> </tr> </tbody> </table> <h3 id="wrapping-the-db-query-option">Wrapping the DB query option</h3> <p>If the <code class="language-plaintext highlighter-rouge">db</code> option is passed to the <code class="language-plaintext highlighter-rouge">run</code> command, its value must be a <code class="language-plaintext highlighter-rouge">DB</code> term. The query:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table("users").run({db: "blog"});
</pre></div></div> <p>should be sent as as if the argument to <code class="language-plaintext highlighter-rouge">db</code> was <code class="language-plaintext highlighter-rouge">r.db("blog")</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">[1,[15,["users"]],{"db":[14,["blog"]]}]
</pre></div></div> <h2 id="receive-responses">Receive responses</h2> <p>Responses from the server take the following form:</p> <ul> <li>The 8-byte unique query token the response corresponds to</li> <li>The size of the JSON-encoded response, as a 4-byte little-endian integer</li> <li>The JSON-encoded <code class="language-plaintext highlighter-rouge">Response</code> object</li> </ul> <p>The <code class="language-plaintext highlighter-rouge">Response</code> object will have the following fields:</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">t</code>: the <code class="language-plaintext highlighter-rouge">ResponseType</code>, as defined in <code class="language-plaintext highlighter-rouge">ql2.proto</code>
</li> <li>
<code class="language-plaintext highlighter-rouge">r</code>: data from the result, as a JSON array</li> <li>
<code class="language-plaintext highlighter-rouge">b</code>: a backtrace if <code class="language-plaintext highlighter-rouge">t</code> is an error type; this field will not be present otherwise</li> <li>
<code class="language-plaintext highlighter-rouge">p</code>: a profile if the global optarg <code class="language-plaintext highlighter-rouge">profile: true</code> was specified; this field will not be present otherwise</li> <li>
<code class="language-plaintext highlighter-rouge">n</code>: an optional array of <code class="language-plaintext highlighter-rouge">ResponseNote</code> values, as defined in <code class="language-plaintext highlighter-rouge">ql2.proto</code>
</li> </ul> <h3 id="response-types">Response types</h3> <p>These will be numeric values, corresponding to the types in <code class="language-plaintext highlighter-rouge">ql2.proto</code>.</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">1</code> <code class="language-plaintext highlighter-rouge">SUCCESS_ATOM</code>: The whole query has been returned and the result is in the first (and only) element of <code class="language-plaintext highlighter-rouge">r</code>.</li> <li>
<code class="language-plaintext highlighter-rouge">2</code> <code class="language-plaintext highlighter-rouge">SUCCESS_SEQUENCE</code>: Either the whole query has been returned in <code class="language-plaintext highlighter-rouge">r</code>, or the last section of a multi-response query has been returned.</li> <li>
<code class="language-plaintext highlighter-rouge">3</code> <code class="language-plaintext highlighter-rouge">SUCCESS_PARTIAL</code>: The query has returned a stream, which may or may not be complete. To retrieve more results for the query, send a <code class="language-plaintext highlighter-rouge">CONTINUE</code> message (see below).</li> <li>
<code class="language-plaintext highlighter-rouge">4</code> <code class="language-plaintext highlighter-rouge">WAIT_COMPLETE</code>: This <code class="language-plaintext highlighter-rouge">ResponseType</code> indicates all queries run in <code class="language-plaintext highlighter-rouge">noreply</code> mode have finished executing. <code class="language-plaintext highlighter-rouge">r</code> will be empty.</li> <li>
<code class="language-plaintext highlighter-rouge">5</code> <code class="language-plaintext highlighter-rouge">SERVER_INFO</code>: The response to a <code class="language-plaintext highlighter-rouge">SERVER_INFO</code> request. The data will be in the first (and only) element of <code class="language-plaintext highlighter-rouge">r</code>.</li> <li>
<code class="language-plaintext highlighter-rouge">16</code> <code class="language-plaintext highlighter-rouge">CLIENT_ERROR</code>: The server failed to run the query due to a bad client request. The error message will be in the first element of <code class="language-plaintext highlighter-rouge">r</code>.</li> <li>
<code class="language-plaintext highlighter-rouge">17</code> <code class="language-plaintext highlighter-rouge">COMPILE_ERROR</code>: The server failed to run the query due to an ReQL compilation error. The error message will be in the first element of <code class="language-plaintext highlighter-rouge">r</code>.</li> <li>
<code class="language-plaintext highlighter-rouge">18</code> <code class="language-plaintext highlighter-rouge">RUNTIME_ERROR</code>: The query compiled correctly, but failed at runtime. The error message will be in the first element of <code class="language-plaintext highlighter-rouge">r</code>.</li> </ul> <h3 id="response-notes">Response notes</h3> <p>The <code class="language-plaintext highlighter-rouge">n</code> field, if present, will be an array of one or more <code class="language-plaintext highlighter-rouge">ResponseNote</code> values, giving further information about the kind of the stream being returned. These will be numeric values, corresponding to the notes in <code class="language-plaintext highlighter-rouge">ql2.proto</code>.</p> <p>All of the response notes involve changefeeds; read <a href="../changefeeds/python/index.html">Changefeeds in RethinkDB</a> for more detailed information.</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">1</code> <code class="language-plaintext highlighter-rouge">SEQUENCE_FEED</code>: The stream is a changefeed.</li> <li>
<code class="language-plaintext highlighter-rouge">2</code> <code class="language-plaintext highlighter-rouge">ATOM_FEED</code>: The stream is a <em>point</em> changefeed, i.e., returning changes from a single document.</li> <li>
<code class="language-plaintext highlighter-rouge">3</code> <code class="language-plaintext highlighter-rouge">ORDER_BY_LIMIT_FEED</code>: The stream is a changefeed generated with an <code class="language-plaintext highlighter-rouge">order_by().limit()</code> query.</li> <li>
<code class="language-plaintext highlighter-rouge">4</code> <code class="language-plaintext highlighter-rouge">UNIONED_FEED</code>: The stream is a union of multiple changefeed types that cannot be collapsed to a single type, e.g., <code class="language-plaintext highlighter-rouge">r.table('test').changes().union(r.table('test').get(0).changes())</code>.</li> <li>
<code class="language-plaintext highlighter-rouge">5</code> <code class="language-plaintext highlighter-rouge">INCLUDES_STATES</code>: The stream is a changefeed that includes states notes, e.g., `{state: ‘initializing’}.</li> </ul> <h3 id="multipart-responses">Multipart responses</h3> <p>Streams and feeds are lazily-computed sequences, and return a <code class="language-plaintext highlighter-rouge">ResponseType</code> of <code class="language-plaintext highlighter-rouge">SUCCESS_PARTIAL</code> (<code class="language-plaintext highlighter-rouge">3</code>), with currently available data in the <code class="language-plaintext highlighter-rouge">r</code> array. When the driver receives a feed or stream, it should return a cursor (or an object with a cursor-like interface). <em>N.B.:</em> <code class="language-plaintext highlighter-rouge">SUCCESS_SEQUENCE</code> and <code class="language-plaintext highlighter-rouge">SUCCESS_PARTIAL</code> responses should be both be represented as cursors. Depending on the size of the query results and the time it takes to return them, you may receive either one <code class="language-plaintext highlighter-rouge">SUCCESS_SEQUENCE</code> result, or one or more <code class="language-plaintext highlighter-rouge">SUCCESS_PARTIAL</code> results followed by a final <code class="language-plaintext highlighter-rouge">SUCCESS_SEQUENCE</code> result.</p> <p>To retrieve more data for the cursor, the driver should send a query with a <code class="language-plaintext highlighter-rouge">QueryType</code> of <code class="language-plaintext highlighter-rouge">CONTINUE</code> <em>on the same connection with the same token.</em> As with other queries, this must be sent with the query token, the size of the query, and the query itself, simply <code class="language-plaintext highlighter-rouge">[2]</code>.</p> <table> <thead> <tr> <th>Step</th> <th>Element</th> <th>Transmitted bytes</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>token</td> <td><code class="language-plaintext highlighter-rouge">00 00 00 00 00 00 00 01</code></td> </tr> <tr> <td>2</td> <td>length</td> <td><code class="language-plaintext highlighter-rouge">03 00 00 00</code></td> </tr> <tr> <td>3</td> <td>query</td> <td><code class="language-plaintext highlighter-rouge">[2]</code></td> </tr> </tbody> </table> <p>You will receive another response of either type <code class="language-plaintext highlighter-rouge">SUCCESS_PARTIAL</code>, indicating there is still more data available, or <code class="language-plaintext highlighter-rouge">SUCCESS_SEQUENCE</code> if you have reached the end of the stream. (This will never be returned for a feed.) Note that these <code class="language-plaintext highlighter-rouge">ResponseType</code>s can be returned without data (an empty array as the <code class="language-plaintext highlighter-rouge">r</code> value). A driver can send <code class="language-plaintext highlighter-rouge">CONTINUE</code> to fetch the next batch of a sequence as soon as the response is received.</p> <p>To close a cursor and stop receiving data from the stream or feed, send a query with a <code class="language-plaintext highlighter-rouge">QueryType</code> of <code class="language-plaintext highlighter-rouge">STOP</code> on the same connection with the same token.</p> <h2 id="notes-on-connections">Notes on connections</h2> <p>Starting with RethinkDB 2.0 (<code class="language-plaintext highlighter-rouge">V0_4</code>), the server will process multiple queries in parallel rather than sequentially, and there is no guarantee that a read following a write on the same connection will “see” the results of the write as long as it’s successful. (Previous versions of the server would process multiple queries on the same connection sequentially.)</p> <p>You should not release a connection in the pool as soon as you receive a response. Only release the connection when you receive a response of a type other than <code class="language-plaintext highlighter-rouge">SUCCESS_PARTIAL</code>.</p> <h2 id="get-help">Get help</h2> <p>You can ask questions and get notes on changes introduced in new versions of RethinkDB on the <a href="https://groups.google.com/forum/?fromgroups#!forum/rethinkdb-dev">RethinkDB-Dev Google Group</a>. You can also visit the <a href="irc://irc.freenode.org/rethinkdb.html">RethinkDB IRC Channel</a>, where core developers and other driver developers frequently hang out. Also, you can ask questions on <a href="http://stackoverflow.com/">Stack Overflow</a> using the tag “<a href="http://stackoverflow.com/questions/tagged/rethinkdb">rethinkdb</a>.”</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; RethinkDB contributors<br>Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.<br>
    <a href="https://rethinkdb.com/docs/writing-drivers/" class="_attribution-link">https://rethinkdb.com/docs/writing-drivers/</a>
  </p>
</div>
