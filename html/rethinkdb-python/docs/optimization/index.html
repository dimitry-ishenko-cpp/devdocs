<h1 class="title">Optimizing query performance</h1> <div class="alg-content">
<p>Understanding how RethinkDB parallelizes queries can improve the performance of your applications—sometimes significantly.</p> <div class="toc">  <ul id="markdown-toc"> <li><a href="#sharding" id="markdown-toc-sharding">Sharding</a></li> <li><a href="#replication" id="markdown-toc-replication">Replication</a></li> <li><a href="#proxy-nodes" id="markdown-toc-proxy-nodes">Proxy nodes</a></li> </ul> </div> <h2 id="sharding">Sharding</h2> <p>The basic rule is:</p> <p><strong>Processing happens where the data is until an operation needs to combine it.</strong></p> <p>In other words, ReQL queries that involve multiple shards will be processed on those shards whenever possible.</p> <p>Let’s follow the processing of a simple query. (This example uses JavaScript, but the commands are virtually identical in other languages.)</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table('users').filter({role: 'admin'}).run(conn, callback);
</pre></div></div> <p>RethinkDB will process this query with the following steps:</p> <ol> <li>The query is sent to a server for execution.</li> <li>The <a href="https://rethinkdb.com/api/javascript/filter/">filter</a> operation is performed in parallel on each shard of the <code class="language-plaintext highlighter-rouge">users</code> table.</li> <li>The result of the <code class="language-plaintext highlighter-rouge">filter</code> is sent from the shards to the query server and combined.</li> <li>The result is returned to the client.</li> </ol> <p>However, an <a href="https://rethinkdb.com/api/javascript/order_by/">orderBy</a> query will be executed differently.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table('users').orderBy('username').run(conn, callback);
</pre></div></div> <ol> <li>The query is sent to a server for execution.</li> <li>Data is sent from the shards to the query server and combined.</li> <li>The <code class="language-plaintext highlighter-rouge">orderBy</code> operation is performed on the query server.</li> <li>The result is returned to the client.</li> </ol> <p>An <code class="language-plaintext highlighter-rouge">orderBy</code> operation (without an index) can’t be distributed across the shards for parallel execution—it needs all the data in the table to perform a sort.</p> <p>The following commands can be distributed across shards:</p> <ul> <li>Selections: <code class="language-plaintext highlighter-rouge">between</code>, <code class="language-plaintext highlighter-rouge">get_all</code>, <code class="language-plaintext highlighter-rouge">filter</code>
</li> <li>
<a href="../map-reduce/index.html">Map-reduce</a> operations: <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">concat_map</code>, <code class="language-plaintext highlighter-rouge">reduce</code>
</li> <li><code class="language-plaintext highlighter-rouge">group</code></li> <li>Derived terms: <code class="language-plaintext highlighter-rouge">pluck</code>, <code class="language-plaintext highlighter-rouge">with_field</code>, <code class="language-plaintext highlighter-rouge">count</code>, <code class="language-plaintext highlighter-rouge">eq_join</code>
</li> <li>
<code class="language-plaintext highlighter-rouge">order_by</code> <em>with</em> indexes</li> </ul> <p>The order in which you chain ReQL commands can affect performance. For an example, imagine combining the previous two queries to return an ordered list of names of admin users. The <code class="language-plaintext highlighter-rouge">filter</code> operation can be distributed across shards, but the <code class="language-plaintext highlighter-rouge">orderBy</code> operation cannot. So this query:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table('users').filter({role: 'admin'}).orderBy('name').run(conn, callback);
</pre></div></div> <p>Is preferable to this query:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table('users').orderBy('name').filter({role: 'admin'}).run(conn, callback);
</pre></div></div> <p>Commands that stop subsequent commands from being parallelized include:</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">order_by</code> (with or without indexes)</li> <li><code class="language-plaintext highlighter-rouge">distinct</code></li> <li><code class="language-plaintext highlighter-rouge">eq_join</code></li> <li>
<code class="language-plaintext highlighter-rouge">reduce</code>, <code class="language-plaintext highlighter-rouge">fold</code>
</li> <li>
<code class="language-plaintext highlighter-rouge">limit</code>, <code class="language-plaintext highlighter-rouge">skip</code>, <code class="language-plaintext highlighter-rouge">slice</code>
</li> <li>
<code class="language-plaintext highlighter-rouge">max</code>, <code class="language-plaintext highlighter-rouge">min</code>, <code class="language-plaintext highlighter-rouge">avg</code>
</li> </ul> <p>Any command that requires the results from the shards to be combined on the server executing the query will finish executing on that server rather than being distributed. Optimize your queries by putting commands that can execute in parallel <em>before</em> commands that combine the result set whenever possible.</p> <h2 id="replication">Replication</h2> <p>RethinkDB’s defaults tend to prioritize safety over performance. One of those defaults is that queries will be sent to the primary replicas for shards, which will always have current data (although that data may be returned to a query before it’s been committed to disk).</p> <p>You can increase the performance of a query by using the <code class="language-plaintext highlighter-rouge">outdated</code> read mode, which allows the cluster to return values from memory on arbitrarily-selected replicas.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table('users', {readMode: 'outdated'}).
  filter({role: 'admin'}).run(conn, callback);
</pre></div></div> <p>While <code class="language-plaintext highlighter-rouge">outdated</code> reads are faster, they are the least consistent. For more information on this option, read “Balancing safety and performance” in the <a href="../consistency/index.html#balancing-safety-and-performance">Consistency guarantees</a> documentation.</p> <h2 id="proxy-nodes">Proxy nodes</h2> <p>Starting RethinkDB with the <code class="language-plaintext highlighter-rouge">proxy</code> command turns a server into a <em>proxy node,</em> which acts as a query router. This increases cluster performance by reducing intracluster traffic and, if you’re using changefeeds, de-duplicating feed messages.</p> <p>For more information about proxy nodes, read “Running a proxy node” under <a href="../sharding-and-replication/index.html#running-a-proxy-node">Scaling, sharding and replication</a>.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; RethinkDB contributors<br>Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.<br>
    <a href="https://rethinkdb.com/docs/optimization/" class="_attribution-link">https://rethinkdb.com/docs/optimization/</a>
  </p>
</div>
