<h1>Built In Functions</h1> <div id="front-matter"> <div id="minitoc-area"> <ul class="minitoc"> <li> <a href="#built-in-functions">Introduction</a> </li> <li> <a href="#dynamic-invokers">Dynamic Invokers</a> </li> <li> <a href="#eval-functions">Eval Functions</a> <ul class="minitoc"> <li> <a href="#avg">AVG</a> </li> <li> <a href="#bagtostring">BagToString</a> </li> <li> <a href="#bagtotuple">BagToTuple</a> </li> <li> <a href="#bloom">Bloom</a> </li> <li> <a href="#concat">CONCAT</a> </li> <li> <a href="#count">COUNT</a> </li> <li> <a href="#count-star">COUNT_STAR</a> </li> <li> <a href="#diff">DIFF</a> </li> <li> <a href="#isempty">IsEmpty</a> </li> <li> <a href="#max">MAX</a> </li> <li> <a href="#min">MIN</a> </li> <li> <a href="#plucktuple">PluckTuple</a> </li> <li> <a href="#size">SIZE</a> </li> <li> <a href="#subtract">SUBTRACT</a> </li> <li> <a href="#sum">SUM</a> </li> <li> <a href="#in">IN</a> </li> <li> <a href="#tokenize">TOKENIZE</a> </li> </ul> </li> <li> <a href="#load-store-functions">Load/Store Functions</a> <ul class="minitoc"> <li> <a href="#handling-compression">Handling Compression</a> </li> <li> <a href="#binstorage">BinStorage</a> </li> <li> <a href="#jsonloadstore">JsonLoader, JsonStorage</a> </li> <li> <a href="#pigdump">PigDump</a> </li> <li> <a href="#pigstorage">PigStorage</a> </li> <li> <a href="#textloader">TextLoader</a> </li> <li> <a href="#HBaseStorage">HBaseStorage</a> </li> <li> <a href="#AvroStorage">AvroStorage</a> </li> <li> <a href="#TrevniStorage">TrevniStorage</a> </li> <li> <a href="#AccumuloStorage">AccumuloStorage</a> </li> <li> <a href="#OrcStorage">OrcStorage</a> </li> </ul> </li> <li> <a href="#math-functions">Math Functions</a> <ul class="minitoc"> <li> <a href="#abs">ABS</a> </li> <li> <a href="#acos">ACOS</a> </li> <li> <a href="#asin">ASIN</a> </li> <li> <a href="#atan">ATAN</a> </li> <li> <a href="#cbrt">CBRT</a> </li> <li> <a href="#ceil">CEIL</a> </li> <li> <a href="#cos">COS</a> </li> <li> <a href="#cosh">COSH</a> </li> <li> <a href="#exp">EXP</a> </li> <li> <a href="#floor">FLOOR</a> </li> <li> <a href="#log">LOG</a> </li> <li> <a href="#log10">LOG10</a> </li> <li> <a href="#random">RANDOM</a> </li> <li> <a href="#round">ROUND</a> </li> <li> <a href="#round_to">ROUND_TO</a> </li> <li> <a href="#sin">SIN</a> </li> <li> <a href="#sinh">SINH</a> </li> <li> <a href="#sqrt">SQRT</a> </li> <li> <a href="#tan">TAN</a> </li> <li> <a href="#tanh">TANH</a> </li> </ul> </li> <li> <a href="#string-functions">String Functions</a> <ul class="minitoc"> <li> <a href="#endswith">ENDSWITH</a> </li> <li> <a href="#equalsignorecase">EqualsIgnoreCase</a> </li> <li> <a href="#indexof">INDEXOF</a> </li> <li> <a href="#last-index-of">LAST_INDEX_OF</a> </li> <li> <a href="#lcfirst">LCFIRST</a> </li> <li> <a href="#lower">LOWER</a> </li> <li> <a href="#ltrim">LTRIM</a> </li> <li> <a href="#regex-extract">REGEX_EXTRACT </a> </li> <li> <a href="#regex-extract-all">REGEX_EXTRACT_ALL </a> </li> <li> <a href="#regex-search">REGEX_SEARCH</a> </li> <li> <a href="#replace">REPLACE</a> </li> <li> <a href="#rtrim">RTRIM</a> </li> <li> <a href="#sprintf">SPRINTF</a> </li> <li> <a href="#startswith">STARTSWITH</a> </li> <li> <a href="#strsplit">STRSPLIT</a> </li> <li> <a href="#strsplittobag">STRSPLITTOBAG</a> </li> <li> <a href="#substring">SUBSTRING</a> </li> <li> <a href="#trim">TRIM</a> </li> <li> <a href="#ucfirst">UCFIRST</a> </li> <li> <a href="#upper">UPPER</a> </li> <li> <a href="#uniqueid">UniqueID</a> </li> </ul> </li> <li> <a href="#datetime-functions">Datetime Functions</a> <ul class="minitoc"> <li> <a href="#add-duration">AddDuration</a> </li> <li> <a href="#current-time">CurrentTime</a> </li> <li> <a href="#days-between">DaysBetween</a> </li> <li> <a href="#get-day">GetDay</a> </li> <li> <a href="#get-hour">GetHour</a> </li> <li> <a href="#get-milli-second">GetMilliSecond</a> </li> <li> <a href="#get-minute">GetMinute</a> </li> <li> <a href="#get-month">GetMonth</a> </li> <li> <a href="#get-second">GetSecond</a> </li> <li> <a href="#get-week">GetWeek</a> </li> <li> <a href="#get-week-year">GetWeekYear</a> </li> <li> <a href="#get-year">GetYear</a> </li> <li> <a href="#hours-between">HoursBetween</a> </li> <li> <a href="#milli-seconds-between">MilliSecondsBetween</a> </li> <li> <a href="#minutes-between">MinutesBetween</a> </li> <li> <a href="#months-between">MonthsBetween</a> </li> <li> <a href="#seconds-between">SecondsBetween</a> </li> <li> <a href="#subtract-duration">SubtractDuration</a> </li> <li> <a href="#to-date">ToDate</a> </li> <li> <a href="#to-milli-seconds">ToMilliSeconds</a> </li> <li> <a href="#to-string">ToString</a> </li> <li> <a href="#to-unix-time">ToUnixTime</a> </li> <li> <a href="#weeks-between">WeeksBetween</a> </li> <li> <a href="#years-between">YearsBetween</a> </li> </ul> </li> <li> <a href="#bag-tuple-functions">Tuple, Bag, Map Functions</a> <ul class="minitoc"> <li> <a href="#totuple">TOTUPLE</a> </li> <li> <a href="#tobag">TOBAG</a> </li> <li> <a href="#tomap">TOMAP</a> </li> <li> <a href="#topx">TOP</a> </li> </ul> </li> <li> <a href="#hive-udf">Hive UDF</a> <ul class="minitoc"> <li> <a href="#Syntax-N13182">Syntax</a> </li> <li> <a href="#Terms-N1319A">Terms</a> </li> <li> <a href="#Example-N131CA">Example</a> </li> </ul> </li> </ul> </div> </div>  <h2 id="built-in-functions">Introduction</h2> <div class="section"> <p> Pig comes with a set of built in functions (the eval, load/store, math, string, bag and tuple functions). Two main properties differentiate built in functions from <a href="udf.html">user defined functions</a> (UDFs). First, built in functions don't need to be registered because Pig knows where they are. Second, built in functions don't need to be qualified when they are used because Pig knows where to find them. </p> </div>    <h2 id="dynamic-invokers">Dynamic Invokers</h2> <div class="section"> <p>Often you may need to use a simple function that is already provided by standard Java libraries, but for which a <a href="udf.html">user defined functions</a> (UDF) has not been written. Dynamic invokers allow you to refer to Java functions without having to wrap them in custom UDFs, at the cost of doing some Java reflection on every function call. </p> <pre class="code">
...
DEFINE UrlDecode InvokeForString('java.net.URLDecoder.decode', 'String String'); 
encoded_strings = LOAD 'encoded_strings.txt' as (encoded:chararray); 
decoded_strings = FOREACH encoded_strings GENERATE UrlDecode(encoded, 'UTF-8'); 
...
</pre> <p>Currently, dynamic invokers can be used for any static function that: </p> <ul> <li>Accepts no arguments or accepts some combination of strings, ints, longs, doubles, floats, or arrays with these same types </li> <li>Returns a string, an int, a long, a double, or a float</li> </ul> <p>Only primitives can be used for numbers; no capital-letter numeric classes can be used as arguments. Depending on the return type, a specific kind of invoker must be used: InvokeForString, InvokeForInt, InvokeForLong, InvokeForDouble, or InvokeForFloat. </p> <p>The <a href="basic.html#define">DEFINE</a> statement is used to bind a keyword to a Java method, as above. The first argument to the InvokeFor* constructor is the full path to the desired method. The second argument is a space-delimited ordered list of the classes of the method arguments. This can be omitted or an empty string if the method takes no arguments. Valid class names are string, long, float, double, and int. Invokers can also work with array arguments, represented in Pig as DataBags of single-tuple elements. Simply refer to string[], for example. Class names are not case sensitive. </p> <p>The ability to use invokers on methods that take array arguments makes methods like those in org.apache.commons.math.stat.StatUtils available (for processing the results of grouping your datasets, for example). This is helpful, but a word of caution: the resulting UDF will not be optimized for Hadoop, and the very significant benefits one gains from implementing the Algebraic and Accumulator interfaces are lost here. Be careful if you use invokers this way.</p> </div>    <h2 id="eval-functions">Eval Functions</h2> <div class="section">  <h3 id="avg">AVG</h3> <p>Computes the average of the numeric values in a single-column bag. </p>  <h4 id="Syntax">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>AVG(expression)</p> </td> </tr> </table>  <h4 id="Terms">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>Any expression whose result is a bag. The elements of the bag should be data type int, long, float, double, bigdecimal, biginteger or bytearray.</p> </td> </tr> </table>  <h4 id="Usage">Usage</h4> <p>Use the AVG function to compute the average of the numeric values in a single-column bag. AVG requires a preceding GROUP ALL statement for global averages and a GROUP BY statement for group averages.</p> <p>The AVG function ignores NULL values. </p>  <h4 id="Example">Example</h4> <p>In this example the average GPA for each student is computed (see the <a href="basic.html#group">GROUP</a> operator for information about the field names in relation B).</p> <pre class="code">
A = LOAD 'student.txt' AS (name:chararray, term:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

C = FOREACH B GENERATE A.name, AVG(A.gpa);

DUMP C;
({(John),(John),(John),(John)},3.850000023841858)
({(Mary),(Mary),(Mary),(Mary)},3.925000011920929)
</pre>  <h4 id="Types+Tables">Types Tables</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p>int </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>float </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>bigdecimal </p> </td> <td colspan="1" rowspan="1"> <p>biginteger </p> </td> <td colspan="1" rowspan="1"> <p>chararray </p> </td> <td colspan="1" rowspan="1"> <p>bytearray </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>AVG </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>bigdecimal *</p> </td> <td colspan="1" rowspan="1"> <p>bigdecimal *</p> </td> <td colspan="1" rowspan="1"> <p>error </p> </td> <td colspan="1" rowspan="1"> <p>cast as double </p> </td> </tr> </table> <p>* Average values for datatypes bigdecimal and biginteger have precision setting <a href="http://docs.oracle.com/javase/7/docs/api/java/math/MathContext.html#DECIMAL128">java.math.MathContext.DECIMAL128</a>.</p>  <h3 id="bagtostring">BagToString</h3> <p>Concatenate the elements of a Bag into a chararray string, placing an optional delimiter between each value.</p>  <h4 id="Syntax-N10162">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>BagToString(vals:bag [, delimiter:chararray])</p> </td> </tr> </table>  <h4 id="Terms-N10176">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>vals</p> </td> <td colspan="1" rowspan="1"> <p>A bag of arbitrary values. They will each be cast to chararray if they are not already.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>delimiter</p> </td> <td colspan="1" rowspan="1"> <p>A chararray value to place between elements of the bag; defaults to underscore <span class="codefrag">'_'</span>.</p> </td> </tr> </table>  <h4 id="Usage-N101A1">Usage</h4> <p>BagToString creates a single string from the elements of a bag, similar to SQL's <span class="codefrag">GROUP_CONCAT</span> function. Keep in mind the following:</p> <ul> <li>Bags can be of arbitrary size, while strings in Java cannot: you will either exhaust available memory or exceed the maximum number of characters (about 2 billion). One of the worst features a production job can have is thresholding behavior: everything will seem nearly fine until the data size of your largest bag grows from nearly-too-big to just-barely-too-big.</li> <li>Bags are disordered unless you explicitly apply a nested <span class="codefrag">ORDER BY</span> operation as demonstrated below. A nested <span class="codefrag">FOREACH</span> will preserve ordering, letting you order by one combination of fields then project out just the values you'd like to concatenate.</li> <li>The default string conversion is applied to each element. If the bags contents are not atoms (tuple, map, etc), this may be not be what you want. Use a nested <span class="codefrag">FOREACH</span> to format values and then compose them with BagToString as shown below</li> </ul> <p>Examples:</p> <table class="ForrestTable"> <tr> <th colspan="1" rowspan="1">vals</th> <th colspan="1" rowspan="1">delimiter</th> <th colspan="1" rowspan="1">BagToString(vals, delimiter)</th> <th colspan="1" rowspan="1">Notes</th> </tr> <tr> <td colspan="1" rowspan="1"><span class="codefrag">{('BOS'),('NYA'),('BAL')}</span></td> <td colspan="1" rowspan="1"></td> <td colspan="1" rowspan="1"><span class="codefrag">BOS_NYA_BAL</span></td> <td colspan="1" rowspan="1">If only one argument is given, the field is delimited with underscore characters</td> </tr> <tr> <td colspan="1" rowspan="1"><span class="codefrag">{('BOS'),('NYA'),('BAL')}</span></td> <td colspan="1" rowspan="1"><span class="codefrag">'|'</span></td> <td colspan="1" rowspan="1"><span class="codefrag">BOS|NYA|BAL</span></td> <td colspan="1" rowspan="1">But you can supply your own delimiter</td> </tr> <tr> <td colspan="1" rowspan="1"><span class="codefrag">{('BOS'),('NYA'),('BAL')}</span></td> <td colspan="1" rowspan="1"><span class="codefrag">''</span></td> <td colspan="1" rowspan="1"><span class="codefrag">BOSNYABAL</span></td> <td colspan="1" rowspan="1">Use an explicit empty string to just smush everything together</td> </tr> <tr> <td colspan="1" rowspan="1"><span class="codefrag">{(1),(2),(3)}</span></td> <td colspan="1" rowspan="1"><span class="codefrag">'|'</span></td> <td colspan="1" rowspan="1"><span class="codefrag">1|2|3</span></td> <td colspan="1" rowspan="1">Elements are type-converted for you (but see examples below)</td> </tr> </table>  <h4 id="Examples">Examples</h4> <p>Simple delimited strings are simple:</p> <pre class="code">
team_parks = LOAD 'team_parks' AS (team_id:chararray, park_id:chararray, years:bag{(year_id:int)});

-- BOS     BOS07   {(1995),(1997),(1996),(1998),(1999)}
-- NYA     NYC16   {(1995),(1999),(1998),(1997),(1996)}
-- NYA     NYC17   {(1998)}
-- SDN     HON01   {(1997)}
-- SDN     MNT01   {(1996),(1999)}
-- SDN     SAN01   {(1999),(1997),(1998),(1995),(1996)}

team_parkslist = FOREACH (GROUP team_parks BY team_id) GENERATE
  group AS team_id, BagToString(team_parks.park_id, ';');

-- BOS     BOS07
-- NYA     NYC17;NYC16
-- SDN     SAN01;MNT01;HON01
</pre> <p>The default handling of complex elements works, but probably isn't what you want.</p> <pre class="code">
team_parkyearsugly = FOREACH (GROUP team_parks BY team_id) GENERATE
  group AS team_id,
  BagToString(team_parks.(park_id, years));

-- BOS     BOS07_{(1995),(1997),(1996),(1998),(1999)}
-- NYA     NYC17_{(1998)}_NYC16_{(1995),(1999),(1998),(1997),(1996)}
-- SDN     SAN01_{(1999),(1997),(1998),(1995),(1996)}_MNT01_{(1996),(1999)}_HON01_{(1997)}
</pre> <p>Instead, assemble it in pieces. In step 2, we sort on one field but process another; it remains in the sorted order.</p> <pre class="code">
team_park_yearslist = FOREACH team_parks {
  years_o = ORDER years BY year_id;
  GENERATE team_id, park_id, SIZE(years_o) AS n_years, BagToString(years_o, '/') AS yearslist;
};
team_parkyearslist = FOREACH (GROUP team_park_yearslist BY team_id) {
  tpy_o = ORDER team_park_yearslist BY n_years DESC, park_id ASC;
  tpy_f = FOREACH tpy_o GENERATE CONCAT(park_id, ':', yearslist);
  GENERATE group AS team_id, BagToString(tpy_f, ';');
  };

-- BOS     BOS07:1995/1996/1997/1998/1999
-- NYA     NYC16:1995/1996/1997/1998/1999;NYC17:1998
-- SDN     SAN01:1995/1996/1997/1998/1999;MNT01:1996/1999;HON01:1997
</pre>  <h3 id="bagtotuple">BagToTuple</h3> <p>Un-nests the elements of a bag into a tuple.</p>  <h4 id="Syntax-N10268">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>BagToTuple(expression)</p> </td> </tr> </table>  <h4 id="Terms-N1027C">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with data type bag.</p> </td> </tr> </table>  <h4 id="Usage-N10299">Usage</h4> <p>BagToTuple creates a tuple from the elements of a bag. It removes only the first level of nesting; it does not recursively un-nest nested bags. Unlike FLATTEN, BagToTuple will not generate multiple output records per input record. </p>  <h4 id="Examples-N102A3">Examples</h4> <p>In this example, a bag containing tuples with one field is converted to a tuple.</p> <pre class="code">
A = LOAD 'bag_data' AS (B1:bag{T1:tuple(f1:chararray)});

DUMP A;
({('a'),('b'),('c')})
({('d'),('e'),('f')})

X = FOREACH A GENERATE BagToTuple(B1);

DUMP X;
(('a','b','c'))
(('d','e','f'))
</pre> <p>In this example, a bag containing tuples with two fields is converted to a tuple.</p> <pre class="code">
A = LOAD 'bag_data' AS (B1:bag{T1:tuple(f1:int,f2:int)});

DUMP A;
({(4,1),(7,8),(4,9)})
({(5,8),(4,3),(3,8)})

X = FOREACH A GENERATE BagToTuple(B1);

DUMP X;
((4,1,7,8,4,9))
((5,8,4,3,3,8))
</pre>  <h3 id="bloom">Bloom</h3> <p>Bloom filters are a common way to select a limited set of records before moving data for a join or other heavy weight operation.</p>  <h4 id="Syntax-N102C2">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>BuildBloom(String hashType, String mode, String vectorSize, String nbHash)</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>Bloom(String filename)</p> </td> </tr> </table>  <h4 id="Terms-N102E1">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>hashtype</p> </td> <td colspan="1" rowspan="1"> <p>The type of hash function to use. Valid values for the hash functions are 'jenkins' and 'murmur'.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>mode</p> </td> <td colspan="1" rowspan="1"> <p>Will be ignored, though by convention it should be "fixed" or "fixedsize"</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>vectorSize</p> </td> <td colspan="1" rowspan="1"> <p>The number of bits in the bloom filter.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>nbHash</p> </td> <td colspan="1" rowspan="1"> <p>The number of hash functions used in constructing the bloom filter.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>filename</p> </td> <td colspan="1" rowspan="1"> <p>File containing the serialized Bloom filter.</p> </td> </tr> </table> <p>See <a href="http://en.wikipedia.org/wiki/Bloom_filter">Bloom Filter</a> for a discussion of how to select the number of bits and the number of hash functions. </p>  <h4 id="Usage-N1033D">Usage</h4> <p>Bloom filters are a common way to select a limited set of records before moving data for a join or other heavy weight operation. For example, if one wanted to join a very large data set L with a smaller set S, and it was known that the number of keys in L that will match with S is small, building a bloom filter on S and then applying it to L before the join can greatly reduce the number of records from L that have to be moved from the map to the reduce, thus speeding the join. </p> <p>The implementation uses Hadoop's bloom filters (org.apache.hadoop.util.bloom.BloomFilter) internally. </p>  <h4 id="Examples-N1034A">Examples</h4> <pre class="code">
  define bb BuildBloom('128', '3', 'jenkins');
  small = load 'S' as (x, y, z);
  grpd = group small all;
  fltrd = foreach grpd generate bb(small.x);
  store fltrd in 'mybloom';
  exec;
  define bloom Bloom('mybloom');
  large = load 'L' as (a, b, c);
  flarge = filter large by bloom(L.a);
  joined = join small by x, flarge by a;
  store joined into 'results';
</pre>  <h3 id="concat">CONCAT</h3> <p>Concatenates two or more expressions of identical type.</p>  <h4 id="Syntax-N10361">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>CONCAT (expression, expression, [...expression])</p> </td> </tr> </table>  <h4 id="Terms-N10376">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>Any expression.</p> </td> </tr> </table>  <h4 id="Usage-N10393">Usage</h4> <p>Use the CONCAT function to concatenate two or more expressions. The result values of the expressions must have identical types.</p> <p>If any subexpression is null, the resulting expression is null.</p>  <h4 id="Example-N103A0">Example</h4> <p>In this example, fields f1, an underscore string literal, f2 and f3 are concatenated.</p> <pre class="code">
A = LOAD 'data' as (f1:chararray, f2:chararray, f3:chararray);

DUMP A;
(apache,open,source)
(hadoop,map,reduce)
(pig,pig,latin)

X = FOREACH A GENERATE CONCAT(f1, '_', f2,f3);

DUMP X;
(apache_opensource)
(hadoop_mapreduce)
(pig_piglatin)
</pre>  <h3 id="count">COUNT</h3> <p>Computes the number of elements in a bag. </p>  <h4 id="Syntax-N103BA">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>COUNT(expression) </p> </td> </tr> </table>  <h4 id="Terms-N103CE">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with data type bag.</p> </td> </tr> </table>  <h4 id="Usage-N103EA">Usage</h4> <p>Use the COUNT function to compute the number of elements in a bag. COUNT requires a preceding GROUP ALL statement for global counts and a GROUP BY statement for group counts.</p> <p> The COUNT function follows syntax semantics and ignores nulls. What this means is that a tuple in the bag will not be counted if the FIRST FIELD in this tuple is NULL. If you want to include NULL values in the count computation, use <a href="#count-star">COUNT_STAR</a>. </p> <p> Note: You cannot use the tuple designator (*) with COUNT; that is, COUNT(*) will not work. </p>  <h4 id="Example-N103FE">Example</h4> <p>In this example the tuples in the bag are counted (see the <a href="basic.html#group">GROUP</a> operator for information about the field names in relation B).</p> <pre class="code">
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

X = FOREACH B GENERATE COUNT(A);

DUMP X;
(1L)
(2L)
(1L)
(2L)
</pre>  <h4 id="Types+Tables-N10410">Types Tables</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p>int </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>float </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>chararray </p> </td> <td colspan="1" rowspan="1"> <p>bytearray </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>COUNT </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> </tr> </table>  <h3 id="count-star">COUNT_STAR</h3> <p>Computes the number of elements in a bag. </p>  <h4 id="Syntax-N1049A">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>COUNT_STAR(expression) </p> </td> </tr> </table>  <h4 id="Terms-N104AF">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with data type bag.</p> </td> </tr> </table>  <h4 id="Usage-N104CC">Usage</h4> <p>Use the COUNT_STAR function to compute the number of elements in a bag. COUNT_STAR requires a preceding GROUP ALL statement for global counts and a GROUP BY statement for group counts.</p> <p>COUNT_STAR includes NULL values in the count computation (unlike <a href="#count">COUNT</a>, which ignores NULL values). </p>  <h4 id="Example-N104DD">Example</h4> <p>In this example COUNT_STAR is used to count the tuples in a bag.</p> <pre class="code">
X = FOREACH B GENERATE COUNT_STAR(A);
</pre>  <h3 id="diff">DIFF</h3> <p>Compares two fields in a tuple.</p>  <h4 id="Syntax-N104F7">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>DIFF (expression, expression)</p> </td> </tr> </table>  <h4 id="Terms-N1050B">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with any data type.</p> </td> </tr> </table>  <h4 id="Usage-N10528">Usage</h4> <p>The DIFF function takes two bags as arguments and compares them. Any tuples that are in one bag but not the other are returned in a bag. If the bags match, an empty bag is returned. If the fields are not bags then they will be wrapped in tuples and returned in a bag if they do not match, or an empty bag will be returned if the two records match. The implementation assumes that both bags being passed to the DIFF function will fit entirely into memory simultaneously. If this is not the case the UDF will still function but it will be VERY slow.</p>  <h4 id="Example-N10532">Example</h4> <p>In this example DIFF compares the tuples in two bags.</p> <pre class="code">
A = LOAD 'bag_data' AS (B1:bag{T1:tuple(t1:int,t2:int)},B2:bag{T2:tuple(f1:int,f2:int)});

DUMP A;
({(8,9),(0,1)},{(8,9),(1,1)})
({(2,3),(4,5)},{(2,3),(4,5)})
({(6,7),(3,7)},{(2,2),(3,7)})

DESCRIBE A;
a: {B1: {T1: (t1: int,t2: int)},B2: {T2: (f1: int,f2: int)}}

X = FOREACH A GENERATE DIFF(B1,B2);

grunt&gt; dump x;
({(0,1),(1,1)})
({})
({(6,7),(2,2)})
</pre>  <h3 id="isempty">IsEmpty</h3> <p>Checks if a bag or map is empty.</p>  <h4 id="Syntax-N1054B">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>IsEmpty(expression)</p> </td> </tr> </table>  <h4 id="Terms-N1055F">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with any data type.</p> </td> </tr> </table>  <h4 id="Usage-N1057B">Usage</h4> <p>The IsEmpty function checks if a bag or map is empty (has no data). The function can be used to filter data.</p>  <h4 id="Example-N10584">Example</h4> <p>In this example all students with an SSN but no name are located.</p> <pre class="code">
SSN = load 'ssn.txt' using PigStorage() as (ssn:long);

SSN_NAME = load 'students.txt' using PigStorage() as (ssn:long, name:chararray);

/* do a cogroup of SSN with SSN_Name */
X = COGROUP SSN by ssn, SSN_NAME by ssn;

/* only keep those ssn's for which there is no name */
Y = filter X by IsEmpty(SSN_NAME);
</pre>  <h3 id="max">MAX</h3> <p>Computes the maximum of the numeric values or chararrays in a single-column bag. MAX requires a preceding GROUP ALL statement for global maximums and a GROUP BY statement for group maximums.</p>  <h4 id="Syntax-N1059D">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>MAX(expression) </p> </td> </tr> </table>  <h4 id="Terms-N105B1">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with data types int, long, float, double, bigdecimal, biginteger, chararray, datetime or bytearray.</p> </td> </tr> </table>  <h4 id="Usage-N105CD">Usage</h4> <p>Use the MAX function to compute the maximum of the numeric values or chararrays in a single-column bag.</p> <p>The MAX function ignores NULL values.</p>  <h4 id="Example-N105DA">Example</h4> <p>In this example the maximum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</p> <pre class="code">
A = LOAD 'student' AS (name:chararray, session:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

X = FOREACH B GENERATE group, MAX(A.gpa);

DUMP X;
(John,4.0F)
(Mary,4.0F)
</pre>  <h4 id="Types+Tables-N105E8">Types Tables</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p>int </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>float </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>bigdecimal </p> </td> <td colspan="1" rowspan="1"> <p>biginteger </p> </td> <td colspan="1" rowspan="1"> <p>chararray </p> </td> <td colspan="1" rowspan="1"> <p>datetime </p> </td> <td colspan="1" rowspan="1"> <p>bytearray </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>MAX </p> </td> <td colspan="1" rowspan="1"> <p>int </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>float </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>bigdecimal </p> </td> <td colspan="1" rowspan="1"> <p>biginteger </p> </td> <td colspan="1" rowspan="1"> <p>chararray </p> </td> <td colspan="1" rowspan="1"> <p>datetime </p> </td> <td colspan="1" rowspan="1"> <p>cast as double</p> </td> </tr> </table>  <h3 id="min">MIN</h3> <p>Computes the minimum of the numeric values or chararrays in a single-column bag. MIN requires a preceding GROUP… ALL statement for global minimums and a GROUP … BY statement for group minimums.</p>  <h4 id="Syntax-N106A2">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>MIN(expression)</p> </td> </tr> </table>  <h4 id="Terms-N106B6">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with data types int, long, float, double, bigdecimal, biginteger, chararray, datetime or bytearray.</p> </td> </tr> </table>  <h4 id="Usage-N106D2">Usage</h4> <p>Use the MIN function to compute the minimum of a set of numeric values or chararrays in a single-column bag.</p> <p>The MIN function ignores NULL values.</p>  <h4 id="Example-N106DF">Example</h4> <p>In this example the minimum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</p> <pre class="code">
A = LOAD 'student' AS (name:chararray, session:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

X = FOREACH B GENERATE group, MIN(A.gpa);

DUMP X;
(John,3.7F)
(Mary,3.8F)
</pre>  <h4 id="Types+Tables-N106ED">Types Tables</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p>int </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>float </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>bigdecimal </p> </td> <td colspan="1" rowspan="1"> <p>biginteger </p> </td> <td colspan="1" rowspan="1"> <p>chararray </p> </td> <td colspan="1" rowspan="1"> <p>datetime </p> </td> <td colspan="1" rowspan="1"> <p>bytearray </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>MIN </p> </td> <td colspan="1" rowspan="1"> <p>int </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>float </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>bigdecimal </p> </td> <td colspan="1" rowspan="1"> <p>biginteger </p> </td> <td colspan="1" rowspan="1"> <p>chararray </p> </td> <td colspan="1" rowspan="1"> <p>datetime </p> </td> <td colspan="1" rowspan="1"> <p>cast as double</p> </td> </tr> </table>  <h3 id="plucktuple">PluckTuple</h3> <p>Allows the user to specify a string prefix, and then filter for the columns in a relation that begin with that prefix or match that regex pattern. Optionally, include flag 'false' to filter for columns that do not match that prefix or match that regex pattern</p>  <h4 id="Syntax-N107A5">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>DEFINE pluck PluckTuple(expression1)</p> <p>DEFINE pluck PluckTuple(expression1,expression3)</p> <p>pluck(expression2)</p> </td> </tr> </table>  <h4 id="Terms-N107C0">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression1</p> </td> <td colspan="1" rowspan="1"> <p>A prefix to pluck by or an regex pattern to pluck by</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>expression2</p> </td> <td colspan="1" rowspan="1"> <p>The fields to apply the pluck to, usually '*'</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>expression3</p> </td> <td colspan="1" rowspan="1"> <p>A boolean flag to indicate whether to include or exclude matching columns</p> </td> </tr> </table>  <h4 id="Usage-N10803">Usage</h4> <p>Example:</p> <pre class="code">
a = load 'a' as (x, y);
b = load 'b' as (x, y);
c = join a by x, b by x;
DEFINE pluck PluckTuple('a::');
d = foreach c generate FLATTEN(pluck(*));
describe c;
c: {a::x: bytearray,a::y: bytearray,b::x: bytearray,b::y: bytearray}
describe d;
d: {plucked::a::x: bytearray,plucked::a::y: bytearray}
DEFINE pluckNegative PluckTuple('a::','false');
d = foreach c generate FLATTEN(pluckNegative(*));
describe d;
d: {plucked::b::x: bytearray,plucked::b::y: bytearray}
</pre>  <h3 id="size">SIZE</h3> <p>Computes the number of elements based on any Pig data type. </p>  <h4 id="Syntax-N1081D">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>SIZE(expression)</p> </td> </tr> </table>  <h4 id="Terms-N10831">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with any data type.</p> </td> </tr> </table>  <h4 id="Usage-N1084D">Usage</h4> <p>Use the SIZE function to compute the number of elements based on the data type (see the Types Tables below). SIZE includes NULL values in the size computation. SIZE is not algebraic.</p> <p>If the tested object is null, the SIZE function returns null.</p>  <h4 id="Example-N1085A">Example</h4> <p>In this example the number of characters in the first field is computed.</p> <pre class="code">
A = LOAD 'data' as (f1:chararray, f2:chararray, f3:chararray);
(apache,open,source)
(hadoop,map,reduce)
(pig,pig,latin)

X = FOREACH A GENERATE SIZE(f1);

DUMP X;
(6L)
(6L)
(3L)
</pre>  <h4 id="Types+Tables-N10868">Types Tables</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>int </p> </td> <td colspan="1" rowspan="1"> <p>returns 1 </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>returns 1 </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>float </p> </td> <td colspan="1" rowspan="1"> <p>returns 1 </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>returns 1 </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>chararray </p> </td> <td colspan="1" rowspan="1"> <p>returns number of characters in the array </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>bytearray </p> </td> <td colspan="1" rowspan="1"> <p>returns number of bytes in the array </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>tuple </p> </td> <td colspan="1" rowspan="1"> <p>returns number of fields in the tuple</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>bag </p> </td> <td colspan="1" rowspan="1"> <p>returns number of tuples in bag </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>map </p> </td> <td colspan="1" rowspan="1"> <p>returns number of key/value pairs in map </p> </td> </tr> </table>  <h3 id="subtract">SUBTRACT</h3> <p>Bags subtraction, SUBTRACT(bag1, bag2) = bags composed of bag1 elements not in bag2</p>  <h4 id="Syntax-N10927">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>SUBTRACT(expression, expression)</p> </td> </tr> </table>  <h4 id="Terms-N1093B">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with data type bag.</p> </td> </tr> </table>  <h4 id="Usage-N10958">Usage</h4> <p>SUBTRACT takes two bags as arguments and returns a new bag composed of the tuples of first bag are not in the second bag.</p> <p>If null, bag arguments are replaced by empty bags.<br>If arguments are not bags, an IOException is thrown.</p> <p>The implementation assumes that both bags being passed to the SUBTRACT function will fit <strong>entirely into memory</strong> simultaneously, if this is not the case, SUBTRACT will still function but will be <strong>very</strong> slow.</p>  <h4 id="Example-N10970">Example</h4> <p>In this example, SUBTRACT creates a new bag composed of B1 elements that are not in B2.</p> <pre class="code">
A = LOAD 'bag_data' AS (B1:bag{T1:tuple(t1:int,t2:int)},B2:bag{T2:tuple(f1:int,f2:int)});

DUMP A;
({(8,9),(0,1),(1,2)},{(8,9),(1,1)})
({(2,3),(4,5)},{(2,3),(4,5)})
({(6,7),(3,7),(3,7)},{(2,2),(3,7)})

DESCRIBE A;
A: {B1: {T1: (t1: int,t2: int)},B2: {T2: (f1: int,f2: int)}}

X = FOREACH A GENERATE SUBTRACT(B1,B2);

DUMP X;
({(0,1),(1,2)})
({})
({(6,7)})
</pre>  <h3 id="sum">SUM</h3> <p>Computes the sum of the numeric values in a single-column bag. SUM requires a preceding GROUP ALL statement for global sums and a GROUP BY statement for group sums.</p>  <h4 id="Syntax-N10989">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>SUM(expression) </p> </td> </tr> </table>  <h4 id="Terms-N1099D">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with data types int, long, float, double, bigdecimal, biginteger or bytearray cast as double.</p> </td> </tr> </table>  <h4 id="Usage-N109B9">Usage</h4> <p>Use the SUM function to compute the sum of a set of numeric values in a single-column bag.</p> <p>The SUM function ignores NULL values.</p>  <h4 id="Example-N109C6">Example</h4> <p>In this example the number of pets is computed. (see the GROUP operator for information about the field names in relation B).</p> <pre class="code">
A = LOAD 'data' AS (owner:chararray, pet_type:chararray, pet_num:int);

DUMP A;
(Alice,turtle,1)
(Alice,goldfish,5)
(Alice,cat,2)
(Bob,dog,2)
(Bob,cat,2) 

B = GROUP A BY owner;

DUMP B;
(Alice,{(Alice,turtle,1),(Alice,goldfish,5),(Alice,cat,2)})
(Bob,{(Bob,dog,2),(Bob,cat,2)})

X = FOREACH B GENERATE group, SUM(A.pet_num);
DUMP X;
(Alice,8L)
(Bob,4L)
</pre>  <h4 id="Types+Tables-N109D4">Types Tables</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p>int </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>float </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>bigdecimal </p> </td> <td colspan="1" rowspan="1"> <p>biginteger </p> </td> <td colspan="1" rowspan="1"> <p>chararray </p> </td> <td colspan="1" rowspan="1"> <p>bytearray </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>SUM </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>long </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>double </p> </td> <td colspan="1" rowspan="1"> <p>bigdecimal </p> </td> <td colspan="1" rowspan="1"> <p>biginteger </p> </td> <td colspan="1" rowspan="1"> <p>error </p> </td> <td colspan="1" rowspan="1"> <p>cast as double </p> </td> </tr> </table>  <h3 id="in">IN</h3> <p>IN operator allows you to easily test if an expression matches any value in a list of values. It is used to reduce the need for multiple OR conditions.</p>  <h4 id="Syntax-N10A7E">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>IN (expression)</p> </td> </tr> </table>  <h4 id="Terms-N10A92">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with data types chararray, int, long, float, double, bigdecimal, biginteger or bytearray.</p> </td> </tr> </table>  <h4 id="Usage-N10AAE">Usage</h4> <p>IN operator allows you to easily test if an expression matches any value in a list of values. It is used to help reduce the need for multiple OR conditions.</p>  <h4 id="Example-N10AB8">Example</h4> <p>In this example we filter out ID 4 and 6.</p> <pre class="code">
A = load 'data' using PigStorage(',') AS (id:int, first:chararray, last:chararray, gender:chararray);

DUMP A;
(1,Christine,Romero,Female)
(2,Sara,Hansen,Female)
(3,Albert,Rogers,Male)
(4,Kimberly,Morrison,Female)
(5,Eugene,Baker,Male)
(6,Ann,Alexander,Female)
(7,Kathleen,Reed,Female)
(8,Todd,Scott,Male)
(9,Sharon,Mccoy,Female)
(10,Evelyn,Rice,Female)

X = FILTER A BY id IN (4, 6);
DUMP X;
(4,Kimberly,Morrison,Female)
(6,Ann,Alexander,Female)
</pre> <p>In this example, we're passing a BigInteger and using NOT operator, thereby negating the passed list of fields in the IN clause</p> <pre class="code">
A = load 'data' using PigStorage(',') AS (id:biginteger, first:chararray, last:chararray, gender:chararray); 
X = FILTER A BY NOT id IN (1, 3, 5, 7, 9); 
DUMP X;
 
(2,Sara,Hansen,Female)
(4,Kimberly,Morrison,Female)
(6,Ann,Alexander,Female)
(8,Todd,Scott,Male)
(10,Evelyn,Rice,Female)
</pre>  <h3 id="tokenize">TOKENIZE</h3> <p>Splits a string and outputs a bag of words. </p>  <h4 id="Syntax-N10AD9">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>TOKENIZE(expression [, 'field_delimiter']) </p> </td> </tr> </table>  <h4 id="Terms-N10AED">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with data type chararray.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>'field_delimiter'</p> </td> <td colspan="1" rowspan="1"> <p>An optional field delimiter (in single quotes).</p> <p>If field_delimiter is null or not passed, the following will be used as delimiters: space [ ], double quote [ " ], coma [ , ] parenthesis [ () ], star [ * ].</p> </td> </tr> </table>  <h4 id="Usage-N10B1F">Usage</h4> <p>Use the TOKENIZE function to split a string of words (all words in a single tuple) into a bag of words (each word in a single tuple). </p>  <h4 id="Example-N10B29">Example</h4> <p>In this example the strings in each row are split.</p> <pre class="code">
A  = LOAD 'data' AS (f1:chararray);

DUMP A;
(Here is the first string.)
(Here is the second string.)
(Here is the third string.)

X = FOREACH A GENERATE TOKENIZE(f1);

DUMP X;
({(Here),(is),(the),(first),(string.)})
({(Here),(is),(the),(second),(string.)})
({(Here),(is),(the),(third),(string.)})
</pre> <p>In this example a field delimiter is specified.</p> <pre class="code">
{code}
A = LOAD 'data' AS (f1:chararray);
B = FOREACH A GENERATE TOKENIZE (f1,'||');
DUMP B;
{code} 
</pre> </div>   <h2 id="load-store-functions">Load/Store Functions</h2> <div class="section"> <p>Load/store functions determine how data goes into Pig and comes out of Pig. Pig provides a set of built-in load/store functions, described in the sections below. You can also write your own load/store functions (see <a href="udf.html">User Defined Functions</a>).</p>  <h3 id="handling-compression">Handling Compression</h3> <p>Support for compression is determined by the load/store function. PigStorage and TextLoader support gzip and bzip compression for both read (load) and write (store). BinStorage does not support compression.</p> <p>To work with gzip compressed files, input/output files need to have a .gz extension. Gzipped files cannot be split across multiple maps; this means that the number of maps created is equal to the number of part files in the input location.</p> <pre class="code">
A = load 'myinput.gz';
store A into 'myoutput.gz';
</pre> <p>To work with bzip compressed files, the input/output files need to have a .bz or .bz2 extension. Because the compression is block-oriented, bzipped files can be split across multiple maps.</p> <pre class="code">
A = load 'myinput.bz';
store A into 'myoutput.bz';
</pre> <p>Note: PigStorage and TextLoader correctly read compressed files as long as they are NOT CONCATENATED bz/bz2 FILES generated in this manner: </p> <ul> <li> <p>cat *.bz &gt; text/concat.bz </p> </li> <li> <p>cat *.bz2 &gt; text/concat.bz2</p> </li> </ul>  <p>If you use concatenated bzip files with your Pig jobs, you will NOT see a failure but the results will be INCORRECT.</p>   <h3 id="binstorage">BinStorage</h3> <p>Loads and stores data in machine-readable format.</p>  <h4 id="Syntax-N10B8B">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>BinStorage() </p> </td> </tr> </table>  <h4 id="Terms-N10B9F">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>none</p> </td> <td colspan="1" rowspan="1"> <p>no parameters</p> </td> </tr> </table>  <h4 id="Usage-N10BBB">Usage</h4> <p>Pig uses BinStorage to load and store the temporary data that is generated between multiple MapReduce jobs.</p> <ul> <li>BinStorage works with data that is represented on disk in machine-readable format. BinStorage does NOT support <a href="#handling-compression">compression</a>.</li> <li>BinStorage supports multiple locations (files, directories, globs) as input.</li> </ul>  <p>Occasionally, users use BinStorage to store their own data. However, because BinStorage is a proprietary binary format, the original data is never in BinStorage - it is always a derivation of some other data.</p> <p>We have seen several examples of users doing something like this:</p> <pre class="code">
a = load 'b.txt' as (id, f);
b = group a by id;
store b into 'g' using BinStorage();
</pre> <p>And then later:</p> <pre class="code">
a = load 'g/part*' using BinStorage() as (id, d:bag{t:(v, s)});
b = foreach a generate (double)id, flatten(d);
dump b;
</pre> <p>There is a problem with this sequence of events. The first script does not define data types and, as the result, the data is stored as a bytearray and a bag with a tuple that contains two bytearrays. The second script attempts to cast the bytearray to double; however, since the data originated from a different loader, it has no way to know the format of the bytearray or how to cast it to a different type. To solve this problem, Pig:</p> <ul> <li>Sends an error message when the second script is executed: "ERROR 1118: Cannot cast bytes loaded from BinStorage. Please provide a custom converter."</li>  <li id="custom-converter">Allows you to use a custom converter to perform the casting. <br> <pre class="code">
a = load 'g/part*' using BinStorage('Utf8StorageConverter') as (id, d:bag{t:(v, s)});
b = foreach a generate (double)id, flatten(d);
dump b;
</pre> </li> </ul>  <h4 id="Examples-N10BF8">Examples</h4> <p>In this example BinStorage is used with the LOAD and STORE functions.</p> <pre class="code">
A = LOAD 'data' USING BinStorage();

STORE X into 'output' USING BinStorage(); 
</pre> <p>In this example BinStorage is used to load multiple locations.</p> <pre class="code">
A = LOAD 'input1.bin, input2.bin' USING BinStorage();
</pre> <p>BinStorage does not track data lineage. When Pig uses BinStorage to move data between MapReduce jobs, Pig can figure out the correct cast function to use and apply it. However, as shown in the example below, when you store data using BinStorage and then use a separate Pig Latin script to read data (thus loosing the type information), it is your responsibility to correctly cast the data before storing it using BinStorage. </p> <pre class="code">
raw = load 'sampledata' using BinStorage() as (col1,col2, col3);
--filter out null columns
A = filter raw by col1#'bcookie' is not null;

B = foreach A generate col1#'bcookie'  as reqcolumn;
describe B;
--B: {regcolumn: bytearray}
X = limit B 5;
dump X;
(36co9b55onr8s)
(36co9b55onr8s)
(36hilul5oo1q1)
(36hilul5oo1q1)
(36l4cj15ooa8a)

B = foreach A generate (chararray)col1#'bcookie'  as convertedcol;
describe B;
--B: {convertedcol: chararray}
X = limit B 5;
dump X; 
()
()
()
()
()
</pre>  <h3 id="jsonloadstore">JsonLoader, JsonStorage</h3> <p>Load or store JSON data.</p>  <h4 id="Syntax-N10C20">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>JsonLoader( ['schema'] ) </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>JsonStorage( ) </p> </td> </tr> </table>  <h4 id="Terms-N10C3F">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>schema</p> </td> <td colspan="1" rowspan="1"> <p>An optional Pig schema, in single quotes.</p> </td> </tr> </table>  <h4 id="Usage-N10C5B">Usage</h4> <p>Use JsonLoader to load JSON data. </p> <p>Use JsonStorage to store JSON data.</p> <p>Note that there is no concept of delimit in JsonLoader or JsonStorage. The data is encoded in standard JSON format. JsonLoader optionally takes a schema as the construct argument.</p>  <h4 id="Examples-N10C6B">Examples</h4> <p>In this example data is loaded with a schema. </p> <pre class="code">
a = load 'a.json' using JsonLoader('a0:int,a1:{(a10:int,a11:chararray)},a2:(a20:double,a21:bytearray),a3:[chararray]');  
</pre> <p>In this example data is loaded without a schema; it assumes there is a .pig_schema (produced by JsonStorage) in the input directory. </p> <pre class="code">
a = load 'a.json' using JsonLoader(); 
</pre>  <h3 id="pigdump">PigDump</h3> <p>Stores data in UTF-8 format.</p>  <h4 id="Syntax-N10C8B">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>PigDump() </p> </td> </tr> </table>  <h4 id="Terms-N10C9F">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>none</p> </td> <td colspan="1" rowspan="1"> <p>no parameters</p> </td> </tr> </table>  <h4 id="Usage-N10CBB">Usage</h4> <p>PigDump stores data as tuples in human-readable UTF-8 format. </p>  <h4 id="Example-N10CC4">Example</h4> <p>In this example PigDump is used with the STORE function.</p> <pre class="code">
STORE X INTO 'output' USING PigDump();
</pre>  <h3 id="pigstorage">PigStorage</h3> <p>Loads and stores data as structured text files.</p>  <h4 id="Syntax-N10CDD">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>PigStorage( [field_delimiter] , ['options'] ) </p> </td> </tr> </table>  <h4 id="Terms-N10CF1">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1">  <p id="field-delimiter">field_delimiter</p> </td> <td colspan="1" rowspan="1"> <p>The default field delimiter is tab ('\t'). </p> <p>You can specify other characters as field delimiters; however, be sure to encase the characters in single quotes.</p> </td> </tr> <tr> <td colspan="1" rowspan="1">  <p id="pigstorage-options">'options'</p> </td> <td colspan="1" rowspan="1"> <p>A string that contains space-separated options ('optionA optionB optionC')</p> <p>Currently supported options are:</p> <ul> <li>('schema') - Stores the schema of the relation using a hidden JSON file.</li> <li>('noschema') - Ignores a stored schema during the load.</li> <li>('tagsource') - (deprecated, Use tagPath instead) Add a first column indicates the input file of the record.</li> <li>('tagPath') - Add a first column indicates the input path of the record.</li> <li>('tagFile') - Add a first column indicates the input file name of the record.</li> </ul> </td> </tr> </table>  <h4 id="Usage-N10D3A">Usage</h4> <p>PigStorage is the default function used by Pig to load/store the data. PigStorage supports structured text files (in human-readable UTF-8 format) in compressed or uncompressed form (see <a href="#handling-compression">Handling Compression</a>). All Pig <a href="basic.html#data-types">data types</a> (both simple and complex) can be read/written using this function. The input data to the load can be a file, a directory or a glob.</p> <p> <strong>Load/Store Statements</strong> </p> <p>Load statements – PigStorage expects data to be formatted using field delimiters, either the tab character ('\t') or other specified character.</p> <p>Store statements – PigStorage outputs data using field delimiters, either the tab character ('\t') or other specified character, and the line feed record delimiter ('\n'). </p> <p> <strong>Field/Record Delimiters</strong> </p> <p>Field Delimiters – For load and store statements the default field delimiter is the tab character ('\t'). You can use other characters as field delimiters, but separators such as ^A or Ctrl-A should be represented in Unicode (\u0001) using UTF-16 encoding (see Wikipedia <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>, <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a>, and <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>).</p> <p>Record Deliminters – For load statements Pig interprets the line feed ( '\n' ), carriage return ( '\r' or CTRL-M) and combined CR + LF ( '\r\n' ) characters as record delimiters (do not use these characters as field delimiters). For store statements Pig uses the line feed ('\n') character as the record delimiter.</p> <p> <strong>Schemas</strong> </p> <p>If the schema option is specified, a hidden ".pig_schema" file is created in the output directory when storing data. It is used by PigStorage (with or without -schema) during loading to determine the field names and types of the data without the need for a user to explicitly provide the schema in an as clause, unless <span class="codefrag">noschema</span> is specified. No attempt to merge conflicting schemas is made during loading. The first schema encountered during a file system scan is used. </p> <p>Additionally, if the schema option is specified, a ".pig_headers" file is created in the output directory. This file simply lists the delimited aliases. This is intended to make export to tools that can read files with header lines easier (just cat the header to your data). </p> <p>If the schema option is NOT specified, a schema will not be written when storing data.</p> <p>If the noschema option is NOT specified, and a schema is found, it gets loaded when loading data.</p> <p>Note that regardless of whether or not you store the schema, you always need to specify the correct delimiter to read your data. If you store using delimiter "#" and then load using the default delimiter, your data will not be parsed correctly.</p> <p> <strong>Record Provenance</strong> </p> <p>If tagPath or tagFile option is specified, PigStorage will add a pseudo-column INPUT_FILE_PATH or INPUT_FILE_NAME respectively to the beginning of the record. As the name suggests, it is the input file path/name containing this particular record. Please note tagsource is deprecated.</p> <p> <strong>Complex Data Types</strong> </p> <p>The formats for complex data types are shown here:</p> <ul> <li> <a href="basic.html#tuple">Tuple</a>: enclosed by (), items separated by "," <ul> <li>Non-empty tuple: (item1,item2,item3)</li> <li>Empty tuple is valid: ()</li> </ul> </li> <li> <a href="basic.html#bag">Bag</a>: enclosed by {}, tuples separated by "," <ul> <li>Non-empty bag: {code}{(tuple1),(tuple2),(tuple3)}{code}</li> <li>Empty bag is valid: {}</li> </ul> </li> <li> <a href="basic.html#map">Map</a>: enclosed by [], items separated by ",", key and value separated by "#" <ul> <li>Non-empty map: [key1#value1,key2#value2]</li> <li>Empty map is valid: []</li> </ul> </li> </ul> <p>If load statement specify a schema, Pig will convert the complex type according to schema. If conversion fails, the affected item will be null (see <a href="basic.html#nulls">Nulls and Pig Latin</a>). </p>  <h4 id="Examples-N10DC7">Examples</h4> <p>In this example PigStorage expects input.txt to contain tab-separated fields and newline-separated records. The statements are equivalent.</p> <pre class="code">
A = LOAD 'student' USING PigStorage('\t') AS (name: chararray, age:int, gpa: float); 

A = LOAD 'student' AS (name: chararray, age:int, gpa: float);
</pre> <p>In this example PigStorage stores the contents of X into files with fields that are delimited with an asterisk ( * ). The STORE statement specifies that the files will be located in a directory named output and that the files will be named part-nnnnn (for example, part-00000).</p> <pre class="code">
STORE X INTO  'output' USING PigStorage('*');
</pre> <p>In this example, PigStorage loads data with complex data type, a bag of map and double.</p> <pre class="code">
a = load '1.txt' as (a0:{t:(m:map[int],d:double)});

{([foo#1,bar#2],34.0),([white#3,yellow#4],45.0)} : valid
{([foo#badint],baddouble)} : conversion fail for badint/baddouble, get {([foo#],)}
{} : valid, empty bag
</pre>  <h3 id="textloader">TextLoader</h3> <p>Loads unstructured data in UTF-8 format.</p>  <h4 id="Syntax-N10DEF">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>TextLoader()</p> </td> </tr> </table>  <h4 id="Terms-N10E04">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>none</p> </td> <td colspan="1" rowspan="1"> <p>no parameters</p> </td> </tr> </table>  <h4 id="Usage-N10E20">Usage</h4> <p>TextLoader works with unstructured data in UTF8 format. Each resulting tuple contains a single field with one line of input text. TextLoader also supports <a href="#handling-compression">compression</a>.</p> <p>Currently, TextLoader support for compression is limited.</p> <p>TextLoader cannot be used to store data.</p>  <h4 id="Example-N10E34">Example</h4> <p>In this example TextLoader is used with the LOAD function.</p> <pre class="code">
A = LOAD 'data' USING TextLoader();
</pre>  <h3 id="HBaseStorage">HBaseStorage</h3> <p>Loads and stores data from an HBase table.</p>  <h4 id="Syntax-N10E4D">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>HBaseStorage('columns', ['options'])</p> </td> </tr> </table>  <h4 id="Terms-N10E62">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>columns</p> </td> <td colspan="1" rowspan="1"> <p>A list of qualified HBase columns to read data from or store data to. The column family name and column qualifier are seperated by a colon (:). Only the columns used in the Pig script need to be specified. Columns are specified in one of three different ways as described below.</p> <ul> <li>Explicitly specify a column family and column qualifier (e.g., user_info:id). This will produce a scalar in the resultant tuple.</li> <li>Specify a column family and a portion of column qualifier name as a prefix followed by an asterisk (i.e., user_info:address_*). This approach is used to read one or more columns from the same column family with a matching descriptor prefix. The datatype for this field will be a map of column descriptor name to field value. Note that combining this style of prefix with a long list of fully qualified column descriptor names could cause perfomance degredation on the HBase scan. This will produce a Pig map in the resultant tuple with column descriptors as keys.</li> <li>Specify all the columns of a column family using the column family name followed by an asterisk (i.e., user_info:*). This will produce a Pig map in the resultant tuple with column descriptors as keys.</li> </ul> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>'options'</p> </td> <td colspan="1" rowspan="1"> <p>A string that contains space-separated options (‘-optionA=valueA -optionB=valueB -optionC=valueC’)</p> <p>Currently supported options are:</p> <ul> <li>-loadKey=(true|false) Load the row key as the first value in every tuple returned from HBase (default=false)</li> <li>-gt=minKeyVal Return rows with a rowKey greater than minKeyVal</li> <li>-lt=maxKeyVal Return rows with a rowKey less than maxKeyVal</li> <li>-regex=regex Return rows with a rowKey that match this regex on KeyVal</li> <li>-gte=minKeyVal Return rows with a rowKey greater than or equal to minKeyVal</li> <li>-lte=maxKeyVal Return rows with a rowKey less than or equal to maxKeyVal</li> <li>-limit=numRowsPerRegion Max number of rows to retrieve per region</li> <li>-caching=numRows Number of rows to cache (faster scans, more memory)</li> <li>-delim=delimiter Column delimiter in columns list (default is whitespace)</li> <li>-ignoreWhitespace=(true|false) When delim is set to something other than whitespace, ignore spaces when parsing column list (default=true)</li> <li>-caster=(HBaseBinaryConverter|Utf8StorageConverter) Class name of Caster to use to convert values (default=Utf8StorageConverter). The default caster can be overridden with the pig.hbase.caster config param. Casters must implement LoadStoreCaster.</li> <li>-noWAL=(true|false) During storage, sets the write ahead to false for faster loading into HBase (default=false). To be used with extreme caution since this could result in data loss (see <a href="http://hbase.apache.org/book.html#perf.hbase.client.putwal">http://hbase.apache.org/book.html#perf.hbase.client.putwal</a>).</li> <li>-minTimestamp=timestamp Return cell values that have a creation timestamp greater or equal to this value</li> <li>-maxTimestamp=timestamp Return cell values that have a creation timestamp less than this value</li> <li>-timestamp=timestamp Return cell values that have a creation timestamp equal to this value</li> <li>-includeTimestamp=Record will include the timestamp after the rowkey on store (rowkey, timestamp, ...)</li> <li>-includeTombstone=Record will include a tombstone marker on store after the rowKey and timestamp (if included) (rowkey, [timestamp,] tombstone, ...)</li> </ul> </td> </tr> </table>  <h4 id="Usage-N10EDB">Usage</h4> <p>HBaseStorage stores and loads data from HBase. The function takes two arguments. The first argument is a space seperated list of columns. The second optional argument is a space seperated list of options. Column syntax and available options are listed above. Note that HBaseStorage always disable split combination.</p>  <h4 id="Load+Example">Load Example</h4> <p>In this example HBaseStorage is used with the LOAD function with an explicit schema.</p> <pre class="code">
raw = LOAD 'hbase://SomeTableName'
      USING org.apache.pig.backend.hadoop.hbase.HBaseStorage(
      'info:first_name info:last_name tags:work_* info:*', '-loadKey=true -limit=5') AS
      (id:bytearray, first_name:chararray, last_name:chararray, tags_map:map[], info_map:map[]);
</pre> <p>The datatypes of the columns are declared with the "AS" clause. The first_name and last_name columns are specified as fully qualified column names with a chararray datatype. The third specification of tags:work_* requests a set of columns in the tags column family that begin with "work_". There can be zero, one or more columns of that type in the HBase table. The type is specified as tags_map:map[]. This indicates that the set of column values returned will be accessed as a map, where the key is the column name and the value is the cell value of the column. The fourth column specification is also a map of column descriptors to cell values.</p> <p>When the type of the column is specified as a map in the "AS" clause, the map keys are the column descriptor names and the data type is chararray. The datatype of the columns values can be declared explicitly as shown in the examples below:</p> <ul> <li>tags_map[chararray] - In this case, the column values are all declared to be of type chararray</li> <li>tags_map[int] - In this case, the column values are all declared to be of type int.</li> </ul>  <h4 id="Store+Example">Store Example</h4> <p>In this example HBaseStorage is used to store a relation into HBase.</p> <pre class="code">
A = LOAD 'hdfs_users' AS (id:bytearray, first_name:chararray, last_name:chararray);
STORE A INTO 'hbase://users_table' USING org.apache.pig.backend.hadoop.hbase.HBaseStorage(
    'info:first_name info:last_name');
</pre> <p>In the example above relation A is loaded from HDFS and stored in HBase. Note that the schema of relation A is a tuple of size 3, but only two column descriptor names are passed to the HBaseStorage constructor. This is because the first entry in the tuple is used as the HBase rowKey.</p>  <h3 id="AvroStorage">AvroStorage</h3> <p>Loads and stores data from Avro files.</p>  <h4 id="Syntax-N10F1F">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>AvroStorage(['schema|record name'], ['options'])</p> </td> </tr> </table>  <h4 id="Terms-N10F34">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>schema</p> </td> <td colspan="1" rowspan="1"> <p>A JSON string specifying the Avro schema for the input. You may specify an explicit schema when storing data or when loading data. When you manually provide a schema, Pig will use the provided schema for serialization and deserialization. This means that you can provide an explicit schema when saving data to simplify the output (for example by removing nullable unions), or rename fields. This also means that you can provide an explicit schema when reading data to only read a subset of the fields in each record.</p> <p>See <a href="http://avro.apache.org/docs/current/spec.html"> the Apache Avro Documentation</a> for more details on how to specify a valid schema.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>record name</p> </td> <td colspan="1" rowspan="1"> <p>When storing a bag of tuples with AvroStorage, if you do not want to specify the full schema, you may specify the avro record name instead. (AvroStorage will determine that the argument isn't a valid schema definition and use it as a variable name instead.)</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>'options'</p> </td> <td colspan="1" rowspan="1"> <p>A string that contains space-separated options (‘-optionA valueA -optionB valueB -optionC ’)</p> <p>Currently supported options are:</p> <ul> <li>-namespace nameSpace or -n nameSpace Explicitly specify the namespace field in Avro records when storing data</li> <li>-schemfile schemaFile or -f schemaFile Specify the input (or output) schema from an external file. Pig assumes that the file is located on the default filesystem, but you may use an explicity URL to unambigously specify the location. (For example, if the data was on your local file system in /stuff/schemafile.avsc, you could specify "-f file:///stuff/schemafile.avsc" to specify the location. If the data was on HDFS under /yourdirectory/schemafile.avsc, you could specify "-f hdfs:///yourdirectory/schemafile.avsc"). Pig expects this to be a text file, containing a valid avro schema.</li> <li>-examplefile exampleFile or -e exampleFile Specify the input (or output) schema using another Avro file as an example. Pig assumes that the file is located on the default filesystem, but you may use and explicity URL to specify the location. Pig expects this to be an Avro data file.</li> <li>-allowrecursive or -r Specify whether to allow recursive schema definitions (the default is to throw an exception if Pig encounters a recursive schema). When reading objects with recursive definitions, Pig will translate Avro records to schema-less tuples; the Pig Schema for the object may not match the data exactly.</li> <li>-doublecolons or -d Specify how to handle Pig schemas that contain double-colons when writing data in Avro format. (When you join two bags in Pig, Pig will automatically label the fields in the output Tuples with names that contain double-colons). If you select this option, AvroStorage will translate names with double colons into names with double underscores. </li> </ul> </td> </tr> </table>  <h4 id="Usage-N10F93">Usage</h4> <p>AvroStorage stores and loads data from Avro files. Often, you can load and store data using AvroStorage without knowing much about the Avros serialization format. AvroStorage will attempt to automatically translate a pig schema and pig data to avro data, or avro data to pig data.</p> <p>By default, when you use AvoStorage to load data, AvroStorage will use depth first search to find a valid Avro file on the input path, then use the schema from that file to load the data. When you use AvroStorage to store data, AvroStorage will attempt to translate the Pig schema to an equivalent Avro schema. You can manually specify the schema by providing an explicit schema in Pig, loading a schema from an external schema file, or explicitly telling Pig to read the schema from a specific avro file.</p> <p>To compress your output with AvroStorage, you need to use the correct Avro properties for compression. For example, to enable compression using deflate level 5, you would specify</p> <pre class="code">
SET avro.output.codec 'deflate'
SET avro.mapred.deflate.level 5
</pre> <p>Valid values for avro.output.codec include deflate, snappy, and null.</p> <p>There are a few key differences between Avro and Pig data, and in some cases it helps to understand the differences between the Avro and Pig data models. Before writing Pig data to Avro (or creating Avro files to use in Pig), keep in mind that there might not be an equivalent Avro Schema for every Pig Schema (and vice versa):</p> <ul> <li> <strong>Recursive schema definitions</strong> You cannot define schemas recursively in Pig, but you can define schemas recursively in Avro.</li> <li> <strong>Allowed characters</strong> Pig schemas may sometimes contain characters like colons (":") that are illegal in Avro names.</li> <li> <strong>Unions</strong> In Avro, you can define an object that may be one of several different types (including complex types such as records). In Pig, you cannot.</li> <li> <strong>Enums</strong> Avro allows you to define enums to efficiently and abstractly represent categorical variable, but Pig does not.</li> <li> <strong>Fixed Length Byte Arrays</strong> Avro allows you to define fixed length byte arrays, but Pig does not.</li> <li> <strong>Nullable values</strong> In Pig, all types are nullable. In Avro, they are not. </li> </ul> <p>Here is how AvroStorage translates Pig values to Avro:</p> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"></td> <td colspan="1" rowspan="1">Original Pig Type</td> <td colspan="1" rowspan="1">Translated Avro Type</td> </tr> <tr> <td colspan="1" rowspan="1">Integers</td> <td colspan="1" rowspan="1">int</td> <td colspan="1" rowspan="1">["int","null"]</td> </tr> <tr> <td colspan="1" rowspan="1">Longs</td> <td colspan="1" rowspan="1">long</td> <td colspan="1" rowspan="1">["long,"null"]</td> </tr> <tr> <td colspan="1" rowspan="1">Floats</td> <td colspan="1" rowspan="1">float</td> <td colspan="1" rowspan="1">["float","null"]</td> </tr> <tr> <td colspan="1" rowspan="1">Doubles</td> <td colspan="1" rowspan="1">double</td> <td colspan="1" rowspan="1">["double","null"]</td> </tr> <tr> <td colspan="1" rowspan="1">Strings</td> <td colspan="1" rowspan="1">chararray</td> <td colspan="1" rowspan="1">["string","null"]</td> </tr> <tr> <td colspan="1" rowspan="1">Bytes</td> <td colspan="1" rowspan="1">bytearray</td> <td colspan="1" rowspan="1">["bytes","null"]</td> </tr> <tr> <td colspan="1" rowspan="1">Booleans</td> <td colspan="1" rowspan="1">boolean</td> <td colspan="1" rowspan="1">["boolean","null"]</td> </tr> <tr> <td colspan="1" rowspan="1">Tuples</td> <td colspan="1" rowspan="1">tuple</td> <td colspan="1" rowspan="1">The Pig Tuple schema will be translated to an union of and Avro record with an equivalent schem and null.</td> </tr> <tr> <td colspan="1" rowspan="1">Bags of Tuples</td> <td colspan="1" rowspan="1">bag</td> <td colspan="1" rowspan="1">The Pig Tuple schema will be translated to a union of an array of records with an equivalent schema and null.</td> </tr> <tr> <td colspan="1" rowspan="1">Maps</td> <td colspan="1" rowspan="1">map</td> <td colspan="1" rowspan="1">The Pig Tuple schema will be translated to a union of a map of records with an equivalent schema and null.</td> </tr> </table> <p>Here is how AvroStorage translates Avro values to Pig:</p> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"></td> <td colspan="1" rowspan="1">Original Avro Types</td> <td colspan="1" rowspan="1">Translated Pig Type</td> </tr> <tr> <td colspan="1" rowspan="1">Integers</td> <td colspan="1" rowspan="1">["int","null"] or "int"</td> <td colspan="1" rowspan="1">int</td> </tr> <tr> <td colspan="1" rowspan="1">Longs</td> <td colspan="1" rowspan="1">["long,"null"] or "long"</td> <td colspan="1" rowspan="1">long</td> </tr> <tr> <td colspan="1" rowspan="1">Floats</td> <td colspan="1" rowspan="1">["float","null"] or "float"</td> <td colspan="1" rowspan="1">float</td> </tr> <tr> <td colspan="1" rowspan="1">Doubles</td> <td colspan="1" rowspan="1">["double","null"] or "double"</td> <td colspan="1" rowspan="1">double</td> </tr> <tr> <td colspan="1" rowspan="1">Strings</td> <td colspan="1" rowspan="1">["string","null"] or "string"</td> <td colspan="1" rowspan="1">chararray</td> </tr> <tr> <td colspan="1" rowspan="1">Enums</td> <td colspan="1" rowspan="1">Either an enum or a union of an enum and null</td> <td colspan="1" rowspan="1">chararray</td> </tr> <tr> <td colspan="1" rowspan="1">Bytes</td> <td colspan="1" rowspan="1">["bytes","null"] or "bytes"</td> <td colspan="1" rowspan="1">bytearray</td> </tr> <tr> <td colspan="1" rowspan="1">Fixes</td> <td colspan="1" rowspan="1">Either a fixed length byte array, or a union of a fixed length array and null</td> <td colspan="1" rowspan="1">bytearray</td> </tr> <tr> <td colspan="1" rowspan="1">Booleans</td> <td colspan="1" rowspan="1">["boolean","null"] or "boolean"</td> <td colspan="1" rowspan="1">boolean</td> </tr> <tr> <td colspan="1" rowspan="1">Tuples</td> <td colspan="1" rowspan="1">Either a record type, or a union or a record and null</td> <td colspan="1" rowspan="1">tuple</td> </tr> <tr> <td colspan="1" rowspan="1">Bags of Tuples</td> <td colspan="1" rowspan="1">Either an array, or a union of an array and null</td> <td colspan="1" rowspan="1">bag</td> </tr> <tr> <td colspan="1" rowspan="1">Maps</td> <td colspan="1" rowspan="1">Either a map, or a union of a map and null</td> <td colspan="1" rowspan="1">map</td> </tr> </table> <p> In many cases, AvroStorage will automatically translate your data correctly and you will not need to provide any more information to AvroStorage. But sometimes, it may be convenient to manually provide a schema to AvroStorge. See the example selection below for examples on manually specifying a schema with AvroStorage. </p>  <h4 id="Load+Examples">Load Examples</h4> <p>Suppose that you were provided with a file of avro data (located in 'stuff') with the following schema:</p> <pre class="code">
{"type" : "record",
 "name" : "stuff",
 "fields" : [
   {"name" : "label", "type" : "string"}, 
   {"name" : "value", "type" : "int"},
   {"name" : "marketingPlans", "type" : ["string", "bytearray", "null"]}
  ]
}
</pre> <p>Additionally, suppose that you don't need the value of the field "marketingPlans." (That's a good thing, because AvroStorage doesn't know how to translate that Avro schema to a Pig schema). To load only the fieds "label" and "value" into Pig, you can manually specify the schema passed to AvroStorage:</p> <pre class="code">
measurements = LOAD 'stuff' USING AvroStorage(
  '{"type":"record","name":"measurement","fields":[{"name":"label","type":"string"},{"name":"value","type":"int"}]}'
  );
</pre>  <h4 id="Store+Examples">Store Examples</h4> <p>Suppose that you are saving a bag called measurements with the schema:</p> <pre class="code">
measurements:{measurement:(label:chararray,value:int)}
</pre> <p>To store this bag into a file called "measurements", you can use a statement like:</p> <pre class="code">
STORE measurements INTO 'measurements' USING AvroStorage('measurement');
</pre> <p>AvroStorage will translate this to the Avro schema</p> <pre class="code">
{"type":"record", 
 "name":"measurement",
 "fields" : [
   {"name" : "label", "type" : ["string", "null"]}, 
   {"name" : "value", "type" : ["int", "null"]}
  ]
} 
</pre> <p>But suppose that you knew that the label and value fields would never be null. You could define a more precise schema manually using a statement like:</p> <pre class="code">
STORE measurements INTO 'measurements' USING AvroStorage(
  '{"type":"record","name":"measurement","fields":[{"name":"label","type":"string"},{"name":"value","type":"int"}]}'
  );
</pre>  <h3 id="TrevniStorage">TrevniStorage</h3> <p>Loads and stores data from Trevni files.</p>  <h4 id="Syntax-N111CF">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>TrevniStorage(['schema|record name'], ['options'])</p> </td> </tr> </table> <p>Trevni is a column-oriented storage format that is part of the Apache Avro project. Trevni is closely related to Avro.</p> <p>Likewise, TrevniStorage is very closely related to AvroStorage, and shares the same options as AvroStorage. See <a href="#AvroStorage">AvroStorage</a> for a detailed description of the arguments for TrevniStorage.</p>  <h3 id="AccumuloStorage">AccumuloStorage</h3> <p>Loads or stores data from an Accumulo table. The first element in a Tuple is equivalent to the "row" from the Accumulo Key, while the columns in that row are can be grouped in various static or wildcarded ways. Basic wildcarding functionality exists to group various columns families/qualifiers into a Map for LOADs, or serialize a Map into some group of column families or qualifiers on STOREs. </p>  <h4 id="Syntax-N111FA">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>AccumuloStorage(['columns'[, 'options']])</p> </td> </tr> </table>  <h4 id="Arguments">Arguments</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>'columns'</p> </td> <td colspan="1" rowspan="1"> <p>A comma-separated list of "columns" to read data from to write data to. Each of these columns can be considered one of three different types: </p> <ol> <li>Literal</li> <li>Column family prefix</li> <li>Column qualifier prefix</li> </ol> <p> <strong>Literal:</strong> this is the simplest specification which is a colon-delimited string that maps to a column family and column qualifier. This will read/write a simple scalar from/to Accumulo. </p> <p> <strong>Column family prefix:</strong> When reading data, this will fetch data from Accumulo Key-Values in the current row whose column family match the given prefix. This will result in a Map being placed into the Tuple. When writing data, a Map is also expected at the given offset in the Tuple whose Keys will be appended to the column family prefix, an empty column qualifier is used, and the Map value will be placed in the Accumulo Value. A valid column family prefix is a literal asterisk (*) in which case the Map Key will be equivalent to the Accumulo column family. </p> <p> <strong>Column qualifier prefix:</strong> Similar to the column family prefix except it operates on the column qualifier. On reads, Accumulo Key-Values in the same row that match the given column family and column qualifier prefix will be placed into a single Map. On writes, the provided column family from the column specification will be used, the Map key will be appended to the column qualifier provided in the specification, and the Map Value will be the Accumulo Value. </p> <p>When "columns" is not provided or is a blank String, it is treated equivalently to "*". This is to say that when a column specification string is not provided, for reads, all columns in the given Accumulo row will be placed into a single Map (with the Map keys being colon delimited to preserve the column family/qualifier from Accumulo). For writes, the Map keys will be placed into the column family and the column qualifier will be empty. </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>'options'</p> </td> <td colspan="1" rowspan="1"> <p>A string that contains space-separated options ("optionA valueA -optionB valueB -optionC valueC")</p> <p>The currently supported options are:</p> <ul> <li>(-c|--caster) LoadStoreCasterImpl An implementation of a LoadStoreCaster to use when serializing types into Accumulo, usually AccumuloBinaryConverter or UTF8StringConverter, defaults to UTF8StorageConverter. </li> <li>(-auths|--authorizations) auth1,auth2... A comma-separated list of Accumulo authorizations to use when reading data from Accumulo. Defaults to the empty set of authorizations (none). </li> <li>(-s|--start) start_row The Accumulo row to begin reading from, inclusive</li> <li>(-e|--end) end_row The Accumulo row to read until, inclusive</li> <li>(-buff|--mutation-buffer-size) num_bytes The number of bytes to buffer when writing data to Accumulo. A higher value requires more memory</li> <li>(-wt|--write-threads) num_threads The number of threads used to write data to Accumulo.</li> <li>(-ml|--max-latency) milliseconds Maximum time in milliseconds before data is flushed to Accumulo.</li> <li>(-sep|--separator) str The separator character used when parsing the column specification, defaults to comma (,)</li> <li>(-iw|--ignore-whitespace) (true|false) Should whitespace be stripped from the column specification, defaults to true</li> </ul> </td> </tr> </table>  <h4 id="Usage-N1127E">Usage</h4> <p>AccumuloStorage has the functionality to store or fetch data from Accumulo. Its goal is to provide a simple, widely applicable table schema compatible with Pig's API. Each Tuple contains some subset of the columns stored within one row of the Accumulo table, which depends on the columns provided as an argument to the function. If '*' is provided, all columns in the table will be returned. The second argument provides control over a variety of options that can be used to change various properties.</p> <p>When invoking Pig Scripts that use AccumuloStorage, it's important to ensure that Pig has the Accumulo jars on its classpath. This is easily achieved using the ACCUMULO_HOME environment variable. </p> <pre class="code">
PIG_CLASSPATH="$ACCUMULO_HOME/lib/*:$PIG_CLASSPATH" pig my_script.pig
</pre>  <h4 id="Load+Example-N1128F">Load Example</h4> <p>It is simple to fetch all columns from Airport codes that fall between Boston and San Francisco that can be viewed with 'auth1' and/or 'auth2' Accumulo authorizations.</p> <pre class="code">
raw = LOAD 'accumulo://airports?instance=accumulo&amp;user=root&amp;password=passwd&amp;zookeepers=localhost'
      USING org.apache.pig.backend.hadoop.accumulo.AccumuloStorage(
      '*', '-a auth1,auth2 -s BOS -e SFO') AS
      (code:chararray, all_columns:map[]);
</pre> <p>The datatypes of the columns are declared with the "AS" clause. In this example, the row key, which is the unique airport code is assigned to the "code" variable while all of the other columns are placed into the map. When there is a non-empty column qualifier, the key in that map will have a colon which separates which portion of the key came from the column family and which portion came from the column qualifier. The Accumulo value is placed in the Map value.</p> <p>Most times, it is not necessary, nor desired for performance reasons, to fetch all columns.</p> <pre class="code">
raw = LOAD 'accumulo://airports?instance=accumulo&amp;user=root&amp;password=passwd&amp;zookeepers=localhost'
      USING org.apache.pig.backend.hadoop.accumulo.AccumuloStorage(
      'name,building:num_terminals,carrier*,reviews:transportation*') AS
      (code:chararray name:bytearray carrier_map:map[] transportion_reviews_map:map[]);
</pre> <p>An asterisk can be used when requesting columns to group a collection of columns into a single Map instead of enumerating each column.</p>  <h4 id="Store+Example-N112AA">Store Example</h4> <p>Data can be easily stored into Accumulo.</p> <pre class="code">
A = LOAD 'flights.txt' AS (id:chararray, carrier_name:chararray, src_airport:chararray, dest_airport:chararray, tail_number:int);
STORE A INTO 'accumulo://flights?instance=accumulo&amp;user=root&amp;password=passwd&amp;zookeepers=localhost' USING 
    org.apache.pig.backend.hadoop.accumulo.AccumuloStorage('carrier_name,src_airport,dest_airport,tail_number');
</pre> <p>Here, we read the file 'flights.txt' out of HDFS and store the results into the relation A. We extract a unique ID for the flight, its source and destination and the tail number from the given file. When STORE'ing back into Accumulo, we specify the column specifications (in this case, just a column family). It is also important to note that four elements are provided as columns because the first element in the Tuple is used as the row in Accumulo. </p>  <h3 id="OrcStorage">OrcStorage</h3> <p>Loads from or stores data to Orc file.</p>  <h4 id="Syntax-N112C5">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>OrcStorage(['options'])</p> </td> </tr> </table>  <h4 id="Options">Options</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>A string that contains space-separated options (‘-optionA valueA -optionB valueB -optionC ’). Current options are only applicable with STORE operation and not for LOAD.</p> <p>Currently supported options are:</p> <ul> <li>--stripeSize or -s Set the stripe size for the file. Default is 268435456(256 MB).</li> <li>--rowIndexStride or -r Set the distance between entries in the row index. Default is 10000.</li> <li>--bufferSize or -b Set the size of the memory buffers used for compressing and storing the stripe in memory. Default is 262144 (256K).</li> <li>--blockPadding or -p Sets whether the HDFS blocks are padded to prevent stripes from straddling blocks. Default is true.</li> <li>--compress or -c Sets the generic compression that is used to compress the data. Valid codecs are: NONE, ZLIB, SNAPPY, LZO. Default is ZLIB.</li> <li>--version or -v Sets the version of the file that will be written</li> </ul> </td> </tr> </table>  <h4 id="Example-N11307">Example</h4> <p>OrcStorage as a StoreFunc.</p> <pre class="code">
A = LOAD 'student.txt' as (name:chararray, age:int, gpa:double);
store A into 'student.orc' using OrcStorage('-c SNAPPY'); -- store student.txt into data.orc with SNAPPY compression
</pre> <p>OrcStorage as a LoadFunc.</p> <pre class="code">
A = LOAD 'student.orc' USING OrcStorage();
describe A; -- See the schema of student.orc
B = filter A by age &gt; 25 and gpa &lt; 3; -- filter condition will be pushed up to loader
dump B; -- dump the content of student.orc
</pre>  <h4 id="Data+types">Data types</h4> <p>Most Orc data type has one to one mapping to Pig data type. Several exceptions are:</p> <p>Loader side:</p> <ul> <li>Orc STRING/CHAR/VARCHAR all map to Pig varchar</li> <li>Orc BYTE/BINARY all map to Pig bytearray</li> <li>Orc TIMESTAMP/DATE all maps to Pig datetime</li> <li>Orc DECIMAL maps to Pig bigdecimal</li> </ul> <p>Storer side:</p> <ul> <li>Pig chararray maps to Orc STRING</li> <li>Pig datetime maps to Orc TIMESTAMP</li> <li>Pig bigdecimal/biginteger all map to Orc DECIMAL</li> <li>Pig bytearray maps to Orc BINARY</li> </ul>  <h4 id="Predicate+pushdown">Predicate pushdown</h4> <p>If there is a filter statement right after OrcStorage, Pig will push the filter condition to the loader. OrcStorage will prune file/stripe/row group which does not satisfy the condition entirely. For the file/stripe/row group contains data that satisfies the filter condition, OrcStorage will load the file/stripe/row group and Pig will evaluate the filter condition again to remove additional data which does not satisfy the filter condition.</p> <p>OrcStorage predicate pushdown currently support all primitive data types but none of the complex data types. For example, map condition cannot push into OrcStorage:</p> <pre class="code">
A = LOAD 'student.orc' USING OrcStorage();
B = filter A by info#'age' &gt; 25; -- map condition cannot push to OrcStorage
dump B;
</pre> <p>Currently, the following expressions in filter condition are supported in OrcStorage predicate pushdown: &gt;, &gt;=, &lt;, &lt;=, ==, !=, between, in, and, or, not. The missing expressions are: is null, is not null, matches.</p> </div>     <h2 id="math-functions">Math Functions</h2> <div class="section"> <p>For general information about these functions, see the <a href="http://docs.oracle.com/javase/6/docs/api/">Java API Specification</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html">Class Math</a>. Note the following:</p> <ul> <li> <p>Pig function names are case sensitive and UPPER CASE.</p> </li> <li> <p>Pig may process results differently than as stated in the Java API Specification:</p> <ul> <li> <p>If the result value is null or empty, Pig returns null.</p> </li> <li> <p>If the result value is not a number (NaN), Pig returns null.</p> </li> <li> <p>If Pig is unable to process the expression, Pig returns an exception.</p> </li> </ul> </li> </ul>  <h3 id="abs">ABS</h3> <p>Returns the absolute value of an expression.</p>  <h4 id="Syntax-N113A6">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ABS(expression)</p> </td> </tr> </table>  <h4 id="Terms-N113BA">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>Any expression whose result is type int, long, float, or double.</p> </td> </tr> </table>  <h4 id="Usage-N113D6">Usage</h4> <p> Use the ABS function to return the absolute value of an expression. If the result is not negative (x ≥ 0), the result is returned. If the result is negative (x &lt; 0), the negation of the result is returned. </p>  <h3 id="acos">ACOS</h3> <p>Returns the arc cosine of an expression.</p>  <h4 id="Syntax-N113EC">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ACOS(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11400">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N1141D">Usage</h4> <p> Use the ACOS function to return the arc cosine of an expression. </p>  <h3 id="asin">ASIN</h3> <p>Returns the arc sine of an expression.</p>  <h4 id="Syntax-N11433">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ASIN(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11448">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N11465">Usage</h4> <p> Use the ASIN function to return the arc sine of an expression. </p>  <h3 id="atan">ATAN</h3> <p>Returns the arc tangent of an expression.</p>  <h4 id="Syntax-N1147B">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ATAN(expression)</p> </td> </tr> </table>  <h4 id="Terms-N1148F">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N114AC">Usage</h4> <p> Use the ATAN function to return the arc tangent of an expression. </p>  <h3 id="cbrt">CBRT</h3> <p>Returns the cube root of an expression.</p>  <h4 id="Syntax-N114C2">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>CBRT(expression)</p> </td> </tr> </table>  <h4 id="Terms-N114D6">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N114F3">Usage</h4> <p> Use the CBRT function to return the cube root of an expression. </p>  <h3 id="ceil">CEIL</h3> <p>Returns the value of an expression rounded up to the nearest integer. </p>  <h4 id="Syntax-N11509">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>CEIL(expression)</p> </td> </tr> </table>  <h4 id="Terms-N1151D">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N1153A">Usage</h4> <p> Use the CEIL function to return the value of an expression rounded up to the nearest integer. This function never decreases the result value. </p> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>x</p> </td> <td colspan="1" rowspan="1"> <p>CEIL(x)</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 4.6</p> </td> <td colspan="1" rowspan="1"> <p> 5</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 3.5</p> </td> <td colspan="1" rowspan="1"> <p> 4</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 2.4</p> </td> <td colspan="1" rowspan="1"> <p> 3</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>1.0</p> </td> <td colspan="1" rowspan="1"> <p>1</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-1.0</p> </td> <td colspan="1" rowspan="1"> <p>-1</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-2.4</p> </td> <td colspan="1" rowspan="1"> <p>-2</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-3.5</p> </td> <td colspan="1" rowspan="1"> <p>-3</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-4.6</p> </td> <td colspan="1" rowspan="1"> <p>-4</p> </td> </tr> </table>  <h3 id="cos">COS</h3> <p>Returns the trigonometric cosine of an expression. </p>  <h4 id="Syntax-N115FE">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>COS(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11612">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression (angle) whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N1162F">Usage</h4> <p> Use the COS function to return the trigonometric cosine of an expression. </p>  <h3 id="cosh">COSH</h3> <p>Returns the hyperbolic cosine of an expression. </p>  <h4 id="Syntax-N11645">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>COSH(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11659">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N11676">Usage</h4> <p> Use the COSH function to return the hyperbolic cosine of an expression. </p>  <h3 id="exp">EXP</h3> <p>Returns Euler's number e raised to the power of x. </p>  <h4 id="Syntax-N1168C">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>EXP(expression)</p> </td> </tr> </table>  <h4 id="Terms-N116A0">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N116BD">Usage</h4> <p> Use the EXP function to return the value of Euler's number e raised to the power of x (where x is the result value of the expression). </p>  <h3 id="floor">FLOOR</h3> <p>Returns the value of an expression rounded down to the nearest integer. </p>  <h4 id="Syntax-N116D3">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>FLOOR(expression)</p> </td> </tr> </table>  <h4 id="Terms-N116E7">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N11704">Usage</h4> <p> Use the FLOOR function to return the value of an expression rounded down to the nearest integer. This function never increases the result value. </p> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>x</p> </td> <td colspan="1" rowspan="1"> <p>FLOOR(x)</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 4.6</p> </td> <td colspan="1" rowspan="1"> <p> 4</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 3.5</p> </td> <td colspan="1" rowspan="1"> <p> 3</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 2.4</p> </td> <td colspan="1" rowspan="1"> <p> 2</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>1.0</p> </td> <td colspan="1" rowspan="1"> <p>1</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-1.0</p> </td> <td colspan="1" rowspan="1"> <p>-1</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-2.4</p> </td> <td colspan="1" rowspan="1"> <p>-3</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-3.5</p> </td> <td colspan="1" rowspan="1"> <p>-4</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-4.6</p> </td> <td colspan="1" rowspan="1"> <p>-5</p> </td> </tr> </table>  <h3 id="log">LOG</h3> <p>Returns the natural logarithm (base e) of an expression.</p>  <h4 id="Syntax-N117C8">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>LOG(expression)</p> </td> </tr> </table>  <h4 id="Terms-N117DC">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N117F9">Usage</h4> <p> Use the LOG function to return the natural logarithm (base e) of an expression. </p>  <h3 id="log10">LOG10</h3> <p>Returns the base 10 logarithm of an expression.</p>  <h4 id="Syntax-N1180F">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>LOG10(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11823">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type double.</p> </td> </tr> </table>  <h4 id="Usage-N11840">Usage</h4> <p> Use the LOG10 function to return the base 10 logarithm of an expression. </p>  <h3 id="random">RANDOM</h3> <p>Returns a pseudo random number.</p>  <h4 id="Syntax-N11856">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>RANDOM( )</p> </td> </tr> </table>  <h4 id="Terms-N1186A">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>N/A</p> </td> <td colspan="1" rowspan="1"> <p>No terms.</p> </td> </tr> </table>  <h4 id="Usage-N11887">Usage</h4> <p> Use the RANDOM function to return a pseudo random number (type double) greater than or equal to 0.0 and less than 1.0. </p>  <h3 id="round">ROUND</h3> <p>Returns the value of an expression rounded to an integer.</p>  <h4 id="Syntax-N1189D">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ROUND(expression)</p> </td> </tr> </table>  <h4 id="Terms-N118B1">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type float or double.</p> </td> </tr> </table>  <h4 id="Usage-N118CE">Usage</h4> <p> Use the ROUND function to return the value of an expression rounded to an integer (if the result type is float) or rounded to a long (if the result type is double). </p> <p> Values are rounded towards positive infinity: <span class="codefrag">round(x) = floor(x + 0.5)</span>. </p> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>x</p> </td> <td colspan="1" rowspan="1"> <p>ROUND(x)</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 4.6</p> </td> <td colspan="1" rowspan="1"> <p> 5</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 3.5</p> </td> <td colspan="1" rowspan="1"> <p> 4</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 2.4</p> </td> <td colspan="1" rowspan="1"> <p> 2</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>1.0</p> </td> <td colspan="1" rowspan="1"> <p>1</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-1.0</p> </td> <td colspan="1" rowspan="1"> <p>-1</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-2.4</p> </td> <td colspan="1" rowspan="1"> <p>-2</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-3.5</p> </td> <td colspan="1" rowspan="1"> <p>-3</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>-4.6</p> </td> <td colspan="1" rowspan="1"> <p>-5</p> </td> </tr> </table>  <h3 id="round_to">ROUND_TO</h3> <p>Returns the value of an expression rounded to a fixed number of decimal digits.</p>  <h4 id="Syntax-N11998">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ROUND_TO(val, digits [, mode])</p> </td> </tr> </table>  <h4 id="Terms-N119AC">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>val</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type float or double: the value to round.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>digits</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is type int: the number of digits to preserve.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>mode</p> </td> <td colspan="1" rowspan="1"> <p> An optional int specifying the <a href="https://en.wikipedia.org/wiki/Rounding#Tie-breaking">rounding mode</a>, according to the <a href="http://docs.oracle.com/javase/7/docs/api/constant-values.html#java.math">constants Java provides</a>. </p> </td> </tr> </table>  <h4 id="Usage-N119F7">Usage</h4> <p> Use the ROUND function to return the value of an expression rounded to a fixed number of digits. Given a float, its result is a float; given a double its result is a double. </p> <p> The result is a multiple of the <span class="codefrag">digits</span>-th power of ten: 0 leads to no fractional digits; a negative value zeros out correspondingly many places to the left of the decimal point. </p> <p> When <span class="codefrag">mode</span> is omitted or has the value 6 (<a href="http://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html#HALF_EVEN"><span class="codefrag">RoundingMode.HALF_EVEN</span></a>), the result is rounded towards the nearest neighbor, and ties are <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even">rounded to the nearest even digit</a>. This mode minimizes cumulative error and tends to preserve the average of a set of values. </p> <p> When <span class="codefrag">mode</span> has the value 4 (<a href="http://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html#HALF_UP"><span class="codefrag">RoundingMode.HALF_UP</span></a>), the result is rounded towards the nearest neighbor, and ties are <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero">rounded away from zero</a>. This mode matches the behavior of most SQL systems. </p> <p> For other rounding modes, consult <a href="http://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html">Java's documentation</a>. There is no rounding mode that matches <span class="codefrag">Math.round</span>'s behavior (i.e. round towards positive infinity) -- blame Java, not Pig. </p> <table class="ForrestTable"> <tr> <th colspan="1" rowspan="1"> <p>val</p> </th> <th colspan="1" rowspan="1"> <p>digits</p> </th> <th colspan="1" rowspan="1"> <p>mode</p> </th> <th colspan="1" rowspan="1"> <p>ROUND_TO(val, digits)</p> </th> </tr> <tr> <td colspan="1" rowspan="1"> <p> 1234.1789</p> </td> <td colspan="1" rowspan="1"> <p> 8</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 1234.1789</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 1234.1789</p> </td> <td colspan="1" rowspan="1"> <p> 4</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 1234.1789</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 1234.1789</p> </td> <td colspan="1" rowspan="1"> <p> 1</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 1234.2</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 1234.1789</p> </td> <td colspan="1" rowspan="1"> <p> 0</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 1234.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 1234.1789</p> </td> <td colspan="1" rowspan="1"> <p>-1</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 1230.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 1234.1789</p> </td> <td colspan="1" rowspan="1"> <p>-3</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 1000.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 1234.1789</p> </td> <td colspan="1" rowspan="1"> <p>-4</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 0.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 3.25000001</p> </td> <td colspan="1" rowspan="1"> <p> 1</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 3.3</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 3.25</p> </td> <td colspan="1" rowspan="1"> <p> 1</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 3.2</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> -3.25</p> </td> <td colspan="1" rowspan="1"> <p> 1</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> -3.2</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 3.15</p> </td> <td colspan="1" rowspan="1"> <p> 1</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 3.2</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> -3.15</p> </td> <td colspan="1" rowspan="1"> <p> 1</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> -3.2</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 3.25</p> </td> <td colspan="1" rowspan="1"> <p> 1</p> </td> <td colspan="1" rowspan="1"> <p>4</p> </td> <td colspan="1" rowspan="1"> <p> 3.3</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> -3.25</p> </td> <td colspan="1" rowspan="1"> <p> 1</p> </td> <td colspan="1" rowspan="1"> <p>4</p> </td> <td colspan="1" rowspan="1"> <p> -3.3</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 3.5</p> </td> <td colspan="1" rowspan="1"> <p> 0</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 4.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> -3.5</p> </td> <td colspan="1" rowspan="1"> <p> 0</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> -4.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 2.5</p> </td> <td colspan="1" rowspan="1"> <p> 0</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> 2.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> -2.5</p> </td> <td colspan="1" rowspan="1"> <p> 0</p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> -2.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 3.5</p> </td> <td colspan="1" rowspan="1"> <p> 0</p> </td> <td colspan="1" rowspan="1"> <p>4</p> </td> <td colspan="1" rowspan="1"> <p> 4.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> -3.5</p> </td> <td colspan="1" rowspan="1"> <p> 0</p> </td> <td colspan="1" rowspan="1"> <p>4</p> </td> <td colspan="1" rowspan="1"> <p> -4.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> 2.5</p> </td> <td colspan="1" rowspan="1"> <p> 0</p> </td> <td colspan="1" rowspan="1"> <p>4</p> </td> <td colspan="1" rowspan="1"> <p> 3.0</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> -2.5</p> </td> <td colspan="1" rowspan="1"> <p> 0</p> </td> <td colspan="1" rowspan="1"> <p>4</p> </td> <td colspan="1" rowspan="1"> <p> -3.0</p> </td> </tr> </table>  <h3 id="sin">SIN</h3> <p>Returns the sine of an expression.</p>  <h4 id="Syntax-N11CAE">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>SIN(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11CC2">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is double.</p> </td> </tr> </table>  <h4 id="Usage-N11CDF">Usage</h4> <p> Use the SIN function to return the sine of an expession. </p>  <h3 id="sinh">SINH</h3> <p>Returns the hyperbolic sine of an expression.</p>  <h4 id="Syntax-N11CF5">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>SINH(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11D09">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is double.</p> </td> </tr> </table>  <h4 id="Usage-N11D26">Usage</h4> <p> Use the SINH function to return the hyperbolic sine of an expression. </p>  <h3 id="sqrt">SQRT</h3> <p>Returns the positive square root of an expression.</p>  <h4 id="Syntax-N11D3C">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>SQRT(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11D50">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is double.</p> </td> </tr> </table>  <h4 id="Usage-N11D6D">Usage</h4> <p> Use the SQRT function to return the positive square root of an expression. </p>  <h3 id="tan">TAN</h3> <p>Returns the trignometric tangent of an angle.</p>  <h4 id="Syntax-N11D83">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>TAN(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11D97">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression (angle) whose result is double.</p> </td> </tr> </table>  <h4 id="Usage-N11DB4">Usage</h4> <p> Use the TAN function to return the trignometric tangent of an angle. </p>  <h3 id="tanh">TANH</h3> <p>Returns the hyperbolic tangent of an expression. </p>  <h4 id="Syntax-N11DCA">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>TANH(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11DDE">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is double.</p> </td> </tr> </table>  <h4 id="Usage-N11DFB">Usage</h4> <p> Use the TANH function to return the hyperbolic tangent of an expression. </p> </div>      <h2 id="string-functions">String Functions</h2> <div class="section"> <p>For general information about these functions, see the <a href="http://docs.oracle.com/javase/6/docs/api/">Java API Specification</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html">Class String</a>. Note the following:</p> <ul> <li> <p>Pig function names are case sensitive and UPPER CASE.</p> </li> <li> <p>Pig string functions have an extra, first parameter: the string to which all the operations are applied.</p> </li> <li> <p>Pig may process results differently than as stated in the Java API Specification. If any of the input parameters are null or if an insufficient number of parameters are supplied, NULL is returned.</p> </li> </ul>  <h3 id="endswith">ENDSWITH</h3> <p>Tests inputs to determine if the first argument ends with the string in the second. </p>  <h4 id="Syntax-N11E40">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ENDSWITH(string, testAgainst)</p> </td> </tr> </table>  <h4 id="Terms-N11E54">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string to be tested.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>testAgainst</p> </td> <td colspan="1" rowspan="1"> <p>The string to test against.</p> </td> </tr> </table>  <h4 id="Usage-N11E84">Usage</h4> <p> Use the ENDSWITH function to determine if the first argument ends with the string in the second. </p> <p> For example, ENDSWITH ('foobar', 'foo') will false, whereas ENDSWITH ('foobar', 'bar') will return true. </p>  <h3 id="equalsignorecase">EqualsIgnoreCase</h3> <p>Compares two Strings ignoring case considerations. </p>  <h4 id="Syntax-N11E9D">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>EqualsIgnoreCase(string1, string2)</p> </td> </tr> </table>  <h4 id="Terms-N11EB1">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string1</p> </td> <td colspan="1" rowspan="1"> <p>The source string.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>string2</p> </td> <td colspan="1" rowspan="1"> <p>The string to compare against.</p> </td> </tr> </table>  <h4 id="Usage-N11EE1">Usage</h4> <p> Use the EqualsIgnoreCase function to determine if two string are equal ignoring case. </p>  <h3 id="indexof">INDEXOF</h3> <p>Returns the index of the first occurrence of a character in a string, searching forward from a start index. </p>  <h4 id="Syntax-N11EF7">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>INDEXOF(string, 'character', startIndex)</p> </td> </tr> </table>  <h4 id="Terms-N11F0C">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string to be searched.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>'character'</p> </td> <td colspan="1" rowspan="1"> <p>The character being searched for, in quotes. </p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>startIndex</p> </td> <td colspan="1" rowspan="1"> <p>The index from which to begin the forward search. </p> <p>The string index begins with zero (0).</p> </td> </tr> </table>  <h4 id="Usage-N11F52">Usage</h4> <p> Use the INDEXOF function to determine the index of the first occurrence of a character in a string. The forward search for the character begins at the designated start index. </p>  <h3 id="last-index-of">LAST_INDEX_OF</h3> <p>Returns the index of the last occurrence of a character in a string, searching backward from the end of the string. </p>  <h4 id="Syntax-N11F68">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>LAST_INDEX_OF(string, 'character')</p> </td> </tr> </table>  <h4 id="Terms-N11F7D">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string to be searched.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>'character'</p> </td> <td colspan="1" rowspan="1"> <p>The character being searched for, in quotes.</p> </td> </tr> </table>  <h4 id="Usage-N11FAD">Usage</h4> <p> Use the LAST_INDEX_OF function to determine the index of the last occurrence of a character in a string. The backward search for the character begins at the end of the string. </p>  <h3 id="lcfirst">LCFIRST</h3> <p>Converts the first character in a string to lower case. </p>  <h4 id="Syntax-N11FC3">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>LCFIRST(expression)</p> </td> </tr> </table>  <h4 id="Terms-N11FD8">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result type is chararray.</p> </td> </tr> </table>  <h4 id="Usage-N11FF5">Usage</h4> <p> Use the LCFIRST function to convert only the first character in a string to lower case. </p>  <h3 id="lower">LOWER</h3> <p>Converts all characters in a string to lower case. </p>  <h4 id="Syntax-N1200B">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>LOWER(expression)</p> </td> </tr> </table>  <h4 id="Terms-N12020">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result type is chararray.</p> </td> </tr> </table>  <h4 id="Usage-N1203D">Usage</h4> <p> Use the LOWER function to convert all characters in a string to lower case. </p>  <h3 id="ltrim">LTRIM</h3> <p>Returns a copy of a string with only leading white space removed.</p>  <h4 id="Syntax-N12053">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>LTRIM(expression)</p> </td> </tr> </table>  <h4 id="Terms-N12067">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is chararray. </p> </td> </tr> </table>  <h4 id="Usage-N12084">Usage</h4> <p> Use the LTRIM function to remove leading white space from a string. </p>  <h3 id="regex-extract">REGEX_EXTRACT </h3> <p>Performs regular expression matching and extracts the matched group defined by an index parameter. </p>  <h4 id="Syntax-N1209A">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>REGEX_EXTRACT (string, regex, index)</p> </td> </tr> </table>  <h4 id="Terms-N120AF">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string in which to perform the match.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>regex</p> </td> <td colspan="1" rowspan="1"> <p>The regular expression.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>index</p> </td> <td colspan="1" rowspan="1"> <p>The index of the matched group to return.</p> </td> </tr> </table>  <h4 id="Usage-N120F2">Usage</h4> <p> Use the REGEX_EXTRACT function to perform regular expression matching and to extract the matched group defined by the index parameter (where the index is a 1-based parameter.) The function uses Java regular expression form. </p> <p> The function returns a string that corresponds to the matched group in the position specified by the index. If there is no matched expression at that position, NULL is returned. </p>  <h4 id="Example-N120FF">Example</h4> <p> This example will return the string '192.168.1.5'. </p> <pre class="code">
REGEX_EXTRACT('192.168.1.5:8020', '(.*):(.*)', 1);
</pre>  <h3 id="regex-extract-all">REGEX_EXTRACT_ALL </h3> <p>Performs regular expression matching and extracts all matched groups.</p>  <h4 id="Syntax-N12119">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>REGEX_EXTRACT_ALL (string, regex)</p> </td> </tr> </table>  <h4 id="Terms-N1212E">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string in which to perform the match.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>regex</p> </td> <td colspan="1" rowspan="1"> <p>The regular expression.</p> </td> </tr> </table>  <h4 id="Usage-N1215E">Usage</h4> <p> Use the REGEX_EXTRACT_ALL function to perform regular expression matching and to extract all matched groups. The function uses Java regular expression form. </p> <p> The function returns a tuple where each field represents a matched expression. If there is no match, an empty tuple is returned. </p>  <h4 id="Example-N1216B">Example</h4> <p> This example will return the tuple (192.168.1.5,8020). </p> <pre class="code">
REGEX_EXTRACT_ALL('192.168.1.5:8020', '(.*)\:(.*)');
</pre>  <h3 id="regex-search">REGEX_SEARCH</h3> <p>Performs regular expression matching and searches all matched characters in a string.</p>  <h4 id="Syntax-N12185">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>REGEX_SEARCH(string, 'regExp');</p> </td> </tr> </table>  <h4 id="Terms-N1219A">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string in which to perform the match.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>'regExp'</p> </td> <td colspan="1" rowspan="1"> <p>The regular expression to which the string is to be matched, in quotes.</p> </td> </tr> </table>  <h4 id="Usage-N121CA">Usage</h4> <p> Use the REGEX_SEARCH function to perform regular expression matching and to find all matched characters in a string. </p> <p> The function returns tuples which are placed in a bag. Each tuple only contains one field which represents a matched expression. </p>  <h4 id="Example-N121D7">Example</h4> <p> This is example will return the bag {(=04 ),(=06 ),(=96 )}. </p> <pre class="code">
REGEX_SEARCH('a=04 b=06 c=96 or more', '(=\\d+\\s)');
</pre> <p> And this is example will return the bag {(04),(06),(96)}. </p> <pre class="code">
REGEX_SEARCH('a=04 b=06 c=96 or more', '=(\\d+)\\s');
</pre>  <h3 id="replace">REPLACE</h3> <p>Replaces existing characters in a string with new characters.</p>  <h4 id="Syntax-N121F8">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>REPLACE(string, 'regExp', 'newChar');</p> </td> </tr> </table>  <h4 id="Terms-N1220D">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string to be updated.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>'regExp'</p> </td> <td colspan="1" rowspan="1"> <p>The regular expression to which the string is to be matched, in quotes.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>'newChar'</p> </td> <td colspan="1" rowspan="1"> <p>The new characters replacing the existing characters, in quotes.</p> </td> </tr> </table>  <h4 id="Usage-N12250">Usage</h4> <p> Use the REPLACE function to replace existing characters in a string with new characters. </p> <p> For example, to change "open source software" to "open source wiki" use this statement: REPLACE(string,'software','wiki') </p> <p> Note that the REPLACE function is internally implemented using <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)"> java.string.replaceAll(String regex, String replacement)</a> where 'regExp' and 'newChar' are passed as the 1st and 2nd argument respectively. If you want to replace <a href="http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#bs"> special characters</a> such as '[' in the string literal, it is necessary to escape them in 'regExp' by prefixing them with double backslashes (e.g. '\\['). </p>  <h3 id="rtrim">RTRIM</h3> <p>Returns a copy of a string with only trailing white space removed.</p>  <h4 id="Syntax-N12274">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>RTRIM(expression)</p> </td> </tr> </table>  <h4 id="Terms-N12288">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is chararray. </p> </td> </tr> </table>  <h4 id="Usage-N122A5">Usage</h4> <p> Use the RTRIM function to remove trailing white space from a string. </p>  <h3 id="sprintf">SPRINTF</h3> <p>Formats a set of values according to a printf-style template, using the <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html">native Java Formatter</a> library.</p>  <h4 id="Syntax-N122BF">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>SPRINTF(format, [...vals])</p> </td> </tr> </table>  <h4 id="Terms-N122D3">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>format</p> </td> <td colspan="1" rowspan="1"> <p>The printf-style string describing the template.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>vals</p> </td> <td colspan="1" rowspan="1"> <p> The values to place in the template. There must be a tuple element for each formatting placeholder, and it must have the correct type: <span class="codefrag">int</span> or <span class="codefrag">long</span> for integer formats such as <span class="codefrag">%d</span>; <span class="codefrag">float</span> or <span class="codefrag">double</span> for decimal formats such as <span class="codefrag">%f</span>; and <span class="codefrag">long</span> for date/time formats such as <span class="codefrag">%t</span>. </p> </td> </tr> </table>  <h4 id="Usage-N1231B">Usage</h4> <p> Use the SPRINTF function to format a string according to a template. For example, SPRINTF("part-%05d", 69) will return 'part-00069'. </p> <table class="ForrestTable"> <tr> <th colspan="1" rowspan="1"> <p>String format specification</p> </th> <th colspan="1" rowspan="1"> <p>arg1</p> </th> <th colspan="1" rowspan="1"> <p>arg2</p> </th> <th colspan="1" rowspan="1"> <p>arg3</p> </th> <th colspan="1" rowspan="1"> <p>SPRINTF(format, arg1, arg2)</p> </th> <th colspan="1" rowspan="1"> <p>notes</p> </th> </tr> <tr> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'%8s|%8d|%-8s'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">1234567</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">1234567</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'yay'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">' 1234567| 1234567|yay '</span> </p> </td> <td colspan="1" rowspan="1"> <p>Format strings with %s, integers with %d. Types are converted for you where reasonable (here, int -&gt; string).</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>(null value)</p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">1234567</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">1234567</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'yay'</span> </p> </td> <td colspan="1" rowspan="1"> <p>(null value)</p> </td> <td colspan="1" rowspan="1"> <p>Returns null (no error or warning) with a null format string.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'%8s|%8d|%-8s'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">1234567</span> </p> </td> <td colspan="1" rowspan="1"> <p>(null value)</p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'yay'</span> </p> </td> <td colspan="1" rowspan="1"> <p>(null value)</p> </td> <td colspan="1" rowspan="1"> <p>Returns null (no error or warning) if any single argument is null.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'%8.3f|%6x'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">123.14159</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">665568</span> </p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">' 123.142| a27e0'</span> </p> </td> <td colspan="1" rowspan="1"> <p>Format floats/doubles with %f, hexadecimal integers with %x (there are others besides -- see the <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html">Java docs</a>)</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'%,+10d|%(06d'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">1234567</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">-123</span> </p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'+1,234,567|(0123)'</span> </p> </td> <td colspan="1" rowspan="1"> <p>Numerics take a prefix modifier: <span class="codefrag">,</span> for locale-specific thousands-delimiting, 0 for zero-padding; <span class="codefrag">+</span> to always show a plus sign for positive numbers; space  to allow a space preceding positive numbers; <span class="codefrag">(</span> to indicate negative numbers with parentheses (accountant-style).</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'%2$5d: %3$6s %1$3s %2$4x (%&lt;4X)'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'the'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">48879</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'wheres'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'48879: wheres the beef (BEEF)'</span> </p> </td> <td colspan="1" rowspan="1"> <p>Refer to args positionally and as many times as you like using <span class="codefrag">%(pos)$...</span>. Use <span class="codefrag">%&lt;...</span> to refer to the previously-specified arg.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'Launch Time: %14d %s'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">ToMilliSeconds(CurrentTime())</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">ToString(CurrentTime(), 'yyyy-MM-dd HH:mm:ss Z')</span> </p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'Launch Time: 1400164132000 2014-05-15 09:28:52 -0500'</span> </p> </td> <td colspan="1" rowspan="1"> <p>Instead use ToString to format the date/time portions and SPRINTF to layout the results.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'%8s|%-8s'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">1234567</span> </p> </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1">  </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">MissingFormatArgumentException: Format specifier '%-8s' </span> </p> </td>
<td colspan="1" rowspan="1"> <p>You must supply arguments for all specifiers</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'%8s'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">1234567</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'ignored'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag">'also'</span> </p> </td> <td colspan="1" rowspan="1"> <p> <span class="codefrag"> 1234567</span> </p> </td> <td colspan="1" rowspan="1"> <p>It's OK to supply too many, though</p> </td> </tr> </table> <p> <em>Note: although the Java formatter (and thus this function) offers the <span class="codefrag">%t</span> specifier for date/time elements, it's best avoided: it's cumbersome, the output and timezone handling may differ from what you expect, and it doesn't accept datetime objects from pig. Instead, just prepare dates usint the ToString UDF as shown.</em> </p>  <h3 id="startswith">STARTSWITH</h3> <p>Tests inputs to determine if the first argument starts with the string in the second. </p>  <h4 id="Syntax-N124E8">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>STARTSWITH(string, testAgainst)</p> </td> </tr> </table>  <h4 id="Terms-N124FC">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string to be tested.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>testAgainst</p> </td> <td colspan="1" rowspan="1"> <p>The string to test against.</p> </td> </tr> </table>  <h4 id="Usage-N1252C">Usage</h4> <p> Use the STARTSWITH function to determine if the first argument starts with the string in the second. </p> <p> For example, STARTSWITH ('foobar', 'foo') will true, whereas STARTSWITH ('foobar', 'bar') will return false. </p>  <h3 id="strsplit">STRSPLIT</h3> <p>Splits a string around matches of a given regular expression. </p>  <h4 id="Syntax-N12545">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>STRSPLIT(string, regex, limit)</p> </td> </tr> </table>  <h4 id="Terms-N12559">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string to be split.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>regex</p> </td> <td colspan="1" rowspan="1"> <p>The regular expression.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>limit</p> </td> <td colspan="1" rowspan="1"> <p>If the value is positive, the pattern (the compiled representation of the regular expression) is applied at most limit-1 times, therefore the value of the argument means the maximum length of the result tuple. The last element of the result tuple will contain all input after the last match.</p> <p>If the value is negative, no limit is applied for the length of the result tuple.</p> <p>If the value is zero, no limit is applied for the length of the result tuple too, and trailing empty strings (if any) will be removed.</p> </td> </tr> </table>  <h4 id="Usage-N125A2">Usage</h4> <p> Use the STRSPLIT function to split a string around matches of a given regular expression. </p> <p> For example, given the string (open:source:software), STRSPLIT (string, ':',2) will return ((open,source:software)) and STRSPLIT (string, ':',3) will return ((open,source,software)). </p>  <h3 id="strsplittobag">STRSPLITTOBAG</h3> <p>Splits a string around matches of a given regular expression and returns a databag</p>  <h4 id="Syntax-N125BB">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>STRSPLITTOBAG(string, regex, limit)</p> </td> </tr> </table>  <h4 id="Terms-N125D0">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string to be split.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>regex</p> </td> <td colspan="1" rowspan="1"> <p>The regular expression.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>limit</p> </td> <td colspan="1" rowspan="1"> <p>If the value is positive, the pattern (the compiled representation of the regular expression) is applied at most limit-1 times, therefore the value of the argument means the maximum size of the result bag. The last tuple of the result bag will contain all input after the last match. </p> <p>If the value is negative, no limit is applied to the size of the result bag.</p> <p>If the value is zero, no limit is applied to the size of the result bag too, and trailing empty strings (if any) will be removed. </p> </td> </tr> </table>  <h4 id="Usage-N12619">Usage</h4> <p> Use the STRSPLITTOBAG function to split a string around matches of a given regular expression. </p> <p> For example, given the string (open:source:software), STRSPLITTOBAG (string, ':',2) will return {(open),(source:software)} and STRSPLITTOBAG (string, ':',3) will return {(open),(source),(software)}. </p>  <h3 id="substring">SUBSTRING</h3> <p>Returns a substring from a given string. </p>  <h4 id="Syntax-N12632">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>SUBSTRING(string, startIndex, stopIndex)</p> </td> </tr> </table>  <h4 id="Terms-N12646">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>string</p> </td> <td colspan="1" rowspan="1"> <p>The string from which a substring will be extracted.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>startIndex</p> </td> <td colspan="1" rowspan="1"> <p>The index (type integer) of the first character of the substring.</p> <p>The index of a string begins with zero (0).</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>stopIndex</p> </td> <td colspan="1" rowspan="1"> <p>The index (type integer) of the character <em>following</em> the last character of the substring.</p> </td> </tr> </table>  <h4 id="Usage-N1268F">Usage</h4> <p> Use the SUBSTRING function to return a substring from a given string. </p> <p> Given a field named alpha whose value is ABCDEF, to return substring BCD use this statement: SUBSTRING(alpha,1,4). Note that 1 is the index of B (the first character of the substring) and 4 is the index of E (the character <em>following</em> the last character of the substring). </p>  <h3 id="trim">TRIM</h3> <p>Returns a copy of a string with leading and trailing white space removed.</p>  <h4 id="Syntax-N126AB">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>TRIM(expression)</p> </td> </tr> </table>  <h4 id="Terms-N126BF">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result is chararray. </p> </td> </tr> </table>  <h4 id="Usage-N126DC">Usage</h4> <p> Use the TRIM function to remove leading and trailing white space from a string. </p>  <h3 id="ucfirst">UCFIRST</h3> <p>Returns a string with the first character converted to upper case. </p>  <h4 id="Syntax-N126F2">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>UCFIRST(expression)</p> </td> </tr> </table>  <h4 id="Terms-N12706">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result type is chararray.</p> </td> </tr> </table>  <h4 id="Usage-N12723">Usage</h4> <p> Use the UCFIRST function to convert only the first character in a string to upper case. </p>  <h3 id="upper">UPPER</h3> <p>Returns a string converted to upper case. </p>  <h4 id="Syntax-N12739">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>UPPER(expression)</p> </td> </tr> </table>  <h4 id="Terms-N1274D">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression whose result type is chararray. </p> </td> </tr> </table>  <h4 id="Usage-N1276A">Usage</h4> <p> Use the UPPER function to convert all characters in a string to upper case. </p>  <h3 id="uniqueid">UniqueID</h3> <p>Returns a unique id string for each record in the alias. </p>  <h4 id="Usage-N1277E">Usage</h4> <p> UniqueID generates a unique id for each records. The id takes form "taskindex-sequence" </p> </div>      <h2 id="datetime-functions">Datetime Functions</h2> <div class="section"> <p> For general information about datetime type operations, see the <a href="http://docs.oracle.com/javase/6/docs/api/">Java API Specification</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Date.html">Java Date class</a>, and <a href="http://joda-time.sourceforge.net/apidocs/index.html">JODA DateTime class</a>. And for the information of ISO date and time formats, please refer to <a href="http://www.w3.org/TR/NOTE-datetime">Date and Time Formats</a>. </p>  <h3 id="add-duration">AddDuration</h3> <p>Returns the result of a DateTime object plus a <a href="http://en.wikipedia.org/wiki/ISO_8601#Durations">Duration object</a>.</p>  <h4 id="Syntax-N127BA">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>AddDuration(datetime, duration)</p> </td> </tr> </table>  <h4 id="Terms-N127CF">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>duration</p> </td> <td colspan="1" rowspan="1"> <p>The duration string in <a href="http://en.wikipedia.org/wiki/ISO_8601#Durations">ISO 8601 format</a>.</p> </td> </tr> </table>  <h4 id="Usage-N12803">Usage</h4> <p> Use the AddDuration function to created a new datetime object by add some duration to a given datetime object. </p>  <h3 id="current-time">CurrentTime</h3> <p>Returns the DateTime object of the current time.</p>  <h4 id="Syntax-N12819">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>CurrentTime()</p> </td> </tr> </table>  <h4 id="Usage-N1282E">Usage</h4> <p> Use the CurrentTime function to generate a datetime object of current timestamp with millisecond accuracy. </p>  <h3 id="days-between">DaysBetween</h3> <p>Returns the number of days between two DateTime objects.</p>  <h4 id="Syntax-N12844">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>DaysBetween(datetime1, datetime2)</p> </td> </tr> </table>  <h4 id="Terms-N12859">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime1</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>datetime2</p> </td> <td colspan="1" rowspan="1"> <p>Another datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12889">Usage</h4> <p> Use the DaysBetween function to get the number of days between the two given datetime objects. </p>  <h3 id="get-day">GetDay</h3> <p>Returns the day of a month from a DateTime object.</p>  <h4 id="Syntax-N1289F">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>GetDay(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N128B4">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N128D1">Usage</h4> <p> Use the GetDay function to extract the day of a month from the given datetime object. </p>  <h3 id="get-hour">GetHour</h3> <p>Returns the hour of a day from a DateTime object.</p>  <h4 id="Syntax-N128E7">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>GetHour(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N128FC">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12919">Usage</h4> <p> Use the GetHour function to extract the hour of a day from the given datetime object. </p>  <h3 id="get-milli-second">GetMilliSecond</h3> <p>Returns the millisecond of a second from a DateTime object.</p>  <h4 id="Syntax-N1292F">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>GetMilliSecond(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N12944">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12961">Usage</h4> <p> Use the GetMilliSecond function to extract the millsecond of a second from the given datetime object. </p>  <h3 id="get-minute">GetMinute</h3> <p>Returns the minute of a hour from a DateTime object.</p>  <h4 id="Syntax-N12977">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>GetMinute(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N1298C">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N129A9">Usage</h4> <p> Use the GetMinute function to extract the minute of a hour from the given datetime object. </p>  <h3 id="get-month">GetMonth</h3> <p>Returns the month of a year from a DateTime object.</p>  <h4 id="Syntax-N129BF">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>GetMonth(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N129D4">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N129F1">Usage</h4> <p> Use the GetMonth function to extract the month of a year from the given datetime object. </p>  <h3 id="get-second">GetSecond</h3> <p>Returns the second of a minute from a DateTime object.</p>  <h4 id="Syntax-N12A07">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>GetSecond(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N12A1C">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12A39">Usage</h4> <p> Use the GetSecond function to extract the second of a minute from the given datetime object. </p>  <h3 id="get-week">GetWeek</h3> <p>Returns the week of a week year from a DateTime object.</p>  <h4 id="Syntax-N12A4F">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>GetWeek(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N12A64">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12A81">Usage</h4> <p> Use the GetWeek function to extract the week of a week year from the given datetime object. Note that week year may be different from year. </p>  <h3 id="get-week-year">GetWeekYear</h3> <p>Returns the week year from a DateTime object.</p>  <h4 id="Syntax-N12A97">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>GetWeekYear(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N12AAC">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12AC9">Usage</h4> <p> Use the GetWeekYear function to extract the week year from the given datetime object. Note that week year may be different from year. </p>  <h3 id="get-year">GetYear</h3> <p>Returns the year from a DateTime object.</p>  <h4 id="Syntax-N12ADF">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>GetYear(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N12AF4">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12B11">Usage</h4> <p> Use the GetYear function to extract the year from the given datetime object. </p>  <h3 id="hours-between">HoursBetween</h3> <p>Returns the number of hours between two DateTime objects.</p>  <h4 id="Syntax-N12B27">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>HoursBetween(datetime1, datetime2)</p> </td> </tr> </table>  <h4 id="Terms-N12B3C">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime1</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>datetime2</p> </td> <td colspan="1" rowspan="1"> <p>Another datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12B6C">Usage</h4> <p> Use the HoursBetween function to get the number of hours between the two given datetime objects. </p>  <h3 id="milli-seconds-between">MilliSecondsBetween</h3> <p>Returns the number of milliseconds between two DateTime objects.</p>  <h4 id="Syntax-N12B82">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>MilliSecondsBetween(datetime1, datetime2)</p> </td> </tr> </table>  <h4 id="Terms-N12B97">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime1</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>datetime2</p> </td> <td colspan="1" rowspan="1"> <p>Another datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12BC7">Usage</h4> <p> Use the MilliSecondsBetween function to get the number of millseconds between the two given datetime objects. </p>  <h3 id="minutes-between">MinutesBetween</h3> <p>Returns the number of minutes between two DateTime objects.</p>  <h4 id="Syntax-N12BDD">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>MinutesBetween(datetime1, datetime2)</p> </td> </tr> </table>  <h4 id="Terms-N12BF2">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime1</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>datetime2</p> </td> <td colspan="1" rowspan="1"> <p>Another datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12C22">Usage</h4> <p> Use the MinutsBetween function to get the number of minutes between the two given datetime objects. </p>  <h3 id="months-between">MonthsBetween</h3> <p>Returns the number of months between two DateTime objects.</p>  <h4 id="Syntax-N12C38">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>MonthsBetween(datetime1, datetime2)</p> </td> </tr> </table>  <h4 id="Terms-N12C4D">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime1</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>datetime2</p> </td> <td colspan="1" rowspan="1"> <p>Another datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12C7D">Usage</h4> <p> Use the MonthsBetween function to get the number of months between the two given datetime objects. </p>  <h3 id="seconds-between">SecondsBetween</h3> <p>Returns the number of seconds between two DateTime objects.</p>  <h4 id="Syntax-N12C93">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>SecondsBetween(datetime1, datetime2)</p> </td> </tr> </table>  <h4 id="Terms-N12CA8">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime1</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>datetime2</p> </td> <td colspan="1" rowspan="1"> <p>Another datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12CD8">Usage</h4> <p> Use the SecondsBetween function to get the number of seconds between the two given datetime objects. </p>  <h3 id="subtract-duration">SubtractDuration</h3> <p>Returns the result of a DateTime object minus a <a href="http://en.wikipedia.org/wiki/ISO_8601#Durations">Duration object</a>.</p>  <h4 id="Syntax-N12CF2">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>SubtractDuration(datetime, duration)</p> </td> </tr> </table>  <h4 id="Terms-N12D07">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>duration</p> </td> <td colspan="1" rowspan="1"> <p>The duration string in <a href="http://en.wikipedia.org/wiki/ISO_8601#Durations">ISO 8601 format</a>.</p> </td> </tr> </table>  <h4 id="Usage-N12D3B">Usage</h4> <p> Use the AddDuration function to created a new datetime object by add some duration to a given datetime object. </p>  <h3 id="to-date">ToDate</h3> <p>Returns a DateTime object according to parameters.</p>  <h4 id="Syntax-N12D51">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ToDate(milliseconds)</p> <p>ToDate(iosstring)</p> <p>ToDate(userstring, format)</p> <p>ToDate(userstring, format, timezone)</p> </td> </tr> </table>  <h4 id="Terms-N12D6F">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>millseconds</p> </td> <td colspan="1" rowspan="1"> <p>The offset from 1970-01-01T00:00:00.000Z in terms of the number milliseconds (either positive or negative).</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>isostring</p> </td> <td colspan="1" rowspan="1"> <p>The datetime string in the <a href="http://www.w3.org/TR/NOTE-datetime">ISO 8601 format</a>.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>userstring</p> </td> <td colspan="1" rowspan="1"> <p>The datetime string in the user defined format.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>format</p> </td> <td colspan="1" rowspan="1"> <p>The date time format pattern string (see <a href="http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html">Java SimpleDateFormat class</a>).</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>timezone</p> </td> <td colspan="1" rowspan="1"> <p>The timezone string. Either the UTC offset and the location based format can be used as a parameter, while internally the timezone will be converted to the UTC offset format.</p> <p>Please see <a href="http://joda-time.sourceforge.net/timezones.html">the Joda-Time doc</a> for available timezone IDs.</p> </td> </tr> </table>  <h4 id="Usage-N12DE7">Usage</h4> <p> Use the ToDate function to generate a DateTime object. Note that if the timezone is not specified with the ISO datetime string or by the timezone parameter, the default timezone will be used. </p>  <h3 id="to-milli-seconds">ToMilliSeconds</h3> <p> Returns the number of milliseconds elapsed since January 1, 1970, 00:00:00.000 GMT for a DateTime object. </p>  <h4 id="Syntax-N12DFD">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ToMilliSeconds(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N12E12">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12E2F">Usage</h4> <p> Use the ToMilliSeconds function to convert the DateTime to the number of milliseconds that have passed since January 1, 1970 00:00:00.000 GMT. </p>  <h3 id="to-string">ToString</h3> <p> ToString converts the DateTime object to the ISO or the customized string. </p>  <h4 id="Syntax-N12E45">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ToString(datetime [, format string])</p> </td> </tr> </table>  <h4 id="Terms-N12E5A">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>format string</p> </td> <td colspan="1" rowspan="1"> <p>The date time format pattern string (see <a href="http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html">Java SimpleDateFormat class</a>).</p> </td> </tr> </table>  <h4 id="Usage-N12E8E">Usage</h4> <p> Use the ToString function to convert the DateTime to the customized string. </p>  <h3 id="to-unix-time">ToUnixTime</h3> <p> Returns the Unix Time as long for a DateTime object. UnixTime is the number of seconds elapsed since January 1, 1970, 00:00:00.000 GMT. </p>  <h4 id="Syntax-N12EA4">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>ToUnixTime(datetime)</p> </td> </tr> </table>  <h4 id="Terms-N12EB9">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12ED6">Usage</h4> <p> Use the ToUnixTime function to convert the DateTime to Unix Time. </p>  <h3 id="weeks-between">WeeksBetween</h3> <p>Returns the number of weeks between two DateTime objects.</p>  <h4 id="Syntax-N12EEC">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>WeeksBetween(datetime1, datetime2)</p> </td> </tr> </table>  <h4 id="Terms-N12F01">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime1</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>datetime2</p> </td> <td colspan="1" rowspan="1"> <p>Another datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12F31">Usage</h4> <p> Use the WeeksBetween function to get the number of weeks between the two given datetime objects. </p>  <h3 id="years-between">YearsBetween</h3> <p>Returns the number of years between two DateTime objects.</p>  <h4 id="Syntax-N12F47">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>YearsBetween(datetime1, datetime2)</p> </td> </tr> </table>  <h4 id="Terms-N12F5C">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>datetime1</p> </td> <td colspan="1" rowspan="1"> <p>A datetime object.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>datetime2</p> </td> <td colspan="1" rowspan="1"> <p>Another datetime object.</p> </td> </tr> </table>  <h4 id="Usage-N12F8C">Usage</h4> <p> Use the YearsBetween function to get the number of years between the two given datetime objects. </p> </div>      <h2 id="bag-tuple-functions">Tuple, Bag, Map Functions</h2> <div class="section">  <h3 id="totuple">TOTUPLE</h3> <p>Converts one or more expressions to type tuple. </p>  <h4 id="Syntax-N12FB1">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>TOTUPLE(expression [, expression ...])</p> </td> </tr> </table>  <h4 id="Terms-N12FC6">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression of any datatype.</p> </td> </tr> </table>  <h4 id="Usage-N12FE3">Usage</h4> <p>Use the TOTUPLE function to convert one or more expressions to a tuple.</p> <p>See also: <a href="basic.html#tuple">Tuple</a> data type and <a href="basic.html#type-construction">Type Construction Operators</a> </p>  <h4 id="Example-N12FF7">Example</h4> <p> In this example, fields f1, f2 and f3 are converted to a tuple. </p> <pre class="code">
a = LOAD 'student' AS (f1:chararray, f2:int, f3:float);
DUMP a;

(John,18,4.0)
(Mary,19,3.8)
(Bill,20,3.9)
(Joe,18,3.8)

b = FOREACH a GENERATE TOTUPLE(f1,f2,f3);
DUMP b;

((John,18,4.0))
((Mary,19,3.8))
((Bill,20,3.9))
((Joe,18,3.8))
</pre>  <h3 id="tobag">TOBAG</h3> <p>Converts one or more expressions to type bag. </p>  <h4 id="Syntax-N13011">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>TOBAG(expression [, expression ...])</p> </td> </tr> </table>  <h4 id="Terms-N13026">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression with any data type.</p> </td> </tr> </table>  <h4 id="Usage-N13043">Usage</h4> <p>Use the TOBAG function to convert one or more expressions to individual tuples which are then placed in a bag.</p> <p>See also: <a href="basic.html#bag">Bag</a> data type and <a href="basic.html#type-construction">Type Construction Operators</a> </p>  <h4 id="Example-N13057">Example</h4> <p> In this example, fields f1 and f3 are converted to tuples that are then placed in a bag. </p> <pre class="code">
a = LOAD 'student' AS (f1:chararray, f2:int, f3:float);
DUMP a;

(John,18,4.0)
(Mary,19,3.8)
(Bill,20,3.9)
(Joe,18,3.8)

b = FOREACH a GENERATE TOBAG(f1,f3);
DUMP b;

({(John),(4.0)})
({(Mary),(3.8)})
({(Bill),(3.9)})
({(Joe),(3.8)})
</pre>  <h3 id="tomap">TOMAP</h3> <p>Converts key/value expression pairs into a map. </p>  <h4 id="Syntax-N13071">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>TOMAP(key-expression, value-expression [, key-expression, value-expression ...])</p> </td> </tr> </table>  <h4 id="Terms-N13086">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>key-expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression of type chararray.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>value-expression</p> </td> <td colspan="1" rowspan="1"> <p>An expression of any type supported by a map.</p> </td> </tr> </table>  <h4 id="Usage-N130B6">Usage</h4> <p>Use the TOMAP function to convert pairs of expressions into a map. Note the following:</p> <ul> <li>You must supply an even number of expressions as parameters</li> <li>The elements must comply with map type rules: <ul> <li>Every odd element (key-expression) must be a chararray since only chararrays can be keys into the map</li> <li>Every even element (value-expression) can be of any type supported by a map. </li> </ul> </li> </ul>  <p>See also: <a href="basic.html#map">Map</a> data type and <a href="basic.html#type-construction">Type Construction Operators</a> </p>  <h4 id="Example-N130DE">Example</h4> <p> In this example, student names (type chararray) and student GPAs (type float) are used to create three maps. </p> <pre class="code">
A = load 'students' as (name:chararray, age:int, gpa:float);
B = foreach A generate TOMAP(name, gpa);
store B into 'results';

Input (students)
joe smith 20 3.5
amy chen 22 3.2
leo allen 18 2.1

Output (results)
[joe smith#3.5]
[amy chen#3.2]
[leo allen#2.1]
</pre>  <h3 id="topx">TOP</h3> <p>Returns the top-n tuples from a bag of tuples.</p>  <h4 id="Syntax-N130F8">Syntax</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>TOP(topN,column,relation)</p> </td> </tr> </table>  <h4 id="Terms-N1310D">Terms</h4> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>topN</p> </td> <td colspan="1" rowspan="1"> <p>The number of top tuples to return (type integer).</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>column</p> </td> <td colspan="1" rowspan="1"> <p>The tuple column whose values are being compared, note 0 denotes the first column.</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>relation</p> </td> <td colspan="1" rowspan="1"> <p>The relation (bag of tuples) containing the tuple column.</p> </td> </tr> </table>  <h4 id="Usage-N13150">Usage</h4> <p> TOP function returns a bag containing top N tuples from the input bag where N is controlled by the first parameter to the function. The tuple comparison is performed based on a single column from the tuple. The column position is determined by the second parameter to the function. The function assumes that all tuples in the bag contain an element of the same type in the compared column. </p> <p> By default, TOP function uses descending order. But it can be configured via DEFINE statement. </p> <pre class="code">
DEFINE asc TOP('ASC'); -- ascending order
DEFINE desc TOP('DESC'); -- descending order
</pre>  <h4 id="Example-N13161">Example</h4> <p> In this example the top 10 occurrences are returned. </p> <pre class="code">
DEFINE asc TOP('ASC'); -- ascending order
DEFINE desc TOP('DESC'); -- descending order

A = LOAD 'data' as (first: chararray, second: chararray);
B = GROUP A BY (first, second);
C = FOREACH B generate FLATTEN(group), COUNT(A) as count;
D = GROUP C BY first; -- again group by first
topResults = FOREACH D {
    result = asc(10, 1, C); -- and retain top 10 (in ascending order) occurrences of 'second' in first  
    GENERATE FLATTEN(result);
}

bottomResults = FOREACH D {
    result = desc(10, 1, C); -- and retain top 10  (in descending order) occurrences of 'second' in first  
    GENERATE FLATTEN(result);
}
</pre> </div>      <h2 id="hive-udf">Hive UDF</h2> <div class="section"> <p>Pig invokes all types of Hive UDF, including UDF, GenericUDF, UDAF, GenericUDAF and GenericUDTF. Depending on the Hive UDF you want to use, you need to declare it in Pig with HiveUDF(handles UDF and GenericUDF), HiveUDAF(handles UDAF and GenericUDAF), HiveUDTF(handles GenericUDTF).</p>  <h3 id="Syntax-N13182">Syntax</h3> <p>HiveUDF, HiveUDAF, HiveUDTF share the same syntax.</p> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>HiveUDF(name[, constant parameters])</p> </td> </tr> </table>  <h3 id="Terms-N1319A">Terms</h3> <table class="ForrestTable"> <tr> <td colspan="1" rowspan="1"> <p>name</p> </td> <td colspan="1" rowspan="1"> <p>Hive UDF name. This can be a fully qualified class name of the Hive UDF/UDTF/UDAF class, or a registered short name in Hive FunctionRegistry (most Hive builtin UDF does that)</p> </td> </tr> <tr> <td colspan="1" rowspan="1"> <p>constant parameters</p> </td> <td colspan="1" rowspan="1"> <p>Optional tuple representing constant parameters of a Hive UDF/UDTF/UDAF. If Hive UDF requires a constant parameter, there is no other way Pig can pass that information to Hive, since Pig schema does not carry the information whether a parameter is constant or not. Null item in the tuple means this field is not a constant. Non-null item represents a constant field. Data type for the item is determined by Pig contant parser.</p> </td> </tr> </table>  <h3 id="Example-N131CA">Example</h3> <p>HiveUDF</p> <pre class="code">
define sin HiveUDF('sin');
A = LOAD 'student' as (name:chararray, age:int, gpa:double);
B = foreach A generate sin(gpa);
  </pre> <p>HiveUDTF</p> <pre class="code">
define explode HiveUDTF('explode');
A = load 'mydata' as (a0:{(b0:chararray)});
B = foreach A generate flatten(explode(a0));
  </pre> <p>HiveUDAF</p> <pre class="code">
define avg HiveUDAF('avg');
A = LOAD 'student' as (name:chararray, age:int, gpa:double);
B = group A by name;
C = foreach B generate group, avg(A.age);
  </pre> <p>HiveUDAF with constant parameter</p> <pre class="code">
define in_file HiveUDF('in_file', '(null, "names.txt")');
A = load 'student' as (name:chararray, age:long, gpa:double);
B = foreach A generate in_file(name, 'names.txt');
</pre> <p>In this example, we pass (null, "names.txt") to the construct of UDF in_file, meaning the first parameter is regular, the second parameter is a constant. names.txt can be double quoted (unlike other Pig syntax), or quoted in \'. Note we need to pass 'names.txt' again in line 3. This looks stupid but we need to do this to fill the semantic gap between Pig and Hive. We need to pass the constant in the data pipeline in line 3, which is similar Pig UDF. Initialization code in Hive UDF takes ObjectInspector, which capture the data type and whether or not the parameter is a constant. However, initialization code in Pig takes schema, which only capture the former. We need to use additional mechanism (construct parameter) to convey the later.</p> <p>Note: A few Hive 0.14 UDF contains bug which affects Pig and are fixed in Hive 1.0. Here is a list: compute_stats, context_ngrams, count, ewah_bitmap, histogram_numeric, collect_list, collect_set, ngrams, case, in, named_struct, stack, percentile_approx.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2017 Apache Software Foundation<br>Licensed under the Apache Software License version 2.0.<br>
    <a href="https://pig.apache.org/docs/r0.17.0/func.html" class="_attribution-link">https://pig.apache.org/docs/r0.17.0/func.html</a>
  </p>
</div>
