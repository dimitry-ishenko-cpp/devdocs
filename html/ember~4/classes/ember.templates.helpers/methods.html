<article class="chapter">  <h1 class="module-name">Class Ember.Templates.helpers</h1> <span class="access">public</span> <table>  <tr> <th>Defined in:</th> <td> <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/index.ts#L86" target="_blank" rel="noopener noreferrer">packages/@ember/-internals/glimmer/index.ts:86</a> </td> </tr> <tr> <th>Module:</th> <td> <a href="../../modules/ember.html"> ember </a> </td> </tr>  </table>     <h3 role="link" id="action">  <span class="method-name">action</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/action.ts#L18" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/action.ts:18 </a> </p>   <p>The <code>{{action}}</code> helper provides a way to pass triggers for behavior (usually just a function) between components, and into components from controllers.</p> <h4 id="passing-functions-with-the-action-helper">Passing functions with the action helper</h4> <p>There are three contexts an action helper can be used in. The first two contexts to discuss are attribute context, and Handlebars value context.</p> <pre class="highlight handlebars" data-language="html">{{! An example of attribute context }}
&lt;div onclick={{action "save"}}&gt;&lt;/div&gt;
{{! Examples of Handlebars value context }}
{{input on-input=(action "save")}}
{{yield (action "refreshData") andAnotherParam}}</pre> <p>In these contexts, the helper is called a "closure action" helper. Its behavior is simple: If passed a function name, read that function off the <code>actions</code> property of the current context. Once that function is read, or immediately if a function was passed, create a closure over that function and any arguments. The resulting value of an action helper used this way is simply a function.</p> <p>For example, in the attribute context:</p> <pre class="highlight handlebars" data-language="html">{{! An example of attribute context }}
&lt;div onclick={{action "save"}}&gt;&lt;/div&gt;</pre> <p>The resulting template render logic would be:</p> <pre class="highlight javascript" data-language="javascript">var div = document.createElement('div');
var actionFunction = (function(context){
  return function() {
    return context.actions.save.apply(context, arguments);
  };
})(context);
div.onclick = actionFunction;</pre> <p>Thus when the div is clicked, the action on that context is called. Because the <code>actionFunction</code> is just a function, closure actions can be passed between components and still execute in the correct context.</p> <p>Here is an example action handler on a component:</p> <div class="pre-title"><code>component.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@glimmer/component';
import { action } from '@ember/object';

export default class extends Component {
  @action
  save() {
    this.model.save();
  }
}</pre> <p>Actions are always looked up on the <code>actions</code> property of the current context. This avoids collisions in the naming of common actions, such as <code>destroy</code>. Two options can be passed to the <code>action</code> helper when it is used in this way.</p> <ul> <li>
<code>target=someProperty</code> will look to <code>someProperty</code> instead of the current context for the <code>actions</code> hash. This can be useful when targeting a service for actions.</li> <li>
<code>value="target.value"</code> will read the path <code>target.value</code> off the first argument to the action when it is called and rewrite the first argument to be that value. This is useful when attaching actions to event listeners.</li> </ul> <h4 id="invoking-an-action">Invoking an action</h4> <p>Closure actions curry both their scope and any arguments. When invoked, any additional arguments are added to the already curried list. Actions are presented in JavaScript as callbacks, and are invoked like any other JavaScript function.</p> <p>For example</p> <div class="pre-title"><code>name.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@glimmer/component';
import { action } from '@ember/object';

export default class extends Component {
  @action
  setName(model, name) {
    model.set('name', name);
  }
}</pre> <div class="pre-title"><code>name.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{input on-input=(action (action 'setName' @model) value="target.value")}}</pre> <p>The first argument (<code>@model</code>) was curried over, and the run-time argument (<code>event</code>) becomes a second argument. Action calls can be nested this way because each simply returns a function. Any function can be passed to the <code>{{action}}</code> helper, including other actions.</p> <p>Actions invoked with <code>sendAction</code> have the same currying behavior as demonstrated with <code>on-input</code> above. For example:</p> <div class="pre-title"><code>input.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@glimmer/component';
import { action } from '@ember/object';

export default class extends Component {
  @action
  setName(model, name) {
    model.set('name', name);
  }
}</pre> <pre class="highlight handlebars" data-language="html">&lt;MyInput @submit={{action 'setName' @model}} /&gt;</pre> <p>or</p> <pre class="highlight handlebars" data-language="html">{{my-input submit=(action 'setName' @model)}}</pre> <div class="pre-title"><code>component.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@ember/component';

export default Component.extend({
  click() {
    // Note that model is not passed, it was curried in the template
    this.submit('bob');
  }
});</pre> <h4 id="attaching-actions-to-dom-elements">Attaching actions to DOM elements</h4> <p>The third context of the <code>{{action}}</code> helper can be called "element space". For example:</p> <pre class="highlight handlebars" data-language="html">{{! An example of element space }}
&lt;div {{action "save"}}&gt;&lt;/div&gt;</pre> <p>Used this way, the <code>{{action}}</code> helper provides a useful shortcut for registering an HTML element in a template for a single DOM event and forwarding that interaction to the template's context (controller or component). If the context of a template is a controller, actions used this way will bubble to routes when the controller does not implement the specified action. Once an action hits a route, it will bubble through the route hierarchy.</p> <h4 id="event-propagation">Event Propagation</h4> <p><code>{{action}}</code> helpers called in element space can control event bubbling. Note that the closure style actions cannot.</p> <p>Events triggered through the action helper will automatically have <code>.preventDefault()</code> called on them. You do not need to do so in your event handlers. If you need to allow event propagation (to handle file inputs for example) you can supply the <code>preventDefault=false</code> option to the <code>{{action}}</code> helper:</p> <pre class="highlight handlebars" data-language="html">&lt;div {{action "sayHello" preventDefault=false}}&gt;
  &lt;input type="file" /&gt;
  &lt;input type="checkbox" /&gt;
&lt;/div&gt;</pre> <p>To disable bubbling, pass <code>bubbles=false</code> to the helper:</p> <pre class="highlight handlebars" data-language="html">&lt;button {{action 'edit' post bubbles=false}}&gt;Edit&lt;/button&gt;</pre> <p>To disable bubbling with closure style actions you must create your own wrapper helper that makes use of <code>event.stopPropagation()</code>:</p> <pre class="highlight handlebars" data-language="html">&lt;div onclick={{disable-bubbling (action "sayHello")}}&gt;Hello&lt;/div&gt;</pre> <div class="pre-title"><code>bubbling.js</code></div>
<pre class="highlight javascript" data-language="javascript">import { helper } from '@ember/component/helper';

export function disableBubbling([action]) {
  return function(event) {
    event.stopPropagation();
    return action(event);
  };
}
export default helper(disableBubbling);</pre> <p>If you need the default handler to trigger you should either register your own event handler, or use event methods on your view class. See <a href="https://api.emberjs.com/ember/release/classes/Component">"Responding to Browser Events"</a> in the documentation for <code>Component</code> for more information.</p> <h4 id="specifying-dom-event-type">Specifying DOM event type</h4> <p><code>{{action}}</code> helpers called in element space can specify an event type. By default the <code>{{action}}</code> helper registers for DOM <code>click</code> events. You can supply an <code>on</code> option to the helper to specify a different DOM event name:</p> <pre class="highlight handlebars" data-language="html">&lt;div {{action "anActionName" on="doubleClick"}}&gt;
  click me
&lt;/div&gt;</pre> <p>See <a href="https://api.emberjs.com/ember/release/classes/Component">"Event Names"</a> for a list of acceptable DOM event names.</p> <h4 id="specifying-whitelisted-modifier-keys">Specifying whitelisted modifier keys</h4> <p><code>{{action}}</code> helpers called in element space can specify modifier keys. By default the <code>{{action}}</code> helper will ignore click events with pressed modifier keys. You can supply an <code>allowedKeys</code> option to specify which keys should not be ignored.</p> <pre class="highlight handlebars" data-language="html">&lt;div {{action "anActionName" allowedKeys="alt"}}&gt;
  click me
&lt;/div&gt;</pre> <p>This way the action will fire when clicking with the alt key pressed down. Alternatively, supply "any" to the <code>allowedKeys</code> option to accept any combination of modifier keys.</p> <pre class="highlight handlebars" data-language="html">&lt;div {{action "anActionName" allowedKeys="any"}}&gt;
  click me with any key pressed
&lt;/div&gt;</pre> <h4 id="specifying-a-target">Specifying a Target</h4> <p>A <code>target</code> option can be provided to the helper to change which object will receive the method call. This option must be a path to an object, accessible in the current context:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;div {{action "anActionName" target=someService}}&gt;
  click me
&lt;/div&gt;</pre> <div class="pre-title"><code>app/controllers/application.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Controller from '@ember/controller';
import { service } from '@ember/service';

export default class extends Controller {
  @service someService;
}</pre>   <h3 role="link" id="array">  <span class="method-name">array</span> <span class="args"> (options) </span> <span class="return-type">Array</span> <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/array.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/array.ts:5 </a> </p> <p class="field-since"> Available since v3.8.0 </p>  <dl class="parameters">  <dt>options</dt> <dd class="parameter-type">Array</dd>     <dt>returns</dt> <dd class="return-type">Array</dd> <dd>Array</dd>  </dl> <p>Use the <code>{{array}}</code> helper to create an array to pass as an option to your components.</p> <pre class="highlight handlebars" data-language="html">&lt;MyComponent @people={{array
  'Tom Dale'
  'Yehuda Katz'
  this.myOtherPerson}}
/&gt;</pre> <p> or</p> <pre class="highlight handlebars" data-language="html">{{my-component people=(array
  'Tom Dale'
  'Yehuda Katz'
  this.myOtherPerson)
}}</pre> <p>Would result in an object such as:</p> <pre class="highlight javascript" data-language="javascript">['Tom Dale', 'Yehuda Katz', this.get('myOtherPerson')]</pre> <p>Where the 3rd item in the array is bound to updates of the <code>myOtherPerson</code> property.</p>   <h3 role="link" id="component">  <span class="method-name">component</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/component.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/component.ts:5 </a> </p> <p class="field-since"> Available since v1.11.0 </p>   <p>The <code>{{component}}</code> helper lets you add instances of <code>Component</code> to a template. See <a href="https://api.emberjs.com/ember/release/classes/Component">Component</a> for additional information on how a <code>Component</code> functions. <code>{{component}}</code>'s primary use is for cases where you want to dynamically change which type of component is rendered as the state of your application changes. This helper has three modes: inline, block, and nested.</p> <h4 id="inline-form">Inline Form</h4> <p>Given the following template:</p> <div class="pre-title"><code>app/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{component this.infographicComponentName}}</pre> <p>And the following application code:</p> <div class="pre-title"><code>app/controllers/application.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Controller from '@ember/controller';
import { tracked } from '@glimmer/tracking';

export default class ApplicationController extends Controller {
  @tracked isMarketOpen = 'live-updating-chart'

  get infographicComponentName() {
    return this.isMarketOpen ? 'live-updating-chart' : 'market-close-summary';
  }
}</pre> <p>The <code>live-updating-chart</code> component will be appended when <code>isMarketOpen</code> is <code>true</code>, and the <code>market-close-summary</code> component will be appended when <code>isMarketOpen</code> is <code>false</code>. If the value changes while the app is running, the component will be automatically swapped out accordingly. Note: You should not use this helper when you are consistently rendering the same component. In that case, use standard component syntax, for example:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;LiveUpdatingChart /&gt;</pre> <p>or</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{live-updating-chart}}</pre> <h4 id="block-form">Block Form</h4> <p>Using the block form of this helper is similar to using the block form of a component. Given the following application template:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{#component this.infographicComponentName}}
  Last update: {{this.lastUpdateTimestamp}}
{{/component}}</pre> <p>The following controller code:</p> <div class="pre-title"><code>app/controllers/application.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Controller from '@ember/controller';
import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

export default class ApplicationController extends Controller {
  @tracked isMarketOpen = 'live-updating-chart'

  get lastUpdateTimestamp() {
    return new Date();
  }

  get infographicComponentName() {
    return this.isMarketOpen ? 'live-updating-chart' : 'market-close-summary';
  }
}</pre> <p>And the following component template:</p> <div class="pre-title"><code>chart.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{! chart }}
{{yield}}</pre> <p>The <code>Last Update: {{this.lastUpdateTimestamp}}</code> will be rendered in place of the <code>{{yield}}</code>.</p> <h4 id="nested-usage">Nested Usage</h4> <p>The <code>component</code> helper can be used to package a component path with initial attrs. The included attrs can then be merged during the final invocation. For example, given a <code>person-form</code> component with the following template:</p> <div class="pre-title"><code>form.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{yield (hash
  nameInput=(component "my-input-component" value=@model.name placeholder="First Name")
)}}</pre> <p>When yielding the component via the <code>hash</code> helper, the component is invoked directly. See the following snippet:</p> <pre class="highlight " data-language="">&lt;PersonForm as |form|&gt;
  &lt;form.nameInput @placeholder="Username" /&gt;
&lt;/PersonForm&gt;</pre> <p>or</p> <pre class="highlight " data-language="">{{#person-form as |form|}}
  {{form.nameInput placeholder="Username"}}
{{/person-form}}</pre> <p>Which outputs an input whose value is already bound to <code>model.name</code> and <code>placeholder</code> is "Username".</p> <p>When yielding the component without the <code>hash</code> helper use the <code>component</code> helper. For example, below is a <code>full-name</code> component template:</p> <pre class="highlight handlebars" data-language="html">{{yield (component "my-input-component" value=@model.name placeholder="Name")}}</pre> <pre class="highlight " data-language="">&lt;FullName as |field|&gt;
  {{component field placeholder="Full name"}}
&lt;/FullName&gt;</pre> <p>or</p> <pre class="highlight " data-language="">{{#full-name as |field|}}
  {{component field placeholder="Full name"}}
{{/full-name}}</pre>   <h3 role="link" id="concat">  <span class="method-name">concat</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/concat.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/concat.ts:5 </a> </p> <p class="field-since"> Available since v1.13.0 </p>   <p>Concatenates the given arguments into a string.</p> <p>Example:</p> <pre class="highlight handlebars" data-language="html">{{some-component name=(concat firstName " " lastName)}}

{{! would pass name="&lt;first name value&gt; &lt;last name value&gt;" to the component}}</pre> <p>or for angle bracket invocation, you actually don't need concat at all.</p> <pre class="highlight handlebars" data-language="html">&lt;SomeComponent @name="{{firstName}} {{lastName}}" /&gt;</pre>   <h3 role="link" id="debugger">  <span class="method-name">debugger</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/index.ts#L403" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/index.ts:403 </a> </p>   <p>Execute the <code>debugger</code> statement in the current template's context.</p> <pre class="highlight handlebars" data-language="html">{{debugger}}</pre> <p>When using the debugger helper you will have access to a <code>get</code> function. This function retrieves values available in the context of the template. For example, if you're wondering why a value <code>{{foo}}</code> isn't rendering as expected within a template, you could place a <code>{{debugger}}</code> statement and, when the <code>debugger;</code> breakpoint is hit, you can attempt to retrieve this value:</p> <pre class="highlight " data-language="">&gt; get('foo')</pre> <p><code>get</code> is also aware of keywords. So in this situation</p> <pre class="highlight handlebars" data-language="html">{{#each this.items as |item|}}
  {{debugger}}
{{/each}}</pre> <p>You'll be able to get values from the current item:</p> <pre class="highlight " data-language="">&gt; get('item.name')</pre> <p>You can also access the context of the view to make sure it is the object that you expect:</p> <pre class="highlight " data-language="">&gt; context</pre>   <h3 role="link" id="each">  <span class="method-name">each</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/each-in.ts#L13" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/each-in.ts:13 </a> </p>   <p>The <code>{{#each}}</code> helper loops over elements in a collection. It is an extension of the base Handlebars <code>{{#each}}</code> helper.</p> <p>The default behavior of <code>{{#each}}</code> is to yield its inner block once for every item in an array passing the item as the first block parameter.</p> <p>Assuming the <code>@developers</code> argument contains this array:</p> <pre class="highlight javascript" data-language="javascript">[{ name: 'Yehuda' },{ name: 'Tom' }, { name: 'Paul' }];</pre> <pre class="highlight handlebars" data-language="html">&lt;ul&gt;
  {{#each @developers as |person|}}
    &lt;li&gt;Hello, {{person.name}}!&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre> <p>The same rules apply to arrays of primitives.</p> <pre class="highlight javascript" data-language="javascript">['Yehuda', 'Tom', 'Paul']</pre> <pre class="highlight handlebars" data-language="html">&lt;ul&gt;
  {{#each @developerNames as |name|}}
    &lt;li&gt;Hello, {{name}}!&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre> <p>During iteration, the index of each item in the array is provided as a second block parameter.</p> <pre class="highlight handlebars" data-language="html">&lt;ul&gt;
  {{#each @developers as |person index|}}
    &lt;li&gt;Hello, {{person.name}}! You're number {{index}} in line&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre> <h4 id="specifying-keys">Specifying Keys</h4> <p>In order to improve rendering speed, Ember will try to reuse the DOM elements where possible. Specifically, if the same item is present in the array both before and after the change, its DOM output will be reused.</p> <p>The <code>key</code> option is used to tell Ember how to determine if the items in the array being iterated over with <code>{{#each}}</code> has changed between renders. By default the item's object identity is used.</p> <p>This is usually sufficient, so in most cases, the <code>key</code> option is simply not needed. However, in some rare cases, the objects' identities may change even though they represent the same underlying data.</p> <p>For example:</p> <pre class="highlight javascript" data-language="javascript">people.map(person =&gt; {
  return { ...person, type: 'developer' };
});</pre> <p>In this case, each time the <code>people</code> array is <code>map</code>-ed over, it will produce an new array with completely different objects between renders. In these cases, you can help Ember determine how these objects related to each other with the <code>key</code> option:</p> <pre class="highlight handlebars" data-language="html">&lt;ul&gt;
  {{#each @developers key="name" as |person|}}
    &lt;li&gt;Hello, {{person.name}}!&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre> <p>By doing so, Ember will use the value of the property specified (<code>person.name</code> in the example) to find a "match" from the previous render. That is, if Ember has previously seen an object from the <code>@developers</code> array with a matching name, its DOM elements will be re-used.</p> <p>There are two special values for <code>key</code>:</p> <ul> <li>
<code>@index</code> - The index of the item in the array.</li> <li>
<code>@identity</code> - The item in the array itself.</li> </ul> <h4 id="else-condition">{{else}} condition</h4> <p><code>{{#each}}</code> can have a matching <code>{{else}}</code>. The contents of this block will render if the collection is empty.</p> <pre class="highlight handlebars" data-language="html">&lt;ul&gt;
  {{#each @developers as |person|}}
    &lt;li&gt;{{person.name}} is available!&lt;/li&gt;
  {{else}}
    &lt;li&gt;Sorry, nobody is available for this task.&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre>   <h3 role="link" id="each-in">  <span class="method-name">each-in</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/each-in.ts#L124" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/each-in.ts:124 </a> </p> <p class="field-since"> Available since v2.1.0 </p>   <p>The <code>{{each-in}}</code> helper loops over properties on an object.</p> <p>For example, given this component definition:</p> <div class="pre-title"><code>details.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

export default class extends Component {
  @tracked developer = {
    "name": "Shelly Sails",
    "age": 42
  };
}</pre> <p>This template would display all properties on the <code>developer</code> object in a list:</p> <div class="pre-title"><code>details.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;ul&gt;
  {{#each-in this.developer as |key value|}}
    &lt;li&gt;{{key}}: {{value}}&lt;/li&gt;
  {{/each-in}}
&lt;/ul&gt;</pre> <p>Outputting their name and age:</p> <pre class="highlight html" data-language="html">&lt;ul&gt;
  &lt;li&gt;name: Shelly Sails&lt;/li&gt;
  &lt;li&gt;age: 42&lt;/li&gt;
&lt;/ul&gt;</pre>   <h3 role="link" id="fn">  <span class="method-name">fn</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/fn.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/fn.ts:5 </a> </p> <p class="field-since"> Available since v3.11.0 </p>   <p>The <code>fn</code> helper allows you to ensure a function that you are passing off to another component, helper, or modifier has access to arguments that are available in the template.</p> <p>For example, if you have an <code>each</code> helper looping over a number of items, you may need to pass a function that expects to receive the item as an argument to a component invoked within the loop. Here's how you could use the <code>fn</code> helper to pass both the function and its arguments together:</p> <div class="pre-title"><code>listing.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{#each @items as |item|}}
  &lt;DisplayItem @item=item @select={{fn this.handleSelected item}} /&gt;
{{/each}}</pre> <div class="pre-title"><code>list.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@glimmer/component';
import { action } from '@ember/object';

export default class ItemsList extends Component {
  @action
  handleSelected(item) {
    // ...snip...
  }
}</pre> <p>In this case the <code>display-item</code> component will receive a normal function that it can invoke. When it invokes the function, the <code>handleSelected</code> function will receive the <code>item</code> and any arguments passed, thanks to the <code>fn</code> helper.</p> <p>Let's take look at what that means in a couple circumstances:</p> <ul> <li>When invoked as <code>this.args.select()</code> the <code>handleSelected</code> function will receive the <code>item</code> from the loop as its first and only argument.</li> <li>When invoked as <code>this.args.select('foo')</code> the <code>handleSelected</code> function will receive the <code>item</code> from the loop as its first argument and the string <code>'foo'</code> as its second argument.</li> </ul> <p>In the example above, we used <code>@action</code> to ensure that <code>handleSelected</code> is properly bound to the <code>items-list</code>, but let's explore what happens if we left out <code>@action</code>:</p> <div class="pre-title"><code>list.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@glimmer/component';

export default class ItemsList extends Component {
  handleSelected(item) {
    // ...snip...
  }
}</pre> <p>In this example, when <code>handleSelected</code> is invoked inside the <code>display-item</code> component, it will <strong>not</strong> have access to the component instance. In other words, it will have no <code>this</code> context, so please make sure your functions are bound (via <code>@action</code> or other means) before passing into <code>fn</code>!</p> <p>See also <a href="https://en.wikipedia.org/wiki/Partial_application">partial application</a>.</p>   <h3 role="link" id="get">  <span class="method-name">get</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/get.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/get.ts:5 </a> </p> <p class="field-since"> Available since v2.1.0 </p>   <p>Dynamically look up a property on an object or an element in an array. The second argument to <code>{{get}}</code> should have a string or number value, although it can be bound.</p> <p>For example, these two usages are equivalent:</p> <div class="pre-title"><code>detail.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

export default class extends Component {
  @tracked developer = {
    name: "Sandi Metz",
    language: "Ruby"
  }
}</pre> <pre class="highlight handlebars" data-language="html">{{this.developer.name}}
{{get this.developer "name"}}</pre> <p>If there were several facts about a person, the <code>{{get}}</code> helper can dynamically pick one:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;DeveloperDetail @factName="language" /&gt;</pre> <pre class="highlight handlebars" data-language="html">{{get this.developer @factName}}</pre> <p>For a more complex example, this template would allow the user to switch between showing the user's name and preferred coding language with a click:</p> <div class="pre-title"><code>detail.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

export default class extends Component {
  @tracked developer = {
    name: "Sandi Metz",
    language: "Ruby"
  }

  @tracked currentFact = 'name'

  @action
  showFact(fact) {
    this.currentFact = fact;
  }
}</pre> <div class="pre-title"><code>detail.js</code></div>
<pre class="highlight javascript" data-language="javascript">{{get this.developer this.currentFact}}

&lt;button {{on 'click' (fn this.showFact "name")}}&gt;Show name&lt;/button&gt;
&lt;button {{on 'click' (fn this.showFact "language")}}&gt;Show language&lt;/button&gt;</pre> <p>The <code>{{get}}</code> helper can also respect mutable values itself. For example:</p> <div class="pre-title"><code>detail.js</code></div>
<pre class="highlight javascript" data-language="javascript">&lt;Input @value={{mut (get this.person this.currentFact)}} /&gt;

&lt;button {{on 'click' (fn this.showFact "name")}}&gt;Show name&lt;/button&gt;
&lt;button {{on 'click' (fn this.showFact "language")}}&gt;Show language&lt;/button&gt;</pre> <p>Would allow the user to swap what fact is being displayed, and also edit that fact via a two-way mutable binding.</p> <p>The <code>{{get}}</code> helper can also be used for array element access via index. This would display the value of the first element in the array <code>this.names</code>:</p> <pre class="highlight handlebars" data-language="html">{{get this.names 0}}</pre> <p>Array element access also works with a dynamic second argument:</p> <pre class="highlight handlebars" data-language="html">{{get this.names @index}}</pre>   <h3 role="link" id="has-block">  <span class="method-name">has-block</span> <span class="args"> (the) </span> <span class="return-type">Boolean</span> <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/index.ts#L303" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/index.ts:303 </a> </p>  <dl class="parameters">  <dt>the</dt> <dd class="parameter-type">String</dd> <dd>name of the block. The name (at the moment) is either "main" or "inverse" (though only curly components support inverse)</dd>    <dt>returns</dt> <dd class="return-type">Boolean</dd> <dd>`true` if the component was invoked with a block</dd>  </dl> <p><code>{{(has-block)}}</code> indicates if the component was invoked with a block.</p> <p>This component is invoked with a block:</p> <pre class="highlight handlebars" data-language="html">{{#my-component}}
  Hi Jen!
{{/my-component}}</pre> <p>This component is invoked without a block:</p> <pre class="highlight handlebars" data-language="html">{{my-component}}</pre> <p>Using angle bracket invocation, this looks like:</p> <pre class="highlight html" data-language="html">&lt;MyComponent&gt;Hi Jen!&lt;/MyComponent&gt; {{! with a block}}</pre> <pre class="highlight html" data-language="html">&lt;MyComponent/&gt; {{! without a block}}</pre> <p>This is useful when you want to create a component that can optionally take a block and then render a default template when it is not invoked with a block.</p> <div class="pre-title"><code>component.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{#if (has-block)}}
  Welcome {{yield}}, we are happy you're here!
{{else}}
  Hey you! You're great!
{{/if}}</pre>   <h3 role="link" id="has-block-params">  <span class="method-name">has-block-params</span> <span class="args"> (the) </span> <span class="return-type">Boolean</span> <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/index.ts#L348" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/index.ts:348 </a> </p>  <dl class="parameters">  <dt>the</dt> <dd class="parameter-type">String</dd> <dd>name of the block. The name (at the moment) is either "main" or "inverse" (though only curly components support inverse)</dd>    <dt>returns</dt> <dd class="return-type">Boolean</dd> <dd>`true` if the component was invoked with block params</dd>  </dl> <p><code>{{(has-block-params)}}</code> indicates if the component was invoked with block params.</p> <p>This component is invoked with block params:</p> <pre class="highlight handlebars" data-language="html">{{#my-component as |favoriteFlavor|}}
  Hi Jen!
{{/my-component}}</pre> <p>This component is invoked without block params:</p> <pre class="highlight handlebars" data-language="html">{{#my-component}}
  Hi Jenn!
{{/my-component}}</pre> <p>With angle bracket syntax, block params look like this:</p> <pre class="highlight handlebars" data-language="html">&lt;MyComponent as |favoriteFlavor|&gt;
  Hi Jen!
&lt;/MyComponent&gt;</pre> <p>And without block params:</p> <pre class="highlight handlebars" data-language="html">&lt;MyComponent&gt;
  Hi Jen!
&lt;/MyComponent&gt;</pre> <p>This is useful when you want to create a component that can render itself differently when it is not invoked with block params.</p> <div class="pre-title"><code>component.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{#if (has-block-params)}}
  Welcome {{yield this.favoriteFlavor}}, we're happy you're here and hope you
  enjoy your favorite ice cream flavor.
{{else}}
  Welcome {{yield}}, we're happy you're here, but we're unsure what
  flavor ice cream you would enjoy.
{{/if}}</pre>   <h3 role="link" id="hash">  <span class="method-name">hash</span> <span class="args"> (options) </span> <span class="return-type">Object</span> <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/hash.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/hash.ts:5 </a> </p> <p class="field-since"> Available since v2.3.0 </p>  <dl class="parameters">  <dt>options</dt> <dd class="parameter-type">Object</dd>     <dt>returns</dt> <dd class="return-type">Object</dd> <dd>Hash</dd>  </dl> <p>Use the <code>{{hash}}</code> helper to create a hash to pass as an option to your components. This is specially useful for contextual components where you can just yield a hash:</p> <pre class="highlight handlebars" data-language="html">{{yield (hash
   name='Sarah'
   title=office
)}}</pre> <p>Would result in an object such as:</p> <pre class="highlight javascript" data-language="javascript">{ name: 'Sarah', title: this.get('office') }</pre> <p>Where the <code>title</code> is bound to updates of the <code>office</code> property.</p> <p>Note that the hash is an empty object with no prototype chain, therefore common methods like <code>toString</code> are not available in the resulting hash. If you need to use such a method, you can use the <code>call</code> or <code>apply</code> approach:</p> <pre class="highlight javascript" data-language="javascript">function toString(obj) {
  return Object.prototype.toString.apply(obj);
}</pre>   <h3 role="link" id="helper">  <span class="method-name">helper</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/helper.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/helper.ts:5 </a> </p> <p class="field-since"> Available since v3.27.0 </p>   <p>Use the <code>{{helper}}</code> helper to create contextual helper so that it can be passed around as first-class values in templates.</p> <pre class="highlight handlebars" data-language="html">{{#let (helper "join-words" "foo" "bar" separator=" ") as |foo-bar|}}

  {{!-- this is equivalent to invoking `{{join-words "foo" "bar" separator=" "}}` --}}
  {{foo-bar}}

  {{!-- this will pass the helper itself into the component, instead of invoking it now --}}
  &lt;MyComponent @helper={{helper foo-bar "baz"}} /&gt;

  {{!-- this will yield the helper itself ("contextual helper"), instead of invoking it now --}}
  {{yield foo-bar}}
{{/let}}</pre> <h4 id="arguments">Arguments</h4> <p>The <code>{{helper}}</code> helper works similarly to the <a href="component.html#component"><code>{{component}}</code></a> and <a href="modifier.html#modifier"><code>{{modifier}}</code></a> helper:</p> <ul> <li>
<p>When passed a string (e.g. <code>(helper "foo")</code>) as the first argument, it will produce an opaque, internal "helper definition" object that can be passed around and invoked elsewhere.</p> </li> <li>
<p>Any additional positional and/or named arguments (a.k.a. params and hash) will be stored ("curried") inside the definition object, such that, when invoked, these arguments will be passed along to the referenced helper.</p> </li> </ul>   <h3 role="link" id="if">  <span class="method-name">if</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/if-unless.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/if-unless.ts:5 </a> </p>   <p>The <code>if</code> helper allows you to conditionally render one of two branches, depending on the "truthiness" of a property. For example the following values are all falsey: <code>false</code>, <code>undefined</code>, <code>null</code>, <code>""</code>, <code>0</code>, <code>NaN</code> or an empty array.</p> <p>This helper has two forms, block and inline.</p> <h2 id="block-form">Block form</h2> <p>You can use the block form of <code>if</code> to conditionally render a section of the template.</p> <p>To use it, pass the conditional value to the <code>if</code> helper, using the block form to wrap the section of template you want to conditionally render. Like so:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;Weather /&gt;</pre> <div class="pre-title"><code>app/components/weather.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{! will not render because greeting is undefined}}
{{#if @isRaining}}
  Yes, grab an umbrella!
{{/if}}</pre> <p>You can also define what to show if the property is falsey by using the <code>else</code> helper.</p> <div class="pre-title"><code>app/components/weather.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{#if @isRaining}}
  Yes, grab an umbrella!
{{else}}
  No, it's lovely outside!
{{/if}}</pre> <p>You are also able to combine <code>else</code> and <code>if</code> helpers to create more complex conditional logic.</p> <p>For the following template:</p> <div class="pre-title"><code>app/components/weather.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{#if @isRaining}}
  Yes, grab an umbrella!
{{else if @isCold}}
  Grab a coat, it's chilly!
{{else}}
  No, it's lovely outside!
{{/if}}</pre> <p>If you call it by saying <code>isCold</code> is true:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;Weather @isCold={{true}} /&gt;</pre> <p>Then <code>Grab a coat, it's chilly!</code> will be rendered.</p> <h2 id="inline-form">Inline form</h2> <p>The inline <code>if</code> helper conditionally renders a single property or string.</p> <p>In this form, the <code>if</code> helper receives three arguments, the conditional value, the value to render when truthy, and the value to render when falsey.</p> <p>For example, if <code>useLongGreeting</code> is truthy, the following:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;Greeting @useLongGreeting={{true}} /&gt;</pre> <div class="pre-title"><code>app/components/greeting.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{if @useLongGreeting "Hello" "Hi"}} Alex</pre> <p>Will render:</p> <pre class="highlight html" data-language="html">Hello Alex</pre> <p>One detail to keep in mind is that both branches of the <code>if</code> helper will be evaluated, so if you have <code>{{if condition "foo" (expensive-operation "bar")</code>, <code>expensive-operation</code> will always calculate.</p>   <h3 role="link" id="in-element">  <span class="method-name">in-element</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/syntax/in-element.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/syntax/in-element.ts:5 </a> </p>   <p>The <code>in-element</code> helper renders its block content outside of the regular flow, into a DOM element given by its <code>destinationElement</code> positional argument.</p> <p>Common use cases - often referred to as "portals" or "wormholes" - are rendering dropdowns, modals or tooltips close to the root of the page to bypass CSS overflow rules, or to render content to parts of the page that are outside of the control of the Ember app itself (e.g. embedded into a static or server rendered HTML page).</p> <pre class="highlight handlebars" data-language="html">{{#in-element this.destinationElement}}
  &lt;div&gt;Some content&lt;/div&gt;
{{/in-element}}</pre> <h4 id="arguments">Arguments</h4> <p><code>{{in-element}}</code> requires a single positional argument:</p> <ul> <li>
<code>destinationElement</code> -- the DOM element to render into. It must exist at the time of rendering.</li> </ul> <p>It also supports an optional named argument:</p> <ul> <li>
<code>insertBefore</code> -- by default the DOM element's content is replaced when used as <code>destinationElement</code>. Passing <code>null</code> changes the behaviour to appended at the end of any existing content. Any other value than <code>null</code> is currently not supported.</li> </ul>   <h3 role="link" id="input">  <span class="method-name">input</span> <span class="args"> (options) </span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/components/input.ts#L45" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/components/input.ts:45 </a> </p>  <dl class="parameters">  <dt>options</dt> <dd class="parameter-type">Hash</dd>     </dl> <p>See <a href="https://api.emberjs.com/ember/release/classes/Ember.Templates.components/methods#Input">Ember.Templates.components.Input</a>.</p>   <h3 role="link" id="let">  <span class="method-name">let</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/syntax/let.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/syntax/let.ts:5 </a> </p>   <p>The <code>let</code> helper receives one or more positional arguments and yields them out as block params.</p> <p>This allows the developer to introduce shorter names for certain computations in the template.</p> <p>This is especially useful if you are passing properties to a component that receives a lot of options and you want to clean up the invocation.</p> <p>For the following example, the template receives a <code>post</code> object with <code>content</code> and <code>title</code> properties.</p> <p>We are going to call the <code>my-post</code> component, passing a title which is the title of the post suffixed with the name of the blog, the content of the post, and a series of options defined in-place.</p> <pre class="highlight handlebars" data-language="html">{{#let
    (concat post.title ' | The Ember.js Blog')
    post.content
    (hash
      theme="high-contrast"
      enableComments=true
    )
    as |title content options|
}}
  &lt;MyPost @title={{title}} @content={{content}} @options={{options}} /&gt;
{{/let}}</pre> <p> or</p> <pre class="highlight handlebars" data-language="html">{{#let
    (concat post.title ' | The Ember.js Blog')
    post.content
    (hash
      theme="high-contrast"
      enableComments=true
    )
    as |title content options|
}}
  {{my-post title=title content=content options=options}}
{{/let}}</pre>   <h3 role="link" id="link-to">  <span class="method-name">link-to</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/components/link-to.ts#L254" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/components/link-to.ts:254 </a> </p>   <p>See <a href="https://api.emberjs.com/ember/release/classes/Ember.Templates.components/methods#LinkTo">Ember.Templates.components.LinkTo</a>.</p>   <h3 role="link" id="log">  <span class="method-name">log</span> <span class="args"> (params) </span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/log.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/log.ts:5 </a> </p>  <dl class="parameters">  <dt>params</dt> <dd class="parameter-type">Array</dd>     </dl> <p><code>log</code> allows you to output the value of variables in the current rendering context. <code>log</code> also accepts primitive types such as strings or numbers.</p> <pre class="highlight handlebars" data-language="html">{{log "myVariable:" myVariable }}</pre>   <h3 role="link" id="modifier">  <span class="method-name">modifier</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/modifier.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/modifier.ts:5 </a> </p> <p class="field-since"> Available since v3.27.0 </p>   <p>Use the <code>{{modifier}}</code> helper to create contextual modifier so that it can be passed around as first-class values in templates.</p> <pre class="highlight handlebars" data-language="html">{{#let (modifier "click-outside" click=this.submit) as |on-click-outside|}}

  {{!-- this is equivalent to `&lt;MyComponent {{click-outside click=this.submit}} /&gt;` --}}
  &lt;MyComponent {{on-click-outside}} /&gt;

  {{!-- this will pass the modifier itself into the component, instead of invoking it now --}}
  &lt;MyComponent @modifier={{modifier on-click-outside "extra" "args"}} /&gt;

  {{!-- this will yield the modifier itself ("contextual modifier"), instead of invoking it now --}}
  {{yield on-click-outside}}
{{/let}}</pre> <h4 id="arguments">Arguments</h4> <p>The <code>{{modifier}}</code> helper works similarly to the <a href="component.html#component"><code>{{component}}</code></a> and <a href="helper.html#helper"><code>{{helper}}</code></a> helper:</p> <ul> <li>
<p>When passed a string (e.g. <code>(modifier "foo")</code>) as the first argument, it will produce an opaque, internal "modifier definition" object that can be passed around and invoked elsewhere.</p> </li> <li>
<p>Any additional positional and/or named arguments (a.k.a. params and hash) will be stored ("curried") inside the definition object, such that, when invoked, these arguments will be passed along to the referenced modifier.</p> </li> </ul>   <h3 role="link" id="mount">  <span class="method-name">mount</span> <span class="args"> (name, model) </span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/syntax/mount.ts#L16" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/syntax/mount.ts:16 </a> </p>  <dl class="parameters">  <dt>name</dt> <dd class="parameter-type">String</dd> <dd>Name of the engine to mount.</dd>    <dt>model</dt> <dd class="parameter-type">Object</dd> <dd>Object that will be set as the model of the engine.</dd>    </dl> <p>The <code>{{mount}}</code> helper lets you embed a routeless engine in a template. Mounting an engine will cause an instance to be booted and its <code>application</code> template to be rendered.</p> <p>For example, the following template mounts the <code>ember-chat</code> engine:</p> <pre class="highlight handlebars" data-language="html">{{! application.hbs }}
{{mount "ember-chat"}}</pre> <p>Additionally, you can also pass in a <code>model</code> argument that will be set as the engines model. This can be an existing object:</p> <pre class="highlight " data-language="">&lt;div&gt;
  {{mount 'admin' model=userSettings}}
&lt;/div&gt;</pre> <p>Or an inline <code>hash</code>, and you can even pass components:</p> <pre class="highlight " data-language="">&lt;div&gt;
  &lt;h1&gt;Application template!&lt;/h1&gt;
  {{mount 'admin' model=(hash
      title='Secret Admin'
      signInButton=(component 'sign-in-button')
  )}}
&lt;/div&gt;</pre>   <h3 role="link" id="mut">  <span class="method-name">mut</span> <span class="args"> (attr) </span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/mut.ts#L9" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/mut.ts:9 </a> </p>  <dl class="parameters">  <dt>attr</dt> <dd class="parameter-type">Object</dd> <dd>the "two-way" attribute that can be modified.</dd>    </dl> <p>The <code>mut</code> helper lets you <strong>clearly specify</strong> that a child <code>Component</code> can update the (mutable) value passed to it, which will <strong>change the value of the parent component</strong>.</p> <p>To specify that a parameter is mutable, when invoking the child <code>Component</code>:</p> <pre class="highlight handlebars" data-language="html">&lt;MyChild @childClickCount={{fn (mut totalClicks)}} /&gt;</pre> <p> or</p> <pre class="highlight handlebars" data-language="html">{{my-child childClickCount=(mut totalClicks)}}</pre> <p>The child <code>Component</code> can then modify the parent's value just by modifying its own property:</p> <pre class="highlight javascript" data-language="javascript">// my-child.js
export default Component.extend({
  click() {
    this.incrementProperty('childClickCount');
  }
});</pre> <p>Note that for curly components (<code>{{my-component}}</code>) the bindings are already mutable, making the <code>mut</code> unnecessary.</p> <p>Additionally, the <code>mut</code> helper can be combined with the <code>fn</code> helper to mutate a value. For example:</p> <pre class="highlight handlebars" data-language="html">&lt;MyChild @childClickCount={{this.totalClicks}} @click-count-change={{fn (mut totalClicks))}} /&gt;</pre> <p>or</p> <pre class="highlight handlebars" data-language="html">{{my-child childClickCount=totalClicks click-count-change=(fn (mut totalClicks))}}</pre> <p>The child <code>Component</code> would invoke the function with the new click value:</p> <pre class="highlight javascript" data-language="javascript">// my-child.js
export default Component.extend({
  click() {
    this.get('click-count-change')(this.get('childClickCount') + 1);
  }
});</pre> <p>The <code>mut</code> helper changes the <code>totalClicks</code> value to what was provided as the <code>fn</code> argument.</p> <p>The <code>mut</code> helper, when used with <code>fn</code>, will return a function that sets the value passed to <code>mut</code> to its first argument. As an example, we can create a button that increments a value passing the value directly to the <code>fn</code>:</p> <pre class="highlight handlebars" data-language="html">{{! inc helper is not provided by Ember }}
&lt;button onclick={{fn (mut count) (inc count)}}&gt;
  Increment count
&lt;/button&gt;</pre>   <h3 role="link" id="on">  <span class="method-name">on</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/modifiers/on.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/modifiers/on.ts:5 </a> </p> <p class="field-since"> Available since v3.11.0 </p>   <p>The <code>{{on}}</code> modifier lets you easily add event listeners (it uses <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener</a> internally).</p> <p>For example, if you'd like to run a function on your component when a <code>&lt;button&gt;</code> in the components template is clicked you might do something like:</p> <div class="pre-title"><code>post.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;button {{on 'click' this.saveLike}}&gt;Like this post!&lt;/button&gt;</pre> <div class="pre-title"><code>post.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@glimmer/component';
import { action } from '@ember/object';

export default class LikePostComponent extends Component {
  @action
  saveLike() {
    // someone likes your post!
    // better send a request off to your server...
  }
}</pre> <h4 id="arguments">Arguments</h4> <p><code>{{on}}</code> accepts two positional arguments, and a few named arguments.</p> <p>The positional arguments are:</p> <ul> <li>
<code>event</code> -- the name to use when calling <code>addEventListener</code>
</li> <li>
<code>callback</code> -- the function to be passed to <code>addEventListener</code>
</li> </ul> <p>The named arguments are:</p> <ul> <li>capture -- a <code>true</code> value indicates that events of this type will be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the DOM tree.</li> <li>once -- indicates that the listener should be invoked at most once after being added. If true, the listener would be automatically removed when invoked.</li> <li>passive -- if <code>true</code>, indicates that the function specified by listener will never call preventDefault(). If a passive listener does call preventDefault(), the user agent will do nothing other than generate a console warning. See <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners">Improving scrolling performance with passive listeners</a> to learn more.</li> </ul> <p>The callback function passed to <code>{{on}}</code> will receive any arguments that are passed to the event handler. Most commonly this would be the <code>event</code> itself.</p> <p>If you would like to pass additional arguments to the function you should use the <code>{{fn}}</code> helper.</p> <p>For example, in our example case above if you'd like to pass in the post that was being liked when the button is clicked you could do something like:</p> <div class="pre-title"><code>post.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;button {{on 'click' (fn this.saveLike @post)}}&gt;Like this post!&lt;/button&gt;</pre> <p>In this case, the <code>saveLike</code> function will receive two arguments: the click event and the value of <code>@post</code>.</p> <h4 id="function-context">Function Context</h4> <p>In the example above, we used <code>@action</code> to ensure that <code>likePost</code> is properly bound to the <code>items-list</code>, but let's explore what happens if we left out <code>@action</code>:</p> <div class="pre-title"><code>post.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Component from '@glimmer/component';

export default class LikePostComponent extends Component {
  saveLike() {
    // ...snip...
  }
}</pre> <p>In this example, when the button is clicked <code>saveLike</code> will be invoked, it will <strong>not</strong> have access to the component instance. In other words, it will have no <code>this</code> context, so please make sure your functions are bound (via <code>@action</code> or other means) before passing into <code>on</code>!</p>   <h3 role="link" id="outlet">  <span class="method-name">outlet</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/syntax/outlet.ts#L22" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/syntax/outlet.ts:22 </a> </p>   <p>The <code>{{outlet}}</code> helper lets you specify where a child route will render in your template. An important use of the <code>{{outlet}}</code> helper is in your application's <code>application.hbs</code> file:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;MyHeader /&gt;

&lt;div class="my-dynamic-content"&gt;
  &lt;!-- this content will change based on the current route, which depends on the current URL --&gt;
  {{outlet}}
&lt;/div&gt;

&lt;MyFooter /&gt;</pre> <p>See the <a href="https://guides.emberjs.com/release/routing/rendering-a-template/">routing guide</a> for more information on how your <code>route</code> interacts with the <code>{{outlet}}</code> helper. Note: Your content <strong>will not render</strong> if there isn't an <code>{{outlet}}</code> for it.</p>   <h3 role="link" id="page-title">  <span class="method-name">page-title</span> <span class="args"> (param) </span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/page-title.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/page-title.ts:5 </a> </p>  <dl class="parameters">  <dt>param</dt> <dd class="parameter-type">String</dd>     </dl> <p><code>page-title</code> allows you to set the title of any page in your application and append additional titles for each route. For complete documentation, see <a href="https://github.com/ember-cli/ember-page-title">https://github.com/ember-cli/ember-page-title</a>.</p> <pre class="highlight handlebars" data-language="html">{{page-title "My Page Title" }}</pre>   <h3 role="link" id="textarea">  <span class="method-name">textarea</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/components/textarea.ts#L122" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/components/textarea.ts:122 </a> </p>   <p>See Ember.Templates.components.Textarea.</p>   <h3 role="link" id="unbound">  <span class="method-name">unbound</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/unbound.ts#L10" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/unbound.ts:10 </a> </p>   <p>The <code>{{unbound}}</code> helper disconnects the one-way binding of a property, essentially freezing its value at the moment of rendering. For example, in this example the display of the variable <code>name</code> will not change even if it is set with a new value:</p> <pre class="highlight handlebars" data-language="html">{{unbound this.name}}</pre> <p>Like any helper, the <code>unbound</code> helper can accept a nested helper expression. This allows for custom helpers to be rendered unbound:</p> <pre class="highlight handlebars" data-language="html">{{unbound (some-custom-helper)}}
{{unbound (capitalize this.name)}}
{{! You can use any helper, including unbound, in a nested expression }}
{{capitalize (unbound this.name)}}</pre> <p>The <code>unbound</code> helper only accepts a single argument, and it return an unbound value.</p>   <h3 role="link" id="unique-id">  <span class="method-name">unique-id</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/unique-id.ts#L5" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/unique-id.ts:5 </a> </p> <p class="field-since"> Available since v4.4.0 </p>   <p>Use the {{unique-id}} helper to generate a unique ID string suitable for use as an ID attribute in the DOM.</p> <pre class="highlight handlebars" data-language="html">&lt;input id={{unique-id}} type="email" /&gt;</pre> <p>Each invocation of {{unique-id}} will return a new, unique ID string. You can use the <code>let</code> helper to create an ID that can be reused within a template.</p> <pre class="highlight handlebars" data-language="html">{{#let (unique-id) as |emailId|}}
  &lt;label for={{emailId}}&gt;Email address&lt;/label&gt;
  &lt;input id={{emailId}} type="email" /&gt;
{{/let}}</pre>   <h3 role="link" id="unless">  <span class="method-name">unless</span>  <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/lib/helpers/if-unless.ts#L97" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/lib/helpers/if-unless.ts:97 </a> </p>   <p>The <code>unless</code> helper is the inverse of the <code>if</code> helper. It displays if a value is falsey ("not true" or "is false"). Example values that will display with <code>unless</code>: <code>false</code>, <code>undefined</code>, <code>null</code>, <code>""</code>, <code>0</code>, <code>NaN</code> or an empty array.</p> <h2 id="inline-form">Inline form</h2> <p>The inline <code>unless</code> helper conditionally renders a single property or string. This helper acts like a ternary operator. If the first property is falsy, the second argument will be displayed, otherwise, the third argument will be displayed</p> <p>For example, if you pass a falsey <code>useLongGreeting</code> to the <code>Greeting</code> component:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;Greeting @useLongGreeting={{false}} /&gt;</pre> <div class="pre-title"><code>app/components/greeting.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{unless @useLongGreeting "Hi" "Hello"}} Ben</pre> <p>Then it will display:</p> <pre class="highlight html" data-language="html">Hi Ben</pre> <h2 id="block-form">Block form</h2> <p>Like the <code>if</code> helper, the <code>unless</code> helper also has a block form.</p> <p>The following will not render anything:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;Greeting /&gt;</pre> <div class="pre-title"><code>app/components/greeting.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{#unless @greeting}}
  No greeting was found. Why not set one?
{{/unless}}</pre> <p>You can also use an <code>else</code> helper with the <code>unless</code> block. The <code>else</code> will display if the value is truthy.</p> <p>If you have the following component:</p> <div class="pre-title"><code>in.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{#unless @userData}}
  Please login.
{{else}}
  Welcome back!
{{/unless}}</pre> <p>Calling it with a truthy <code>userData</code>:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;LoggedIn @userData={{hash username="Zoey"}} /&gt;</pre> <p>Will render:</p> <pre class="highlight html" data-language="html">Welcome back!</pre> <p>and calling it with a falsey <code>userData</code>:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;LoggedIn @userData={{false}} /&gt;</pre> <p>Will render:</p> <pre class="highlight html" data-language="html">Please login.</pre>   <h3 role="link" id="yield">  <span class="method-name">yield</span> <span class="args"> (options) </span> <span class="return-type">String</span> <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/ember.html">ember</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/-internals/glimmer/index.ts#L91" target="_blank" rel="noopener noreferrer"> packages/@ember/-internals/glimmer/index.ts:91 </a> </p>  <dl class="parameters">  <dt>options</dt> <dd class="parameter-type">Hash</dd>     <dt>returns</dt> <dd class="return-type">String</dd> <dd>HTML string</dd>  </dl> <p><code>{{yield}}</code> denotes an area of a template that will be rendered inside of another template.</p> <h4 id="use-with-component">Use with <code>Component</code>
</h4> <p>When designing components <code>{{yield}}</code> is used to denote where, inside the component's template, an optional block passed to the component should render:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;LabeledTextfield @value={{@model.name}}&gt;
  First name:
&lt;/LabeledTextfield&gt;</pre> <div class="pre-title"><code>textfield.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;label&gt;
  {{yield}} &lt;Input @value={{@value}} /&gt;
&lt;/label&gt;</pre> <p>Result:</p> <pre class="highlight html" data-language="html">&lt;label&gt;
  First name: &lt;input type="text" /&gt;
&lt;/label&gt;</pre> <p>Additionally you can <code>yield</code> properties into the context for use by the consumer:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;LabeledTextfield @value={{@model.validation}} @validator={{this.firstNameValidator}} as |validationError|&gt;
  {{#if validationError}}
    &lt;p class="error"&gt;{{validationError}}&lt;/p&gt;
  {{/if}}
  First name:
&lt;/LabeledTextfield&gt;</pre> <div class="pre-title"><code>textfield.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;label&gt;
  {{yield this.validationError}} &lt;Input @value={{@value}} /&gt;
&lt;/label&gt;</pre> <p>Result:</p> <pre class="highlight html" data-language="html">&lt;label&gt;
  &lt;p class="error"&gt;First Name must be at least 3 characters long.&lt;/p&gt;
  First name: &lt;input type="text" /&gt;
&lt;/label&gt;</pre> <p><code>yield</code> can also be used with the <code>hash</code> helper:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;DateRanges @value={{@model.date}} as |range|&gt;
  Start date: {{range.start}}
  End date: {{range.end}}
&lt;/DateRanges&gt;</pre> <div class="pre-title"><code>ranges.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;div&gt;
  {{yield (hash start=@value.start end=@value.end)}}
&lt;/div&gt;</pre> <p>Result:</p> <pre class="highlight html" data-language="html">&lt;div&gt;
  Start date: July 1st
  End date: July 30th
&lt;/div&gt;</pre> <p>Multiple values can be yielded as block params:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;Banner @value={{@model}} as |title subtitle body|&gt;
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;h2&gt;{{subtitle}}&lt;/h2&gt;
  {{body}}
&lt;/Banner&gt;</pre> <div class="pre-title"><code>app/components/banner.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;div&gt;
  {{yield "Hello title" "hello subtitle" "body text"}}
&lt;/div&gt;</pre> <p>Result:</p> <pre class="highlight html" data-language="html">&lt;div&gt;
  &lt;h1&gt;Hello title&lt;/h1&gt;
  &lt;h2&gt;hello subtitle&lt;/h2&gt;
  body text
&lt;/div&gt;</pre> <p>However, it is preferred to use the hash helper, as this can prevent breaking changes to your component and also simplify the api for the component.</p> <p>Multiple components can be yielded with the <code>hash</code> and <code>component</code> helper:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;Banner @value={{@model}} as |banner|&gt;
  &lt;banner.Title&gt;Banner title&lt;/banner.Title&gt;
  &lt;banner.Subtitle&gt;Banner subtitle&lt;/banner.Subtitle&gt;
  &lt;banner.Body&gt;A load of body text&lt;/banner.Body&gt;
&lt;/Banner&gt;</pre> <div class="pre-title"><code>app/components/banner.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Title from './banner/title';
import Subtitle from './banner/subtitle';
import Body from './banner/body';

export default class Banner extends Component {
  Title = Title;
  Subtitle = Subtitle;
  Body = Body;
}</pre> <div class="pre-title"><code>app/components/banner.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;div&gt;
  {{yield (hash
    Title=this.Title
    Subtitle=this.Subtitle
    Body=(component this.Body defaultArg="some value")
  )}}
&lt;/div&gt;</pre> <p>Result:</p> <pre class="highlight html" data-language="html">&lt;div&gt;
  &lt;h1&gt;Banner title&lt;/h1&gt;
  &lt;h2&gt;Banner subtitle&lt;/h2&gt;
  A load of body text
&lt;/div&gt;</pre> <p>A benefit of using this pattern is that the user of the component can change the order the components are displayed.</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;Banner @value={{@model}} as |banner|&gt;
  &lt;banner.Subtitle&gt;Banner subtitle&lt;/banner.Subtitle&gt;
  &lt;banner.Title&gt;Banner title&lt;/banner.Title&gt;
  &lt;banner.Body&gt;A load of body text&lt;/banner.Body&gt;
&lt;/Banner&gt;</pre> <p>Result:</p> <pre class="highlight html" data-language="html">&lt;div&gt;
  &lt;h2&gt;Banner subtitle&lt;/h2&gt;
  &lt;h1&gt;Banner title&lt;/h1&gt;
  A load of body text
&lt;/div&gt;</pre> <p>Another benefit to using <code>yield</code> with the <code>hash</code> and <code>component</code> helper is you can pass attributes and arguments to these components:</p> <div class="pre-title"><code>app/templates/application.hbs</code></div>
<pre class="highlight handlebars" data-language="html">&lt;Banner @value={{@model}} as |banner|&gt;
  &lt;banner.Subtitle class="mb-1"&gt;Banner subtitle&lt;/banner.Subtitle&gt;
  &lt;banner.Title @variant="loud"&gt;Banner title&lt;/banner.Title&gt;
  &lt;banner.Body&gt;A load of body text&lt;/banner.Body&gt;
&lt;/Banner&gt;</pre> <div class="pre-title"><code>app/components/banner/subtitle.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{!-- note the use of ..attributes --}}
&lt;h2 ...attributes&gt;
  {{yield}}
&lt;/h2&gt;</pre> <div class="pre-title"><code>app/components/banner/title.hbs</code></div>
<pre class="highlight handlebars" data-language="html">{{#if (eq @variant "loud")}}
    &lt;h1 class="loud"&gt;{{yield}}&lt;/h1&gt;
{{else}}
    &lt;h1 class="quiet"&gt;{{yield}}&lt;/h1&gt;
{{/if}}</pre> <p>Result:</p> <pre class="highlight html" data-language="html">&lt;div&gt;
  &lt;h2 class="mb-1"&gt;Banner subtitle&lt;/h2&gt;
  &lt;h1 class="loud"&gt;Banner title&lt;/h1&gt;
  A load of body text
&lt;/div&gt;</pre>   </article><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 Yehuda Katz, Tom Dale and Ember.js contributors<br>Licensed under the MIT License.<br>
    <a href="https://api.emberjs.com/ember/4.9/classes/Ember.Templates.helpers/methods" class="_attribution-link">https://api.emberjs.com/ember/4.9/classes/Ember.Templates.helpers/methods</a>
  </p>
</div>
