<h1 class="module-name">Function</h1>  <h3 role="link" id="setHelperManager">  <span class="method-name">setHelperManager</span> <span class="args"> (factory, definition) </span> <span class="return-type">Object</span> <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/@ember/helper.html">@ember/helper</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/ember.js/tree/v4.9.1/packages/@ember/helper/index.ts#L58" target="_blank" rel="noopener noreferrer"> packages/@ember/helper/index.ts:58 </a> </p>  <pre class="highlight javascript" data-language="javascript">import { setHelperManager } from '@ember/helper';</pre> <dl class="parameters">  <dt>factory</dt> <dd class="parameter-type">Function</dd> <dd>A factory function which receives an optional owner, and returns a helper manager</dd>    <dt>definition</dt> <dd class="parameter-type">Object</dd> <dd>The definition to associate the manager factory with</dd>    <dt>returns</dt> <dd class="return-type">Object</dd> <dd>The definition passed into setHelperManager</dd>  </dl> <p>Sets the helper manager for an object or function.</p> <pre class="highlight javascript" data-language="javascript">setHelperManager((owner) =&gt; new ClassHelperManager(owner), Helper)</pre> <p>When a value is used as a helper in a template, the helper manager is looked up on the object by walking up its prototype chain and finding the first helper manager. This manager then receives the value and can create and manage an instance of a helper from it. This provides a layer of indirection that allows users to design high-level helper APIs, without Ember needing to worry about the details. High-level APIs can be experimented with and iterated on while the core of Ember helpers remains stable, and new APIs can be introduced gradually over time to existing code bases.</p> <p><code>setHelperManager</code> receives two arguments:</p> <ol> <li>A factory function, which receives the <code>owner</code> and returns an instance of a helper manager.</li> <li>A helper definition, which is the object or function to associate the factory function with.</li> </ol> <p>The first time the object is looked up, the factory function will be called to create the helper manager. It will be cached, and in subsequent lookups the cached helper manager will be used instead.</p> <p>Only one helper manager is guaranteed to exist per <code>owner</code> and per usage of <code>setHelperManager</code>, so many helpers will end up using the same instance of the helper manager. As such, you should only store state that is related to the manager itself. If you want to store state specific to a particular helper definition, you should assign a unique helper manager to that helper. In general, most managers should either be stateless, or only have the <code>owner</code> they were created with as state.</p> <p>Helper managers must fulfill the following interface (This example uses <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html">TypeScript interfaces</a> for precision, you do not need to write helper managers using TypeScript):</p> <pre class="highlight typescript" data-language="">interface HelperManager&lt;HelperStateBucket&gt; {
  capabilities: HelperCapabilities;

  createHelper(definition: HelperDefinition, args: TemplateArgs): HelperStateBucket;

  getValue?(bucket: HelperStateBucket): unknown;

  runEffect?(bucket: HelperStateBucket): void;

  getDestroyable?(bucket: HelperStateBucket): object;
}</pre> <p>The capabilities property <em>must</em> be provided using the <code>capabilities()</code> function imported from the same module as <code>setHelperManager</code>:</p> <pre class="highlight javascript" data-language="javascript">import { capabilities } from '@ember/helper';

class MyHelperManager {
  capabilities = capabilities('3.21.0', { hasValue: true });

  // ...snip...
}</pre> <p>Below is a description of each of the methods on the interface and their functions.</p> <h4 id="createhelper"><code>createHelper</code></h4> <p><code>createHelper</code> is a required hook on the HelperManager interface. The hook is passed the definition of the helper that is currently being created, and is expected to return a <em>state bucket</em>. This state bucket is what represents the current state of the helper, and will be passed to the other lifecycle hooks at appropriate times. It is not necessarily related to the definition of the helper itself - for instance, you could return an object <em>containing</em> an instance of the helper:</p> <pre class="highlight javascript" data-language="javascript">class MyManager {
  createHelper(Definition, args) {
    return {
      instance: new Definition(args);
    };
  }
}</pre> <p>This allows the manager to store metadata that it doesn't want to expose to the user.</p> <p>This hook is <em>not</em> autotracked - changes to tracked values used within this hook will <em>not</em> result in a call to any of the other lifecycle hooks. This is because it is unclear what should happen if it invalidates, and rather than make a decision at this point, the initial API is aiming to allow as much expressivity as possible. This could change in the future with changes to capabilities and their behaviors.</p> <p>If users do want to autotrack some values used during construction, they can either create the instance of the helper in <code>runEffect</code> or <code>getValue</code>, or they can use the <code>cache</code> API to autotrack the <code>createHelper</code> hook themselves. This provides maximum flexibility and expressiveness to manager authors.</p> <p>This hook has the following timing semantics:</p> <p><strong>Always</strong></p> <ul> <li>called as discovered during DOM construction</li> <li>called in definition order in the template</li> </ul> <h4 id="getvalue"><code>getValue</code></h4> <p><code>getValue</code> is an optional hook that should return the value of the helper. This is the value that is returned from the helper and passed into the template.</p> <p>This hook is called when the value is requested from the helper (e.g. when the template is rendering and the helper value is needed). The hook is autotracked, and will rerun whenever any tracked values used inside of it are updated. Otherwise it does not rerun.</p> <blockquote> <p>Note: This means that arguments which are not <em>consumed</em> within the hook will not trigger updates.</p> </blockquote> <p>This hook is only called for helpers with the <code>hasValue</code> capability enabled. This hook has the following timing semantics:</p> <p><strong>Always</strong></p> <ul> <li>called the first time the helper value is requested</li> <li>called after autotracked state has changed</li> </ul> <p><strong>Never</strong></p> <ul> <li>called if the <code>hasValue</code> capability is disabled</li> </ul> <h4 id="runeffect"><code>runEffect</code></h4> <p><code>runEffect</code> is an optional hook that should run the effect that the helper is applying, setting it up or updating it.</p> <p>This hook is scheduled to be called some time after render and prior to paint. There is not a guaranteed, 1-to-1 relationship between a render pass and this hook firing. For instance, multiple render passes could occur, and the hook may only trigger once. It may also never trigger if it was dirtied in one render pass and then destroyed in the next.</p> <p>The hook is autotracked, and will rerun whenever any tracked values used inside of it are updated. Otherwise it does not rerun.</p> <p>The hook is also run during a time period where state mutations are <em>disabled</em> in Ember. Any tracked state mutation will throw an error during this time, including changes to tracked properties, changes made using <code>Ember.set</code>, updates to computed properties, etc. This is meant to prevent infinite rerenders and other antipatterns.</p> <p>This hook is only called for helpers with the <code>hasScheduledEffect</code> capability enabled. This hook is also not called in SSR currently, though this could be added as a capability in the future. It has the following timing semantics:</p> <p><strong>Always</strong></p> <ul> <li>called after the helper was first created, if the helper has not been destroyed since creation</li> <li>called after autotracked state has changed, if the helper has not been destroyed during render</li> </ul> <p><strong>Never</strong></p> <ul> <li>called if the <code>hasScheduledEffect</code> capability is disabled</li> <li>called in SSR</li> </ul> <h4 id="getdestroyable"><code>getDestroyable</code></h4> <p><code>getDestroyable</code> is an optional hook that users can use to register a destroyable object for the helper. This destroyable will be registered to the containing block or template parent, and will be destroyed when it is destroyed. See the <a href="https://github.com/emberjs/rfcs/blob/master/text/0580-destroyables.md">Destroyables RFC</a> for more details.</p> <p><code>getDestroyable</code> is only called if the <code>hasDestroyable</code> capability is enabled.</p> <p>This hook has the following timing semantics:</p> <p><strong>Always</strong></p> <ul> <li>called immediately after the <code>createHelper</code> hook is called</li> </ul> <p><strong>Never</strong></p> <ul> <li>called if the <code>hasDestroyable</code> capability is disabled</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 Yehuda Katz, Tom Dale and Ember.js contributors<br>Licensed under the MIT License.<br>
    <a href="https://api.emberjs.com/ember/4.9/functions/@ember%2Fhelper/setHelperManager" class="_attribution-link">https://api.emberjs.com/ember/4.9/functions/@ember%2Fhelper/setHelperManager</a>
  </p>
</div>
