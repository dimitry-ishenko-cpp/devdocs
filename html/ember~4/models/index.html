<h1> Introduction </h1>  <div id="ember359365" class="ember-view">
<p>This section of the Guides describes the essential features of Ember Data, a powerful set of tools for formatting requests, normalizing responses, and efficiently managing a local cache of data.</p> <p>Ember.js itself works with any type of back end: REST, JSON:API, GraphQL, or anything else. To learn about other ways to handle data and to find extensions, check out the guide for <a href="../in-depth-topics/making-api-requests.html">making API requests</a>, look for plugins on <a href="https://www.emberobserver.com/">Ember Observer</a>, and search for community-made tutorials.</p> <h2 id="toc_what-are-ember-data-models">What are Ember Data models?</h2> <section aria-labelledby="toc_what-are-ember-data-models"> <p>In Ember Data, models are objects that represent the underlying data that your application presents to the user. Note that Ember Data models are a different concept than the <a href="../routing/specifying-a-routes-model.html"><code>model</code></a> method on Routes, although they share the same name.</p> <p>Different apps may have very different models, depending on what problems they're trying to solve. For example, a photo sharing application might have a <code>Photo</code> model to represent a particular photo, and a <code>PhotoAlbum</code> that represents a group of photos. In contrast, an online shopping app would probably have different models, like <code>ShoppingCart</code>, <code>Invoice</code>, or <code>LineItem</code>.</p> <p>Models tend to be <em>persistent</em>. That means the user does not expect model data to be lost when they close their browser window. To make sure no data is lost, if the user makes changes to a model, you need to store the model data somewhere that it will not be lost.</p> <p>Typically, most models are loaded from and saved to a server that uses a database to store data. Usually you will send JSON representations of models back and forth to an HTTP server that you have written. However, Ember makes it easy to use other durable storage, such as saving to the user's hard disk with <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a>, or hosted storage solutions that let you avoid writing and hosting your own servers.</p> <p>Once you've loaded your models from storage, components know how to translate model data into a UI that your user can interact with. For more information about how components get model data, see the <a href="../routing/specifying-a-routes-model.html">Specifying a Route's Model</a> guide.</p> <p>At first, using Ember Data may feel different than the way you're used to writing JavaScript applications. Many developers are familiar with using Ajax to fetch raw JSON data from an endpoint, which may appear easy at first. Over time, however, complexity leaks out into your application code, making it hard to maintain.</p> <p>With Ember Data, managing models as your application grows becomes both simpler <em>and</em> easier.</p> <p>Once you have an understanding of Ember Data, you will have a much better way to manage the complexity of data loading in your application. This will allow your code to evolve and grow, with better maintainability.</p> </section> <h2 id="toc_ember-data-flexibility">Ember Data flexibility</h2> <section aria-labelledby="toc_ember-data-flexibility"> <p>Thanks to its use of the <em>adapter pattern</em>, Ember Data can be configured to work with many different kinds of backends. There is <a href="http://emberobserver.com/categories/ember-data-adapters">an entire ecosystem of adapters</a> and several <a href="customizing-adapters.html">built-in adapters</a> that allow your Ember app to talk to different types of servers.</p> <p>By default, Ember Data is designed to work out of the box with <a href="http://jsonapi.org">JSON:API</a>. JSON:API is a formal specification for building conventional, robust, and performant APIs that allow clients and servers to communicate model data.</p> <p>JSON:API standardizes how JavaScript applications talk to servers, so you decrease the coupling between your frontend and backend, and have more freedom to change pieces of your stack.</p> <p>If you need to integrate your Ember.js app with a server that does not have an <a href="http://emberobserver.com/categories/ember-data-adapters">adapter</a> available (for example, you hand-rolled an API server that does not adhere to any JSON specification), Ember Data is designed to <strong>be configurable</strong> to work with whatever data your server returns.</p> <p>Ember Data is also designed to work with streaming servers, like those powered by WebSockets. You can open a socket to your server and push changes into Ember Data whenever they occur, giving your app a real-time user interface that is always up-to-date.</p> </section> <h2 id="toc_the-store-and-a-single-source-of-truth">The Store and a Single Source of Truth</h2> <section aria-labelledby="toc_the-store-and-a-single-source-of-truth"> <p>One common way of building web applications is to tightly couple user interface elements to data fetching. For example, imagine you are writing the admin section of a blogging app, which has a feature that lists the drafts for the currently logged in user.</p> <p>You might be tempted to make the component responsible for fetching that data and storing it:</p> <pre><code class="javascript language-javascript" data-filename="app/components/list-of-drafts.js">import Component from "@glimmer/component";
import { tracked } from "@glimmer/tracking";
import fetch from "fetch";

export default class ListOfDraftsComponent extends Component {
  @tracked drafts;

  constructor() {
    super(...arguments);

    fetch("/drafts").then((data) =&gt; {
      this.drafts = data;
    });
  }
}
</code></pre> <p>You could then show the list of drafts in your component's template like this:</p> <pre><code class="handlebars language-handlebars" data-filename="app/components/list-of-drafts.hbs">&lt;ul&gt;
  {{#each this.drafts key="id" as |draft|}}
    &lt;li&gt;{{draft.title}}&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;
</code></pre> <p>This works great for the <code>list-of-drafts</code> component. However, your app is likely made up of many different components. On another page you may want a component to display the number of drafts. You may be tempted to copy and paste your existing <code>willRender</code> code into the new component.</p> <pre><code class="javascript language-javascript" data-filename="app/components/drafts-button.js">import Component from "@glimmer/component";
import { tracked } from "@glimmer/tracking";
import fetch from "fetch";

export default class DraftsButtonComponent extends Component {
  @tracked drafts;

  constructor() {
    super(...arguments);

    fetch("/drafts").then((data) =&gt; {
      this.drafts = data;
    });
  }
}
</code></pre> <pre><code class="handlebars language-handlebars" data-filename="app/components/drafts-button.hbs">&lt;LinkTo @route="drafts"&gt;
  Drafts ({{this.drafts.length}})
&lt;/LinkTo&gt;
</code></pre> <p>Unfortunately, the app will now make two separate requests for the same information. Not only is the redundant data fetching costly in terms of wasted bandwidth and affecting the perceived speed of your app, it's easy for the two values to get out-of-sync. You yourself have probably used a web application where the list of items gets out of sync with the counter in a toolbar, leading to a frustrating and inconsistent experience.</p> <p>There is also a <em>tight coupling</em> between your application's UI and the network code. If the URL or the format of the JSON payload changes, it is likely to break all of your UI components in ways that are hard to track down.</p> <p>The SOLID principles of good design tell us that objects should have a single responsibility. The responsibility of a component should be presenting model data to the user, not fetching the model.</p> <p>Good Ember apps take a different approach. Ember Data gives you a single <strong>store</strong> that is the central repository of models in your application. Routes and their corresponding controllers can ask the store for models, and the store is responsible for knowing how to fetch them.</p> <p>It also means that the store can detect that two different components are asking for the same model, allowing your app to only fetch the data from the server once. You can think of the store as a read-through cache for your app's models. Both routes and their corresponding controllers have access to this shared store; when they need to display or modify a model, they first ask the store for it.</p> </section> <h3 id="toc_injecting-the-store">Injecting the store</h3> <section aria-labelledby="toc_injecting-the-store"> <p>Ember Data provides a store service that you can inject into routes, components, services and other classes, that enables you to access the store directly.</p> <p>To do this, import the <a href="https://api.emberjs.com/ember/release/functions/@ember%2Fservice/service"><code>service</code> decorator</a> and inject a <code>store</code> property into your class. Let's see an example using a route:</p> <pre><code class="javascript language-javascript">import Route from "@ember/routing/route";
import { service } from "@ember/service";

export default class BlogPostsIndexRoute extends Route {
  @service store;

  model() {
    return this.store.findAll("posts");
  }
}
</code></pre> <div class="cta"> <div class="cta-note"> <div class="cta-note-body"> <div class="cta-note-heading">Zoey says...</div> <div class="cta-note-message"> You can read more about service injection in the <a href="../services.html#toc_accessing-services"><i>Accessing Services</i></a> guide. </div> </div> <img src="https://guides.emberjs.com/v4.9.0/images/mascots/zoey.png" role="presentation" alt=""> </div> </div> </section> <h2 id="toc_models">Models</h2> <section aria-labelledby="toc_models"> <p>In Ember Data, each model is represented by a subclass of <code>Model</code> that defines the attributes, relationships, and behavior of the data that you present to the user.</p> <p>Models define the type of data that will be provided by your server. For example, a <code>Person</code> model might have a <code>name</code> attribute that is a string, and a <code>birthday</code> attribute that is a date:</p> <pre><code class="javascript language-javascript" data-filename="app/models/person.js">import Model, { attr } from "@ember-data/model";

export default class PersonModel extends Model {
  @attr("string") name;
  @attr("date") birthday;
}
</code></pre> <p>A model also describes its relationships with other objects. For example, an <code>order</code> may have many <code>line-items</code>, and a <code>line-item</code> may belong to a particular <code>order</code>.</p> <pre><code class="javascript language-javascript" data-filename="app/models/order.js">import Model, { hasMany } from "@ember-data/model";

export default class OrderModel extends Model {
  @hasMany("line-item") lineItems;
}
</code></pre> <pre><code class="javascript language-javascript" data-filename="app/models/line-item.js">import Model, { belongsTo } from "@ember-data/model";

export default class LineItemModel extends Model {
  @belongsTo("order") order;
}
</code></pre> <p>Models don't have any data themselves, they define the attributes, relationships and behavior of specific instances, which are called <strong>records</strong>.</p> </section> <h2 id="toc_records">Records</h2> <section aria-labelledby="toc_records"> <p>A <strong>record</strong> is an instance of a model that contains data loaded from a server. Your application can also create new records and save them back to the server.</p> <p>A record is uniquely identified by its model <strong>type</strong> and <strong>ID</strong>.</p> <p>For example, if you were writing a contact management app, you might have a <code>Person</code> model. An individual record in your app might have a type of <code>person</code> and an ID of <code>1</code> or <code>steve-buscemi</code>.</p> <pre><code class="javascript language-javascript">this.store.findRecord("person", 1); // =&gt; { id: 1, name: 'steve-buscemi' }
</code></pre> <p>An ID is usually assigned to a record by the server when you save it for the first time, but you can also generate IDs client-side.</p> </section> <h2 id="toc_adapter">Adapter</h2> <section aria-labelledby="toc_adapter"> <p>An <strong>adapter</strong> is an object that translates requests from Ember (such as "find the user with an ID of 1") into requests to a server.</p> <p>For example, if your application asks for a <code>Person</code> with an ID of <code>1</code>, how should Ember load it? Over HTTP or a WebSocket? If it's HTTP, is the URL <code>/person/1</code> or <code>/resources/people/1</code>?</p> <p>The adapter is responsible for answering all of these questions. Whenever your app asks the store for a record that it doesn't have cached, it will ask the adapter for it. If you change a record and save it, the store will hand the record to the adapter to send the appropriate data to your server and confirm that the save was successful.</p> <p>Adapters let you completely change how your API is implemented without impacting your Ember application code.</p> </section> <h2 id="toc_caching">Caching</h2> <section aria-labelledby="toc_caching"> <p>The store will automatically cache records for you. If a record had already been loaded, asking for it a second time will always return the same object instance. This minimizes the number of round-trips to the server, and allows your application to render its UI to the user as fast as possible.</p> <p>For example, the first time your application asks the store for a <code>person</code> record with an ID of <code>1</code>, it will fetch that information from your server.</p> <p>However, the next time your app asks for a <code>person</code> with ID <code>1</code>, the store will notice that it had already retrieved and cached that information from the server. Instead of sending another request for the same information, it will give your application the same record it had provided it the first time. This feature—always returning the same record object, no matter how many times you look it up—is sometimes called an <em>identity map</em>.</p> <p>Using an identity map is important because it ensures that changes you make in one part of your UI are propagated to other parts of the UI. It also means that you don't have to manually keep records in sync—you can ask for a record by ID and not have to worry about whether other parts of your application have already asked for and loaded it.</p> <p>One downside to returning a cached record is you may find the state of the data has changed since it was first loaded into the store's identity map. In order to prevent this stale data from being a problem for long, Ember Data will automatically make a request in the background each time a cached record is returned from the store. When the new data comes in, the record is updated, and if there have been changes to the record since the initial render, the template is re-rendered with the new information.</p> </section> <h2 id="toc_architecture-overview">Architecture Overview</h2> <section aria-labelledby="toc_architecture-overview"> <p>The first time your application asks the store for a record, the store sees that it doesn't have a local copy and requests it from your adapter. Your adapter will go and retrieve the record from your persistence layer; typically, this will be a JSON representation of the record served from an HTTP server.</p> <p><img src="https://guides.emberjs.com/v4.9.0/images/guides/models/finding-unloaded-record-step1-diagram.png" alt="Diagram showing process for finding an unloaded record"></p> <p>As illustrated in the diagram above, the adapter cannot always return the requested record immediately. In this case, the adapter must make an <em>asynchronous</em> request to the server, and only when that request finishes loading can the record be created with its backing data.</p> <p>Because of this asynchronicity, the store immediately returns a <em>promise</em> from the <code>findRecord()</code> method. Similarly, any request that the store makes to the adapter also returns promises.</p> <p>Once the request to the server returns with a JSON payload for the requested record, the adapter resolves the promise it returned to the store with the JSON.</p> <p>The store then takes that JSON, initializes the record with the JSON data, and resolves the promise returned to your application with the newly-loaded record.</p> <p><img src="https://guides.emberjs.com/v4.9.0/images/guides/models/finding-unloaded-record-step2-diagram.png" alt="Diagram showing process for finding an unloaded record after the payload has returned from the server"></p> <p>Let's look at what happens if you request a record that the store already has in its cache.</p> <p><img src="https://guides.emberjs.com/v4.9.0/images/guides/models/finding-loaded-record-diagram.png" alt="Diagram showing process for finding an unloaded record after the payload has returned from the server"></p> <p>In this case, because the store already knew about the record, it returns a promise that it resolves with the record immediately. It does not need to ask the adapter (and, therefore, the server) for a copy since it already has it saved locally.</p>  <p>Models, records, adapters and the store are the core concepts you should understand to get the most out of Ember Data. The following sections go into more depth about each of these concepts, and how to use them together.</p> </section> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 Yehuda Katz, Tom Dale and Ember.js contributors<br>Licensed under the MIT License.<br>
    <a href="https://guides.emberjs.com/v4.9.0/models/index" class="_attribution-link">https://guides.emberjs.com/v4.9.0/models/index</a>
  </p>
</div>
