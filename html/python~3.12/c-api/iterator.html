 <span id="id1"></span><h1>Iterator Objects</h1> <p>Python provides two general-purpose iterator objects. The first, a sequence iterator, works with an arbitrary sequence supporting the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> method. The second works with a callable object and a sentinel value, calling the callable for each item in the sequence, and ending the iteration when the sentinel value is returned.</p> <dl class="c var"> <dt class="sig sig-object c" id="c.PySeqIter_Type">
<code>PyTypeObject PySeqIter_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Type object for iterator objects returned by <a class="reference internal" href="#c.PySeqIter_New" title="PySeqIter_New"><code>PySeqIter_New()</code></a> and the one-argument form of the <a class="reference internal" href="../library/functions.html#iter" title="iter"><code>iter()</code></a> built-in function for built-in sequence types.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySeqIter_Check">
<code>int PySeqIter_Check(PyObject *op)</code> </dt> <dd>
<p>Return true if the type of <em>op</em> is <a class="reference internal" href="#c.PySeqIter_Type" title="PySeqIter_Type"><code>PySeqIter_Type</code></a>. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PySeqIter_New">
<code>PyObject *PySeqIter_New(PyObject *seq)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return an iterator that works with a general sequence object, <em>seq</em>. The iteration ends when the sequence raises <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a> for the subscripting operation.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyCallIter_Type">
<code>PyTypeObject PyCallIter_Type</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Type object for iterator objects returned by <a class="reference internal" href="#c.PyCallIter_New" title="PyCallIter_New"><code>PyCallIter_New()</code></a> and the two-argument form of the <a class="reference internal" href="../library/functions.html#iter" title="iter"><code>iter()</code></a> built-in function.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCallIter_Check">
<code>int PyCallIter_Check(PyObject *op)</code> </dt> <dd>
<p>Return true if the type of <em>op</em> is <a class="reference internal" href="#c.PyCallIter_Type" title="PyCallIter_Type"><code>PyCallIter_Type</code></a>. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCallIter_New">
<code>PyObject *PyCallIter_New(PyObject *callable, PyObject *sentinel)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Return a new iterator. The first parameter, <em>callable</em>, can be any Python callable object that can be called with no parameters; each call to it should return the next item in the iteration. When <em>callable</em> returns a value equal to <em>sentinel</em>, the iteration will be terminated.</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/c-api/iterator.html" class="_attribution-link">https://docs.python.org/3.12/c-api/iterator.html</a>
  </p>
</div>
