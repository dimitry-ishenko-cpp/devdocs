 <span id="codeobjects"></span><span id="index-0"></span><h1>Code Objects</h1> <p>Code objects are a low-level detail of the CPython implementation. Each one represents a chunk of executable code that hasn’t yet been bound into a function.</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyCodeObject">
<code>type PyCodeObject</code> </dt> <dd>
<p>The C structure of the objects used to describe code objects. The fields of this type are subject to change at any time.</p> </dd>
</dl> <dl class="c var"> <dt class="sig sig-object c" id="c.PyCode_Type">
<code>PyTypeObject PyCode_Type</code> </dt> <dd>
<p>This is an instance of <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> representing the Python <a class="reference internal" href="../library/code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code>code</code></a> type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_Check">
<code>int PyCode_Check(PyObject *co)</code> </dt> <dd>
<p>Return true if <em>co</em> is a <a class="reference internal" href="../library/code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code>code</code></a> object. This function always succeeds.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_GetNumFree">
<code>int PyCode_GetNumFree(PyCodeObject *co)</code> </dt> <dd>
<p>Return the number of free variables in <em>co</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnstable_Code_New">
<code>PyCodeObject *PyUnstable_Code_New(int argcount, int kwonlyargcount, int nlocals, int stacksize, int flags, PyObject *code, PyObject *consts, PyObject *names, PyObject *varnames, PyObject *freevars, PyObject *cellvars, PyObject *filename, PyObject *name, PyObject *qualname, int firstlineno, PyObject *linetable, PyObject *exceptiontable)</code> </dt> <dd>
<div class="unstable-c-api warning admonition"> <em>This is <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable API</span></a>. It may change without warning in minor releases.</em>
</div> <p>Return a new code object. If you need a dummy code object to create a frame, use <a class="reference internal" href="#c.PyCode_NewEmpty" title="PyCode_NewEmpty"><code>PyCode_NewEmpty()</code></a> instead.</p> <p>Since the definition of the bytecode changes often, calling <a class="reference internal" href="#c.PyUnstable_Code_New" title="PyUnstable_Code_New"><code>PyUnstable_Code_New()</code></a> directly can bind you to a precise Python version.</p> <p>The many arguments of this function are inter-dependent in complex ways, meaning that subtle changes to values are likely to result in incorrect execution or VM crashes. Use this function only with extreme care.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Added <code>qualname</code> and <code>exceptiontable</code> parameters.</p> </div> <div class="versionchanged" id="index-1"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Renamed from <code>PyCode_New</code> as part of <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable C API</span></a>. The old name is deprecated, but will remain available until the signature changes again.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnstable_Code_NewWithPosOnlyArgs">
<code>PyCodeObject *PyUnstable_Code_NewWithPosOnlyArgs(int argcount, int posonlyargcount, int kwonlyargcount, int nlocals, int stacksize, int flags, PyObject *code, PyObject *consts, PyObject *names, PyObject *varnames, PyObject *freevars, PyObject *cellvars, PyObject *filename, PyObject *name, PyObject *qualname, int firstlineno, PyObject *linetable, PyObject *exceptiontable)</code> </dt> <dd>
<div class="unstable-c-api warning admonition"> <em>This is <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable API</span></a>. It may change without warning in minor releases.</em>
</div> <p>Similar to <a class="reference internal" href="#c.PyUnstable_Code_New" title="PyUnstable_Code_New"><code>PyUnstable_Code_New()</code></a>, but with an extra “posonlyargcount” for positional-only arguments. The same caveats that apply to <code>PyUnstable_Code_New</code> also apply to this function.</p> <div class="versionadded" id="index-2"> <p><span class="versionmodified added">New in version 3.8: </span>as <code>PyCode_NewWithPosOnlyArgs</code></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>Added <code>qualname</code> and <code>exceptiontable</code> parameters.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Renamed to <code>PyUnstable_Code_NewWithPosOnlyArgs</code>. The old name is deprecated, but will remain available until the signature changes again.</p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_NewEmpty">
<code>PyCodeObject *PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno)</code> </dt> <dd>
<em class="refcount">Return value: New reference.</em><p>Return a new empty code object with the specified filename, function name, and first line number. The resulting code object will raise an <code>Exception</code> if executed.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_Addr2Line">
<code>int PyCode_Addr2Line(PyCodeObject *co, int byte_offset)</code> </dt> <dd>
<p>Return the line number of the instruction that occurs on or before <code>byte_offset</code> and ends after it. If you just need the line number of a frame, use <a class="reference internal" href="frame.html#c.PyFrame_GetLineNumber" title="PyFrame_GetLineNumber"><code>PyFrame_GetLineNumber()</code></a> instead.</p> <p>For efficiently iterating over the line numbers in a code object, use <a class="reference external" href="https://peps.python.org/pep-0626/#out-of-process-debuggers-and-profilers">the API described in PEP 626</a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_Addr2Location">
<code>int PyCode_Addr2Location(PyObject *co, int byte_offset, int *start_line, int *start_column, int *end_line, int *end_column)</code> </dt> <dd>
<p>Sets the passed <code>int</code> pointers to the source code line and column numbers for the instruction at <code>byte_offset</code>. Sets the value to <code>0</code> when information is not available for any particular element.</p> <p>Returns <code>1</code> if the function succeeds and 0 otherwise.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_GetCode">
<code>PyObject *PyCode_GetCode(PyCodeObject *co)</code> </dt> <dd>
<p>Equivalent to the Python code <code>getattr(co, 'co_code')</code>. Returns a strong reference to a <a class="reference internal" href="bytes.html#c.PyBytesObject" title="PyBytesObject"><code>PyBytesObject</code></a> representing the bytecode in a code object. On error, <code>NULL</code> is returned and an exception is raised.</p> <p>This <code>PyBytesObject</code> may be created on-demand by the interpreter and does not necessarily represent the bytecode actually executed by CPython. The primary use case for this function is debuggers and profilers.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_GetVarnames">
<code>PyObject *PyCode_GetVarnames(PyCodeObject *co)</code> </dt> <dd>
<p>Equivalent to the Python code <code>getattr(co, 'co_varnames')</code>. Returns a new reference to a <a class="reference internal" href="tuple.html#c.PyTupleObject" title="PyTupleObject"><code>PyTupleObject</code></a> containing the names of the local variables. On error, <code>NULL</code> is returned and an exception is raised.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_GetCellvars">
<code>PyObject *PyCode_GetCellvars(PyCodeObject *co)</code> </dt> <dd>
<p>Equivalent to the Python code <code>getattr(co, 'co_cellvars')</code>. Returns a new reference to a <a class="reference internal" href="tuple.html#c.PyTupleObject" title="PyTupleObject"><code>PyTupleObject</code></a> containing the names of the local variables that are referenced by nested functions. On error, <code>NULL</code> is returned and an exception is raised.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_GetFreevars">
<code>PyObject *PyCode_GetFreevars(PyCodeObject *co)</code> </dt> <dd>
<p>Equivalent to the Python code <code>getattr(co, 'co_freevars')</code>. Returns a new reference to a <a class="reference internal" href="tuple.html#c.PyTupleObject" title="PyTupleObject"><code>PyTupleObject</code></a> containing the names of the free variables. On error, <code>NULL</code> is returned and an exception is raised.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_AddWatcher">
<code>int PyCode_AddWatcher(PyCode_WatchCallback callback)</code> </dt> <dd>
<p>Register <em>callback</em> as a code object watcher for the current interpreter. Return an ID which may be passed to <a class="reference internal" href="#c.PyCode_ClearWatcher" title="PyCode_ClearWatcher"><code>PyCode_ClearWatcher()</code></a>. In case of error (e.g. no more watcher IDs available), return <code>-1</code> and set an exception.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyCode_ClearWatcher">
<code>int PyCode_ClearWatcher(int watcher_id)</code> </dt> <dd>
<p>Clear watcher identified by <em>watcher_id</em> previously returned from <a class="reference internal" href="#c.PyCode_AddWatcher" title="PyCode_AddWatcher"><code>PyCode_AddWatcher()</code></a> for the current interpreter. Return <code>0</code> on success, or <code>-1</code> and set an exception on error (e.g. if the given <em>watcher_id</em> was never registered.)</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyCodeEvent">
<code>type PyCodeEvent</code> </dt> <dd>
<p>Enumeration of possible code object watcher events: - <code>PY_CODE_EVENT_CREATE</code> - <code>PY_CODE_EVENT_DESTROY</code></p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.PyCode_WatchCallback">
<code>typedef int (*PyCode_WatchCallback)(PyCodeEvent event, PyCodeObject *co)</code> </dt> <dd>
<p>Type of a code object watcher callback function.</p> <p>If <em>event</em> is <code>PY_CODE_EVENT_CREATE</code>, then the callback is invoked after <code>co</code> has been fully initialized. Otherwise, the callback is invoked before the destruction of <em>co</em> takes place, so the prior state of <em>co</em> can be inspected.</p> <p>If <em>event</em> is <code>PY_CODE_EVENT_DESTROY</code>, taking a reference in the callback to the about-to-be-destroyed code object will resurrect it and prevent it from being freed at this time. When the resurrected object is destroyed later, any watcher callbacks active at that time will be called again.</p> <p>Users of this API should not rely on internal runtime implementation details. Such details may include, but are not limited to, the exact order and timing of creation and destruction of code objects. While changes in these details may result in differences observable by watchers (including whether a callback is invoked or not), it does not change the semantics of the Python code being executed.</p> <p>If the callback sets an exception, it must return <code>-1</code>; this exception will be printed as an unraisable exception using <a class="reference internal" href="exceptions.html#c.PyErr_WriteUnraisable" title="PyErr_WriteUnraisable"><code>PyErr_WriteUnraisable()</code></a>. Otherwise it should return <code>0</code>.</p> <p>There may already be a pending exception set on entry to the callback. In this case, the callback should return <code>0</code> with the same exception still set. This means the callback may not call any other API that can set an exception unless it saves and clears the exception state first, and restores it before returning.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/c-api/code.html" class="_attribution-link">https://docs.python.org/3.12/c-api/code.html</a>
  </p>
</div>
