 <span id="supporting-cycle-detection"></span><h1>Supporting Cyclic Garbage Collection</h1> <p>Python’s support for detecting and collecting garbage which involves circular references requires support from object types which are “containers” for other objects which may also be containers. Types which do not store references to other objects, or which only store references to atomic types (such as numbers or strings), do not need to provide any explicit support for garbage collection.</p> <p>To create a container type, the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a> field of the type object must include the <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> and provide an implementation of the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler. If instances of the type are mutable, a <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> implementation must also be provided.</p> <dl class="simple"> <dt>
<code></code> <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a>
</dt>
<dd>
<p>Objects with a type with this flag set must conform with the rules documented here. For convenience these objects will be referred to as container objects.</p> </dd> </dl> <p>Constructors for container types must conform to two rules:</p> <ol class="arabic simple"> <li>The memory for the object must be allocated using <a class="reference internal" href="#c.PyObject_GC_New" title="PyObject_GC_New"><code>PyObject_GC_New</code></a> or <a class="reference internal" href="#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code>PyObject_GC_NewVar</code></a>.</li> <li>Once all the fields which may contain references to other containers are initialized, it must call <a class="reference internal" href="#c.PyObject_GC_Track" title="PyObject_GC_Track"><code>PyObject_GC_Track()</code></a>.</li> </ol> <p>Similarly, the deallocator for the object must conform to a similar pair of rules:</p> <ol class="arabic"> <li>Before fields which refer to other containers are invalidated, <a class="reference internal" href="#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code>PyObject_GC_UnTrack()</code></a> must be called.</li> <li>
<p>The object’s memory must be deallocated using <a class="reference internal" href="#c.PyObject_GC_Del" title="PyObject_GC_Del"><code>PyObject_GC_Del()</code></a>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If a type adds the Py_TPFLAGS_HAVE_GC, then it <em>must</em> implement at least a <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler or explicitly use one from its subclass or subclasses.</p> <p>When calling <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code>PyType_Ready()</code></a> or some of the APIs that indirectly call it like <a class="reference internal" href="type.html#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code>PyType_FromSpecWithBases()</code></a> or <a class="reference internal" href="type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code>PyType_FromSpec()</code></a> the interpreter will automatically populate the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code>tp_flags</code></a>, <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> and <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> fields if the type inherits from a class that implements the garbage collector protocol and the child class does <em>not</em> include the <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag.</p> </div> </li> </ol> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyObject_GC_New">
<code>PyObject_GC_New(TYPE, typeobj)</code> </dt> <dd>
<p>Analogous to <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code>PyObject_New</code></a> but for container objects with the <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag set.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyObject_GC_NewVar">
<code>PyObject_GC_NewVar(TYPE, typeobj, size)</code> </dt> <dd>
<p>Analogous to <a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code>PyObject_NewVar</code></a> but for container objects with the <a class="reference internal" href="typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code>Py_TPFLAGS_HAVE_GC</code></a> flag set.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnstable_Object_GC_NewWithExtraData">
<code>PyObject *PyUnstable_Object_GC_NewWithExtraData(PyTypeObject *type, size_t extra_size)</code> </dt> <dd>
<div class="unstable-c-api warning admonition"> <em>This is <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable API</span></a>. It may change without warning in minor releases.</em>
</div> <p>Analogous to <a class="reference internal" href="#c.PyObject_GC_New" title="PyObject_GC_New"><code>PyObject_GC_New</code></a> but allocates <em>extra_size</em> bytes at the end of the object (at offset <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code>tp_basicsize</code></a>). The allocated memory is initialized to zeros, except for the <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code>Python object header</code></a>.</p> <p>The extra data will be deallocated with the object, but otherwise it is not managed by Python.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The function is marked as unstable because the final mechanism for reserving extra data after an instance is not yet decided. For allocating a variable number of fields, prefer using <a class="reference internal" href="structures.html#c.PyVarObject" title="PyVarObject"><code>PyVarObject</code></a> and <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code>tp_itemsize</code></a> instead.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_GC_Resize">
<code>TYPE *PyObject_GC_Resize(TYPE, PyVarObject *op, Py_ssize_t newsize)</code> </dt> <dd>
<p>Resize an object allocated by <a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code>PyObject_NewVar</code></a>. Returns the resized object or <code>NULL</code> on failure. <em>op</em> must not be tracked by the collector yet.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_GC_Track">
<code>void PyObject_GC_Track(PyObject *op)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Adds the object <em>op</em> to the set of container objects tracked by the collector. The collector can run at unexpected times so objects must be valid while being tracked. This should be called once all the fields followed by the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler become valid, usually near the end of the constructor.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_IS_GC">
<code>int PyObject_IS_GC(PyObject *obj)</code> </dt> <dd>
<p>Returns non-zero if the object implements the garbage collector protocol, otherwise returns 0.</p> <p>The object cannot be tracked by the garbage collector if this function returns 0.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_GC_IsTracked">
<code>int PyObject_GC_IsTracked(PyObject *op)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.9.</em><p>Returns 1 if the object type of <em>op</em> implements the GC protocol and <em>op</em> is being currently tracked by the garbage collector and 0 otherwise.</p> <p>This is analogous to the Python function <a class="reference internal" href="../library/gc.html#gc.is_tracked" title="gc.is_tracked"><code>gc.is_tracked()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_GC_IsFinalized">
<code>int PyObject_GC_IsFinalized(PyObject *op)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.9.</em><p>Returns 1 if the object type of <em>op</em> implements the GC protocol and <em>op</em> has been already finalized by the garbage collector and 0 otherwise.</p> <p>This is analogous to the Python function <a class="reference internal" href="../library/gc.html#gc.is_finalized" title="gc.is_finalized"><code>gc.is_finalized()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_GC_Del">
<code>void PyObject_GC_Del(void *op)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Releases memory allocated to an object using <a class="reference internal" href="#c.PyObject_GC_New" title="PyObject_GC_New"><code>PyObject_GC_New</code></a> or <a class="reference internal" href="#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code>PyObject_GC_NewVar</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyObject_GC_UnTrack">
<code>void PyObject_GC_UnTrack(void *op)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Remove the object <em>op</em> from the set of container objects tracked by the collector. Note that <a class="reference internal" href="#c.PyObject_GC_Track" title="PyObject_GC_Track"><code>PyObject_GC_Track()</code></a> can be called again on this object to add it back to the set of tracked objects. The deallocator (<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code>tp_dealloc</code></a> handler) should call this for the object before any of the fields used by the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler become invalid.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>The <code>_PyObject_GC_TRACK()</code> and <code>_PyObject_GC_UNTRACK()</code> macros have been removed from the public C API.</p> </div> <p>The <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler accepts a function parameter of this type:</p> <dl class="c type"> <dt class="sig sig-object c" id="c.visitproc">
<code>typedef int (*visitproc)(PyObject *object, void *arg)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Type of the visitor function passed to the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler. The function should be called with an object to traverse as <em>object</em> and the third parameter to the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler as <em>arg</em>. The Python core uses several visitor functions to implement cyclic garbage detection; it’s not expected that users will need to write their own visitor functions.</p> </dd>
</dl> <p>The <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handler must have the following type:</p> <dl class="c type"> <dt class="sig sig-object c" id="c.traverseproc">
<code>typedef int (*traverseproc)(PyObject *self, visitproc visit, void *arg)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Traversal function for a container object. Implementations must call the <em>visit</em> function for each object directly contained by <em>self</em>, with the parameters to <em>visit</em> being the contained object and the <em>arg</em> value passed to the handler. The <em>visit</em> function must not be called with a <code>NULL</code> object argument. If <em>visit</em> returns a non-zero value that value should be returned immediately.</p> </dd>
</dl> <p>To simplify writing <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handlers, a <a class="reference internal" href="#c.Py_VISIT" title="Py_VISIT"><code>Py_VISIT()</code></a> macro is provided. In order to use this macro, the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> implementation must name its arguments exactly <em>visit</em> and <em>arg</em>:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.Py_VISIT">
<code>void Py_VISIT(PyObject *o)</code> </dt> <dd>
<p>If <em>o</em> is not <code>NULL</code>, call the <em>visit</em> callback, with arguments <em>o</em> and <em>arg</em>. If <em>visit</em> returns a non-zero value, then return it. Using this macro, <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code>tp_traverse</code></a> handlers look like:</p> <pre data-language="c">static int
my_traverse(Noddy *self, visitproc visit, void *arg)
{
    Py_VISIT(self-&gt;foo);
    Py_VISIT(self-&gt;bar);
    return 0;
}
</pre> </dd>
</dl> <p>The <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code>tp_clear</code></a> handler must be of the <a class="reference internal" href="#c.inquiry" title="inquiry"><code>inquiry</code></a> type, or <code>NULL</code> if the object is immutable.</p> <dl class="c type"> <dt class="sig sig-object c" id="c.inquiry">
<code>typedef int (*inquiry)(PyObject *self)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Drop references that may have created reference cycles. Immutable objects do not have to define this method since they can never directly create reference cycles. Note that the object must still be valid after calling this method (don’t just call <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> on a reference). The collector will call this method if it detects that this object is involved in a reference cycle.</p> </dd>
</dl> <section id="controlling-the-garbage-collector-state"> <h2>Controlling the Garbage Collector State</h2> <p>The C-API provides the following functions for controlling garbage collection runs.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyGC_Collect">
<code>Py_ssize_t PyGC_Collect(void)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Perform a full garbage collection, if the garbage collector is enabled. (Note that <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code>gc.collect()</code></a> runs it unconditionally.)</p> <p>Returns the number of collected + unreachable objects which cannot be collected. If the garbage collector is disabled or already collecting, returns <code>0</code> immediately. Errors during garbage collection are passed to <a class="reference internal" href="../library/sys.html#sys.unraisablehook" title="sys.unraisablehook"><code>sys.unraisablehook</code></a>. This function does not raise exceptions.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyGC_Enable">
<code>int PyGC_Enable(void)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Enable the garbage collector: similar to <a class="reference internal" href="../library/gc.html#gc.enable" title="gc.enable"><code>gc.enable()</code></a>. Returns the previous state, 0 for disabled and 1 for enabled.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyGC_Disable">
<code>int PyGC_Disable(void)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Disable the garbage collector: similar to <a class="reference internal" href="../library/gc.html#gc.disable" title="gc.disable"><code>gc.disable()</code></a>. Returns the previous state, 0 for disabled and 1 for enabled.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyGC_IsEnabled">
<code>int PyGC_IsEnabled(void)</code> </dt> <dd>
<em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Query the state of the garbage collector: similar to <a class="reference internal" href="../library/gc.html#gc.isenabled" title="gc.isenabled"><code>gc.isenabled()</code></a>. Returns the current state, 0 for disabled and 1 for enabled.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div> </dd>
</dl> </section> <section id="querying-garbage-collector-state"> <h2>Querying Garbage Collector State</h2> <p>The C-API provides the following interface for querying information about the garbage collector.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUnstable_GC_VisitObjects">
<code>void PyUnstable_GC_VisitObjects(gcvisitobjects_t callback, void *arg)</code> </dt> <dd>
<div class="unstable-c-api warning admonition"> <em>This is <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">Unstable API</span></a>. It may change without warning in minor releases.</em>
</div> <p>Run supplied <em>callback</em> on all live GC-capable objects. <em>arg</em> is passed through to all invocations of <em>callback</em>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If new objects are (de)allocated by the callback it is undefined if they will be visited.</p> <p>Garbage collection is disabled during operation. Explicitly running a collection in the callback may lead to undefined behaviour e.g. visiting the same objects multiple times or not at all.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> <dl class="c type"> <dt class="sig sig-object c" id="c.gcvisitobjects_t">
<code>typedef int (*gcvisitobjects_t)(PyObject *object, void *arg)</code> </dt> <dd>
<p>Type of the visitor function to be passed to <a class="reference internal" href="#c.PyUnstable_GC_VisitObjects" title="PyUnstable_GC_VisitObjects"><code>PyUnstable_GC_VisitObjects()</code></a>. <em>arg</em> is the same as the <em>arg</em> passed to <code>PyUnstable_GC_VisitObjects</code>. Return <code>0</code> to continue iteration, return <code>1</code> to stop iteration. Other return values are reserved for now so behavior on returning anything else is undefined.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12.</span></p> </div> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/c-api/gcsupport.html" class="_attribution-link">https://docs.python.org/3.12/c-api/gcsupport.html</a>
  </p>
</div>
