 <span id="pyporting-howto"></span><h1>How to port Python 2 Code to Python 3</h1> <dl class="field-list simple"> <dt class="field-odd">author</dt> <dd class="field-odd">
<p>Brett Cannon</p> </dd> </dl> <div class="topic"> <p class="topic-title">Abstract</p> <p>Python 2 reached its official end-of-life at the start of 2020. This means that no new bug reports, fixes, or changes will be made to Python 2 - it’s no longer supported.</p> <p>This guide is intended to provide you with a path to Python 3 for your code, that includes compatibility with Python 2 as a first step.</p> <p>If you are looking to port an extension module instead of pure Python code, please see <a class="reference internal" href="cporting.html#cporting-howto"><span class="std std-ref">Porting Extension Modules to Python 3</span></a>.</p> <p>The archived <a class="reference external" href="https://mail.python.org/pipermail/python-porting/">python-porting</a> mailing list may contain some useful guidance.</p> </div> <section id="the-short-explanation"> <h2>The Short Explanation</h2> <p>To achieve Python 2/3 compatibility in a single code base, the basic steps are:</p> <ol class="arabic simple"> <li>Only worry about supporting Python 2.7</li> <li>Make sure you have good test coverage (<a class="reference external" href="https://pypi.org/project/coverage">coverage.py</a> can help; <code>python -m pip install coverage</code>)</li> <li>Learn the differences between Python 2 and 3</li> <li>Use <a class="reference external" href="https://python-future.org/automatic_conversion.html">Futurize</a> (or <a class="reference external" href="https://python-modernize.readthedocs.io/">Modernize</a>) to update your code (e.g. <code>python -m pip install future</code>)</li> <li>Use <a class="reference external" href="https://pypi.org/project/pylint">Pylint</a> to help make sure you don’t regress on your Python 3 support (<code>python -m pip install pylint</code>)</li> <li>Use <a class="reference external" href="https://pypi.org/project/caniusepython3">caniusepython3</a> to find out which of your dependencies are blocking your use of Python 3 (<code>python -m pip install caniusepython3</code>)</li> <li>Once your dependencies are no longer blocking you, use continuous integration to make sure you stay compatible with Python 2 and 3 (<a class="reference external" href="https://pypi.org/project/tox">tox</a> can help test against multiple versions of Python; <code>python -m pip install tox</code>)</li> <li>Consider using optional <a class="reference internal" href="../glossary.html#term-static-type-checker"><span class="xref std std-term">static type checking</span></a> to make sure your type usage works in both Python 2 and 3 (e.g. use <a class="reference external" href="https://mypy-lang.org/">mypy</a> to check your typing under both Python 2 and Python 3; <code>python -m pip install mypy</code>).</li> </ol> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Note: Using <code>python -m pip install</code> guarantees that the <code>pip</code> you invoke is the one installed for the Python currently in use, whether it be a system-wide <code>pip</code> or one installed within a <a class="reference internal" href="../tutorial/venv.html#tut-venv"><span class="std std-ref">virtual environment</span></a>.</p> </div> </section> <section id="details"> <h2>Details</h2> <p>Even if other factors - say, dependencies over which you have no control - still require you to support Python 2, that does not prevent you taking the step of including Python 3 support.</p> <p>Most changes required to support Python 3 lead to cleaner code using newer practices even in Python 2 code.</p> <section id="different-versions-of-python-2"> <h3>Different versions of Python 2</h3> <p>Ideally, your code should be compatible with Python 2.7, which was the last supported version of Python 2.</p> <p>Some of the tools mentioned in this guide will not work with Python 2.6.</p> <p>If absolutely necessary, the <a class="reference external" href="https://pypi.org/project/six">six</a> project can help you support Python 2.5 and 3 simultaneously. Do realize, though, that nearly all the projects listed in this guide will not be available to you.</p> <p>If you are able to skip Python 2.5 and older, the required changes to your code will be minimal. At worst you will have to use a function instead of a method in some instances or have to import a function instead of using a built-in one.</p> </section> <section id="make-sure-you-specify-the-proper-version-support-in-your-setup-py-file"> <h3>Make sure you specify the proper version support in your <code>setup.py</code> file</h3> <p>In your <code>setup.py</code> file you should have the proper <a class="reference external" href="https://pypi.org/classifiers">trove classifier</a> specifying what versions of Python you support. As your project does not support Python 3 yet you should at least have <code>Programming Language :: Python :: 2 :: Only</code> specified. Ideally you should also specify each major/minor version of Python that you do support, e.g. <code>Programming Language :: Python :: 2.7</code>.</p> </section> <section id="have-good-test-coverage"> <h3>Have good test coverage</h3> <p>Once you have your code supporting the oldest version of Python 2 you want it to, you will want to make sure your test suite has good coverage. A good rule of thumb is that if you want to be confident enough in your test suite that any failures that appear after having tools rewrite your code are actual bugs in the tools and not in your code. If you want a number to aim for, try to get over 80% coverage (and don’t feel bad if you find it hard to get better than 90% coverage). If you don’t already have a tool to measure test coverage then <a class="reference external" href="https://pypi.org/project/coverage">coverage.py</a> is recommended.</p> </section> <section id="be-aware-of-the-differences-between-python-2-and-3"> <h3>Be aware of the differences between Python 2 and 3</h3> <p>Once you have your code well-tested you are ready to begin porting your code to Python 3! But to fully understand how your code is going to change and what you want to look out for while you code, you will want to learn what changes Python 3 makes in terms of Python 2.</p> <p>Some resources for understanding the differences and their implications for you code:</p> <ul class="simple"> <li>the <a class="reference internal" href="https://docs.python.org/3.12/whatsnew/index.html#whatsnew-index"><span class="std std-ref">“What’s New”</span></a> doc for each release of Python 3</li> <li>the <a class="reference external" href="http://python3porting.com/">Porting to Python 3</a> book (which is free online)</li> <li>the handy <a class="reference external" href="https://python-future.org/compatible_idioms.html">cheat sheet</a> from the Python-Future project.</li> </ul> </section> <section id="update-your-code"> <h3>Update your code</h3> <p>There are tools available that can port your code automatically.</p> <p><a class="reference external" href="https://python-future.org/automatic_conversion.html">Futurize</a> does its best to make Python 3 idioms and practices exist in Python 2, e.g. backporting the <code>bytes</code> type from Python 3 so that you have semantic parity between the major versions of Python. This is the better approach for most cases.</p> <p><a class="reference external" href="https://python-modernize.readthedocs.io/">Modernize</a>, on the other hand, is more conservative and targets a Python 2/3 subset of Python, directly relying on <a class="reference external" href="https://pypi.org/project/six">six</a> to help provide compatibility.</p> <p>A good approach is to run the tool over your test suite first and visually inspect the diff to make sure the transformation is accurate. After you have transformed your test suite and verified that all the tests still pass as expected, then you can transform your application code knowing that any tests which fail is a translation failure.</p> <p>Unfortunately the tools can’t automate everything to make your code work under Python 3, and you will also need to read the tools’ documentation in case some options you need are turned off by default.</p> <p>Key issues to be aware of and check for:</p> <section id="division"> <h4>Division</h4> <p>In Python 3, <code>5 / 2 == 2.5</code> and not <code>2</code> as it was in Python 2; all division between <code>int</code> values result in a <code>float</code>. This change has actually been planned since Python 2.2 which was released in 2002. Since then users have been encouraged to add <code>from __future__ import division</code> to any and all files which use the <code>/</code> and <code>//</code> operators or to be running the interpreter with the <code>-Q</code> flag. If you have not been doing this then you will need to go through your code and do two things:</p> <ol class="arabic simple"> <li>Add <code>from __future__ import division</code> to your files</li> <li>Update any division operator as necessary to either use <code>//</code> to use floor division or continue using <code>/</code> and expect a float</li> </ol> <p>The reason that <code>/</code> isn’t simply translated to <code>//</code> automatically is that if an object defines a <code>__truediv__</code> method but not <code>__floordiv__</code> then your code would begin to fail (e.g. a user-defined class that uses <code>/</code> to signify some operation but not <code>//</code> for the same thing or at all).</p> </section> <section id="text-versus-binary-data"> <h4>Text versus binary data</h4> <p>In Python 2 you could use the <code>str</code> type for both text and binary data. Unfortunately this confluence of two different concepts could lead to brittle code which sometimes worked for either kind of data, sometimes not. It also could lead to confusing APIs if people didn’t explicitly state that something that accepted <code>str</code> accepted either text or binary data instead of one specific type. This complicated the situation especially for anyone supporting multiple languages as APIs wouldn’t bother explicitly supporting <code>unicode</code> when they claimed text data support.</p> <p>Python 3 made text and binary data distinct types that cannot simply be mixed together. For any code that deals only with text or only binary data, this separation doesn’t pose an issue. But for code that has to deal with both, it does mean you might have to now care about when you are using text compared to binary data, which is why this cannot be entirely automated.</p> <p>Decide which APIs take text and which take binary (it is <strong>highly</strong> recommended you don’t design APIs that can take both due to the difficulty of keeping the code working; as stated earlier it is difficult to do well). In Python 2 this means making sure the APIs that take text can work with <code>unicode</code> and those that work with binary data work with the <code>bytes</code> type from Python 3 (which is a subset of <code>str</code> in Python 2 and acts as an alias for <code>bytes</code> type in Python 2). Usually the biggest issue is realizing which methods exist on which types in Python 2 and 3 simultaneously (for text that’s <code>unicode</code> in Python 2 and <code>str</code> in Python 3, for binary that’s <code>str</code>/<code>bytes</code> in Python 2 and <code>bytes</code> in Python 3).</p> <p>The following table lists the <strong>unique</strong> methods of each data type across Python 2 and 3 (e.g., the <code>decode()</code> method is usable on the equivalent binary data type in either Python 2 or 3, but it can’t be used by the textual data type consistently between Python 2 and 3 because <code>str</code> in Python 3 doesn’t have the method). Do note that as of Python 3.5 the <code>__mod__</code> method was added to the bytes type.</p> <table class="docutils align-default">   <tr>
<td><p><strong>Text data</strong></p></td> <td><p><strong>Binary data</strong></p></td> </tr> <tr>
<td><p></p></td> <td><p>decode</p></td> </tr> <tr>
<td><p>encode</p></td> <td></td> </tr> <tr>
<td><p>format</p></td> <td></td> </tr> <tr>
<td><p>isdecimal</p></td> <td></td> </tr> <tr>
<td><p>isnumeric</p></td> <td></td> </tr>  </table> <p>Making the distinction easier to handle can be accomplished by encoding and decoding between binary data and text at the edge of your code. This means that when you receive text in binary data, you should immediately decode it. And if your code needs to send text as binary data then encode it as late as possible. This allows your code to work with only text internally and thus eliminates having to keep track of what type of data you are working with.</p> <p>The next issue is making sure you know whether the string literals in your code represent text or binary data. You should add a <code>b</code> prefix to any literal that presents binary data. For text you should add a <code>u</code> prefix to the text literal. (There is a <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code>__future__</code></a> import to force all unspecified literals to be Unicode, but usage has shown it isn’t as effective as adding a <code>b</code> or <code>u</code> prefix to all literals explicitly)</p> <p>You also need to be careful about opening files. Possibly you have not always bothered to add the <code>b</code> mode when opening a binary file (e.g., <code>rb</code> for binary reading). Under Python 3, binary files and text files are clearly distinct and mutually incompatible; see the <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code>io</code></a> module for details. Therefore, you <strong>must</strong> make a decision of whether a file will be used for binary access (allowing binary data to be read and/or written) or textual access (allowing text data to be read and/or written). You should also use <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code>io.open()</code></a> for opening files instead of the built-in <a class="reference internal" href="../library/functions.html#open" title="open"><code>open()</code></a> function as the <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code>io</code></a> module is consistent from Python 2 to 3 while the built-in <a class="reference internal" href="../library/functions.html#open" title="open"><code>open()</code></a> function is not (in Python 3 it’s actually <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code>io.open()</code></a>). Do not bother with the outdated practice of using <a class="reference internal" href="../library/codecs.html#codecs.open" title="codecs.open"><code>codecs.open()</code></a> as that’s only necessary for keeping compatibility with Python 2.5.</p> <p>The constructors of both <code>str</code> and <code>bytes</code> have different semantics for the same arguments between Python 2 and 3. Passing an integer to <code>bytes</code> in Python 2 will give you the string representation of the integer: <code>bytes(3) == '3'</code>. But in Python 3, an integer argument to <code>bytes</code> will give you a bytes object as long as the integer specified, filled with null bytes: <code>bytes(3) == b'\x00\x00\x00'</code>. A similar worry is necessary when passing a bytes object to <code>str</code>. In Python 2 you just get the bytes object back: <code>str(b'3') == b'3'</code>. But in Python 3 you get the string representation of the bytes object: <code>str(b'3') == "b'3'"</code>.</p> <p>Finally, the indexing of binary data requires careful handling (slicing does <strong>not</strong> require any special handling). In Python 2, <code>b'123'[1] == b'2'</code> while in Python 3 <code>b'123'[1] == 50</code>. Because binary data is simply a collection of binary numbers, Python 3 returns the integer value for the byte you index on. But in Python 2 because <code>bytes == str</code>, indexing returns a one-item slice of bytes. The <a class="reference external" href="https://pypi.org/project/six">six</a> project has a function named <code>six.indexbytes()</code> which will return an integer like in Python 3: <code>six.indexbytes(b'123', 1)</code>.</p> <p>To summarize:</p> <ol class="arabic simple"> <li>Decide which of your APIs take text and which take binary data</li> <li>Make sure that your code that works with text also works with <code>unicode</code> and code for binary data works with <code>bytes</code> in Python 2 (see the table above for what methods you cannot use for each type)</li> <li>Mark all binary literals with a <code>b</code> prefix, textual literals with a <code>u</code> prefix</li> <li>Decode binary data to text as soon as possible, encode text as binary data as late as possible</li> <li>Open files using <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code>io.open()</code></a> and make sure to specify the <code>b</code> mode when appropriate</li> <li>Be careful when indexing into binary data</li> </ol> </section> <section id="use-feature-detection-instead-of-version-detection"> <h4>Use feature detection instead of version detection</h4> <p>Inevitably you will have code that has to choose what to do based on what version of Python is running. The best way to do this is with feature detection of whether the version of Python you’re running under supports what you need. If for some reason that doesn’t work then you should make the version check be against Python 2 and not Python 3. To help explain this, let’s look at an example.</p> <p>Let’s pretend that you need access to a feature of <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> that is available in Python’s standard library since Python 3.3 and available for Python 2 through <a class="reference external" href="https://pypi.org/project/importlib2">importlib2</a> on PyPI. You might be tempted to write code to access e.g. the <a class="reference internal" href="../library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code>importlib.abc</code></a> module by doing the following:</p> <pre data-language="python">import sys

if sys.version_info[0] == 3:
    from importlib import abc
else:
    from importlib2 import abc
</pre> <p>The problem with this code is what happens when Python 4 comes out? It would be better to treat Python 2 as the exceptional case instead of Python 3 and assume that future Python versions will be more compatible with Python 3 than Python 2:</p> <pre data-language="python">import sys

if sys.version_info[0] &gt; 2:
    from importlib import abc
else:
    from importlib2 import abc
</pre> <p>The best solution, though, is to do no version detection at all and instead rely on feature detection. That avoids any potential issues of getting the version detection wrong and helps keep you future-compatible:</p> <pre data-language="python">try:
    from importlib import abc
except ImportError:
    from importlib2 import abc
</pre> </section> </section> <section id="prevent-compatibility-regressions"> <h3>Prevent compatibility regressions</h3> <p>Once you have fully translated your code to be compatible with Python 3, you will want to make sure your code doesn’t regress and stop working under Python 3. This is especially true if you have a dependency which is blocking you from actually running under Python 3 at the moment.</p> <p>To help with staying compatible, any new modules you create should have at least the following block of code at the top of it:</p> <pre data-language="python">from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
</pre> <p>You can also run Python 2 with the <code>-3</code> flag to be warned about various compatibility issues your code triggers during execution. If you turn warnings into errors with <code>-Werror</code> then you can make sure that you don’t accidentally miss a warning.</p> <p>You can also use the <a class="reference external" href="https://pypi.org/project/pylint">Pylint</a> project and its <code>--py3k</code> flag to lint your code to receive warnings when your code begins to deviate from Python 3 compatibility. This also prevents you from having to run <a class="reference external" href="https://python-modernize.readthedocs.io/">Modernize</a> or <a class="reference external" href="https://python-future.org/automatic_conversion.html">Futurize</a> over your code regularly to catch compatibility regressions. This does require you only support Python 2.7 and Python 3.4 or newer as that is Pylint’s minimum Python version support.</p> </section> <section id="check-which-dependencies-block-your-transition"> <h3>Check which dependencies block your transition</h3> <p><strong>After</strong> you have made your code compatible with Python 3 you should begin to care about whether your dependencies have also been ported. The <a class="reference external" href="https://pypi.org/project/caniusepython3">caniusepython3</a> project was created to help you determine which projects – directly or indirectly – are blocking you from supporting Python 3. There is both a command-line tool as well as a web interface at <a class="reference external" href="https://caniusepython3.com">https://caniusepython3.com</a>.</p> <p>The project also provides code which you can integrate into your test suite so that you will have a failing test when you no longer have dependencies blocking you from using Python 3. This allows you to avoid having to manually check your dependencies and to be notified quickly when you can start running on Python 3.</p> </section> <section id="update-your-setup-py-file-to-denote-python-3-compatibility"> <h3>Update your <code>setup.py</code> file to denote Python 3 compatibility</h3> <p>Once your code works under Python 3, you should update the classifiers in your <code>setup.py</code> to contain <code>Programming Language :: Python :: 3</code> and to not specify sole Python 2 support. This will tell anyone using your code that you support Python 2 <strong>and</strong> 3. Ideally you will also want to add classifiers for each major/minor version of Python you now support.</p> </section> <section id="use-continuous-integration-to-stay-compatible"> <h3>Use continuous integration to stay compatible</h3> <p>Once you are able to fully run under Python 3 you will want to make sure your code always works under both Python 2 and 3. Probably the best tool for running your tests under multiple Python interpreters is <a class="reference external" href="https://pypi.org/project/tox">tox</a>. You can then integrate tox with your continuous integration system so that you never accidentally break Python 2 or 3 support.</p> <p>You may also want to use the <code>-bb</code> flag with the Python 3 interpreter to trigger an exception when you are comparing bytes to strings or bytes to an int (the latter is available starting in Python 3.5). By default type-differing comparisons simply return <code>False</code>, but if you made a mistake in your separation of text/binary data handling or indexing on bytes you wouldn’t easily find the mistake. This flag will raise an exception when these kinds of comparisons occur, making the mistake much easier to track down.</p> </section> <section id="consider-using-optional-static-type-checking"> <h3>Consider using optional static type checking</h3> <p>Another way to help port your code is to use a <a class="reference internal" href="../glossary.html#term-static-type-checker"><span class="xref std std-term">static type checker</span></a> like <a class="reference external" href="https://mypy-lang.org/">mypy</a> or <a class="reference external" href="https://github.com/google/pytype">pytype</a> on your code. These tools can be used to analyze your code as if it’s being run under Python 2, then you can run the tool a second time as if your code is running under Python 3. By running a static type checker twice like this you can discover if you’re e.g. misusing binary data type in one version of Python compared to another. If you add optional type hints to your code you can also explicitly state whether your APIs use textual or binary data, helping to make sure everything functions as expected in both versions of Python.</p> </section> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/howto/pyporting.html" class="_attribution-link">https://docs.python.org/3.12/howto/pyporting.html</a>
  </p>
</div>
