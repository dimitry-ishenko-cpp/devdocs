 <span id="annotations-howto"></span><h1>Annotations Best Practices</h1> <dl class="field-list simple"> <dt class="field-odd">author</dt> <dd class="field-odd">
<p>Larry Hastings</p> </dd> </dl> <div class="topic"> <p class="topic-title">Abstract</p> <p>This document is designed to encapsulate the best practices for working with annotations dicts. If you write Python code that examines <code>__annotations__</code> on Python objects, we encourage you to follow the guidelines described below.</p> <p>The document is organized into four sections: best practices for accessing the annotations of an object in Python versions 3.10 and newer, best practices for accessing the annotations of an object in Python versions 3.9 and older, other best practices for <code>__annotations__</code> that apply to any Python version, and quirks of <code>__annotations__</code>.</p> <p>Note that this document is specifically about working with <code>__annotations__</code>, not uses <em>for</em> annotations. If you’re looking for information on how to use “type hints” in your code, please see the <a class="reference internal" href="../library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code>typing</code></a> module.</p> </div> <section id="accessing-the-annotations-dict-of-an-object-in-python-3-10-and-newer"> <h2>Accessing The Annotations Dict Of An Object In Python 3.10 And Newer</h2> <p>Python 3.10 adds a new function to the standard library: <a class="reference internal" href="../library/inspect.html#inspect.get_annotations" title="inspect.get_annotations"><code>inspect.get_annotations()</code></a>. In Python versions 3.10 and newer, calling this function is the best practice for accessing the annotations dict of any object that supports annotations. This function can also “un-stringize” stringized annotations for you.</p> <p>If for some reason <a class="reference internal" href="../library/inspect.html#inspect.get_annotations" title="inspect.get_annotations"><code>inspect.get_annotations()</code></a> isn’t viable for your use case, you may access the <code>__annotations__</code> data member manually. Best practice for this changed in Python 3.10 as well: as of Python 3.10, <code>o.__annotations__</code> is guaranteed to <em>always</em> work on Python functions, classes, and modules. If you’re certain the object you’re examining is one of these three <em>specific</em> objects, you may simply use <code>o.__annotations__</code> to get at the object’s annotations dict.</p> <p>However, other types of callables–for example, callables created by <a class="reference internal" href="../library/functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a>–may not have an <code>__annotations__</code> attribute defined. When accessing the <code>__annotations__</code> of a possibly unknown object, best practice in Python versions 3.10 and newer is to call <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code>getattr()</code></a> with three arguments, for example <code>getattr(o, '__annotations__', None)</code>.</p> <p>Before Python 3.10, accessing <code>__annotations__</code> on a class that defines no annotations but that has a parent class with annotations would return the parent’s <code>__annotations__</code>. In Python 3.10 and newer, the child class’s annotations will be an empty dict instead.</p> </section> <section id="accessing-the-annotations-dict-of-an-object-in-python-3-9-and-older"> <h2>Accessing The Annotations Dict Of An Object In Python 3.9 And Older</h2> <p>In Python 3.9 and older, accessing the annotations dict of an object is much more complicated than in newer versions. The problem is a design flaw in these older versions of Python, specifically to do with class annotations.</p> <p>Best practice for accessing the annotations dict of other objects–functions, other callables, and modules–is the same as best practice for 3.10, assuming you aren’t calling <a class="reference internal" href="../library/inspect.html#inspect.get_annotations" title="inspect.get_annotations"><code>inspect.get_annotations()</code></a>: you should use three-argument <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code>getattr()</code></a> to access the object’s <code>__annotations__</code> attribute.</p> <p>Unfortunately, this isn’t best practice for classes. The problem is that, since <code>__annotations__</code> is optional on classes, and because classes can inherit attributes from their base classes, accessing the <code>__annotations__</code> attribute of a class may inadvertently return the annotations dict of a <em>base class.</em> As an example:</p> <pre data-language="python">class Base:
    a: int = 3
    b: str = 'abc'

class Derived(Base):
    pass

print(Derived.__annotations__)
</pre> <p>This will print the annotations dict from <code>Base</code>, not <code>Derived</code>.</p> <p>Your code will have to have a separate code path if the object you’re examining is a class (<code>isinstance(o, type)</code>). In that case, best practice relies on an implementation detail of Python 3.9 and before: if a class has annotations defined, they are stored in the class’s <code>__dict__</code> dictionary. Since the class may or may not have annotations defined, best practice is to call the <code>get</code> method on the class dict.</p> <p>To put it all together, here is some sample code that safely accesses the <code>__annotations__</code> attribute on an arbitrary object in Python 3.9 and before:</p> <pre data-language="python">if isinstance(o, type):
    ann = o.__dict__.get('__annotations__', None)
else:
    ann = getattr(o, '__annotations__', None)
</pre> <p>After running this code, <code>ann</code> should be either a dictionary or <code>None</code>. You’re encouraged to double-check the type of <code>ann</code> using <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> before further examination.</p> <p>Note that some exotic or malformed type objects may not have a <code>__dict__</code> attribute, so for extra safety you may also wish to use <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code>getattr()</code></a> to access <code>__dict__</code>.</p> </section> <section id="manually-un-stringizing-stringized-annotations"> <h2>Manually Un-Stringizing Stringized Annotations</h2> <p>In situations where some annotations may be “stringized”, and you wish to evaluate those strings to produce the Python values they represent, it really is best to call <a class="reference internal" href="../library/inspect.html#inspect.get_annotations" title="inspect.get_annotations"><code>inspect.get_annotations()</code></a> to do this work for you.</p> <p>If you’re using Python 3.9 or older, or if for some reason you can’t use <a class="reference internal" href="../library/inspect.html#inspect.get_annotations" title="inspect.get_annotations"><code>inspect.get_annotations()</code></a>, you’ll need to duplicate its logic. You’re encouraged to examine the implementation of <a class="reference internal" href="../library/inspect.html#inspect.get_annotations" title="inspect.get_annotations"><code>inspect.get_annotations()</code></a> in the current Python version and follow a similar approach.</p> <p>In a nutshell, if you wish to evaluate a stringized annotation on an arbitrary object <code>o</code>:</p> <ul class="simple"> <li>If <code>o</code> is a module, use <code>o.__dict__</code> as the <code>globals</code> when calling <a class="reference internal" href="../library/functions.html#eval" title="eval"><code>eval()</code></a>.</li> <li>If <code>o</code> is a class, use <code>sys.modules[o.__module__].__dict__</code> as the <code>globals</code>, and <code>dict(vars(o))</code> as the <code>locals</code>, when calling <a class="reference internal" href="../library/functions.html#eval" title="eval"><code>eval()</code></a>.</li> <li>If <code>o</code> is a wrapped callable using <a class="reference internal" href="../library/functools.html#functools.update_wrapper" title="functools.update_wrapper"><code>functools.update_wrapper()</code></a>, <a class="reference internal" href="../library/functools.html#functools.wraps" title="functools.wraps"><code>functools.wraps()</code></a>, or <a class="reference internal" href="../library/functools.html#functools.partial" title="functools.partial"><code>functools.partial()</code></a>, iteratively unwrap it by accessing either <code>o.__wrapped__</code> or <code>o.func</code> as appropriate, until you have found the root unwrapped function.</li> <li>If <code>o</code> is a callable (but not a class), use <a class="reference internal" href="../reference/datamodel.html#function.__globals__" title="function.__globals__"><code>o.__globals__</code></a> as the globals when calling <a class="reference internal" href="../library/functions.html#eval" title="eval"><code>eval()</code></a>.</li> </ul> <p>However, not all string values used as annotations can be successfully turned into Python values by <a class="reference internal" href="../library/functions.html#eval" title="eval"><code>eval()</code></a>. String values could theoretically contain any valid string, and in practice there are valid use cases for type hints that require annotating with string values that specifically <em>can’t</em> be evaluated. For example:</p> <ul class="simple"> <li>
<span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0604/"><strong>PEP 604</strong></a> union types using <code>|</code>, before support for this was added to Python 3.10.</li> <li>Definitions that aren’t needed at runtime, only imported when <a class="reference internal" href="../library/typing.html#typing.TYPE_CHECKING" title="typing.TYPE_CHECKING"><code>typing.TYPE_CHECKING</code></a> is true.</li> </ul> <p>If <a class="reference internal" href="../library/functions.html#eval" title="eval"><code>eval()</code></a> attempts to evaluate such values, it will fail and raise an exception. So, when designing a library API that works with annotations, it’s recommended to only attempt to evaluate string values when explicitly requested to by the caller.</p> </section> <section id="best-practices-for-annotations-in-any-python-version"> <h2>Best Practices For <code>__annotations__</code> In Any Python Version</h2> <ul class="simple"> <li>You should avoid assigning to the <code>__annotations__</code> member of objects directly. Let Python manage setting <code>__annotations__</code>.</li> <li>If you do assign directly to the <code>__annotations__</code> member of an object, you should always set it to a <code>dict</code> object.</li> <li>If you directly access the <code>__annotations__</code> member of an object, you should ensure that it’s a dictionary before attempting to examine its contents.</li> <li>You should avoid modifying <code>__annotations__</code> dicts.</li> <li>You should avoid deleting the <code>__annotations__</code> attribute of an object.</li> </ul> </section> <section id="annotations-quirks"> <h2>
<code>__annotations__</code> Quirks</h2> <p>In all versions of Python 3, function objects lazy-create an annotations dict if no annotations are defined on that object. You can delete the <code>__annotations__</code> attribute using <code>del fn.__annotations__</code>, but if you then access <code>fn.__annotations__</code> the object will create a new empty dict that it will store and return as its annotations. Deleting the annotations on a function before it has lazily created its annotations dict will throw an <code>AttributeError</code>; using <code>del fn.__annotations__</code> twice in a row is guaranteed to always throw an <code>AttributeError</code>.</p> <p>Everything in the above paragraph also applies to class and module objects in Python 3.10 and newer.</p> <p>In all versions of Python 3, you can set <code>__annotations__</code> on a function object to <code>None</code>. However, subsequently accessing the annotations on that object using <code>fn.__annotations__</code> will lazy-create an empty dictionary as per the first paragraph of this section. This is <em>not</em> true of modules and classes, in any Python version; those objects permit setting <code>__annotations__</code> to any Python value, and will retain whatever value is set.</p> <p>If Python stringizes your annotations for you (using <code>from __future__ import annotations</code>), and you specify a string as an annotation, the string will itself be quoted. In effect the annotation is quoted <em>twice.</em> For example:</p> <pre data-language="python">from __future__ import annotations
def foo(a: "str"): pass

print(foo.__annotations__)
</pre> <p>This prints <code>{'a': "'str'"}</code>. This shouldn’t really be considered a “quirk”; it’s mentioned here simply because it might be surprising.</p> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/howto/annotations.html" class="_attribution-link">https://docs.python.org/3.12/howto/annotations.html</a>
  </p>
</div>
