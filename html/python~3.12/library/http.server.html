 <span id="http-server-http-servers"></span><h1>http.server — HTTP servers</h1> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/http/server.py">Lib/http/server.py</a></p>  <p>This module defines classes for implementing HTTP servers.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#module-http.server" title="http.server: HTTP server and request handlers."><code>http.server</code></a> is not recommended for production. It only implements <a class="reference internal" href="#http-server-security"><span class="std std-ref">basic security checks</span></a>.</p> </div> <div class="availability docutils container"> <p><a class="reference internal" href="https://docs.python.org/3.12/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: not Emscripten, not WASI.</p> <p>This module does not work or is not available on WebAssembly platforms <code>wasm32-emscripten</code> and <code>wasm32-wasi</code>. See <a class="reference internal" href="https://docs.python.org/3.12/library/intro.html#wasm-availability"><span class="std std-ref">WebAssembly platforms</span></a> for more information.</p> </div> <p>One class, <a class="reference internal" href="#http.server.HTTPServer" title="http.server.HTTPServer"><code>HTTPServer</code></a>, is a <a class="reference internal" href="socketserver.html#socketserver.TCPServer" title="socketserver.TCPServer"><code>socketserver.TCPServer</code></a> subclass. It creates and listens at the HTTP socket, dispatching the requests to a handler. Code to create and run the server looks like this:</p> <pre data-language="python">def run(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler):
    server_address = ('', 8000)
    httpd = server_class(server_address, handler_class)
    httpd.serve_forever()
</pre> <dl class="py class"> <dt class="sig sig-object py" id="http.server.HTTPServer">
<code>class http.server.HTTPServer(server_address, RequestHandlerClass)</code> </dt> <dd>
<p>This class builds on the <a class="reference internal" href="socketserver.html#socketserver.TCPServer" title="socketserver.TCPServer"><code>TCPServer</code></a> class by storing the server address as instance variables named <code>server_name</code> and <code>server_port</code>. The server is accessible by the handler, typically through the handler’s <code>server</code> instance variable.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="http.server.ThreadingHTTPServer">
<code>class http.server.ThreadingHTTPServer(server_address, RequestHandlerClass)</code> </dt> <dd>
<p>This class is identical to HTTPServer but uses threads to handle requests by using the <a class="reference internal" href="socketserver.html#socketserver.ThreadingMixIn" title="socketserver.ThreadingMixIn"><code>ThreadingMixIn</code></a>. This is useful to handle web browsers pre-opening sockets, on which <a class="reference internal" href="#http.server.HTTPServer" title="http.server.HTTPServer"><code>HTTPServer</code></a> would wait indefinitely.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7.</span></p> </div> </dd>
</dl> <p>The <a class="reference internal" href="#http.server.HTTPServer" title="http.server.HTTPServer"><code>HTTPServer</code></a> and <a class="reference internal" href="#http.server.ThreadingHTTPServer" title="http.server.ThreadingHTTPServer"><code>ThreadingHTTPServer</code></a> must be given a <em>RequestHandlerClass</em> on instantiation, of which this module provides three different variants:</p> <dl class="py class"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler">
<code>class http.server.BaseHTTPRequestHandler(request, client_address, server)</code> </dt> <dd>
<p>This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; it must be subclassed to handle each request method (e.g. GET or POST). <a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code>BaseHTTPRequestHandler</code></a> provides a number of class and instance variables, and methods for use by subclasses.</p> <p>The handler will parse the request and the headers, then call a method specific to the request type. The method name is constructed from the request. For example, for the request method <code>SPAM</code>, the <code>do_SPAM()</code> method will be called with no arguments. All of the relevant information is stored in instance variables of the handler. Subclasses should not need to override or extend the <code>__init__()</code> method.</p> <p><a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code>BaseHTTPRequestHandler</code></a> has the following instance variables:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.client_address">
<code>client_address</code> </dt> <dd>
<p>Contains a tuple of the form <code>(host, port)</code> referring to the client’s address.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.server">
<code>server</code> </dt> <dd>
<p>Contains the server instance.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.close_connection">
<code>close_connection</code> </dt> <dd>
<p>Boolean that should be set before <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.handle_one_request" title="http.server.BaseHTTPRequestHandler.handle_one_request"><code>handle_one_request()</code></a> returns, indicating if another request may be expected, or if the connection should be shut down.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.requestline">
<code>requestline</code> </dt> <dd>
<p>Contains the string representation of the HTTP request line. The terminating CRLF is stripped. This attribute should be set by <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.handle_one_request" title="http.server.BaseHTTPRequestHandler.handle_one_request"><code>handle_one_request()</code></a>. If no valid request line was processed, it should be set to the empty string.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.command">
<code>command</code> </dt> <dd>
<p>Contains the command (request type). For example, <code>'GET'</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.path">
<code>path</code> </dt> <dd>
<p>Contains the request path. If query component of the URL is present, then <code>path</code> includes the query. Using the terminology of <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a>, <code>path</code> here includes <code>hier-part</code> and the <code>query</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.request_version">
<code>request_version</code> </dt> <dd>
<p>Contains the version string from the request. For example, <code>'HTTP/1.0'</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.headers">
<code>headers</code> </dt> <dd>
<p>Holds an instance of the class specified by the <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.MessageClass" title="http.server.BaseHTTPRequestHandler.MessageClass"><code>MessageClass</code></a> class variable. This instance parses and manages the headers in the HTTP request. The <a class="reference internal" href="http.client#http.client.parse_headers" title="http.client.parse_headers"><code>parse_headers()</code></a> function from <a class="reference internal" href="http.client#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code>http.client</code></a> is used to parse the headers and it requires that the HTTP request provide a valid <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2822.html"><strong>RFC 2822</strong></a> style header.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.rfile">
<code>rfile</code> </dt> <dd>
<p>An <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code>io.BufferedIOBase</code></a> input stream, ready to read from the start of the optional input data.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.wfile">
<code>wfile</code> </dt> <dd>
<p>Contains the output stream for writing a response back to the client. Proper adherence to the HTTP protocol must be used when writing to this stream in order to achieve successful interoperation with HTTP clients.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>This is an <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code>io.BufferedIOBase</code></a> stream.</p> </div> </dd>
</dl> <p><a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code>BaseHTTPRequestHandler</code></a> has the following attributes:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.server_version">
<code>server_version</code> </dt> <dd>
<p>Specifies the server software version. You may want to override this. The format is multiple whitespace-separated strings, where each string is of the form name[/version]. For example, <code>'BaseHTTP/0.2'</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.sys_version">
<code>sys_version</code> </dt> <dd>
<p>Contains the Python system version, in a form usable by the <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.version_string" title="http.server.BaseHTTPRequestHandler.version_string"><code>version_string</code></a> method and the <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.server_version" title="http.server.BaseHTTPRequestHandler.server_version"><code>server_version</code></a> class variable. For example, <code>'Python/1.4'</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.error_message_format">
<code>error_message_format</code> </dt> <dd>
<p>Specifies a format string that should be used by <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_error" title="http.server.BaseHTTPRequestHandler.send_error"><code>send_error()</code></a> method for building an error response to the client. The string is filled by default with variables from <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.responses" title="http.server.BaseHTTPRequestHandler.responses"><code>responses</code></a> based on the status code that passed to <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_error" title="http.server.BaseHTTPRequestHandler.send_error"><code>send_error()</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.error_content_type">
<code>error_content_type</code> </dt> <dd>
<p>Specifies the Content-Type HTTP header of error responses sent to the client. The default value is <code>'text/html'</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.protocol_version">
<code>protocol_version</code> </dt> <dd>
<p>Specifies the HTTP version to which the server is conformant. It is sent in responses to let the client know the server’s communication capabilities for future requests. If set to <code>'HTTP/1.1'</code>, the server will permit HTTP persistent connections; however, your server <em>must</em> then include an accurate <code>Content-Length</code> header (using <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_header" title="http.server.BaseHTTPRequestHandler.send_header"><code>send_header()</code></a>) in all of its responses to clients. For backwards compatibility, the setting defaults to <code>'HTTP/1.0'</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.MessageClass">
<code>MessageClass</code> </dt> <dd>
<p>Specifies an <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code>email.message.Message</code></a>-like class to parse HTTP headers. Typically, this is not overridden, and it defaults to <code>http.client.HTTPMessage</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.responses">
<code>responses</code> </dt> <dd>
<p>This attribute contains a mapping of error code integers to two-element tuples containing a short and long message. For example, <code>{code: (shortmessage,
longmessage)}</code>. The <em>shortmessage</em> is usually used as the <em>message</em> key in an error response, and <em>longmessage</em> as the <em>explain</em> key. It is used by <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_response_only" title="http.server.BaseHTTPRequestHandler.send_response_only"><code>send_response_only()</code></a> and <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_error" title="http.server.BaseHTTPRequestHandler.send_error"><code>send_error()</code></a> methods.</p> </dd>
</dl> <p>A <a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code>BaseHTTPRequestHandler</code></a> instance has the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.handle">
<code>handle()</code> </dt> <dd>
<p>Calls <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.handle_one_request" title="http.server.BaseHTTPRequestHandler.handle_one_request"><code>handle_one_request()</code></a> once (or, if persistent connections are enabled, multiple times) to handle incoming HTTP requests. You should never need to override it; instead, implement appropriate <code>do_*()</code> methods.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.handle_one_request">
<code>handle_one_request()</code> </dt> <dd>
<p>This method will parse and dispatch the request to the appropriate <code>do_*()</code> method. You should never need to override it.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.handle_expect_100">
<code>handle_expect_100()</code> </dt> <dd>
<p>When an HTTP/1.1 conformant server receives an <code>Expect: 100-continue</code> request header it responds back with a <code>100 Continue</code> followed by <code>200
OK</code> headers. This method can be overridden to raise an error if the server does not want the client to continue. For e.g. server can choose to send <code>417
Expectation Failed</code> as a response header and <code>return False</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.send_error">
<code>send_error(code, message=None, explain=None)</code> </dt> <dd>
<p>Sends and logs a complete error reply to the client. The numeric <em>code</em> specifies the HTTP error code, with <em>message</em> as an optional, short, human readable description of the error. The <em>explain</em> argument can be used to provide more detailed information about the error; it will be formatted using the <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.error_message_format" title="http.server.BaseHTTPRequestHandler.error_message_format"><code>error_message_format</code></a> attribute and emitted, after a complete set of headers, as the response body. The <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.responses" title="http.server.BaseHTTPRequestHandler.responses"><code>responses</code></a> attribute holds the default values for <em>message</em> and <em>explain</em> that will be used if no value is provided; for unknown codes the default value for both is the string <code>???</code>. The body will be empty if the method is HEAD or the response code is one of the following: <code>1<em>xx</em></code>, <code>204 No Content</code>, <code>205 Reset Content</code>, <code>304 Not Modified</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The error response includes a Content-Length header. Added the <em>explain</em> argument.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.send_response">
<code>send_response(code, message=None)</code> </dt> <dd>
<p>Adds a response header to the headers buffer and logs the accepted request. The HTTP response line is written to the internal buffer, followed by <em>Server</em> and <em>Date</em> headers. The values for these two headers are picked up from the <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.version_string" title="http.server.BaseHTTPRequestHandler.version_string"><code>version_string()</code></a> and <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.date_time_string" title="http.server.BaseHTTPRequestHandler.date_time_string"><code>date_time_string()</code></a> methods, respectively. If the server does not intend to send any other headers using the <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_header" title="http.server.BaseHTTPRequestHandler.send_header"><code>send_header()</code></a> method, then <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_response" title="http.server.BaseHTTPRequestHandler.send_response"><code>send_response()</code></a> should be followed by an <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.end_headers" title="http.server.BaseHTTPRequestHandler.end_headers"><code>end_headers()</code></a> call.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Headers are stored to an internal buffer and <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.end_headers" title="http.server.BaseHTTPRequestHandler.end_headers"><code>end_headers()</code></a> needs to be called explicitly.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.send_header">
<code>send_header(keyword, value)</code> </dt> <dd>
<p>Adds the HTTP header to an internal buffer which will be written to the output stream when either <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.end_headers" title="http.server.BaseHTTPRequestHandler.end_headers"><code>end_headers()</code></a> or <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.flush_headers" title="http.server.BaseHTTPRequestHandler.flush_headers"><code>flush_headers()</code></a> is invoked. <em>keyword</em> should specify the header keyword, with <em>value</em> specifying its value. Note that, after the send_header calls are done, <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.end_headers" title="http.server.BaseHTTPRequestHandler.end_headers"><code>end_headers()</code></a> MUST BE called in order to complete the operation.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Headers are stored in an internal buffer.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.send_response_only">
<code>send_response_only(code, message=None)</code> </dt> <dd>
<p>Sends the response header only, used for the purposes when <code>100
Continue</code> response is sent by the server to the client. The headers not buffered and sent directly the output stream.If the <em>message</em> is not specified, the HTTP message corresponding the response <em>code</em> is sent.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.end_headers">
<code>end_headers()</code> </dt> <dd>
<p>Adds a blank line (indicating the end of the HTTP headers in the response) to the headers buffer and calls <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.flush_headers" title="http.server.BaseHTTPRequestHandler.flush_headers"><code>flush_headers()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>The buffered headers are written to the output stream.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.flush_headers">
<code>flush_headers()</code> </dt> <dd>
<p>Finally send the headers to the output stream and flush the internal headers buffer.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.log_request">
<code>log_request(code='-', size='-')</code> </dt> <dd>
<p>Logs an accepted (successful) request. <em>code</em> should specify the numeric HTTP code associated with the response. If a size of the response is available, then it should be passed as the <em>size</em> parameter.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.log_error">
<code>log_error(...)</code> </dt> <dd>
<p>Logs an error when a request cannot be fulfilled. By default, it passes the message to <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.log_message" title="http.server.BaseHTTPRequestHandler.log_message"><code>log_message()</code></a>, so it takes the same arguments (<em>format</em> and additional values).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.log_message">
<code>log_message(format, ...)</code> </dt> <dd>
<p>Logs an arbitrary message to <code>sys.stderr</code>. This is typically overridden to create custom error logging mechanisms. The <em>format</em> argument is a standard printf-style format string, where the additional arguments to <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.log_message" title="http.server.BaseHTTPRequestHandler.log_message"><code>log_message()</code></a> are applied as inputs to the formatting. The client ip address and current date and time are prefixed to every message logged.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.version_string">
<code>version_string()</code> </dt> <dd>
<p>Returns the server software’s version string. This is a combination of the <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.server_version" title="http.server.BaseHTTPRequestHandler.server_version"><code>server_version</code></a> and <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.sys_version" title="http.server.BaseHTTPRequestHandler.sys_version"><code>sys_version</code></a> attributes.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.date_time_string">
<code>date_time_string(timestamp=None)</code> </dt> <dd>
<p>Returns the date and time given by <em>timestamp</em> (which must be <code>None</code> or in the format returned by <a class="reference internal" href="time.html#time.time" title="time.time"><code>time.time()</code></a>), formatted for a message header. If <em>timestamp</em> is omitted, it uses the current date and time.</p> <p>The result looks like <code>'Sun, 06 Nov 1994 08:49:37 GMT'</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.log_date_time_string">
<code>log_date_time_string()</code> </dt> <dd>
<p>Returns the current date and time, formatted for logging.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.BaseHTTPRequestHandler.address_string">
<code>address_string()</code> </dt> <dd>
<p>Returns the client address.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Previously, a name lookup was performed. To avoid name resolution delays, it now always returns the IP address.</p> </div> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="http.server.SimpleHTTPRequestHandler">
<code>class http.server.SimpleHTTPRequestHandler(request, client_address, server, directory=None)</code> </dt> <dd>
<p>This class serves files from the directory <em>directory</em> and below, or the current directory if <em>directory</em> is not provided, directly mapping the directory structure to HTTP requests.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7: </span>The <em>directory</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>The <em>directory</em> parameter accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> <p>A lot of the work, such as parsing the request, is done by the base class <a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code>BaseHTTPRequestHandler</code></a>. This class implements the <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler.do_GET" title="http.server.SimpleHTTPRequestHandler.do_GET"><code>do_GET()</code></a> and <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler.do_HEAD" title="http.server.SimpleHTTPRequestHandler.do_HEAD"><code>do_HEAD()</code></a> functions.</p> <p>The following are defined as class-level attributes of <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler" title="http.server.SimpleHTTPRequestHandler"><code>SimpleHTTPRequestHandler</code></a>:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.SimpleHTTPRequestHandler.server_version">
<code>server_version</code> </dt> <dd>
<p>This will be <code>"SimpleHTTP/" + __version__</code>, where <code>__version__</code> is defined at the module level.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.SimpleHTTPRequestHandler.extensions_map">
<code>extensions_map</code> </dt> <dd>
<p>A dictionary mapping suffixes into MIME types, contains custom overrides for the default system mappings. The mapping is used case-insensitively, and so should contain only lower-cased keys.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>This dictionary is no longer filled with the default system mappings, but only contains overrides.</p> </div> </dd>
</dl> <p>The <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler" title="http.server.SimpleHTTPRequestHandler"><code>SimpleHTTPRequestHandler</code></a> class defines the following methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="http.server.SimpleHTTPRequestHandler.do_HEAD">
<code>do_HEAD()</code> </dt> <dd>
<p>This method serves the <code>'HEAD'</code> request type: it sends the headers it would send for the equivalent <code>GET</code> request. See the <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler.do_GET" title="http.server.SimpleHTTPRequestHandler.do_GET"><code>do_GET()</code></a> method for a more complete explanation of the possible headers.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="http.server.SimpleHTTPRequestHandler.do_GET">
<code>do_GET()</code> </dt> <dd>
<p>The request is mapped to a local file by interpreting the request as a path relative to the current working directory.</p> <p>If the request was mapped to a directory, the directory is checked for a file named <code>index.html</code> or <code>index.htm</code> (in that order). If found, the file’s contents are returned; otherwise a directory listing is generated by calling the <code>list_directory()</code> method. This method uses <a class="reference internal" href="os.html#os.listdir" title="os.listdir"><code>os.listdir()</code></a> to scan the directory, and returns a <code>404</code> error response if the <a class="reference internal" href="os.html#os.listdir" title="os.listdir"><code>listdir()</code></a> fails.</p> <p>If the request was mapped to a file, it is opened. Any <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code>OSError</code></a> exception in opening the requested file is mapped to a <code>404</code>, <code>'File not found'</code> error. If there was a <code>'If-Modified-Since'</code> header in the request, and the file was not modified after this time, a <code>304</code>, <code>'Not Modified'</code> response is sent. Otherwise, the content type is guessed by calling the <code>guess_type()</code> method, which in turn uses the <em>extensions_map</em> variable, and the file contents are returned.</p> <p>A <code>'Content-type:'</code> header with the guessed content type is output, followed by a <code>'Content-Length:'</code> header with the file’s size and a <code>'Last-Modified:'</code> header with the file’s modification time.</p> <p>Then follows a blank line signifying the end of the headers, and then the contents of the file are output. If the file’s MIME type starts with <code>text/</code> the file is opened in text mode; otherwise binary mode is used.</p> <p>For example usage, see the implementation of the <code>test</code> function in <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/http/server.py">Lib/http/server.py</a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Support of the <code>'If-Modified-Since'</code> header.</p> </div> </dd>
</dl> </dd>
</dl> <p>The <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler" title="http.server.SimpleHTTPRequestHandler"><code>SimpleHTTPRequestHandler</code></a> class can be used in the following manner in order to create a very basic webserver serving files relative to the current directory:</p> <pre data-language="python">import http.server
import socketserver

PORT = 8000

Handler = http.server.SimpleHTTPRequestHandler

with socketserver.TCPServer(("", PORT), Handler) as httpd:
    print("serving at port", PORT)
    httpd.serve_forever()
</pre> <p><a class="reference internal" href="#http.server.SimpleHTTPRequestHandler" title="http.server.SimpleHTTPRequestHandler"><code>SimpleHTTPRequestHandler</code></a> can also be subclassed to enhance behavior, such as using different index file names by overriding the class attribute <code>index_pages</code>.</p> <p id="http-server-cli"><a class="reference internal" href="#module-http.server" title="http.server: HTTP server and request handlers."><code>http.server</code></a> can also be invoked directly using the <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code>-m</code></a> switch of the interpreter. Similar to the previous example, this serves files relative to the current directory:</p> <pre data-language="python">python -m http.server
</pre> <p>The server listens to port 8000 by default. The default can be overridden by passing the desired port number as an argument:</p> <pre data-language="python">python -m http.server 9000
</pre> <p>By default, the server binds itself to all interfaces. The option <code>-b/--bind</code> specifies a specific address to which it should bind. Both IPv4 and IPv6 addresses are supported. For example, the following command causes the server to bind to localhost only:</p> <pre data-language="python">python -m http.server --bind 127.0.0.1
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4: </span><code>--bind</code> argument was introduced.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8: </span><code>--bind</code> argument enhanced to support IPv6</p> </div> <p>By default, the server uses the current directory. The option <code>-d/--directory</code> specifies a directory to which it should serve the files. For example, the following command uses a specific directory:</p> <pre data-language="python">python -m http.server --directory /tmp/
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7: </span><code>--directory</code> argument was introduced.</p> </div> <p>By default, the server is conformant to HTTP/1.0. The option <code>-p/--protocol</code> specifies the HTTP version to which the server is conformant. For example, the following command runs an HTTP/1.1 conformant server:</p> <pre data-language="python">python -m http.server --protocol HTTP/1.1
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11: </span><code>--protocol</code> argument was introduced.</p> </div> <dl class="py class"> <dt class="sig sig-object py" id="http.server.CGIHTTPRequestHandler">
<code>class http.server.CGIHTTPRequestHandler(request, client_address, server)</code> </dt> <dd>
<p>This class is used to serve either files or output of CGI scripts from the current directory and below. Note that mapping HTTP hierarchic structure to local directory structure is exactly as in <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler" title="http.server.SimpleHTTPRequestHandler"><code>SimpleHTTPRequestHandler</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>CGI scripts run by the <a class="reference internal" href="#http.server.CGIHTTPRequestHandler" title="http.server.CGIHTTPRequestHandler"><code>CGIHTTPRequestHandler</code></a> class cannot execute redirects (HTTP code 302), because code 200 (script output follows) is sent prior to execution of the CGI script. This pre-empts the status code.</p> </div> <p>The class will however, run the CGI script, instead of serving it as a file, if it guesses it to be a CGI script. Only directory-based CGI are used — the other common server configuration is to treat special extensions as denoting CGI scripts.</p> <p>The <code>do_GET()</code> and <code>do_HEAD()</code> functions are modified to run CGI scripts and serve the output, instead of serving files, if the request leads to somewhere below the <code>cgi_directories</code> path.</p> <p>The <a class="reference internal" href="#http.server.CGIHTTPRequestHandler" title="http.server.CGIHTTPRequestHandler"><code>CGIHTTPRequestHandler</code></a> defines the following data member:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="http.server.CGIHTTPRequestHandler.cgi_directories">
<code>cgi_directories</code> </dt> <dd>
<p>This defaults to <code>['/cgi-bin', '/htbin']</code> and describes directories to treat as containing CGI scripts.</p> </dd>
</dl> <p>The <a class="reference internal" href="#http.server.CGIHTTPRequestHandler" title="http.server.CGIHTTPRequestHandler"><code>CGIHTTPRequestHandler</code></a> defines the following method:</p> <dl class="py method"> <dt class="sig sig-object py" id="http.server.CGIHTTPRequestHandler.do_POST">
<code>do_POST()</code> </dt> <dd>
<p>This method serves the <code>'POST'</code> request type, only allowed for CGI scripts. Error 501, “Can only POST to CGI scripts”, is output when trying to POST to a non-CGI url.</p> </dd>
</dl> <p>Note that CGI scripts will be run with UID of user nobody, for security reasons. Problems with the CGI script will be translated to error 403.</p> </dd>
</dl> <p><a class="reference internal" href="#http.server.CGIHTTPRequestHandler" title="http.server.CGIHTTPRequestHandler"><code>CGIHTTPRequestHandler</code></a> can be enabled in the command line by passing the <code>--cgi</code> option:</p> <pre data-language="python">python -m http.server --cgi
</pre> <section id="security-considerations"> <span id="http-server-security"></span><h2>Security Considerations</h2> <p id="index-3"><a class="reference internal" href="#http.server.SimpleHTTPRequestHandler" title="http.server.SimpleHTTPRequestHandler"><code>SimpleHTTPRequestHandler</code></a> will follow symbolic links when handling requests, this makes it possible for files outside of the specified directory to be served.</p> <p>Earlier versions of Python did not scrub control characters from the log messages emitted to stderr from <code>python -m http.server</code> or the default <a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code>BaseHTTPRequestHandler</code></a> <code>.log_message</code> implementation. This could allow remote clients connecting to your server to send nefarious control codes to your terminal.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.12: </span>Control characters are scrubbed in stderr logs.</p> </div> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/http.server.html" class="_attribution-link">https://docs.python.org/3.12/library/http.server.html</a>
  </p>
</div>
