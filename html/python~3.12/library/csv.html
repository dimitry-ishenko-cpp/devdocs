 <span id="csv-csv-file-reading-and-writing"></span><h1>csv — CSV File Reading and Writing</h1> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/csv.py">Lib/csv.py</a></p>  <p>The so-called CSV (Comma Separated Values) format is the most common import and export format for spreadsheets and databases. CSV format was used for many years prior to attempts to describe the format in a standardized way in <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4180.html"><strong>RFC 4180</strong></a>. The lack of a well-defined standard means that subtle differences often exist in the data produced and consumed by different applications. These differences can make it annoying to process CSV files from multiple sources. Still, while the delimiters and quoting characters vary, the overall format is similar enough that it is possible to write a single module which can efficiently manipulate such data, hiding the details of reading and writing the data from the programmer.</p> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module implements classes to read and write tabular data in CSV format. It allows programmers to say, “write this data in the format preferred by Excel,” or “read data from this file which was generated by Excel,” without knowing the precise details of the CSV format used by Excel. Programmers can also describe the CSV formats understood by other applications or define their own special-purpose CSV formats.</p> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module’s <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> and <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects read and write sequences. Programmers can also read and write data in dictionary form using the <a class="reference internal" href="#csv.DictReader" title="csv.DictReader"><code>DictReader</code></a> and <a class="reference internal" href="#csv.DictWriter" title="csv.DictWriter"><code>DictWriter</code></a> classes.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0305/"><strong>PEP 305</strong></a> - CSV File API</dt>
<dd>
<p>The Python Enhancement Proposal which proposed this addition to Python.</p> </dd> </dl> </div> <section id="module-contents"> <span id="csv-contents"></span><h2>Module Contents</h2> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module defines the following functions:</p> <span class="target" id="index-3"></span><dl class="py function"> <dt class="sig sig-object py" id="csv.reader">
<code>csv.reader(csvfile, dialect='excel', **fmtparams)</code> </dt> <dd>
<p>Return a <a class="reference internal" href="#reader-objects"><span class="std std-ref">reader object</span></a> that will process lines from the given <em>csvfile</em>. A csvfile must be an iterable of strings, each in the reader’s defined csv format. A csvfile is most commonly a file-like object or list. If <em>csvfile</em> is a file object, it should be opened with <code>newline=''</code>. <a class="footnote-reference brackets" href="#id4" id="id1">1</a> An optional <em>dialect</em> parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class or one of the strings returned by the <a class="reference internal" href="#csv.list_dialects" title="csv.list_dialects"><code>list_dialects()</code></a> function. The other optional <em>fmtparams</em> keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section <a class="reference internal" href="#csv-fmt-params"><span class="std std-ref">Dialects and Formatting Parameters</span></a>.</p> <p>Each row read from the csv file is returned as a list of strings. No automatic data type conversion is performed unless the <code>QUOTE_NONNUMERIC</code> format option is specified (in which case unquoted fields are transformed into floats).</p> <p>A short usage example:</p> <pre data-language="python">&gt;&gt;&gt; import csv
&gt;&gt;&gt; with open('eggs.csv', newline='') as csvfile:
...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
...     for row in spamreader:
...         print(', '.join(row))
Spam, Spam, Spam, Spam, Spam, Baked Beans
Spam, Lovely Spam, Wonderful Spam
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="csv.writer">
<code>csv.writer(csvfile, dialect='excel', **fmtparams)</code> </dt> <dd>
<p>Return a writer object responsible for converting the user’s data into delimited strings on the given file-like object. <em>csvfile</em> can be any object with a <code>write()</code> method. If <em>csvfile</em> is a file object, it should be opened with <code>newline=''</code> <a class="footnote-reference brackets" href="#id4" id="id2">1</a>. An optional <em>dialect</em> parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class or one of the strings returned by the <a class="reference internal" href="#csv.list_dialects" title="csv.list_dialects"><code>list_dialects()</code></a> function. The other optional <em>fmtparams</em> keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about dialects and formatting parameters, see the <a class="reference internal" href="#csv-fmt-params"><span class="std std-ref">Dialects and Formatting Parameters</span></a> section. To make it as easy as possible to interface with modules which implement the DB API, the value <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a> is written as the empty string. While this isn’t a reversible transformation, it makes it easier to dump SQL NULL data values to CSV files without preprocessing the data returned from a <code>cursor.fetch*</code> call. All other non-string data are stringified with <a class="reference internal" href="stdtypes.html#str" title="str"><code>str()</code></a> before being written.</p> <p>A short usage example:</p> <pre data-language="python">import csv
with open('eggs.csv', 'w', newline='') as csvfile:
    spamwriter = csv.writer(csvfile, delimiter=' ',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])
    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="csv.register_dialect">
<code>csv.register_dialect(name[, dialect[, **fmtparams]])</code> </dt> <dd>
<p>Associate <em>dialect</em> with <em>name</em>. <em>name</em> must be a string. The dialect can be specified either by passing a sub-class of <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a>, or by <em>fmtparams</em> keyword arguments, or both, with keyword arguments overriding parameters of the dialect. For full details about dialects and formatting parameters, see section <a class="reference internal" href="#csv-fmt-params"><span class="std std-ref">Dialects and Formatting Parameters</span></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="csv.unregister_dialect">
<code>csv.unregister_dialect(name)</code> </dt> <dd>
<p>Delete the dialect associated with <em>name</em> from the dialect registry. An <a class="reference internal" href="#csv.Error" title="csv.Error"><code>Error</code></a> is raised if <em>name</em> is not a registered dialect name.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="csv.get_dialect">
<code>csv.get_dialect(name)</code> </dt> <dd>
<p>Return the dialect associated with <em>name</em>. An <a class="reference internal" href="#csv.Error" title="csv.Error"><code>Error</code></a> is raised if <em>name</em> is not a registered dialect name. This function returns an immutable <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="csv.list_dialects">
<code>csv.list_dialects()</code> </dt> <dd>
<p>Return the names of all registered dialects.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="csv.field_size_limit">
<code>csv.field_size_limit([new_limit])</code> </dt> <dd>
<p>Returns the current maximum field size allowed by the parser. If <em>new_limit</em> is given, this becomes the new limit.</p> </dd>
</dl> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module defines the following classes:</p> <dl class="py class"> <dt class="sig sig-object py" id="csv.DictReader">
<code>class csv.DictReader(f, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds)</code> </dt> <dd>
<p>Create an object that operates like a regular reader but maps the information in each row to a <a class="reference internal" href="stdtypes.html#dict" title="dict"><code>dict</code></a> whose keys are given by the optional <em>fieldnames</em> parameter.</p> <p>The <em>fieldnames</em> parameter is a <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a>. If <em>fieldnames</em> is omitted, the values in the first row of file <em>f</em> will be used as the fieldnames. Regardless of how the fieldnames are determined, the dictionary preserves their original ordering.</p> <p>If a row has more fields than fieldnames, the remaining data is put in a list and stored with the fieldname specified by <em>restkey</em> (which defaults to <code>None</code>). If a non-blank row has fewer fields than fieldnames, the missing values are filled-in with the value of <em>restval</em> (which defaults to <code>None</code>).</p> <p>All other optional or keyword arguments are passed to the underlying <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> instance.</p> <p>If the argument passed to <em>fieldnames</em> is an iterator, it will be coerced to a <a class="reference internal" href="stdtypes.html#list" title="list"><code>list</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Returned rows are now of type <code>OrderedDict</code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Returned rows are now of type <a class="reference internal" href="stdtypes.html#dict" title="dict"><code>dict</code></a>.</p> </div> <p>A short usage example:</p> <pre data-language="python">&gt;&gt;&gt; import csv
&gt;&gt;&gt; with open('names.csv', newline='') as csvfile:
...     reader = csv.DictReader(csvfile)
...     for row in reader:
...         print(row['first_name'], row['last_name'])
...
Eric Idle
John Cleese

&gt;&gt;&gt; print(row)
{'first_name': 'John', 'last_name': 'Cleese'}
</pre> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="csv.DictWriter">
<code>class csv.DictWriter(f, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds)</code> </dt> <dd>
<p>Create an object which operates like a regular writer but maps dictionaries onto output rows. The <em>fieldnames</em> parameter is a <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code>sequence</code></a> of keys that identify the order in which values in the dictionary passed to the <code>writerow()</code> method are written to file <em>f</em>. The optional <em>restval</em> parameter specifies the value to be written if the dictionary is missing a key in <em>fieldnames</em>. If the dictionary passed to the <code>writerow()</code> method contains a key not found in <em>fieldnames</em>, the optional <em>extrasaction</em> parameter indicates what action to take. If it is set to <code>'raise'</code>, the default value, a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised. If it is set to <code>'ignore'</code>, extra values in the dictionary are ignored. Any other optional or keyword arguments are passed to the underlying <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> instance.</p> <p>Note that unlike the <a class="reference internal" href="#csv.DictReader" title="csv.DictReader"><code>DictReader</code></a> class, the <em>fieldnames</em> parameter of the <a class="reference internal" href="#csv.DictWriter" title="csv.DictWriter"><code>DictWriter</code></a> class is not optional.</p> <p>If the argument passed to <em>fieldnames</em> is an iterator, it will be coerced to a <a class="reference internal" href="stdtypes.html#list" title="list"><code>list</code></a>.</p> <p>A short usage example:</p> <pre data-language="python">import csv

with open('names.csv', 'w', newline='') as csvfile:
    fieldnames = ['first_name', 'last_name']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

    writer.writeheader()
    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})
    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})
    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})
</pre> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="csv.Dialect">
<code>class csv.Dialect</code> </dt> <dd>
<p>The <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class is a container class whose attributes contain information for how to handle doublequotes, whitespace, delimiters, etc. Due to the lack of a strict CSV specification, different applications produce subtly different CSV data. <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> instances define how <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> and <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> instances behave.</p> <p>All available <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> names are returned by <a class="reference internal" href="#csv.list_dialects" title="csv.list_dialects"><code>list_dialects()</code></a>, and they can be registered with specific <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> and <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> classes through their initializer (<code>__init__</code>) functions like this:</p> <pre data-language="python">import csv

with open('students.csv', 'w', newline='') as csvfile:
    writer = csv.writer(csvfile, dialect='unix')
                                 ^^^^^^^^^^^^^^
</pre> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="csv.excel">
<code>class csv.excel</code> </dt> <dd>
<p>The <a class="reference internal" href="#csv.excel" title="csv.excel"><code>excel</code></a> class defines the usual properties of an Excel-generated CSV file. It is registered with the dialect name <code>'excel'</code>.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="csv.excel_tab">
<code>class csv.excel_tab</code> </dt> <dd>
<p>The <a class="reference internal" href="#csv.excel_tab" title="csv.excel_tab"><code>excel_tab</code></a> class defines the usual properties of an Excel-generated TAB-delimited file. It is registered with the dialect name <code>'excel-tab'</code>.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="csv.unix_dialect">
<code>class csv.unix_dialect</code> </dt> <dd>
<p>The <a class="reference internal" href="#csv.unix_dialect" title="csv.unix_dialect"><code>unix_dialect</code></a> class defines the usual properties of a CSV file generated on UNIX systems, i.e. using <code>'\n'</code> as line terminator and quoting all fields. It is registered with the dialect name <code>'unix'</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="csv.Sniffer">
<code>class csv.Sniffer</code> </dt> <dd>
<p>The <a class="reference internal" href="#csv.Sniffer" title="csv.Sniffer"><code>Sniffer</code></a> class is used to deduce the format of a CSV file.</p> <p>The <a class="reference internal" href="#csv.Sniffer" title="csv.Sniffer"><code>Sniffer</code></a> class provides two methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="csv.Sniffer.sniff">
<code>sniff(sample, delimiters=None)</code> </dt> <dd>
<p>Analyze the given <em>sample</em> and return a <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> subclass reflecting the parameters found. If the optional <em>delimiters</em> parameter is given, it is interpreted as a string containing possible valid delimiter characters.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="csv.Sniffer.has_header">
<code>has_header(sample)</code> </dt> <dd>
<p>Analyze the sample text (presumed to be in CSV format) and return <a class="reference internal" href="constants.html#True" title="True"><code>True</code></a> if the first row appears to be a series of column headers. Inspecting each column, one of two key criteria will be considered to estimate if the sample contains a header:</p> <ul class="simple"> <li>the second through n-th rows contain numeric values</li> <li>the second through n-th rows contain strings where at least one value’s length differs from that of the putative header of that column.</li> </ul> <p>Twenty rows after the first row are sampled; if more than half of columns + rows meet the criteria, <a class="reference internal" href="constants.html#True" title="True"><code>True</code></a> is returned.</p> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method is a rough heuristic and may produce both false positives and negatives.</p> </div> </dd>
</dl> <p>An example for <a class="reference internal" href="#csv.Sniffer" title="csv.Sniffer"><code>Sniffer</code></a> use:</p> <pre data-language="python">with open('example.csv', newline='') as csvfile:
    dialect = csv.Sniffer().sniff(csvfile.read(1024))
    csvfile.seek(0)
    reader = csv.reader(csvfile, dialect)
    # ... process CSV file contents here ...
</pre> <p id="csv-constants">The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module defines the following constants:</p> <dl class="py data"> <dt class="sig sig-object py" id="csv.QUOTE_ALL">
<code>csv.QUOTE_ALL</code> </dt> <dd>
<p>Instructs <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects to quote all fields.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="csv.QUOTE_MINIMAL">
<code>csv.QUOTE_MINIMAL</code> </dt> <dd>
<p>Instructs <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects to only quote those fields which contain special characters such as <em>delimiter</em>, <em>quotechar</em> or any of the characters in <em>lineterminator</em>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="csv.QUOTE_NONNUMERIC">
<code>csv.QUOTE_NONNUMERIC</code> </dt> <dd>
<p>Instructs <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects to quote all non-numeric fields.</p> <p>Instructs <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> objects to convert all non-quoted fields to type <em>float</em>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="csv.QUOTE_NONE">
<code>csv.QUOTE_NONE</code> </dt> <dd>
<p>Instructs <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects to never quote fields. When the current <em>delimiter</em> occurs in output data it is preceded by the current <em>escapechar</em> character. If <em>escapechar</em> is not set, the writer will raise <a class="reference internal" href="#csv.Error" title="csv.Error"><code>Error</code></a> if any characters that require escaping are encountered.</p> <p>Instructs <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> objects to perform no special processing of quote characters.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="csv.QUOTE_NOTNULL">
<code>csv.QUOTE_NOTNULL</code> </dt> <dd>
<p>Instructs <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects to quote all fields which are not <code>None</code>. This is similar to <a class="reference internal" href="#csv.QUOTE_ALL" title="csv.QUOTE_ALL"><code>QUOTE_ALL</code></a>, except that if a field value is <code>None</code> an empty (unquoted) string is written.</p> <p>Instructs <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> objects to interpret an empty (unquoted) field as None and to otherwise behave as <a class="reference internal" href="#csv.QUOTE_ALL" title="csv.QUOTE_ALL"><code>QUOTE_ALL</code></a>.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="csv.QUOTE_STRINGS">
<code>csv.QUOTE_STRINGS</code> </dt> <dd>
<p>Instructs <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects to always place quotes around fields which are strings. This is similar to <a class="reference internal" href="#csv.QUOTE_NONNUMERIC" title="csv.QUOTE_NONNUMERIC"><code>QUOTE_NONNUMERIC</code></a>, except that if a field value is <code>None</code> an empty (unquoted) string is written.</p> <p>Instructs <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> objects to interpret an empty (unquoted) string as <code>None</code> and to otherwise behave as <a class="reference internal" href="#csv.QUOTE_NONNUMERIC" title="csv.QUOTE_NONNUMERIC"><code>QUOTE_NONNUMERIC</code></a>.</p> </dd>
</dl> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module defines the following exception:</p> <dl class="py exception"> <dt class="sig sig-object py" id="csv.Error">
<code>exception csv.Error</code> </dt> <dd>
<p>Raised by any of the functions when an error is detected.</p> </dd>
</dl> </section> <section id="dialects-and-formatting-parameters"> <span id="csv-fmt-params"></span><h2>Dialects and Formatting Parameters</h2> <p>To make it easier to specify the format of input and output records, specific formatting parameters are grouped together into dialects. A dialect is a subclass of the <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class having a set of specific methods and a single <code>validate()</code> method. When creating <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> or <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects, the programmer can specify a string or a subclass of the <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class as the dialect parameter. In addition to, or instead of, the <em>dialect</em> parameter, the programmer can also specify individual formatting parameters, which have the same names as the attributes defined below for the <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class.</p> <p>Dialects support the following attributes:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.Dialect.delimiter">
<code>Dialect.delimiter</code> </dt> <dd>
<p>A one-character string used to separate fields. It defaults to <code>','</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.Dialect.doublequote">
<code>Dialect.doublequote</code> </dt> <dd>
<p>Controls how instances of <em>quotechar</em> appearing inside a field should themselves be quoted. When <a class="reference internal" href="constants.html#True" title="True"><code>True</code></a>, the character is doubled. When <a class="reference internal" href="constants.html#False" title="False"><code>False</code></a>, the <em>escapechar</em> is used as a prefix to the <em>quotechar</em>. It defaults to <a class="reference internal" href="constants.html#True" title="True"><code>True</code></a>.</p> <p>On output, if <em>doublequote</em> is <a class="reference internal" href="constants.html#False" title="False"><code>False</code></a> and no <em>escapechar</em> is set, <a class="reference internal" href="#csv.Error" title="csv.Error"><code>Error</code></a> is raised if a <em>quotechar</em> is found in a field.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.Dialect.escapechar">
<code>Dialect.escapechar</code> </dt> <dd>
<p>A one-character string used by the writer to escape the <em>delimiter</em> if <em>quoting</em> is set to <a class="reference internal" href="#csv.QUOTE_NONE" title="csv.QUOTE_NONE"><code>QUOTE_NONE</code></a> and the <em>quotechar</em> if <em>doublequote</em> is <a class="reference internal" href="constants.html#False" title="False"><code>False</code></a>. On reading, the <em>escapechar</em> removes any special meaning from the following character. It defaults to <a class="reference internal" href="constants.html#None" title="None"><code>None</code></a>, which disables escaping.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>An empty <em>escapechar</em> is not allowed.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.Dialect.lineterminator">
<code>Dialect.lineterminator</code> </dt> <dd>
<p>The string used to terminate lines produced by the <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a>. It defaults to <code>'\r\n'</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> is hard-coded to recognise either <code>'\r'</code> or <code>'\n'</code> as end-of-line, and ignores <em>lineterminator</em>. This behavior may change in the future.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.Dialect.quotechar">
<code>Dialect.quotechar</code> </dt> <dd>
<p>A one-character string used to quote fields containing special characters, such as the <em>delimiter</em> or <em>quotechar</em>, or which contain new-line characters. It defaults to <code>'"'</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.11: </span>An empty <em>quotechar</em> is not allowed.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.Dialect.quoting">
<code>Dialect.quoting</code> </dt> <dd>
<p>Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the <a class="reference internal" href="#csv-constants"><span class="std std-ref">QUOTE_* constants</span></a> and defaults to <a class="reference internal" href="#csv.QUOTE_MINIMAL" title="csv.QUOTE_MINIMAL"><code>QUOTE_MINIMAL</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.Dialect.skipinitialspace">
<code>Dialect.skipinitialspace</code> </dt> <dd>
<p>When <a class="reference internal" href="constants.html#True" title="True"><code>True</code></a>, spaces immediately following the <em>delimiter</em> are ignored. The default is <a class="reference internal" href="constants.html#False" title="False"><code>False</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.Dialect.strict">
<code>Dialect.strict</code> </dt> <dd>
<p>When <code>True</code>, raise exception <a class="reference internal" href="#csv.Error" title="csv.Error"><code>Error</code></a> on bad CSV input. The default is <code>False</code>.</p> </dd>
</dl> </section> <section id="reader-objects"> <span id="id3"></span><h2>Reader Objects</h2> <p>Reader objects (<a class="reference internal" href="#csv.DictReader" title="csv.DictReader"><code>DictReader</code></a> instances and objects returned by the <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader()</code></a> function) have the following public methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="csv.csvreader.__next__">
<code>csvreader.__next__()</code> </dt> <dd>
<p>Return the next row of the reader’s iterable object as a list (if the object was returned from <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader()</code></a>) or a dict (if it is a <a class="reference internal" href="#csv.DictReader" title="csv.DictReader"><code>DictReader</code></a> instance), parsed according to the current <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a>. Usually you should call this as <code>next(reader)</code>.</p> </dd>
</dl> <p>Reader objects have the following public attributes:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.csvreader.dialect">
<code>csvreader.dialect</code> </dt> <dd>
<p>A read-only description of the dialect in use by the parser.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.csvreader.line_num">
<code>csvreader.line_num</code> </dt> <dd>
<p>The number of lines read from the source iterator. This is not the same as the number of records returned, as records can span multiple lines.</p> </dd>
</dl> <p>DictReader objects have the following public attribute:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.DictReader.fieldnames">
<code>DictReader.fieldnames</code> </dt> <dd>
<p>If not passed as a parameter when creating the object, this attribute is initialized upon first access or when the first record is read from the file.</p> </dd>
</dl> </section> <section id="writer-objects"> <h2>Writer Objects</h2> <p><code>Writer</code> objects (<a class="reference internal" href="#csv.DictWriter" title="csv.DictWriter"><code>DictWriter</code></a> instances and objects returned by the <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer()</code></a> function) have the following public methods. A <em>row</em> must be an iterable of strings or numbers for <code>Writer</code> objects and a dictionary mapping fieldnames to strings or numbers (by passing them through <a class="reference internal" href="stdtypes.html#str" title="str"><code>str()</code></a> first) for <a class="reference internal" href="#csv.DictWriter" title="csv.DictWriter"><code>DictWriter</code></a> objects. Note that complex numbers are written out surrounded by parens. This may cause some problems for other programs which read CSV files (assuming they support complex numbers at all).</p> <dl class="py method"> <dt class="sig sig-object py" id="csv.csvwriter.writerow">
<code>csvwriter.writerow(row)</code> </dt> <dd>
<p>Write the <em>row</em> parameter to the writer’s file object, formatted according to the current <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a>. Return the return value of the call to the <em>write</em> method of the underlying file object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>Added support of arbitrary iterables.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="csv.csvwriter.writerows">
<code>csvwriter.writerows(rows)</code> </dt> <dd>
<p>Write all elements in <em>rows</em> (an iterable of <em>row</em> objects as described above) to the writer’s file object, formatted according to the current dialect.</p> </dd>
</dl> <p>Writer objects have the following public attribute:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="csv.csvwriter.dialect">
<code>csvwriter.dialect</code> </dt> <dd>
<p>A read-only description of the dialect in use by the writer.</p> </dd>
</dl> <p>DictWriter objects have the following public method:</p> <dl class="py method"> <dt class="sig sig-object py" id="csv.DictWriter.writeheader">
<code>DictWriter.writeheader()</code> </dt> <dd>
<p>Write a row with the field names (as specified in the constructor) to the writer’s file object, formatted according to the current dialect. Return the return value of the <a class="reference internal" href="#csv.csvwriter.writerow" title="csv.csvwriter.writerow"><code>csvwriter.writerow()</code></a> call used internally.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span><a class="reference internal" href="#csv.DictWriter.writeheader" title="csv.DictWriter.writeheader"><code>writeheader()</code></a> now also returns the value returned by the <a class="reference internal" href="#csv.csvwriter.writerow" title="csv.csvwriter.writerow"><code>csvwriter.writerow()</code></a> method it uses internally.</p> </div> </dd>
</dl> </section> <section id="examples"> <span id="csv-examples"></span><h2>Examples</h2> <p>The simplest example of reading a CSV file:</p> <pre data-language="python">import csv
with open('some.csv', newline='') as f:
    reader = csv.reader(f)
    for row in reader:
        print(row)
</pre> <p>Reading a file with an alternate format:</p> <pre data-language="python">import csv
with open('passwd', newline='') as f:
    reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)
    for row in reader:
        print(row)
</pre> <p>The corresponding simplest possible writing example is:</p> <pre data-language="python">import csv
with open('some.csv', 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerows(someiterable)
</pre> <p>Since <a class="reference internal" href="functions.html#open" title="open"><code>open()</code></a> is used to open a CSV file for reading, the file will by default be decoded into unicode using the system default encoding (see <a class="reference internal" href="locale.html#locale.getencoding" title="locale.getencoding"><code>locale.getencoding()</code></a>). To decode a file using a different encoding, use the <code>encoding</code> argument of open:</p> <pre data-language="python">import csv
with open('some.csv', newline='', encoding='utf-8') as f:
    reader = csv.reader(f)
    for row in reader:
        print(row)
</pre> <p>The same applies to writing in something other than the system default encoding: specify the encoding argument when opening the output file.</p> <p>Registering a new dialect:</p> <pre data-language="python">import csv
csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)
with open('passwd', newline='') as f:
    reader = csv.reader(f, 'unixpwd')
</pre> <p>A slightly more advanced use of the reader — catching and reporting errors:</p> <pre data-language="python">import csv, sys
filename = 'some.csv'
with open(filename, newline='') as f:
    reader = csv.reader(f)
    try:
        for row in reader:
            print(row)
    except csv.Error as e:
        sys.exit('file {}, line {}: {}'.format(filename, reader.line_num, e))
</pre> <p>And while the module doesn’t directly support parsing strings, it can easily be done:</p> <pre data-language="python">import csv
for row in csv.reader(['one,two,three']):
    print(row)
</pre> <h4 class="rubric">Footnotes</h4> <dl class="footnote brackets"> <dt class="label" id="id4">
<code>1(1,2)</code> </dt> <dd>
<p>If <code>newline=''</code> is not specified, newlines embedded inside quoted fields will not be interpreted correctly, and on platforms that use <code>\r\n</code> linendings on write an extra <code>\r</code> will be added. It should always be safe to specify <code>newline=''</code>, since the csv module does its own (<a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal</span></a>) newline handling.</p> </dd> </dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/csv.html" class="_attribution-link">https://docs.python.org/3.12/library/csv.html</a>
  </p>
</div>
