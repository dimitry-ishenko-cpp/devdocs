 <span id="email-iterators-iterators"></span><h1>email.iterators: Iterators</h1> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/email/iterators.py">Lib/email/iterators.py</a></p>  <p>Iterating over a message object tree is fairly easy with the <a class="reference internal" href="email.compat32-message.html#email.message.Message.walk" title="email.message.Message.walk"><code>Message.walk</code></a> method. The <a class="reference internal" href="#module-email.iterators" title="email.iterators: Iterate over a  message object tree."><code>email.iterators</code></a> module provides some useful higher level iterations over message object trees.</p> <dl class="py function"> <dt class="sig sig-object py" id="email.iterators.body_line_iterator">
<code>email.iterators.body_line_iterator(msg, decode=False)</code> </dt> <dd>
<p>This iterates over all the payloads in all the subparts of <em>msg</em>, returning the string payloads line-by-line. It skips over all the subpart headers, and it skips over any subpart with a payload that isn’t a Python string. This is somewhat equivalent to reading the flat text representation of the message from a file using <a class="reference internal" href="io.html#io.TextIOBase.readline" title="io.TextIOBase.readline"><code>readline()</code></a>, skipping over all the intervening headers.</p> <p>Optional <em>decode</em> is passed through to <a class="reference internal" href="email.compat32-message.html#email.message.Message.get_payload" title="email.message.Message.get_payload"><code>Message.get_payload</code></a>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="email.iterators.typed_subpart_iterator">
<code>email.iterators.typed_subpart_iterator(msg, maintype='text', subtype=None)</code> </dt> <dd>
<p>This iterates over all the subparts of <em>msg</em>, returning only those subparts that match the MIME type specified by <em>maintype</em> and <em>subtype</em>.</p> <p>Note that <em>subtype</em> is optional; if omitted, then subpart MIME type matching is done only with the main type. <em>maintype</em> is optional too; it defaults to <em class="mimetype">text</em>.</p> <p>Thus, by default <a class="reference internal" href="#email.iterators.typed_subpart_iterator" title="email.iterators.typed_subpart_iterator"><code>typed_subpart_iterator()</code></a> returns each subpart that has a MIME type of <em class="mimetype">text/*</em>.</p> </dd>
</dl> <p>The following function has been added as a useful debugging tool. It should <em>not</em> be considered part of the supported public interface for the package.</p> <dl class="py function"> <dt class="sig sig-object py" id="email.iterators._structure">
<code>email.iterators._structure(msg, fp=None, level=0, include_default=False)</code> </dt> <dd>
<p>Prints an indented representation of the content types of the message object structure. For example:</p> <pre data-language="pycon3">&gt;&gt;&gt; msg = email.message_from_file(somefile)
&gt;&gt;&gt; _structure(msg)
multipart/mixed
    text/plain
    text/plain
    multipart/digest
        message/rfc822
            text/plain
        message/rfc822
            text/plain
        message/rfc822
            text/plain
        message/rfc822
            text/plain
        message/rfc822
            text/plain
    text/plain
</pre> <p>Optional <em>fp</em> is a file-like object to print the output to. It must be suitable for Python’s <a class="reference internal" href="functions.html#print" title="print"><code>print()</code></a> function. <em>level</em> is used internally. <em>include_default</em>, if true, prints the default type as well.</p> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/email.iterators.html" class="_attribution-link">https://docs.python.org/3.12/library/email.iterators.html</a>
  </p>
</div>
