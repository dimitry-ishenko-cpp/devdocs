 <span id="operator-standard-operators-as-functions"></span><h1>operator — Standard operators as functions</h1> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/operator.py">Lib/operator.py</a></p>  <p>The <a class="reference internal" href="#module-operator" title="operator: Functions corresponding to the standard operators."><code>operator</code></a> module exports a set of efficient functions corresponding to the intrinsic operators of Python. For example, <code>operator.add(x, y)</code> is equivalent to the expression <code>x+y</code>. Many function names are those used for special methods, without the double underscores. For backward compatibility, many of these have a variant with the double underscores kept. The variants without the double underscores are preferred for clarity.</p> <p>The functions fall into categories that perform object comparisons, logical operations, mathematical operations and sequence operations.</p> <p>The object comparison functions are useful for all objects, and are named after the rich comparison operators they support:</p> <dl class="py function"> <dt class="sig sig-object py" id="operator.lt">
<code>operator.lt(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.le">
<code>operator.le(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.eq">
<code>operator.eq(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.ne">
<code>operator.ne(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.ge">
<code>operator.ge(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.gt">
<code>operator.gt(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__lt__">
<code>operator.__lt__(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__le__">
<code>operator.__le__(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__eq__">
<code>operator.__eq__(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__ne__">
<code>operator.__ne__(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__ge__">
<code>operator.__ge__(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__gt__">
<code>operator.__gt__(a, b)</code> </dt> <dd>
<p>Perform “rich comparisons” between <em>a</em> and <em>b</em>. Specifically, <code>lt(a, b)</code> is equivalent to <code>a &lt; b</code>, <code>le(a, b)</code> is equivalent to <code>a &lt;= b</code>, <code>eq(a,
b)</code> is equivalent to <code>a == b</code>, <code>ne(a, b)</code> is equivalent to <code>a != b</code>, <code>gt(a, b)</code> is equivalent to <code>a &gt; b</code> and <code>ge(a, b)</code> is equivalent to <code>a
&gt;= b</code>. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">Comparisons</span></a> for more information about rich comparisons.</p> </dd>
</dl> <p>The logical operations are also generally applicable to all objects, and support truth tests, identity tests, and boolean operations:</p> <dl class="py function"> <dt class="sig sig-object py" id="operator.not_">
<code>operator.not_(obj)</code> </dt> <dt class="sig sig-object py" id="operator.__not__">
<code>operator.__not__(obj)</code> </dt> <dd>
<p>Return the outcome of <a class="reference internal" href="../reference/expressions.html#not"><code>not</code></a> <em>obj</em>. (Note that there is no <code>__not__()</code> method for object instances; only the interpreter core defines this operation. The result is affected by the <a class="reference internal" href="../reference/datamodel.html#object.__bool__" title="object.__bool__"><code>__bool__()</code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code>__len__()</code></a> methods.)</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.truth">
<code>operator.truth(obj)</code> </dt> <dd>
<p>Return <a class="reference internal" href="constants.html#True" title="True"><code>True</code></a> if <em>obj</em> is true, and <a class="reference internal" href="constants.html#False" title="False"><code>False</code></a> otherwise. This is equivalent to using the <a class="reference internal" href="functions.html#bool" title="bool"><code>bool</code></a> constructor.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.is_">
<code>operator.is_(a, b)</code> </dt> <dd>
<p>Return <code>a is b</code>. Tests object identity.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.is_not">
<code>operator.is_not(a, b)</code> </dt> <dd>
<p>Return <code>a is not b</code>. Tests object identity.</p> </dd>
</dl> <p>The mathematical and bitwise operations are the most numerous:</p> <dl class="py function"> <dt class="sig sig-object py" id="operator.abs">
<code>operator.abs(obj)</code> </dt> <dt class="sig sig-object py" id="operator.__abs__">
<code>operator.__abs__(obj)</code> </dt> <dd>
<p>Return the absolute value of <em>obj</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.add">
<code>operator.add(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__add__">
<code>operator.__add__(a, b)</code> </dt> <dd>
<p>Return <code>a + b</code>, for <em>a</em> and <em>b</em> numbers.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.and_">
<code>operator.and_(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__and__">
<code>operator.__and__(a, b)</code> </dt> <dd>
<p>Return the bitwise and of <em>a</em> and <em>b</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.floordiv">
<code>operator.floordiv(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__floordiv__">
<code>operator.__floordiv__(a, b)</code> </dt> <dd>
<p>Return <code>a // b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.index">
<code>operator.index(a)</code> </dt> <dt class="sig sig-object py" id="operator.__index__">
<code>operator.__index__(a)</code> </dt> <dd>
<p>Return <em>a</em> converted to an integer. Equivalent to <code>a.__index__()</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The result always has exact type <a class="reference internal" href="functions.html#int" title="int"><code>int</code></a>. Previously, the result could have been an instance of a subclass of <code>int</code>.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.inv">
<code>operator.inv(obj)</code> </dt> <dt class="sig sig-object py" id="operator.invert">
<code>operator.invert(obj)</code> </dt> <dt class="sig sig-object py" id="operator.__inv__">
<code>operator.__inv__(obj)</code> </dt> <dt class="sig sig-object py" id="operator.__invert__">
<code>operator.__invert__(obj)</code> </dt> <dd>
<p>Return the bitwise inverse of the number <em>obj</em>. This is equivalent to <code>~obj</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.lshift">
<code>operator.lshift(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__lshift__">
<code>operator.__lshift__(a, b)</code> </dt> <dd>
<p>Return <em>a</em> shifted left by <em>b</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.mod">
<code>operator.mod(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__mod__">
<code>operator.__mod__(a, b)</code> </dt> <dd>
<p>Return <code>a % b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.mul">
<code>operator.mul(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__mul__">
<code>operator.__mul__(a, b)</code> </dt> <dd>
<p>Return <code>a * b</code>, for <em>a</em> and <em>b</em> numbers.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.matmul">
<code>operator.matmul(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__matmul__">
<code>operator.__matmul__(a, b)</code> </dt> <dd>
<p>Return <code>a @ b</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.neg">
<code>operator.neg(obj)</code> </dt> <dt class="sig sig-object py" id="operator.__neg__">
<code>operator.__neg__(obj)</code> </dt> <dd>
<p>Return <em>obj</em> negated (<code>-obj</code>).</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.or_">
<code>operator.or_(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__or__">
<code>operator.__or__(a, b)</code> </dt> <dd>
<p>Return the bitwise or of <em>a</em> and <em>b</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.pos">
<code>operator.pos(obj)</code> </dt> <dt class="sig sig-object py" id="operator.__pos__">
<code>operator.__pos__(obj)</code> </dt> <dd>
<p>Return <em>obj</em> positive (<code>+obj</code>).</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.pow">
<code>operator.pow(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__pow__">
<code>operator.__pow__(a, b)</code> </dt> <dd>
<p>Return <code>a ** b</code>, for <em>a</em> and <em>b</em> numbers.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.rshift">
<code>operator.rshift(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__rshift__">
<code>operator.__rshift__(a, b)</code> </dt> <dd>
<p>Return <em>a</em> shifted right by <em>b</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.sub">
<code>operator.sub(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__sub__">
<code>operator.__sub__(a, b)</code> </dt> <dd>
<p>Return <code>a - b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.truediv">
<code>operator.truediv(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__truediv__">
<code>operator.__truediv__(a, b)</code> </dt> <dd>
<p>Return <code>a / b</code> where 2/3 is .66 rather than 0. This is also known as “true” division.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.xor">
<code>operator.xor(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__xor__">
<code>operator.__xor__(a, b)</code> </dt> <dd>
<p>Return the bitwise exclusive or of <em>a</em> and <em>b</em>.</p> </dd>
</dl> <p>Operations which work with sequences (some of them with mappings too) include:</p> <dl class="py function"> <dt class="sig sig-object py" id="operator.concat">
<code>operator.concat(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__concat__">
<code>operator.__concat__(a, b)</code> </dt> <dd>
<p>Return <code>a + b</code> for <em>a</em> and <em>b</em> sequences.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.contains">
<code>operator.contains(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__contains__">
<code>operator.__contains__(a, b)</code> </dt> <dd>
<p>Return the outcome of the test <code>b in a</code>. Note the reversed operands.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.countOf">
<code>operator.countOf(a, b)</code> </dt> <dd>
<p>Return the number of occurrences of <em>b</em> in <em>a</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.delitem">
<code>operator.delitem(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__delitem__">
<code>operator.__delitem__(a, b)</code> </dt> <dd>
<p>Remove the value of <em>a</em> at index <em>b</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.getitem">
<code>operator.getitem(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__getitem__">
<code>operator.__getitem__(a, b)</code> </dt> <dd>
<p>Return the value of <em>a</em> at index <em>b</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.indexOf">
<code>operator.indexOf(a, b)</code> </dt> <dd>
<p>Return the index of the first of occurrence of <em>b</em> in <em>a</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.setitem">
<code>operator.setitem(a, b, c)</code> </dt> <dt class="sig sig-object py" id="operator.__setitem__">
<code>operator.__setitem__(a, b, c)</code> </dt> <dd>
<p>Set the value of <em>a</em> at index <em>b</em> to <em>c</em>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.length_hint">
<code>operator.length_hint(obj, default=0)</code> </dt> <dd>
<p>Return an estimated length for the object <em>obj</em>. First try to return its actual length, then an estimate using <a class="reference internal" href="../reference/datamodel.html#object.__length_hint__" title="object.__length_hint__"><code>object.__length_hint__()</code></a>, and finally return the default value.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </dd>
</dl> <p>The following operation works with callables:</p> <dl class="py function"> <dt class="sig sig-object py" id="operator.call">
<code>operator.call(obj, /, *args, **kwargs)</code> </dt> <dt class="sig sig-object py" id="operator.__call__">
<code>operator.__call__(obj, /, *args, **kwargs)</code> </dt> <dd>
<p>Return <code>obj(*args, **kwargs)</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.11.</span></p> </div> </dd>
</dl> <p>The <a class="reference internal" href="#module-operator" title="operator: Functions corresponding to the standard operators."><code>operator</code></a> module also defines tools for generalized attribute and item lookups. These are useful for making fast field extractors as arguments for <a class="reference internal" href="functions.html#map" title="map"><code>map()</code></a>, <a class="reference internal" href="functions.html#sorted" title="sorted"><code>sorted()</code></a>, <a class="reference internal" href="itertools.html#itertools.groupby" title="itertools.groupby"><code>itertools.groupby()</code></a>, or other functions that expect a function argument.</p> <dl class="py function"> <dt class="sig sig-object py" id="operator.attrgetter">
<code>operator.attrgetter(attr)</code> </dt> <dt class="sig sig-object py"> <span class="sig-prename descclassname">operator.</span><span class="sig-name descname">attrgetter</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">attrs</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Return a callable object that fetches <em>attr</em> from its operand. If more than one attribute is requested, returns a tuple of attributes. The attribute names can also contain dots. For example:</p> <ul class="simple"> <li>After <code>f = attrgetter('name')</code>, the call <code>f(b)</code> returns <code>b.name</code>.</li> <li>After <code>f = attrgetter('name', 'date')</code>, the call <code>f(b)</code> returns <code>(b.name, b.date)</code>.</li> <li>After <code>f = attrgetter('name.first', 'name.last')</code>, the call <code>f(b)</code> returns <code>(b.name.first, b.name.last)</code>.</li> </ul> <p>Equivalent to:</p> <pre data-language="python">def attrgetter(*items):
    if any(not isinstance(item, str) for item in items):
        raise TypeError('attribute name must be a string')
    if len(items) == 1:
        attr = items[0]
        def g(obj):
            return resolve_attr(obj, attr)
    else:
        def g(obj):
            return tuple(resolve_attr(obj, attr) for attr in items)
    return g

def resolve_attr(obj, attr):
    for name in attr.split("."):
        obj = getattr(obj, name)
    return obj
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.itemgetter">
<code>operator.itemgetter(item)</code> </dt> <dt class="sig sig-object py"> <span class="sig-prename descclassname">operator.</span><span class="sig-name descname">itemgetter</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">items</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Return a callable object that fetches <em>item</em> from its operand using the operand’s <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> method. If multiple items are specified, returns a tuple of lookup values. For example:</p> <ul class="simple"> <li>After <code>f = itemgetter(2)</code>, the call <code>f(r)</code> returns <code>r[2]</code>.</li> <li>After <code>g = itemgetter(2, 5, 3)</code>, the call <code>g(r)</code> returns <code>(r[2], r[5], r[3])</code>.</li> </ul> <p>Equivalent to:</p> <pre data-language="python">def itemgetter(*items):
    if len(items) == 1:
        item = items[0]
        def g(obj):
            return obj[item]
    else:
        def g(obj):
            return tuple(obj[item] for item in items)
    return g
</pre> <p>The items can be any type accepted by the operand’s <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> method. Dictionaries accept any <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> value. Lists, tuples, and strings accept an index or a slice:</p> <pre data-language="python">&gt;&gt;&gt; itemgetter(1)('ABCDEFG')
'B'
&gt;&gt;&gt; itemgetter(1, 3, 5)('ABCDEFG')
('B', 'D', 'F')
&gt;&gt;&gt; itemgetter(slice(2, None))('ABCDEFG')
'CDEFG'
&gt;&gt;&gt; soldier = dict(rank='captain', name='dotterbart')
&gt;&gt;&gt; itemgetter('rank')(soldier)
'captain'
</pre> <p>Example of using <a class="reference internal" href="#operator.itemgetter" title="operator.itemgetter"><code>itemgetter()</code></a> to retrieve specific fields from a tuple record:</p> <pre data-language="python">&gt;&gt;&gt; inventory = [('apple', 3), ('banana', 2), ('pear', 5), ('orange', 1)]
&gt;&gt;&gt; getcount = itemgetter(1)
&gt;&gt;&gt; list(map(getcount, inventory))
[3, 2, 5, 1]
&gt;&gt;&gt; sorted(inventory, key=getcount)
[('orange', 1), ('banana', 2), ('apple', 3), ('pear', 5)]
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.methodcaller">
<code>operator.methodcaller(name, /, *args, **kwargs)</code> </dt> <dd>
<p>Return a callable object that calls the method <em>name</em> on its operand. If additional arguments and/or keyword arguments are given, they will be given to the method as well. For example:</p> <ul class="simple"> <li>After <code>f = methodcaller('name')</code>, the call <code>f(b)</code> returns <code>b.name()</code>.</li> <li>After <code>f = methodcaller('name', 'foo', bar=1)</code>, the call <code>f(b)</code> returns <code>b.name('foo', bar=1)</code>.</li> </ul> <p>Equivalent to:</p> <pre data-language="python">def methodcaller(name, /, *args, **kwargs):
    def caller(obj):
        return getattr(obj, name)(*args, **kwargs)
    return caller
</pre> </dd>
</dl> <section id="mapping-operators-to-functions"> <span id="operator-map"></span><h2>Mapping Operators to Functions</h2> <p>This table shows how abstract operations correspond to operator symbols in the Python syntax and the functions in the <a class="reference internal" href="#module-operator" title="operator: Functions corresponding to the standard operators."><code>operator</code></a> module.</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Operation</p></th> <th class="head"><p>Syntax</p></th> <th class="head"><p>Function</p></th> </tr> </thead>  <tr>
<td><p>Addition</p></td> <td><p><code>a + b</code></p></td> <td><p><code>add(a, b)</code></p></td> </tr> <tr>
<td><p>Concatenation</p></td> <td><p><code>seq1 + seq2</code></p></td> <td><p><code>concat(seq1, seq2)</code></p></td> </tr> <tr>
<td><p>Containment Test</p></td> <td><p><code>obj in seq</code></p></td> <td><p><code>contains(seq, obj)</code></p></td> </tr> <tr>
<td><p>Division</p></td> <td><p><code>a / b</code></p></td> <td><p><code>truediv(a, b)</code></p></td> </tr> <tr>
<td><p>Division</p></td> <td><p><code>a // b</code></p></td> <td><p><code>floordiv(a, b)</code></p></td> </tr> <tr>
<td><p>Bitwise And</p></td> <td><p><code>a &amp; b</code></p></td> <td><p><code>and_(a, b)</code></p></td> </tr> <tr>
<td><p>Bitwise Exclusive Or</p></td> <td><p><code>a ^ b</code></p></td> <td><p><code>xor(a, b)</code></p></td> </tr> <tr>
<td><p>Bitwise Inversion</p></td> <td><p><code>~ a</code></p></td> <td><p><code>invert(a)</code></p></td> </tr> <tr>
<td><p>Bitwise Or</p></td> <td><p><code>a | b</code></p></td> <td><p><code>or_(a, b)</code></p></td> </tr> <tr>
<td><p>Exponentiation</p></td> <td><p><code>a ** b</code></p></td> <td><p><code>pow(a, b)</code></p></td> </tr> <tr>
<td><p>Identity</p></td> <td><p><code>a is b</code></p></td> <td><p><code>is_(a, b)</code></p></td> </tr> <tr>
<td><p>Identity</p></td> <td><p><code>a is not b</code></p></td> <td><p><code>is_not(a, b)</code></p></td> </tr> <tr>
<td><p>Indexed Assignment</p></td> <td><p><code>obj[k] = v</code></p></td> <td><p><code>setitem(obj, k, v)</code></p></td> </tr> <tr>
<td><p>Indexed Deletion</p></td> <td><p><code>del obj[k]</code></p></td> <td><p><code>delitem(obj, k)</code></p></td> </tr> <tr>
<td><p>Indexing</p></td> <td><p><code>obj[k]</code></p></td> <td><p><code>getitem(obj, k)</code></p></td> </tr> <tr>
<td><p>Left Shift</p></td> <td><p><code>a &lt;&lt; b</code></p></td> <td><p><code>lshift(a, b)</code></p></td> </tr> <tr>
<td><p>Modulo</p></td> <td><p><code>a % b</code></p></td> <td><p><code>mod(a, b)</code></p></td> </tr> <tr>
<td><p>Multiplication</p></td> <td><p><code>a * b</code></p></td> <td><p><code>mul(a, b)</code></p></td> </tr> <tr>
<td><p>Matrix Multiplication</p></td> <td><p><code>a @ b</code></p></td> <td><p><code>matmul(a, b)</code></p></td> </tr> <tr>
<td><p>Negation (Arithmetic)</p></td> <td><p><code>- a</code></p></td> <td><p><code>neg(a)</code></p></td> </tr> <tr>
<td><p>Negation (Logical)</p></td> <td><p><code>not a</code></p></td> <td><p><code>not_(a)</code></p></td> </tr> <tr>
<td><p>Positive</p></td> <td><p><code>+ a</code></p></td> <td><p><code>pos(a)</code></p></td> </tr> <tr>
<td><p>Right Shift</p></td> <td><p><code>a &gt;&gt; b</code></p></td> <td><p><code>rshift(a, b)</code></p></td> </tr> <tr>
<td><p>Slice Assignment</p></td> <td><p><code>seq[i:j] = values</code></p></td> <td><p><code>setitem(seq, slice(i, j), values)</code></p></td> </tr> <tr>
<td><p>Slice Deletion</p></td> <td><p><code>del seq[i:j]</code></p></td> <td><p><code>delitem(seq, slice(i, j))</code></p></td> </tr> <tr>
<td><p>Slicing</p></td> <td><p><code>seq[i:j]</code></p></td> <td><p><code>getitem(seq, slice(i, j))</code></p></td> </tr> <tr>
<td><p>String Formatting</p></td> <td><p><code>s % obj</code></p></td> <td><p><code>mod(s, obj)</code></p></td> </tr> <tr>
<td><p>Subtraction</p></td> <td><p><code>a - b</code></p></td> <td><p><code>sub(a, b)</code></p></td> </tr> <tr>
<td><p>Truth Test</p></td> <td><p><code>obj</code></p></td> <td><p><code>truth(obj)</code></p></td> </tr> <tr>
<td><p>Ordering</p></td> <td><p><code>a &lt; b</code></p></td> <td><p><code>lt(a, b)</code></p></td> </tr> <tr>
<td><p>Ordering</p></td> <td><p><code>a &lt;= b</code></p></td> <td><p><code>le(a, b)</code></p></td> </tr> <tr>
<td><p>Equality</p></td> <td><p><code>a == b</code></p></td> <td><p><code>eq(a, b)</code></p></td> </tr> <tr>
<td><p>Difference</p></td> <td><p><code>a != b</code></p></td> <td><p><code>ne(a, b)</code></p></td> </tr> <tr>
<td><p>Ordering</p></td> <td><p><code>a &gt;= b</code></p></td> <td><p><code>ge(a, b)</code></p></td> </tr> <tr>
<td><p>Ordering</p></td> <td><p><code>a &gt; b</code></p></td> <td><p><code>gt(a, b)</code></p></td> </tr>  </table> </section> <section id="in-place-operators"> <h2>In-place Operators</h2> <p>Many operations have an “in-place” version. Listed below are functions providing a more primitive access to in-place operators than the usual syntax does; for example, the <a class="reference internal" href="../glossary.html#term-statement"><span class="xref std std-term">statement</span></a> <code>x += y</code> is equivalent to <code>x = operator.iadd(x, y)</code>. Another way to put it is to say that <code>z = operator.iadd(x, y)</code> is equivalent to the compound statement <code>z = x; z += y</code>.</p> <p>In those examples, note that when an in-place method is called, the computation and assignment are performed in two separate steps. The in-place functions listed below only do the first step, calling the in-place method. The second step, assignment, is not handled.</p> <p>For immutable targets such as strings, numbers, and tuples, the updated value is computed, but not assigned back to the input variable:</p> <pre data-language="python">&gt;&gt;&gt; a = 'hello'
&gt;&gt;&gt; iadd(a, ' world')
'hello world'
&gt;&gt;&gt; a
'hello'
</pre> <p>For mutable targets such as lists and dictionaries, the in-place method will perform the update, so no subsequent assignment is necessary:</p> <pre data-language="python">&gt;&gt;&gt; s = ['h', 'e', 'l', 'l', 'o']
&gt;&gt;&gt; iadd(s, [' ', 'w', 'o', 'r', 'l', 'd'])
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
&gt;&gt;&gt; s
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
</pre> <dl class="py function"> <dt class="sig sig-object py" id="operator.iadd">
<code>operator.iadd(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__iadd__">
<code>operator.__iadd__(a, b)</code> </dt> <dd>
<p><code>a = iadd(a, b)</code> is equivalent to <code>a += b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.iand">
<code>operator.iand(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__iand__">
<code>operator.__iand__(a, b)</code> </dt> <dd>
<p><code>a = iand(a, b)</code> is equivalent to <code>a &amp;= b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.iconcat">
<code>operator.iconcat(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__iconcat__">
<code>operator.__iconcat__(a, b)</code> </dt> <dd>
<p><code>a = iconcat(a, b)</code> is equivalent to <code>a += b</code> for <em>a</em> and <em>b</em> sequences.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.ifloordiv">
<code>operator.ifloordiv(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__ifloordiv__">
<code>operator.__ifloordiv__(a, b)</code> </dt> <dd>
<p><code>a = ifloordiv(a, b)</code> is equivalent to <code>a //= b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.ilshift">
<code>operator.ilshift(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__ilshift__">
<code>operator.__ilshift__(a, b)</code> </dt> <dd>
<p><code>a = ilshift(a, b)</code> is equivalent to <code>a &lt;&lt;= b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.imod">
<code>operator.imod(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__imod__">
<code>operator.__imod__(a, b)</code> </dt> <dd>
<p><code>a = imod(a, b)</code> is equivalent to <code>a %= b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.imul">
<code>operator.imul(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__imul__">
<code>operator.__imul__(a, b)</code> </dt> <dd>
<p><code>a = imul(a, b)</code> is equivalent to <code>a *= b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.imatmul">
<code>operator.imatmul(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__imatmul__">
<code>operator.__imatmul__(a, b)</code> </dt> <dd>
<p><code>a = imatmul(a, b)</code> is equivalent to <code>a @= b</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.ior">
<code>operator.ior(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__ior__">
<code>operator.__ior__(a, b)</code> </dt> <dd>
<p><code>a = ior(a, b)</code> is equivalent to <code>a |= b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.ipow">
<code>operator.ipow(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__ipow__">
<code>operator.__ipow__(a, b)</code> </dt> <dd>
<p><code>a = ipow(a, b)</code> is equivalent to <code>a **= b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.irshift">
<code>operator.irshift(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__irshift__">
<code>operator.__irshift__(a, b)</code> </dt> <dd>
<p><code>a = irshift(a, b)</code> is equivalent to <code>a &gt;&gt;= b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.isub">
<code>operator.isub(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__isub__">
<code>operator.__isub__(a, b)</code> </dt> <dd>
<p><code>a = isub(a, b)</code> is equivalent to <code>a -= b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.itruediv">
<code>operator.itruediv(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__itruediv__">
<code>operator.__itruediv__(a, b)</code> </dt> <dd>
<p><code>a = itruediv(a, b)</code> is equivalent to <code>a /= b</code>.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="operator.ixor">
<code>operator.ixor(a, b)</code> </dt> <dt class="sig sig-object py" id="operator.__ixor__">
<code>operator.__ixor__(a, b)</code> </dt> <dd>
<p><code>a = ixor(a, b)</code> is equivalent to <code>a ^= b</code>.</p> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/operator.html" class="_attribution-link">https://docs.python.org/3.12/library/operator.html</a>
  </p>
</div>
