 <span id="symtable-access-to-the-compiler-s-symbol-tables"></span><h1>symtable — Access to the compiler’s symbol tables</h1> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/symtable.py">Lib/symtable.py</a></p>  <p>Symbol tables are generated by the compiler from AST just before bytecode is generated. The symbol table is responsible for calculating the scope of every identifier in the code. <a class="reference internal" href="#module-symtable" title="symtable: Interface to the compiler's internal symbol tables."><code>symtable</code></a> provides an interface to examine these tables.</p> <section id="generating-symbol-tables"> <h2>Generating Symbol Tables</h2> <dl class="py function"> <dt class="sig sig-object py" id="symtable.symtable">
<code>symtable.symtable(code, filename, compile_type)</code> </dt> <dd>
<p>Return the toplevel <a class="reference internal" href="#symtable.SymbolTable" title="symtable.SymbolTable"><code>SymbolTable</code></a> for the Python source <em>code</em>. <em>filename</em> is the name of the file containing the code. <em>compile_type</em> is like the <em>mode</em> argument to <a class="reference internal" href="functions.html#compile" title="compile"><code>compile()</code></a>.</p> </dd>
</dl> </section> <section id="examining-symbol-tables"> <h2>Examining Symbol Tables</h2> <dl class="py class"> <dt class="sig sig-object py" id="symtable.SymbolTable">
<code>class symtable.SymbolTable</code> </dt> <dd>
<p>A namespace table for a block. The constructor is not public.</p> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.get_type">
<code>get_type()</code> </dt> <dd>
<p>Return the type of the symbol table. Possible values are <code>'class'</code>, <code>'module'</code>, <code>'function'</code>, <code>'annotation'</code>, <code>'TypeVar bound'</code>, <code>'type alias'</code>, and <code>'type parameter'</code>. The latter four refer to different flavors of <a class="reference internal" href="../reference/executionmodel.html#annotation-scopes"><span class="std std-ref">annotation scopes</span></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.12: </span>Added <code>'annotation'</code>, <code>'TypeVar bound'</code>, <code>'type alias'</code>, and <code>'type parameter'</code> as possible return values.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.get_id">
<code>get_id()</code> </dt> <dd>
<p>Return the table’s identifier.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.get_name">
<code>get_name()</code> </dt> <dd>
<p>Return the table’s name. This is the name of the class if the table is for a class, the name of the function if the table is for a function, or <code>'top'</code> if the table is global (<a class="reference internal" href="#symtable.SymbolTable.get_type" title="symtable.SymbolTable.get_type"><code>get_type()</code></a> returns <code>'module'</code>). For type parameter scopes (which are used for generic classes, functions, and type aliases), it is the name of the underlying class, function, or type alias. For type alias scopes, it is the name of the type alias. For <a class="reference internal" href="typing.html#typing.TypeVar" title="typing.TypeVar"><code>TypeVar</code></a> bound scopes, it is the name of the <code>TypeVar</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.get_lineno">
<code>get_lineno()</code> </dt> <dd>
<p>Return the number of the first line in the block this table represents.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.is_optimized">
<code>is_optimized()</code> </dt> <dd>
<p>Return <code>True</code> if the locals in this table can be optimized.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.is_nested">
<code>is_nested()</code> </dt> <dd>
<p>Return <code>True</code> if the block is a nested class or function.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.has_children">
<code>has_children()</code> </dt> <dd>
<p>Return <code>True</code> if the block has nested namespaces within it. These can be obtained with <a class="reference internal" href="#symtable.SymbolTable.get_children" title="symtable.SymbolTable.get_children"><code>get_children()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.get_identifiers">
<code>get_identifiers()</code> </dt> <dd>
<p>Return a view object containing the names of symbols in the table. See the <a class="reference internal" href="stdtypes.html#dict-views"><span class="std std-ref">documentation of view objects</span></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.lookup">
<code>lookup(name)</code> </dt> <dd>
<p>Lookup <em>name</em> in the table and return a <a class="reference internal" href="#symtable.Symbol" title="symtable.Symbol"><code>Symbol</code></a> instance.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.get_symbols">
<code>get_symbols()</code> </dt> <dd>
<p>Return a list of <a class="reference internal" href="#symtable.Symbol" title="symtable.Symbol"><code>Symbol</code></a> instances for names in the table.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.SymbolTable.get_children">
<code>get_children()</code> </dt> <dd>
<p>Return a list of the nested symbol tables.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="symtable.Function">
<code>class symtable.Function</code> </dt> <dd>
<p>A namespace for a function or method. This class inherits <a class="reference internal" href="#symtable.SymbolTable" title="symtable.SymbolTable"><code>SymbolTable</code></a>.</p> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Function.get_parameters">
<code>get_parameters()</code> </dt> <dd>
<p>Return a tuple containing names of parameters to this function.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Function.get_locals">
<code>get_locals()</code> </dt> <dd>
<p>Return a tuple containing names of locals in this function.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Function.get_globals">
<code>get_globals()</code> </dt> <dd>
<p>Return a tuple containing names of globals in this function.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Function.get_nonlocals">
<code>get_nonlocals()</code> </dt> <dd>
<p>Return a tuple containing names of nonlocals in this function.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Function.get_frees">
<code>get_frees()</code> </dt> <dd>
<p>Return a tuple containing names of free variables in this function.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="symtable.Class">
<code>class symtable.Class</code> </dt> <dd>
<p>A namespace of a class. This class inherits <a class="reference internal" href="#symtable.SymbolTable" title="symtable.SymbolTable"><code>SymbolTable</code></a>.</p> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Class.get_methods">
<code>get_methods()</code> </dt> <dd>
<p>Return a tuple containing the names of methods declared in the class.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="symtable.Symbol">
<code>class symtable.Symbol</code> </dt> <dd>
<p>An entry in a <a class="reference internal" href="#symtable.SymbolTable" title="symtable.SymbolTable"><code>SymbolTable</code></a> corresponding to an identifier in the source. The constructor is not public.</p> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.get_name">
<code>get_name()</code> </dt> <dd>
<p>Return the symbol’s name.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_referenced">
<code>is_referenced()</code> </dt> <dd>
<p>Return <code>True</code> if the symbol is used in its block.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_imported">
<code>is_imported()</code> </dt> <dd>
<p>Return <code>True</code> if the symbol is created from an import statement.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_parameter">
<code>is_parameter()</code> </dt> <dd>
<p>Return <code>True</code> if the symbol is a parameter.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_global">
<code>is_global()</code> </dt> <dd>
<p>Return <code>True</code> if the symbol is global.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_nonlocal">
<code>is_nonlocal()</code> </dt> <dd>
<p>Return <code>True</code> if the symbol is nonlocal.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_declared_global">
<code>is_declared_global()</code> </dt> <dd>
<p>Return <code>True</code> if the symbol is declared global with a global statement.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_local">
<code>is_local()</code> </dt> <dd>
<p>Return <code>True</code> if the symbol is local to its block.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_annotated">
<code>is_annotated()</code> </dt> <dd>
<p>Return <code>True</code> if the symbol is annotated.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_free">
<code>is_free()</code> </dt> <dd>
<p>Return <code>True</code> if the symbol is referenced in its block, but not assigned to.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_assigned">
<code>is_assigned()</code> </dt> <dd>
<p>Return <code>True</code> if the symbol is assigned to in its block.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.is_namespace">
<code>is_namespace()</code> </dt> <dd>
<p>Return <code>True</code> if name binding introduces new namespace.</p> <p>If the name is used as the target of a function or class statement, this will be true.</p> <p>For example:</p> <pre data-language="python">&gt;&gt;&gt; table = symtable.symtable("def some_func(): pass", "string", "exec")
&gt;&gt;&gt; table.lookup("some_func").is_namespace()
True
</pre> <p>Note that a single name can be bound to multiple objects. If the result is <code>True</code>, the name may also be bound to other objects, like an int or list, that does not introduce a new namespace.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.get_namespaces">
<code>get_namespaces()</code> </dt> <dd>
<p>Return a list of namespaces bound to this name.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="symtable.Symbol.get_namespace">
<code>get_namespace()</code> </dt> <dd>
<p>Return the namespace bound to this name. If more than one or no namespace is bound to this name, a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> is raised.</p> </dd>
</dl> </dd>
</dl> </section> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/library/symtable.html" class="_attribution-link">https://docs.python.org/3.12/library/symtable.html</a>
  </p>
</div>
