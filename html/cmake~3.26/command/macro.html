<h1 id="command:macro">macro</h1> <p>Start recording a macro for later invocation as a command</p> <pre data-language="cmake">macro(&lt;name&gt; [&lt;arg1&gt; ...])
  &lt;commands&gt;
endmacro()
</pre> <p>Defines a macro named <code>&lt;name&gt;</code> that takes arguments named <code>&lt;arg1&gt;</code>, ... Commands listed after macro, but before the matching <a class="reference internal" href="endmacro.html#command:endmacro" title="endmacro" id="index-0-command:endmacro"><code>endmacro()</code></a>, are not executed until the macro is invoked.</p> <p>Per legacy, the <a class="reference internal" href="endmacro.html#command:endmacro" title="endmacro" id="index-1-command:endmacro"><code>endmacro()</code></a> command admits an optional <code>&lt;name&gt;</code> argument. If used, it must be a verbatim repeat of the argument of the opening <code>macro</code> command.</p> <p>See the <a class="reference internal" href="cmake_policy.html#command:cmake_policy" title="cmake_policy" id="index-0-command:cmake_policy"><code>cmake_policy()</code></a> command documentation for the behavior of policies inside macros.</p> <p>See the <a class="reference internal" href="#macro-vs-function"><span class="std std-ref">Macro vs Function</span></a> section below for differences between CMake macros and <a class="reference internal" href="function.html#command:function" title="function" id="index-0-command:function"><code>functions</code></a>.</p>  <h2>Invocation</h2> <p>The macro invocation is case-insensitive. A macro defined as</p> <pre data-language="cmake">macro(foo)
  &lt;commands&gt;
endmacro()
</pre> <p>can be invoked through any of</p> <pre data-language="cmake">foo()
Foo()
FOO()
cmake_language(CALL foo)
</pre> <p>and so on. However, it is strongly recommended to stay with the case chosen in the macro definition. Typically macros use all-lowercase names.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.18: </span>The <a class="reference internal" href="cmake_language.html#command:cmake_language" title="cmake_language" id="index-0-command:cmake_language"><code>cmake_language(CALL ...)</code></a> command can also be used to invoke the macro.</p> </div>   <h2>Arguments</h2> <p>When a macro is invoked, the commands recorded in the macro are first modified by replacing formal parameters (<code>${arg1}</code>, ...) with the arguments passed, and then invoked as normal commands.</p> <p>In addition to referencing the formal parameters you can reference the values <code>${ARGC}</code> which will be set to the number of arguments passed into the function as well as <code>${ARGV0}</code>, <code>${ARGV1}</code>, <code>${ARGV2}</code>, ... which will have the actual values of the arguments passed in. This facilitates creating macros with optional arguments.</p> <p>Furthermore, <code>${ARGV}</code> holds the list of all arguments given to the macro and <code>${ARGN}</code> holds the list of arguments past the last expected argument. Referencing to <code>${ARGV#}</code> arguments beyond <code>${ARGC}</code> have undefined behavior. Checking that <code>${ARGC}</code> is greater than <code>#</code> is the only way to ensure that <code>${ARGV#}</code> was passed to the function as an extra argument.</p>   <h2 id="id1">Macro vs Function</h2> <p>The <code>macro</code> command is very similar to the <a class="reference internal" href="function.html#command:function" title="function" id="index-1-command:function"><code>function()</code></a> command. Nonetheless, there are a few important differences.</p> <p>In a function, <code>ARGN</code>, <code>ARGC</code>, <code>ARGV</code> and <code>ARGV0</code>, <code>ARGV1</code>, ... are true variables in the usual CMake sense. In a macro, they are not, they are string replacements much like the C preprocessor would do with a macro. This has a number of consequences, as explained in the <a class="reference internal" href="#argument-caveats"><span class="std std-ref">Argument Caveats</span></a> section below.</p> <p>Another difference between macros and functions is the control flow. A function is executed by transferring control from the calling statement to the function body. A macro is executed as if the macro body were pasted in place of the calling statement. This has the consequence that a <a class="reference internal" href="return.html#command:return" title="return" id="index-0-command:return"><code>return()</code></a> in a macro body does not just terminate execution of the macro; rather, control is returned from the scope of the macro call. To avoid confusion, it is recommended to avoid <a class="reference internal" href="return.html#command:return" title="return" id="index-1-command:return"><code>return()</code></a> in macros altogether.</p> <p>Unlike a function, the <a class="reference internal" href="../variable/cmake_current_function.html#variable:CMAKE_CURRENT_FUNCTION" title="CMAKE_CURRENT_FUNCTION" id="index-0-variable:CMAKE_CURRENT_FUNCTION"><code>CMAKE_CURRENT_FUNCTION</code></a>, <a class="reference internal" href="../variable/cmake_current_function_list_dir.html#variable:CMAKE_CURRENT_FUNCTION_LIST_DIR" title="CMAKE_CURRENT_FUNCTION_LIST_DIR" id="index-0-variable:CMAKE_CURRENT_FUNCTION_LIST_DIR"><code>CMAKE_CURRENT_FUNCTION_LIST_DIR</code></a>, <a class="reference internal" href="../variable/cmake_current_function_list_file.html#variable:CMAKE_CURRENT_FUNCTION_LIST_FILE" title="CMAKE_CURRENT_FUNCTION_LIST_FILE" id="index-0-variable:CMAKE_CURRENT_FUNCTION_LIST_FILE"><code>CMAKE_CURRENT_FUNCTION_LIST_FILE</code></a>, <a class="reference internal" href="../variable/cmake_current_function_list_line.html#variable:CMAKE_CURRENT_FUNCTION_LIST_LINE" title="CMAKE_CURRENT_FUNCTION_LIST_LINE" id="index-0-variable:CMAKE_CURRENT_FUNCTION_LIST_LINE"><code>CMAKE_CURRENT_FUNCTION_LIST_LINE</code></a> variables are not set for a macro.</p>   <h2 id="id2">Argument Caveats</h2> <p>Since <code>ARGN</code>, <code>ARGC</code>, <code>ARGV</code>, <code>ARGV0</code> etc. are not variables, you will NOT be able to use commands like</p> <pre data-language="cmake">if(ARGV1) # ARGV1 is not a variable
if(DEFINED ARGV2) # ARGV2 is not a variable
if(ARGC GREATER 2) # ARGC is not a variable
foreach(loop_var IN LISTS ARGN) # ARGN is not a variable
</pre> <p>In the first case, you can use <code>if(${ARGV1})</code>. In the second and third case, the proper way to check if an optional variable was passed to the macro is to use <code>if(${ARGC} GREATER 2)</code>. In the last case, you can use <code>foreach(loop_var ${ARGN})</code> but this will skip empty arguments. If you need to include them, you can use</p> <pre data-language="cmake">set(list_var "${ARGN}")
foreach(loop_var IN LISTS list_var)
</pre> <p>Note that if you have a variable with the same name in the scope from which the macro is called, using unreferenced names will use the existing variable instead of the arguments. For example:</p> <pre data-language="cmake">macro(bar)
  foreach(arg IN LISTS ARGN)
    &lt;commands&gt;
  endforeach()
endmacro()

function(foo)
  bar(x y z)
endfunction()

foo(a b c)
</pre> <p>Will loop over <code>a;b;c</code> and not over <code>x;y;z</code> as one might have expected. If you want true CMake variables and/or better CMake scope control you should look at the function command.</p>   <h2>See Also</h2> <ul class="simple"> <li><a class="reference internal" href="cmake_parse_arguments.html#command:cmake_parse_arguments" title="cmake_parse_arguments" id="index-0-command:cmake_parse_arguments"><code>cmake_parse_arguments()</code></a></li> <li><a class="reference internal" href="endmacro.html#command:endmacro" title="endmacro" id="index-2-command:endmacro"><code>endmacro()</code></a></li> </ul>   <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2000&ndash;2023 Kitware, Inc. and Contributors<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://cmake.org/cmake/help/v3.26/command/macro.html" class="_attribution-link">https://cmake.org/cmake/help/v3.26/command/macro.html</a>
  </p>
</div>
