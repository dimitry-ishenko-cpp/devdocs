   <h1>Constants Passed To The Conflict Handler</h1>
<pre data-language="sql">#define SQLITE_CHANGESET_DATA        1
#define SQLITE_CHANGESET_NOTFOUND    2
#define SQLITE_CHANGESET_CONFLICT    3
#define SQLITE_CHANGESET_CONSTRAINT  4
#define SQLITE_CHANGESET_FOREIGN_KEY 5
</pre>
<p> Values that may be passed as the second argument to a conflict-handler.</p> <p></p>
<dl> <dt>SQLITE_CHANGESET_DATA</dt>
<dd> The conflict handler is invoked with CHANGESET_DATA as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is present in the database, but one or more other (non primary-key) fields modified by the update do not contain the expected "before" values. <p> The conflicting row, in this case, is the database row with the matching primary key.</p> <p></p>
</dd>
<dt>SQLITE_CHANGESET_NOTFOUND</dt>
<dd> The conflict handler is invoked with CHANGESET_NOTFOUND as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is not present in the database. <p> There is no conflicting row in this case. The results of invoking the sqlite3changeset_conflict() API are undefined.</p> <p></p>
</dd>
<dt>SQLITE_CHANGESET_CONFLICT</dt>
<dd> CHANGESET_CONFLICT is passed as the second argument to the conflict handler while processing an INSERT change if the operation would result in duplicate primary key values. <p> The conflicting row in this case is the database row with the matching primary key.</p> <p></p>
</dd>
<dt>SQLITE_CHANGESET_FOREIGN_KEY</dt>
<dd> If foreign key handling is enabled, and applying a changeset leaves the database in a state containing foreign key violations, the conflict handler is invoked with CHANGESET_FOREIGN_KEY as the second argument exactly once before the changeset is committed. If the conflict handler returns CHANGESET_OMIT, the changes, including those that caused the foreign key constraint violation, are committed. Or, if it returns CHANGESET_ABORT, the changeset is rolled back. <p> No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</p> <p></p>
</dd>
<dt>SQLITE_CHANGESET_CONSTRAINT</dt>
<dd> If any other constraint violation occurs while applying a change (i.e. a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is invoked with CHANGESET_CONSTRAINT as the second argument. <p> There is no conflicting row in this case. The results of invoking the sqlite3changeset_conflict() API are undefined.</p> <p></p>
</dd>
</dl> <p>See also lists of <a href="objlist.html">Objects</a>, <a href="constlist.html">Constants</a>, and <a href="funclist.html">Functions</a>.</p> <div class="_attribution">
  <p class="_attribution-p">
    SQLite is in the Public Domain.<br>
    <a href="https://sqlite.org/session/c_changeset_conflict.html" class="_attribution-link">https://sqlite.org/session/c_changeset_conflict.html</a>
  </p>
</div>
