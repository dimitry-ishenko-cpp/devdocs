      <h1>Determine If A Prepared Statement Has Been Reset</h1>  <pre data-language="sql">
int sqlite3_stmt_busy(sqlite3_stmt*);
</pre> <p> The sqlite3_stmt_busy(S) interface returns true (non-zero) if the <a href="stmt.html">prepared statement</a> S has been stepped at least once using <a href="step.html">sqlite3_step(S)</a> but has neither run to completion (returned <a href="../rescode.html#done">SQLITE_DONE</a> from <a href="step.html">sqlite3_step(S)</a>) nor been reset using <a href="reset.html">sqlite3_reset(S)</a>. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid <a href="stmt.html">prepared statement</a> object, then the behavior is undefined and probably undesirable.</p> <p>This interface can be used in combination <a href="next_stmt.html">sqlite3_next_stmt()</a> to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open. </p>
<p>See also lists of <a href="objlist.html">Objects</a>, <a href="constlist.html">Constants</a>, and <a href="funclist.html">Functions</a>.</p> <div class="_attribution">
  <p class="_attribution-p">
    SQLite is in the Public Domain.<br>
    <a href="https://sqlite.org/c3ref/stmt_busy.html" class="_attribution-link">https://sqlite.org/c3ref/stmt_busy.html</a>
  </p>
</div>
