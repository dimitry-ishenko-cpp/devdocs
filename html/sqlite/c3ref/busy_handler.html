      <h1>Register A Callback To Handle SQLITE_BUSY Errors</h1>  <pre data-language="sql">
int sqlite3_busy_handler(sqlite3*,int(*)(void*,int),void*);
</pre> <p> The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with <a href="sqlite3.html">database connection</a> D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement <a href="busy_timeout.html">sqlite3_busy_timeout()</a> and <a href="../pragma.html#pragma_busy_timeout">PRAGMA busy_timeout</a>.</p> <p>If the busy callback is NULL, then <a href="../rescode.html#busy">SQLITE_BUSY</a> is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</p> <p>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and <a href="../rescode.html#busy">SQLITE_BUSY</a> is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</p> <p>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return <a href="../rescode.html#busy">SQLITE_BUSY</a> to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns <a href="../rescode.html#busy">SQLITE_BUSY</a> for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</p> <p>The default busy callback is NULL.</p> <p>There can only be a single busy handler defined for each <a href="sqlite3.html">database connection</a>. Setting a new busy handler clears any previously set handler. Note that calling <a href="busy_timeout.html">sqlite3_busy_timeout()</a> or evaluating <a href="../pragma.html#pragma_busy_timeout">PRAGMA busy_timeout=N</a> will change the busy handler and thus clear any previously set busy handler.</p> <p>The busy callback should not take any actions which modify the database connection that invoked the busy handler. In other words, the busy handler is not reentrant. Any such actions result in undefined behavior.</p> <p>A busy handler must not close the database connection or <a href="stmt.html">prepared statement</a> that invoked the busy handler. </p>
<p>See also lists of <a href="objlist.html">Objects</a>, <a href="constlist.html">Constants</a>, and <a href="funclist.html">Functions</a>.</p> <div class="_attribution">
  <p class="_attribution-p">
    SQLite is in the Public Domain.<br>
    <a href="https://sqlite.org/c3ref/busy_handler.html" class="_attribution-link">https://sqlite.org/c3ref/busy_handler.html</a>
  </p>
</div>
