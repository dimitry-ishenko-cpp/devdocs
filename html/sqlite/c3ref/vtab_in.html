      <h1>Identify and handle IN constraints in xBestIndex</h1>  <pre data-language="sql">
int sqlite3_vtab_in(sqlite3_index_info*, int iCons, int bHandle);
</pre> <p> This interface may only be used from within an <a href="../vtab.html#xbestindex">xBestIndex() method</a> of a <a href="../vtab.html">virtual table</a> implementation. The result of invoking this interface from any other context is undefined and probably harmful.</p> <p>A constraint on a virtual table of the form "<a href="../lang_expr.html#in_op">column IN (...)</a>" is communicated to the xBestIndex method as a <a href="c_index_constraint_eq.html">SQLITE_INDEX_CONSTRAINT_EQ</a> constraint. If xBestIndex wants to use this constraint, it must set the corresponding aConstraintUsage[].argvIndex to a positive integer. Then, under the usual mode of handling IN operators, SQLite generates <a href="../opcode.html">bytecode</a> that invokes the <a href="../vtab.html#xfilter">xFilter() method</a> once for each value on the right-hand side of the IN operator. Thus the virtual table only sees a single value from the right-hand side of the IN operator at a time.</p> <p>In some cases, however, it would be advantageous for the virtual table to see all values on the right-hand of the IN operator all at once. The sqlite3_vtab_in() interfaces facilitates this in two ways:</p> <p></p>
<ol> <li>
<p> A call to sqlite3_vtab_in(P,N,-1) will return true (non-zero) if and only if the <a href="index_info.html">P-&gt;aConstraint</a>[N] constraint is an <a href="../lang_expr.html#in_op">IN operator</a> that can be processed all at once. In other words, sqlite3_vtab_in() with -1 in the third argument is a mechanism by which the virtual table can ask SQLite if all-at-once processing of the IN operator is even possible.</p> <p></p>
</li>
<li><p> A call to sqlite3_vtab_in(P,N,F) with F==1 or F==0 indicates to SQLite that the virtual table does or does not want to process the IN operator all-at-once, respectively. Thus when the third parameter (F) is non-negative, this interface is the mechanism by which the virtual table tells SQLite how it wants to process the IN operator. </p></li>
</ol> <p>The sqlite3_vtab_in(P,N,F) interface can be invoked multiple times within the same xBestIndex method call. For any given P,N pair, the return value from sqlite3_vtab_in(P,N,F) will always be the same within the same xBestIndex call. If the interface returns true (non-zero), that means that the constraint is an IN operator that can be processed all-at-once. If the constraint is not an IN operator or cannot be processed all-at-once, then the interface returns false.</p> <p>All-at-once processing of the IN operator is selected if both of the following conditions are met:</p> <p></p>
<ol> <li>
<p> The P-&gt;aConstraintUsage[N].argvIndex value is set to a positive integer. This is how the virtual table tells SQLite that it wants to use the N-th constraint.</p> <p></p>
</li>
<li><p> The last call to sqlite3_vtab_in(P,N,F) for which F was non-negative had F&gt;=1. </p></li>
</ol> <p>If either or both of the conditions above are false, then SQLite uses the traditional one-at-a-time processing strategy for the IN constraint. If both conditions are true, then the argvIndex-th parameter to the xFilter method will be an <a href="value.html">sqlite3_value</a> that appears to be NULL, but which can be passed to <a href="vtab_in_first.html">sqlite3_vtab_in_first()</a> and <a href="vtab_in_first.html">sqlite3_vtab_in_next()</a> to find all values on the right-hand side of the IN constraint. </p>
<p>See also lists of <a href="objlist.html">Objects</a>, <a href="constlist.html">Constants</a>, and <a href="funclist.html">Functions</a>.</p> <div class="_attribution">
  <p class="_attribution-p">
    SQLite is in the Public Domain.<br>
    <a href="https://sqlite.org/c3ref/vtab_in.html" class="_attribution-link">https://sqlite.org/c3ref/vtab_in.html</a>
  </p>
</div>
