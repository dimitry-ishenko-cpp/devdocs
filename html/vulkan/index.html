<h1>Vulkan API Reference</h1>   <h2 id="protos">Vulkan Commands</h2>   <h3 id="_vkallocatecommandbuffers_3">vkAllocateCommandBuffers(3)</h3>  <h4 id="_name">Name</h4>  <p>vkAllocateCommandBuffers - Allocate command buffers from an existing command pool</p>    <h4 id="_c_specification">C Specification</h4>  <p>To allocate command buffers, call:</p>  <pre id="vkAllocateCommandBuffers" data-language="c++">VkResult vkAllocateCommandBuffers(
    VkDevice                                    device,
    const VkCommandBufferAllocateInfo*          pAllocateInfo,
    VkCommandBuffer*                            pCommandBuffers);</pre>   <h4 id="_parameters">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the command pool. </li> <li> <code>pAllocateInfo</code> is a pointer to an instance of the <code>VkCommandBufferAllocateInfo</code> structure describing parameters of the allocation. </li> <li> <code>pCommandBuffers</code> is a pointer to an array of <code>VkCommandBuffer</code> handles in which the resulting command buffer objects are returned. The array <strong>must</strong> be at least the length specified by the <code>commandBufferCount</code> member of <code>pAllocateInfo</code>. Each allocated command buffer begins in the initial state. </li> </ul>    <h4 id="_description">Description</h4>  <p>When command buffers are first allocated, they are in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">initial state</a>.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkAllocateCommandBuffers-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkAllocateCommandBuffers-pAllocateInfo-parameter">  <code>pAllocateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkCommandBufferAllocateInfo</code> structure </li> <li id="VUID-vkAllocateCommandBuffers-pCommandBuffers-parameter">  <code>pCommandBuffers</code> <strong>must</strong> be a pointer to an array of <code>pAllocateInfo</code>::commandBufferCount <code>VkCommandBuffer</code> handles </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>pAllocateInfo</code>::commandPool <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkCommandBufferAllocateInfo">VkCommandBufferAllocateInfo</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkAllocateCommandBuffers">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkAllocateCommandBuffers</a></p>         <h3 id="_vkallocatedescriptorsets_3">vkAllocateDescriptorSets(3)</h3>  <h4 id="_name_2">Name</h4>  <p>vkAllocateDescriptorSets - Allocate one or more descriptor sets</p>    <h4 id="_c_specification_2">C Specification</h4>  <p>To allocate descriptor sets from a descriptor pool, call:</p>  <pre id="vkAllocateDescriptorSets" data-language="c++">VkResult vkAllocateDescriptorSets(
    VkDevice                                    device,
    const VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets);</pre>   <h4 id="_parameters_2">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the descriptor pool. </li> <li> <code>pAllocateInfo</code> is a pointer to an instance of the <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a> structure describing parameters of the allocation. </li> <li> <code>pDescriptorSets</code> is a pointer to an array of <code>VkDescriptorSet</code> handles in which the resulting descriptor set objects are returned. The array <strong>must</strong> be at least the length specified by the <code>descriptorSetCount</code> member of <code>pAllocateInfo</code>. </li> </ul>    <h4 id="_description_2">Description</h4>  <p>The allocated descriptor sets are returned in <code>pDescriptorSets</code>.</p>   <p>When a descriptor set is allocated, the initial state is largely uninitialized and all descriptors are undefined. However, the descriptor set <strong>can</strong> be bound in a command buffer without causing errors or exceptions. All entries that are statically used by a pipeline in a drawing or dispatching command <strong>must</strong> have been populated before the descriptor set is bound for use by that command. Entries that are not statically used by a pipeline <strong>can</strong> have uninitialized descriptors or descriptors of resources that have been destroyed, and executing a draw or dispatch with such a descriptor set bound does not cause undefined behavior. This means applications need not populate unused entries with dummy descriptors.</p>   <p>If an allocation fails due to fragmentation, an indeterminate error is returned with an unspecified error code. Any returned error other than <code>VK_ERROR_FRAGMENTED_POOL</code> does not imply its usual meaning: applications <strong>should</strong> assume that the allocation failed due to fragmentation, and create a new descriptor pool.</p>  <blockquote> <h5 class="title">Note</h5>  <p>Applications <strong>should</strong> check for a negative return value when allocating new descriptor sets, assume that any error effectively means <code>VK_ERROR_FRAGMENTED_POOL</code>, and try to create a new descriptor pool. If <code>VK_ERROR_FRAGMENTED_POOL</code> is the actual return value, it adds certainty to that decision.</p>   <p>The reason for this is that <code>VK_ERROR_FRAGMENTED_POOL</code> was only added in a later revision of the 1.0 specification, and so drivers <strong>may</strong> return other errors if they were written against earlier revisions. To ensure full compatibility with earlier patch revisions, these other errors are allowed.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkAllocateDescriptorSets-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter">  <code>pAllocateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkDescriptorSetAllocateInfo</code> structure </li> <li id="VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter">  <code>pDescriptorSets</code> <strong>must</strong> be a pointer to an array of <code>pAllocateInfo</code>::descriptorSetCount <code>VkDescriptorSet</code> handles </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>pAllocateInfo</code>::descriptorPool <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_FRAGMENTED_POOL</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_2">See Also</h4>  <p><a href="#VkDescriptorSet">VkDescriptorSet</a>, <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_2">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkAllocateDescriptorSets">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkAllocateDescriptorSets</a></p>         <h3 id="_vkallocatememory_3">vkAllocateMemory(3)</h3>  <h4 id="_name_3">Name</h4>  <p>vkAllocateMemory - Allocate GPU memory</p>    <h4 id="_c_specification_3">C Specification</h4>  <p>To allocate memory objects, call:</p>  <pre id="vkAllocateMemory" data-language="c++">VkResult vkAllocateMemory(
    VkDevice                                    device,
    const VkMemoryAllocateInfo*                 pAllocateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDeviceMemory*                             pMemory);</pre>   <h4 id="_parameters_3">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the memory. </li> <li> <code>pAllocateInfo</code> is a pointer to an instance of the <a href="#VkMemoryAllocateInfo">VkMemoryAllocateInfo</a> structure describing parameters of the allocation. A successful returned allocation <strong>must</strong> use the requested parameters — no substitution is permitted by the implementation. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pMemory</code> is a pointer to a <code>VkDeviceMemory</code> handle in which information about the allocated memory is returned. </li> </ul>    <h4 id="_description_3">Description</h4>  <p>Allocations returned by <code>vkAllocateMemory</code> are guaranteed to meet any alignment requirement by the implementation. For example, if an implementation requires 128 byte alignment for images and 64 byte alignment for buffers, the device memory returned through this mechanism would be 128-byte aligned. This ensures that applications <strong>can</strong> correctly suballocate objects of different types (with potentially different alignment requirements) in the same memory object.</p>   <p>When memory is allocated, its contents are undefined.</p>   <p>There is an implementation-dependent maximum number of memory allocations which <strong>can</strong> be simultaneously created on a device. This is specified by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxMemoryAllocationCount"><code>maxMemoryAllocationCount</code></a> member of the <code>VkPhysicalDeviceLimits</code> structure. If <code>maxMemoryAllocationCount</code> is exceeded, <code>vkAllocateMemory</code> will return <code>VK_ERROR_TOO_MANY_OBJECTS</code>.</p>  <blockquote> <h5 class="title">Note</h5>  <p>Some platforms <strong>may</strong> have a limit on the maximum size of a single allocation. For example, certain systems <strong>may</strong> fail to create allocations with a size greater than or equal to 4GB. Such a limit is implementation-dependent, and if such a failure occurs then the error <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> <strong>should</strong> be returned.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkAllocateMemory-device-00636">  The number of currently valid memory objects, allocated from <code>device</code>, <strong>must</strong> be less than <code>VkPhysicalDeviceLimits</code>::<code>maxMemoryAllocationCount</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkAllocateMemory-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkAllocateMemory-pAllocateInfo-parameter">  <code>pAllocateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkMemoryAllocateInfo</code> structure </li> <li id="VUID-vkAllocateMemory-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkAllocateMemory-pMemory-parameter">  <code>pMemory</code> <strong>must</strong> be a pointer to a <code>VkDeviceMemory</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_TOO_MANY_OBJECTS</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_3">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkDeviceMemory">VkDeviceMemory</a>, <a href="#VkMemoryAllocateInfo">VkMemoryAllocateInfo</a></p>    <h4 id="_document_notes_3">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkAllocateMemory">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkAllocateMemory</a></p>         <h3 id="_vkbegincommandbuffer_3">vkBeginCommandBuffer(3)</h3>  <h4 id="_name_4">Name</h4>  <p>vkBeginCommandBuffer - Start recording a command buffer</p>    <h4 id="_c_specification_4">C Specification</h4>  <p>To begin recording a command buffer, call:</p>  <pre id="vkBeginCommandBuffer" data-language="c++">VkResult vkBeginCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    const VkCommandBufferBeginInfo*             pBeginInfo);</pre>   <h4 id="_parameters_4">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the handle of the command buffer which is to be put in the recording state. </li> <li> <code>pBeginInfo</code> is an instance of the <code>VkCommandBufferBeginInfo</code> structure, which defines additional information about how the command buffer begins recording. </li> </ul>    <h4 id="_description_4">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkBeginCommandBuffer-commandBuffer-00049">  <code>commandBuffer</code> <strong>must</strong> not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or pending state</a>. </li> <li id="VUID-vkBeginCommandBuffer-commandBuffer-00050">  If <code>commandBuffer</code> was allocated from a <a href="#VkCommandPool">VkCommandPool</a> which did not have the <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code> flag set, <code>commandBuffer</code> <strong>must</strong> be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">initial state</a>. </li> <li id="VUID-vkBeginCommandBuffer-commandBuffer-00051">  If <code>commandBuffer</code> is a secondary command buffer, the <code>pInheritanceInfo</code> member of <code>pBeginInfo</code> <strong>must</strong> be a valid <code>VkCommandBufferInheritanceInfo</code> structure </li> <li id="VUID-vkBeginCommandBuffer-commandBuffer-00052">  If <code>commandBuffer</code> is a secondary command buffer and either the <code>occlusionQueryEnable</code> member of the <code>pInheritanceInfo</code> member of <code>pBeginInfo</code> is <code>VK_FALSE</code>, or the precise occlusion queries feature is not enabled, the <code>queryFlags</code> member of the <code>pInheritanceInfo</code> member <code>pBeginInfo</code> <strong>must</strong> not contain <code>VK_QUERY_CONTROL_PRECISE_BIT</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkBeginCommandBuffer-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkBeginCommandBuffer-pBeginInfo-parameter">  <code>pBeginInfo</code> <strong>must</strong> be a pointer to a valid <code>VkCommandBufferBeginInfo</code> structure </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_4">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkCommandBufferBeginInfo">VkCommandBufferBeginInfo</a></p>    <h4 id="_document_notes_4">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkBeginCommandBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkBeginCommandBuffer</a></p>         <h3 id="_vkbindbuffermemory_3">vkBindBufferMemory(3)</h3>  <h4 id="_name_5">Name</h4>  <p>vkBindBufferMemory - Bind device memory to a buffer object</p>    <h4 id="_c_specification_5">C Specification</h4>  <p>To attach memory to a buffer object, call:</p>  <pre id="vkBindBufferMemory" data-language="c++">VkResult vkBindBufferMemory(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);</pre>   <h4 id="_parameters_5">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the buffer and memory. </li> <li> <code>buffer</code> is the buffer to be attached to memory. </li> <li> <code>memory</code> is a <code>VkDeviceMemory</code> object describing the device memory to attach. </li> <li> <code>memoryOffset</code> is the start offset of the region of <code>memory</code> which is to be bound to the buffer. The number of bytes returned in the <code>VkMemoryRequirements</code>::<code>size</code> member in <code>memory</code>, starting from <code>memoryOffset</code> bytes, will be bound to the specified buffer. </li> </ul>    <h4 id="_description_5">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkBindBufferMemory-buffer-01029">  <code>buffer</code> <strong>must</strong> not already be backed by a memory object </li> <li id="VUID-vkBindBufferMemory-buffer-01030">  <code>buffer</code> <strong>must</strong> not have been created with any sparse memory binding flags </li> <li id="VUID-vkBindBufferMemory-memoryOffset-01031">  <code>memoryOffset</code> <strong>must</strong> be less than the size of <code>memory</code> </li> <li id="VUID-vkBindBufferMemory-buffer-01032">  If <code>buffer</code> was created with the <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> or <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code>, <code>memoryOffset</code> <strong>must</strong> be a multiple of <code>VkPhysicalDeviceLimits</code>::<code>minTexelBufferOffsetAlignment</code> </li> <li id="VUID-vkBindBufferMemory-buffer-01033">  If <code>buffer</code> was created with the <code>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</code>, <code>memoryOffset</code> <strong>must</strong> be a multiple of <code>VkPhysicalDeviceLimits</code>::<code>minUniformBufferOffsetAlignment</code> </li> <li id="VUID-vkBindBufferMemory-buffer-01034">  If <code>buffer</code> was created with the <code>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</code>, <code>memoryOffset</code> <strong>must</strong> be a multiple of <code>VkPhysicalDeviceLimits</code>::<code>minStorageBufferOffsetAlignment</code> </li> <li id="VUID-vkBindBufferMemory-memory-01035">  <code>memory</code> <strong>must</strong> have been allocated using one of the memory types allowed in the <code>memoryTypeBits</code> member of the <code>VkMemoryRequirements</code> structure returned from a call to <code>vkGetBufferMemoryRequirements</code> with <code>buffer</code> </li> <li id="VUID-vkBindBufferMemory-memoryOffset-01036">  <code>memoryOffset</code> <strong>must</strong> be an integer multiple of the <code>alignment</code> member of the <code>VkMemoryRequirements</code> structure returned from a call to <code>vkGetBufferMemoryRequirements</code> with <code>buffer</code> </li> <li id="VUID-vkBindBufferMemory-size-01037">  The <code>size</code> member of the <code>VkMemoryRequirements</code> structure returned from a call to <code>vkGetBufferMemoryRequirements</code> with <code>buffer</code> <strong>must</strong> be less than or equal to the size of <code>memory</code> minus <code>memoryOffset</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkBindBufferMemory-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkBindBufferMemory-buffer-parameter">  <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkBindBufferMemory-memory-parameter">  <code>memory</code> <strong>must</strong> be a valid <code>VkDeviceMemory</code> handle </li> <li id="VUID-vkBindBufferMemory-buffer-parent">  <code>buffer</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> <li id="VUID-vkBindBufferMemory-memory-parent">  <code>memory</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>buffer</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_5">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkDeviceMemory">VkDeviceMemory</a>, <code>VkDeviceSize</code></p>    <h4 id="_document_notes_5">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkBindBufferMemory">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkBindBufferMemory</a></p>         <h3 id="_vkbindimagememory_3">vkBindImageMemory(3)</h3>  <h4 id="_name_6">Name</h4>  <p>vkBindImageMemory - Bind device memory to an image object</p>    <h4 id="_c_specification_6">C Specification</h4>  <p>To attach memory to an image object, call:</p>  <pre id="vkBindImageMemory" data-language="c++">VkResult vkBindImageMemory(
    VkDevice                                    device,
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);</pre>   <h4 id="_parameters_6">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the image and memory. </li> <li> <code>image</code> is the image. </li> <li> <code>memory</code> is the <code>VkDeviceMemory</code> object describing the device memory to attach. </li> <li> <code>memoryOffset</code> is the start offset of the region of <code>memory</code> which is to be bound to the image. The number of bytes returned in the <code>VkMemoryRequirements</code>::<code>size</code> member in <code>memory</code>, starting from <code>memoryOffset</code> bytes, will be bound to the specified image. </li> </ul>    <h4 id="_description_6">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkBindImageMemory-image-01044">  <code>image</code> <strong>must</strong> not already be backed by a memory object </li> <li id="VUID-vkBindImageMemory-image-01045">  <code>image</code> <strong>must</strong> not have been created with any sparse memory binding flags </li> <li id="VUID-vkBindImageMemory-memoryOffset-01046">  <code>memoryOffset</code> <strong>must</strong> be less than the size of <code>memory</code> </li> <li id="VUID-vkBindImageMemory-memory-01047">  <code>memory</code> <strong>must</strong> have been allocated using one of the memory types allowed in the <code>memoryTypeBits</code> member of the <code>VkMemoryRequirements</code> structure returned from a call to <code>vkGetImageMemoryRequirements</code> with <code>image</code> </li> <li id="VUID-vkBindImageMemory-memoryOffset-01048">  <code>memoryOffset</code> <strong>must</strong> be an integer multiple of the <code>alignment</code> member of the <code>VkMemoryRequirements</code> structure returned from a call to <code>vkGetImageMemoryRequirements</code> with <code>image</code> </li> <li id="VUID-vkBindImageMemory-size-01049">  The <code>size</code> member of the <code>VkMemoryRequirements</code> structure returned from a call to <code>vkGetImageMemoryRequirements</code> with <code>image</code> <strong>must</strong> be less than or equal to the size of <code>memory</code> minus <code>memoryOffset</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkBindImageMemory-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkBindImageMemory-image-parameter">  <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkBindImageMemory-memory-parameter">  <code>memory</code> <strong>must</strong> be a valid <code>VkDeviceMemory</code> handle </li> <li id="VUID-vkBindImageMemory-image-parent">  <code>image</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> <li id="VUID-vkBindImageMemory-memory-parent">  <code>memory</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>image</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_6">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkDeviceMemory">VkDeviceMemory</a>, <code>VkDeviceSize</code>, <a href="#VkImage">VkImage</a></p>    <h4 id="_document_notes_6">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkBindImageMemory">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkBindImageMemory</a></p>         <h3 id="_vkcmdbeginquery_3">vkCmdBeginQuery(3)</h3>  <h4 id="_name_7">Name</h4>  <p>vkCmdBeginQuery - Begin a query</p>    <h4 id="_c_specification_7">C Specification</h4>  <p>To begin a query, call:</p>  <pre id="vkCmdBeginQuery" data-language="c++">void vkCmdBeginQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags);</pre>   <h4 id="_parameters_7">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which this command will be recorded. </li> <li> <code>queryPool</code> is the query pool that will manage the results of the query. </li> <li> <code>query</code> is the query index within the query pool that will contain the results. </li> <li> <code>flags</code> is a bitmask of <a href="#VkQueryControlFlagBits">VkQueryControlFlagBits</a> specifying constraints on the types of queries that <strong>can</strong> be performed. </li> </ul>    <h4 id="_description_7">Description</h4>  <p>If the <code>queryType</code> of the pool is <code>VK_QUERY_TYPE_OCCLUSION</code> and <code>flags</code> contains <code>VK_QUERY_CONTROL_PRECISE_BIT</code>, an implementation <strong>must</strong> return a result that matches the actual number of samples passed. This is described in more detail in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-occlusion">Occlusion Queries</a>.</p>   <p>After beginning a query, that query is considered <em>active</em> within the command buffer it was called in until that same query is ended. Queries active in a primary command buffer when secondary command buffers are executed are considered active for those secondary command buffers.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdBeginQuery-queryPool-00798">  The query identified by <code>queryPool</code> and <code>query</code> <strong>must</strong> currently not be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a> </li> <li id="VUID-vkCmdBeginQuery-queryPool-00799">  The query identified by <code>queryPool</code> and <code>query</code> <strong>must</strong> be unavailable </li> <li id="VUID-vkCmdBeginQuery-queryType-00800">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-occlusionQueryPrecise">precise occlusion queries</a> feature is not enabled, or the <code>queryType</code> used to create <code>queryPool</code> was not <code>VK_QUERY_TYPE_OCCLUSION</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_QUERY_CONTROL_PRECISE_BIT</code> </li> <li id="VUID-vkCmdBeginQuery-queryPool-00801">  <code>queryPool</code> <strong>must</strong> have been created with a <code>queryType</code> that differs from that of any other queries that have been made <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>, and are currently still active within <code>commandBuffer</code> </li> <li id="VUID-vkCmdBeginQuery-query-00802">  <code>query</code> <strong>must</strong> be less than the number of queries in <code>queryPool</code> </li> <li id="VUID-vkCmdBeginQuery-queryType-00803">  If the <code>queryType</code> used to create <code>queryPool</code> was <code>VK_QUERY_TYPE_OCCLUSION</code>, the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdBeginQuery-queryType-00804">  If the <code>queryType</code> used to create <code>queryPool</code> was <code>VK_QUERY_TYPE_PIPELINE_STATISTICS</code> and any of the <code>pipelineStatistics</code> indicate graphics operations, the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdBeginQuery-queryType-00805">  If the <code>queryType</code> used to create <code>queryPool</code> was <code>VK_QUERY_TYPE_PIPELINE_STATISTICS</code> and any of the <code>pipelineStatistics</code> indicate compute operations, the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support compute operations </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdBeginQuery-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdBeginQuery-queryPool-parameter">  <code>queryPool</code> <strong>must</strong> be a valid <code>VkQueryPool</code> handle </li> <li id="VUID-vkCmdBeginQuery-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkQueryControlFlagBits">VkQueryControlFlagBits</a> values </li> <li id="VUID-vkCmdBeginQuery-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdBeginQuery-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdBeginQuery-commonparent">  Both of <code>commandBuffer</code>, and <code>queryPool</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_7">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkQueryControlFlags">VkQueryControlFlags</a>, <a href="#VkQueryPool">VkQueryPool</a></p>    <h4 id="_document_notes_7">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBeginQuery">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBeginQuery</a></p>         <h3 id="_vkcmdbeginrenderpass_3">vkCmdBeginRenderPass(3)</h3>  <h4 id="_name_8">Name</h4>  <p>vkCmdBeginRenderPass - Begin a new render pass</p>    <h4 id="_c_specification_8">C Specification</h4>  <p>To begin a render pass instance, call:</p>  <pre id="vkCmdBeginRenderPass" data-language="c++">void vkCmdBeginRenderPass(
    VkCommandBuffer                             commandBuffer,
    const VkRenderPassBeginInfo*                pRenderPassBegin,
    VkSubpassContents                           contents);</pre>   <h4 id="_parameters_8">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer in which to record the command. </li> <li> <code>pRenderPassBegin</code> is a pointer to a <a href="#VkRenderPassBeginInfo">VkRenderPassBeginInfo</a> structure (defined below) which indicates the render pass to begin an instance of, and the framebuffer the instance uses. </li> <li> <code>contents</code> is a <a href="#VkSubpassContents">VkSubpassContents</a> value specifying how the commands in the first subpass will be provided. </li> </ul>    <h4 id="_description_8">Description</h4>  <p>After beginning a render pass instance, the command buffer is ready to record the commands for the first subpass of that render pass.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdBeginRenderPass-initialLayout-00895">  If any of the <code>initialLayout</code> or <code>finalLayout</code> member of the <code>VkAttachmentDescription</code> structures or the <code>layout</code> member of the <code>VkAttachmentReference</code> structures specified when creating the render pass specified in the <code>renderPass</code> member of <code>pRenderPassBegin</code> is <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> then the corresponding attachment image subresource of the framebuffer specified in the <code>framebuffer</code> member of <code>pRenderPassBegin</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code> set </li> <li id="VUID-vkCmdBeginRenderPass-initialLayout-00896">  If any of the <code>initialLayout</code> or <code>finalLayout</code> member of the <code>VkAttachmentDescription</code> structures or the <code>layout</code> member of the <code>VkAttachmentReference</code> structures specified when creating the render pass specified in the <code>renderPass</code> member of <code>pRenderPassBegin</code> is <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code> then the corresponding attachment image subresource of the framebuffer specified in the <code>framebuffer</code> member of <code>pRenderPassBegin</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code> set </li> <li id="VUID-vkCmdBeginRenderPass-initialLayout-00897">  If any of the <code>initialLayout</code> or <code>finalLayout</code> member of the <code>VkAttachmentDescription</code> structures or the <code>layout</code> member of the <code>VkAttachmentReference</code> structures specified when creating the render pass specified in the <code>renderPass</code> member of <code>pRenderPassBegin</code> is <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code> then the corresponding attachment image subresource of the framebuffer specified in the <code>framebuffer</code> member of <code>pRenderPassBegin</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_SAMPLED_BIT</code> or <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> set </li> <li id="VUID-vkCmdBeginRenderPass-initialLayout-00898">  If any of the <code>initialLayout</code> or <code>finalLayout</code> member of the <code>VkAttachmentDescription</code> structures or the <code>layout</code> member of the <code>VkAttachmentReference</code> structures specified when creating the render pass specified in the <code>renderPass</code> member of <code>pRenderPassBegin</code> is <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> then the corresponding attachment image subresource of the framebuffer specified in the <code>framebuffer</code> member of <code>pRenderPassBegin</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> set </li> <li id="VUID-vkCmdBeginRenderPass-initialLayout-00899">  If any of the <code>initialLayout</code> or <code>finalLayout</code> member of the <code>VkAttachmentDescription</code> structures or the <code>layout</code> member of the <code>VkAttachmentReference</code> structures specified when creating the render pass specified in the <code>renderPass</code> member of <code>pRenderPassBegin</code> is <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> then the corresponding attachment image subresource of the framebuffer specified in the <code>framebuffer</code> member of <code>pRenderPassBegin</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> set </li> <li id="VUID-vkCmdBeginRenderPass-initialLayout-00900">  If any of the <code>initialLayout</code> members of the <code>VkAttachmentDescription</code> structures specified when creating the render pass specified in the <code>renderPass</code> member of <code>pRenderPassBegin</code> is not <code>VK_IMAGE_LAYOUT_UNDEFINED</code>, then each such <code>initialLayout</code> <strong>must</strong> be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the <code>framebuffer</code> member of <code>pRenderPassBegin</code> </li> <li id="VUID-vkCmdBeginRenderPass-srcStageMask-00901">  The <code>srcStageMask</code> and <code>dstStageMask</code> members of any element of the <code>pDependencies</code> member of <a href="#VkRenderPassCreateInfo">VkRenderPassCreateInfo</a> used to create <code>renderpass</code> <strong>must</strong> be supported by the capabilities of the queue family identified by the <code>queueFamilyIndex</code> member of the <a href="#VkCommandPoolCreateInfo">VkCommandPoolCreateInfo</a> used to create the command pool which <code>commandBuffer</code> was allocated from. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdBeginRenderPass-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdBeginRenderPass-pRenderPassBegin-parameter">  <code>pRenderPassBegin</code> <strong>must</strong> be a pointer to a valid <code>VkRenderPassBeginInfo</code> structure </li> <li id="VUID-vkCmdBeginRenderPass-contents-parameter">  <code>contents</code> <strong>must</strong> be a valid <a href="#VkSubpassContents">VkSubpassContents</a> value </li> <li id="VUID-vkCmdBeginRenderPass-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdBeginRenderPass-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdBeginRenderPass-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdBeginRenderPass-bufferlevel">  <code>commandBuffer</code> <strong>must</strong> be a primary <code>VkCommandBuffer</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_8">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkRenderPassBeginInfo">VkRenderPassBeginInfo</a>, <a href="#VkSubpassContents">VkSubpassContents</a></p>    <h4 id="_document_notes_8">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBeginRenderPass">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBeginRenderPass</a></p>         <h3 id="_vkcmdbinddescriptorsets_3">vkCmdBindDescriptorSets(3)</h3>  <h4 id="_name_9">Name</h4>  <p>vkCmdBindDescriptorSets - Binds descriptor sets to a command buffer</p>    <h4 id="_c_specification_9">C Specification</h4>  <p>To bind one or more descriptor sets to a command buffer, call:</p>  <pre id="vkCmdBindDescriptorSets" data-language="c++">void vkCmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    const uint32_t*                             pDynamicOffsets);</pre>   <h4 id="_parameters_9">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer that the descriptor sets will be bound to. </li> <li> <code>pipelineBindPoint</code> is a <a href="#VkPipelineBindPoint">VkPipelineBindPoint</a> indicating whether the descriptors will be used by graphics pipelines or compute pipelines. There is a separate set of bind points for each of graphics and compute, so binding one does not disturb the other. </li> <li> <code>layout</code> is a <code>VkPipelineLayout</code> object used to program the bindings. </li> <li> <code>firstSet</code> is the set number of the first descriptor set to be bound. </li> <li> <code>descriptorSetCount</code> is the number of elements in the <code>pDescriptorSets</code> array. </li> <li> <code>pDescriptorSets</code> is an array of handles to <code>VkDescriptorSet</code> objects describing the descriptor sets to write to. </li> <li> <code>dynamicOffsetCount</code> is the number of dynamic offsets in the <code>pDynamicOffsets</code> array. </li> <li> <code>pDynamicOffsets</code> is a pointer to an array of <code>uint32_t</code> values specifying dynamic offsets. </li> </ul>    <h4 id="_description_9">Description</h4>  <p><code>vkCmdBindDescriptorSets</code> causes the sets numbered [<code>firstSet</code>.. <code>firstSet</code>+<code>descriptorSetCount</code>-1] to use the bindings stored in <code>pDescriptorSets</code>[0..<code>descriptorSetCount</code>-1] for subsequent rendering commands (either compute or graphics, according to the <code>pipelineBindPoint</code>). Any bindings that were previously applied via these sets are no longer valid.</p>   <p>Once bound, a descriptor set affects rendering of subsequent graphics or compute commands in the command buffer until a different set is bound to the same set number, or else until the set is disturbed as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">Pipeline Layout Compatibility</a>.</p>   <p>A compatible descriptor set <strong>must</strong> be bound for all set numbers that any shaders in a pipeline access, at the time that a draw or dispatch command is recorded to execute using that pipeline. However, if none of the shaders in a pipeline statically use any bindings with a particular set number, then no descriptor set need be bound for that set number, even if the pipeline layout includes a non-trivial descriptor set layout for that set number.</p>   <p>If any of the sets being bound include dynamic uniform or storage buffers, then <code>pDynamicOffsets</code> includes one element for each array element in each dynamic descriptor type binding in each set. Values are taken from <code>pDynamicOffsets</code> in an order such that all entries for set N come before set N+1; within a set, entries are ordered by the binding numbers in the descriptor set layouts; and within a binding array, elements are in order. <code>dynamicOffsetCount</code> <strong>must</strong> equal the total number of dynamic descriptors in the sets being bound.</p>   <p>The effective offset used for dynamic uniform and storage buffer bindings is the sum of the relative offset taken from <code>pDynamicOffsets</code>, and the base address of the buffer plus base offset in the descriptor set. The length of the dynamic uniform and storage buffer bindings is the buffer range as specified in the descriptor set.</p>   <p>Each of the <code>pDescriptorSets</code> <strong>must</strong> be compatible with the pipeline layout specified by <code>layout</code>. The layout used to program the bindings <strong>must</strong> also be compatible with the pipeline used in subsequent graphics or compute commands, as defined in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">Pipeline Layout Compatibility</a> section.</p>   <p>The descriptor set contents bound by a call to <code>vkCmdBindDescriptorSets</code> <strong>may</strong> be consumed during host execution of the command, or during shader execution of the resulting draws, or any time in between. Thus, the contents <strong>must</strong> not be altered (overwritten by an update command, or freed) between when the command is recorded and when the command completes executing on the queue. The contents of <code>pDynamicOffsets</code> are consumed immediately during execution of <code>vkCmdBindDescriptorSets</code>. Once all pending uses have completed, it is legal to update and reuse a descriptor set.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdBindDescriptorSets-pDescriptorSets-00358">  Any given element of <code>pDescriptorSets</code> <strong>must</strong> have been allocated with a <code>VkDescriptorSetLayout</code> that matches (is the same as, or identically defined as) the <code>VkDescriptorSetLayout</code> at set <em>n</em> in <code>layout</code>, where <em>n</em> is the sum of <code>firstSet</code> and the index into <code>pDescriptorSets</code> </li> <li id="VUID-vkCmdBindDescriptorSets-dynamicOffsetCount-00359">  <code>dynamicOffsetCount</code> <strong>must</strong> be equal to the total number of dynamic descriptors in <code>pDescriptorSets</code> </li> <li id="VUID-vkCmdBindDescriptorSets-firstSet-00360">  The sum of <code>firstSet</code> and <code>descriptorSetCount</code> <strong>must</strong> be less than or equal to <code>VkPipelineLayoutCreateInfo</code>::<code>setLayoutCount</code> provided when <code>layout</code> was created </li> <li id="VUID-vkCmdBindDescriptorSets-pipelineBindPoint-00361">  <code>pipelineBindPoint</code> <strong>must</strong> be supported by the <code>commandBuffer</code>’s parent <code>VkCommandPool</code>’s queue family </li> <li id="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-00362">  Any given element of <code>pDynamicOffsets</code> <strong>must</strong> satisfy the required alignment for the corresponding descriptor binding’s descriptor type </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdBindDescriptorSets-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter">  <code>pipelineBindPoint</code> <strong>must</strong> be a valid <a href="#VkPipelineBindPoint">VkPipelineBindPoint</a> value </li> <li id="VUID-vkCmdBindDescriptorSets-layout-parameter">  <code>layout</code> <strong>must</strong> be a valid <code>VkPipelineLayout</code> handle </li> <li id="VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter">  <code>pDescriptorSets</code> <strong>must</strong> be a pointer to an array of <code>descriptorSetCount</code> valid <code>VkDescriptorSet</code> handles </li> <li id="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter">  If <code>dynamicOffsetCount</code> is not <code>0</code>, <code>pDynamicOffsets</code> <strong>must</strong> be a pointer to an array of <code>dynamicOffsetCount</code> <code>uint32_t</code> values </li> <li id="VUID-vkCmdBindDescriptorSets-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdBindDescriptorSets-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength">  <code>descriptorSetCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdBindDescriptorSets-commonparent">  Each of <code>commandBuffer</code>, <code>layout</code>, and the elements of <code>pDescriptorSets</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_9">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkDescriptorSet">VkDescriptorSet</a>, <a href="#VkPipelineBindPoint">VkPipelineBindPoint</a>, <a href="#VkPipelineLayout">VkPipelineLayout</a></p>    <h4 id="_document_notes_9">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBindDescriptorSets">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBindDescriptorSets</a></p>         <h3 id="_vkcmdbindindexbuffer_3">vkCmdBindIndexBuffer(3)</h3>  <h4 id="_name_10">Name</h4>  <p>vkCmdBindIndexBuffer - Bind an index buffer to a command buffer</p>    <h4 id="_c_specification_10">C Specification</h4>  <p>To bind an index buffer to a command buffer, call:</p>  <pre id="vkCmdBindIndexBuffer" data-language="c++">void vkCmdBindIndexBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType);</pre>   <h4 id="_parameters_10">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command is recorded. </li> <li> <code>buffer</code> is the buffer being bound. </li> <li> <code>offset</code> is the starting offset in bytes within <code>buffer</code> used in index buffer address calculations. </li> <li> <code>indexType</code> is a <a href="#VkIndexType">VkIndexType</a> value specifying whether indices are treated as 16 bits or 32 bits. </li> </ul>    <h4 id="_description_10">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdBindIndexBuffer-offset-00431">  <code>offset</code> <strong>must</strong> be less than the size of <code>buffer</code> </li> <li id="VUID-vkCmdBindIndexBuffer-offset-00432">  The sum of <code>offset</code> and the address of the range of <code>VkDeviceMemory</code> object that is backing <code>buffer</code>, <strong>must</strong> be a multiple of the type indicated by <code>indexType</code> </li> <li id="VUID-vkCmdBindIndexBuffer-buffer-00433">  <code>buffer</code> <strong>must</strong> have been created with the <code>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</code> flag </li> <li id="VUID-vkCmdBindIndexBuffer-buffer-00434">  If <code>buffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdBindIndexBuffer-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdBindIndexBuffer-buffer-parameter">  <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdBindIndexBuffer-indexType-parameter">  <code>indexType</code> <strong>must</strong> be a valid <a href="#VkIndexType">VkIndexType</a> value </li> <li id="VUID-vkCmdBindIndexBuffer-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdBindIndexBuffer-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdBindIndexBuffer-commonparent">  Both of <code>buffer</code>, and <code>commandBuffer</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_10">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <code>VkDeviceSize</code>, <a href="#VkIndexType">VkIndexType</a></p>    <h4 id="_document_notes_10">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBindIndexBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBindIndexBuffer</a></p>         <h3 id="_vkcmdbindpipeline_3">vkCmdBindPipeline(3)</h3>  <h4 id="_name_11">Name</h4>  <p>vkCmdBindPipeline - Bind a pipeline object to a command buffer</p>    <h4 id="_c_specification_11">C Specification</h4>  <p>Once a pipeline has been created, it <strong>can</strong> be bound to the command buffer using the command:</p>  <pre id="vkCmdBindPipeline" data-language="c++">void vkCmdBindPipeline(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline);</pre>   <h4 id="_parameters_11">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer that the pipeline will be bound to. </li> <li> <code>pipelineBindPoint</code> is a <a href="#VkPipelineBindPoint">VkPipelineBindPoint</a> value specifying whether to bind to the compute or graphics bind point. Binding one does not disturb the other. </li> <li> <code>pipeline</code> is the pipeline to be bound. </li> </ul>    <h4 id="_description_11">Description</h4>  <p>Once bound, a pipeline binding affects subsequent graphics or compute commands in the command buffer until a different pipeline is bound to the bind point. The pipeline bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> controls the behavior of <a href="#vkCmdDispatch">vkCmdDispatch</a> and <a href="#vkCmdDispatchIndirect">vkCmdDispatchIndirect</a>. The pipeline bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> controls the behavior of <a href="#vkCmdDraw">vkCmdDraw</a>, <a href="#vkCmdDrawIndexed">vkCmdDrawIndexed</a>, <a href="#vkCmdDrawIndirect">vkCmdDrawIndirect</a>, and <a href="#vkCmdDrawIndexedIndirect">vkCmdDrawIndexedIndirect</a>. No other commands are affected by the pipeline state.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdBindPipeline-pipelineBindPoint-00777">  If <code>pipelineBindPoint</code> is <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>, the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support compute operations </li> <li id="VUID-vkCmdBindPipeline-pipelineBindPoint-00778">  If <code>pipelineBindPoint</code> is <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdBindPipeline-pipelineBindPoint-00779">  If <code>pipelineBindPoint</code> is <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>, <code>pipeline</code> <strong>must</strong> be a compute pipeline </li> <li id="VUID-vkCmdBindPipeline-pipelineBindPoint-00780">  If <code>pipelineBindPoint</code> is <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, <code>pipeline</code> <strong>must</strong> be a graphics pipeline </li> <li id="VUID-vkCmdBindPipeline-pipeline-00781">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-variableMultisampleRate">variable multisample rate</a> feature is not supported, <code>pipeline</code> is a graphics pipeline, the current subpass has no attachments, and this is not the first call to this function with a graphics pipeline after transitioning to the current subpass, then the sample count specified by this pipeline <strong>must</strong> match that set in the previous pipeline </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdBindPipeline-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdBindPipeline-pipelineBindPoint-parameter">  <code>pipelineBindPoint</code> <strong>must</strong> be a valid <a href="#VkPipelineBindPoint">VkPipelineBindPoint</a> value </li> <li id="VUID-vkCmdBindPipeline-pipeline-parameter">  <code>pipeline</code> <strong>must</strong> be a valid <code>VkPipeline</code> handle </li> <li id="VUID-vkCmdBindPipeline-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdBindPipeline-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdBindPipeline-commonparent">  Both of <code>commandBuffer</code>, and <code>pipeline</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_11">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkPipeline">VkPipeline</a>, <a href="#VkPipelineBindPoint">VkPipelineBindPoint</a></p>    <h4 id="_document_notes_11">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBindPipeline">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBindPipeline</a></p>         <h3 id="_vkcmdbindvertexbuffers_3">vkCmdBindVertexBuffers(3)</h3>  <h4 id="_name_12">Name</h4>  <p>vkCmdBindVertexBuffers - Bind vertex buffers to a command buffer</p>    <h4 id="_c_specification_12">C Specification</h4>  <p>To bind vertex buffers to a command buffer for use in subsequent draw commands, call:</p>  <pre id="vkCmdBindVertexBuffers" data-language="c++">void vkCmdBindVertexBuffers(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const VkBuffer*                             pBuffers,
    const VkDeviceSize*                         pOffsets);</pre>   <h4 id="_parameters_12">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command is recorded. </li> <li> <code>firstBinding</code> is the index of the first vertex input binding whose state is updated by the command. </li> <li> <code>bindingCount</code> is the number of vertex input bindings whose state is updated by the command. </li> <li> <code>pBuffers</code> is a pointer to an array of buffer handles. </li> <li> <code>pOffsets</code> is a pointer to an array of buffer offsets. </li> </ul>    <h4 id="_description_12">Description</h4>  <p>The values taken from elements i of <code>pBuffers</code> and <code>pOffsets</code> replace the current state for the vertex input binding <code>firstBinding</code> + i, for i in [0, <code>bindingCount</code>). The vertex input binding is updated to start at the offset indicated by <code>pOffsets</code>[i] from the start of the buffer <code>pBuffers</code>[i]. All vertex input attributes that use each of these bindings will use these updated addresses in their address calculations for subsequent draw commands.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdBindVertexBuffers-firstBinding-00624">  <code>firstBinding</code> <strong>must</strong> be less than <code>VkPhysicalDeviceLimits</code>::<code>maxVertexInputBindings</code> </li> <li id="VUID-vkCmdBindVertexBuffers-firstBinding-00625">  The sum of <code>firstBinding</code> and <code>bindingCount</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxVertexInputBindings</code> </li> <li id="VUID-vkCmdBindVertexBuffers-pOffsets-00626">  All elements of <code>pOffsets</code> <strong>must</strong> be less than the size of the corresponding element in <code>pBuffers</code> </li> <li id="VUID-vkCmdBindVertexBuffers-pBuffers-00627">  All elements of <code>pBuffers</code> <strong>must</strong> have been created with the <code>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</code> flag </li> <li id="VUID-vkCmdBindVertexBuffers-pBuffers-00628">  Each element of <code>pBuffers</code> that is non-sparse <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdBindVertexBuffers-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdBindVertexBuffers-pBuffers-parameter">  <code>pBuffers</code> <strong>must</strong> be a pointer to an array of <code>bindingCount</code> valid <code>VkBuffer</code> handles </li> <li id="VUID-vkCmdBindVertexBuffers-pOffsets-parameter">  <code>pOffsets</code> <strong>must</strong> be a pointer to an array of <code>bindingCount</code> <code>VkDeviceSize</code> values </li> <li id="VUID-vkCmdBindVertexBuffers-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdBindVertexBuffers-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdBindVertexBuffers-bindingCount-arraylength">  <code>bindingCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdBindVertexBuffers-commonparent">  Both of <code>commandBuffer</code>, and the elements of <code>pBuffers</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_12">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <code>VkDeviceSize</code></p>    <h4 id="_document_notes_12">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBindVertexBuffers">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBindVertexBuffers</a></p>         <h3 id="_vkcmdblitimage_3">vkCmdBlitImage(3)</h3>  <h4 id="_name_13">Name</h4>  <p>vkCmdBlitImage - Copy regions of an image, potentially performing format conversion,</p>    <h4 id="_c_specification_13">C Specification</h4>  <p>To copy regions of a source image into a destination image, potentially performing format conversion, arbitrary scaling, and filtering, call:</p>  <pre id="vkCmdBlitImage" data-language="c++">void vkCmdBlitImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageBlit*                          pRegions,
    VkFilter                                    filter);</pre>   <h4 id="_parameters_13">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>srcImage</code> is the source image. </li> <li> <code>srcImageLayout</code> is the layout of the source image subresources for the blit. </li> <li> <code>dstImage</code> is the destination image. </li> <li> <code>dstImageLayout</code> is the layout of the destination image subresources for the blit. </li> <li> <code>regionCount</code> is the number of regions to blit. </li> <li> <code>pRegions</code> is a pointer to an array of <a href="#VkImageBlit">VkImageBlit</a> structures specifying the regions to blit. </li> <li> <code>filter</code> is a <a href="#VkFilter">VkFilter</a> specifying the filter to apply if the blits require scaling. </li> </ul>    <h4 id="_description_13">Description</h4>  <p><code>vkCmdBlitImage</code> <strong>must</strong> not be used for multisampled source or destination images. Use <a href="#vkCmdResolveImage">vkCmdResolveImage</a> for this purpose.</p>   <p>As the sizes of the source and destination extents <strong>can</strong> differ in any dimension, texels in the source extent are scaled and filtered to the destination extent. Scaling occurs via the following operations:</p>   <ul> <li> <p>For each destination texel, the integer coordinate of that texel is converted to an unnormalized texture coordinate, using the effective inverse of the equations described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-unnormalized-to-integer">unnormalized to integer conversion</a>:</p> <div class="dlist"> <dl>  <dd> u<sub>base</sub> = i + ½ </dd>  <dd> v<sub>base</sub> = j + ½ </dd>  <dd> w<sub>base</sub> = k + ½ </dd> </dl> </div> </li> <li> <p>These base coordinates are then offset by the first destination offset:</p> <div class="dlist"> <dl>  <dd> u<sub>offset</sub> = u<sub>base</sub> - x<sub>dst0</sub> </dd>  <dd> v<sub>offset</sub> = v<sub>base</sub> - y<sub>dst0</sub> </dd>  <dd> w<sub>offset</sub> = w<sub>base</sub> - z<sub>dst0</sub> </dd>  <dd> a<sub>offset</sub> = a - <code>baseArrayCount</code><sub>dst</sub> </dd> </dl> </div> </li> <li> <p>The scale is determined from the source and destination regions, and applied to the offset coordinates:</p> <div class="dlist"> <dl>  <dd> scale_u = (x<sub>src1</sub> - x<sub>src0</sub>) / (x<sub>dst1</sub> - x<sub>dst0</sub>) </dd>  <dd> scale_v = (y<sub>src1</sub> - y<sub>src0</sub>) / (y<sub>dst1</sub> - y<sub>dst0</sub>) </dd>  <dd> scale_w = (z<sub>src1</sub> - z<sub>src0</sub>) / (z<sub>dst1</sub> - z<sub>dst0</sub>) </dd>  <dd> u<sub>scaled</sub> = u<sub>offset</sub> * scale<sub>u</sub> </dd>  <dd> v<sub>scaled</sub> = v<sub>offset</sub> * scale<sub>v</sub> </dd>  <dd> w<sub>scaled</sub> = w<sub>offset</sub> * scale<sub>w</sub> </dd> </dl> </div> </li> <li> <p>Finally the source offset is added to the scaled coordinates, to determine the final unnormalized coordinates used to sample from <code>srcImage</code>:<br></p> <div class="dlist"> <dl>  <dd> u = u<sub>scaled</sub> + x<sub>src0</sub> </dd>  <dd> v = v<sub>scaled</sub> + y<sub>src0</sub> </dd>  <dd> w = w<sub>scaled</sub> + z<sub>src0</sub> </dd>  <dd> q = <code>mipLevel</code> </dd>  <dd> a = a<sub>offset</sub> + <code>baseArrayCount</code><sub>src</sub> </dd> </dl> </div> </li> </ul>   <p>These coordinates are used to sample from the source image, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures">Image Operations chapter</a>, with the filter mode equal to that of <code>filter</code>, a mipmap mode of <code>VK_SAMPLER_MIPMAP_MODE_NEAREST</code> and an address mode of <code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</code>. Implementations <strong>must</strong> clamp at the edge of the source image, and <strong>may</strong> additionally clamp to the edge of the source region.</p>  <blockquote> <h5 class="title">Note</h5>  <p>Due to allowable rounding errors in the generation of the source texture coordinates, it is not always possible to guarantee exactly which source texels will be sampled for a given blit. As rounding errors are implementation dependent, the exact results of a blitting operation are also implementation dependent.</p>  </blockquote>  <p>Blits are done layer by layer starting with the <code>baseArrayLayer</code> member of <code>srcSubresource</code> for the source and <code>dstSubresource</code> for the destination. <code>layerCount</code> layers are blitted to the destination image.</p>   <p>3D textures are blitted slice by slice. Slices in the source region bounded by <code>srcOffsets</code>[0].<code>z</code> and <code>srcOffsets</code>[1].<code>z</code> are copied to slices in the destination region bounded by <code>dstOffsets</code>[0].<code>z</code> and <code>dstOffsets</code>[1].<code>z</code>. For each destination slice, a source z coordinate is linearly interpolated between <code>srcOffsets</code>[0].<code>z</code> and <code>srcOffsets</code>[1].<code>z</code>. If the <code>filter</code> parameter is <code>VK_FILTER_LINEAR</code> then the value sampled from the source image is taken by doing linear filtering using the interpolated z coordinate. If <code>filter</code> parameter is <code>VK_FILTER_NEAREST</code> then value sampled from the source image is taken from the single nearest slice (with undefined rounding mode).</p>   <p>The following filtering and conversion rules apply:</p>   <ul> <li> Integer formats <strong>can</strong> only be converted to other integer formats with the same signedness. </li> <li> No format conversion is supported between depth/stencil images. The formats <strong>must</strong> match. </li> <li> Format conversions on unorm, snorm, unscaled and packed float formats of the copied aspect of the image are performed by first converting the pixels to float values. </li> <li> For sRGB source formats, nonlinear RGB values are converted to linear representation prior to filtering. </li> <li> After filtering, the float values are first clamped and then cast to the destination image format. In case of sRGB destination format, linear RGB values are converted to nonlinear representation before writing the pixel to the image. </li> </ul>   <p>Signed and unsigned integers are converted by first clamping to the representable range of the destination format, then casting the value.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdBlitImage-pRegions-00215">  The source region specified by a given element of <code>pRegions</code> <strong>must</strong> be a region that is contained within <code>srcImage</code> </li> <li id="VUID-vkCmdBlitImage-pRegions-00216">  The destination region specified by a given element of <code>pRegions</code> <strong>must</strong> be a region that is contained within <code>dstImage</code> </li> <li id="VUID-vkCmdBlitImage-pRegions-00217">  The union of all destination regions, specified by the elements of <code>pRegions</code>, <strong>must</strong> not overlap in memory with any texel that <strong>may</strong> be sampled during the blit operation </li> <li id="VUID-vkCmdBlitImage-srcImage-00218">  <code>srcImage</code> <strong>must</strong> use a format that supports <code>VK_FORMAT_FEATURE_BLIT_SRC_BIT</code>, which is indicated by <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for linearly tiled images) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> (for optimally tiled images) - as returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-vkCmdBlitImage-srcImage-00219">  <code>srcImage</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> usage flag </li> <li id="VUID-vkCmdBlitImage-srcImage-00220">  If <code>srcImage</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdBlitImage-srcImageLayout-00221">  <code>srcImageLayout</code> <strong>must</strong> specify the layout of the image subresources of <code>srcImage</code> specified in <code>pRegions</code> at the time this command is executed on a <code>VkDevice</code> </li> <li id="VUID-vkCmdBlitImage-srcImageLayout-00222">  <code>srcImageLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-vkCmdBlitImage-dstImage-00223">  <code>dstImage</code> <strong>must</strong> use a format that supports <code>VK_FORMAT_FEATURE_BLIT_DST_BIT</code>, which is indicated by <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for linearly tiled images) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> (for optimally tiled images) - as returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-vkCmdBlitImage-dstImage-00224">  <code>dstImage</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> usage flag </li> <li id="VUID-vkCmdBlitImage-dstImage-00225">  If <code>dstImage</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdBlitImage-dstImageLayout-00226">  <code>dstImageLayout</code> <strong>must</strong> specify the layout of the image subresources of <code>dstImage</code> specified in <code>pRegions</code> at the time this command is executed on a <code>VkDevice</code> </li> <li id="VUID-vkCmdBlitImage-dstImageLayout-00227">  <code>dstImageLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-vkCmdBlitImage-srcImage-00228">  The sample count of <code>srcImage</code> and <code>dstImage</code> <strong>must</strong> both be equal to <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li id="VUID-vkCmdBlitImage-srcImage-00229">  If either of <code>srcImage</code> or <code>dstImage</code> was created with a signed integer <a href="#VkFormat">VkFormat</a>, the other <strong>must</strong> also have been created with a signed integer <a href="#VkFormat">VkFormat</a> </li> <li id="VUID-vkCmdBlitImage-srcImage-00230">  If either of <code>srcImage</code> or <code>dstImage</code> was created with an unsigned integer <a href="#VkFormat">VkFormat</a>, the other <strong>must</strong> also have been created with an unsigned integer <a href="#VkFormat">VkFormat</a> </li> <li id="VUID-vkCmdBlitImage-srcImage-00231">  If either of <code>srcImage</code> or <code>dstImage</code> was created with a depth/stencil format, the other <strong>must</strong> have exactly the same format </li> <li id="VUID-vkCmdBlitImage-srcImage-00232">  If <code>srcImage</code> was created with a depth/stencil format, <code>filter</code> <strong>must</strong> be <code>VK_FILTER_NEAREST</code> </li> <li id="VUID-vkCmdBlitImage-srcImage-00233">  <code>srcImage</code> <strong>must</strong> have been created with a <code>samples</code> value of <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li id="VUID-vkCmdBlitImage-dstImage-00234">  <code>dstImage</code> <strong>must</strong> have been created with a <code>samples</code> value of <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li id="VUID-vkCmdBlitImage-filter-00235">  If <code>filter</code> is <code>VK_FILTER_LINEAR</code>, <code>srcImage</code> <strong>must</strong> be of a format which supports linear filtering, as specified by the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for a linear image) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code>(for an optimally tiled image) returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdBlitImage-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdBlitImage-srcImage-parameter">  <code>srcImage</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkCmdBlitImage-srcImageLayout-parameter">  <code>srcImageLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-vkCmdBlitImage-dstImage-parameter">  <code>dstImage</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkCmdBlitImage-dstImageLayout-parameter">  <code>dstImageLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-vkCmdBlitImage-pRegions-parameter">  <code>pRegions</code> <strong>must</strong> be a pointer to an array of <code>regionCount</code> valid <code>VkImageBlit</code> structures </li> <li id="VUID-vkCmdBlitImage-filter-parameter">  <code>filter</code> <strong>must</strong> be a valid <a href="#VkFilter">VkFilter</a> value </li> <li id="VUID-vkCmdBlitImage-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdBlitImage-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdBlitImage-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdBlitImage-regionCount-arraylength">  <code>regionCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdBlitImage-commonparent">  Each of <code>commandBuffer</code>, <code>dstImage</code>, and <code>srcImage</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_13">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkFilter">VkFilter</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageBlit">VkImageBlit</a>, <a href="#VkImageLayout">VkImageLayout</a></p>    <h4 id="_document_notes_13">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBlitImage">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdBlitImage</a></p>         <h3 id="_vkcmdclearattachments_3">vkCmdClearAttachments(3)</h3>  <h4 id="_name_14">Name</h4>  <p>vkCmdClearAttachments - Clear regions within currently bound framebuffer attachments</p>    <h4 id="_c_specification_14">C Specification</h4>  <p>To clear one or more regions of color and depth/stencil attachments inside a render pass instance, call:</p>  <pre id="vkCmdClearAttachments" data-language="c++">void vkCmdClearAttachments(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    attachmentCount,
    const VkClearAttachment*                    pAttachments,
    uint32_t                                    rectCount,
    const VkClearRect*                          pRects);</pre>   <h4 id="_parameters_14">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>attachmentCount</code> is the number of entries in the <code>pAttachments</code> array. </li> <li> <code>pAttachments</code> is a pointer to an array of <a href="#VkClearAttachment">VkClearAttachment</a> structures defining the attachments to clear and the clear values to use. </li> <li> <code>rectCount</code> is the number of entries in the <code>pRects</code> array. </li> <li> <code>pRects</code> points to an array of <a href="#VkClearRect">VkClearRect</a> structures defining regions within each selected attachment to clear. </li> </ul>    <h4 id="_description_14">Description</h4>  <p><code>vkCmdClearAttachments</code> <strong>can</strong> clear multiple regions of each attachment used in the current subpass of a render pass instance. This command <strong>must</strong> be called only inside a render pass instance, and implicitly selects the images to clear based on the current framebuffer attachments and the command parameters.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdClearAttachments-aspectMask-00015">  If the <code>aspectMask</code> member of any given element of <code>pAttachments</code> contains <code>VK_IMAGE_ASPECT_COLOR_BIT</code>, the <code>colorAttachment</code> member of those elements <strong>must</strong> refer to a valid color attachment in the current subpass </li> <li id="VUID-vkCmdClearAttachments-pRects-00016">  The rectangular region specified by a given element of <code>pRects</code> <strong>must</strong> be contained within the render area of the current render pass instance </li> <li id="VUID-vkCmdClearAttachments-pRects-00017">  The layers specified by a given element of <code>pRects</code> <strong>must</strong> be contained within every attachment that <code>pAttachments</code> refers to </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdClearAttachments-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdClearAttachments-pAttachments-parameter">  <code>pAttachments</code> <strong>must</strong> be a pointer to an array of <code>attachmentCount</code> valid <code>VkClearAttachment</code> structures </li> <li id="VUID-vkCmdClearAttachments-pRects-parameter">  <code>pRects</code> <strong>must</strong> be a pointer to an array of <code>rectCount</code> <code>VkClearRect</code> structures </li> <li id="VUID-vkCmdClearAttachments-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdClearAttachments-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdClearAttachments-renderpass">  This command <strong>must</strong> only be called inside of a render pass instance </li> <li id="VUID-vkCmdClearAttachments-attachmentCount-arraylength">  <code>attachmentCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdClearAttachments-rectCount-arraylength">  <code>rectCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Inside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_14">See Also</h4>  <p><a href="#VkClearAttachment">VkClearAttachment</a>, <a href="#VkClearRect">VkClearRect</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_14">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdClearAttachments">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdClearAttachments</a></p>         <h3 id="_vkcmdclearcolorimage_3">vkCmdClearColorImage(3)</h3>  <h4 id="_name_15">Name</h4>  <p>vkCmdClearColorImage - Clear regions of a color image</p>    <h4 id="_c_specification_15">C Specification</h4>  <p>To clear one or more subranges of a color image, call:</p>  <pre id="vkCmdClearColorImage" data-language="c++">void vkCmdClearColorImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearColorValue*                    pColor,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges);</pre>   <h4 id="_parameters_15">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>image</code> is the image to be cleared. </li> <li> <code>imageLayout</code> specifies the current layout of the image subresource ranges to be cleared, and <strong>must</strong> be <code>VK_IMAGE_LAYOUT_GENERAL</code> or <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>. </li> <li> <code>pColor</code> is a pointer to a <a href="#VkClearColorValue">VkClearColorValue</a> structure that contains the values the image subresource ranges will be cleared to (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#clears-values">html/vkspec.html#clears-values</a> below). </li> <li> <code>rangeCount</code> is the number of image subresource range structures in <code>pRanges</code>. </li> <li> <code>pRanges</code> points to an array of <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a> structures that describe a range of mipmap levels, array layers, and aspects to be cleared, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views">Image Views</a>. The <code>aspectMask</code> of all image subresource ranges <strong>must</strong> only include <code>VK_IMAGE_ASPECT_COLOR_BIT</code>. </li> </ul>    <h4 id="_description_15">Description</h4>  <p>Each specified range in <code>pRanges</code> is cleared to the value specified by <code>pColor</code>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdClearColorImage-image-00002">  <code>image</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> usage flag </li> <li id="VUID-vkCmdClearColorImage-image-00003">  If <code>image</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdClearColorImage-imageLayout-00004">  <code>imageLayout</code> <strong>must</strong> specify the layout of the image subresource ranges of <code>image</code> specified in <code>pRanges</code> at the time this command is executed on a <code>VkDevice</code> </li> <li id="VUID-vkCmdClearColorImage-imageLayout-00005">  <code>imageLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-vkCmdClearColorImage-baseMipLevel-01470">  The <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>baseMipLevel</code> members of the elements of the <code>pRanges</code> array <strong>must</strong> each be less than the <code>mipLevels</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-vkCmdClearColorImage-levelCount-01471">  If the <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>levelCount</code> member of any element of the <code>pRanges</code> array is not <code>VK_REMAINING_MIP_LEVELS</code>, it <strong>must</strong> be non-zero and <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>baseMipLevel</code> + <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>levelCount</code> for that element of the <code>pRanges</code> array <strong>must</strong> be less than or equal to the <code>mipLevels</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-vkCmdClearColorImage-baseArrayLayer-01472">  The <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>baseArrayLayer</code> members of the elements of the <code>pRanges</code> array <strong>must</strong> each be less than the <code>arrayLayers</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-vkCmdClearColorImage-layerCount-01473">  If the <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>layerCount</code> member of any element of the <code>pRanges</code> array is not <code>VK_REMAINING_ARRAY_LAYERS</code>, it <strong>must</strong> be non-zero and <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>baseArrayLayer</code> + <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>layerCount</code> for that element of the <code>pRanges</code> array <strong>must</strong> be less than or equal to the <code>arrayLayers</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-vkCmdClearColorImage-image-00007">  <code>image</code> <strong>must</strong> not have a compressed or depth/stencil format </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdClearColorImage-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdClearColorImage-image-parameter">  <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkCmdClearColorImage-imageLayout-parameter">  <code>imageLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-vkCmdClearColorImage-pColor-parameter">  <code>pColor</code> <strong>must</strong> be a pointer to a valid <code>VkClearColorValue</code> union </li> <li id="VUID-vkCmdClearColorImage-pRanges-parameter">  <code>pRanges</code> <strong>must</strong> be a pointer to an array of <code>rangeCount</code> valid <code>VkImageSubresourceRange</code> structures </li> <li id="VUID-vkCmdClearColorImage-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdClearColorImage-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdClearColorImage-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdClearColorImage-rangeCount-arraylength">  <code>rangeCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdClearColorImage-commonparent">  Both of <code>commandBuffer</code>, and <code>image</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_15">See Also</h4>  <p><a href="#VkClearColorValue">VkClearColorValue</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageLayout">VkImageLayout</a>, <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a></p>    <h4 id="_document_notes_15">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdClearColorImage">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdClearColorImage</a></p>         <h3 id="_vkcmdcleardepthstencilimage_3">vkCmdClearDepthStencilImage(3)</h3>  <h4 id="_name_16">Name</h4>  <p>vkCmdClearDepthStencilImage - Fill regions of a combined depth/stencil image</p>    <h4 id="_c_specification_16">C Specification</h4>  <p>To clear one or more subranges of a depth/stencil image, call:</p>  <pre id="vkCmdClearDepthStencilImage" data-language="c++">void vkCmdClearDepthStencilImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearDepthStencilValue*             pDepthStencil,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges);</pre>   <h4 id="_parameters_16">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>image</code> is the image to be cleared. </li> <li> <code>imageLayout</code> specifies the current layout of the image subresource ranges to be cleared, and <strong>must</strong> be <code>VK_IMAGE_LAYOUT_GENERAL</code> or <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>. </li> <li> <code>pDepthStencil</code> is a pointer to a <a href="#VkClearDepthStencilValue">VkClearDepthStencilValue</a> structure that contains the values the depth and stencil image subresource ranges will be cleared to (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#clears-values">html/vkspec.html#clears-values</a> below). </li> <li> <code>rangeCount</code> is the number of image subresource range structures in <code>pRanges</code>. </li> <li> <code>pRanges</code> points to an array of <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a> structures that describe a range of mipmap levels, array layers, and aspects to be cleared, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views">Image Views</a>. The <code>aspectMask</code> of each image subresource range in <code>pRanges</code> <strong>can</strong> include <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> if the image format has a depth component, and <code>VK_IMAGE_ASPECT_STENCIL_BIT</code> if the image format has a stencil component. <code>pDepthStencil</code> is a pointer to a <code>VkClearDepthStencilValue</code> structure that contains the values the image subresource ranges will be cleared to (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#clears-values">html/vkspec.html#clears-values</a> below). </li> </ul>    <h4 id="_description_16">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdClearDepthStencilImage-image-00009">  <code>image</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> usage flag </li> <li id="VUID-vkCmdClearDepthStencilImage-image-00010">  If <code>image</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdClearDepthStencilImage-imageLayout-00011">  <code>imageLayout</code> <strong>must</strong> specify the layout of the image subresource ranges of <code>image</code> specified in <code>pRanges</code> at the time this command is executed on a <code>VkDevice</code> </li> <li id="VUID-vkCmdClearDepthStencilImage-imageLayout-00012">  <code>imageLayout</code> <strong>must</strong> be either of <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-vkCmdClearDepthStencilImage-baseMipLevel-01474">  The <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>baseMipLevel</code> members of the elements of the <code>pRanges</code> array <strong>must</strong> each be less than the <code>mipLevels</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-vkCmdClearDepthStencilImage-levelCount-01475">  If the <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>levelCount</code> member of any element of the <code>pRanges</code> array is not <code>VK_REMAINING_MIP_LEVELS</code>, it <strong>must</strong> be non-zero and <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>baseMipLevel</code> + <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>levelCount</code> for that element of the <code>pRanges</code> array <strong>must</strong> be less than or equal to the <code>mipLevels</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-vkCmdClearDepthStencilImage-baseArrayLayer-01476">  The <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>baseArrayLayer</code> members of the elements of the <code>pRanges</code> array <strong>must</strong> each be less than the <code>arrayLayers</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-vkCmdClearDepthStencilImage-layerCount-01477">  If the <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>layerCount</code> member of any element of the <code>pRanges</code> array is not <code>VK_REMAINING_ARRAY_LAYERS</code>, it <strong>must</strong> be non-zero and <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>baseArrayLayer</code> + <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>::<code>layerCount</code> for that element of the <code>pRanges</code> array <strong>must</strong> be less than or equal to the <code>arrayLayers</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-vkCmdClearDepthStencilImage-image-00014">  <code>image</code> <strong>must</strong> have a depth/stencil format </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdClearDepthStencilImage-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdClearDepthStencilImage-image-parameter">  <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkCmdClearDepthStencilImage-imageLayout-parameter">  <code>imageLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-vkCmdClearDepthStencilImage-pDepthStencil-parameter">  <code>pDepthStencil</code> <strong>must</strong> be a pointer to a valid <code>VkClearDepthStencilValue</code> structure </li> <li id="VUID-vkCmdClearDepthStencilImage-pRanges-parameter">  <code>pRanges</code> <strong>must</strong> be a pointer to an array of <code>rangeCount</code> valid <code>VkImageSubresourceRange</code> structures </li> <li id="VUID-vkCmdClearDepthStencilImage-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdClearDepthStencilImage-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdClearDepthStencilImage-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdClearDepthStencilImage-rangeCount-arraylength">  <code>rangeCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdClearDepthStencilImage-commonparent">  Both of <code>commandBuffer</code>, and <code>image</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_16">See Also</h4>  <p><a href="#VkClearDepthStencilValue">VkClearDepthStencilValue</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageLayout">VkImageLayout</a>, <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a></p>    <h4 id="_document_notes_16">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdClearDepthStencilImage">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdClearDepthStencilImage</a></p>         <h3 id="_vkcmdcopybuffer_3">vkCmdCopyBuffer(3)</h3>  <h4 id="_name_17">Name</h4>  <p>vkCmdCopyBuffer - Copy data between buffer regions</p>    <h4 id="_c_specification_17">C Specification</h4>  <p>To copy data between buffer objects, call:</p>  <pre id="vkCmdCopyBuffer" data-language="c++">void vkCmdCopyBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferCopy*                         pRegions);</pre>   <h4 id="_parameters_17">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>srcBuffer</code> is the source buffer. </li> <li> <code>dstBuffer</code> is the destination buffer. </li> <li> <code>regionCount</code> is the number of regions to copy. </li> <li> <code>pRegions</code> is a pointer to an array of <a href="#VkBufferCopy">VkBufferCopy</a> structures specifying the regions to copy. </li> </ul>    <h4 id="_description_17">Description</h4>  <p>Each region in <code>pRegions</code> is copied from the source buffer to the same region of the destination buffer. <code>srcBuffer</code> and <code>dstBuffer</code> <strong>can</strong> be the same buffer or alias the same memory, but the result is undefined if the copy regions overlap in memory.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdCopyBuffer-size-00112">  The <code>size</code> member of a given element of <code>pRegions</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdCopyBuffer-srcOffset-00113">  The <code>srcOffset</code> member of a given element of <code>pRegions</code> <strong>must</strong> be less than the size of <code>srcBuffer</code> </li> <li id="VUID-vkCmdCopyBuffer-dstOffset-00114">  The <code>dstOffset</code> member of a given element of <code>pRegions</code> <strong>must</strong> be less than the size of <code>dstBuffer</code> </li> <li id="VUID-vkCmdCopyBuffer-size-00115">  The <code>size</code> member of a given element of <code>pRegions</code> <strong>must</strong> be less than or equal to the size of <code>srcBuffer</code> minus <code>srcOffset</code> </li> <li id="VUID-vkCmdCopyBuffer-size-00116">  The <code>size</code> member of a given element of <code>pRegions</code> <strong>must</strong> be less than or equal to the size of <code>dstBuffer</code> minus <code>dstOffset</code> </li> <li id="VUID-vkCmdCopyBuffer-pRegions-00117">  The union of the source regions, and the union of the destination regions, specified by the elements of <code>pRegions</code>, <strong>must</strong> not overlap in memory </li> <li id="VUID-vkCmdCopyBuffer-srcBuffer-00118">  <code>srcBuffer</code> <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> usage flag </li> <li id="VUID-vkCmdCopyBuffer-srcBuffer-00119">  If <code>srcBuffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdCopyBuffer-dstBuffer-00120">  <code>dstBuffer</code> <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> usage flag </li> <li id="VUID-vkCmdCopyBuffer-dstBuffer-00121">  If <code>dstBuffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdCopyBuffer-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdCopyBuffer-srcBuffer-parameter">  <code>srcBuffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdCopyBuffer-dstBuffer-parameter">  <code>dstBuffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdCopyBuffer-pRegions-parameter">  <code>pRegions</code> <strong>must</strong> be a pointer to an array of <code>regionCount</code> <code>VkBufferCopy</code> structures </li> <li id="VUID-vkCmdCopyBuffer-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdCopyBuffer-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support transfer, graphics, or compute operations </li> <li id="VUID-vkCmdCopyBuffer-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdCopyBuffer-regionCount-arraylength">  <code>regionCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdCopyBuffer-commonparent">  Each of <code>commandBuffer</code>, <code>dstBuffer</code>, and <code>srcBuffer</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer<br> graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_17">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkBufferCopy">VkBufferCopy</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_17">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdCopyBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdCopyBuffer</a></p>         <h3 id="_vkcmdcopybuffertoimage_3">vkCmdCopyBufferToImage(3)</h3>  <h4 id="_name_18">Name</h4>  <p>vkCmdCopyBufferToImage - Copy data from a buffer into an image</p>    <h4 id="_c_specification_18">C Specification</h4>  <p>To copy data from a buffer object to an image object, call:</p>  <pre id="vkCmdCopyBufferToImage" data-language="c++">void vkCmdCopyBufferToImage(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions);</pre>   <h4 id="_parameters_18">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>srcBuffer</code> is the source buffer. </li> <li> <code>dstImage</code> is the destination image. </li> <li> <code>dstImageLayout</code> is the layout of the destination image subresources for the copy. </li> <li> <code>regionCount</code> is the number of regions to copy. </li> <li> <code>pRegions</code> is a pointer to an array of <a href="#VkBufferImageCopy">VkBufferImageCopy</a> structures specifying the regions to copy. </li> </ul>    <h4 id="_description_18">Description</h4>  <p>Each region in <code>pRegions</code> is copied from the specified region of the source buffer to the specified region of the destination image.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdCopyBufferToImage-pRegions-00171">  The buffer region specified by a given element of <code>pRegions</code> <strong>must</strong> be a region that is contained within <code>srcBuffer</code> </li> <li id="VUID-vkCmdCopyBufferToImage-pRegions-00172">  The image region specified by a given element of <code>pRegions</code> <strong>must</strong> be a region that is contained within <code>dstImage</code> </li> <li id="VUID-vkCmdCopyBufferToImage-pRegions-00173">  The union of all source regions, and the union of all destination regions, specified by the elements of <code>pRegions</code>, <strong>must</strong> not overlap in memory </li> <li id="VUID-vkCmdCopyBufferToImage-srcBuffer-00174">  <code>srcBuffer</code> <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> usage flag </li> <li id="VUID-vkCmdCopyBufferToImage-srcBuffer-00176">  If <code>srcBuffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdCopyBufferToImage-dstImage-00177">  <code>dstImage</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> usage flag </li> <li id="VUID-vkCmdCopyBufferToImage-dstImage-00178">  If <code>dstImage</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdCopyBufferToImage-dstImage-00179">  <code>dstImage</code> <strong>must</strong> have a sample count equal to <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li id="VUID-vkCmdCopyBufferToImage-dstImageLayout-00180">  <code>dstImageLayout</code> <strong>must</strong> specify the layout of the image subresources of <code>dstImage</code> specified in <code>pRegions</code> at the time this command is executed on a <code>VkDevice</code> </li> <li id="VUID-vkCmdCopyBufferToImage-dstImageLayout-00181">  <code>dstImageLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdCopyBufferToImage-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdCopyBufferToImage-srcBuffer-parameter">  <code>srcBuffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdCopyBufferToImage-dstImage-parameter">  <code>dstImage</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkCmdCopyBufferToImage-dstImageLayout-parameter">  <code>dstImageLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-vkCmdCopyBufferToImage-pRegions-parameter">  <code>pRegions</code> <strong>must</strong> be a pointer to an array of <code>regionCount</code> valid <code>VkBufferImageCopy</code> structures </li> <li id="VUID-vkCmdCopyBufferToImage-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdCopyBufferToImage-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support transfer, graphics, or compute operations </li> <li id="VUID-vkCmdCopyBufferToImage-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdCopyBufferToImage-regionCount-arraylength">  <code>regionCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdCopyBufferToImage-commonparent">  Each of <code>commandBuffer</code>, <code>dstImage</code>, and <code>srcBuffer</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer<br> graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_18">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkBufferImageCopy">VkBufferImageCopy</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageLayout">VkImageLayout</a></p>    <h4 id="_document_notes_18">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdCopyBufferToImage">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdCopyBufferToImage</a></p>         <h3 id="_vkcmdcopyimage_3">vkCmdCopyImage(3)</h3>  <h4 id="_name_19">Name</h4>  <p>vkCmdCopyImage - Copy data between images</p>    <h4 id="_c_specification_19">C Specification</h4>  <p>To copy data between image objects, call:</p>  <pre id="vkCmdCopyImage" data-language="c++">void vkCmdCopyImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageCopy*                          pRegions);</pre>   <h4 id="_parameters_19">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>srcImage</code> is the source image. </li> <li> <code>srcImageLayout</code> is the current layout of the source image subresource. </li> <li> <code>dstImage</code> is the destination image. </li> <li> <code>dstImageLayout</code> is the current layout of the destination image subresource. </li> <li> <code>regionCount</code> is the number of regions to copy. </li> <li> <code>pRegions</code> is a pointer to an array of <a href="#VkImageCopy">VkImageCopy</a> structures specifying the regions to copy. </li> </ul>    <h4 id="_description_19">Description</h4>  <p>Each region in <code>pRegions</code> is copied from the source image to the same region of the destination image. <code>srcImage</code> and <code>dstImage</code> <strong>can</strong> be the same image or alias the same memory.</p>   <p>The formats of <code>srcImage</code> and <code>dstImage</code> <strong>must</strong> be compatible. Formats are considered compatible if their element size is the same between both formats. For example, <code>VK_FORMAT_R8G8B8A8_UNORM</code> is compatible with <code>VK_FORMAT_R32_UINT</code> because both texels are 4 bytes in size. Depth/stencil formats <strong>must</strong> match exactly.</p>   <p><code>vkCmdCopyImage</code> allows copying between size-compatible compressed and uncompressed internal formats. Formats are size-compatible if the element size of the uncompressed format is equal to the element size (compressed texel block size) of the compressed format. Such a copy does not perform on-the-fly compression or decompression. When copying from an uncompressed format to a compressed format, each texel of uncompressed data of the source image is copied as a raw value to the corresponding compressed texel block of the destination image. When copying from a compressed format to an uncompressed format, each compressed texel block of the source image is copied as a raw value to the corresponding texel of uncompressed data in the destination image. Thus, for example, it is legal to copy between a 128-bit uncompressed format and a compressed format which has a 128-bit sized compressed texel block representing 4×4 texels (using 8 bits per texel), or between a 64-bit uncompressed format and a compressed format which has a 64-bit sized compressed texel block representing 4×4 texels (using 4 bits per texel).</p>   <p>When copying between compressed and uncompressed formats the <code>extent</code> members represent the texel dimensions of the source image and not the destination. When copying from a compressed image to an uncompressed image the image texel dimensions written to the uncompressed image will be source extent divided by the compressed texel block dimensions. When copying from an uncompressed image to a compressed image the image texel dimensions written to the compressed image will be the source extent multiplied by the compressed texel block dimensions. In both cases the number of bytes read and the number of bytes written will be identical.</p>   <p>Copying to or from block-compressed images is typically done in multiples of the compressed texel block size. For this reason the <code>extent</code> <strong>must</strong> be a multiple of the compressed texel block dimension. There is one exception to this rule which is <strong>required</strong> to handle compressed images created with dimensions that are not a multiple of the compressed texel block dimensions: if the <code>srcImage</code> is compressed, then:</p>   <ul> <li> If <code>extent.width</code> is not a multiple of the compressed texel block width, then (<code>extent.width</code> + <code>srcOffset.x</code>) <strong>must</strong> equal the image subresource width. </li> <li> If <code>extent.height</code> is not a multiple of the compressed texel block height, then (<code>extent.height</code> + <code>srcOffset.y</code>) <strong>must</strong> equal the image subresource height. </li> <li> If <code>extent.depth</code> is not a multiple of the compressed texel block depth, then (<code>extent.depth</code> + <code>srcOffset.z</code>) <strong>must</strong> equal the image subresource depth. </li> </ul>   <p>Similarly, if the <code>dstImage</code> is compressed, then:</p>   <ul> <li> If <code>extent.width</code> is not a multiple of the compressed texel block width, then (<code>extent.width</code> + <code>dstOffset.x</code>) <strong>must</strong> equal the image subresource width. </li> <li> If <code>extent.height</code> is not a multiple of the compressed texel block height, then (<code>extent.height</code> + <code>dstOffset.y</code>) <strong>must</strong> equal the image subresource height. </li> <li> If <code>extent.depth</code> is not a multiple of the compressed texel block depth, then (<code>extent.depth</code> + <code>dstOffset.z</code>) <strong>must</strong> equal the image subresource depth. </li> </ul>   <p>This allows the last compressed texel block of the image in each non-multiple dimension to be included as a source or destination of the copy.</p>   <p><code>vkCmdCopyImage</code> <strong>can</strong> be used to copy image data between multisample images, but both images <strong>must</strong> have the same number of samples.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdCopyImage-pRegions-00122">  The source region specified by a given element of <code>pRegions</code> <strong>must</strong> be a region that is contained within <code>srcImage</code> </li> <li id="VUID-vkCmdCopyImage-pRegions-00123">  The destination region specified by a given element of <code>pRegions</code> <strong>must</strong> be a region that is contained within <code>dstImage</code> </li> <li id="VUID-vkCmdCopyImage-pRegions-00124">  The union of all source regions, and the union of all destination regions, specified by the elements of <code>pRegions</code>, <strong>must</strong> not overlap in memory </li> <li id="VUID-vkCmdCopyImage-srcImage-00126">  <code>srcImage</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> usage flag </li> <li id="VUID-vkCmdCopyImage-srcImage-00127">  If <code>srcImage</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdCopyImage-srcImageLayout-00128">  <code>srcImageLayout</code> <strong>must</strong> specify the layout of the image subresources of <code>srcImage</code> specified in <code>pRegions</code> at the time this command is executed on a <code>VkDevice</code> </li> <li id="VUID-vkCmdCopyImage-srcImageLayout-00129">  <code>srcImageLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-vkCmdCopyImage-dstImage-00131">  <code>dstImage</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> usage flag </li> <li id="VUID-vkCmdCopyImage-dstImage-00132">  If <code>dstImage</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdCopyImage-dstImageLayout-00133">  <code>dstImageLayout</code> <strong>must</strong> specify the layout of the image subresources of <code>dstImage</code> specified in <code>pRegions</code> at the time this command is executed on a <code>VkDevice</code> </li> <li id="VUID-vkCmdCopyImage-dstImageLayout-00134">  <code>dstImageLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-vkCmdCopyImage-srcImage-00135">  The <a href="#VkFormat">VkFormat</a> of each of <code>srcImage</code> and <code>dstImage</code> <strong>must</strong> be compatible, as defined <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#copies-images-format-compatibility">below</a> </li> <li id="VUID-vkCmdCopyImage-srcImage-00136">  The sample count of <code>srcImage</code> and <code>dstImage</code> <strong>must</strong> match </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdCopyImage-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdCopyImage-srcImage-parameter">  <code>srcImage</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkCmdCopyImage-srcImageLayout-parameter">  <code>srcImageLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-vkCmdCopyImage-dstImage-parameter">  <code>dstImage</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkCmdCopyImage-dstImageLayout-parameter">  <code>dstImageLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-vkCmdCopyImage-pRegions-parameter">  <code>pRegions</code> <strong>must</strong> be a pointer to an array of <code>regionCount</code> valid <code>VkImageCopy</code> structures </li> <li id="VUID-vkCmdCopyImage-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdCopyImage-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support transfer, graphics, or compute operations </li> <li id="VUID-vkCmdCopyImage-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdCopyImage-regionCount-arraylength">  <code>regionCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdCopyImage-commonparent">  Each of <code>commandBuffer</code>, <code>dstImage</code>, and <code>srcImage</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer<br> graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_19">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageCopy">VkImageCopy</a>, <a href="#VkImageLayout">VkImageLayout</a></p>    <h4 id="_document_notes_19">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdCopyImage">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdCopyImage</a></p>         <h3 id="_vkcmdcopyimagetobuffer_3">vkCmdCopyImageToBuffer(3)</h3>  <h4 id="_name_20">Name</h4>  <p>vkCmdCopyImageToBuffer - Copy image data into a buffer</p>    <h4 id="_c_specification_20">C Specification</h4>  <p>To copy data from an image object to a buffer object, call:</p>  <pre id="vkCmdCopyImageToBuffer" data-language="c++">void vkCmdCopyImageToBuffer(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions);</pre>   <h4 id="_parameters_20">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>srcImage</code> is the source image. </li> <li> <code>srcImageLayout</code> is the layout of the source image subresources for the copy. </li> <li> <code>dstBuffer</code> is the destination buffer. </li> <li> <code>regionCount</code> is the number of regions to copy. </li> <li> <code>pRegions</code> is a pointer to an array of <a href="#VkBufferImageCopy">VkBufferImageCopy</a> structures specifying the regions to copy. </li> </ul>    <h4 id="_description_20">Description</h4>  <p>Each region in <code>pRegions</code> is copied from the specified region of the source image to the specified region of the destination buffer.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdCopyImageToBuffer-pRegions-00182">  The image region specified by a given element of <code>pRegions</code> <strong>must</strong> be a region that is contained within <code>srcImage</code> </li> <li id="VUID-vkCmdCopyImageToBuffer-pRegions-00183">  The buffer region specified by a given element of <code>pRegions</code> <strong>must</strong> be a region that is contained within <code>dstBuffer</code> </li> <li id="VUID-vkCmdCopyImageToBuffer-pRegions-00184">  The union of all source regions, and the union of all destination regions, specified by the elements of <code>pRegions</code>, <strong>must</strong> not overlap in memory </li> <li id="VUID-vkCmdCopyImageToBuffer-srcImage-00186">  <code>srcImage</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> usage flag </li> <li id="VUID-vkCmdCopyImageToBuffer-srcImage-00187">  If <code>srcImage</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdCopyImageToBuffer-srcImage-00188">  <code>srcImage</code> <strong>must</strong> have a sample count equal to <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li id="VUID-vkCmdCopyImageToBuffer-srcImageLayout-00189">  <code>srcImageLayout</code> <strong>must</strong> specify the layout of the image subresources of <code>srcImage</code> specified in <code>pRegions</code> at the time this command is executed on a <code>VkDevice</code> </li> <li id="VUID-vkCmdCopyImageToBuffer-srcImageLayout-00190">  <code>srcImageLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-vkCmdCopyImageToBuffer-dstBuffer-00191">  <code>dstBuffer</code> <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> usage flag </li> <li id="VUID-vkCmdCopyImageToBuffer-dstBuffer-00192">  If <code>dstBuffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdCopyImageToBuffer-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdCopyImageToBuffer-srcImage-parameter">  <code>srcImage</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkCmdCopyImageToBuffer-srcImageLayout-parameter">  <code>srcImageLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-vkCmdCopyImageToBuffer-dstBuffer-parameter">  <code>dstBuffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdCopyImageToBuffer-pRegions-parameter">  <code>pRegions</code> <strong>must</strong> be a pointer to an array of <code>regionCount</code> valid <code>VkBufferImageCopy</code> structures </li> <li id="VUID-vkCmdCopyImageToBuffer-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdCopyImageToBuffer-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support transfer, graphics, or compute operations </li> <li id="VUID-vkCmdCopyImageToBuffer-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdCopyImageToBuffer-regionCount-arraylength">  <code>regionCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdCopyImageToBuffer-commonparent">  Each of <code>commandBuffer</code>, <code>dstBuffer</code>, and <code>srcImage</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer<br> graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_20">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkBufferImageCopy">VkBufferImageCopy</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageLayout">VkImageLayout</a></p>    <h4 id="_document_notes_20">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdCopyImageToBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdCopyImageToBuffer</a></p>         <h3 id="_vkcmdcopyquerypoolresults_3">vkCmdCopyQueryPoolResults(3)</h3>  <h4 id="_name_21">Name</h4>  <p>vkCmdCopyQueryPoolResults - Copy the results of queries in a query pool to a buffer object</p>    <h4 id="_c_specification_21">C Specification</h4>  <p>To copy query statuses and numerical results directly to buffer memory, call:</p>  <pre id="vkCmdCopyQueryPoolResults" data-language="c++">void vkCmdCopyQueryPoolResults(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);</pre>   <h4 id="_parameters_21">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which this command will be recorded. </li> <li> <code>queryPool</code> is the query pool managing the queries containing the desired results. </li> <li> <code>firstQuery</code> is the initial query index. </li> <li> <code>queryCount</code> is the number of queries. <code>firstQuery</code> and <code>queryCount</code> together define a range of queries. </li> <li> <code>dstBuffer</code> is a <code>VkBuffer</code> object that will receive the results of the copy command. </li> <li> <code>dstOffset</code> is an offset into <code>dstBuffer</code>. </li> <li> <code>stride</code> is the stride in bytes between results for individual queries within <code>dstBuffer</code>. The required size of the backing memory for <code>dstBuffer</code> is determined as described above for <a href="#vkGetQueryPoolResults">vkGetQueryPoolResults</a>. </li> <li> <code>flags</code> is a bitmask of <a href="#VkQueryResultFlagBits">VkQueryResultFlagBits</a> specifying how and when results are returned. </li> </ul>    <h4 id="_description_21">Description</h4>  <p><code>vkCmdCopyQueryPoolResults</code> is guaranteed to see the effect of previous uses of <code>vkCmdResetQueryPool</code> in the same queue, without any additional synchronization. Thus, the results will always reflect the most recent use of the query.</p>   <p><code>flags</code> has the same possible values described above for the <code>flags</code> parameter of <a href="#vkGetQueryPoolResults">vkGetQueryPoolResults</a>, but the different style of execution causes some subtle behavioral differences. Because <code>vkCmdCopyQueryPoolResults</code> executes in order with respect to other query commands, there is less ambiguity about which use of a query is being requested.</p>   <p>If no bits are set in <code>flags</code>, results for all requested queries in the available state are written as 32-bit unsigned integer values, and nothing is written for queries in the unavailable state.</p>   <p>If <code>VK_QUERY_RESULT_64_BIT</code> is set, the results are written as an array of 64-bit unsigned integer values as described for <a href="#vkGetQueryPoolResults">vkGetQueryPoolResults</a>.</p>   <p>If <code>VK_QUERY_RESULT_WAIT_BIT</code> is set, the implementation will wait for each query’s status to be in the available state before retrieving the numerical results for that query. This is guaranteed to reflect the most recent use of the query on the same queue, assuming that the query is not being simultaneously used by other queues. If the query does not become available in a finite amount of time (e.g. due to not issuing a query since the last reset), a <code>VK_ERROR_DEVICE_LOST</code> error <strong>may</strong> occur.</p>   <p>Similarly, if <code>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</code> is set and <code>VK_QUERY_RESULT_WAIT_BIT</code> is not set, the availability is guaranteed to reflect the most recent use of the query on the same queue, assuming that the query is not being simultaneously used by other queues. As with <code>vkGetQueryPoolResults</code>, implementations <strong>must</strong> guarantee that if they return a non-zero availability value, then the numerical results are valid.</p>   <p>If <code>VK_QUERY_RESULT_PARTIAL_BIT</code> is set, <code>VK_QUERY_RESULT_WAIT_BIT</code> is not set, and the query’s status is unavailable, an intermediate result value between zero and the final result value is written for that query.</p>   <p><code>VK_QUERY_RESULT_PARTIAL_BIT</code> <strong>must</strong> not be used if the pool’s <code>queryType</code> is <code>VK_QUERY_TYPE_TIMESTAMP</code>.</p>   <p><code>vkCmdCopyQueryPoolResults</code> is considered to be a transfer operation, and its writes to buffer memory <strong>must</strong> be synchronized using <code>VK_PIPELINE_STAGE_TRANSFER_BIT</code> and <code>VK_ACCESS_TRANSFER_WRITE_BIT</code> before using the results.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdCopyQueryPoolResults-dstOffset-00819">  <code>dstOffset</code> <strong>must</strong> be less than the size of <code>dstBuffer</code> </li> <li id="VUID-vkCmdCopyQueryPoolResults-firstQuery-00820">  <code>firstQuery</code> <strong>must</strong> be less than the number of queries in <code>queryPool</code> </li> <li id="VUID-vkCmdCopyQueryPoolResults-firstQuery-00821">  The sum of <code>firstQuery</code> and <code>queryCount</code> <strong>must</strong> be less than or equal to the number of queries in <code>queryPool</code> </li> <li id="VUID-vkCmdCopyQueryPoolResults-flags-00822">  If <code>VK_QUERY_RESULT_64_BIT</code> is not set in <code>flags</code> then <code>dstOffset</code> and <code>stride</code> <strong>must</strong> be multiples of <code>4</code> </li> <li id="VUID-vkCmdCopyQueryPoolResults-flags-00823">  If <code>VK_QUERY_RESULT_64_BIT</code> is set in <code>flags</code> then <code>dstOffset</code> and <code>stride</code> <strong>must</strong> be multiples of <code>8</code> </li> <li id="VUID-vkCmdCopyQueryPoolResults-dstBuffer-00824">  <code>dstBuffer</code> <strong>must</strong> have enough storage, from <code>dstOffset</code>, to contain the result of each query, as described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-memorylayout">here</a> </li> <li id="VUID-vkCmdCopyQueryPoolResults-dstBuffer-00825">  <code>dstBuffer</code> <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> usage flag </li> <li id="VUID-vkCmdCopyQueryPoolResults-dstBuffer-00826">  If <code>dstBuffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdCopyQueryPoolResults-queryType-00827">  If the <code>queryType</code> used to create <code>queryPool</code> was <code>VK_QUERY_TYPE_TIMESTAMP</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_QUERY_RESULT_PARTIAL_BIT</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdCopyQueryPoolResults-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdCopyQueryPoolResults-queryPool-parameter">  <code>queryPool</code> <strong>must</strong> be a valid <code>VkQueryPool</code> handle </li> <li id="VUID-vkCmdCopyQueryPoolResults-dstBuffer-parameter">  <code>dstBuffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdCopyQueryPoolResults-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkQueryResultFlagBits">VkQueryResultFlagBits</a> values </li> <li id="VUID-vkCmdCopyQueryPoolResults-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdCopyQueryPoolResults-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdCopyQueryPoolResults-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdCopyQueryPoolResults-commonparent">  Each of <code>commandBuffer</code>, <code>dstBuffer</code>, and <code>queryPool</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_21">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <code>VkDeviceSize</code>, <a href="#VkQueryPool">VkQueryPool</a>, <a href="#VkQueryResultFlags">VkQueryResultFlags</a></p>    <h4 id="_document_notes_21">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdCopyQueryPoolResults">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdCopyQueryPoolResults</a></p>         <h3 id="_vkcmddispatch_3">vkCmdDispatch(3)</h3>  <h4 id="_name_22">Name</h4>  <p>vkCmdDispatch - Dispatch compute work items</p>    <h4 id="_c_specification_22">C Specification</h4>  <p>To record a dispatch, call:</p>  <pre id="vkCmdDispatch" data-language="c++">void vkCmdDispatch(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ);</pre>   <h4 id="_parameters_22">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>groupCountX</code> is the number of local workgroups to dispatch in the X dimension. </li> <li> <code>groupCountY</code> is the number of local workgroups to dispatch in the Y dimension. </li> <li> <code>groupCountZ</code> is the number of local workgroups to dispatch in the Z dimension. </li> </ul>    <h4 id="_description_22">Description</h4>  <p>When the command is executed, a global workgroup consisting of groupCountX × groupCountY × groupCountZ local workgroups is assembled.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdDispatch-groupCountX-00386">  <code>groupCountX</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxComputeWorkGroupCount</code>[0] </li> <li id="VUID-vkCmdDispatch-groupCountY-00387">  <code>groupCountY</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxComputeWorkGroupCount</code>[1] </li> <li id="VUID-vkCmdDispatch-groupCountZ-00388">  <code>groupCountZ</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxComputeWorkGroupCount</code>[2] </li> <li id="VUID-vkCmdDispatch-None-00389">  For each set <em>n</em> that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>, a descriptor set <strong>must</strong> have been bound to <em>n</em> at <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>, with a <code>VkPipelineLayout</code> that is compatible for set <em>n</em>, with the <code>VkPipelineLayout</code> used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDispatch-None-00390">  Descriptors in each bound descriptor set, specified via <code>vkCmdBindDescriptorSets</code>, <strong>must</strong> be valid if they are statically used by the currently bound <code>VkPipeline</code> object, specified via <code>vkCmdBindPipeline</code> </li> <li id="VUID-vkCmdDispatch-None-00391">  A valid compute pipeline <strong>must</strong> be bound to the current command buffer with <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> </li> <li id="VUID-vkCmdDispatch-None-00392">  For each push constant that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>, a push constant value <strong>must</strong> have been set for <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>, with a <code>VkPipelineLayout</code> that is compatible for push constants with the one used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDispatch-None-00393">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> uses unnormalized coordinates, it <strong>must</strong> not be used to sample from any <code>VkImage</code> with a <code>VkImageView</code> of the type <code>VK_IMAGE_VIEW_TYPE_3D</code>, <code>VK_IMAGE_VIEW_TYPE_CUBE</code>, <code>VK_IMAGE_VIEW_TYPE_1D_ARRAY</code>, <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code> or <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>, in any shader stage </li> <li id="VUID-vkCmdDispatch-None-00394">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions with <code>ImplicitLod</code>, <code>Dref</code> or <code>Proj</code> in their name, in any shader stage </li> <li id="VUID-vkCmdDispatch-None-00395">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions that includes a LOD bias or any offset values, in any shader stage </li> <li id="VUID-vkCmdDispatch-None-00396">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> accesses a uniform buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDispatch-None-00397">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> accesses a storage buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDispatch-linearTilingFeatures-00398">  Any <code>VkImageView</code> being sampled with <code>VK_FILTER_LINEAR</code> as a result of this command <strong>must</strong> be of a format which supports linear filtering, as specified by the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for a linear image) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code>(for an optimally tiled image) returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdDispatch-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdDispatch-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdDispatch-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support compute operations </li> <li id="VUID-vkCmdDispatch-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Compute</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_22">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_22">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDispatch">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDispatch</a></p>         <h3 id="_vkcmddispatchindirect_3">vkCmdDispatchIndirect(3)</h3>  <h4 id="_name_23">Name</h4>  <p>vkCmdDispatchIndirect - Dispatch compute work items using indirect parameters</p>    <h4 id="_c_specification_23">C Specification</h4>  <p>To record an indirect command dispatch, call:</p>  <pre id="vkCmdDispatchIndirect" data-language="c++">void vkCmdDispatchIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset);</pre>   <h4 id="_parameters_23">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>buffer</code> is the buffer containing dispatch parameters. </li> <li> <code>offset</code> is the byte offset into <code>buffer</code> where parameters begin. </li> </ul>    <h4 id="_description_23">Description</h4>  <p><code>vkCmdDispatchIndirect</code> behaves similarly to <a href="#vkCmdDispatch">vkCmdDispatch</a> except that the parameters are read by the device from a buffer during execution. The parameters of the dispatch are encoded in a <a href="#VkDispatchIndirectCommand">VkDispatchIndirectCommand</a> structure taken from <code>buffer</code> starting at <code>offset</code>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdDispatchIndirect-buffer-00401">  If <code>buffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdDispatchIndirect-None-00402">  For each set <em>n</em> that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>, a descriptor set <strong>must</strong> have been bound to <em>n</em> at <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>, with a <code>VkPipelineLayout</code> that is compatible for set <em>n</em>, with the <code>VkPipelineLayout</code> used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDispatchIndirect-None-00403">  Descriptors in each bound descriptor set, specified via <code>vkCmdBindDescriptorSets</code>, <strong>must</strong> be valid if they are statically used by the currently bound <code>VkPipeline</code> object, specified via <code>vkCmdBindPipeline</code> </li> <li id="VUID-vkCmdDispatchIndirect-None-00404">  A valid compute pipeline <strong>must</strong> be bound to the current command buffer with <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> </li> <li id="VUID-vkCmdDispatchIndirect-buffer-00405">  <code>buffer</code> <strong>must</strong> have been created with the <code>VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT</code> bit set </li> <li id="VUID-vkCmdDispatchIndirect-offset-00406">  <code>offset</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-vkCmdDispatchIndirect-offset-00407">  The sum of <code>offset</code> and the size of <code>VkDispatchIndirectCommand</code> <strong>must</strong> be less than or equal to the size of <code>buffer</code> </li> <li id="VUID-vkCmdDispatchIndirect-None-00408">  For each push constant that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>, a push constant value <strong>must</strong> have been set for <code>VK_PIPELINE_BIND_POINT_COMPUTE</code>, with a <code>VkPipelineLayout</code> that is compatible for push constants with the one used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDispatchIndirect-None-00409">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> uses unnormalized coordinates, it <strong>must</strong> not be used to sample from any <code>VkImage</code> with a <code>VkImageView</code> of the type <code>VK_IMAGE_VIEW_TYPE_3D</code>, <code>VK_IMAGE_VIEW_TYPE_CUBE</code>, <code>VK_IMAGE_VIEW_TYPE_1D_ARRAY</code>, <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code> or <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>, in any shader stage </li> <li id="VUID-vkCmdDispatchIndirect-None-00410">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions with <code>ImplicitLod</code>, <code>Dref</code> or <code>Proj</code> in their name, in any shader stage </li> <li id="VUID-vkCmdDispatchIndirect-None-00411">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions that includes a LOD bias or any offset values, in any shader stage </li> <li id="VUID-vkCmdDispatchIndirect-None-00412">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> accesses a uniform buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDispatchIndirect-None-00413">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> accesses a storage buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDispatchIndirect-linearTilingFeatures-00414">  Any <code>VkImageView</code> being sampled with <code>VK_FILTER_LINEAR</code> as a result of this command <strong>must</strong> be of a format which supports linear filtering, as specified by the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for a linear image) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code>(for an optimally tiled image) returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdDispatchIndirect-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdDispatchIndirect-buffer-parameter">  <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdDispatchIndirect-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdDispatchIndirect-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support compute operations </li> <li id="VUID-vkCmdDispatchIndirect-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdDispatchIndirect-commonparent">  Both of <code>buffer</code>, and <code>commandBuffer</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Compute</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_23">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <code>VkDeviceSize</code></p>    <h4 id="_document_notes_23">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDispatchIndirect">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDispatchIndirect</a></p>         <h3 id="_vkcmddraw_3">vkCmdDraw(3)</h3>  <h4 id="_name_24">Name</h4>  <p>vkCmdDraw - Draw primitives</p>    <h4 id="_c_specification_24">C Specification</h4>  <p>To record a non-indexed draw, call:</p>  <pre id="vkCmdDraw" data-language="c++">void vkCmdDraw(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance);</pre>   <h4 id="_parameters_24">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command is recorded. </li> <li> <code>vertexCount</code> is the number of vertices to draw. </li> <li> <code>instanceCount</code> is the number of instances to draw. </li> <li> <code>firstVertex</code> is the index of the first vertex to draw. </li> <li> <code>firstInstance</code> is the instance ID of the first instance to draw. </li> </ul>    <h4 id="_description_24">Description</h4>  <p>When the command is executed, primitives are assembled using the current primitive topology and <code>vertexCount</code> consecutive vertex indices with the first <code>vertexIndex</code> value equal to <code>firstVertex</code>. The primitives are drawn <code>instanceCount</code> times with <code>instanceIndex</code> starting with <code>firstInstance</code> and increasing sequentially for each instance. The assembled primitives execute the currently bound graphics pipeline.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdDraw-renderPass-00435">  The current render pass <strong>must</strong> be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a> with the <code>renderPass</code> member of the <code>VkGraphicsPipelineCreateInfo</code> structure specified when creating the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>. </li> <li id="VUID-vkCmdDraw-subpass-00436">  The subpass index of the current render pass <strong>must</strong> be equal to the <code>subpass</code> member of the <code>VkGraphicsPipelineCreateInfo</code> structure specified when creating the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>. </li> <li id="VUID-vkCmdDraw-None-00437">  For each set <em>n</em> that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a descriptor set <strong>must</strong> have been bound to <em>n</em> at <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code>VkPipelineLayout</code> that is compatible for set <em>n</em>, with the <code>VkPipelineLayout</code> used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDraw-None-00438">  For each push constant that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a push constant value <strong>must</strong> have been set for <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code>VkPipelineLayout</code> that is compatible for push constants, with the <code>VkPipelineLayout</code> used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDraw-None-00439">  Descriptors in each bound descriptor set, specified via <code>vkCmdBindDescriptorSets</code>, <strong>must</strong> be valid if they are statically used by the currently bound <code>VkPipeline</code> object, specified via <code>vkCmdBindPipeline</code> </li> <li id="VUID-vkCmdDraw-None-00440">  All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface <strong>must</strong> have valid buffers bound </li> <li id="VUID-vkCmdDraw-None-00441">  For a given vertex buffer binding, any attribute data fetched <strong>must</strong> be entirely contained within the corresponding vertex buffer binding, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">html/vkspec.html#fxvertex-input</a> </li> <li id="VUID-vkCmdDraw-None-00442">  A valid graphics pipeline <strong>must</strong> be bound to the current command buffer with <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> </li> <li id="VUID-vkCmdDraw-None-00443">  If the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> requires any dynamic state, that state <strong>must</strong> have been set on the current command buffer </li> <li id="VUID-vkCmdDraw-None-00444">  Every input attachment used by the current subpass <strong>must</strong> be bound to the pipeline via a descriptor set </li> <li id="VUID-vkCmdDraw-None-00445">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used to sample from any <code>VkImage</code> with a <code>VkImageView</code> of the type <code>VK_IMAGE_VIEW_TYPE_3D</code>, <code>VK_IMAGE_VIEW_TYPE_CUBE</code>, <code>VK_IMAGE_VIEW_TYPE_1D_ARRAY</code>, <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code> or <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>, in any shader stage </li> <li id="VUID-vkCmdDraw-None-00446">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions with <code>ImplicitLod</code>, <code>Dref</code> or <code>Proj</code> in their name, in any shader stage </li> <li id="VUID-vkCmdDraw-None-00447">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions that includes a LOD bias or any offset values, in any shader stage </li> <li id="VUID-vkCmdDraw-None-00448">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses a uniform buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDraw-None-00449">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses a storage buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDraw-linearTilingFeatures-00450">  Any <code>VkImageView</code> being sampled with <code>VK_FILTER_LINEAR</code> as a result of this command <strong>must</strong> be of a format which supports linear filtering, as specified by the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for a linear image) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code>(for an optimally tiled image) returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-vkCmdDraw-None-01499">  Image subresources used as attachments in the current render pass <strong>must</strong> not be accessed in any way other than as an attachment by this command. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdDraw-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdDraw-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdDraw-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdDraw-renderpass">  This command <strong>must</strong> only be called inside of a render pass instance </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Inside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_24">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_24">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDraw">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDraw</a></p>         <h3 id="_vkcmddrawindexed_3">vkCmdDrawIndexed(3)</h3>  <h4 id="_name_25">Name</h4>  <p>vkCmdDrawIndexed - Issue an indexed draw into a command buffer</p>    <h4 id="_c_specification_25">C Specification</h4>  <p>To record an indexed draw, call:</p>  <pre id="vkCmdDrawIndexed" data-language="c++">void vkCmdDrawIndexed(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance);</pre>   <h4 id="_parameters_25">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command is recorded. </li> <li> <code>indexCount</code> is the number of vertices to draw. </li> <li> <code>instanceCount</code> is the number of instances to draw. </li> <li> <code>firstIndex</code> is the base index within the index buffer. </li> <li> <code>vertexOffset</code> is the value added to the vertex index before indexing into the vertex buffer. </li> <li> <code>firstInstance</code> is the instance ID of the first instance to draw. </li> </ul>    <h4 id="_description_25">Description</h4>  <p>When the command is executed, primitives are assembled using the current primitive topology and <code>indexCount</code> vertices whose indices are retrieved from the index buffer. The index buffer is treated as an array of tightly packed unsigned integers of size defined by the <a href="#vkCmdBindIndexBuffer">vkCmdBindIndexBuffer</a>::<code>indexType</code> parameter with which the buffer was bound.</p>   <p>The first vertex index is at an offset of <code>firstIndex</code> * <code>indexSize</code> + <code>offset</code> within the currently bound index buffer, where <code>offset</code> is the offset specified by <code>vkCmdBindIndexBuffer</code> and <code>indexSize</code> is the byte size of the type specified by <code>indexType</code>. Subsequent index values are retrieved from consecutive locations in the index buffer. Indices are first compared to the primitive restart value, then zero extended to 32 bits (if the <code>indexType</code> is <code>VK_INDEX_TYPE_UINT16</code>) and have <code>vertexOffset</code> added to them, before being supplied as the <code>vertexIndex</code> value.</p>   <p>The primitives are drawn <code>instanceCount</code> times with <code>instanceIndex</code> starting with <code>firstInstance</code> and increasing sequentially for each instance. The assembled primitives execute the currently bound graphics pipeline.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdDrawIndexed-renderPass-00454">  The current render pass <strong>must</strong> be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a> with the <code>renderPass</code> member of the <code>VkGraphicsPipelineCreateInfo</code> structure specified when creating the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>. </li> <li id="VUID-vkCmdDrawIndexed-subpass-00455">  The subpass index of the current render pass <strong>must</strong> be equal to the <code>subpass</code> member of the <code>VkGraphicsPipelineCreateInfo</code> structure specified when creating the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>. </li> <li id="VUID-vkCmdDrawIndexed-None-00456">  For each set <em>n</em> that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a descriptor set <strong>must</strong> have been bound to <em>n</em> at <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code>VkPipelineLayout</code> that is compatible for set <em>n</em>, with the <code>VkPipelineLayout</code> used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDrawIndexed-None-00457">  For each push constant that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a push constant value <strong>must</strong> have been set for <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code>VkPipelineLayout</code> that is compatible for push constants, with the <code>VkPipelineLayout</code> used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDrawIndexed-None-00458">  Descriptors in each bound descriptor set, specified via <code>vkCmdBindDescriptorSets</code>, <strong>must</strong> be valid if they are statically used by the currently bound <code>VkPipeline</code> object, specified via <code>vkCmdBindPipeline</code> </li> <li id="VUID-vkCmdDrawIndexed-None-00459">  All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface <strong>must</strong> have valid buffers bound </li> <li id="VUID-vkCmdDrawIndexed-None-00460">  For a given vertex buffer binding, any attribute data fetched <strong>must</strong> be entirely contained within the corresponding vertex buffer binding, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">html/vkspec.html#fxvertex-input</a> </li> <li id="VUID-vkCmdDrawIndexed-None-00461">  A valid graphics pipeline <strong>must</strong> be bound to the current command buffer with <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> </li> <li id="VUID-vkCmdDrawIndexed-None-00462">  If the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> requires any dynamic state, that state <strong>must</strong> have been set on the current command buffer </li> <li id="VUID-vkCmdDrawIndexed-indexSize-00463">  (<code>indexSize</code> * (<code>firstIndex</code> + <code>indexCount</code>) + <code>offset</code>) <strong>must</strong> be less than or equal to the size of the currently bound index buffer, with indexSize being based on the type specified by <code>indexType</code>, where the index buffer, <code>indexType</code>, and <code>offset</code> are specified via <code>vkCmdBindIndexBuffer</code> </li> <li id="VUID-vkCmdDrawIndexed-None-00464">  Every input attachment used by the current subpass <strong>must</strong> be bound to the pipeline via a descriptor set </li> <li id="VUID-vkCmdDrawIndexed-None-00465">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used to sample from any <code>VkImage</code> with a <code>VkImageView</code> of the type <code>VK_IMAGE_VIEW_TYPE_3D</code>, <code>VK_IMAGE_VIEW_TYPE_CUBE</code>, <code>VK_IMAGE_VIEW_TYPE_1D_ARRAY</code>, <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code> or <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>, in any shader stage </li> <li id="VUID-vkCmdDrawIndexed-None-00466">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions with <code>ImplicitLod</code>, <code>Dref</code> or <code>Proj</code> in their name, in any shader stage </li> <li id="VUID-vkCmdDrawIndexed-None-00467">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions that includes a LOD bias or any offset values, in any shader stage </li> <li id="VUID-vkCmdDrawIndexed-None-00468">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses a uniform buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDrawIndexed-None-00469">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses a storage buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDrawIndexed-linearTilingFeatures-00470">  Any <code>VkImageView</code> being sampled with <code>VK_FILTER_LINEAR</code> as a result of this command <strong>must</strong> be of a format which supports linear filtering, as specified by the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for a linear image) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code>(for an optimally tiled image) returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-vkCmdDrawIndexed-None-01500">  Image subresources used as attachments in the current render pass <strong>must</strong> not be accessed in any way other than as an attachment by this command. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdDrawIndexed-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdDrawIndexed-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdDrawIndexed-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdDrawIndexed-renderpass">  This command <strong>must</strong> only be called inside of a render pass instance </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Inside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_25">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_25">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDrawIndexed">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDrawIndexed</a></p>         <h3 id="_vkcmddrawindexedindirect_3">vkCmdDrawIndexedIndirect(3)</h3>  <h4 id="_name_26">Name</h4>  <p>vkCmdDrawIndexedIndirect - Perform an indexed indirect draw</p>    <h4 id="_c_specification_26">C Specification</h4>  <p>To record an indexed indirect draw, call:</p>  <pre id="vkCmdDrawIndexedIndirect" data-language="c++">void vkCmdDrawIndexedIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);</pre>   <h4 id="_parameters_26">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command is recorded. </li> <li> <code>buffer</code> is the buffer containing draw parameters. </li> <li> <code>offset</code> is the byte offset into <code>buffer</code> where parameters begin. </li> <li> <code>drawCount</code> is the number of draws to execute, and <strong>can</strong> be zero. </li> <li> <code>stride</code> is the byte stride between successive sets of draw parameters. </li> </ul>    <h4 id="_description_26">Description</h4>  <p><code>vkCmdDrawIndexedIndirect</code> behaves similarly to <a href="#vkCmdDrawIndexed">vkCmdDrawIndexed</a> except that the parameters are read by the device from a buffer during execution. <code>drawCount</code> draws are executed by the command, with parameters taken from <code>buffer</code> starting at <code>offset</code> and increasing by <code>stride</code> bytes for each successive draw. The parameters of each draw are encoded in an array of <a href="#VkDrawIndexedIndirectCommand">VkDrawIndexedIndirectCommand</a> structures. If <code>drawCount</code> is less than or equal to one, <code>stride</code> is ignored.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdDrawIndexedIndirect-buffer-00526">  If <code>buffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdDrawIndexedIndirect-offset-00527">  <code>offset</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-vkCmdDrawIndexedIndirect-drawCount-00528">  If <code>drawCount</code> is greater than <code>1</code>, <code>stride</code> <strong>must</strong> be a multiple of <code>4</code> and <strong>must</strong> be greater than or equal to sizeof(<code>VkDrawIndexedIndirectCommand</code>) </li> <li id="VUID-vkCmdDrawIndexedIndirect-drawCount-00529">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiDrawIndirect">multi-draw indirect</a> feature is not enabled, <code>drawCount</code> <strong>must</strong> be <code>0</code> or <code>1</code> </li> <li id="VUID-vkCmdDrawIndexedIndirect-firstInstance-00530">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a> feature is not enabled, all the <code>firstInstance</code> members of the <code>VkDrawIndexedIndirectCommand</code> structures accessed by this command <strong>must</strong> be <code>0</code> </li> <li id="VUID-vkCmdDrawIndexedIndirect-renderPass-00531">  The current render pass <strong>must</strong> be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a> with the <code>renderPass</code> member of the <code>VkGraphicsPipelineCreateInfo</code> structure specified when creating the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>. </li> <li id="VUID-vkCmdDrawIndexedIndirect-subpass-00532">  The subpass index of the current render pass <strong>must</strong> be equal to the <code>subpass</code> member of the <code>VkGraphicsPipelineCreateInfo</code> structure specified when creating the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>. </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00533">  For each set <em>n</em> that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a descriptor set <strong>must</strong> have been bound to <em>n</em> at <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code>VkPipelineLayout</code> that is compatible for set <em>n</em>, with the <code>VkPipelineLayout</code> used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00534">  For each push constant that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a push constant value <strong>must</strong> have been set for <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code>VkPipelineLayout</code> that is compatible for push constants, with the <code>VkPipelineLayout</code> used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00535">  Descriptors in each bound descriptor set, specified via <code>vkCmdBindDescriptorSets</code>, <strong>must</strong> be valid if they are statically used by the currently bound <code>VkPipeline</code> object, specified via <code>vkCmdBindPipeline</code> </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00536">  All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface <strong>must</strong> have valid buffers bound </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00537">  A valid graphics pipeline <strong>must</strong> be bound to the current command buffer with <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00538">  If the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> requires any dynamic state, that state <strong>must</strong> have been set on the current command buffer </li> <li id="VUID-vkCmdDrawIndexedIndirect-drawCount-00539">  If <code>drawCount</code> is equal to <code>1</code>, (<code>offset</code> + sizeof(<code>VkDrawIndexedIndirectCommand</code>)) <strong>must</strong> be less than or equal to the size of <code>buffer</code> </li> <li id="VUID-vkCmdDrawIndexedIndirect-drawCount-00540">  If <code>drawCount</code> is greater than <code>1</code>, (<code>stride</code> × (<code>drawCount</code> - 1) + <code>offset</code> + sizeof(<code>VkDrawIndexedIndirectCommand</code>)) <strong>must</strong> be less than or equal to the size of <code>buffer</code> </li> <li id="VUID-vkCmdDrawIndexedIndirect-drawCount-00541">  <code>drawCount</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxDrawIndirectCount</code> </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00542">  Every input attachment used by the current subpass <strong>must</strong> be bound to the pipeline via a descriptor set </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00543">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used to sample from any <code>VkImage</code> with a <code>VkImageView</code> of the type <code>VK_IMAGE_VIEW_TYPE_3D</code>, <code>VK_IMAGE_VIEW_TYPE_CUBE</code>, <code>VK_IMAGE_VIEW_TYPE_1D_ARRAY</code>, <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code> or <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>, in any shader stage </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00544">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions with <code>ImplicitLod</code>, <code>Dref</code> or <code>Proj</code> in their name, in any shader stage </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00545">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions that includes a LOD bias or any offset values, in any shader stage </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00546">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses a uniform buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-00547">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses a storage buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDrawIndexedIndirect-linearTilingFeatures-00548">  Any <code>VkImageView</code> being sampled with <code>VK_FILTER_LINEAR</code> as a result of this command <strong>must</strong> be of a format which supports linear filtering, as specified by the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for a linear image) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code>(for an optimally tiled image) returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-vkCmdDrawIndexedIndirect-None-01503">  Image subresources used as attachments in the current render pass <strong>must</strong> not be accessed in any way other than as an attachment by this command. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdDrawIndexedIndirect-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdDrawIndexedIndirect-buffer-parameter">  <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdDrawIndexedIndirect-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdDrawIndexedIndirect-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdDrawIndexedIndirect-renderpass">  This command <strong>must</strong> only be called inside of a render pass instance </li> <li id="VUID-vkCmdDrawIndexedIndirect-commonparent">  Both of <code>buffer</code>, and <code>commandBuffer</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Inside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_26">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <code>VkDeviceSize</code></p>    <h4 id="_document_notes_26">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDrawIndexedIndirect">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDrawIndexedIndirect</a></p>         <h3 id="_vkcmddrawindirect_3">vkCmdDrawIndirect(3)</h3>  <h4 id="_name_27">Name</h4>  <p>vkCmdDrawIndirect - Issue an indirect draw into a command buffer</p>    <h4 id="_c_specification_27">C Specification</h4>  <p>To record a non-indexed indirect draw, call:</p>  <pre id="vkCmdDrawIndirect" data-language="c++">void vkCmdDrawIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);</pre>   <h4 id="_parameters_27">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command is recorded. </li> <li> <code>buffer</code> is the buffer containing draw parameters. </li> <li> <code>offset</code> is the byte offset into <code>buffer</code> where parameters begin. </li> <li> <code>drawCount</code> is the number of draws to execute, and <strong>can</strong> be zero. </li> <li> <code>stride</code> is the byte stride between successive sets of draw parameters. </li> </ul>    <h4 id="_description_27">Description</h4>  <p><code>vkCmdDrawIndirect</code> behaves similarly to <a href="#vkCmdDraw">vkCmdDraw</a> except that the parameters are read by the device from a buffer during execution. <code>drawCount</code> draws are executed by the command, with parameters taken from <code>buffer</code> starting at <code>offset</code> and increasing by <code>stride</code> bytes for each successive draw. The parameters of each draw are encoded in an array of <a href="#VkDrawIndirectCommand">VkDrawIndirectCommand</a> structures. If <code>drawCount</code> is less than or equal to one, <code>stride</code> is ignored.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdDrawIndirect-buffer-00474">  If <code>buffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdDrawIndirect-offset-00475">  <code>offset</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-vkCmdDrawIndirect-drawCount-00476">  If <code>drawCount</code> is greater than <code>1</code>, <code>stride</code> <strong>must</strong> be a multiple of <code>4</code> and <strong>must</strong> be greater than or equal to sizeof(<code>VkDrawIndirectCommand</code>) </li> <li id="VUID-vkCmdDrawIndirect-drawCount-00477">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiDrawIndirect">multi-draw indirect</a> feature is not enabled, <code>drawCount</code> <strong>must</strong> be <code>0</code> or <code>1</code> </li> <li id="VUID-vkCmdDrawIndirect-firstInstance-00478">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a> feature is not enabled, all the <code>firstInstance</code> members of the <code>VkDrawIndirectCommand</code> structures accessed by this command <strong>must</strong> be <code>0</code> </li> <li id="VUID-vkCmdDrawIndirect-renderPass-00479">  The current render pass <strong>must</strong> be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a> with the <code>renderPass</code> member of the <code>VkGraphicsPipelineCreateInfo</code> structure specified when creating the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>. </li> <li id="VUID-vkCmdDrawIndirect-subpass-00480">  The subpass index of the current render pass <strong>must</strong> be equal to the <code>subpass</code> member of the <code>VkGraphicsPipelineCreateInfo</code> structure specified when creating the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>. </li> <li id="VUID-vkCmdDrawIndirect-None-00481">  For each set <em>n</em> that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a descriptor set <strong>must</strong> have been bound to <em>n</em> at <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code>VkPipelineLayout</code> that is compatible for set <em>n</em>, with the <code>VkPipelineLayout</code> used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDrawIndirect-None-00482">  For each push constant that is statically used by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a push constant value <strong>must</strong> have been set for <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code>VkPipelineLayout</code> that is compatible for push constants, with the <code>VkPipelineLayout</code> used to create the current <code>VkPipeline</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility">html/vkspec.html#descriptorsets-compatibility</a> </li> <li id="VUID-vkCmdDrawIndirect-None-00483">  Descriptors in each bound descriptor set, specified via <code>vkCmdBindDescriptorSets</code>, <strong>must</strong> be valid if they are statically used by the currently bound <code>VkPipeline</code> object, specified via <code>vkCmdBindPipeline</code> </li> <li id="VUID-vkCmdDrawIndirect-None-00484">  All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface <strong>must</strong> have valid buffers bound </li> <li id="VUID-vkCmdDrawIndirect-None-00485">  A valid graphics pipeline <strong>must</strong> be bound to the current command buffer with <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> </li> <li id="VUID-vkCmdDrawIndirect-None-00486">  If the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> requires any dynamic state, that state <strong>must</strong> have been set on the current command buffer </li> <li id="VUID-vkCmdDrawIndirect-drawCount-00487">  If <code>drawCount</code> is equal to <code>1</code>, (<code>offset</code> + sizeof(<a href="#VkDrawIndirectCommand">VkDrawIndirectCommand</a>)) <strong>must</strong> be less than or equal to the size of <code>buffer</code> </li> <li id="VUID-vkCmdDrawIndirect-drawCount-00488">  If <code>drawCount</code> is greater than <code>1</code>, (<code>stride</code> × (<code>drawCount</code> - 1) + <code>offset</code> + sizeof(<a href="#VkDrawIndirectCommand">VkDrawIndirectCommand</a>)) <strong>must</strong> be less than or equal to the size of <code>buffer</code> </li> <li id="VUID-vkCmdDrawIndirect-drawCount-00489">  <code>drawCount</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxDrawIndirectCount</code> </li> <li id="VUID-vkCmdDrawIndirect-None-00490">  Every input attachment used by the current subpass <strong>must</strong> be bound to the pipeline via a descriptor set </li> <li id="VUID-vkCmdDrawIndirect-None-00491">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used to sample from any <code>VkImage</code> with a <code>VkImageView</code> of the type <code>VK_IMAGE_VIEW_TYPE_3D</code>, <code>VK_IMAGE_VIEW_TYPE_CUBE</code>, <code>VK_IMAGE_VIEW_TYPE_1D_ARRAY</code>, <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code> or <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>, in any shader stage </li> <li id="VUID-vkCmdDrawIndirect-None-00492">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions with <code>ImplicitLod</code>, <code>Dref</code> or <code>Proj</code> in their name, in any shader stage </li> <li id="VUID-vkCmdDrawIndirect-None-00493">  If any <code>VkSampler</code> object that is accessed from a shader by the <code>VkPipeline</code> currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it <strong>must</strong> not be used with any of the SPIR-V <code>OpImageSample*</code> or <code>OpImageSparseSample*</code> instructions that includes a LOD bias or any offset values, in any shader stage </li> <li id="VUID-vkCmdDrawIndirect-None-00494">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses a uniform buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDrawIndirect-None-00495">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess">robust buffer access</a> feature is not enabled, and any shader stage in the <code>VkPipeline</code> object currently bound to <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses a storage buffer, it <strong>must</strong> not access values outside of the range of that buffer specified in the currently bound descriptor set </li> <li id="VUID-vkCmdDrawIndirect-linearTilingFeatures-00496">  Any <code>VkImageView</code> being sampled with <code>VK_FILTER_LINEAR</code> as a result of this command <strong>must</strong> be of a format which supports linear filtering, as specified by the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (for a linear image) or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code>(for an optimally tiled image) returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-vkCmdDrawIndirect-None-01501">  Image subresources used as attachments in the current render pass <strong>must</strong> not be accessed in any way other than as an attachment by this command. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdDrawIndirect-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdDrawIndirect-buffer-parameter">  <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdDrawIndirect-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdDrawIndirect-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdDrawIndirect-renderpass">  This command <strong>must</strong> only be called inside of a render pass instance </li> <li id="VUID-vkCmdDrawIndirect-commonparent">  Both of <code>buffer</code>, and <code>commandBuffer</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Inside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_27">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <code>VkDeviceSize</code></p>    <h4 id="_document_notes_27">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDrawIndirect">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdDrawIndirect</a></p>         <h3 id="_vkcmdendquery_3">vkCmdEndQuery(3)</h3>  <h4 id="_name_28">Name</h4>  <p>vkCmdEndQuery - Ends a query</p>    <h4 id="_c_specification_28">C Specification</h4>  <p>To end a query after the set of desired draw or dispatch commands is executed, call:</p>  <pre id="vkCmdEndQuery" data-language="c++">void vkCmdEndQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);</pre>   <h4 id="_parameters_28">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which this command will be recorded. </li> <li> <code>queryPool</code> is the query pool that is managing the results of the query. </li> <li> <code>query</code> is the query index within the query pool where the result is stored. </li> </ul>    <h4 id="_description_28">Description</h4>  <p>As queries operate asynchronously, ending a query does not immediately set the query’s status to available. A query is considered <em>finished</em> when the final results of the query are ready to be retrieved by <a href="#vkGetQueryPoolResults">vkGetQueryPoolResults</a> and <a href="#vkCmdCopyQueryPoolResults">vkCmdCopyQueryPoolResults</a>, and this is when the query’s status is set to available.</p>   <p>Once a query is ended the query <strong>must</strong> finish in finite time, unless the state of the query is changed using other commands, e.g. by issuing a reset of the query.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdEndQuery-queryPool-00809">  The query identified by <code>queryPool</code> and <code>query</code> <strong>must</strong> currently be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a> </li> <li id="VUID-vkCmdEndQuery-query-00810">  <code>query</code> <strong>must</strong> be less than the number of queries in <code>queryPool</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdEndQuery-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdEndQuery-queryPool-parameter">  <code>queryPool</code> <strong>must</strong> be a valid <code>VkQueryPool</code> handle </li> <li id="VUID-vkCmdEndQuery-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdEndQuery-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdEndQuery-commonparent">  Both of <code>commandBuffer</code>, and <code>queryPool</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_28">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkQueryPool">VkQueryPool</a></p>    <h4 id="_document_notes_28">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdEndQuery">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdEndQuery</a></p>         <h3 id="_vkcmdendrenderpass_3">vkCmdEndRenderPass(3)</h3>  <h4 id="_name_29">Name</h4>  <p>vkCmdEndRenderPass - End the current render pass</p>    <h4 id="_c_specification_29">C Specification</h4>  <p>To record a command to end a render pass instance after recording the commands for the last subpass, call:</p>  <pre id="vkCmdEndRenderPass" data-language="c++">void vkCmdEndRenderPass(
    VkCommandBuffer                             commandBuffer);</pre>   <h4 id="_parameters_29">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer in which to end the current render pass instance. </li> </ul>    <h4 id="_description_29">Description</h4>  <p>Ending a render pass instance performs any multisample resolve operations on the final subpass.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdEndRenderPass-None-00910">  The current subpass index <strong>must</strong> be equal to the number of subpasses in the render pass minus one </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdEndRenderPass-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdEndRenderPass-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdEndRenderPass-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdEndRenderPass-renderpass">  This command <strong>must</strong> only be called inside of a render pass instance </li> <li id="VUID-vkCmdEndRenderPass-bufferlevel">  <code>commandBuffer</code> <strong>must</strong> be a primary <code>VkCommandBuffer</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Inside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_29">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_29">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdEndRenderPass">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdEndRenderPass</a></p>         <h3 id="_vkcmdexecutecommands_3">vkCmdExecuteCommands(3)</h3>  <h4 id="_name_30">Name</h4>  <p>vkCmdExecuteCommands - Execute a secondary command buffer from a primary command buffer</p>    <h4 id="_c_specification_30">C Specification</h4>  <p>A secondary command buffer <strong>must</strong> not be directly submitted to a queue. Instead, secondary command buffers are recorded to execute as part of a primary command buffer with the command:</p>  <pre id="vkCmdExecuteCommands" data-language="c++">void vkCmdExecuteCommands(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers);</pre>   <h4 id="_parameters_30">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is a handle to a primary command buffer that the secondary command buffers are executed in. </li> <li> <code>commandBufferCount</code> is the length of the <code>pCommandBuffers</code> array. </li> <li> <code>pCommandBuffers</code> is an array of secondary command buffer handles, which are recorded to execute in the primary command buffer in the order they are listed in the array. </li> </ul>    <h4 id="_description_30">Description</h4>  <p>If any element of <code>pCommandBuffers</code> was not recorded with the <code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code> flag, and it was recorded into any other primary command buffer which is currently in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">executable or recording state</a>, that primary command buffer becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdExecuteCommands-commandBuffer-00087">  <code>commandBuffer</code> <strong>must</strong> have been allocated with a <code>level</code> of <code>VK_COMMAND_BUFFER_LEVEL_PRIMARY</code> </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00088">  Any given element of <code>pCommandBuffers</code> <strong>must</strong> have been allocated with a <code>level</code> of <code>VK_COMMAND_BUFFER_LEVEL_SECONDARY</code> </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00089">  Any given element of <code>pCommandBuffers</code> <strong>must</strong> be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending or executable state</a>. </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00090">  If any element of <code>pCommandBuffers</code> was not recorded with the <code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code> flag, and it was recorded into any other primary command buffer, that primary command buffer <strong>must</strong> not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a> </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00091">  If any given element of <code>pCommandBuffers</code> was not recorded with the <code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code> flag, it <strong>must</strong> not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>. </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00092">  If any given element of <code>pCommandBuffers</code> was not recorded with the <code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code> flag, it <strong>must</strong> not have already been recorded to <code>commandBuffer</code>. </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00093">  If any given element of <code>pCommandBuffers</code> was not recorded with the <code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code> flag, it <strong>must</strong> not appear more than once in <code>pCommandBuffers</code>. </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00094">  Any given element of <code>pCommandBuffers</code> <strong>must</strong> have been allocated from a <code>VkCommandPool</code> that was created for the same queue family as the <code>VkCommandPool</code> from which <code>commandBuffer</code> was allocated </li> <li id="VUID-vkCmdExecuteCommands-contents-00095">  If <code>vkCmdExecuteCommands</code> is being called within a render pass instance, that render pass instance <strong>must</strong> have been begun with the <code>contents</code> parameter of <code>vkCmdBeginRenderPass</code> set to <code>VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS</code> </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00096">  If <code>vkCmdExecuteCommands</code> is being called within a render pass instance, any given element of <code>pCommandBuffers</code> <strong>must</strong> have been recorded with the <code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code> </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00097">  If <code>vkCmdExecuteCommands</code> is being called within a render pass instance, any given element of <code>pCommandBuffers</code> <strong>must</strong> have been recorded with <code>VkCommandBufferInheritanceInfo</code>::<code>subpass</code> set to the index of the subpass which the given command buffer will be executed in </li> <li id="VUID-vkCmdExecuteCommands-pInheritanceInfo-00098">  If <code>vkCmdExecuteCommands</code> is being called within a render pass instance, the render passes specified in the pname::pBeginInfo::<code>pInheritanceInfo</code>::<code>renderPass</code> members of the <a href="#vkBeginCommandBuffer">vkBeginCommandBuffer</a> commands used to begin recording each element of <code>pCommandBuffers</code> <strong>must</strong> be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a> with the current render pass. </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00099">  If <code>vkCmdExecuteCommands</code> is being called within a render pass instance, and any given element of <code>pCommandBuffers</code> was recorded with <code>VkCommandBufferInheritanceInfo</code>::<code>framebuffer</code> not equal to <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, that <code>VkFramebuffer</code> <strong>must</strong> match the <code>VkFramebuffer</code> used in the current render pass instance </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00100">  If <code>vkCmdExecuteCommands</code> is not being called within a render pass instance, any given element of <code>pCommandBuffers</code> <strong>must</strong> not have been recorded with the <code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code> </li> <li id="VUID-vkCmdExecuteCommands-commandBuffer-00101">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries">inherited queries</a> feature is not enabled, <code>commandBuffer</code> <strong>must</strong> not have any queries <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a> </li> <li id="VUID-vkCmdExecuteCommands-commandBuffer-00102">  If <code>commandBuffer</code> has a <code>VK_QUERY_TYPE_OCCLUSION</code> query <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>, then each element of <code>pCommandBuffers</code> <strong>must</strong> have been recorded with <code>VkCommandBufferInheritanceInfo</code>::<code>occlusionQueryEnable</code> set to <code>VK_TRUE</code> </li> <li id="VUID-vkCmdExecuteCommands-commandBuffer-00103">  If <code>commandBuffer</code> has a <code>VK_QUERY_TYPE_OCCLUSION</code> query <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>, then each element of <code>pCommandBuffers</code> <strong>must</strong> have been recorded with <code>VkCommandBufferInheritanceInfo</code>::<code>queryFlags</code> having all bits set that are set for the query </li> <li id="VUID-vkCmdExecuteCommands-commandBuffer-00104">  If <code>commandBuffer</code> has a <code>VK_QUERY_TYPE_PIPELINE_STATISTICS</code> query <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a>, then each element of <code>pCommandBuffers</code> <strong>must</strong> have been recorded with <code>VkCommandBufferInheritanceInfo</code>::<code>pipelineStatistics</code> having all bits set that are set in the <code>VkQueryPool</code> the query uses </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-00105">  Any given element of <code>pCommandBuffers</code> <strong>must</strong> not begin any query types that are <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a> in <code>commandBuffer</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdExecuteCommands-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdExecuteCommands-pCommandBuffers-parameter">  <code>pCommandBuffers</code> <strong>must</strong> be a pointer to an array of <code>commandBufferCount</code> valid <code>VkCommandBuffer</code> handles </li> <li id="VUID-vkCmdExecuteCommands-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdExecuteCommands-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support transfer, graphics, or compute operations </li> <li id="VUID-vkCmdExecuteCommands-bufferlevel">  <code>commandBuffer</code> <strong>must</strong> be a primary <code>VkCommandBuffer</code> </li> <li id="VUID-vkCmdExecuteCommands-commandBufferCount-arraylength">  <code>commandBufferCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdExecuteCommands-commonparent">  Both of <code>commandBuffer</code>, and the elements of <code>pCommandBuffers</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer<br> graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_30">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_30">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdExecuteCommands">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdExecuteCommands</a></p>         <h3 id="_vkcmdfillbuffer_3">vkCmdFillBuffer(3)</h3>  <h4 id="_name_31">Name</h4>  <p>vkCmdFillBuffer - Fill a region of a buffer with a fixed value</p>    <h4 id="_c_specification_31">C Specification</h4>  <p>To clear buffer data, call:</p>  <pre id="vkCmdFillBuffer" data-language="c++">void vkCmdFillBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data);</pre>   <h4 id="_parameters_31">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>dstBuffer</code> is the buffer to be filled. </li> <li> <code>dstOffset</code> is the byte offset into the buffer at which to start filling, and <strong>must</strong> be a multiple of 4. </li> <li> <code>size</code> is the number of bytes to fill, and <strong>must</strong> be either a multiple of 4, or <code>VK_WHOLE_SIZE</code> to fill the range from <code>offset</code> to the end of the buffer. If <code>VK_WHOLE_SIZE</code> is used and the remaining size of the buffer is not a multiple of 4, then the nearest smaller multiple is used. </li> <li> <code>data</code> is the 4-byte word written repeatedly to the buffer to fill <code>size</code> bytes of data. The data word is written to memory according to the host endianness. </li> </ul>    <h4 id="_description_31">Description</h4>  <p><code>vkCmdFillBuffer</code> is treated as “transfer” operation for the purposes of synchronization barriers. The <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> <strong>must</strong> be specified in <code>usage</code> of <code>VkBufferCreateInfo</code> in order for the buffer to be compatible with <code>vkCmdFillBuffer</code>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdFillBuffer-dstOffset-00024">  <code>dstOffset</code> <strong>must</strong> be less than the size of <code>dstBuffer</code> </li> <li id="VUID-vkCmdFillBuffer-dstOffset-00025">  <code>dstOffset</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-vkCmdFillBuffer-size-00026">  If <code>size</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>size</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdFillBuffer-size-00027">  If <code>size</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>size</code> <strong>must</strong> be less than or equal to the size of <code>dstBuffer</code> minus <code>dstOffset</code> </li> <li id="VUID-vkCmdFillBuffer-size-00028">  If <code>size</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>size</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-vkCmdFillBuffer-dstBuffer-00029">  <code>dstBuffer</code> <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> usage flag </li> <li id="VUID-vkCmdFillBuffer-commandBuffer-00030">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics or compute operations </li> <li id="VUID-vkCmdFillBuffer-dstBuffer-00031">  If <code>dstBuffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdFillBuffer-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdFillBuffer-dstBuffer-parameter">  <code>dstBuffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdFillBuffer-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdFillBuffer-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics or compute operations </li> <li id="VUID-vkCmdFillBuffer-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdFillBuffer-commonparent">  Both of <code>commandBuffer</code>, and <code>dstBuffer</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> Compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_31">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <code>VkDeviceSize</code></p>    <h4 id="_document_notes_31">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdFillBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdFillBuffer</a></p>         <h3 id="_vkcmdnextsubpass_3">vkCmdNextSubpass(3)</h3>  <h4 id="_name_32">Name</h4>  <p>vkCmdNextSubpass - Transition to the next subpass of a render pass</p>    <h4 id="_c_specification_32">C Specification</h4>  <p>To transition to the next subpass in the render pass instance after recording the commands for a subpass, call:</p>  <pre id="vkCmdNextSubpass" data-language="c++">void vkCmdNextSubpass(
    VkCommandBuffer                             commandBuffer,
    VkSubpassContents                           contents);</pre>   <h4 id="_parameters_32">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer in which to record the command. </li> <li> <code>contents</code> specifies how the commands in the next subpass will be provided, in the same fashion as the corresponding parameter of <a href="#vkCmdBeginRenderPass">vkCmdBeginRenderPass</a>. </li> </ul>    <h4 id="_description_32">Description</h4>  <p>The subpass index for a render pass begins at zero when <code>vkCmdBeginRenderPass</code> is recorded, and increments each time <code>vkCmdNextSubpass</code> is recorded.</p>   <p>Moving to the next subpass automatically performs any multisample resolve operations in the subpass being ended. End-of-subpass multisample resolves are treated as color attachment writes for the purposes of synchronization. That is, they are considered to execute in the <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> pipeline stage and their writes are synchronized with <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code>. Synchronization between rendering within a subpass and any resolve operations at the end of the subpass occurs automatically, without need for explicit dependencies or pipeline barriers. However, if the resolve attachment is also used in a different subpass, an explicit dependency is needed.</p>   <p>After transitioning to the next subpass, the application <strong>can</strong> record the commands for that subpass.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdNextSubpass-None-00909">  The current subpass index <strong>must</strong> be less than the number of subpasses in the render pass minus one </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdNextSubpass-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdNextSubpass-contents-parameter">  <code>contents</code> <strong>must</strong> be a valid <a href="#VkSubpassContents">VkSubpassContents</a> value </li> <li id="VUID-vkCmdNextSubpass-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdNextSubpass-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdNextSubpass-renderpass">  This command <strong>must</strong> only be called inside of a render pass instance </li> <li id="VUID-vkCmdNextSubpass-bufferlevel">  <code>commandBuffer</code> <strong>must</strong> be a primary <code>VkCommandBuffer</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Inside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_32">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkSubpassContents">VkSubpassContents</a></p>    <h4 id="_document_notes_32">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdNextSubpass">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdNextSubpass</a></p>         <h3 id="_vkcmdpipelinebarrier_3">vkCmdPipelineBarrier(3)</h3>  <h4 id="_name_33">Name</h4>  <p>vkCmdPipelineBarrier - Insert a memory dependency</p>    <h4 id="_c_specification_33">C Specification</h4>  <p>To record a pipeline barrier, call:</p>  <pre id="vkCmdPipelineBarrier" data-language="c++">void vkCmdPipelineBarrier(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers);</pre>   <h4 id="_parameters_33">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command is recorded. </li> <li> <code>srcStageMask</code> is a bitmask of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> specifying the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a>. </li> <li> <code>dstStageMask</code> is a bitmask of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> specifying the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a>. </li> <li> <code>dependencyFlags</code> is a bitmask of <a href="#VkDependencyFlagBits">VkDependencyFlagBits</a> specifying how execution and memory dependencies are formed. </li> <li> <code>memoryBarrierCount</code> is the length of the <code>pMemoryBarriers</code> array. </li> <li> <code>pMemoryBarriers</code> is a pointer to an array of <a href="#VkMemoryBarrier">VkMemoryBarrier</a> structures. </li> <li> <code>bufferMemoryBarrierCount</code> is the length of the <code>pBufferMemoryBarriers</code> array. </li> <li> <code>pBufferMemoryBarriers</code> is a pointer to an array of <a href="#VkBufferMemoryBarrier">VkBufferMemoryBarrier</a> structures. </li> <li> <code>imageMemoryBarrierCount</code> is the length of the <code>pImageMemoryBarriers</code> array. </li> <li> <code>pImageMemoryBarriers</code> is a pointer to an array of <a href="#VkImageMemoryBarrier">VkImageMemoryBarrier</a> structures. </li> </ul>    <h4 id="_description_33">Description</h4>  <p>When <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a> is submitted to a queue, it defines a memory dependency between commands that were submitted before it, and those submitted after it.</p>   <p>If <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a> was recorded outside a render pass instance, the first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes every command submitted to the same queue before it, including those in the same command buffer and batch. If <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a> was recorded inside a render pass instance, the first synchronization scope includes only commands submitted before it within the same subpass. In either case, the first synchronization scope is limited to operations on the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by <code>srcStageMask</code>.</p>   <p>If <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a> was recorded outside a render pass instance, the second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes every command submitted to the same queue after it, including those in the same command buffer and batch. If <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a> was recorded inside a render pass instance, the second synchronization scope includes only commands submitted after it within the same subpass. In either case, the second synchronization scope is limited to operations on the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified by <code>dstStageMask</code>.</p>   <p>The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access in the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by <code>srcStageMask</code>. Within that, the first access scope only includes the first access scopes defined by elements of the <code>pMemoryBarriers</code>, <code>pBufferMemoryBarriers</code> and <code>pImageMemoryBarriers</code> arrays, which each define a set of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers">memory barriers</a>. If no memory barriers are specified, then the first access scope includes no accesses.</p>   <p>The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access in the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified by <code>dstStageMask</code>. Within that, the second access scope only includes the second access scopes defined by elements of the <code>pMemoryBarriers</code>, <code>pBufferMemoryBarriers</code> and <code>pImageMemoryBarriers</code> arrays, which each define a set of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers">memory barriers</a>. If no memory barriers are specified, then the second access scope includes no accesses.</p>   <p>If <code>dependencyFlags</code> includes <code>VK_DEPENDENCY_BY_REGION_BIT</code>, then any dependency between <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions">framebuffer-space</a> pipeline stages is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions">framebuffer-local</a> - otherwise it is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions">framebuffer-global</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdPipelineBarrier-srcStageMask-01168">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, <code>srcStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> </li> <li id="VUID-vkCmdPipelineBarrier-dstStageMask-01169">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, <code>dstStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> </li> <li id="VUID-vkCmdPipelineBarrier-srcStageMask-01170">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, <code>srcStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> or <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> </li> <li id="VUID-vkCmdPipelineBarrier-dstStageMask-01171">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, <code>dstStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> or <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> </li> <li id="VUID-vkCmdPipelineBarrier-pDependencies-01172">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, the render pass <strong>must</strong> have been created with a <code>VkSubpassDependency</code> instance in <code>pDependencies</code> that expresses a dependency from the current subpass to itself. </li> <li id="VUID-vkCmdPipelineBarrier-srcStageMask-01173">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, <code>srcStageMask</code> <strong>must</strong> contain a subset of the bit values in the <code>srcStageMask</code> member of that instance of <code>VkSubpassDependency</code> </li> <li id="VUID-vkCmdPipelineBarrier-dstStageMask-01174">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, <code>dstStageMask</code> <strong>must</strong> contain a subset of the bit values in the <code>dstStageMask</code> member of that instance of <code>VkSubpassDependency</code> </li> <li id="VUID-vkCmdPipelineBarrier-srcAccessMask-01175">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, the <code>srcAccessMask</code> of any element of <code>pMemoryBarriers</code> or <code>pImageMemoryBarriers</code> <strong>must</strong> contain a subset of the bit values the <code>srcAccessMask</code> member of that instance of <code>VkSubpassDependency</code> </li> <li id="VUID-vkCmdPipelineBarrier-dstAccessMask-01176">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, the <code>dstAccessMask</code> of any element of <code>pMemoryBarriers</code> or <code>pImageMemoryBarriers</code> <strong>must</strong> contain a subset of the bit values the <code>dstAccessMask</code> member of that instance of <code>VkSubpassDependency</code> </li> <li id="VUID-vkCmdPipelineBarrier-dependencyFlags-01177">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, <code>dependencyFlags</code> <strong>must</strong> be equal to the <code>dependencyFlags</code> member of that instance of <code>VkSubpassDependency</code> </li> <li id="VUID-vkCmdPipelineBarrier-bufferMemoryBarrierCount-01178">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, <code>bufferMemoryBarrierCount</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-vkCmdPipelineBarrier-image-01179">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, the <code>image</code> member of any element of <code>pImageMemoryBarriers</code> <strong>must</strong> be equal to one of the elements of <code>pAttachments</code> that the current <code>framebuffer</code> was created with, that is also referred to by one of the elements of the <code>pColorAttachments</code>, <code>pResolveAttachments</code> or <code>pDepthStencilAttachment</code> members of the <code>VkSubpassDescription</code> instance that the current subpass was created with </li> <li id="VUID-vkCmdPipelineBarrier-oldLayout-01180">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, the <code>oldLayout</code> and <code>newLayout</code> members of any element of <code>pImageMemoryBarriers</code> <strong>must</strong> be equal to the <code>layout</code> member of an element of the <code>pColorAttachments</code>, <code>pResolveAttachments</code> or <code>pDepthStencilAttachment</code> members of the <code>VkSubpassDescription</code> instance that the current subpass was created with, that refers to the same <code>image</code> </li> <li id="VUID-vkCmdPipelineBarrier-oldLayout-01181">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, the <code>oldLayout</code> and <code>newLayout</code> members of an element of <code>pImageMemoryBarriers</code> <strong>must</strong> be equal </li> <li id="VUID-vkCmdPipelineBarrier-srcQueueFamilyIndex-01182">  If <code>vkCmdPipelineBarrier</code> is called within a render pass instance, the <code>srcQueueFamilyIndex</code> and <code>dstQueueFamilyIndex</code> members of any element of <code>pImageMemoryBarriers</code> <strong>must</strong> be <code>VK_QUEUE_FAMILY_IGNORED</code> </li> <li id="VUID-vkCmdPipelineBarrier-srcStageMask-01183">  Any pipeline stage included in <code>srcStageMask</code> or <code>dstStageMask</code> <strong>must</strong> be supported by the capabilities of the queue family specified by the <code>queueFamilyIndex</code> member of the <a href="#VkCommandPoolCreateInfo">VkCommandPoolCreateInfo</a> structure that was used to create the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from, as specified in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-supported">table of supported pipeline stages</a>. </li> <li id="VUID-vkCmdPipelineBarrier-pMemoryBarriers-01184">  Any given element of <code>pMemoryBarriers</code>, <code>pBufferMemoryBarriers</code> or <code>pImageMemoryBarriers</code> <strong>must</strong> not have any access flag included in its <code>srcAccessMask</code> member if that bit is not supported by any of the pipeline stages in <code>srcStageMask</code>, as specified in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access types</a>. </li> <li id="VUID-vkCmdPipelineBarrier-pMemoryBarriers-01185">  Any given element of <code>pMemoryBarriers</code>, <code>pBufferMemoryBarriers</code> or <code>pImageMemoryBarriers</code> <strong>must</strong> not have any access flag included in its <code>dstAccessMask</code> member if that bit is not supported by any of the pipeline stages in <code>dstStageMask</code>, as specified in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access types</a>. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdPipelineBarrier-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdPipelineBarrier-srcStageMask-parameter">  <code>srcStageMask</code> <strong>must</strong> be a valid combination of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> values </li> <li id="VUID-vkCmdPipelineBarrier-srcStageMask-requiredbitmask">  <code>srcStageMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkCmdPipelineBarrier-dstStageMask-parameter">  <code>dstStageMask</code> <strong>must</strong> be a valid combination of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> values </li> <li id="VUID-vkCmdPipelineBarrier-dstStageMask-requiredbitmask">  <code>dstStageMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkCmdPipelineBarrier-dependencyFlags-parameter">  <code>dependencyFlags</code> <strong>must</strong> be a valid combination of <a href="#VkDependencyFlagBits">VkDependencyFlagBits</a> values </li> <li id="VUID-vkCmdPipelineBarrier-pMemoryBarriers-parameter">  If <code>memoryBarrierCount</code> is not <code>0</code>, <code>pMemoryBarriers</code> <strong>must</strong> be a pointer to an array of <code>memoryBarrierCount</code> valid <code>VkMemoryBarrier</code> structures </li> <li id="VUID-vkCmdPipelineBarrier-pBufferMemoryBarriers-parameter">  If <code>bufferMemoryBarrierCount</code> is not <code>0</code>, <code>pBufferMemoryBarriers</code> <strong>must</strong> be a pointer to an array of <code>bufferMemoryBarrierCount</code> valid <code>VkBufferMemoryBarrier</code> structures </li> <li id="VUID-vkCmdPipelineBarrier-pImageMemoryBarriers-parameter">  If <code>imageMemoryBarrierCount</code> is not <code>0</code>, <code>pImageMemoryBarriers</code> <strong>must</strong> be a pointer to an array of <code>imageMemoryBarrierCount</code> valid <code>VkImageMemoryBarrier</code> structures </li> <li id="VUID-vkCmdPipelineBarrier-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdPipelineBarrier-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support transfer, graphics, or compute operations </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer<br> graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_33">See Also</h4>  <p><a href="#VkBufferMemoryBarrier">VkBufferMemoryBarrier</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkDependencyFlags">VkDependencyFlags</a>, <a href="#VkImageMemoryBarrier">VkImageMemoryBarrier</a>, <a href="#VkMemoryBarrier">VkMemoryBarrier</a>, <a href="#VkPipelineStageFlags">VkPipelineStageFlags</a></p>    <h4 id="_document_notes_33">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdPipelineBarrier">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdPipelineBarrier</a></p>         <h3 id="_vkcmdpushconstants_3">vkCmdPushConstants(3)</h3>  <h4 id="_name_34">Name</h4>  <p>vkCmdPushConstants - Update the values of push constants</p>    <h4 id="_c_specification_34">C Specification</h4>  <p>To update push constants, call:</p>  <pre id="vkCmdPushConstants" data-language="c++">void vkCmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    const void*                                 pValues);</pre>   <h4 id="_parameters_34">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer in which the push constant update will be recorded. </li> <li> <code>layout</code> is the pipeline layout used to program the push constant updates. </li> <li> <code>stageFlags</code> is a bitmask of <a href="#VkShaderStageFlagBits">VkShaderStageFlagBits</a> specifying the shader stages that will use the push constants in the updated range. </li> <li> <code>offset</code> is the start offset of the push constant range to update, in units of bytes. </li> <li> <code>size</code> is the size of the push constant range to update, in units of bytes. </li> <li> <code>pValues</code> is an array of <code>size</code> bytes containing the new push constant values. </li> </ul>    <h4 id="_description_34">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdPushConstants-stageFlags-00367">  <code>stageFlags</code> <strong>must</strong> match exactly the shader stages used in <code>layout</code> for the range specified by <code>offset</code> and <code>size</code> </li> <li id="VUID-vkCmdPushConstants-offset-00368">  <code>offset</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-vkCmdPushConstants-size-00369">  <code>size</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-vkCmdPushConstants-offset-00370">  <code>offset</code> <strong>must</strong> be less than <code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code> </li> <li id="VUID-vkCmdPushConstants-size-00371">  <code>size</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code> minus <code>offset</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdPushConstants-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdPushConstants-layout-parameter">  <code>layout</code> <strong>must</strong> be a valid <code>VkPipelineLayout</code> handle </li> <li id="VUID-vkCmdPushConstants-stageFlags-parameter">  <code>stageFlags</code> <strong>must</strong> be a valid combination of <a href="#VkShaderStageFlagBits">VkShaderStageFlagBits</a> values </li> <li id="VUID-vkCmdPushConstants-stageFlags-requiredbitmask">  <code>stageFlags</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkCmdPushConstants-pValues-parameter">  <code>pValues</code> <strong>must</strong> be a pointer to an array of <code>size</code> bytes </li> <li id="VUID-vkCmdPushConstants-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdPushConstants-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdPushConstants-size-arraylength">  <code>size</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdPushConstants-commonparent">  Both of <code>commandBuffer</code>, and <code>layout</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_34">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkPipelineLayout">VkPipelineLayout</a>, <a href="#VkShaderStageFlags">VkShaderStageFlags</a></p>    <h4 id="_document_notes_34">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdPushConstants">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdPushConstants</a></p>         <h3 id="_vkcmdresetevent_3">vkCmdResetEvent(3)</h3>  <h4 id="_name_35">Name</h4>  <p>vkCmdResetEvent - Reset an event object to non-signaled state</p>    <h4 id="_c_specification_35">C Specification</h4>  <p>To set the state of an event to unsignaled from a device, call:</p>  <pre id="vkCmdResetEvent" data-language="c++">void vkCmdResetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);</pre>   <h4 id="_parameters_35">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command is recorded. </li> <li> <code>event</code> is the event that will be unsignaled. </li> <li> <code>stageMask</code> is a bitmask of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> specifying the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages">source stage mask</a> used to determine when the <code>event</code> is unsignaled. </li> </ul>    <h4 id="_description_35">Description</h4>  <p>When <a href="#vkCmdResetEvent">vkCmdResetEvent</a> is submitted to a queue, it defines an execution dependency on commands that were submitted before it, and defines an event unsignal operation which resets the event to the unsignaled state.</p>   <p>The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes every command previously submitted to the same queue, including those in the same command buffer and batch. The synchronization scope is limited to operations on the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by <code>stageMask</code>.</p>   <p>The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes only the event unsignal operation.</p>   <p>If <code>event</code> is already in the unsignaled state when <a href="#vkCmdResetEvent">vkCmdResetEvent</a> is executed on the device, then <a href="#vkCmdResetEvent">vkCmdResetEvent</a> has no effect, no event unsignal operation occurs, and no execution dependency is generated.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdResetEvent-stageMask-01153">  <code>stageMask</code> <strong>must</strong> not include <code>VK_PIPELINE_STAGE_HOST_BIT</code> </li> <li id="VUID-vkCmdResetEvent-stageMask-01154">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, <code>stageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> </li> <li id="VUID-vkCmdResetEvent-stageMask-01155">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, <code>stageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> or <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> </li> <li id="VUID-vkCmdResetEvent-event-01156">  When this command executes, <code>event</code> <strong>must</strong> not be waited on by a <code>vkCmdWaitEvents</code> command that is currently executing </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdResetEvent-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdResetEvent-event-parameter">  <code>event</code> <strong>must</strong> be a valid <code>VkEvent</code> handle </li> <li id="VUID-vkCmdResetEvent-stageMask-parameter">  <code>stageMask</code> <strong>must</strong> be a valid combination of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> values </li> <li id="VUID-vkCmdResetEvent-stageMask-requiredbitmask">  <code>stageMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkCmdResetEvent-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdResetEvent-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdResetEvent-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdResetEvent-commonparent">  Both of <code>commandBuffer</code>, and <code>event</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_35">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkEvent">VkEvent</a>, <a href="#VkPipelineStageFlags">VkPipelineStageFlags</a></p>    <h4 id="_document_notes_35">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdResetEvent">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdResetEvent</a></p>         <h3 id="_vkcmdresetquerypool_3">vkCmdResetQueryPool(3)</h3>  <h4 id="_name_36">Name</h4>  <p>vkCmdResetQueryPool - Reset queries in a query pool</p>    <h4 id="_c_specification_36">C Specification</h4>  <p>To reset a range of queries in a query pool, call:</p>  <pre id="vkCmdResetQueryPool" data-language="c++">void vkCmdResetQueryPool(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount);</pre>   <h4 id="_parameters_36">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which this command will be recorded. </li> <li> <code>queryPool</code> is the handle of the query pool managing the queries being reset. </li> <li> <code>firstQuery</code> is the initial query index to reset. </li> <li> <code>queryCount</code> is the number of queries to reset. </li> </ul>    <h4 id="_description_36">Description</h4>  <p>When executed on a queue, this command sets the status of query indices [<code>firstQuery</code>, <code>firstQuery</code> + <code>queryCount</code> - 1] to unavailable.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdResetQueryPool-firstQuery-00796">  <code>firstQuery</code> <strong>must</strong> be less than the number of queries in <code>queryPool</code> </li> <li id="VUID-vkCmdResetQueryPool-firstQuery-00797">  The sum of <code>firstQuery</code> and <code>queryCount</code> <strong>must</strong> be less than or equal to the number of queries in <code>queryPool</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdResetQueryPool-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdResetQueryPool-queryPool-parameter">  <code>queryPool</code> <strong>must</strong> be a valid <code>VkQueryPool</code> handle </li> <li id="VUID-vkCmdResetQueryPool-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdResetQueryPool-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdResetQueryPool-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdResetQueryPool-commonparent">  Both of <code>commandBuffer</code>, and <code>queryPool</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_36">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkQueryPool">VkQueryPool</a></p>    <h4 id="_document_notes_36">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdResetQueryPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdResetQueryPool</a></p>         <h3 id="_vkcmdresolveimage_3">vkCmdResolveImage(3)</h3>  <h4 id="_name_37">Name</h4>  <p>vkCmdResolveImage - Resolve regions of an image</p>    <h4 id="_c_specification_37">C Specification</h4>  <p>To resolve a multisample image to a non-multisample image, call:</p>  <pre id="vkCmdResolveImage" data-language="c++">void vkCmdResolveImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageResolve*                       pRegions);</pre>   <h4 id="_parameters_37">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>srcImage</code> is the source image. </li> <li> <code>srcImageLayout</code> is the layout of the source image subresources for the resolve. </li> <li> <code>dstImage</code> is the destination image. </li> <li> <code>dstImageLayout</code> is the layout of the destination image subresources for the resolve. </li> <li> <code>regionCount</code> is the number of regions to resolve. </li> <li> <code>pRegions</code> is a pointer to an array of <a href="#VkImageResolve">VkImageResolve</a> structures specifying the regions to resolve. </li> </ul>    <h4 id="_description_37">Description</h4>  <p>During the resolve the samples corresponding to each pixel location in the source are converted to a single sample before being written to the destination. If the source formats are floating-point or normalized types, the sample values for each pixel are resolved in an implementation-dependent manner. If the source formats are integer types, a single sample’s value is selected for each pixel.</p>   <p><code>srcOffset</code> and <code>dstOffset</code> select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data. <code>extent</code> is the size in texels of the source image to resolve in <code>width</code>, <code>height</code> and <code>depth</code>.</p>   <p>Resolves are done layer by layer starting with <code>baseArrayLayer</code> member of <code>srcSubresource</code> for the source and <code>dstSubresource</code> for the destination. <code>layerCount</code> layers are resolved to the destination image.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdResolveImage-pRegions-00253">  The source region specified by a given element of <code>pRegions</code> <strong>must</strong> be a region that is contained within <code>srcImage</code> </li> <li id="VUID-vkCmdResolveImage-pRegions-00254">  The destination region specified by a given element of <code>pRegions</code> <strong>must</strong> be a region that is contained within <code>dstImage</code> </li> <li id="VUID-vkCmdResolveImage-pRegions-00255">  The union of all source regions, and the union of all destination regions, specified by the elements of <code>pRegions</code>, <strong>must</strong> not overlap in memory </li> <li id="VUID-vkCmdResolveImage-srcImage-00256">  If <code>srcImage</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdResolveImage-srcImage-00257">  <code>srcImage</code> <strong>must</strong> have a sample count equal to any valid sample count value other than <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li id="VUID-vkCmdResolveImage-dstImage-00258">  If <code>dstImage</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdResolveImage-dstImage-00259">  <code>dstImage</code> <strong>must</strong> have a sample count equal to <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li id="VUID-vkCmdResolveImage-srcImageLayout-00260">  <code>srcImageLayout</code> <strong>must</strong> specify the layout of the image subresources of <code>srcImage</code> specified in <code>pRegions</code> at the time this command is executed on a <code>VkDevice</code> </li> <li id="VUID-vkCmdResolveImage-srcImageLayout-00261">  <code>srcImageLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-vkCmdResolveImage-dstImageLayout-00262">  <code>dstImageLayout</code> <strong>must</strong> specify the layout of the image subresources of <code>dstImage</code> specified in <code>pRegions</code> at the time this command is executed on a <code>VkDevice</code> </li> <li id="VUID-vkCmdResolveImage-dstImageLayout-00263">  <code>dstImageLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-vkCmdResolveImage-dstImage-00264">  If <code>dstImage</code> was created with <code>tiling</code> equal to <code>VK_IMAGE_TILING_LINEAR</code>, <code>dstImage</code> <strong>must</strong> have been created with a <code>format</code> that supports being a color attachment, as specified by the <code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-vkCmdResolveImage-dstImage-00265">  If <code>dstImage</code> was created with <code>tiling</code> equal to <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>dstImage</code> <strong>must</strong> have been created with a <code>format</code> that supports being a color attachment, as specified by the <code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</code> flag in <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-vkCmdResolveImage-srcImage-01386">  <code>srcImage</code> and <code>dstImage</code> <strong>must</strong> have been created with the same image format </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdResolveImage-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdResolveImage-srcImage-parameter">  <code>srcImage</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkCmdResolveImage-srcImageLayout-parameter">  <code>srcImageLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-vkCmdResolveImage-dstImage-parameter">  <code>dstImage</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkCmdResolveImage-dstImageLayout-parameter">  <code>dstImageLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-vkCmdResolveImage-pRegions-parameter">  <code>pRegions</code> <strong>must</strong> be a pointer to an array of <code>regionCount</code> valid <code>VkImageResolve</code> structures </li> <li id="VUID-vkCmdResolveImage-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdResolveImage-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdResolveImage-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdResolveImage-regionCount-arraylength">  <code>regionCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdResolveImage-commonparent">  Each of <code>commandBuffer</code>, <code>dstImage</code>, and <code>srcImage</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_37">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageLayout">VkImageLayout</a>, <a href="#VkImageResolve">VkImageResolve</a></p>    <h4 id="_document_notes_37">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdResolveImage">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdResolveImage</a></p>         <h3 id="_vkcmdsetblendconstants_3">vkCmdSetBlendConstants(3)</h3>  <h4 id="_name_38">Name</h4>  <p>vkCmdSetBlendConstants - Set the values of blend constants</p>    <h4 id="_c_specification_38">C Specification</h4>  <p>Otherwise, to dynamically set and change the blend constant, call:</p>  <pre id="vkCmdSetBlendConstants" data-language="c++">void vkCmdSetBlendConstants(
    VkCommandBuffer                             commandBuffer,
    const float                                 blendConstants[4]);</pre>   <h4 id="_parameters_38">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>blendConstants</code> is an array of four values specifying the R, G, B, and A components of the blend constant color used in blending, depending on the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-blendfactors">blend factor</a>. </li> </ul>    <h4 id="_description_38">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdSetBlendConstants-None-00612">  The currently bound graphics pipeline <strong>must</strong> have been created with the <code>VK_DYNAMIC_STATE_BLEND_CONSTANTS</code> dynamic state enabled </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdSetBlendConstants-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdSetBlendConstants-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdSetBlendConstants-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_38">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_38">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetBlendConstants">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetBlendConstants</a></p>         <h3 id="_vkcmdsetdepthbias_3">vkCmdSetDepthBias(3)</h3>  <h4 id="_name_39">Name</h4>  <p>vkCmdSetDepthBias - Set the depth bias dynamic state</p>    <h4 id="_c_specification_39">C Specification</h4>  <p>The depth values of all fragments generated by the rasterization of a polygon <strong>can</strong> be offset by a single value that is computed for that polygon. This behavior is controlled by the <code>depthBiasEnable</code>, <code>depthBiasConstantFactor</code>, <code>depthBiasClamp</code>, and <code>depthBiasSlopeFactor</code> members of <a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a>, or by the corresponding parameters to the <code>vkCmdSetDepthBias</code> command if depth bias state is dynamic.</p>  <pre id="vkCmdSetDepthBias" data-language="c++">void vkCmdSetDepthBias(
    VkCommandBuffer                             commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor);</pre>   <h4 id="_parameters_39">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>depthBiasConstantFactor</code> is a scalar factor controlling the constant depth value added to each fragment. </li> <li> <code>depthBiasClamp</code> is the maximum (or minimum) depth bias of a fragment. </li> <li> <code>depthBiasSlopeFactor</code> is a scalar factor applied to a fragment’s slope in depth bias calculations. </li> </ul>    <h4 id="_description_39">Description</h4>  <p>If <code>depthBiasEnable</code> is <code>VK_FALSE</code>, no depth bias is applied and the fragment’s depth values are unchanged.</p>   <p><code>depthBiasSlopeFactor</code> scales the maximum depth slope of the polygon, and <code>depthBiasConstantFactor</code> scales an implementation-dependent constant that relates to the usable resolution of the depth buffer. The resulting values are summed to produce the depth bias value which is then clamped to a minimum or maximum value specified by <code>depthBiasClamp</code>. <code>depthBiasSlopeFactor</code>, <code>depthBiasConstantFactor</code>, and <code>depthBiasClamp</code> <strong>can</strong> each be positive, negative, or zero.</p>   <p>The maximum depth slope m of a triangle is</p>  <div class="stemblock"> <div class="content"> \[m = \sqrt{ \left({{\partial z_f} \over {\partial x_f}}\right)^2 + \left({{\partial z_f} \over {\partial y_f}}\right)^2}\] </div> </div>  <p>where (x<sub>f</sub>, y<sub>f</sub>, z<sub>f</sub>) is a point on the triangle. m <strong>may</strong> be approximated as</p>  <div class="stemblock"> <div class="content"> \[m = \max\left( \left| { {\partial z_f} \over {\partial x_f} } \right|, \left| { {\partial z_f} \over {\partial y_f} } \right| \right).\] </div> </div>  <p>The minimum resolvable difference r is an implementation-dependent parameter that depends on the depth buffer representation. It is the smallest difference in framebuffer coordinate z values that is guaranteed to remain distinct throughout polygon rasterization and in the depth buffer. All pairs of fragments generated by the rasterization of two polygons with otherwise identical vertices, but <code>z</code><sub>f</sub> values that differ by $r$, will have distinct depth values.</p>   <p>For fixed-point depth buffer representations, r is constant throughout the range of the entire depth buffer. For floating-point depth buffers, there is no single minimum resolvable difference. In this case, the minimum resolvable difference for a given polygon is dependent on the maximum exponent, e, in the range of z values spanned by the primitive. If n is the number of bits in the floating-point mantissa, the minimum resolvable difference, r, for the given primitive is defined as</p>  <div class="dlist"> <dl>  <dd> r = 2<sup>e-n</sup> </dd> </dl> </div>  <p>If no depth buffer is present, r is undefined.</p>   <p>The bias value o for a polygon is</p>  <div class="stemblock"> <div class="content"> \[o = \begin{cases} m \times depthBiasSlopeFactor + r \times depthBiasConstantFactor &amp; depthBiasClamp = 0\ or\ NaN \\ \min(m \times depthBiasSlopeFactor + r \times depthBiasConstantFactor, depthBiasClamp) &amp; depthBiasClamp &gt; 0 \\ \max(m \times depthBiasSlopeFactor + r \times depthBiasConstantFactor, depthBiasClamp) &amp; depthBiasClamp &lt; 0 \\ \end{cases}\] </div> </div>  <p>m is computed as described above. If the depth buffer uses a fixed-point representation, m is a function of depth values in the range [0,1], and o is applied to depth values in the same range.</p>   <p>For fixed-point depth buffers, fragment depth values are always limited to the range [0,1] by clamping after depth bias addition is performed. Fragment depth values are clamped even when the depth buffer uses a floating-point representation.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdSetDepthBias-None-00789">  The currently bound graphics pipeline <strong>must</strong> have been created with the <code>VK_DYNAMIC_STATE_DEPTH_BIAS</code> dynamic state enabled </li> <li id="VUID-vkCmdSetDepthBias-depthBiasClamp-00790">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthBiasClamp">depth bias clamping</a> feature is not enabled, <code>depthBiasClamp</code> <strong>must</strong> be <code>0</code>.0 </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdSetDepthBias-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdSetDepthBias-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdSetDepthBias-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_39">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_39">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetDepthBias">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetDepthBias</a></p>         <h3 id="_vkcmdsetdepthbounds_3">vkCmdSetDepthBounds(3)</h3>  <h4 id="_name_40">Name</h4>  <p>vkCmdSetDepthBounds - Set the depth bounds test values for a command buffer</p>    <h4 id="_c_specification_40">C Specification</h4>  <p>The depth bounds test conditionally disables coverage of a sample based on the outcome of a comparison between the value z<sub>a</sub> in the depth attachment at location (x<sub>f</sub>,y<sub>f</sub>) (for the appropriate sample) and a range of values. The test is enabled or disabled by the <code>depthBoundsTestEnable</code> member of <a href="#VkPipelineDepthStencilStateCreateInfo">VkPipelineDepthStencilStateCreateInfo</a>: If the pipeline state object is created without the <code>VK_DYNAMIC_STATE_DEPTH_BOUNDS</code> dynamic state enabled then the range of values used in the depth bounds test are defined by the <code>minDepthBounds</code> and <code>maxDepthBounds</code> members of the <a href="#VkPipelineDepthStencilStateCreateInfo">VkPipelineDepthStencilStateCreateInfo</a> structure. Otherwise, to dynamically set the depth bounds range values call:</p>  <pre id="vkCmdSetDepthBounds" data-language="c++">void vkCmdSetDepthBounds(
    VkCommandBuffer                             commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds);</pre>   <h4 id="_parameters_40">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>minDepthBounds</code> is the lower bound of the range of depth values used in the depth bounds test. </li> <li> <code>maxDepthBounds</code> is the upper bound of the range. </li> </ul>    <h4 id="_description_40">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdSetDepthBounds-None-00599">  The currently bound graphics pipeline <strong>must</strong> have been created with the <code>VK_DYNAMIC_STATE_DEPTH_BOUNDS</code> dynamic state enabled </li> <li id="VUID-vkCmdSetDepthBounds-minDepthBounds-00600">  <code>minDepthBounds</code> <strong>must</strong> be between <code>0.0</code> and <code>1.0</code>, inclusive </li> <li id="VUID-vkCmdSetDepthBounds-maxDepthBounds-00601">  <code>maxDepthBounds</code> <strong>must</strong> be between <code>0.0</code> and <code>1.0</code>, inclusive </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdSetDepthBounds-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdSetDepthBounds-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdSetDepthBounds-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_40">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_40">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetDepthBounds">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetDepthBounds</a></p>         <h3 id="_vkcmdsetevent_3">vkCmdSetEvent(3)</h3>  <h4 id="_name_41">Name</h4>  <p>vkCmdSetEvent - Set an event object to signaled state</p>    <h4 id="_c_specification_41">C Specification</h4>  <p>To set the state of an event to signaled from a device, call:</p>  <pre id="vkCmdSetEvent" data-language="c++">void vkCmdSetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);</pre>   <h4 id="_parameters_41">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command is recorded. </li> <li> <code>event</code> is the event that will be signaled. </li> <li> <code>stageMask</code> specifies the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages">source stage mask</a> used to determine when the <code>event</code> is signaled. </li> </ul>    <h4 id="_description_41">Description</h4>  <p>When <a href="#vkCmdSetEvent">vkCmdSetEvent</a> is submitted to a queue, it defines an execution dependency on commands that were submitted before it, and defines an event signal operation which sets the event to the signaled state.</p>   <p>The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes every command previously submitted to the same queue, including those in the same command buffer and batch. The synchronization scope is limited to operations on the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by <code>stageMask</code>.</p>   <p>The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes only the event signal operation.</p>   <p>If <code>event</code> is already in the signaled state when <a href="#vkCmdSetEvent">vkCmdSetEvent</a> is executed on the device, then <a href="#vkCmdSetEvent">vkCmdSetEvent</a> has no effect, no event signal operation occurs, and no execution dependency is generated.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdSetEvent-stageMask-01149">  <code>stageMask</code> <strong>must</strong> not include <code>VK_PIPELINE_STAGE_HOST_BIT</code> </li> <li id="VUID-vkCmdSetEvent-stageMask-01150">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, <code>stageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> </li> <li id="VUID-vkCmdSetEvent-stageMask-01151">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, <code>stageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> or <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdSetEvent-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdSetEvent-event-parameter">  <code>event</code> <strong>must</strong> be a valid <code>VkEvent</code> handle </li> <li id="VUID-vkCmdSetEvent-stageMask-parameter">  <code>stageMask</code> <strong>must</strong> be a valid combination of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> values </li> <li id="VUID-vkCmdSetEvent-stageMask-requiredbitmask">  <code>stageMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkCmdSetEvent-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdSetEvent-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdSetEvent-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdSetEvent-commonparent">  Both of <code>commandBuffer</code>, and <code>event</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_41">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkEvent">VkEvent</a>, <a href="#VkPipelineStageFlags">VkPipelineStageFlags</a></p>    <h4 id="_document_notes_41">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetEvent">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetEvent</a></p>         <h3 id="_vkcmdsetlinewidth_3">vkCmdSetLineWidth(3)</h3>  <h4 id="_name_42">Name</h4>  <p>vkCmdSetLineWidth - Set the dynamic line width state</p>    <h4 id="_c_specification_42">C Specification</h4>  <p>The line width is specified by the <a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a>::<code>lineWidth</code> property of the currently active pipeline, if the pipeline was not created with <code>VK_DYNAMIC_STATE_LINE_WIDTH</code> enabled.</p>   <p>Otherwise, the line width is set by calling <code>vkCmdSetLineWidth</code>:</p>  <pre id="vkCmdSetLineWidth" data-language="c++">void vkCmdSetLineWidth(
    VkCommandBuffer                             commandBuffer,
    float                                       lineWidth);</pre>   <h4 id="_parameters_42">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>lineWidth</code> is the width of rasterized line segments. </li> </ul>    <h4 id="_description_42">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdSetLineWidth-None-00787">  The currently bound graphics pipeline <strong>must</strong> have been created with the <code>VK_DYNAMIC_STATE_LINE_WIDTH</code> dynamic state enabled </li> <li id="VUID-vkCmdSetLineWidth-lineWidth-00788">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-wideLines">wide lines</a> feature is not enabled, <code>lineWidth</code> <strong>must</strong> be <code>1.0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdSetLineWidth-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdSetLineWidth-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdSetLineWidth-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_42">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_42">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetLineWidth">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetLineWidth</a></p>         <h3 id="_vkcmdsetscissor_3">vkCmdSetScissor(3)</h3>  <h4 id="_name_43">Name</h4>  <p>vkCmdSetScissor - Set the dynamic scissor rectangles on a command buffer</p>    <h4 id="_c_specification_43">C Specification</h4>  <p>The scissor test determines if a fragment’s framebuffer coordinates (x<sub>f</sub>,y<sub>f</sub>) lie within the scissor rectangle corresponding to the viewport index (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vertexpostproc-viewport">Controlling the Viewport</a>) used by the primitive that generated the fragment. If the pipeline state object is created without <code>VK_DYNAMIC_STATE_SCISSOR</code> enabled then the scissor rectangles are set by the <a href="#VkPipelineViewportStateCreateInfo">VkPipelineViewportStateCreateInfo</a> state of the pipeline state object. Otherwise, to dynamically set the scissor rectangles call:</p>  <pre id="vkCmdSetScissor" data-language="c++">void vkCmdSetScissor(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    const VkRect2D*                             pScissors);</pre>   <h4 id="_parameters_43">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>firstScissor</code> is the index of the first scissor whose state is updated by the command. </li> <li> <code>scissorCount</code> is the number of scissors whose rectangles are updated by the command. </li> <li> <code>pScissors</code> is a pointer to an array of <a href="#VkRect2D">VkRect2D</a> structures defining scissor rectangles. </li> </ul>    <h4 id="_description_43">Description</h4>  <p>The scissor rectangles taken from element i of <code>pScissors</code> replace the current state for the scissor index <code>firstScissor</code> + i, for i in [0, <code>scissorCount</code>).</p>   <p>Each scissor rectangle is described by a <a href="#VkRect2D">VkRect2D</a> structure, with the <code>offset.x</code> and <code>offset.y</code> values determining the upper left corner of the scissor rectangle, and the <code>extent.width</code> and <code>extent.height</code> values determining the size in pixels.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdSetScissor-None-00590">  The currently bound graphics pipeline <strong>must</strong> have been created with the <code>VK_DYNAMIC_STATE_SCISSOR</code> dynamic state enabled </li> <li id="VUID-vkCmdSetScissor-firstScissor-00591">  <code>firstScissor</code> <strong>must</strong> be less than <code>VkPhysicalDeviceLimits</code>::<code>maxViewports</code> </li> <li id="VUID-vkCmdSetScissor-firstScissor-00592">  The sum of <code>firstScissor</code> and <code>scissorCount</code> <strong>must</strong> be between <code>1</code> and <code>VkPhysicalDeviceLimits</code>::<code>maxViewports</code>, inclusive </li> <li id="VUID-vkCmdSetScissor-firstScissor-00593">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is not enabled, <code>firstScissor</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-vkCmdSetScissor-scissorCount-00594">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is not enabled, <code>scissorCount</code> <strong>must</strong> be <code>1</code> </li> <li id="VUID-vkCmdSetScissor-x-00595">  The <code>x</code> and <code>y</code> members of <code>offset</code> <strong>must</strong> be greater than or equal to <code>0</code> </li> <li id="VUID-vkCmdSetScissor-offset-00596">  Evaluation of (<code>offset.x</code> + <code>extent.width</code>) <strong>must</strong> not cause a signed integer addition overflow </li> <li id="VUID-vkCmdSetScissor-offset-00597">  Evaluation of (<code>offset.y</code> + <code>extent.height</code>) <strong>must</strong> not cause a signed integer addition overflow </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdSetScissor-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdSetScissor-pScissors-parameter">  <code>pScissors</code> <strong>must</strong> be a pointer to an array of <code>scissorCount</code> <code>VkRect2D</code> structures </li> <li id="VUID-vkCmdSetScissor-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdSetScissor-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdSetScissor-scissorCount-arraylength">  <code>scissorCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_43">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkRect2D">VkRect2D</a></p>    <h4 id="_document_notes_43">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetScissor">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetScissor</a></p>         <h3 id="_vkcmdsetstencilcomparemask_3">vkCmdSetStencilCompareMask(3)</h3>  <h4 id="_name_44">Name</h4>  <p>vkCmdSetStencilCompareMask - Set the stencil compare mask dynamic state</p>    <h4 id="_c_specification_44">C Specification</h4>  <p>If the pipeline state object is created with the <code>VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK</code> dynamic state enabled, then to dynamically set the stencil compare mask call:</p>  <pre id="vkCmdSetStencilCompareMask" data-language="c++">void vkCmdSetStencilCompareMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask);</pre>   <h4 id="_parameters_44">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>faceMask</code> is a bitmask of <a href="#VkStencilFaceFlagBits">VkStencilFaceFlagBits</a> specifying the set of stencil state for which to update the compare mask. </li> <li> <code>compareMask</code> is the new value to use as the stencil compare mask. </li> </ul>    <h4 id="_description_44">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdSetStencilCompareMask-None-00602">  The currently bound graphics pipeline <strong>must</strong> have been created with the <code>VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK</code> dynamic state enabled </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdSetStencilCompareMask-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdSetStencilCompareMask-faceMask-parameter">  <code>faceMask</code> <strong>must</strong> be a valid combination of <a href="#VkStencilFaceFlagBits">VkStencilFaceFlagBits</a> values </li> <li id="VUID-vkCmdSetStencilCompareMask-faceMask-requiredbitmask">  <code>faceMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkCmdSetStencilCompareMask-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdSetStencilCompareMask-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_44">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkStencilFaceFlags">VkStencilFaceFlags</a></p>    <h4 id="_document_notes_44">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetStencilCompareMask">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetStencilCompareMask</a></p>         <h3 id="_vkcmdsetstencilreference_3">vkCmdSetStencilReference(3)</h3>  <h4 id="_name_45">Name</h4>  <p>vkCmdSetStencilReference - Set the stencil reference dynamic state</p>    <h4 id="_c_specification_45">C Specification</h4>  <p>If the pipeline state object is created with the <code>VK_DYNAMIC_STATE_STENCIL_REFERENCE</code> dynamic state enabled, then to dynamically set the stencil reference value call:</p>  <pre id="vkCmdSetStencilReference" data-language="c++">void vkCmdSetStencilReference(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference);</pre>   <h4 id="_parameters_45">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>faceMask</code> is a bitmask of <a href="#VkStencilFaceFlagBits">VkStencilFaceFlagBits</a> specifying the set of stencil state for which to update the reference value, as described above for <a href="#vkCmdSetStencilCompareMask">vkCmdSetStencilCompareMask</a>. </li> <li> <code>reference</code> is the new value to use as the stencil reference value. </li> </ul>    <h4 id="_description_45">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdSetStencilReference-None-00604">  The currently bound graphics pipeline <strong>must</strong> have been created with the <code>VK_DYNAMIC_STATE_STENCIL_REFERENCE</code> dynamic state enabled </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdSetStencilReference-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdSetStencilReference-faceMask-parameter">  <code>faceMask</code> <strong>must</strong> be a valid combination of <a href="#VkStencilFaceFlagBits">VkStencilFaceFlagBits</a> values </li> <li id="VUID-vkCmdSetStencilReference-faceMask-requiredbitmask">  <code>faceMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkCmdSetStencilReference-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdSetStencilReference-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_45">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkStencilFaceFlags">VkStencilFaceFlags</a></p>    <h4 id="_document_notes_45">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetStencilReference">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetStencilReference</a></p>         <h3 id="_vkcmdsetstencilwritemask_3">vkCmdSetStencilWriteMask(3)</h3>  <h4 id="_name_46">Name</h4>  <p>vkCmdSetStencilWriteMask - Set the stencil write mask dynamic state</p>    <h4 id="_c_specification_46">C Specification</h4>  <p>If the pipeline state object is created with the <code>VK_DYNAMIC_STATE_STENCIL_WRITE_MASK</code> dynamic state enabled, then to dynamically set the stencil write mask call:</p>  <pre id="vkCmdSetStencilWriteMask" data-language="c++">void vkCmdSetStencilWriteMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask);</pre>   <h4 id="_parameters_46">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>faceMask</code> is a bitmask of <a href="#VkStencilFaceFlagBits">VkStencilFaceFlagBits</a> specifying the set of stencil state for which to update the write mask, as described above for <a href="#vkCmdSetStencilCompareMask">vkCmdSetStencilCompareMask</a>. </li> <li> <code>writeMask</code> is the new value to use as the stencil write mask. </li> </ul>    <h4 id="_description_46">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdSetStencilWriteMask-None-00603">  The currently bound graphics pipeline <strong>must</strong> have been created with the <code>VK_DYNAMIC_STATE_STENCIL_WRITE_MASK</code> dynamic state enabled </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdSetStencilWriteMask-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdSetStencilWriteMask-faceMask-parameter">  <code>faceMask</code> <strong>must</strong> be a valid combination of <a href="#VkStencilFaceFlagBits">VkStencilFaceFlagBits</a> values </li> <li id="VUID-vkCmdSetStencilWriteMask-faceMask-requiredbitmask">  <code>faceMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkCmdSetStencilWriteMask-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdSetStencilWriteMask-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_46">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkStencilFaceFlags">VkStencilFaceFlags</a></p>    <h4 id="_document_notes_46">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetStencilWriteMask">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetStencilWriteMask</a></p>         <h3 id="_vkcmdsetviewport_3">vkCmdSetViewport(3)</h3>  <h4 id="_name_47">Name</h4>  <p>vkCmdSetViewport - Set the viewport on a command buffer</p>    <h4 id="_c_specification_47">C Specification</h4>  <p>If the bound pipeline state object was not created with the <code>VK_DYNAMIC_STATE_VIEWPORT</code> dynamic state enabled, viewport transformation parameters are specified using the <code>pViewports</code> member of <code>VkPipelineViewportStateCreateInfo</code> in the pipeline state object. If the pipeline state object was created with the <code>VK_DYNAMIC_STATE_VIEWPORT</code> dynamic state enabled, the viewport transformation parameters are dynamically set and changed with the command:</p>  <pre id="vkCmdSetViewport" data-language="c++">void vkCmdSetViewport(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewport*                           pViewports);</pre>   <h4 id="_parameters_47">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>firstViewport</code> is the index of the first viewport whose parameters are updated by the command. </li> <li> <code>viewportCount</code> is the number of viewports whose parameters are updated by the command. </li> <li> <code>pViewports</code> is a pointer to an array of <a href="#VkViewport">VkViewport</a> structures specifying viewport parameters. </li> </ul>    <h4 id="_description_47">Description</h4>  <p>The viewport parameters taken from element i of <code>pViewports</code> replace the current state for the viewport index <code>firstViewport</code> + i, for i in [0, <code>viewportCount</code>).</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdSetViewport-None-01221">  The currently bound graphics pipeline <strong>must</strong> have been created with the <code>VK_DYNAMIC_STATE_VIEWPORT</code> dynamic state enabled </li> <li id="VUID-vkCmdSetViewport-firstViewport-01222">  <code>firstViewport</code> <strong>must</strong> be less than <code>VkPhysicalDeviceLimits</code>::<code>maxViewports</code> </li> <li id="VUID-vkCmdSetViewport-firstViewport-01223">  The sum of <code>firstViewport</code> and <code>viewportCount</code> <strong>must</strong> be between <code>1</code> and <code>VkPhysicalDeviceLimits</code>::<code>maxViewports</code>, inclusive </li> <li id="VUID-vkCmdSetViewport-firstViewport-01224">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is not enabled, <code>firstViewport</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-vkCmdSetViewport-viewportCount-01225">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is not enabled, <code>viewportCount</code> <strong>must</strong> be <code>1</code> </li> <li id="VUID-vkCmdSetViewport-pViewports-01226">  <code>pViewports</code> <strong>must</strong> be a pointer to an array of <code>viewportCount</code> valid <code>VkViewport</code> structures </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdSetViewport-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdSetViewport-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdSetViewport-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics operations </li> <li id="VUID-vkCmdSetViewport-viewportCount-arraylength">  <code>viewportCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_47">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkViewport">VkViewport</a></p>    <h4 id="_document_notes_47">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetViewport">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdSetViewport</a></p>         <h3 id="_vkcmdupdatebuffer_3">vkCmdUpdateBuffer(3)</h3>  <h4 id="_name_48">Name</h4>  <p>vkCmdUpdateBuffer - Update a buffer’s contents from host memory</p>    <h4 id="_c_specification_48">C Specification</h4>  <p>To update buffer data inline in a command buffer, call:</p>  <pre id="vkCmdUpdateBuffer" data-language="c++">void vkCmdUpdateBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    const void*                                 pData);</pre>   <h4 id="_parameters_48">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>dstBuffer</code> is a handle to the buffer to be updated. </li> <li> <code>dstOffset</code> is the byte offset into the buffer to start updating, and <strong>must</strong> be a multiple of 4. </li> <li> <code>dataSize</code> is the number of bytes to update, and <strong>must</strong> be a multiple of 4. </li> <li> <code>pData</code> is a pointer to the source data for the buffer update, and <strong>must</strong> be at least <code>dataSize</code> bytes in size. </li> </ul>    <h4 id="_description_48">Description</h4>  <p><code>dataSize</code> <strong>must</strong> be less than or equal to 65536 bytes. For larger updates, applications <strong>can</strong> use buffer to buffer <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#copies-buffers">copies</a>.</p>   <p>The source data is copied from the user pointer to the command buffer when the command is called.</p>   <p><code>vkCmdUpdateBuffer</code> is only allowed outside of a render pass. This command is treated as “transfer” operation, for the purposes of synchronization barriers. The <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> <strong>must</strong> be specified in <code>usage</code> of <a href="#VkBufferCreateInfo">VkBufferCreateInfo</a> in order for the buffer to be compatible with <code>vkCmdUpdateBuffer</code>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdUpdateBuffer-dstOffset-00032">  <code>dstOffset</code> <strong>must</strong> be less than the size of <code>dstBuffer</code> </li> <li id="VUID-vkCmdUpdateBuffer-dataSize-00033">  <code>dataSize</code> <strong>must</strong> be less than or equal to the size of <code>dstBuffer</code> minus <code>dstOffset</code> </li> <li id="VUID-vkCmdUpdateBuffer-dstBuffer-00034">  <code>dstBuffer</code> <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> usage flag </li> <li id="VUID-vkCmdUpdateBuffer-dstBuffer-00035">  If <code>dstBuffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-vkCmdUpdateBuffer-dstOffset-00036">  <code>dstOffset</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-vkCmdUpdateBuffer-dataSize-00037">  <code>dataSize</code> <strong>must</strong> be less than or equal to <code>65536</code> </li> <li id="VUID-vkCmdUpdateBuffer-dataSize-00038">  <code>dataSize</code> <strong>must</strong> be a multiple of <code>4</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdUpdateBuffer-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdUpdateBuffer-dstBuffer-parameter">  <code>dstBuffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkCmdUpdateBuffer-pData-parameter">  <code>pData</code> <strong>must</strong> be a pointer to an array of <code>dataSize</code> bytes </li> <li id="VUID-vkCmdUpdateBuffer-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdUpdateBuffer-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support transfer, graphics, or compute operations </li> <li id="VUID-vkCmdUpdateBuffer-renderpass">  This command <strong>must</strong> only be called outside of a render pass instance </li> <li id="VUID-vkCmdUpdateBuffer-dataSize-arraylength">  <code>dataSize</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdUpdateBuffer-commonparent">  Both of <code>commandBuffer</code>, and <code>dstBuffer</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Outside</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer<br> graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_48">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <code>VkDeviceSize</code></p>    <h4 id="_document_notes_48">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdUpdateBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdUpdateBuffer</a></p>         <h3 id="_vkcmdwaitevents_3">vkCmdWaitEvents(3)</h3>  <h4 id="_name_49">Name</h4>  <p>vkCmdWaitEvents - Wait for one or more events and insert a set of memory</p>    <h4 id="_c_specification_49">C Specification</h4>  <p>To wait for one or more events to enter the signaled state on a device, call:</p>  <pre id="vkCmdWaitEvents" data-language="c++">void vkCmdWaitEvents(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    const VkEvent*                              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers);</pre>   <h4 id="_parameters_49">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command is recorded. </li> <li> <code>eventCount</code> is the length of the <code>pEvents</code> array. </li> <li> <code>pEvents</code> is an array of event object handles to wait on. </li> <li> <code>srcStageMask</code> is a bitmask of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> specifying the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages">source stage mask</a>. </li> <li> <code>dstStageMask</code> is a bitmask of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> specifying the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages">destination stage mask</a>. </li> <li> <code>memoryBarrierCount</code> is the length of the <code>pMemoryBarriers</code> array. </li> <li> <code>pMemoryBarriers</code> is a pointer to an array of <a href="#VkMemoryBarrier">VkMemoryBarrier</a> structures. </li> <li> <code>bufferMemoryBarrierCount</code> is the length of the <code>pBufferMemoryBarriers</code> array. </li> <li> <code>pBufferMemoryBarriers</code> is a pointer to an array of <a href="#VkBufferMemoryBarrier">VkBufferMemoryBarrier</a> structures. </li> <li> <code>imageMemoryBarrierCount</code> is the length of the <code>pImageMemoryBarriers</code> array. </li> <li> <code>pImageMemoryBarriers</code> is a pointer to an array of <a href="#VkImageMemoryBarrier">VkImageMemoryBarrier</a> structures. </li> </ul>    <h4 id="_description_49">Description</h4>  <p>When <code>vkCmdWaitEvents</code> is submitted to a queue, it defines a memory dependency between prior event signal operations, and subsequent commands.</p>   <p>The first synchronization scope only includes event signal operations that operate on members of <code>pEvents</code>, and the operations that happened-before the event signal operations. Event signal operations performed by <a href="#vkCmdSetEvent">vkCmdSetEvent</a> that were previously submitted to the same queue are included in the first synchronization scope, if the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically latest</a> pipeline stage in their <code>stageMask</code> parameter is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically earlier</a> than or equal to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically latest</a> pipeline stage in <code>srcStageMask</code>. Event signal operations performed by <a href="#vkSetEvent">vkSetEvent</a> are only included in the first synchronization scope if <code>VK_PIPELINE_STAGE_HOST_BIT</code> is included in <code>srcStageMask</code>.</p>   <p>The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes commands subsequently submitted to the same queue, including those in the same command buffer and batch. The second synchronization scope is limited to operations on the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified by <code>dstStageMask</code>.</p>   <p>The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access in the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by <code>srcStageMask</code>. Within that, the first access scope only includes the first access scopes defined by elements of the <code>pMemoryBarriers</code>, <code>pBufferMemoryBarriers</code> and <code>pImageMemoryBarriers</code> arrays, which each define a set of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers">memory barriers</a>. If no memory barriers are specified, then the first access scope includes no accesses.</p>   <p>The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access in the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified by <code>dstStageMask</code>. Within that, the second access scope only includes the second access scopes defined by elements of the <code>pMemoryBarriers</code>, <code>pBufferMemoryBarriers</code> and <code>pImageMemoryBarriers</code> arrays, which each define a set of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers">memory barriers</a>. If no memory barriers are specified, then the second access scope includes no accesses.</p>  <blockquote> <h5 class="title">Note</h5>  <p><a href="#vkCmdWaitEvents">vkCmdWaitEvents</a> is used with <a href="#vkCmdSetEvent">vkCmdSetEvent</a> to define a memory dependency between two sets of action commands, roughly in the same way as pipeline barriers, but split into two commands such that work between the two <strong>may</strong> execute unhindered.</p>  </blockquote> <blockquote> <h5 class="title">Note</h5>  <p>Applications <strong>should</strong> be careful to avoid race conditions when using events. There is no direct ordering guarantee between a <a href="#vkCmdResetEvent">vkCmdResetEvent</a> command and a <a href="#vkCmdWaitEvents">vkCmdWaitEvents</a> command submitted after it, so some other execution dependency <strong>must</strong> be included between these commands (e.g. a semaphore).</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdWaitEvents-srcStageMask-01158">  <code>srcStageMask</code> <strong>must</strong> be the bitwise OR of the <code>stageMask</code> parameter used in previous calls to <code>vkCmdSetEvent</code> with any of the members of <code>pEvents</code> and <code>VK_PIPELINE_STAGE_HOST_BIT</code> if any of the members of <code>pEvents</code> was set using <code>vkSetEvent</code> </li> <li id="VUID-vkCmdWaitEvents-srcStageMask-01159">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, <code>srcStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> </li> <li id="VUID-vkCmdWaitEvents-dstStageMask-01160">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, <code>dstStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> </li> <li id="VUID-vkCmdWaitEvents-srcStageMask-01161">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, <code>srcStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> or <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> </li> <li id="VUID-vkCmdWaitEvents-dstStageMask-01162">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, <code>dstStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> or <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> </li> <li id="VUID-vkCmdWaitEvents-pEvents-01163">  If <code>pEvents</code> includes one or more events that will be signaled by <code>vkSetEvent</code> after <code>commandBuffer</code> has been submitted to a queue, then <code>vkCmdWaitEvents</code> <strong>must</strong> not be called inside a render pass instance </li> <li id="VUID-vkCmdWaitEvents-srcStageMask-01164">  Any pipeline stage included in <code>srcStageMask</code> or <code>dstStageMask</code> <strong>must</strong> be supported by the capabilities of the queue family specified by the <code>queueFamilyIndex</code> member of the <a href="#VkCommandPoolCreateInfo">VkCommandPoolCreateInfo</a> structure that was used to create the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from, as specified in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-supported">table of supported pipeline stages</a>. </li> <li id="VUID-vkCmdWaitEvents-pMemoryBarriers-01165">  Any given element of <code>pMemoryBarriers</code>, <code>pBufferMemoryBarriers</code> or <code>pImageMemoryBarriers</code> <strong>must</strong> not have any access flag included in its <code>srcAccessMask</code> member if that bit is not supported by any of the pipeline stages in <code>srcStageMask</code>, as specified in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access types</a>. </li> <li id="VUID-vkCmdWaitEvents-pMemoryBarriers-01166">  Any given element of <code>pMemoryBarriers</code>, <code>pBufferMemoryBarriers</code> or <code>pImageMemoryBarriers</code> <strong>must</strong> not have any access flag included in its <code>dstAccessMask</code> member if that bit is not supported by any of the pipeline stages in <code>dstStageMask</code>, as specified in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access types</a>. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdWaitEvents-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdWaitEvents-pEvents-parameter">  <code>pEvents</code> <strong>must</strong> be a pointer to an array of <code>eventCount</code> valid <code>VkEvent</code> handles </li> <li id="VUID-vkCmdWaitEvents-srcStageMask-parameter">  <code>srcStageMask</code> <strong>must</strong> be a valid combination of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> values </li> <li id="VUID-vkCmdWaitEvents-srcStageMask-requiredbitmask">  <code>srcStageMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkCmdWaitEvents-dstStageMask-parameter">  <code>dstStageMask</code> <strong>must</strong> be a valid combination of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> values </li> <li id="VUID-vkCmdWaitEvents-dstStageMask-requiredbitmask">  <code>dstStageMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkCmdWaitEvents-pMemoryBarriers-parameter">  If <code>memoryBarrierCount</code> is not <code>0</code>, <code>pMemoryBarriers</code> <strong>must</strong> be a pointer to an array of <code>memoryBarrierCount</code> valid <code>VkMemoryBarrier</code> structures </li> <li id="VUID-vkCmdWaitEvents-pBufferMemoryBarriers-parameter">  If <code>bufferMemoryBarrierCount</code> is not <code>0</code>, <code>pBufferMemoryBarriers</code> <strong>must</strong> be a pointer to an array of <code>bufferMemoryBarrierCount</code> valid <code>VkBufferMemoryBarrier</code> structures </li> <li id="VUID-vkCmdWaitEvents-pImageMemoryBarriers-parameter">  If <code>imageMemoryBarrierCount</code> is not <code>0</code>, <code>pImageMemoryBarriers</code> <strong>must</strong> be a pointer to an array of <code>imageMemoryBarrierCount</code> valid <code>VkImageMemoryBarrier</code> structures </li> <li id="VUID-vkCmdWaitEvents-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdWaitEvents-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdWaitEvents-eventCount-arraylength">  <code>eventCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCmdWaitEvents-commonparent">  Both of <code>commandBuffer</code>, and the elements of <code>pEvents</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_49">See Also</h4>  <p><a href="#VkBufferMemoryBarrier">VkBufferMemoryBarrier</a>, <a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkEvent">VkEvent</a>, <a href="#VkImageMemoryBarrier">VkImageMemoryBarrier</a>, <a href="#VkMemoryBarrier">VkMemoryBarrier</a>, <a href="#VkPipelineStageFlags">VkPipelineStageFlags</a></p>    <h4 id="_document_notes_49">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdWaitEvents">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdWaitEvents</a></p>         <h3 id="_vkcmdwritetimestamp_3">vkCmdWriteTimestamp(3)</h3>  <h4 id="_name_50">Name</h4>  <p>vkCmdWriteTimestamp - Write a device timestamp into a query object</p>    <h4 id="_c_specification_50">C Specification</h4>  <p>To request a timestamp, call:</p>  <pre id="vkCmdWriteTimestamp" data-language="c++">void vkCmdWriteTimestamp(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);</pre>   <h4 id="_parameters_50">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer into which the command will be recorded. </li> <li> <code>pipelineStage</code> is one of the <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a>, specifying a stage of the pipeline. </li> <li> <code>queryPool</code> is the query pool that will manage the timestamp. </li> <li> <code>query</code> is the query within the query pool that will contain the timestamp. </li> </ul>    <h4 id="_description_50">Description</h4>  <p><code>vkCmdWriteTimestamp</code> latches the value of the timer when all previous commands have completed executing as far as the specified pipeline stage, and writes the timestamp value to memory. When the timestamp value is written, the availability status of the query is set to available.</p>  <blockquote> <h5 class="title">Note</h5>  <p>If an implementation is unable to detect completion and latch the timer at any specific stage of the pipeline, it <strong>may</strong> instead do so at any logically later stage.</p>  </blockquote>  <p><a href="#vkCmdCopyQueryPoolResults">vkCmdCopyQueryPoolResults</a> <strong>can</strong> then be called to copy the timestamp value from the query pool into buffer memory, with ordering and synchronization behavior equivalent to how other queries operate. Timestamp values <strong>can</strong> also be retrieved from the query pool using <a href="#vkGetQueryPoolResults">vkGetQueryPoolResults</a>. As with other queries, the query <strong>must</strong> be reset using <a href="#vkCmdResetQueryPool">vkCmdResetQueryPool</a> before requesting the timestamp value be written to it.</p>   <p>While <code>vkCmdWriteTimestamp</code> <strong>can</strong> be called inside or outside of a render pass instance, <a href="#vkCmdCopyQueryPoolResults">vkCmdCopyQueryPoolResults</a> <strong>must</strong> only be called outside of a render pass instance.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCmdWriteTimestamp-queryPool-01416">  <code>queryPool</code> <strong>must</strong> have been created with a <code>queryType</code> of <code>VK_QUERY_TYPE_TIMESTAMP</code> </li> <li id="VUID-vkCmdWriteTimestamp-queryPool-00828">  The query identified by <code>queryPool</code> and <code>query</code> <strong>must</strong> be <em>unavailable</em> </li> <li id="VUID-vkCmdWriteTimestamp-timestampValidBits-00829">  The command pool’s queue family <strong>must</strong> support a non-zero <code>timestampValidBits</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCmdWriteTimestamp-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkCmdWriteTimestamp-pipelineStage-parameter">  <code>pipelineStage</code> <strong>must</strong> be a valid <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> value </li> <li id="VUID-vkCmdWriteTimestamp-queryPool-parameter">  <code>queryPool</code> <strong>must</strong> be a valid <code>VkQueryPool</code> handle </li> <li id="VUID-vkCmdWriteTimestamp-commandBuffer-recording">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="#commandbuffers-lifecycle">recording state</a> </li> <li id="VUID-vkCmdWriteTimestamp-commandBuffer-cmdpool">  The <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> support graphics, or compute operations </li> <li id="VUID-vkCmdWriteTimestamp-commonparent">  Both of <code>commandBuffer</code>, and <code>queryPool</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">Primary<br> Secondary</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Both</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Graphics<br> compute</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Transfer</p></td> </tr> </tbody> </table></div>  </blockquote>   <h4 id="_see_also_50">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a>, <a href="#VkQueryPool">VkQueryPool</a></p>    <h4 id="_document_notes_50">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdWriteTimestamp">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCmdWriteTimestamp</a></p>         <h3 id="_vkcreatebuffer_3">vkCreateBuffer(3)</h3>  <h4 id="_name_51">Name</h4>  <p>vkCreateBuffer - Create a new buffer object</p>    <h4 id="_c_specification_51">C Specification</h4>  <p>To create buffers, call:</p>  <pre id="vkCreateBuffer" data-language="c++">VkResult vkCreateBuffer(
    VkDevice                                    device,
    const VkBufferCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBuffer*                                   pBuffer);</pre>   <h4 id="_parameters_51">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the buffer object. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <code>VkBufferCreateInfo</code> structure containing parameters affecting creation of the buffer. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pBuffer</code> points to a <code>VkBuffer</code> handle in which the resulting buffer object is returned. </li> </ul>    <h4 id="_description_51">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCreateBuffer-flags-00911">  If the <code>flags</code> member of <code>pCreateInfo</code> includes <code>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</code>, creating this <code>VkBuffer</code> <strong>must</strong> not cause the total required sparse memory for all currently valid sparse resources on the device to exceed <code>VkPhysicalDeviceLimits</code>::<code>sparseAddressSpaceSize</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateBuffer-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateBuffer-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkBufferCreateInfo</code> structure </li> <li id="VUID-vkCreateBuffer-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateBuffer-pBuffer-parameter">  <code>pBuffer</code> <strong>must</strong> be a pointer to a <code>VkBuffer</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_51">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkBuffer">VkBuffer</a>, <a href="#VkBufferCreateInfo">VkBufferCreateInfo</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_51">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateBuffer</a></p>         <h3 id="_vkcreatebufferview_3">vkCreateBufferView(3)</h3>  <h4 id="_name_52">Name</h4>  <p>vkCreateBufferView - Create a new buffer view object</p>    <h4 id="_c_specification_52">C Specification</h4>  <p>To create a buffer view, call:</p>  <pre id="vkCreateBufferView" data-language="c++">VkResult vkCreateBufferView(
    VkDevice                                    device,
    const VkBufferViewCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBufferView*                               pView);</pre>   <h4 id="_parameters_52">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the buffer view. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <code>VkBufferViewCreateInfo</code> structure containing parameters to be used to create the buffer. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pView</code> points to a <code>VkBufferView</code> handle in which the resulting buffer view object is returned. </li> </ul>    <h4 id="_description_52">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateBufferView-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateBufferView-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkBufferViewCreateInfo</code> structure </li> <li id="VUID-vkCreateBufferView-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateBufferView-pView-parameter">  <code>pView</code> <strong>must</strong> be a pointer to a <code>VkBufferView</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_52">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkBufferView">VkBufferView</a>, <a href="#VkBufferViewCreateInfo">VkBufferViewCreateInfo</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_52">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateBufferView">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateBufferView</a></p>         <h3 id="_vkcreatecommandpool_3">vkCreateCommandPool(3)</h3>  <h4 id="_name_53">Name</h4>  <p>vkCreateCommandPool - Create a new command pool object</p>    <h4 id="_c_specification_53">C Specification</h4>  <p>To create a command pool, call:</p>  <pre id="vkCreateCommandPool" data-language="c++">VkResult vkCreateCommandPool(
    VkDevice                                    device,
    const VkCommandPoolCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool);</pre>   <h4 id="_parameters_53">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the command pool. </li> <li> <code>pCreateInfo</code> contains information used to create the command pool. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pCommandPool</code> points to a <code>VkCommandPool</code> handle in which the created pool is returned. </li> </ul>    <h4 id="_description_53">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateCommandPool-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateCommandPool-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkCommandPoolCreateInfo</code> structure </li> <li id="VUID-vkCreateCommandPool-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateCommandPool-pCommandPool-parameter">  <code>pCommandPool</code> <strong>must</strong> be a pointer to a <code>VkCommandPool</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_53">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkCommandPool">VkCommandPool</a>, <a href="#VkCommandPoolCreateInfo">VkCommandPoolCreateInfo</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_53">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateCommandPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateCommandPool</a></p>         <h3 id="_vkcreatecomputepipelines_3">vkCreateComputePipelines(3)</h3>  <h4 id="_name_54">Name</h4>  <p>vkCreateComputePipelines - Creates a new compute pipeline object</p>    <h4 id="_c_specification_54">C Specification</h4>  <p>To create compute pipelines, call:</p>  <pre id="vkCreateComputePipelines" data-language="c++">VkResult vkCreateComputePipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkComputePipelineCreateInfo*          pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);</pre>   <h4 id="_parameters_54">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the compute pipelines. </li> <li> <code>pipelineCache</code> is either <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, indicating that pipeline caching is disabled; or the handle of a valid <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-cache">pipeline cache</a> object, in which case use of that cache is enabled for the duration of the command. </li> <li> <code>createInfoCount</code> is the length of the <code>pCreateInfos</code> and <code>pPipelines</code> arrays. </li> <li> <code>pCreateInfos</code> is an array of <code>VkComputePipelineCreateInfo</code> structures. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pPipelines</code> is a pointer to an array in which the resulting compute pipeline objects are returned. </li> </ul>    <h4 id="_description_54">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCreateComputePipelines-flags-00695">  If the <code>flags</code> member of any given element of <code>pCreateInfos</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, and the <code>basePipelineIndex</code> member of that same element is not <code>-1</code>, <code>basePipelineIndex</code> <strong>must</strong> be less than the index into <code>pCreateInfos</code> that corresponds to that element </li> <li id="VUID-vkCreateComputePipelines-flags-00696">  If the <code>flags</code> member of any given element of <code>pCreateInfos</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, the base pipeline <strong>must</strong> have been created with the <code>VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT</code> flag set </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateComputePipelines-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateComputePipelines-pipelineCache-parameter">  If <code>pipelineCache</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>pipelineCache</code> <strong>must</strong> be a valid <code>VkPipelineCache</code> handle </li> <li id="VUID-vkCreateComputePipelines-pCreateInfos-parameter">  <code>pCreateInfos</code> <strong>must</strong> be a pointer to an array of <code>createInfoCount</code> valid <code>VkComputePipelineCreateInfo</code> structures </li> <li id="VUID-vkCreateComputePipelines-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateComputePipelines-pPipelines-parameter">  <code>pPipelines</code> <strong>must</strong> be a pointer to an array of <code>createInfoCount</code> <code>VkPipeline</code> handles </li> <li id="VUID-vkCreateComputePipelines-createInfoCount-arraylength">  <code>createInfoCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCreateComputePipelines-pipelineCache-parent">  If <code>pipelineCache</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_54">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkComputePipelineCreateInfo">VkComputePipelineCreateInfo</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkPipeline">VkPipeline</a>, <a href="#VkPipelineCache">VkPipelineCache</a></p>    <h4 id="_document_notes_54">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateComputePipelines">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateComputePipelines</a></p>         <h3 id="_vkcreatedescriptorpool_3">vkCreateDescriptorPool(3)</h3>  <h4 id="_name_55">Name</h4>  <p>vkCreateDescriptorPool - Creates a descriptor pool object</p>    <h4 id="_c_specification_55">C Specification</h4>  <p>To create a descriptor pool object, call:</p>  <pre id="vkCreateDescriptorPool" data-language="c++">VkResult vkCreateDescriptorPool(
    VkDevice                                    device,
    const VkDescriptorPoolCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool);</pre>   <h4 id="_parameters_55">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the descriptor pool. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a> structure specifying the state of the descriptor pool object. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pDescriptorPool</code> points to a <code>VkDescriptorPool</code> handle in which the resulting descriptor pool object is returned. </li> </ul>    <h4 id="_description_55">Description</h4>  <p><code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter.</p>   <p>The created descriptor pool is returned in <code>pDescriptorPool</code>.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateDescriptorPool-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateDescriptorPool-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkDescriptorPoolCreateInfo</code> structure </li> <li id="VUID-vkCreateDescriptorPool-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateDescriptorPool-pDescriptorPool-parameter">  <code>pDescriptorPool</code> <strong>must</strong> be a pointer to a <code>VkDescriptorPool</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_55">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDescriptorPool">VkDescriptorPool</a>, <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_55">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateDescriptorPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateDescriptorPool</a></p>         <h3 id="_vkcreatedescriptorsetlayout_3">vkCreateDescriptorSetLayout(3)</h3>  <h4 id="_name_56">Name</h4>  <p>vkCreateDescriptorSetLayout - Create a new descriptor set layout</p>    <h4 id="_c_specification_56">C Specification</h4>  <p>To create descriptor set layout objects, call:</p>  <pre id="vkCreateDescriptorSetLayout" data-language="c++">VkResult vkCreateDescriptorSetLayout(
    VkDevice                                    device,
    const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout);</pre>   <h4 id="_parameters_56">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the descriptor set layout. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a> structure specifying the state of the descriptor set layout object. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pSetLayout</code> points to a <code>VkDescriptorSetLayout</code> handle in which the resulting descriptor set layout object is returned. </li> </ul>    <h4 id="_description_56">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateDescriptorSetLayout-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkDescriptorSetLayoutCreateInfo</code> structure </li> <li id="VUID-vkCreateDescriptorSetLayout-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter">  <code>pSetLayout</code> <strong>must</strong> be a pointer to a <code>VkDescriptorSetLayout</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_56">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a>, <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_56">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateDescriptorSetLayout">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateDescriptorSetLayout</a></p>         <h3 id="_vkcreatedevice_3">vkCreateDevice(3)</h3>  <h4 id="_name_57">Name</h4>  <p>vkCreateDevice - Create a new device instance</p>    <h4 id="_c_specification_57">C Specification</h4>  <p>A logical device is created as a <em>connection</em> to a physical device. To create a logical device, call:</p>  <pre id="vkCreateDevice" data-language="c++">VkResult vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);</pre>   <h4 id="_parameters_57">Parameters</h4>  <ul> <li> <code>physicalDevice</code> <strong>must</strong> be one of the device handles returned from a call to <code>vkEnumeratePhysicalDevices</code> (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-physical-device-enumeration">Physical Device Enumeration</a>). </li> <li> <code>pCreateInfo</code> is a pointer to a <a href="#VkDeviceCreateInfo">VkDeviceCreateInfo</a> structure containing information about how to create the device. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pDevice</code> points to a handle in which the created <code>VkDevice</code> is returned. </li> </ul>    <h4 id="_description_57">Description</h4>  <p><code>vkCreateDevice</code> verifies that extensions and features requested in the <code>ppEnabledExtensionNames</code> and <code>pEnabledFeatures</code> members of <code>pCreateInfo</code>, respectively, are supported by the implementation. If any requested extension is not supported, <code>vkCreateDevice</code> <strong>must</strong> return <code>VK_ERROR_EXTENSION_NOT_PRESENT</code>. If any requested feature is not supported, <code>vkCreateDevice</code> <strong>must</strong> return <code>VK_ERROR_FEATURE_NOT_PRESENT</code>. Support for extensions <strong>can</strong> be checked before creating a device by querying <a href="#vkEnumerateDeviceExtensionProperties">vkEnumerateDeviceExtensionProperties</a>. Support for features <strong>can</strong> similarly be checked by querying <a href="#vkGetPhysicalDeviceFeatures">vkGetPhysicalDeviceFeatures</a>.</p>   <p>After verifying and enabling the extensions the <code>VkDevice</code> object is created and returned to the application. If a requested extension is only supported by a layer, both the layer and the extension need to be specified at <code>vkCreateInstance</code> time for the creation to succeed.</p>   <p>Multiple logical devices <strong>can</strong> be created from the same physical device. Logical device creation <strong>may</strong> fail due to lack of device-specific resources (in addition to the other errors). If that occurs, <code>vkCreateDevice</code> will return <code>VK_ERROR_TOO_MANY_OBJECTS</code>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCreateDevice-ppEnabledExtensionNames-01387">  All <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#extended-functionality-extensions-dependencies">required extensions</a> for each extension in the <a href="#VkDeviceCreateInfo">VkDeviceCreateInfo</a>::<code>ppEnabledExtensionNames</code> list <strong>must</strong> also be present in that list. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateDevice-physicalDevice-parameter">  <code>physicalDevice</code> <strong>must</strong> be a valid <code>VkPhysicalDevice</code> handle </li> <li id="VUID-vkCreateDevice-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkDeviceCreateInfo</code> structure </li> <li id="VUID-vkCreateDevice-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateDevice-pDevice-parameter">  <code>pDevice</code> <strong>must</strong> be a pointer to a <code>VkDevice</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_INITIALIZATION_FAILED</code> </li> <li> <code>VK_ERROR_EXTENSION_NOT_PRESENT</code> </li> <li> <code>VK_ERROR_FEATURE_NOT_PRESENT</code> </li> <li> <code>VK_ERROR_TOO_MANY_OBJECTS</code> </li> <li> <code>VK_ERROR_DEVICE_LOST</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_57">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkDeviceCreateInfo">VkDeviceCreateInfo</a>, <a href="#VkPhysicalDevice">VkPhysicalDevice</a></p>    <h4 id="_document_notes_57">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateDevice">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateDevice</a></p>         <h3 id="_vkcreateevent_3">vkCreateEvent(3)</h3>  <h4 id="_name_58">Name</h4>  <p>vkCreateEvent - Create a new event object</p>    <h4 id="_c_specification_58">C Specification</h4>  <p>To create an event, call:</p>  <pre id="vkCreateEvent" data-language="c++">VkResult vkCreateEvent(
    VkDevice                                    device,
    const VkEventCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkEvent*                                    pEvent);</pre>   <h4 id="_parameters_58">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the event. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <code>VkEventCreateInfo</code> structure which contains information about how the event is to be created. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pEvent</code> points to a handle in which the resulting event object is returned. </li> </ul>    <h4 id="_description_58">Description</h4>  <p>When created, the event object is in the unsignaled state.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateEvent-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateEvent-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkEventCreateInfo</code> structure </li> <li id="VUID-vkCreateEvent-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateEvent-pEvent-parameter">  <code>pEvent</code> <strong>must</strong> be a pointer to a <code>VkEvent</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_58">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkEvent">VkEvent</a>, <a href="#VkEventCreateInfo">VkEventCreateInfo</a></p>    <h4 id="_document_notes_58">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateEvent">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateEvent</a></p>         <h3 id="_vkcreatefence_3">vkCreateFence(3)</h3>  <h4 id="_name_59">Name</h4>  <p>vkCreateFence - Create a new fence object</p>    <h4 id="_c_specification_59">C Specification</h4>  <p>To create a fence, call:</p>  <pre id="vkCreateFence" data-language="c++">VkResult vkCreateFence(
    VkDevice                                    device,
    const VkFenceCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence);</pre>   <h4 id="_parameters_59">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the fence. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <code>VkFenceCreateInfo</code> structure which contains information about how the fence is to be created. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pFence</code> points to a handle in which the resulting fence object is returned. </li> </ul>    <h4 id="_description_59">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateFence-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateFence-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkFenceCreateInfo</code> structure </li> <li id="VUID-vkCreateFence-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateFence-pFence-parameter">  <code>pFence</code> <strong>must</strong> be a pointer to a <code>VkFence</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_59">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkFence">VkFence</a>, <a href="#VkFenceCreateInfo">VkFenceCreateInfo</a></p>    <h4 id="_document_notes_59">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateFence">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateFence</a></p>         <h3 id="_vkcreateframebuffer_3">vkCreateFramebuffer(3)</h3>  <h4 id="_name_60">Name</h4>  <p>vkCreateFramebuffer - Create a new framebuffer object</p>    <h4 id="_c_specification_60">C Specification</h4>  <p>To create a framebuffer, call:</p>  <pre id="vkCreateFramebuffer" data-language="c++">VkResult vkCreateFramebuffer(
    VkDevice                                    device,
    const VkFramebufferCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFramebuffer*                              pFramebuffer);</pre>   <h4 id="_parameters_60">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the framebuffer. </li> <li> <code>pCreateInfo</code> points to a <a href="#VkFramebufferCreateInfo">VkFramebufferCreateInfo</a> structure which describes additional information about framebuffer creation. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pFramebuffer</code> points to a <code>VkFramebuffer</code> handle in which the resulting framebuffer object is returned. </li> </ul>    <h4 id="_description_60">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateFramebuffer-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateFramebuffer-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkFramebufferCreateInfo</code> structure </li> <li id="VUID-vkCreateFramebuffer-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateFramebuffer-pFramebuffer-parameter">  <code>pFramebuffer</code> <strong>must</strong> be a pointer to a <code>VkFramebuffer</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_60">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkFramebuffer">VkFramebuffer</a>, <a href="#VkFramebufferCreateInfo">VkFramebufferCreateInfo</a></p>    <h4 id="_document_notes_60">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateFramebuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateFramebuffer</a></p>         <h3 id="_vkcreategraphicspipelines_3">vkCreateGraphicsPipelines(3)</h3>  <h4 id="_name_61">Name</h4>  <p>vkCreateGraphicsPipelines - Create graphics pipelines</p>    <h4 id="_c_specification_61">C Specification</h4>  <p>To create graphics pipelines, call:</p>  <pre id="vkCreateGraphicsPipelines" data-language="c++">VkResult vkCreateGraphicsPipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkGraphicsPipelineCreateInfo*         pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);</pre>   <h4 id="_parameters_61">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the graphics pipelines. </li> <li> <code>pipelineCache</code> is either <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, indicating that pipeline caching is disabled; or the handle of a valid <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-cache">pipeline cache</a> object, in which case use of that cache is enabled for the duration of the command. </li> <li> <code>createInfoCount</code> is the length of the <code>pCreateInfos</code> and <code>pPipelines</code> arrays. </li> <li> <code>pCreateInfos</code> is an array of <code>VkGraphicsPipelineCreateInfo</code> structures. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pPipelines</code> is a pointer to an array in which the resulting graphics pipeline objects are returned. </li> </ul>    <h4 id="_description_61">Description</h4>  <p>The <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a> structure includes an array of shader create info structures containing all the desired active shader stages, as well as creation info to define all relevant fixed-function stages, and a pipeline layout.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCreateGraphicsPipelines-flags-00720">  If the <code>flags</code> member of any given element of <code>pCreateInfos</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, and the <code>basePipelineIndex</code> member of that same element is not <code>-1</code>, <code>basePipelineIndex</code> <strong>must</strong> be less than the index into <code>pCreateInfos</code> that corresponds to that element </li> <li id="VUID-vkCreateGraphicsPipelines-flags-00721">  If the <code>flags</code> member of any given element of <code>pCreateInfos</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, the base pipeline <strong>must</strong> have been created with the <code>VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT</code> flag set </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateGraphicsPipelines-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateGraphicsPipelines-pipelineCache-parameter">  If <code>pipelineCache</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>pipelineCache</code> <strong>must</strong> be a valid <code>VkPipelineCache</code> handle </li> <li id="VUID-vkCreateGraphicsPipelines-pCreateInfos-parameter">  <code>pCreateInfos</code> <strong>must</strong> be a pointer to an array of <code>createInfoCount</code> valid <code>VkGraphicsPipelineCreateInfo</code> structures </li> <li id="VUID-vkCreateGraphicsPipelines-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateGraphicsPipelines-pPipelines-parameter">  <code>pPipelines</code> <strong>must</strong> be a pointer to an array of <code>createInfoCount</code> <code>VkPipeline</code> handles </li> <li id="VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength">  <code>createInfoCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkCreateGraphicsPipelines-pipelineCache-parent">  If <code>pipelineCache</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_61">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipeline">VkPipeline</a>, <a href="#VkPipelineCache">VkPipelineCache</a></p>    <h4 id="_document_notes_61">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateGraphicsPipelines">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateGraphicsPipelines</a></p>         <h3 id="_vkcreateimage_3">vkCreateImage(3)</h3>  <h4 id="_name_62">Name</h4>  <p>vkCreateImage - Create a new image object</p>    <h4 id="_c_specification_62">C Specification</h4>  <p>To create images, call:</p>  <pre id="vkCreateImage" data-language="c++">VkResult vkCreateImage(
    VkDevice                                    device,
    const VkImageCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImage*                                    pImage);</pre>   <h4 id="_parameters_62">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the image. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <code>VkImageCreateInfo</code> structure containing parameters to be used to create the image. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pImage</code> points to a <code>VkImage</code> handle in which the resulting image object is returned. </li> </ul>    <h4 id="_description_62">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCreateImage-flags-00939">  If the <code>flags</code> member of <code>pCreateInfo</code> includes <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code>, creating this <code>VkImage</code> <strong>must</strong> not cause the total required sparse memory for all currently valid sparse resources on the device to exceed <code>VkPhysicalDeviceLimits</code>::<code>sparseAddressSpaceSize</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateImage-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateImage-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkImageCreateInfo</code> structure </li> <li id="VUID-vkCreateImage-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateImage-pImage-parameter">  <code>pImage</code> <strong>must</strong> be a pointer to a <code>VkImage</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_62">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageCreateInfo">VkImageCreateInfo</a></p>    <h4 id="_document_notes_62">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateImage">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateImage</a></p>         <h3 id="_vkcreateimageview_3">vkCreateImageView(3)</h3>  <h4 id="_name_63">Name</h4>  <p>vkCreateImageView - Create an image view from an existing image</p>    <h4 id="_c_specification_63">C Specification</h4>  <p>To create an image view, call:</p>  <pre id="vkCreateImageView" data-language="c++">VkResult vkCreateImageView(
    VkDevice                                    device,
    const VkImageViewCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImageView*                                pView);</pre>   <h4 id="_parameters_63">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the image view. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <code>VkImageViewCreateInfo</code> structure containing parameters to be used to create the image view. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pView</code> points to a <code>VkImageView</code> handle in which the resulting image view object is returned. </li> </ul>    <h4 id="_description_63">Description</h4>  <p>Some of the image creation parameters are inherited by the view. The remaining parameters are contained in the <code>pCreateInfo</code>.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateImageView-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateImageView-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkImageViewCreateInfo</code> structure </li> <li id="VUID-vkCreateImageView-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateImageView-pView-parameter">  <code>pView</code> <strong>must</strong> be a pointer to a <code>VkImageView</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_63">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkImageView">VkImageView</a>, <a href="#VkImageViewCreateInfo">VkImageViewCreateInfo</a></p>    <h4 id="_document_notes_63">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateImageView">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateImageView</a></p>         <h3 id="_vkcreateinstance_3">vkCreateInstance(3)</h3>  <h4 id="_name_64">Name</h4>  <p>vkCreateInstance - Create a new Vulkan instance</p>    <h4 id="_c_specification_64">C Specification</h4>  <p>To create an instance object, call:</p>  <pre id="vkCreateInstance" data-language="c++">VkResult vkCreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);</pre>   <h4 id="_parameters_64">Parameters</h4>  <ul> <li> <code>pCreateInfo</code> points to an instance of <a href="#VkInstanceCreateInfo">VkInstanceCreateInfo</a> controlling creation of the instance. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pInstance</code> points a <code>VkInstance</code> handle in which the resulting instance is returned. </li> </ul>    <h4 id="_description_64">Description</h4>  <p><code>vkCreateInstance</code> verifies that the requested layers exist. If not, <code>vkCreateInstance</code> will return <code>VK_ERROR_LAYER_NOT_PRESENT</code>. Next <code>vkCreateInstance</code> verifies that the requested extensions are supported (e.g. in the implementation or in any enabled instance layer) and if any requested extension is not supported, <code>vkCreateInstance</code> <strong>must</strong> return <code>VK_ERROR_EXTENSION_NOT_PRESENT</code>. After verifying and enabling the instance layers and extensions the <code>VkInstance</code> object is created and returned to the application. If a requested extension is only supported by a layer, both the layer and the extension need to be specified at <code>vkCreateInstance</code> time for the creation to succeed.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkCreateInstance-ppEnabledExtensionNames-01388">  All <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#extended-functionality-extensions-dependencies">required extensions</a> for each extension in the <a href="#VkInstanceCreateInfo">VkInstanceCreateInfo</a>::<code>ppEnabledExtensionNames</code> list <strong>must</strong> also be present in that list. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateInstance-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkInstanceCreateInfo</code> structure </li> <li id="VUID-vkCreateInstance-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateInstance-pInstance-parameter">  <code>pInstance</code> <strong>must</strong> be a pointer to a <code>VkInstance</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_INITIALIZATION_FAILED</code> </li> <li> <code>VK_ERROR_LAYER_NOT_PRESENT</code> </li> <li> <code>VK_ERROR_EXTENSION_NOT_PRESENT</code> </li> <li> <code>VK_ERROR_INCOMPATIBLE_DRIVER</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_64">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkInstance">VkInstance</a>, <a href="#VkInstanceCreateInfo">VkInstanceCreateInfo</a></p>    <h4 id="_document_notes_64">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateInstance">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateInstance</a></p>         <h3 id="_vkcreatepipelinecache_3">vkCreatePipelineCache(3)</h3>  <h4 id="_name_65">Name</h4>  <p>vkCreatePipelineCache - Creates a new pipeline cache</p>    <h4 id="_c_specification_65">C Specification</h4>  <p>To create pipeline cache objects, call:</p>  <pre id="vkCreatePipelineCache" data-language="c++">VkResult vkCreatePipelineCache(
    VkDevice                                    device,
    const VkPipelineCacheCreateInfo*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineCache*                            pPipelineCache);</pre>   <h4 id="_parameters_65">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the pipeline cache object. </li> <li> <code>pCreateInfo</code> is a pointer to a <code>VkPipelineCacheCreateInfo</code> structure that contains the initial parameters for the pipeline cache object. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pPipelineCache</code> is a pointer to a <code>VkPipelineCache</code> handle in which the resulting pipeline cache object is returned. </li> </ul>    <h4 id="_description_65">Description</h4> <blockquote> <h5 class="title">Note</h5>  <p>Applications <strong>can</strong> track and manage the total host memory size of a pipeline cache object using the <code>pAllocator</code>. Applications <strong>can</strong> limit the amount of data retrieved from a pipeline cache object in <code>vkGetPipelineCacheData</code>. Implementations <strong>should</strong> not internally limit the total number of entries added to a pipeline cache object or the total host memory consumed.</p>  </blockquote>  <p>Once created, a pipeline cache <strong>can</strong> be passed to the <code>vkCreateGraphicsPipelines</code> and <code>vkCreateComputePipelines</code> commands. If the pipeline cache passed into these commands is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, the implementation will query it for possible reuse opportunities and update it with new content. The use of the pipeline cache object in these commands is internally synchronized, and the same pipeline cache object <strong>can</strong> be used in multiple threads simultaneously.</p>  <blockquote> <h5 class="title">Note</h5>  <p>Implementations <strong>should</strong> make every effort to limit any critical sections to the actual accesses to the cache, which is expected to be significantly shorter than the duration of the <code>vkCreateGraphicsPipelines</code> and <code>vkCreateComputePipelines</code> commands.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreatePipelineCache-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreatePipelineCache-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineCacheCreateInfo</code> structure </li> <li id="VUID-vkCreatePipelineCache-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreatePipelineCache-pPipelineCache-parameter">  <code>pPipelineCache</code> <strong>must</strong> be a pointer to a <code>VkPipelineCache</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_65">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkPipelineCache">VkPipelineCache</a>, <a href="#VkPipelineCacheCreateInfo">VkPipelineCacheCreateInfo</a></p>    <h4 id="_document_notes_65">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreatePipelineCache">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreatePipelineCache</a></p>         <h3 id="_vkcreatepipelinelayout_3">vkCreatePipelineLayout(3)</h3>  <h4 id="_name_66">Name</h4>  <p>vkCreatePipelineLayout - Creates a new pipeline layout object</p>    <h4 id="_c_specification_66">C Specification</h4>  <p>To create a pipeline layout, call:</p>  <pre id="vkCreatePipelineLayout" data-language="c++">VkResult vkCreatePipelineLayout(
    VkDevice                                    device,
    const VkPipelineLayoutCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout);</pre>   <h4 id="_parameters_66">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the pipeline layout. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a> structure specifying the state of the pipeline layout object. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pPipelineLayout</code> points to a <code>VkPipelineLayout</code> handle in which the resulting pipeline layout object is returned. </li> </ul>    <h4 id="_description_66">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreatePipelineLayout-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreatePipelineLayout-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineLayoutCreateInfo</code> structure </li> <li id="VUID-vkCreatePipelineLayout-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreatePipelineLayout-pPipelineLayout-parameter">  <code>pPipelineLayout</code> <strong>must</strong> be a pointer to a <code>VkPipelineLayout</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_66">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkPipelineLayout">VkPipelineLayout</a>, <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a></p>    <h4 id="_document_notes_66">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreatePipelineLayout">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreatePipelineLayout</a></p>         <h3 id="_vkcreatequerypool_3">vkCreateQueryPool(3)</h3>  <h4 id="_name_67">Name</h4>  <p>vkCreateQueryPool - Create a new query pool object</p>    <h4 id="_c_specification_67">C Specification</h4>  <p>To create a query pool, call:</p>  <pre id="vkCreateQueryPool" data-language="c++">VkResult vkCreateQueryPool(
    VkDevice                                    device,
    const VkQueryPoolCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkQueryPool*                                pQueryPool);</pre>   <h4 id="_parameters_67">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the query pool. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <code>VkQueryPoolCreateInfo</code> structure containing the number and type of queries to be managed by the pool. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pQueryPool</code> is a pointer to a <code>VkQueryPool</code> handle in which the resulting query pool object is returned. </li> </ul>    <h4 id="_description_67">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateQueryPool-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateQueryPool-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkQueryPoolCreateInfo</code> structure </li> <li id="VUID-vkCreateQueryPool-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateQueryPool-pQueryPool-parameter">  <code>pQueryPool</code> <strong>must</strong> be a pointer to a <code>VkQueryPool</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_67">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkQueryPool">VkQueryPool</a>, <a href="#VkQueryPoolCreateInfo">VkQueryPoolCreateInfo</a></p>    <h4 id="_document_notes_67">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateQueryPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateQueryPool</a></p>         <h3 id="_vkcreaterenderpass_3">vkCreateRenderPass(3)</h3>  <h4 id="_name_68">Name</h4>  <p>vkCreateRenderPass - Create a new render pass object</p>    <h4 id="_c_specification_68">C Specification</h4>  <p>To create a render pass, call:</p>  <pre id="vkCreateRenderPass" data-language="c++">VkResult vkCreateRenderPass(
    VkDevice                                    device,
    const VkRenderPassCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass);</pre>   <h4 id="_parameters_68">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the render pass. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <a href="#VkRenderPassCreateInfo">VkRenderPassCreateInfo</a> structure that describes the parameters of the render pass. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pRenderPass</code> points to a <code>VkRenderPass</code> handle in which the resulting render pass object is returned. </li> </ul>    <h4 id="_description_68">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateRenderPass-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateRenderPass-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkRenderPassCreateInfo</code> structure </li> <li id="VUID-vkCreateRenderPass-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateRenderPass-pRenderPass-parameter">  <code>pRenderPass</code> <strong>must</strong> be a pointer to a <code>VkRenderPass</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_68">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkRenderPass">VkRenderPass</a>, <a href="#VkRenderPassCreateInfo">VkRenderPassCreateInfo</a></p>    <h4 id="_document_notes_68">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateRenderPass">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateRenderPass</a></p>         <h3 id="_vkcreatesampler_3">vkCreateSampler(3)</h3>  <h4 id="_name_69">Name</h4>  <p>vkCreateSampler - Create a new sampler object</p>    <h4 id="_c_specification_69">C Specification</h4>  <p>To create a sampler object, call:</p>  <pre id="vkCreateSampler" data-language="c++">VkResult vkCreateSampler(
    VkDevice                                    device,
    const VkSamplerCreateInfo*                  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSampler*                                  pSampler);</pre>   <h4 id="_parameters_69">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the sampler. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a> structure specifying the state of the sampler object. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pSampler</code> points to a <a href="#VkSampler">VkSampler</a> handle in which the resulting sampler object is returned. </li> </ul>    <h4 id="_description_69">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateSampler-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateSampler-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkSamplerCreateInfo</code> structure </li> <li id="VUID-vkCreateSampler-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateSampler-pSampler-parameter">  <code>pSampler</code> <strong>must</strong> be a pointer to a <code>VkSampler</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_TOO_MANY_OBJECTS</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_69">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkSampler">VkSampler</a>, <a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a></p>    <h4 id="_document_notes_69">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateSampler">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateSampler</a></p>         <h3 id="_vkcreatesemaphore_3">vkCreateSemaphore(3)</h3>  <h4 id="_name_70">Name</h4>  <p>vkCreateSemaphore - Create a new queue semaphore object</p>    <h4 id="_c_specification_70">C Specification</h4>  <p>To create a semaphore, call:</p>  <pre id="vkCreateSemaphore" data-language="c++">VkResult vkCreateSemaphore(
    VkDevice                                    device,
    const VkSemaphoreCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSemaphore*                                pSemaphore);</pre>   <h4 id="_parameters_70">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the semaphore. </li> <li> <code>pCreateInfo</code> is a pointer to an instance of the <code>VkSemaphoreCreateInfo</code> structure which contains information about how the semaphore is to be created. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pSemaphore</code> points to a handle in which the resulting semaphore object is returned. </li> </ul>    <h4 id="_description_70">Description</h4>  <p>When created, the semaphore is in the unsignaled state.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateSemaphore-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateSemaphore-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkSemaphoreCreateInfo</code> structure </li> <li id="VUID-vkCreateSemaphore-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateSemaphore-pSemaphore-parameter">  <code>pSemaphore</code> <strong>must</strong> be a pointer to a <code>VkSemaphore</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_70">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkSemaphore">VkSemaphore</a>, <a href="#VkSemaphoreCreateInfo">VkSemaphoreCreateInfo</a></p>    <h4 id="_document_notes_70">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateSemaphore">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateSemaphore</a></p>         <h3 id="_vkcreateshadermodule_3">vkCreateShaderModule(3)</h3>  <h4 id="_name_71">Name</h4>  <p>vkCreateShaderModule - Creates a new shader module object</p>    <h4 id="_c_specification_71">C Specification</h4>  <p>To create a shader module, call:</p>  <pre id="vkCreateShaderModule" data-language="c++">VkResult vkCreateShaderModule(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule);</pre>   <h4 id="_parameters_71">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that creates the shader module. </li> <li> <code>pCreateInfo</code> parameter is a pointer to an instance of the <code>VkShaderModuleCreateInfo</code> structure. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> <li> <code>pShaderModule</code> points to a <code>VkShaderModule</code> handle in which the resulting shader module object is returned. </li> </ul>    <h4 id="_description_71">Description</h4>  <p>Once a shader module has been created, any entry points it contains <strong>can</strong> be used in pipeline shader stages as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-compute">Compute Pipelines</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-graphics">Graphics Pipelines</a>.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkCreateShaderModule-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkCreateShaderModule-pCreateInfo-parameter">  <code>pCreateInfo</code> <strong>must</strong> be a pointer to a valid <code>VkShaderModuleCreateInfo</code> structure </li> <li id="VUID-vkCreateShaderModule-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkCreateShaderModule-pShaderModule-parameter">  <code>pShaderModule</code> <strong>must</strong> be a pointer to a <code>VkShaderModule</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_71">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkShaderModule">VkShaderModule</a>, <a href="#VkShaderModuleCreateInfo">VkShaderModuleCreateInfo</a></p>    <h4 id="_document_notes_71">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateShaderModule">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkCreateShaderModule</a></p>         <h3 id="_vkdestroybuffer_3">vkDestroyBuffer(3)</h3>  <h4 id="_name_72">Name</h4>  <p>vkDestroyBuffer - Destroy a buffer object</p>    <h4 id="_c_specification_72">C Specification</h4>  <p>To destroy a buffer, call:</p>  <pre id="vkDestroyBuffer" data-language="c++">void vkDestroyBuffer(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_72">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the buffer. </li> <li> <code>buffer</code> is the buffer to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_72">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyBuffer-buffer-00922">  All submitted commands that refer to <code>buffer</code>, either directly or via a <code>VkBufferView</code>, <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyBuffer-buffer-00923">  If <code>VkAllocationCallbacks</code> were provided when <code>buffer</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyBuffer-buffer-00924">  If no <code>VkAllocationCallbacks</code> were provided when <code>buffer</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyBuffer-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyBuffer-buffer-parameter">  If <code>buffer</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkDestroyBuffer-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyBuffer-buffer-parent">  If <code>buffer</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>buffer</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_72">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkBuffer">VkBuffer</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_72">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyBuffer</a></p>         <h3 id="_vkdestroybufferview_3">vkDestroyBufferView(3)</h3>  <h4 id="_name_73">Name</h4>  <p>vkDestroyBufferView - Destroy a buffer view object</p>    <h4 id="_c_specification_73">C Specification</h4>  <p>To destroy a buffer view, call:</p>  <pre id="vkDestroyBufferView" data-language="c++">void vkDestroyBufferView(
    VkDevice                                    device,
    VkBufferView                                bufferView,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_73">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the buffer view. </li> <li> <code>bufferView</code> is the buffer view to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_73">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyBufferView-bufferView-00936">  All submitted commands that refer to <code>bufferView</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyBufferView-bufferView-00937">  If <code>VkAllocationCallbacks</code> were provided when <code>bufferView</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyBufferView-bufferView-00938">  If no <code>VkAllocationCallbacks</code> were provided when <code>bufferView</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyBufferView-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyBufferView-bufferView-parameter">  If <code>bufferView</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>bufferView</code> <strong>must</strong> be a valid <code>VkBufferView</code> handle </li> <li id="VUID-vkDestroyBufferView-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyBufferView-bufferView-parent">  If <code>bufferView</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>bufferView</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_73">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkBufferView">VkBufferView</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_73">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyBufferView">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyBufferView</a></p>         <h3 id="_vkdestroycommandpool_3">vkDestroyCommandPool(3)</h3>  <h4 id="_name_74">Name</h4>  <p>vkDestroyCommandPool - Destroy a command pool object</p>    <h4 id="_c_specification_74">C Specification</h4>  <p>To destroy a command pool, call:</p>  <pre id="vkDestroyCommandPool" data-language="c++">void vkDestroyCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_74">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the command pool. </li> <li> <code>commandPool</code> is the handle of the command pool to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_74">Description</h4>  <p>When a pool is destroyed, all command buffers allocated from the pool are <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkFreeCommandBuffers">freed</a>.</p>   <p>Any primary command buffer allocated from another <a href="#VkCommandPool">VkCommandPool</a> that is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or executable state</a> and has a secondary command buffer allocated from <code>commandPool</code> recorded into it, becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyCommandPool-commandPool-00041">  All <code>VkCommandBuffer</code> objects allocated from <code>commandPool</code> <strong>must</strong> not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>. </li> <li id="VUID-vkDestroyCommandPool-commandPool-00042">  If <code>VkAllocationCallbacks</code> were provided when <code>commandPool</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyCommandPool-commandPool-00043">  If no <code>VkAllocationCallbacks</code> were provided when <code>commandPool</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyCommandPool-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyCommandPool-commandPool-parameter">  If <code>commandPool</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>commandPool</code> <strong>must</strong> be a valid <code>VkCommandPool</code> handle </li> <li id="VUID-vkDestroyCommandPool-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyCommandPool-commandPool-parent">  If <code>commandPool</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandPool</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_74">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkCommandPool">VkCommandPool</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_74">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyCommandPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyCommandPool</a></p>         <h3 id="_vkdestroydescriptorpool_3">vkDestroyDescriptorPool(3)</h3>  <h4 id="_name_75">Name</h4>  <p>vkDestroyDescriptorPool - Destroy a descriptor pool object</p>    <h4 id="_c_specification_75">C Specification</h4>  <p>To destroy a descriptor pool, call:</p>  <pre id="vkDestroyDescriptorPool" data-language="c++">void vkDestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_75">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the descriptor pool. </li> <li> <code>descriptorPool</code> is the descriptor pool to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_75">Description</h4>  <p>When a pool is destroyed, all descriptor sets allocated from the pool are implicitly freed and become invalid. Descriptor sets allocated from a given pool do not need to be freed before destroying that descriptor pool.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyDescriptorPool-descriptorPool-00303">  All submitted commands that refer to <code>descriptorPool</code> (via any allocated descriptor sets) <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyDescriptorPool-descriptorPool-00304">  If <code>VkAllocationCallbacks</code> were provided when <code>descriptorPool</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyDescriptorPool-descriptorPool-00305">  If no <code>VkAllocationCallbacks</code> were provided when <code>descriptorPool</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyDescriptorPool-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyDescriptorPool-descriptorPool-parameter">  If <code>descriptorPool</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>descriptorPool</code> <strong>must</strong> be a valid <code>VkDescriptorPool</code> handle </li> <li id="VUID-vkDestroyDescriptorPool-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyDescriptorPool-descriptorPool-parent">  If <code>descriptorPool</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>descriptorPool</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_75">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDescriptorPool">VkDescriptorPool</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_75">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyDescriptorPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyDescriptorPool</a></p>         <h3 id="_vkdestroydescriptorsetlayout_3">vkDestroyDescriptorSetLayout(3)</h3>  <h4 id="_name_76">Name</h4>  <p>vkDestroyDescriptorSetLayout - Destroy a descriptor set layout object</p>    <h4 id="_c_specification_76">C Specification</h4>  <p>To destroy a descriptor set layout, call:</p>  <pre id="vkDestroyDescriptorSetLayout" data-language="c++">void vkDestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_76">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the descriptor set layout. </li> <li> <code>descriptorSetLayout</code> is the descriptor set layout to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_76">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00284">  If <code>VkAllocationCallbacks</code> were provided when <code>descriptorSetLayout</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00285">  If no <code>VkAllocationCallbacks</code> were provided when <code>descriptorSetLayout</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyDescriptorSetLayout-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parameter">  If <code>descriptorSetLayout</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>descriptorSetLayout</code> <strong>must</strong> be a valid <code>VkDescriptorSetLayout</code> handle </li> <li id="VUID-vkDestroyDescriptorSetLayout-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parent">  If <code>descriptorSetLayout</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>descriptorSetLayout</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_76">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_76">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyDescriptorSetLayout">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyDescriptorSetLayout</a></p>         <h3 id="_vkdestroydevice_3">vkDestroyDevice(3)</h3>  <h4 id="_name_77">Name</h4>  <p>vkDestroyDevice - Destroy a logical device</p>    <h4 id="_c_specification_77">C Specification</h4>  <p>To destroy a device, call:</p>  <pre id="vkDestroyDevice" data-language="c++">void vkDestroyDevice(
    VkDevice                                    device,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_77">Parameters</h4>  <ul> <li> <code>device</code> is the logical device to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_77">Description</h4>  <p>To ensure that no work is active on the device, <a href="#vkDeviceWaitIdle">vkDeviceWaitIdle</a> <strong>can</strong> be used to gate the destruction of the device. Prior to destroying a device, an application is responsible for destroying/freeing any Vulkan objects that were created using that device as the first parameter of the corresponding <code>vkCreate*</code> or <code>vkAllocate*</code> command.</p>  <blockquote> <h5 class="title">Note</h5>  <p>The lifetime of each of these objects is bound by the lifetime of the <code>VkDevice</code> object. Therefore, to avoid resource leaks, it is critical that an application explicitly free all of these resources prior to calling <code>vkDestroyDevice</code>.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyDevice-device-00378">  All child objects created on <code>device</code> <strong>must</strong> have been destroyed prior to destroying <code>device</code> </li> <li id="VUID-vkDestroyDevice-device-00379">  If <code>VkAllocationCallbacks</code> were provided when <code>device</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyDevice-device-00380">  If no <code>VkAllocationCallbacks</code> were provided when <code>device</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyDevice-device-parameter">  If <code>device</code> is not <code>NULL</code>, <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyDevice-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>device</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_77">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_77">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyDevice">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyDevice</a></p>         <h3 id="_vkdestroyevent_3">vkDestroyEvent(3)</h3>  <h4 id="_name_78">Name</h4>  <p>vkDestroyEvent - Destroy an event object</p>    <h4 id="_c_specification_78">C Specification</h4>  <p>To destroy an event, call:</p>  <pre id="vkDestroyEvent" data-language="c++">void vkDestroyEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_78">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the event. </li> <li> <code>event</code> is the handle of the event to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_78">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyEvent-event-01145">  All submitted commands that refer to <code>event</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyEvent-event-01146">  If <code>VkAllocationCallbacks</code> were provided when <code>event</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyEvent-event-01147">  If no <code>VkAllocationCallbacks</code> were provided when <code>event</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyEvent-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyEvent-event-parameter">  If <code>event</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>event</code> <strong>must</strong> be a valid <code>VkEvent</code> handle </li> <li id="VUID-vkDestroyEvent-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyEvent-event-parent">  If <code>event</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>event</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_78">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkEvent">VkEvent</a></p>    <h4 id="_document_notes_78">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyEvent">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyEvent</a></p>         <h3 id="_vkdestroyfence_3">vkDestroyFence(3)</h3>  <h4 id="_name_79">Name</h4>  <p>vkDestroyFence - Destroy a fence object</p>    <h4 id="_c_specification_79">C Specification</h4>  <p>To destroy a fence, call:</p>  <pre id="vkDestroyFence" data-language="c++">void vkDestroyFence(
    VkDevice                                    device,
    VkFence                                     fence,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_79">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the fence. </li> <li> <code>fence</code> is the handle of the fence to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_79">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyFence-fence-01120">  All <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission">queue submission</a> commands that refer to <code>fence</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyFence-fence-01121">  If <code>VkAllocationCallbacks</code> were provided when <code>fence</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyFence-fence-01122">  If no <code>VkAllocationCallbacks</code> were provided when <code>fence</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyFence-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyFence-fence-parameter">  If <code>fence</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>fence</code> <strong>must</strong> be a valid <code>VkFence</code> handle </li> <li id="VUID-vkDestroyFence-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyFence-fence-parent">  If <code>fence</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>fence</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_79">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkFence">VkFence</a></p>    <h4 id="_document_notes_79">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyFence">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyFence</a></p>         <h3 id="_vkdestroyframebuffer_3">vkDestroyFramebuffer(3)</h3>  <h4 id="_name_80">Name</h4>  <p>vkDestroyFramebuffer - Destroy a framebuffer object</p>    <h4 id="_c_specification_80">C Specification</h4>  <p>To destroy a framebuffer, call:</p>  <pre id="vkDestroyFramebuffer" data-language="c++">void vkDestroyFramebuffer(
    VkDevice                                    device,
    VkFramebuffer                               framebuffer,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_80">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the framebuffer. </li> <li> <code>framebuffer</code> is the handle of the framebuffer to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_80">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyFramebuffer-framebuffer-00892">  All submitted commands that refer to <code>framebuffer</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyFramebuffer-framebuffer-00893">  If <code>VkAllocationCallbacks</code> were provided when <code>framebuffer</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyFramebuffer-framebuffer-00894">  If no <code>VkAllocationCallbacks</code> were provided when <code>framebuffer</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyFramebuffer-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyFramebuffer-framebuffer-parameter">  If <code>framebuffer</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>framebuffer</code> <strong>must</strong> be a valid <code>VkFramebuffer</code> handle </li> <li id="VUID-vkDestroyFramebuffer-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyFramebuffer-framebuffer-parent">  If <code>framebuffer</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>framebuffer</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_80">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkFramebuffer">VkFramebuffer</a></p>    <h4 id="_document_notes_80">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyFramebuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyFramebuffer</a></p>         <h3 id="_vkdestroyimage_3">vkDestroyImage(3)</h3>  <h4 id="_name_81">Name</h4>  <p>vkDestroyImage - Destroy an image object</p>    <h4 id="_c_specification_81">C Specification</h4>  <p>To destroy an image, call:</p>  <pre id="vkDestroyImage" data-language="c++">void vkDestroyImage(
    VkDevice                                    device,
    VkImage                                     image,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_81">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the image. </li> <li> <code>image</code> is the image to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_81">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyImage-image-01000">  All submitted commands that refer to <code>image</code>, either directly or via a <code>VkImageView</code>, <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyImage-image-01001">  If <code>VkAllocationCallbacks</code> were provided when <code>image</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyImage-image-01002">  If no <code>VkAllocationCallbacks</code> were provided when <code>image</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyImage-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyImage-image-parameter">  If <code>image</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkDestroyImage-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyImage-image-parent">  If <code>image</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>image</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_81">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkImage">VkImage</a></p>    <h4 id="_document_notes_81">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyImage">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyImage</a></p>         <h3 id="_vkdestroyimageview_3">vkDestroyImageView(3)</h3>  <h4 id="_name_82">Name</h4>  <p>vkDestroyImageView - Destroy an image view object</p>    <h4 id="_c_specification_82">C Specification</h4>  <p>To destroy an image view, call:</p>  <pre id="vkDestroyImageView" data-language="c++">void vkDestroyImageView(
    VkDevice                                    device,
    VkImageView                                 imageView,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_82">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the image view. </li> <li> <code>imageView</code> is the image view to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_82">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyImageView-imageView-01026">  All submitted commands that refer to <code>imageView</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyImageView-imageView-01027">  If <code>VkAllocationCallbacks</code> were provided when <code>imageView</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyImageView-imageView-01028">  If no <code>VkAllocationCallbacks</code> were provided when <code>imageView</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyImageView-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyImageView-imageView-parameter">  If <code>imageView</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>imageView</code> <strong>must</strong> be a valid <code>VkImageView</code> handle </li> <li id="VUID-vkDestroyImageView-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyImageView-imageView-parent">  If <code>imageView</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>imageView</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_82">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkImageView">VkImageView</a></p>    <h4 id="_document_notes_82">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyImageView">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyImageView</a></p>         <h3 id="_vkdestroyinstance_3">vkDestroyInstance(3)</h3>  <h4 id="_name_83">Name</h4>  <p>vkDestroyInstance - Destroy an instance of Vulkan</p>    <h4 id="_c_specification_83">C Specification</h4>  <p>To destroy an instance, call:</p>  <pre id="vkDestroyInstance" data-language="c++">void vkDestroyInstance(
    VkInstance                                  instance,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_83">Parameters</h4>  <ul> <li> <code>instance</code> is the handle of the instance to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_83">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyInstance-instance-00629">  All child objects created using <code>instance</code> <strong>must</strong> have been destroyed prior to destroying <code>instance</code> </li> <li id="VUID-vkDestroyInstance-instance-00630">  If <code>VkAllocationCallbacks</code> were provided when <code>instance</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyInstance-instance-00631">  If no <code>VkAllocationCallbacks</code> were provided when <code>instance</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyInstance-instance-parameter">  If <code>instance</code> is not <code>NULL</code>, <code>instance</code> <strong>must</strong> be a valid <code>VkInstance</code> handle </li> <li id="VUID-vkDestroyInstance-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>instance</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_83">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkInstance">VkInstance</a></p>    <h4 id="_document_notes_83">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyInstance">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyInstance</a></p>         <h3 id="_vkdestroypipeline_3">vkDestroyPipeline(3)</h3>  <h4 id="_name_84">Name</h4>  <p>vkDestroyPipeline - Destroy a pipeline object</p>    <h4 id="_c_specification_84">C Specification</h4>  <p>To destroy a graphics or compute pipeline, call:</p>  <pre id="vkDestroyPipeline" data-language="c++">void vkDestroyPipeline(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_84">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the pipeline. </li> <li> <code>pipeline</code> is the handle of the pipeline to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_84">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyPipeline-pipeline-00765">  All submitted commands that refer to <code>pipeline</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyPipeline-pipeline-00766">  If <code>VkAllocationCallbacks</code> were provided when <code>pipeline</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyPipeline-pipeline-00767">  If no <code>VkAllocationCallbacks</code> were provided when <code>pipeline</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyPipeline-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyPipeline-pipeline-parameter">  If <code>pipeline</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>pipeline</code> <strong>must</strong> be a valid <code>VkPipeline</code> handle </li> <li id="VUID-vkDestroyPipeline-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyPipeline-pipeline-parent">  If <code>pipeline</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>pipeline</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_84">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkPipeline">VkPipeline</a></p>    <h4 id="_document_notes_84">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyPipeline">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyPipeline</a></p>         <h3 id="_vkdestroypipelinecache_3">vkDestroyPipelineCache(3)</h3>  <h4 id="_name_85">Name</h4>  <p>vkDestroyPipelineCache - Destroy a pipeline cache object</p>    <h4 id="_c_specification_85">C Specification</h4>  <p>To destroy a pipeline cache, call:</p>  <pre id="vkDestroyPipelineCache" data-language="c++">void vkDestroyPipelineCache(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_85">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the pipeline cache object. </li> <li> <code>pipelineCache</code> is the handle of the pipeline cache to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_85">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyPipelineCache-pipelineCache-00771">  If <code>VkAllocationCallbacks</code> were provided when <code>pipelineCache</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyPipelineCache-pipelineCache-00772">  If no <code>VkAllocationCallbacks</code> were provided when <code>pipelineCache</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyPipelineCache-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyPipelineCache-pipelineCache-parameter">  If <code>pipelineCache</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>pipelineCache</code> <strong>must</strong> be a valid <code>VkPipelineCache</code> handle </li> <li id="VUID-vkDestroyPipelineCache-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyPipelineCache-pipelineCache-parent">  If <code>pipelineCache</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>pipelineCache</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_85">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkPipelineCache">VkPipelineCache</a></p>    <h4 id="_document_notes_85">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyPipelineCache">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyPipelineCache</a></p>         <h3 id="_vkdestroypipelinelayout_3">vkDestroyPipelineLayout(3)</h3>  <h4 id="_name_86">Name</h4>  <p>vkDestroyPipelineLayout - Destroy a pipeline layout object</p>    <h4 id="_c_specification_86">C Specification</h4>  <p>To destroy a pipeline layout, call:</p>  <pre id="vkDestroyPipelineLayout" data-language="c++">void vkDestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_86">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the pipeline layout. </li> <li> <code>pipelineLayout</code> is the pipeline layout to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_86">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyPipelineLayout-pipelineLayout-00299">  If <code>VkAllocationCallbacks</code> were provided when <code>pipelineLayout</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyPipelineLayout-pipelineLayout-00300">  If no <code>VkAllocationCallbacks</code> were provided when <code>pipelineLayout</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyPipelineLayout-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyPipelineLayout-pipelineLayout-parameter">  If <code>pipelineLayout</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>pipelineLayout</code> <strong>must</strong> be a valid <code>VkPipelineLayout</code> handle </li> <li id="VUID-vkDestroyPipelineLayout-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyPipelineLayout-pipelineLayout-parent">  If <code>pipelineLayout</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>pipelineLayout</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_86">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkPipelineLayout">VkPipelineLayout</a></p>    <h4 id="_document_notes_86">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyPipelineLayout">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyPipelineLayout</a></p>         <h3 id="_vkdestroyquerypool_3">vkDestroyQueryPool(3)</h3>  <h4 id="_name_87">Name</h4>  <p>vkDestroyQueryPool - Destroy a query pool object</p>    <h4 id="_c_specification_87">C Specification</h4>  <p>To destroy a query pool, call:</p>  <pre id="vkDestroyQueryPool" data-language="c++">void vkDestroyQueryPool(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_87">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the query pool. </li> <li> <code>queryPool</code> is the query pool to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_87">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyQueryPool-queryPool-00793">  All submitted commands that refer to <code>queryPool</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyQueryPool-queryPool-00794">  If <code>VkAllocationCallbacks</code> were provided when <code>queryPool</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyQueryPool-queryPool-00795">  If no <code>VkAllocationCallbacks</code> were provided when <code>queryPool</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyQueryPool-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyQueryPool-queryPool-parameter">  If <code>queryPool</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>queryPool</code> <strong>must</strong> be a valid <code>VkQueryPool</code> handle </li> <li id="VUID-vkDestroyQueryPool-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyQueryPool-queryPool-parent">  If <code>queryPool</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>queryPool</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_87">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkQueryPool">VkQueryPool</a></p>    <h4 id="_document_notes_87">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyQueryPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyQueryPool</a></p>         <h3 id="_vkdestroyrenderpass_3">vkDestroyRenderPass(3)</h3>  <h4 id="_name_88">Name</h4>  <p>vkDestroyRenderPass - Destroy a render pass object</p>    <h4 id="_c_specification_88">C Specification</h4>  <p>To destroy a render pass, call:</p>  <pre id="vkDestroyRenderPass" data-language="c++">void vkDestroyRenderPass(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_88">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the render pass. </li> <li> <code>renderPass</code> is the handle of the render pass to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_88">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyRenderPass-renderPass-00873">  All submitted commands that refer to <code>renderPass</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroyRenderPass-renderPass-00874">  If <code>VkAllocationCallbacks</code> were provided when <code>renderPass</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyRenderPass-renderPass-00875">  If no <code>VkAllocationCallbacks</code> were provided when <code>renderPass</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyRenderPass-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyRenderPass-renderPass-parameter">  If <code>renderPass</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>renderPass</code> <strong>must</strong> be a valid <code>VkRenderPass</code> handle </li> <li id="VUID-vkDestroyRenderPass-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyRenderPass-renderPass-parent">  If <code>renderPass</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>renderPass</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_88">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkRenderPass">VkRenderPass</a></p>    <h4 id="_document_notes_88">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyRenderPass">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyRenderPass</a></p>         <h3 id="_vkdestroysampler_3">vkDestroySampler(3)</h3>  <h4 id="_name_89">Name</h4>  <p>vkDestroySampler - Destroy a sampler object</p>    <h4 id="_c_specification_89">C Specification</h4>  <p>To destroy a sampler, call:</p>  <pre id="vkDestroySampler" data-language="c++">void vkDestroySampler(
    VkDevice                                    device,
    VkSampler                                   sampler,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_89">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the sampler. </li> <li> <code>sampler</code> is the sampler to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_89">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroySampler-sampler-01082">  All submitted commands that refer to <code>sampler</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroySampler-sampler-01083">  If <code>VkAllocationCallbacks</code> were provided when <code>sampler</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroySampler-sampler-01084">  If no <code>VkAllocationCallbacks</code> were provided when <code>sampler</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroySampler-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroySampler-sampler-parameter">  If <code>sampler</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>sampler</code> <strong>must</strong> be a valid <code>VkSampler</code> handle </li> <li id="VUID-vkDestroySampler-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroySampler-sampler-parent">  If <code>sampler</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>sampler</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_89">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkSampler">VkSampler</a></p>    <h4 id="_document_notes_89">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroySampler">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroySampler</a></p>         <h3 id="_vkdestroysemaphore_3">vkDestroySemaphore(3)</h3>  <h4 id="_name_90">Name</h4>  <p>vkDestroySemaphore - Destroy a semaphore object</p>    <h4 id="_c_specification_90">C Specification</h4>  <p>To destroy a semaphore, call:</p>  <pre id="vkDestroySemaphore" data-language="c++">void vkDestroySemaphore(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_90">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the semaphore. </li> <li> <code>semaphore</code> is the handle of the semaphore to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_90">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroySemaphore-semaphore-01137">  All submitted batches that refer to <code>semaphore</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkDestroySemaphore-semaphore-01138">  If <code>VkAllocationCallbacks</code> were provided when <code>semaphore</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroySemaphore-semaphore-01139">  If no <code>VkAllocationCallbacks</code> were provided when <code>semaphore</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroySemaphore-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroySemaphore-semaphore-parameter">  If <code>semaphore</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>semaphore</code> <strong>must</strong> be a valid <code>VkSemaphore</code> handle </li> <li id="VUID-vkDestroySemaphore-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroySemaphore-semaphore-parent">  If <code>semaphore</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>semaphore</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_90">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkSemaphore">VkSemaphore</a></p>    <h4 id="_document_notes_90">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroySemaphore">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroySemaphore</a></p>         <h3 id="_vkdestroyshadermodule_3">vkDestroyShaderModule(3)</h3>  <h4 id="_name_91">Name</h4>  <p>vkDestroyShaderModule - Destroy a shader module module</p>    <h4 id="_c_specification_91">C Specification</h4>  <p>To destroy a shader module, call:</p>  <pre id="vkDestroyShaderModule" data-language="c++">void vkDestroyShaderModule(
    VkDevice                                    device,
    VkShaderModule                              shaderModule,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_91">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that destroys the shader module. </li> <li> <code>shaderModule</code> is the handle of the shader module to destroy. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_91">Description</h4>  <p>A shader module <strong>can</strong> be destroyed while pipelines created using its shaders are still in use.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkDestroyShaderModule-shaderModule-01092">  If <code>VkAllocationCallbacks</code> were provided when <code>shaderModule</code> was created, a compatible set of callbacks <strong>must</strong> be provided here </li> <li id="VUID-vkDestroyShaderModule-shaderModule-01093">  If no <code>VkAllocationCallbacks</code> were provided when <code>shaderModule</code> was created, <code>pAllocator</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDestroyShaderModule-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkDestroyShaderModule-shaderModule-parameter">  If <code>shaderModule</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>shaderModule</code> <strong>must</strong> be a valid <code>VkShaderModule</code> handle </li> <li id="VUID-vkDestroyShaderModule-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkDestroyShaderModule-shaderModule-parent">  If <code>shaderModule</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>shaderModule</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_91">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkShaderModule">VkShaderModule</a></p>    <h4 id="_document_notes_91">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyShaderModule">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDestroyShaderModule</a></p>         <h3 id="_vkdevicewaitidle_3">vkDeviceWaitIdle(3)</h3>  <h4 id="_name_92">Name</h4>  <p>vkDeviceWaitIdle - Wait for a device to become idle</p>    <h4 id="_c_specification_92">C Specification</h4>  <p>To wait on the host for the completion of outstanding queue operations for all queues on a given logical device, call:</p>  <pre id="vkDeviceWaitIdle" data-language="c++">VkResult vkDeviceWaitIdle(
    VkDevice                                    device);</pre>   <h4 id="_parameters_92">Parameters</h4>  <ul> <li> <code>device</code> is the logical device to idle. </li> </ul>    <h4 id="_description_92">Description</h4>  <p><code>vkDeviceWaitIdle</code> is equivalent to calling <code>vkQueueWaitIdle</code> for all queues owned by <code>device</code>.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkDeviceWaitIdle-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to all <code>VkQueue</code> objects created from <code>device</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_DEVICE_LOST</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_92">See Also</h4>  <p><a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_92">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDeviceWaitIdle">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkDeviceWaitIdle</a></p>         <h3 id="_vkendcommandbuffer_3">vkEndCommandBuffer(3)</h3>  <h4 id="_name_93">Name</h4>  <p>vkEndCommandBuffer - Finish recording a command buffer</p>    <h4 id="_c_specification_93">C Specification</h4>  <p>To complete recording of a command buffer, call:</p>  <pre id="vkEndCommandBuffer" data-language="c++">VkResult vkEndCommandBuffer(
    VkCommandBuffer                             commandBuffer);</pre>   <h4 id="_parameters_93">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer to complete recording. </li> </ul>    <h4 id="_description_93">Description</h4>  <p>If there was an error during recording, the application will be notified by an unsuccessful return code returned by <code>vkEndCommandBuffer</code>. If the application wishes to further use the command buffer, the command buffer <strong>must</strong> be reset. The command buffer <strong>must</strong> have been in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording state</a>, and is moved to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">executable state</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkEndCommandBuffer-commandBuffer-00059">  <code>commandBuffer</code> <strong>must</strong> be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording state</a>. </li> <li id="VUID-vkEndCommandBuffer-commandBuffer-00060">  If <code>commandBuffer</code> is a primary command buffer, there <strong>must</strong> not be an active render pass instance </li> <li id="VUID-vkEndCommandBuffer-commandBuffer-00061">  All queries made <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active">active</a> during the recording of <code>commandBuffer</code> <strong>must</strong> have been made inactive </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkEndCommandBuffer-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> <li> Host access to the <code>VkCommandPool</code> that <code>commandBuffer</code> was allocated from <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_93">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a></p>    <h4 id="_document_notes_93">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEndCommandBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEndCommandBuffer</a></p>         <h3 id="_vkenumeratedeviceextensionproperties_3">vkEnumerateDeviceExtensionProperties(3)</h3>  <h4 id="_name_94">Name</h4>  <p>vkEnumerateDeviceExtensionProperties - Returns properties of available physical device extensions</p>    <h4 id="_c_specification_94">C Specification</h4>  <p>To query the extensions available to a given physical device, call:</p>  <pre id="vkEnumerateDeviceExtensionProperties" data-language="c++">VkResult vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice                            physicalDevice,
    const char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties);</pre>   <h4 id="_parameters_94">Parameters</h4>  <ul> <li> <code>physicalDevice</code> is the physical device that will be queried. </li> <li> <code>pLayerName</code> is either <code>NULL</code> or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. </li> <li> <code>pPropertyCount</code> is a pointer to an integer related to the number of extension properties available or queried, and is treated in the same fashion as the <a href="#vkEnumerateInstanceExtensionProperties">vkEnumerateInstanceExtensionProperties</a>::<code>pPropertyCount</code> parameter. </li> <li> <code>pProperties</code> is either <code>NULL</code> or a pointer to an array of <a href="#VkExtensionProperties">VkExtensionProperties</a> structures. </li> </ul>    <h4 id="_description_94">Description</h4>  <p>When <code>pLayerName</code> parameter is NULL, only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When <code>pLayerName</code> is the name of a layer, the device extensions provided by that layer are returned.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkEnumerateDeviceExtensionProperties-physicalDevice-parameter">  <code>physicalDevice</code> <strong>must</strong> be a valid <code>VkPhysicalDevice</code> handle </li> <li id="VUID-vkEnumerateDeviceExtensionProperties-pLayerName-parameter">  If <code>pLayerName</code> is not <code>NULL</code>, <code>pLayerName</code> <strong>must</strong> be a null-terminated UTF-8 string </li> <li id="VUID-vkEnumerateDeviceExtensionProperties-pPropertyCount-parameter">  <code>pPropertyCount</code> <strong>must</strong> be a pointer to a <code>uint32_t</code> value </li> <li id="VUID-vkEnumerateDeviceExtensionProperties-pProperties-parameter">  If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong>must</strong> be a pointer to an array of <code>pPropertyCount</code> <code>VkExtensionProperties</code> structures </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> <li> <code>VK_INCOMPLETE</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_LAYER_NOT_PRESENT</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_94">See Also</h4>  <p><a href="#VkExtensionProperties">VkExtensionProperties</a>, <a href="#VkPhysicalDevice">VkPhysicalDevice</a></p>    <h4 id="_document_notes_94">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEnumerateDeviceExtensionProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEnumerateDeviceExtensionProperties</a></p>         <h3 id="_vkenumeratedevicelayerproperties_3">vkEnumerateDeviceLayerProperties(3)</h3>  <h4 id="_name_95">Name</h4>  <p>vkEnumerateDeviceLayerProperties - Returns properties of available physical device layers</p>    <h4 id="_c_specification_95">C Specification</h4>  <p>To enumerate device layers, call:</p>  <pre id="vkEnumerateDeviceLayerProperties" data-language="c++">VkResult vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties);</pre>   <h4 id="_parameters_95">Parameters</h4>  <ul> <li> <code>pPropertyCount</code> is a pointer to an integer related to the number of layer properties available or queried. </li> <li> <code>pProperties</code> is either <code>NULL</code> or a pointer to an array of <a href="#VkLayerProperties">VkLayerProperties</a> structures. </li> </ul>    <h4 id="_description_95">Description</h4>  <p>If <code>pProperties</code> is <code>NULL</code>, then the number of layer properties available is returned in <code>pPropertyCount</code>. Otherwise, <code>pPropertyCount</code> <strong>must</strong> point to a variable set by the user to the number of elements in the <code>pProperties</code> array, and on return the variable is overwritten with the number of structures actually written to <code>pProperties</code>. If <code>pPropertyCount</code> is less than the number of layer properties available, at most <code>pPropertyCount</code> structures will be written. If <code>pPropertyCount</code> is smaller than the number of layers available, <code>VK_INCOMPLETE</code> will be returned instead of <code>VK_SUCCESS</code>, to indicate that not all the available layer properties were returned.</p>   <p>The list of layers enumerated by <code>vkEnumerateDeviceLayerProperties</code> <strong>must</strong> be exactly the sequence of layers enabled for the instance. The members of <code>VkLayerProperties</code> for each enumerated layer <strong>must</strong> be the same as the properties when the layer was enumerated by <code>vkEnumerateInstanceLayerProperties</code>.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkEnumerateDeviceLayerProperties-physicalDevice-parameter">  <code>physicalDevice</code> <strong>must</strong> be a valid <code>VkPhysicalDevice</code> handle </li> <li id="VUID-vkEnumerateDeviceLayerProperties-pPropertyCount-parameter">  <code>pPropertyCount</code> <strong>must</strong> be a pointer to a <code>uint32_t</code> value </li> <li id="VUID-vkEnumerateDeviceLayerProperties-pProperties-parameter">  If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong>must</strong> be a pointer to an array of <code>pPropertyCount</code> <code>VkLayerProperties</code> structures </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> <li> <code>VK_INCOMPLETE</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_95">See Also</h4>  <p><a href="#VkLayerProperties">VkLayerProperties</a>, <a href="#VkPhysicalDevice">VkPhysicalDevice</a></p>    <h4 id="_document_notes_95">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEnumerateDeviceLayerProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEnumerateDeviceLayerProperties</a></p>         <h3 id="_vkenumerateinstanceextensionproperties_3">vkEnumerateInstanceExtensionProperties(3)</h3>  <h4 id="_name_96">Name</h4>  <p>vkEnumerateInstanceExtensionProperties - Returns up to requested number of global extension properties</p>    <h4 id="_c_specification_96">C Specification</h4>  <p>To query the available instance extensions, call:</p>  <pre id="vkEnumerateInstanceExtensionProperties" data-language="c++">VkResult vkEnumerateInstanceExtensionProperties(
    const char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties);</pre>   <h4 id="_parameters_96">Parameters</h4>  <ul> <li> <code>pLayerName</code> is either <code>NULL</code> or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from. </li> <li> <code>pPropertyCount</code> is a pointer to an integer related to the number of extension properties available or queried, as described below. </li> <li> <code>pProperties</code> is either <code>NULL</code> or a pointer to an array of <a href="#VkExtensionProperties">VkExtensionProperties</a> structures. </li> </ul>    <h4 id="_description_96">Description</h4>  <p>When <code>pLayerName</code> parameter is NULL, only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When <code>pLayerName</code> is the name of a layer, the instance extensions provided by that layer are returned.</p>   <p>If <code>pProperties</code> is <code>NULL</code>, then the number of extensions properties available is returned in <code>pPropertyCount</code>. Otherwise, <code>pPropertyCount</code> <strong>must</strong> point to a variable set by the user to the number of elements in the <code>pProperties</code> array, and on return the variable is overwritten with the number of structures actually written to <code>pProperties</code>. If <code>pPropertyCount</code> is less than the number of extension properties available, at most <code>pPropertyCount</code> structures will be written. If <code>pPropertyCount</code> is smaller than the number of extensions available, <code>VK_INCOMPLETE</code> will be returned instead of <code>VK_SUCCESS</code>, to indicate that not all the available properties were returned.</p>   <p>Because the list of available layers may change externally between calls to <code>vkEnumerateInstanceExtensionProperties</code>, two calls may retrieve different results if a <code>pLayerName</code> is available in one call but not in another. The extensions supported by a layer may also change between two calls, e.g. if the layer implementation is replaced by a different version between those calls.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkEnumerateInstanceExtensionProperties-pLayerName-parameter">  If <code>pLayerName</code> is not <code>NULL</code>, <code>pLayerName</code> <strong>must</strong> be a null-terminated UTF-8 string </li> <li id="VUID-vkEnumerateInstanceExtensionProperties-pPropertyCount-parameter">  <code>pPropertyCount</code> <strong>must</strong> be a pointer to a <code>uint32_t</code> value </li> <li id="VUID-vkEnumerateInstanceExtensionProperties-pProperties-parameter">  If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong>must</strong> be a pointer to an array of <code>pPropertyCount</code> <code>VkExtensionProperties</code> structures </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> <li> <code>VK_INCOMPLETE</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_LAYER_NOT_PRESENT</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_96">See Also</h4>  <p><a href="#VkExtensionProperties">VkExtensionProperties</a></p>    <h4 id="_document_notes_96">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEnumerateInstanceExtensionProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEnumerateInstanceExtensionProperties</a></p>         <h3 id="_vkenumerateinstancelayerproperties_3">vkEnumerateInstanceLayerProperties(3)</h3>  <h4 id="_name_97">Name</h4>  <p>vkEnumerateInstanceLayerProperties - Returns up to requested number of global layer properties</p>    <h4 id="_c_specification_97">C Specification</h4>  <p>To query the available layers, call:</p>  <pre id="vkEnumerateInstanceLayerProperties" data-language="c++">VkResult vkEnumerateInstanceLayerProperties(
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties);</pre>   <h4 id="_parameters_97">Parameters</h4>  <ul> <li> <code>pPropertyCount</code> is a pointer to an integer related to the number of layer properties available or queried, as described below. </li> <li> <code>pProperties</code> is either <code>NULL</code> or a pointer to an array of <a href="#VkLayerProperties">VkLayerProperties</a> structures. </li> </ul>    <h4 id="_description_97">Description</h4>  <p>If <code>pProperties</code> is <code>NULL</code>, then the number of layer properties available is returned in <code>pPropertyCount</code>. Otherwise, <code>pPropertyCount</code> <strong>must</strong> point to a variable set by the user to the number of elements in the <code>pProperties</code> array, and on return the variable is overwritten with the number of structures actually written to <code>pProperties</code>. If <code>pPropertyCount</code> is less than the number of layer properties available, at most <code>pPropertyCount</code> structures will be written. If <code>pPropertyCount</code> is smaller than the number of layers available, <code>VK_INCOMPLETE</code> will be returned instead of <code>VK_SUCCESS</code>, to indicate that not all the available layer properties were returned.</p>   <p>The list of available layers may change at any time due to actions outside of the Vulkan implementation, so two calls to <code>vkEnumerateInstanceLayerProperties</code> with the same parameters <strong>may</strong> return different results, or retrieve different <code>pPropertyCount</code> values or <code>pProperties</code> contents. Once an instance has been created, the layers enabled for that instance will continue to be enabled and valid for the lifetime of that instance, even if some of them become unavailable for future instances.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkEnumerateInstanceLayerProperties-pPropertyCount-parameter">  <code>pPropertyCount</code> <strong>must</strong> be a pointer to a <code>uint32_t</code> value </li> <li id="VUID-vkEnumerateInstanceLayerProperties-pProperties-parameter">  If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong>must</strong> be a pointer to an array of <code>pPropertyCount</code> <code>VkLayerProperties</code> structures </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> <li> <code>VK_INCOMPLETE</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_97">See Also</h4>  <p><a href="#VkLayerProperties">VkLayerProperties</a></p>    <h4 id="_document_notes_97">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEnumerateInstanceLayerProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEnumerateInstanceLayerProperties</a></p>         <h3 id="_vkenumeratephysicaldevices_3">vkEnumeratePhysicalDevices(3)</h3>  <h4 id="_name_98">Name</h4>  <p>vkEnumeratePhysicalDevices - Enumerates the physical devices accessible to a Vulkan instance</p>    <h4 id="_c_specification_98">C Specification</h4>  <p>To retrieve a list of physical device objects representing the physical devices installed in the system, call:</p>  <pre id="vkEnumeratePhysicalDevices" data-language="c++">VkResult vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices);</pre>   <h4 id="_parameters_98">Parameters</h4>  <ul> <li> <code>instance</code> is a handle to a Vulkan instance previously created with <a href="#vkCreateInstance">vkCreateInstance</a>. </li> <li> <code>pPhysicalDeviceCount</code> is a pointer to an integer related to the number of physical devices available or queried, as described below. </li> <li> <code>pPhysicalDevices</code> is either <code>NULL</code> or a pointer to an array of <code>VkPhysicalDevice</code> handles. </li> </ul>    <h4 id="_description_98">Description</h4>  <p>If <code>pPhysicalDevices</code> is <code>NULL</code>, then the number of physical devices available is returned in <code>pPhysicalDeviceCount</code>. Otherwise, <code>pPhysicalDeviceCount</code> <strong>must</strong> point to a variable set by the user to the number of elements in the <code>pPhysicalDevices</code> array, and on return the variable is overwritten with the number of handles actually written to <code>pPhysicalDevices</code>. If <code>pPhysicalDeviceCount</code> is less than the number of physical devices available, at most <code>pPhysicalDeviceCount</code> structures will be written. If <code>pPhysicalDeviceCount</code> is smaller than the number of physical devices available, <code>VK_INCOMPLETE</code> will be returned instead of <code>VK_SUCCESS</code>, to indicate that not all the available physical devices were returned.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkEnumeratePhysicalDevices-instance-parameter">  <code>instance</code> <strong>must</strong> be a valid <code>VkInstance</code> handle </li> <li id="VUID-vkEnumeratePhysicalDevices-pPhysicalDeviceCount-parameter">  <code>pPhysicalDeviceCount</code> <strong>must</strong> be a pointer to a <code>uint32_t</code> value </li> <li id="VUID-vkEnumeratePhysicalDevices-pPhysicalDevices-parameter">  If the value referenced by <code>pPhysicalDeviceCount</code> is not <code>0</code>, and <code>pPhysicalDevices</code> is not <code>NULL</code>, <code>pPhysicalDevices</code> <strong>must</strong> be a pointer to an array of <code>pPhysicalDeviceCount</code> <code>VkPhysicalDevice</code> handles </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> <li> <code>VK_INCOMPLETE</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_INITIALIZATION_FAILED</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_98">See Also</h4>  <p><a href="#VkInstance">VkInstance</a>, <a href="#VkPhysicalDevice">VkPhysicalDevice</a></p>    <h4 id="_document_notes_98">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEnumeratePhysicalDevices">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkEnumeratePhysicalDevices</a></p>         <h3 id="_vkflushmappedmemoryranges_3">vkFlushMappedMemoryRanges(3)</h3>  <h4 id="_name_99">Name</h4>  <p>vkFlushMappedMemoryRanges - Flush mapped memory ranges</p>    <h4 id="_c_specification_99">C Specification</h4>  <p>To flush ranges of non-coherent memory from the host caches, call:</p>  <pre id="vkFlushMappedMemoryRanges" data-language="c++">VkResult vkFlushMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges);</pre>   <h4 id="_parameters_99">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the memory ranges. </li> <li> <code>memoryRangeCount</code> is the length of the <code>pMemoryRanges</code> array. </li> <li> <code>pMemoryRanges</code> is a pointer to an array of <a href="#VkMappedMemoryRange">VkMappedMemoryRange</a> structures describing the memory ranges to flush. </li> </ul>    <h4 id="_description_99">Description</h4>  <p><code>vkFlushMappedMemoryRanges</code> guarantees that host writes to the memory ranges described by <code>pMemoryRanges</code> <strong>can</strong> be made available to device access, via <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-available-and-visible">availability operations</a> from the <code>VK_ACCESS_HOST_WRITE_BIT</code> <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types">access type</a>.</p>   <p>Unmapping non-coherent memory does not implicitly flush the mapped memory, and host writes that have not been flushed <strong>may</strong> not ever be visible to the device. However, implementations <strong>must</strong> ensure that writes that have not been flushed do not become visible to any other memory.</p>  <blockquote> <h5 class="title">Note</h5>  <p>The above guarantee avoids a potential memory corruption in scenarios where host writes to a mapped memory object have not been flushed before the memory is unmapped (or freed), and the virtual address range is subsequently reused for a different mapping (or memory allocation).</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkFlushMappedMemoryRanges-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkFlushMappedMemoryRanges-pMemoryRanges-parameter">  <code>pMemoryRanges</code> <strong>must</strong> be a pointer to an array of <code>memoryRangeCount</code> valid <code>VkMappedMemoryRange</code> structures </li> <li id="VUID-vkFlushMappedMemoryRanges-memoryRangeCount-arraylength">  <code>memoryRangeCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_99">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkMappedMemoryRange">VkMappedMemoryRange</a></p>    <h4 id="_document_notes_99">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkFlushMappedMemoryRanges">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkFlushMappedMemoryRanges</a></p>         <h3 id="_vkfreecommandbuffers_3">vkFreeCommandBuffers(3)</h3>  <h4 id="_name_100">Name</h4>  <p>vkFreeCommandBuffers - Free command buffers</p>    <h4 id="_c_specification_100">C Specification</h4>  <p>To free command buffers, call:</p>  <pre id="vkFreeCommandBuffers" data-language="c++">void vkFreeCommandBuffers(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers);</pre>   <h4 id="_parameters_100">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the command pool. </li> <li> <code>commandPool</code> is the command pool from which the command buffers were allocated. </li> <li> <code>commandBufferCount</code> is the length of the <code>pCommandBuffers</code> array. </li> <li> <code>pCommandBuffers</code> is an array of handles of command buffers to free. </li> </ul>    <h4 id="_description_100">Description</h4>  <p>Any primary command buffer that is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or executable state</a> and has any element of <code>pCommandBuffers</code> recorded into it, becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkFreeCommandBuffers-pCommandBuffers-00047">  All elements of <code>pCommandBuffers</code> <strong>must</strong> not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a> </li> <li id="VUID-vkFreeCommandBuffers-pCommandBuffers-00048">  <code>pCommandBuffers</code> <strong>must</strong> be a pointer to an array of <code>commandBufferCount</code> <code>VkCommandBuffer</code> handles, each element of which <strong>must</strong> either be a valid handle or <code>NULL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkFreeCommandBuffers-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkFreeCommandBuffers-commandPool-parameter">  <code>commandPool</code> <strong>must</strong> be a valid <code>VkCommandPool</code> handle </li> <li id="VUID-vkFreeCommandBuffers-commandBufferCount-arraylength">  <code>commandBufferCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkFreeCommandBuffers-commandPool-parent">  <code>commandPool</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> <li id="VUID-vkFreeCommandBuffers-pCommandBuffers-parent">  Each element of <code>pCommandBuffers</code> that is a valid handle <strong>must</strong> have been created, allocated, or retrieved from <code>commandPool</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandPool</code> <strong>must</strong> be externally synchronized </li> <li> Host access to each member of <code>pCommandBuffers</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_100">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkCommandPool">VkCommandPool</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_100">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkFreeCommandBuffers">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkFreeCommandBuffers</a></p>         <h3 id="_vkfreedescriptorsets_3">vkFreeDescriptorSets(3)</h3>  <h4 id="_name_101">Name</h4>  <p>vkFreeDescriptorSets - Free one or more descriptor sets</p>    <h4 id="_c_specification_101">C Specification</h4>  <p>To free allocated descriptor sets, call:</p>  <pre id="vkFreeDescriptorSets" data-language="c++">VkResult vkFreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets);</pre>   <h4 id="_parameters_101">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the descriptor pool. </li> <li> <code>descriptorPool</code> is the descriptor pool from which the descriptor sets were allocated. </li> <li> <code>descriptorSetCount</code> is the number of elements in the <code>pDescriptorSets</code> array. </li> <li> <code>pDescriptorSets</code> is an array of handles to <code>VkDescriptorSet</code> objects. </li> </ul>    <h4 id="_description_101">Description</h4>  <p>After a successful call to <code>vkFreeDescriptorSets</code>, all descriptor sets in <code>pDescriptorSets</code> are invalid.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkFreeDescriptorSets-pDescriptorSets-00309">  All submitted commands that refer to any element of <code>pDescriptorSets</code> <strong>must</strong> have completed execution </li> <li id="VUID-vkFreeDescriptorSets-pDescriptorSets-00310">  <code>pDescriptorSets</code> <strong>must</strong> be a pointer to an array of <code>descriptorSetCount</code> <code>VkDescriptorSet</code> handles, each element of which <strong>must</strong> either be a valid handle or <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a> </li> <li id="VUID-vkFreeDescriptorSets-pDescriptorSets-00311">  Each valid handle in <code>pDescriptorSets</code> <strong>must</strong> have been allocated from <code>descriptorPool</code> </li> <li id="VUID-vkFreeDescriptorSets-descriptorPool-00312">  <code>descriptorPool</code> <strong>must</strong> have been created with the <code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code> flag </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkFreeDescriptorSets-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkFreeDescriptorSets-descriptorPool-parameter">  <code>descriptorPool</code> <strong>must</strong> be a valid <code>VkDescriptorPool</code> handle </li> <li id="VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength">  <code>descriptorSetCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkFreeDescriptorSets-descriptorPool-parent">  <code>descriptorPool</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> <li id="VUID-vkFreeDescriptorSets-pDescriptorSets-parent">  Each element of <code>pDescriptorSets</code> that is a valid handle <strong>must</strong> have been created, allocated, or retrieved from <code>descriptorPool</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>descriptorPool</code> <strong>must</strong> be externally synchronized </li> <li> Host access to each member of <code>pDescriptorSets</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_101">See Also</h4>  <p><a href="#VkDescriptorPool">VkDescriptorPool</a>, <a href="#VkDescriptorSet">VkDescriptorSet</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_101">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkFreeDescriptorSets">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkFreeDescriptorSets</a></p>         <h3 id="_vkfreememory_3">vkFreeMemory(3)</h3>  <h4 id="_name_102">Name</h4>  <p>vkFreeMemory - Free GPU memory</p>    <h4 id="_c_specification_102">C Specification</h4>  <p>To free a memory object, call:</p>  <pre id="vkFreeMemory" data-language="c++">void vkFreeMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    const VkAllocationCallbacks*                pAllocator);</pre>   <h4 id="_parameters_102">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the memory. </li> <li> <code>memory</code> is the <code>VkDeviceMemory</code> object to be freed. </li> <li> <code>pAllocator</code> controls host memory allocation as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-allocation">Memory Allocation</a> chapter. </li> </ul>    <h4 id="_description_102">Description</h4>  <p>Before freeing a memory object, an application <strong>must</strong> ensure the memory object is no longer in use by the device—​for example by command buffers queued for execution. The memory <strong>can</strong> remain bound to images or buffers at the time the memory object is freed, but any further use of them (on host or device) for anything other than destroying those objects will result in undefined behavior. If there are still any bound images or buffers, the memory <strong>may</strong> not be immediately released by the implementation, but <strong>must</strong> be released by the time all bound images and buffers have been destroyed. Once memory is released, it is returned to the heap from which it was allocated.</p>   <p>How memory objects are bound to Images and Buffers is described in detail in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-association">Resource Memory Association</a> section.</p>   <p>If a memory object is mapped at the time it is freed, it is implicitly unmapped.</p>  <blockquote> <h5 class="title">Note</h5>  <p>As described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-device-unmap-does-not-flush">below</a>, host writes are not implicitly flushed when the memory object is unmapped, but the implementation <strong>must</strong> guarantee that writes that have not been flushed do not affect any other memory.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkFreeMemory-memory-00677">  All submitted commands that refer to <code>memory</code> (via images or buffers) <strong>must</strong> have completed execution </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkFreeMemory-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkFreeMemory-memory-parameter">  If <code>memory</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>memory</code> <strong>must</strong> be a valid <code>VkDeviceMemory</code> handle </li> <li id="VUID-vkFreeMemory-pAllocator-parameter">  If <code>pAllocator</code> is not <code>NULL</code>, <code>pAllocator</code> <strong>must</strong> be a pointer to a valid <code>VkAllocationCallbacks</code> structure </li> <li id="VUID-vkFreeMemory-memory-parent">  If <code>memory</code> is a valid handle, it <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>memory</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_102">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkDeviceMemory">VkDeviceMemory</a></p>    <h4 id="_document_notes_102">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkFreeMemory">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkFreeMemory</a></p>         <h3 id="_vkgetbuffermemoryrequirements_3">vkGetBufferMemoryRequirements(3)</h3>  <h4 id="_name_103">Name</h4>  <p>vkGetBufferMemoryRequirements - Returns the memory requirements for specified Vulkan object</p>    <h4 id="_c_specification_103">C Specification</h4>  <p>To determine the memory requirements for a buffer resource, call:</p>  <pre id="vkGetBufferMemoryRequirements" data-language="c++">void vkGetBufferMemoryRequirements(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkMemoryRequirements*                       pMemoryRequirements);</pre>   <h4 id="_parameters_103">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the buffer. </li> <li> <code>buffer</code> is the buffer to query. </li> <li> <code>pMemoryRequirements</code> points to an instance of the <a href="#VkMemoryRequirements">VkMemoryRequirements</a> structure in which the memory requirements of the buffer object are returned. </li> </ul>    <h4 id="_description_103">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetBufferMemoryRequirements-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetBufferMemoryRequirements-buffer-parameter">  <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-vkGetBufferMemoryRequirements-pMemoryRequirements-parameter">  <code>pMemoryRequirements</code> <strong>must</strong> be a pointer to a <code>VkMemoryRequirements</code> structure </li> <li id="VUID-vkGetBufferMemoryRequirements-buffer-parent">  <code>buffer</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote>   <h4 id="_see_also_103">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkMemoryRequirements">VkMemoryRequirements</a></p>    <h4 id="_document_notes_103">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetBufferMemoryRequirements">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetBufferMemoryRequirements</a></p>         <h3 id="_vkgetdevicememorycommitment_3">vkGetDeviceMemoryCommitment(3)</h3>  <h4 id="_name_104">Name</h4>  <p>vkGetDeviceMemoryCommitment - Query the current commitment for a VkDeviceMemory</p>    <h4 id="_c_specification_104">C Specification</h4>  <p>To determine the amount of lazily-allocated memory that is currently committed for a memory object, call:</p>  <pre id="vkGetDeviceMemoryCommitment" data-language="c++">void vkGetDeviceMemoryCommitment(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize*                               pCommittedMemoryInBytes);</pre>   <h4 id="_parameters_104">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the memory. </li> <li> <code>memory</code> is the memory object being queried. </li> <li> <code>pCommittedMemoryInBytes</code> is a pointer to a <code>VkDeviceSize</code> value in which the number of bytes currently committed is returned, on success. </li> </ul>    <h4 id="_description_104">Description</h4>  <p>The implementation <strong>may</strong> update the commitment at any time, and the value returned by this query <strong>may</strong> be out of date.</p>   <p>The implementation guarantees to allocate any committed memory from the heapIndex indicated by the memory type that the memory object was created with.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkGetDeviceMemoryCommitment-memory-00690">  <code>memory</code> <strong>must</strong> have been created with a memory type that reports <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetDeviceMemoryCommitment-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetDeviceMemoryCommitment-memory-parameter">  <code>memory</code> <strong>must</strong> be a valid <code>VkDeviceMemory</code> handle </li> <li id="VUID-vkGetDeviceMemoryCommitment-pCommittedMemoryInBytes-parameter">  <code>pCommittedMemoryInBytes</code> <strong>must</strong> be a pointer to a <code>VkDeviceSize</code> value </li> <li id="VUID-vkGetDeviceMemoryCommitment-memory-parent">  <code>memory</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote>   <h4 id="_see_also_104">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkDeviceMemory">VkDeviceMemory</a>, <code>VkDeviceSize</code></p>    <h4 id="_document_notes_104">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetDeviceMemoryCommitment">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetDeviceMemoryCommitment</a></p>         <h3 id="_vkgetdeviceprocaddr_3">vkGetDeviceProcAddr(3)</h3>  <h4 id="_name_105">Name</h4>  <p>vkGetDeviceProcAddr - Return a function pointer for a command</p>    <h4 id="_c_specification_105">C Specification</h4>  <p>In order to support systems with multiple Vulkan implementations comprising heterogeneous collections of hardware and software, the function pointers returned by <code>vkGetInstanceProcAddr</code> <strong>may</strong> point to dispatch code, which calls a different real implementation for different <code>VkDevice</code> objects (and objects created from them). The overhead of this internal dispatch <strong>can</strong> be avoided by obtaining device-specific function pointers for any commands that use a device or device-child object as their dispatchable object. Such function pointers <strong>can</strong> be obtained with the command:</p>  <pre id="vkGetDeviceProcAddr" data-language="c++">PFN_vkVoidFunction vkGetDeviceProcAddr(
    VkDevice                                    device,
    const char*                                 pName);</pre>   <h4 id="_parameters_105">Parameters</h4>  <p>The table below defines the various use cases for <code>vkGetDeviceProcAddr</code> and expected return value for each case.</p>    <h4 id="_description_105">Description</h4>  <p>The returned function pointer is of type <a href="#PFN_vkVoidFunction">PFN_vkVoidFunction</a>, and must be cast to the type of the command being queried.</p>  <div class="_table"><table class="tableblock frame-all grid-all" style="width: 80%;"> <caption class="title">Table 1. vkGetDeviceProcAddr behavior</caption> <colgroup> <col style="width: 33.3333%;"> <col style="width: 33.3333%;"> <col style="width: 33.3334%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><code>device</code></th> <th class="tableblock halign-left valign-top"><code>pName</code></th> <th class="tableblock halign-left valign-top">return value</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">undefined</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">invalid device</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">undefined</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">device</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">undefined</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">device</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">core Vulkan command</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">fp<sup>1</sup></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">device</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">enabled extension commands</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">fp<sup>1</sup></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">device</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">* (any <code>pName</code> not covered above)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td> </tr> </tbody> </table></div> <div class="dlist"> <dl> <dt>1</dt> <dd> The returned function pointer <strong>must</strong> only be called with a dispatchable object (the first parameter) that is <code>device</code> or a child of <code>device</code>. e.g. <code>VkDevice</code>, <code>VkQueue</code>, or <code>VkCommandBuffer</code>. </dd> </dl> </div> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetDeviceProcAddr-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetDeviceProcAddr-pName-parameter">  <code>pName</code> <strong>must</strong> be a null-terminated UTF-8 string </li> </ul>   </blockquote>   <h4 id="_see_also_105">See Also</h4>  <p><a href="#PFN_vkVoidFunction">PFN_vkVoidFunction</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_105">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetDeviceProcAddr">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetDeviceProcAddr</a></p>         <h3 id="_vkgetdevicequeue_3">vkGetDeviceQueue(3)</h3>  <h4 id="_name_106">Name</h4>  <p>vkGetDeviceQueue - Get a queue handle from a device</p>    <h4 id="_c_specification_106">C Specification</h4>  <p>To retrieve a handle to a VkQueue object, call:</p>  <pre id="vkGetDeviceQueue" data-language="c++">void vkGetDeviceQueue(
    VkDevice                                    device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    VkQueue*                                    pQueue);</pre>   <h4 id="_parameters_106">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the queue. </li> <li> <code>queueFamilyIndex</code> is the index of the queue family to which the queue belongs. </li> <li> <code>queueIndex</code> is the index within this queue family of the queue to retrieve. </li> <li> <code>pQueue</code> is a pointer to a <code>VkQueue</code> object that will be filled with the handle for the requested queue. </li> </ul>    <h4 id="_description_106">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkGetDeviceQueue-queueFamilyIndex-00384">  <code>queueFamilyIndex</code> <strong>must</strong> be one of the queue family indices specified when <code>device</code> was created, via the <code>VkDeviceQueueCreateInfo</code> structure </li> <li id="VUID-vkGetDeviceQueue-queueIndex-00385">  <code>queueIndex</code> <strong>must</strong> be less than the number of queues created for the specified queue family index when <code>device</code> was created, via the <code>queueCount</code> member of the <code>VkDeviceQueueCreateInfo</code> structure </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetDeviceQueue-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetDeviceQueue-pQueue-parameter">  <code>pQueue</code> <strong>must</strong> be a pointer to a <code>VkQueue</code> handle </li> </ul>   </blockquote>   <h4 id="_see_also_106">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkQueue">VkQueue</a></p>    <h4 id="_document_notes_106">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetDeviceQueue">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetDeviceQueue</a></p>         <h3 id="_vkgeteventstatus_3">vkGetEventStatus(3)</h3>  <h4 id="_name_107">Name</h4>  <p>vkGetEventStatus - Retrieve the status of an event object</p>    <h4 id="_c_specification_107">C Specification</h4>  <p>To query the state of an event from the host, call:</p>  <pre id="vkGetEventStatus" data-language="c++">VkResult vkGetEventStatus(
    VkDevice                                    device,
    VkEvent                                     event);</pre>   <h4 id="_parameters_107">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the event. </li> <li> <code>event</code> is the handle of the event to query. </li> </ul>    <h4 id="_description_107">Description</h4>  <p>Upon success, <code>vkGetEventStatus</code> returns the state of the event object with the following return codes:</p>  <div class="_table"><table class="tableblock frame-all grid-all" style="width: 80%;"> <caption class="title">Table 2. Event Object Status Codes</caption> <colgroup> <col style="width: 50%;"> <col style="width: 50%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Status</th> <th class="tableblock halign-left valign-top">Meaning</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_EVENT_SET</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">The event specified by <code>event</code> is signaled.</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_EVENT_RESET</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">The event specified by <code>event</code> is unsignaled.</p></td> </tr> </tbody> </table></div>  <p>If a <code>vkCmdSetEvent</code> or <code>vkCmdResetEvent</code> command is in a command buffer that is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>, then the value returned by this command <strong>may</strong> immediately be out of date.</p>   <p>The state of an event <strong>can</strong> be updated by the host. The state of the event is immediately changed, and subsequent calls to <code>vkGetEventStatus</code> will return the new state. If an event is already in the requested state, then updating it to the same state has no effect.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetEventStatus-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetEventStatus-event-parameter">  <code>event</code> <strong>must</strong> be a valid <code>VkEvent</code> handle </li> <li id="VUID-vkGetEventStatus-event-parent">  <code>event</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_EVENT_SET</code> </li> <li> <code>VK_EVENT_RESET</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_DEVICE_LOST</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_107">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkEvent">VkEvent</a></p>    <h4 id="_document_notes_107">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetEventStatus">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetEventStatus</a></p>         <h3 id="_vkgetfencestatus_3">vkGetFenceStatus(3)</h3>  <h4 id="_name_108">Name</h4>  <p>vkGetFenceStatus - Return the status of a fence</p>    <h4 id="_c_specification_108">C Specification</h4>  <p>To query the status of a fence from the host, call:</p>  <pre id="vkGetFenceStatus" data-language="c++">VkResult vkGetFenceStatus(
    VkDevice                                    device,
    VkFence                                     fence);</pre>   <h4 id="_parameters_108">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the fence. </li> <li> <code>fence</code> is the handle of the fence to query. </li> </ul>    <h4 id="_description_108">Description</h4>  <p>Upon success, <code>vkGetFenceStatus</code> returns the status of the fence object, with the following return codes:</p>  <div class="_table"><table class="tableblock frame-all grid-all" style="width: 80%;"> <caption class="title">Table 3. Fence Object Status Codes</caption> <colgroup> <col style="width: 50%;"> <col style="width: 50%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Status</th> <th class="tableblock halign-left valign-top">Meaning</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_SUCCESS</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">The fence specified by <code>fence</code> is signaled.</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_NOT_READY</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">The fence specified by <code>fence</code> is unsignaled.</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_DEVICE_LOST</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">The device has been lost. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device">Lost Device</a>.</p></td> </tr> </tbody> </table></div>  <p>If a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission">queue submission</a> command is pending execution, then the value returned by this command <strong>may</strong> immediately be out of date.</p>   <p>If the device has been lost (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device">Lost Device</a>), <code>vkGetFenceStatus</code> <strong>may</strong> return any of the above status codes. If the device has been lost and <code>vkGetFenceStatus</code> is called repeatedly, it will eventually return either <code>VK_SUCCESS</code> or <code>VK_DEVICE_LOST</code>.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetFenceStatus-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetFenceStatus-fence-parameter">  <code>fence</code> <strong>must</strong> be a valid <code>VkFence</code> handle </li> <li id="VUID-vkGetFenceStatus-fence-parent">  <code>fence</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> <li> <code>VK_NOT_READY</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_DEVICE_LOST</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_108">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkFence">VkFence</a></p>    <h4 id="_document_notes_108">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetFenceStatus">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetFenceStatus</a></p>         <h3 id="_vkgetimagememoryrequirements_3">vkGetImageMemoryRequirements(3)</h3>  <h4 id="_name_109">Name</h4>  <p>vkGetImageMemoryRequirements - Returns the memory requirements for specified Vulkan object</p>    <h4 id="_c_specification_109">C Specification</h4>  <p>To determine the memory requirements for an image resource, call:</p>  <pre id="vkGetImageMemoryRequirements" data-language="c++">void vkGetImageMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    VkMemoryRequirements*                       pMemoryRequirements);</pre>   <h4 id="_parameters_109">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the image. </li> <li> <code>image</code> is the image to query. </li> <li> <code>pMemoryRequirements</code> points to an instance of the <a href="#VkMemoryRequirements">VkMemoryRequirements</a> structure in which the memory requirements of the image object are returned. </li> </ul>    <h4 id="_description_109">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetImageMemoryRequirements-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetImageMemoryRequirements-image-parameter">  <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkGetImageMemoryRequirements-pMemoryRequirements-parameter">  <code>pMemoryRequirements</code> <strong>must</strong> be a pointer to a <code>VkMemoryRequirements</code> structure </li> <li id="VUID-vkGetImageMemoryRequirements-image-parent">  <code>image</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote>   <h4 id="_see_also_109">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkImage">VkImage</a>, <a href="#VkMemoryRequirements">VkMemoryRequirements</a></p>    <h4 id="_document_notes_109">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetImageMemoryRequirements">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetImageMemoryRequirements</a></p>         <h3 id="_vkgetimagesparsememoryrequirements_3">vkGetImageSparseMemoryRequirements(3)</h3>  <h4 id="_name_110">Name</h4>  <p>vkGetImageSparseMemoryRequirements - Query the memory requirements for a sparse image</p>    <h4 id="_c_specification_110">C Specification</h4>  <p>To query sparse memory requirements for an image, call:</p>  <pre id="vkGetImageSparseMemoryRequirements" data-language="c++">void vkGetImageSparseMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements*            pSparseMemoryRequirements);</pre>   <h4 id="_parameters_110">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the image. </li> <li> <code>image</code> is the <code>VkImage</code> object to get the memory requirements for. </li> <li> <code>pSparseMemoryRequirementCount</code> is a pointer to an integer related to the number of sparse memory requirements available or queried, as described below. </li> <li> <code>pSparseMemoryRequirements</code> is either <code>NULL</code> or a pointer to an array of <code>VkSparseImageMemoryRequirements</code> structures. </li> </ul>    <h4 id="_description_110">Description</h4>  <p>If <code>pSparseMemoryRequirements</code> is <code>NULL</code>, then the number of sparse memory requirements available is returned in <code>pSparseMemoryRequirementCount</code>. Otherwise, <code>pSparseMemoryRequirementCount</code> <strong>must</strong> point to a variable set by the user to the number of elements in the <code>pSparseMemoryRequirements</code> array, and on return the variable is overwritten with the number of structures actually written to <code>pSparseMemoryRequirements</code>. If <code>pSparseMemoryRequirementCount</code> is less than the number of sparse memory requirements available, at most <code>pSparseMemoryRequirementCount</code> structures will be written.</p>   <p>If the image was not created with <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> then <code>pSparseMemoryRequirementCount</code> will be set to zero and <code>pSparseMemoryRequirements</code> will not be written to.</p>  <blockquote> <h5 class="title">Note</h5>  <p>It is legal for an implementation to report a larger value in <code>VkMemoryRequirements</code>::<code>size</code> than would be obtained by adding together memory sizes for all <code>VkSparseImageMemoryRequirements</code> returned by <code>vkGetImageSparseMemoryRequirements</code>. This <strong>may</strong> occur when the hardware requires unused padding in the address range describing the resource.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetImageSparseMemoryRequirements-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetImageSparseMemoryRequirements-image-parameter">  <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirementCount-parameter">  <code>pSparseMemoryRequirementCount</code> <strong>must</strong> be a pointer to a <code>uint32_t</code> value </li> <li id="VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter">  If the value referenced by <code>pSparseMemoryRequirementCount</code> is not <code>0</code>, and <code>pSparseMemoryRequirements</code> is not <code>NULL</code>, <code>pSparseMemoryRequirements</code> <strong>must</strong> be a pointer to an array of <code>pSparseMemoryRequirementCount</code> <code>VkSparseImageMemoryRequirements</code> structures </li> <li id="VUID-vkGetImageSparseMemoryRequirements-image-parent">  <code>image</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote>   <h4 id="_see_also_110">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkImage">VkImage</a>, <a href="#VkSparseImageMemoryRequirements">VkSparseImageMemoryRequirements</a></p>    <h4 id="_document_notes_110">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetImageSparseMemoryRequirements">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetImageSparseMemoryRequirements</a></p>         <h3 id="_vkgetimagesubresourcelayout_3">vkGetImageSubresourceLayout(3)</h3>  <h4 id="_name_111">Name</h4>  <p>vkGetImageSubresourceLayout - Retrieve information about an image subresource</p>    <h4 id="_c_specification_111">C Specification</h4>  <p>To query the host access layout of an image subresource, for an image created with linear tiling, call:</p>  <pre id="vkGetImageSubresourceLayout" data-language="c++">void vkGetImageSubresourceLayout(
    VkDevice                                    device,
    VkImage                                     image,
    const VkImageSubresource*                   pSubresource,
    VkSubresourceLayout*                        pLayout);</pre>   <h4 id="_parameters_111">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the image. </li> <li> <code>image</code> is the image whose layout is being queried. </li> <li> <code>pSubresource</code> is a pointer to a <a href="#VkImageSubresource">VkImageSubresource</a> structure selecting a specific image for the image subresource. </li> <li> <code>pLayout</code> points to a <a href="#VkSubresourceLayout">VkSubresourceLayout</a> structure in which the layout is returned. </li> </ul>    <h4 id="_description_111">Description</h4>  <p><a href="#vkGetImageSubresourceLayout">vkGetImageSubresourceLayout</a> is invariant for the lifetime of a single image.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkGetImageSubresourceLayout-image-00996">  <code>image</code> <strong>must</strong> have been created with <code>tiling</code> equal to <code>VK_IMAGE_TILING_LINEAR</code> </li> <li id="VUID-vkGetImageSubresourceLayout-aspectMask-00997">  The <code>aspectMask</code> member of <code>pSubresource</code> <strong>must</strong> only have a single bit set </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetImageSubresourceLayout-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetImageSubresourceLayout-image-parameter">  <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-vkGetImageSubresourceLayout-pSubresource-parameter">  <code>pSubresource</code> <strong>must</strong> be a pointer to a valid <code>VkImageSubresource</code> structure </li> <li id="VUID-vkGetImageSubresourceLayout-pLayout-parameter">  <code>pLayout</code> <strong>must</strong> be a pointer to a <code>VkSubresourceLayout</code> structure </li> <li id="VUID-vkGetImageSubresourceLayout-image-parent">  <code>image</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote>   <h4 id="_see_also_111">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageSubresource">VkImageSubresource</a>, <a href="#VkSubresourceLayout">VkSubresourceLayout</a></p>    <h4 id="_document_notes_111">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetImageSubresourceLayout">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetImageSubresourceLayout</a></p>         <h3 id="_vkgetinstanceprocaddr_3">vkGetInstanceProcAddr(3)</h3>  <h4 id="_name_112">Name</h4>  <p>vkGetInstanceProcAddr - Return a function pointer for a command</p>    <h4 id="_c_specification_112">C Specification</h4>  <p>Vulkan commands are not necessarily exposed statically on a platform. Function pointers for all Vulkan commands <strong>can</strong> be obtained with the command:</p>  <pre id="vkGetInstanceProcAddr" data-language="c++">PFN_vkVoidFunction vkGetInstanceProcAddr(
    VkInstance                                  instance,
    const char*                                 pName);</pre>   <h4 id="_parameters_112">Parameters</h4>  <ul> <li> <code>instance</code> is the instance that the function pointer will be compatible with, or <code>NULL</code> for commands not dependent on any instance. </li> <li> <code>pName</code> is the name of the command to obtain. </li> </ul>    <h4 id="_description_112">Description</h4>  <p><code>vkGetInstanceProcAddr</code> itself is obtained in a platform- and loader- specific manner. Typically, the loader library will export this command as a function symbol, so applications <strong>can</strong> link against the loader library, or load it dynamically and look up the symbol using platform-specific APIs. Loaders are encouraged to export function symbols for all other core Vulkan commands as well; if this is done, then applications that use only the core Vulkan commands have no need to use <code>vkGetInstanceProcAddr</code>.</p>   <p>The table below defines the various use cases for <code>vkGetInstanceProcAddr</code> and expected return value ("fp" is function pointer) for each case.</p>   <p>The returned function pointer is of type <a href="#PFN_vkVoidFunction">PFN_vkVoidFunction</a>, and must be cast to the type of the command being queried.</p>  <div class="_table"><table class="tableblock frame-all grid-all" style="width: 80%;"> <caption class="title">Table 4. vkGetInstanceProcAddr behavior</caption> <colgroup> <col style="width: 33.3333%;"> <col style="width: 33.3333%;"> <col style="width: 33.3334%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><code>instance</code></th> <th class="tableblock halign-left valign-top"><code>pName</code></th> <th class="tableblock halign-left valign-top">return value</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">undefined</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">invalid instance</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">undefined</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#vkEnumerateInstanceExtensionProperties">vkEnumerateInstanceExtensionProperties</a></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">fp</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#vkEnumerateInstanceLayerProperties">vkEnumerateInstanceLayerProperties</a></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">fp</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#vkCreateInstance">vkCreateInstance</a></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">fp</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">* (any <code>pName</code> not covered above)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">instance</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">core Vulkan command</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">fp<sup>1</sup></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">instance</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">enabled instance extension commands for <code>instance</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">fp<sup>1</sup></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">instance</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">available device extension<sup>2</sup> commands for <code>instance</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">fp<sup>1</sup></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">instance</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">* (any <code>pName</code> not covered above)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td> </tr> </tbody> </table></div> <div class="dlist"> <dl> <dt>1</dt> <dd> The returned function pointer <strong>must</strong> only be called with a dispatchable object (the first parameter) that is <code>instance</code> or a child of <code>instance</code>. e.g. <code>VkInstance</code>, <code>VkPhysicalDevice</code>, <code>VkDevice</code>, <code>VkQueue</code>, or <code>VkCommandBuffer</code>. </dd> <dt>2</dt> <dd> An “available extension” is an extension function supported by any of the loader, driver or layer. </dd> </dl> </div> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetInstanceProcAddr-instance-parameter">  If <code>instance</code> is not <code>NULL</code>, <code>instance</code> <strong>must</strong> be a valid <code>VkInstance</code> handle </li> <li id="VUID-vkGetInstanceProcAddr-pName-parameter">  <code>pName</code> <strong>must</strong> be a null-terminated UTF-8 string </li> </ul>   </blockquote>   <h4 id="_see_also_112">See Also</h4>  <p><a href="#PFN_vkVoidFunction">PFN_vkVoidFunction</a>, <a href="#VkInstance">VkInstance</a></p>    <h4 id="_document_notes_112">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetInstanceProcAddr">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetInstanceProcAddr</a></p>         <h3 id="_vkgetphysicaldevicefeatures_3">vkGetPhysicalDeviceFeatures(3)</h3>  <h4 id="_name_113">Name</h4>  <p>vkGetPhysicalDeviceFeatures - Reports capabilities of a physical device</p>    <h4 id="_c_specification_113">C Specification</h4>  <p>To query supported features, call:</p>  <pre id="vkGetPhysicalDeviceFeatures" data-language="c++">void vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures*                   pFeatures);</pre>   <h4 id="_parameters_113">Parameters</h4>  <ul> <li> <code>physicalDevice</code> is the physical device from which to query the supported features. </li> <li> <code>pFeatures</code> is a pointer to a <a href="#VkPhysicalDeviceFeatures">VkPhysicalDeviceFeatures</a> structure in which the physical device features are returned. For each feature, a value of <code>VK_TRUE</code> indicates that the feature is supported on this physical device, and <code>VK_FALSE</code> indicates that the feature is not supported. </li> </ul>    <h4 id="_description_113">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetPhysicalDeviceFeatures-physicalDevice-parameter">  <code>physicalDevice</code> <strong>must</strong> be a valid <code>VkPhysicalDevice</code> handle </li> <li id="VUID-vkGetPhysicalDeviceFeatures-pFeatures-parameter">  <code>pFeatures</code> <strong>must</strong> be a pointer to a <code>VkPhysicalDeviceFeatures</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_113">See Also</h4>  <p><a href="#VkPhysicalDevice">VkPhysicalDevice</a>, <a href="#VkPhysicalDeviceFeatures">VkPhysicalDeviceFeatures</a></p>    <h4 id="_document_notes_113">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceFeatures">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceFeatures</a></p>         <h3 id="_vkgetphysicaldeviceformatproperties_3">vkGetPhysicalDeviceFormatProperties(3)</h3>  <h4 id="_name_114">Name</h4>  <p>vkGetPhysicalDeviceFormatProperties - Lists physical device’s format capabilities</p>    <h4 id="_c_specification_114">C Specification</h4>  <p>To query supported format features which are properties of the physical device, call:</p>  <pre id="vkGetPhysicalDeviceFormatProperties" data-language="c++">void vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties*                         pFormatProperties);</pre>   <h4 id="_parameters_114">Parameters</h4>  <ul> <li> <code>physicalDevice</code> is the physical device from which to query the format properties. </li> <li> <code>format</code> is the format whose properties are queried. </li> <li> <code>pFormatProperties</code> is a pointer to a <a href="#VkFormatProperties">VkFormatProperties</a> structure in which physical device properties for <code>format</code> are returned. </li> </ul>    <h4 id="_description_114">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetPhysicalDeviceFormatProperties-physicalDevice-parameter">  <code>physicalDevice</code> <strong>must</strong> be a valid <code>VkPhysicalDevice</code> handle </li> <li id="VUID-vkGetPhysicalDeviceFormatProperties-format-parameter">  <code>format</code> <strong>must</strong> be a valid <a href="#VkFormat">VkFormat</a> value </li> <li id="VUID-vkGetPhysicalDeviceFormatProperties-pFormatProperties-parameter">  <code>pFormatProperties</code> <strong>must</strong> be a pointer to a <code>VkFormatProperties</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_114">See Also</h4>  <p><a href="#VkFormat">VkFormat</a>, <a href="#VkFormatProperties">VkFormatProperties</a>, <a href="#VkPhysicalDevice">VkPhysicalDevice</a></p>    <h4 id="_document_notes_114">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceFormatProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceFormatProperties</a></p>         <h3 id="_vkgetphysicaldeviceimageformatproperties_3">vkGetPhysicalDeviceImageFormatProperties(3)</h3>  <h4 id="_name_115">Name</h4>  <p>vkGetPhysicalDeviceImageFormatProperties - Lists physical device’s image format capabilities</p>    <h4 id="_c_specification_115">C Specification</h4>  <p>To query additional capabilities specific to image types, call:</p>  <pre id="vkGetPhysicalDeviceImageFormatProperties" data-language="c++">VkResult vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkImageFormatProperties*                    pImageFormatProperties);</pre>   <h4 id="_parameters_115">Parameters</h4>  <ul> <li> <code>physicalDevice</code> is the physical device from which to query the image capabilities. </li> <li> <code>format</code> is a <a href="#VkFormat">VkFormat</a> value specifying the image format, corresponding to <a href="#VkImageCreateInfo">VkImageCreateInfo</a>::<code>format</code>. </li> <li> <code>type</code> is a <a href="#VkImageType">VkImageType</a> value specifying the image type, corresponding to <a href="#VkImageCreateInfo">VkImageCreateInfo</a>::<code>imageType</code>. </li> <li> <code>tiling</code> is a <a href="#VkImageTiling">VkImageTiling</a> value specifying the image tiling, corresponding to <a href="#VkImageCreateInfo">VkImageCreateInfo</a>::<code>tiling</code>. </li> <li> <code>usage</code> is a bitmask of <a href="#VkImageUsageFlagBits">VkImageUsageFlagBits</a> specifying the intended usage of the image, corresponding to <a href="#VkImageCreateInfo">VkImageCreateInfo</a>::<code>usage</code>. </li> <li> <code>flags</code> is a bitmask of <a href="#VkImageCreateFlagBits">VkImageCreateFlagBits</a> specifying additional parameters of the image, corresponding to <a href="#VkImageCreateInfo">VkImageCreateInfo</a>::<code>flags</code>. </li> <li> <code>pImageFormatProperties</code> points to an instance of the <a href="#VkImageFormatProperties">VkImageFormatProperties</a> structure in which capabilities are returned. </li> </ul>    <h4 id="_description_115">Description</h4>  <p>The <code>format</code>, <code>type</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code> parameters correspond to parameters that would be consumed by <a href="#vkCreateImage">vkCreateImage</a> (as members of <code>VkImageCreateInfo</code>).</p>   <p>If <code>format</code> is not a supported image format, or if the combination of <code>format</code>, <code>type</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code> is not supported for images, then <code>vkGetPhysicalDeviceImageFormatProperties</code> returns <code>VK_ERROR_FORMAT_NOT_SUPPORTED</code>.</p>   <p>The limitations on an image format that are reported by <code>vkGetPhysicalDeviceImageFormatProperties</code> have the following property: if <code>usage1</code> and <code>usage2</code> of type <a href="#VkImageUsageFlags">VkImageUsageFlags</a> are such that the bits set in <code>usage1</code> are a subset of the bits set in <code>usage2</code>, and <code>flags1</code> and <code>flags2</code> of type <a href="#VkImageCreateFlags">VkImageCreateFlags</a> are such that the bits set in <code>flags1</code> are a subset of the bits set in <code>flags2</code>, then the limitations for <code>usage1</code> and <code>flags1</code> <strong>must</strong> be no more strict than the limitations for <code>usage2</code> and <code>flags2</code>, for all values of <code>format</code>, <code>type</code>, and <code>tiling</code>.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetPhysicalDeviceImageFormatProperties-physicalDevice-parameter">  <code>physicalDevice</code> <strong>must</strong> be a valid <code>VkPhysicalDevice</code> handle </li> <li id="VUID-vkGetPhysicalDeviceImageFormatProperties-format-parameter">  <code>format</code> <strong>must</strong> be a valid <a href="#VkFormat">VkFormat</a> value </li> <li id="VUID-vkGetPhysicalDeviceImageFormatProperties-type-parameter">  <code>type</code> <strong>must</strong> be a valid <a href="#VkImageType">VkImageType</a> value </li> <li id="VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-parameter">  <code>tiling</code> <strong>must</strong> be a valid <a href="#VkImageTiling">VkImageTiling</a> value </li> <li id="VUID-vkGetPhysicalDeviceImageFormatProperties-usage-parameter">  <code>usage</code> <strong>must</strong> be a valid combination of <a href="#VkImageUsageFlagBits">VkImageUsageFlagBits</a> values </li> <li id="VUID-vkGetPhysicalDeviceImageFormatProperties-usage-requiredbitmask">  <code>usage</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkGetPhysicalDeviceImageFormatProperties-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkImageCreateFlagBits">VkImageCreateFlagBits</a> values </li> <li id="VUID-vkGetPhysicalDeviceImageFormatProperties-pImageFormatProperties-parameter">  <code>pImageFormatProperties</code> <strong>must</strong> be a pointer to a <code>VkImageFormatProperties</code> structure </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_FORMAT_NOT_SUPPORTED</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_115">See Also</h4>  <p><a href="#VkFormat">VkFormat</a>, <a href="#VkImageCreateFlags">VkImageCreateFlags</a>, <a href="#VkImageFormatProperties">VkImageFormatProperties</a>, <a href="#VkImageTiling">VkImageTiling</a>, <a href="#VkImageType">VkImageType</a>, <a href="#VkImageUsageFlags">VkImageUsageFlags</a>, <a href="#VkPhysicalDevice">VkPhysicalDevice</a></p>    <h4 id="_document_notes_115">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceImageFormatProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceImageFormatProperties</a></p>         <h3 id="_vkgetphysicaldevicememoryproperties_3">vkGetPhysicalDeviceMemoryProperties(3)</h3>  <h4 id="_name_116">Name</h4>  <p>vkGetPhysicalDeviceMemoryProperties - Reports memory information for the specified physical device</p>    <h4 id="_c_specification_116">C Specification</h4>  <p>To query memory properties, call:</p>  <pre id="vkGetPhysicalDeviceMemoryProperties" data-language="c++">void vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties*           pMemoryProperties);</pre>   <h4 id="_parameters_116">Parameters</h4>  <ul> <li> <code>physicalDevice</code> is the handle to the device to query. </li> <li> <code>pMemoryProperties</code> points to an instance of <code>VkPhysicalDeviceMemoryProperties</code> structure in which the properties are returned. </li> </ul>    <h4 id="_description_116">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetPhysicalDeviceMemoryProperties-physicalDevice-parameter">  <code>physicalDevice</code> <strong>must</strong> be a valid <code>VkPhysicalDevice</code> handle </li> <li id="VUID-vkGetPhysicalDeviceMemoryProperties-pMemoryProperties-parameter">  <code>pMemoryProperties</code> <strong>must</strong> be a pointer to a <code>VkPhysicalDeviceMemoryProperties</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_116">See Also</h4>  <p><a href="#VkPhysicalDevice">VkPhysicalDevice</a>, <a href="#VkPhysicalDeviceMemoryProperties">VkPhysicalDeviceMemoryProperties</a></p>    <h4 id="_document_notes_116">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceMemoryProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceMemoryProperties</a></p>         <h3 id="_vkgetphysicaldeviceproperties_3">vkGetPhysicalDeviceProperties(3)</h3>  <h4 id="_name_117">Name</h4>  <p>vkGetPhysicalDeviceProperties - Returns properties of a physical device</p>    <h4 id="_c_specification_117">C Specification</h4>  <p>To query general properties of physical devices once enumerated, call:</p>  <pre id="vkGetPhysicalDeviceProperties" data-language="c++">void vkGetPhysicalDeviceProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties*                 pProperties);</pre>   <h4 id="_parameters_117">Parameters</h4>  <ul> <li> <code>physicalDevice</code> is the handle to the physical device whose properties will be queried. </li> <li> <code>pProperties</code> points to an instance of the <a href="#VkPhysicalDeviceProperties">VkPhysicalDeviceProperties</a> structure, that will be filled with returned information. </li> </ul>    <h4 id="_description_117">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetPhysicalDeviceProperties-physicalDevice-parameter">  <code>physicalDevice</code> <strong>must</strong> be a valid <code>VkPhysicalDevice</code> handle </li> <li id="VUID-vkGetPhysicalDeviceProperties-pProperties-parameter">  <code>pProperties</code> <strong>must</strong> be a pointer to a <code>VkPhysicalDeviceProperties</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_117">See Also</h4>  <p><a href="#VkPhysicalDevice">VkPhysicalDevice</a>, <a href="#VkPhysicalDeviceProperties">VkPhysicalDeviceProperties</a></p>    <h4 id="_document_notes_117">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceProperties</a></p>         <h3 id="_vkgetphysicaldevicequeuefamilyproperties_3">vkGetPhysicalDeviceQueueFamilyProperties(3)</h3>  <h4 id="_name_118">Name</h4>  <p>vkGetPhysicalDeviceQueueFamilyProperties - Reports properties of the queues of the specified physical device</p>    <h4 id="_c_specification_118">C Specification</h4>  <p>To query properties of queues available on a physical device, call:</p>  <pre id="vkGetPhysicalDeviceQueueFamilyProperties" data-language="c++">void vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties*                    pQueueFamilyProperties);</pre>   <h4 id="_parameters_118">Parameters</h4>  <ul> <li> <code>physicalDevice</code> is the handle to the physical device whose properties will be queried. </li> <li> <code>pQueueFamilyPropertyCount</code> is a pointer to an integer related to the number of queue families available or queried, as described below. </li> <li> <code>pQueueFamilyProperties</code> is either <code>NULL</code> or a pointer to an array of <a href="#VkQueueFamilyProperties">VkQueueFamilyProperties</a> structures. </li> </ul>    <h4 id="_description_118">Description</h4>  <p>If <code>pQueueFamilyProperties</code> is <code>NULL</code>, then the number of queue families available is returned in <code>pQueueFamilyPropertyCount</code>. Otherwise, <code>pQueueFamilyPropertyCount</code> <strong>must</strong> point to a variable set by the user to the number of elements in the <code>pQueueFamilyProperties</code> array, and on return the variable is overwritten with the number of structures actually written to <code>pQueueFamilyProperties</code>. If <code>pQueueFamilyPropertyCount</code> is less than the number of queue families available, at most <code>pQueueFamilyPropertyCount</code> structures will be written.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetPhysicalDeviceQueueFamilyProperties-physicalDevice-parameter">  <code>physicalDevice</code> <strong>must</strong> be a valid <code>VkPhysicalDevice</code> handle </li> <li id="VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyPropertyCount-parameter">  <code>pQueueFamilyPropertyCount</code> <strong>must</strong> be a pointer to a <code>uint32_t</code> value </li> <li id="VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyProperties-parameter">  If the value referenced by <code>pQueueFamilyPropertyCount</code> is not <code>0</code>, and <code>pQueueFamilyProperties</code> is not <code>NULL</code>, <code>pQueueFamilyProperties</code> <strong>must</strong> be a pointer to an array of <code>pQueueFamilyPropertyCount</code> <code>VkQueueFamilyProperties</code> structures </li> </ul>   </blockquote>   <h4 id="_see_also_118">See Also</h4>  <p><a href="#VkPhysicalDevice">VkPhysicalDevice</a>, <a href="#VkQueueFamilyProperties">VkQueueFamilyProperties</a></p>    <h4 id="_document_notes_118">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceQueueFamilyProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceQueueFamilyProperties</a></p>         <h3 id="_vkgetphysicaldevicesparseimageformatproperties_3">vkGetPhysicalDeviceSparseImageFormatProperties(3)</h3>  <h4 id="_name_119">Name</h4>  <p>vkGetPhysicalDeviceSparseImageFormatProperties - Retrieve properties of an image format applied to sparse images</p>    <h4 id="_c_specification_119">C Specification</h4>  <p><code>vkGetPhysicalDeviceSparseImageFormatProperties</code> returns an array of <a href="#VkSparseImageFormatProperties">VkSparseImageFormatProperties</a>. Each element will describe properties for one set of image aspects that are bound simultaneously in the image. This is usually one element for each aspect in the image, but for interleaved depth/stencil images there is only one element describing the combined aspects.</p>  <pre id="vkGetPhysicalDeviceSparseImageFormatProperties" data-language="c++">void vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties*              pProperties);</pre>   <h4 id="_parameters_119">Parameters</h4>  <ul> <li> <code>physicalDevice</code> is the physical device from which to query the sparse image capabilities. </li> <li> <code>format</code> is the image format. </li> <li> <code>type</code> is the dimensionality of image. </li> <li> <code>samples</code> is the number of samples per pixel as defined in <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a>. </li> <li> <code>usage</code> is a bitmask describing the intended usage of the image. </li> <li> <code>tiling</code> is the tiling arrangement of the data elements in memory. </li> <li> <code>pPropertyCount</code> is a pointer to an integer related to the number of sparse format properties available or queried, as described below. </li> <li> <code>pProperties</code> is either <code>NULL</code> or a pointer to an array of <a href="#VkSparseImageFormatProperties">VkSparseImageFormatProperties</a> structures. </li> </ul>    <h4 id="_description_119">Description</h4>  <p>If <code>pProperties</code> is <code>NULL</code>, then the number of sparse format properties available is returned in <code>pPropertyCount</code>. Otherwise, <code>pPropertyCount</code> <strong>must</strong> point to a variable set by the user to the number of elements in the <code>pProperties</code> array, and on return the variable is overwritten with the number of structures actually written to <code>pProperties</code>. If <code>pPropertyCount</code> is less than the number of sparse format properties available, at most <code>pPropertyCount</code> structures will be written.</p>   <p>If <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> is not supported for the given arguments, <code>pPropertyCount</code> will be set to zero upon return, and no data will be written to <code>pProperties</code>.</p>   <p>Multiple aspects are returned for depth/stencil images that are implemented as separate planes by the implementation. The depth and stencil data planes each have unique <code>VkSparseImageFormatProperties</code> data.</p>   <p>Depth/stencil images with depth and stencil data interleaved into a single plane will return a single <code>VkSparseImageFormatProperties</code> structure with the <code>aspectMask</code> set to <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> | <code>VK_IMAGE_ASPECT_STENCIL_BIT</code>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-01094">  <code>samples</code> <strong>must</strong> be a bit value that is set in <code>VkImageFormatProperties</code>::<code>sampleCounts</code> returned by <code>vkGetPhysicalDeviceImageFormatProperties</code> with <code>format</code>, <code>type</code>, <code>tiling</code>, and <code>usage</code> equal to those in this command and <code>flags</code> equal to the value that is set in <code>VkImageCreateInfo</code>::<code>flags</code> when the image is created </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-physicalDevice-parameter">  <code>physicalDevice</code> <strong>must</strong> be a valid <code>VkPhysicalDevice</code> handle </li> <li id="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-format-parameter">  <code>format</code> <strong>must</strong> be a valid <a href="#VkFormat">VkFormat</a> value </li> <li id="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-type-parameter">  <code>type</code> <strong>must</strong> be a valid <a href="#VkImageType">VkImageType</a> value </li> <li id="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter">  <code>samples</code> <strong>must</strong> be a valid <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> value </li> <li id="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-parameter">  <code>usage</code> <strong>must</strong> be a valid combination of <a href="#VkImageUsageFlagBits">VkImageUsageFlagBits</a> values </li> <li id="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-requiredbitmask">  <code>usage</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-tiling-parameter">  <code>tiling</code> <strong>must</strong> be a valid <a href="#VkImageTiling">VkImageTiling</a> value </li> <li id="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pPropertyCount-parameter">  <code>pPropertyCount</code> <strong>must</strong> be a pointer to a <code>uint32_t</code> value </li> <li id="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pProperties-parameter">  If the value referenced by <code>pPropertyCount</code> is not <code>0</code>, and <code>pProperties</code> is not <code>NULL</code>, <code>pProperties</code> <strong>must</strong> be a pointer to an array of <code>pPropertyCount</code> <code>VkSparseImageFormatProperties</code> structures </li> </ul>   </blockquote>   <h4 id="_see_also_119">See Also</h4>  <p><a href="#VkFormat">VkFormat</a>, <a href="#VkImageTiling">VkImageTiling</a>, <a href="#VkImageType">VkImageType</a>, <a href="#VkImageUsageFlags">VkImageUsageFlags</a>, <a href="#VkPhysicalDevice">VkPhysicalDevice</a>, <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a>, <a href="#VkSparseImageFormatProperties">VkSparseImageFormatProperties</a></p>    <h4 id="_document_notes_119">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceSparseImageFormatProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPhysicalDeviceSparseImageFormatProperties</a></p>         <h3 id="_vkgetpipelinecachedata_3">vkGetPipelineCacheData(3)</h3>  <h4 id="_name_120">Name</h4>  <p>vkGetPipelineCacheData - Get the data store from a pipeline cache</p>    <h4 id="_c_specification_120">C Specification</h4>  <p>Data <strong>can</strong> be retrieved from a pipeline cache object using the command:</p>  <pre id="vkGetPipelineCacheData" data-language="c++">VkResult vkGetPipelineCacheData(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    size_t*                                     pDataSize,
    void*                                       pData);</pre>   <h4 id="_parameters_120">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the pipeline cache. </li> <li> <code>pipelineCache</code> is the pipeline cache to retrieve data from. </li> <li> <code>pDataSize</code> is a pointer to a value related to the amount of data in the pipeline cache, as described below. </li> <li> <code>pData</code> is either <code>NULL</code> or a pointer to a buffer. </li> </ul>    <h4 id="_description_120">Description</h4>  <p>If <code>pData</code> is <code>NULL</code>, then the maximum size of the data that <strong>can</strong> be retrieved from the pipeline cache, in bytes, is returned in <code>pDataSize</code>. Otherwise, <code>pDataSize</code> <strong>must</strong> point to a variable set by the user to the size of the buffer, in bytes, pointed to by <code>pData</code>, and on return the variable is overwritten with the amount of data actually written to <code>pData</code>.</p>   <p>If <code>pDataSize</code> is less than the maximum size that <strong>can</strong> be retrieved by the pipeline cache, at most <code>pDataSize</code> bytes will be written to <code>pData</code>, and <code>vkGetPipelineCacheData</code> will return <code>VK_INCOMPLETE</code>. Any data written to <code>pData</code> is valid and <strong>can</strong> be provided as the <code>pInitialData</code> member of the <code>VkPipelineCacheCreateInfo</code> structure passed to <code>vkCreatePipelineCache</code>.</p>   <p>Two calls to <code>vkGetPipelineCacheData</code> with the same parameters <strong>must</strong> retrieve the same data unless a command that modifies the contents of the cache is called between them.</p>   <p>Applications <strong>can</strong> store the data retrieved from the pipeline cache, and use these data, possibly in a future run of the application, to populate new pipeline cache objects. The results of pipeline compiles, however, <strong>may</strong> depend on the vendor ID, device ID, driver version, and other details of the device. To enable applications to detect when previously retrieved data is incompatible with the device, the initial bytes written to <code>pData</code> <strong>must</strong> be a header consisting of the following members:</p>  <div class="_table"><table class="tableblock frame-all grid-all" style="width: 85%;"> <caption class="title">Table 5. Layout for pipeline cache header version <code>VK_PIPELINE_CACHE_HEADER_VERSION_ONE</code>
</caption> <colgroup> <col style="width: 8%;"> <col style="width: 21%;"> <col style="width: 71%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Offset</th> <th class="tableblock halign-left valign-top">Size</th> <th class="tableblock halign-left valign-top">Meaning</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">length in bytes of the entire pipeline cache header written as a stream of bytes, with the least significant byte first</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">a <a href="#VkPipelineCacheHeaderVersion">VkPipelineCacheHeaderVersion</a> value written as a stream of bytes, with the least significant byte first</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">a vendor ID equal to <code>VkPhysicalDeviceProperties</code>::<code>vendorID</code> written as a stream of bytes, with the least significant byte first</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">a device ID equal to <code>VkPhysicalDeviceProperties</code>::<code>deviceID</code> written as a stream of bytes, with the least significant byte first</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_UUID_SIZE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">a pipeline cache ID equal to <code>VkPhysicalDeviceProperties</code>::<code>pipelineCacheUUID</code></p></td> </tr> </tbody> </table></div>  <p>The first four bytes encode the length of the entire pipeline header, in bytes. This value includes all fields in the header including the pipeline cache version field and the size of the length field.</p>   <p>The next four bytes encode the pipeline cache version, as described for <a href="#VkPipelineCacheHeaderVersion">VkPipelineCacheHeaderVersion</a>. A consumer of the pipeline cache <strong>should</strong> use the cache version to interpret the remainder of the cache header.</p>   <p>If <code>pDataSize</code> is less than what is necessary to store this header, nothing will be written to <code>pData</code> and zero will be written to <code>pDataSize</code>.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetPipelineCacheData-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetPipelineCacheData-pipelineCache-parameter">  <code>pipelineCache</code> <strong>must</strong> be a valid <code>VkPipelineCache</code> handle </li> <li id="VUID-vkGetPipelineCacheData-pDataSize-parameter">  <code>pDataSize</code> <strong>must</strong> be a pointer to a <code>size_t</code> value </li> <li id="VUID-vkGetPipelineCacheData-pData-parameter">  If the value referenced by <code>pDataSize</code> is not <code>0</code>, and <code>pData</code> is not <code>NULL</code>, <code>pData</code> <strong>must</strong> be a pointer to an array of <code>pDataSize</code> bytes </li> <li id="VUID-vkGetPipelineCacheData-pipelineCache-parent">  <code>pipelineCache</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> <li> <code>VK_INCOMPLETE</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_120">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkPipelineCache">VkPipelineCache</a></p>    <h4 id="_document_notes_120">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPipelineCacheData">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetPipelineCacheData</a></p>         <h3 id="_vkgetquerypoolresults_3">vkGetQueryPoolResults(3)</h3>  <h4 id="_name_121">Name</h4>  <p>vkGetQueryPoolResults - Copy results of queries in a query pool to a host memory region</p>    <h4 id="_c_specification_121">C Specification</h4>  <p>To retrieve status and results for a set of queries, call:</p>  <pre id="vkGetQueryPoolResults" data-language="c++">VkResult vkGetQueryPoolResults(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    void*                                       pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);</pre>   <h4 id="_parameters_121">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the query pool. </li> <li> <code>queryPool</code> is the query pool managing the queries containing the desired results. </li> <li> <code>firstQuery</code> is the initial query index. </li> <li> <code>queryCount</code> is the number of queries. <code>firstQuery</code> and <code>queryCount</code> together define a range of queries. For pipeline statistics queries, each query index in the pool contains one integer value for each bit that is enabled in <a href="#VkQueryPoolCreateInfo">VkQueryPoolCreateInfo</a>::<code>pipelineStatistics</code> when the pool is created. </li> <li> <code>dataSize</code> is the size in bytes of the buffer pointed to by <code>pData</code>. </li> <li> <code>pData</code> is a pointer to a user-allocated buffer where the results will be written </li> <li> <code>stride</code> is the stride in bytes between results for individual queries within <code>pData</code>. </li> <li> <code>flags</code> is a bitmask of <a href="#VkQueryResultFlagBits">VkQueryResultFlagBits</a> specifying how and when results are returned. </li> </ul>    <h4 id="_description_121">Description</h4>  <p>If no bits are set in <code>flags</code>, and all requested queries are in the available state, results are written as an array of 32-bit unsigned integer values. The behavior when not all queries are available, is described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-wait-bit-not-set">below</a>.</p>   <p>If <code>VK_QUERY_RESULT_64_BIT</code> is not set and the result overflows a 32-bit value, the value <strong>may</strong> either wrap or saturate. Similarly, if <code>VK_QUERY_RESULT_64_BIT</code> is set and the result overflows a 64-bit value, the value <strong>may</strong> either wrap or saturate.</p>   <p>If <code>VK_QUERY_RESULT_WAIT_BIT</code> is set, Vulkan will wait for each query to be in the available state before retrieving the numerical results for that query. In this case, <code>vkGetQueryPoolResults</code> is guaranteed to succeed and return <code>VK_SUCCESS</code> if the queries become available in a finite time (i.e. if they have been issued and not reset). If queries will never finish (e.g. due to being reset but not issued), then <code>vkGetQueryPoolResults</code> <strong>may</strong> not return in finite time.</p>   <p>If <code>VK_QUERY_RESULT_WAIT_BIT</code> and <code>VK_QUERY_RESULT_PARTIAL_BIT</code> are both not set then no result values are written to <code>pData</code> for queries that are in the unavailable state at the time of the call, and <code>vkGetQueryPoolResults</code> returns <code>VK_NOT_READY</code>. However, availability state is still written to <code>pData</code> for those queries if <code>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</code> is set.</p>  <blockquote> <h5 class="title">Note</h5>  <p>Applications <strong>must</strong> take care to ensure that use of the <code>VK_QUERY_RESULT_WAIT_BIT</code> bit has the desired effect.</p>   <p>For example, if a query has been used previously and a command buffer records the commands <code>vkCmdResetQueryPool</code>, <code>vkCmdBeginQuery</code>, and <code>vkCmdEndQuery</code> for that query, then the query will remain in the available state until the <code>vkCmdResetQueryPool</code> command executes on a queue. Applications <strong>can</strong> use fences or events to ensure that a query has already been reset before checking for its results or availability status. Otherwise, a stale value could be returned from a previous use of the query.</p>   <p>The above also applies when <code>VK_QUERY_RESULT_WAIT_BIT</code> is used in combination with <code>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</code>. In this case, the returned availability status <strong>may</strong> reflect the result of a previous use of the query unless the <code>vkCmdResetQueryPool</code> command has been executed since the last use of the query.</p>  </blockquote> <blockquote> <h5 class="title">Note</h5>  <p>Applications <strong>can</strong> double-buffer query pool usage, with a pool per frame, and reset queries at the end of the frame in which they are read.</p>  </blockquote>  <p>If <code>VK_QUERY_RESULT_PARTIAL_BIT</code> is set, <code>VK_QUERY_RESULT_WAIT_BIT</code> is not set, and the query’s status is unavailable, an intermediate result value between zero and the final result value is written to <code>pData</code> for that query.</p>   <p><code>VK_QUERY_RESULT_PARTIAL_BIT</code> <strong>must</strong> not be used if the pool’s <code>queryType</code> is <code>VK_QUERY_TYPE_TIMESTAMP</code>.</p>   <p>If <code>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</code> is set, the final integer value written for each query is non-zero if the query’s status was available or zero if the status was unavailable. When <code>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</code> is used, implementations <strong>must</strong> guarantee that if they return a non-zero availability value then the numerical results <strong>must</strong> be valid, assuming the results are not reset by a subsequent command.</p>  <blockquote> <h5 class="title">Note</h5>  <p>Satisfying this guarantee <strong>may</strong> require careful ordering by the application, e.g. to read the availability status before reading the results.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkGetQueryPoolResults-firstQuery-00813">  <code>firstQuery</code> <strong>must</strong> be less than the number of queries in <code>queryPool</code> </li> <li id="VUID-vkGetQueryPoolResults-flags-00814">  If <code>VK_QUERY_RESULT_64_BIT</code> is not set in <code>flags</code> then <code>pData</code> and <code>stride</code> <strong>must</strong> be multiples of <code>4</code> </li> <li id="VUID-vkGetQueryPoolResults-flags-00815">  If <code>VK_QUERY_RESULT_64_BIT</code> is set in <code>flags</code> then <code>pData</code> and <code>stride</code> <strong>must</strong> be multiples of <code>8</code> </li> <li id="VUID-vkGetQueryPoolResults-firstQuery-00816">  The sum of <code>firstQuery</code> and <code>queryCount</code> <strong>must</strong> be less than or equal to the number of queries in <code>queryPool</code> </li> <li id="VUID-vkGetQueryPoolResults-dataSize-00817">  <code>dataSize</code> <strong>must</strong> be large enough to contain the result of each query, as described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-memorylayout">here</a> </li> <li id="VUID-vkGetQueryPoolResults-queryType-00818">  If the <code>queryType</code> used to create <code>queryPool</code> was <code>VK_QUERY_TYPE_TIMESTAMP</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_QUERY_RESULT_PARTIAL_BIT</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetQueryPoolResults-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetQueryPoolResults-queryPool-parameter">  <code>queryPool</code> <strong>must</strong> be a valid <code>VkQueryPool</code> handle </li> <li id="VUID-vkGetQueryPoolResults-pData-parameter">  <code>pData</code> <strong>must</strong> be a pointer to an array of <code>dataSize</code> bytes </li> <li id="VUID-vkGetQueryPoolResults-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkQueryResultFlagBits">VkQueryResultFlagBits</a> values </li> <li id="VUID-vkGetQueryPoolResults-dataSize-arraylength">  <code>dataSize</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkGetQueryPoolResults-queryPool-parent">  <code>queryPool</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> <li> <code>VK_NOT_READY</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_DEVICE_LOST</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_121">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <code>VkDeviceSize</code>, <a href="#VkQueryPool">VkQueryPool</a>, <a href="#VkQueryResultFlags">VkQueryResultFlags</a></p>    <h4 id="_document_notes_121">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetQueryPoolResults">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetQueryPoolResults</a></p>         <h3 id="_vkgetrenderareagranularity_3">vkGetRenderAreaGranularity(3)</h3>  <h4 id="_name_122">Name</h4>  <p>vkGetRenderAreaGranularity - Returns the granularity for optimal render area</p>    <h4 id="_c_specification_122">C Specification</h4>  <p>To query the render area granularity, call:</p>  <pre id="vkGetRenderAreaGranularity" data-language="c++">void vkGetRenderAreaGranularity(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkExtent2D*                                 pGranularity);</pre>   <h4 id="_parameters_122">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the render pass. </li> <li> <code>renderPass</code> is a handle to a render pass. </li> <li> <code>pGranularity</code> points to a <a href="#VkExtent2D">VkExtent2D</a> structure in which the granularity is returned. </li> </ul>    <h4 id="_description_122">Description</h4>  <p>The conditions leading to an optimal <code>renderArea</code> are:</p>   <ul> <li> the <code>offset.x</code> member in <code>renderArea</code> is a multiple of the <code>width</code> member of the returned <a href="#VkExtent2D">VkExtent2D</a> (the horizontal granularity). </li> <li> the <code>offset.y</code> member in <code>renderArea</code> is a multiple of the <code>height</code> of the returned <a href="#VkExtent2D">VkExtent2D</a> (the vertical granularity). </li> <li> either the <code>offset.width</code> member in <code>renderArea</code> is a multiple of the horizontal granularity or <code>offset.x</code>+<code>offset.width</code> is equal to the <code>width</code> of the <code>framebuffer</code> in the <a href="#VkRenderPassBeginInfo">VkRenderPassBeginInfo</a>. </li> <li> either the <code>offset.height</code> member in <code>renderArea</code> is a multiple of the vertical granularity or <code>offset.y</code>+<code>offset.height</code> is equal to the <code>height</code> of the <code>framebuffer</code> in the <a href="#VkRenderPassBeginInfo">VkRenderPassBeginInfo</a>. </li> </ul>   <p>Subpass dependencies are not affected by the render area, and apply to the entire image subresources attached to the framebuffer as specified in the description of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-layout-transitions">automatic layout transitions</a>. Similarly, pipeline barriers are valid even if their effect extends outside the render area.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkGetRenderAreaGranularity-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkGetRenderAreaGranularity-renderPass-parameter">  <code>renderPass</code> <strong>must</strong> be a valid <code>VkRenderPass</code> handle </li> <li id="VUID-vkGetRenderAreaGranularity-pGranularity-parameter">  <code>pGranularity</code> <strong>must</strong> be a pointer to a <code>VkExtent2D</code> structure </li> <li id="VUID-vkGetRenderAreaGranularity-renderPass-parent">  <code>renderPass</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote>   <h4 id="_see_also_122">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkExtent2D">VkExtent2D</a>, <a href="#VkRenderPass">VkRenderPass</a></p>    <h4 id="_document_notes_122">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetRenderAreaGranularity">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkGetRenderAreaGranularity</a></p>         <h3 id="_vkinvalidatemappedmemoryranges_3">vkInvalidateMappedMemoryRanges(3)</h3>  <h4 id="_name_123">Name</h4>  <p>vkInvalidateMappedMemoryRanges - Invalidate ranges of mapped memory objects</p>    <h4 id="_c_specification_123">C Specification</h4>  <p>To invalidate ranges of non-coherent memory from the host caches, call:</p>  <pre id="vkInvalidateMappedMemoryRanges" data-language="c++">VkResult vkInvalidateMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges);</pre>   <h4 id="_parameters_123">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the memory ranges. </li> <li> <code>memoryRangeCount</code> is the length of the <code>pMemoryRanges</code> array. </li> <li> <code>pMemoryRanges</code> is a pointer to an array of <a href="#VkMappedMemoryRange">VkMappedMemoryRange</a> structures describing the memory ranges to invalidate. </li> </ul>    <h4 id="_description_123">Description</h4>  <p><code>vkInvalidateMappedMemoryRanges</code> guarantees that device writes to the memory ranges described by <code>pMemoryRanges</code>, which have been made visible to the <code>VK_ACCESS_HOST_WRITE_BIT</code> and <code>VK_ACCESS_HOST_READ_BIT</code> <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types">access types</a>, are made visible to the host. If a range of non-coherent memory is written by the host and then invalidated without first being flushed, its contents are undefined.</p>  <blockquote> <h5 class="title">Note</h5>  <p>Mapping non-coherent memory does not implicitly invalidate the mapped memory, and device writes that have not been invalidated <strong>must</strong> be made visible before the host reads or overwrites them.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkInvalidateMappedMemoryRanges-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkInvalidateMappedMemoryRanges-pMemoryRanges-parameter">  <code>pMemoryRanges</code> <strong>must</strong> be a pointer to an array of <code>memoryRangeCount</code> valid <code>VkMappedMemoryRange</code> structures </li> <li id="VUID-vkInvalidateMappedMemoryRanges-memoryRangeCount-arraylength">  <code>memoryRangeCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_123">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkMappedMemoryRange">VkMappedMemoryRange</a></p>    <h4 id="_document_notes_123">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkInvalidateMappedMemoryRanges">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkInvalidateMappedMemoryRanges</a></p>         <h3 id="_vkmapmemory_3">vkMapMemory(3)</h3>  <h4 id="_name_124">Name</h4>  <p>vkMapMemory - Map a memory object into application address space</p>    <h4 id="_c_specification_124">C Specification</h4>  <p>To retrieve a host virtual address pointer to a region of a mappable memory object, call:</p>  <pre id="vkMapMemory" data-language="c++">VkResult vkMapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData);</pre>   <h4 id="_parameters_124">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the memory. </li> <li> <code>memory</code> is the <code>VkDeviceMemory</code> object to be mapped. </li> <li> <code>offset</code> is a zero-based byte offset from the beginning of the memory object. </li> <li> <code>size</code> is the size of the memory range to map, or <code>VK_WHOLE_SIZE</code> to map from <code>offset</code> to the end of the allocation. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>ppData</code> points to a pointer in which is returned a host-accessible pointer to the beginning of the mapped range. This pointer minus <code>offset</code> <strong>must</strong> be aligned to at least <code>VkPhysicalDeviceLimits</code>::<code>minMemoryMapAlignment</code>. </li> </ul>    <h4 id="_description_124">Description</h4>  <p>It is an application error to call <code>vkMapMemory</code> on a memory object that is already mapped.</p>  <blockquote> <h5 class="title">Note</h5>  <p><code>vkMapMemory</code> will fail if the implementation is unable to allocate an appropriately sized contiguous virtual address range, e.g. due to virtual address space fragmentation or platform limits. In such cases, <code>vkMapMemory</code> <strong>must</strong> return <code>VK_ERROR_MEMORY_MAP_FAILED</code>. The application <strong>can</strong> improve the likelihood of success by reducing the size of the mapped range and/or removing unneeded mappings using <code>VkUnmapMemory</code>.</p>  </blockquote>  <p><code>vkMapMemory</code> does not check whether the device memory is currently in use before returning the host-accessible pointer. The application <strong>must</strong> guarantee that any previously submitted command that writes to this range has completed before the host reads from or writes to that range, and that any previously submitted command that reads from that range has completed before the host writes to that region (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-host-writes">here</a> for details on fulfilling such a guarantee). If the device memory was allocated without the <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> set, these guarantees <strong>must</strong> be made for an extended range: the application <strong>must</strong> round down the start of the range to the nearest multiple of <code>VkPhysicalDeviceLimits</code>::<code>nonCoherentAtomSize</code>, and round the end of the range up to the nearest multiple of <code>VkPhysicalDeviceLimits</code>::<code>nonCoherentAtomSize</code>.</p>   <p>While a range of device memory is mapped for host access, the application is responsible for synchronizing both device and host access to that memory range.</p>  <blockquote> <h5 class="title">Note</h5>  <p>It is important for the application developer to become meticulously familiar with all of the mechanisms described in the chapter on <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">Synchronization and Cache Control</a> as they are crucial to maintaining memory access ordering.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkMapMemory-memory-00678">  <code>memory</code> <strong>must</strong> not currently be mapped </li> <li id="VUID-vkMapMemory-offset-00679">  <code>offset</code> <strong>must</strong> be less than the size of <code>memory</code> </li> <li id="VUID-vkMapMemory-size-00680">  If <code>size</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>size</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkMapMemory-size-00681">  If <code>size</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>size</code> <strong>must</strong> be less than or equal to the size of the <code>memory</code> minus <code>offset</code> </li> <li id="VUID-vkMapMemory-memory-00682">  <code>memory</code> <strong>must</strong> have been created with a memory type that reports <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkMapMemory-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkMapMemory-memory-parameter">  <code>memory</code> <strong>must</strong> be a valid <code>VkDeviceMemory</code> handle </li> <li id="VUID-vkMapMemory-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-vkMapMemory-ppData-parameter">  <code>ppData</code> <strong>must</strong> be a pointer to a pointer </li> <li id="VUID-vkMapMemory-memory-parent">  <code>memory</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>memory</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_MEMORY_MAP_FAILED</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_124">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkDeviceMemory">VkDeviceMemory</a>, <code>VkDeviceSize</code>, <a href="#VkMemoryMapFlags">VkMemoryMapFlags</a></p>    <h4 id="_document_notes_124">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkMapMemory">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkMapMemory</a></p>         <h3 id="_vkmergepipelinecaches_3">vkMergePipelineCaches(3)</h3>  <h4 id="_name_125">Name</h4>  <p>vkMergePipelineCaches - Combine the data stores of pipeline caches</p>    <h4 id="_c_specification_125">C Specification</h4>  <p>Pipeline cache objects <strong>can</strong> be merged using the command:</p>  <pre id="vkMergePipelineCaches" data-language="c++">VkResult vkMergePipelineCaches(
    VkDevice                                    device,
    VkPipelineCache                             dstCache,
    uint32_t                                    srcCacheCount,
    const VkPipelineCache*                      pSrcCaches);</pre>   <h4 id="_parameters_125">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the pipeline cache objects. </li> <li> <code>dstCache</code> is the handle of the pipeline cache to merge results into. </li> <li> <code>srcCacheCount</code> is the length of the <code>pSrcCaches</code> array. </li> <li> <code>pSrcCaches</code> is an array of pipeline cache handles, which will be merged into <code>dstCache</code>. The previous contents of <code>dstCache</code> are included after the merge. </li> </ul>    <h4 id="_description_125">Description</h4> <blockquote> <h5 class="title">Note</h5>  <p>The details of the merge operation are implementation dependent, but implementations <strong>should</strong> merge the contents of the specified pipelines and prune duplicate entries.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkMergePipelineCaches-dstCache-00770">  <code>dstCache</code> <strong>must</strong> not appear in the list of source caches </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkMergePipelineCaches-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkMergePipelineCaches-dstCache-parameter">  <code>dstCache</code> <strong>must</strong> be a valid <code>VkPipelineCache</code> handle </li> <li id="VUID-vkMergePipelineCaches-pSrcCaches-parameter">  <code>pSrcCaches</code> <strong>must</strong> be a pointer to an array of <code>srcCacheCount</code> valid <code>VkPipelineCache</code> handles </li> <li id="VUID-vkMergePipelineCaches-srcCacheCount-arraylength">  <code>srcCacheCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkMergePipelineCaches-dstCache-parent">  <code>dstCache</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> <li id="VUID-vkMergePipelineCaches-pSrcCaches-parent">  Each element of <code>pSrcCaches</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>dstCache</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_125">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkPipelineCache">VkPipelineCache</a></p>    <h4 id="_document_notes_125">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkMergePipelineCaches">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkMergePipelineCaches</a></p>         <h3 id="_vkqueuebindsparse_3">vkQueueBindSparse(3)</h3>  <h4 id="_name_126">Name</h4>  <p>vkQueueBindSparse - Bind device memory to a sparse resource object</p>    <h4 id="_c_specification_126">C Specification</h4>  <p>To submit sparse binding operations to a queue, call:</p>  <pre id="vkQueueBindSparse" data-language="c++">VkResult vkQueueBindSparse(
    VkQueue                                     queue,
    uint32_t                                    bindInfoCount,
    const VkBindSparseInfo*                     pBindInfo,
    VkFence                                     fence);</pre>   <h4 id="_parameters_126">Parameters</h4>  <ul> <li> <code>queue</code> is the queue that the sparse binding operations will be submitted to. </li> <li> <code>bindInfoCount</code> is the number of elements in the <code>pBindInfo</code> array. </li> <li> <code>pBindInfo</code> is an array of <a href="#VkBindSparseInfo">VkBindSparseInfo</a> structures, each specifying a sparse binding submission batch. </li> <li> <code>fence</code> is an optional handle to a fence to be signaled. If <code>fence</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, it defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-fences-signaling">fence signal operation</a>. </li> </ul>    <h4 id="_description_126">Description</h4>  <p><code>vkQueueBindSparse</code> is a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission">queue submission command</a>, with each batch defined by an element of <code>pBindInfo</code> as an instance of the <a href="#VkBindSparseInfo">VkBindSparseInfo</a> structure. Batches begin execution in the order they appear in <code>pBindInfo</code>, but <strong>may</strong> complete out of order.</p>   <p>Within a batch, a given range of a resource <strong>must</strong> not be bound more than once. Across batches, if a range is to be bound to one allocation and offset and then to another allocation and offset, then the application <strong>must</strong> guarantee (usually using semaphores) that the binding operations are executed in the correct order, as well as to order binding operations against the execution of command buffer submissions.</p>   <p>As no operation to <a href="#vkQueueBindSparse">vkQueueBindSparse</a> causes any pipeline stage to access memory, synchronization primitives used in this command effectively only define execution dependencies.</p>   <p>Additional information about fence and semaphore operation is described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">the synchronization chapter</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkQueueBindSparse-fence-01113">  If <code>fence</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>fence</code> <strong>must</strong> be unsignaled </li> <li id="VUID-vkQueueBindSparse-fence-01114">  If <code>fence</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>fence</code> <strong>must</strong> not be associated with any other queue command that has not yet completed execution on that queue </li> <li id="VUID-vkQueueBindSparse-pSignalSemaphores-01115">  Any given element of the <code>pSignalSemaphores</code> member of any element of <code>pBindInfo</code> <strong>must</strong> be unsignaled when the semaphore signal operation it defines is executed on the device </li> <li id="VUID-vkQueueBindSparse-pWaitSemaphores-01116">  When a semaphore unsignal operation defined by any element of the <code>pWaitSemaphores</code> member of any element of <code>pBindInfo</code> executes on <code>queue</code>, no other queue <strong>must</strong> be waiting on the same semaphore. </li> <li id="VUID-vkQueueBindSparse-pWaitSemaphores-01117">  All elements of the <code>pWaitSemaphores</code> member of all elements of <code>pBindInfo</code> <strong>must</strong> be semaphores that are signaled, or have <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores-signaling">semaphore signal operations</a> previously submitted for execution. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkQueueBindSparse-queue-parameter">  <code>queue</code> <strong>must</strong> be a valid <code>VkQueue</code> handle </li> <li id="VUID-vkQueueBindSparse-pBindInfo-parameter">  If <code>bindInfoCount</code> is not <code>0</code>, <code>pBindInfo</code> <strong>must</strong> be a pointer to an array of <code>bindInfoCount</code> valid <code>VkBindSparseInfo</code> structures </li> <li id="VUID-vkQueueBindSparse-fence-parameter">  If <code>fence</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>fence</code> <strong>must</strong> be a valid <code>VkFence</code> handle </li> <li id="VUID-vkQueueBindSparse-queuetype">  The <code>queue</code> <strong>must</strong> support sparse binding operations </li> <li id="VUID-vkQueueBindSparse-commonparent">  Both of <code>fence</code>, and <code>queue</code> that are valid handles <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>queue</code> <strong>must</strong> be externally synchronized </li> <li> Host access to <code>pBindInfo</code>[].pWaitSemaphores[] <strong>must</strong> be externally synchronized </li> <li> Host access to <code>pBindInfo</code>[].pSignalSemaphores[] <strong>must</strong> be externally synchronized </li> <li> Host access to <code>pBindInfo</code>[].pBufferBinds[].buffer <strong>must</strong> be externally synchronized </li> <li> Host access to <code>pBindInfo</code>[].pImageOpaqueBinds[].image <strong>must</strong> be externally synchronized </li> <li> Host access to <code>pBindInfo</code>[].pImageBinds[].image <strong>must</strong> be externally synchronized </li> <li> Host access to <code>fence</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">SPARSE_BINDING</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td> </tr> </tbody> </table></div>  </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_DEVICE_LOST</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_126">See Also</h4>  <p><a href="#VkBindSparseInfo">VkBindSparseInfo</a>, <a href="#VkFence">VkFence</a>, <a href="#VkQueue">VkQueue</a></p>    <h4 id="_document_notes_126">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkQueueBindSparse">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkQueueBindSparse</a></p>         <h3 id="_vkqueuesubmit_3">vkQueueSubmit(3)</h3>  <h4 id="_name_127">Name</h4>  <p>vkQueueSubmit - Submits a sequence of semaphores or command buffers to a queue</p>    <h4 id="_c_specification_127">C Specification</h4>  <p>To submit command buffers to a queue, call:</p>  <pre id="vkQueueSubmit" data-language="c++">VkResult vkQueueSubmit(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    const VkSubmitInfo*                         pSubmits,
    VkFence                                     fence);</pre>   <h4 id="_parameters_127">Parameters</h4>  <ul> <li> <code>queue</code> is the queue that the command buffers will be submitted to. </li> <li> <code>submitCount</code> is the number of elements in the <code>pSubmits</code> array. </li> <li> <code>pSubmits</code> is a pointer to an array of <a href="#VkSubmitInfo">VkSubmitInfo</a> structures, each specifying a command buffer submission batch. </li> <li> <code>fence</code> is an optional handle to a fence to be signaled. If <code>fence</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, it defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-fences-signaling">fence signal operation</a>. </li> </ul>    <h4 id="_description_127">Description</h4> <blockquote> <h5 class="title">Note</h5>  <p>Submission can be a high overhead operation, and applications <strong>should</strong> attempt to batch work together into as few calls to <code>vkQueueSubmit</code> as possible.</p>  </blockquote>  <p><code>vkQueueSubmit</code> is a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission">queue submission command</a>, with each batch defined by an element of <code>pSubmits</code> as an instance of the <a href="#VkSubmitInfo">VkSubmitInfo</a> structure. Batches begin execution in the order they appear in <code>pSubmits</code>, but <strong>may</strong> complete out of order.</p>   <p>Fence and semaphore operations submitted with <a href="#vkQueueSubmit">vkQueueSubmit</a> have additional ordering constraints compared to other submission commands, with dependencies involving previous and subsequent queue operations. Information about these additional constraints can be found in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores">semaphore</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-fences">fence</a> sections of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">the synchronization chapter</a>.</p>   <p>Details on the interaction of <code>pWaitDstStageMask</code> with synchronization are described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores-waiting">semaphore wait operation</a> section of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">the synchronization chapter</a>.</p>   <p>The order that batches appear in <code>pSubmits</code> is used to determine <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order">submission order</a>, and thus all the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-implicit">implicit ordering guarantees</a> that respect it. Other than these implicit ordering guarantees and any <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">explicit synchronization primitives</a>, these batches <strong>may</strong> overlap or otherwise execute out of order.</p>   <p>If any command buffer submitted to this queue is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">executable state</a>, it is moved to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>. Once execution of all submissions of a command buffer complete, it moves from the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>, back to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">executable state</a>. If a command buffer was recorded with the <code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code> flag, it instead moves back to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid state</a>.</p>   <p>If <code>vkQueueSubmit</code> fails, it <strong>may</strong> return <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> or <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>. If it does, the implementation <strong>must</strong> ensure that the state and contents of any resources or synchronization primitives referenced by the submitted command buffers and any semaphores referenced by <code>pSubmits</code> is unaffected by the call or its failure. If <code>vkQueueSubmit</code> fails in such a way that the implementation <strong>can</strong> not make that guarantee, the implementation <strong>must</strong> return <code>VK_ERROR_DEVICE_LOST</code>. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device">Lost Device</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkQueueSubmit-fence-00063">  If <code>fence</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>fence</code> <strong>must</strong> be unsignaled </li> <li id="VUID-vkQueueSubmit-fence-00064">  If <code>fence</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>fence</code> <strong>must</strong> not be associated with any other queue command that has not yet completed execution on that queue </li> <li id="VUID-vkQueueSubmit-pCommandBuffers-00065">  Any calls to <a href="#vkCmdSetEvent">vkCmdSetEvent</a>, <a href="#vkCmdResetEvent">vkCmdResetEvent</a> or <a href="#vkCmdWaitEvents">vkCmdWaitEvents</a> that have been recorded into any of the command buffer elements of the <code>pCommandBuffers</code> member of any element of <code>pSubmits</code>, <strong>must</strong> not reference any <a href="#VkEvent">VkEvent</a> that is referenced by any of those commands in a command buffer that has been submitted to another queue and is still in the <em>pending state</em>. </li> <li id="VUID-vkQueueSubmit-pWaitDstStageMask-00066">  Any stage flag included in any element of the <code>pWaitDstStageMask</code> member of any element of <code>pSubmits</code> <strong>must</strong> be a pipeline stage supported by one of the capabilities of <code>queue</code>, as specified in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-supported">table of supported pipeline stages</a>. </li> <li id="VUID-vkQueueSubmit-pSignalSemaphores-00067">  Any given element of the <code>pSignalSemaphores</code> member of any element of <code>pSubmits</code> <strong>must</strong> be unsignaled when the semaphore signal operation it defines is executed on the device </li> <li id="VUID-vkQueueSubmit-pWaitSemaphores-00068">  When a semaphore unsignal operation defined by any element of the <code>pWaitSemaphores</code> member of any element of <code>pSubmits</code> executes on <code>queue</code>, no other queue <strong>must</strong> be waiting on the same semaphore. </li> <li id="VUID-vkQueueSubmit-pWaitSemaphores-00069">  All elements of the <code>pWaitSemaphores</code> member of all elements of <code>pSubmits</code> <strong>must</strong> be semaphores that are signaled, or have <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores-signaling">semaphore signal operations</a> previously submitted for execution. </li> <li id="VUID-vkQueueSubmit-pCommandBuffers-00070">  Any given element of the <code>pCommandBuffers</code> member of any element of <code>pSubmits</code> <strong>must</strong> be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending or executable state</a>. </li> <li id="VUID-vkQueueSubmit-pCommandBuffers-00071">  If any given element of the <code>pCommandBuffers</code> member of any element of <code>pSubmits</code> was not recorded with the <code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code>, it <strong>must</strong> not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>. </li> <li id="VUID-vkQueueSubmit-pCommandBuffers-00072">  Any <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-secondary">secondary command buffers recorded</a> into any given element of the <code>pCommandBuffers</code> member of any element of <code>pSubmits</code> <strong>must</strong> be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending or executable state</a>. </li> <li id="VUID-vkQueueSubmit-pCommandBuffers-00073">  If any <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-secondary">secondary command buffers recorded</a> into any given element of the <code>pCommandBuffers</code> member of any element of <code>pSubmits</code> was not recorded with the <code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code>, it <strong>must</strong> not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>. </li> <li id="VUID-vkQueueSubmit-pCommandBuffers-00074">  Any given element of the <code>pCommandBuffers</code> member of any element of <code>pSubmits</code> <strong>must</strong> have been allocated from a <code>VkCommandPool</code> that was created for the same queue family <code>queue</code> belongs to. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkQueueSubmit-queue-parameter">  <code>queue</code> <strong>must</strong> be a valid <code>VkQueue</code> handle </li> <li id="VUID-vkQueueSubmit-pSubmits-parameter">  If <code>submitCount</code> is not <code>0</code>, <code>pSubmits</code> <strong>must</strong> be a pointer to an array of <code>submitCount</code> valid <code>VkSubmitInfo</code> structures </li> <li id="VUID-vkQueueSubmit-fence-parameter">  If <code>fence</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>fence</code> <strong>must</strong> be a valid <code>VkFence</code> handle </li> <li id="VUID-vkQueueSubmit-commonparent">  Both of <code>fence</code>, and <code>queue</code> that are valid handles <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>queue</code> <strong>must</strong> be externally synchronized </li> <li> Host access to <code>pSubmits</code>[].pWaitSemaphores[] <strong>must</strong> be externally synchronized </li> <li> Host access to <code>pSubmits</code>[].pSignalSemaphores[] <strong>must</strong> be externally synchronized </li> <li> Host access to <code>fence</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td> </tr> </tbody> </table></div>  </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_DEVICE_LOST</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_127">See Also</h4>  <p><a href="#VkFence">VkFence</a>, <a href="#VkQueue">VkQueue</a>, <a href="#VkSubmitInfo">VkSubmitInfo</a></p>    <h4 id="_document_notes_127">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkQueueSubmit">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkQueueSubmit</a></p>         <h3 id="_vkqueuewaitidle_3">vkQueueWaitIdle(3)</h3>  <h4 id="_name_128">Name</h4>  <p>vkQueueWaitIdle - Wait for a queue to become idle</p>    <h4 id="_c_specification_128">C Specification</h4>  <p>To wait on the host for the completion of outstanding queue operations for a given queue, call:</p>  <pre id="vkQueueWaitIdle" data-language="c++">VkResult vkQueueWaitIdle(
    VkQueue                                     queue);</pre>   <h4 id="_parameters_128">Parameters</h4>  <ul> <li> <code>queue</code> is the queue on which to wait. </li> </ul>    <h4 id="_description_128">Description</h4>  <p><code>vkQueueWaitIdle</code> is equivalent to submitting a fence to a queue and waiting with an infinite timeout for that fence to signal.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkQueueWaitIdle-queue-parameter">  <code>queue</code> <strong>must</strong> be a valid <code>VkQueue</code> handle </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Command Properties</h5> <div class="_table"><table class="tableblock frame-all grid-all spread"> <colgroup> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkCommandBufferLevel">Command Buffer Levels</a></th> <th class="tableblock halign-left valign-top"><a href="#vkCmdBeginRenderPass">Render Pass Scope</a></th> <th class="tableblock halign-left valign-top"><a href="#VkQueueFlagBits">Supported Queue Types</a></th> <th class="tableblock halign-left valign-top"><a href="#synchronization-pipeline-stages-types">Pipeline Type</a></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td> </tr> </tbody> </table></div>  </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_DEVICE_LOST</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_128">See Also</h4>  <p><a href="#VkQueue">VkQueue</a></p>    <h4 id="_document_notes_128">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkQueueWaitIdle">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkQueueWaitIdle</a></p>         <h3 id="_vkresetcommandbuffer_3">vkResetCommandBuffer(3)</h3>  <h4 id="_name_129">Name</h4>  <p>vkResetCommandBuffer - Reset a command buffer to the initial state</p>    <h4 id="_c_specification_129">C Specification</h4>  <p>To reset command buffers, call:</p>  <pre id="vkResetCommandBuffer" data-language="c++">VkResult vkResetCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferResetFlags                   flags);</pre>   <h4 id="_parameters_129">Parameters</h4>  <ul> <li> <code>commandBuffer</code> is the command buffer to reset. The command buffer <strong>can</strong> be in any state other than <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending</a>, and is moved into the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">initial state</a>. </li> <li> <code>flags</code> is a bitmask of <a href="#VkCommandBufferResetFlagBits">VkCommandBufferResetFlagBits</a> controlling the reset operation. </li> </ul>    <h4 id="_description_129">Description</h4>  <p>Any primary command buffer that is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or executable state</a> and has <code>commandBuffer</code> recorded into it, becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkResetCommandBuffer-commandBuffer-00045">  <code>commandBuffer</code> <strong>must</strong> not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a> </li> <li id="VUID-vkResetCommandBuffer-commandBuffer-00046">  <code>commandBuffer</code> <strong>must</strong> have been allocated from a pool that was created with the <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkResetCommandBuffer-commandBuffer-parameter">  <code>commandBuffer</code> <strong>must</strong> be a valid <code>VkCommandBuffer</code> handle </li> <li id="VUID-vkResetCommandBuffer-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkCommandBufferResetFlagBits">VkCommandBufferResetFlagBits</a> values </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandBuffer</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_129">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkCommandBufferResetFlags">VkCommandBufferResetFlags</a></p>    <h4 id="_document_notes_129">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkResetCommandBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkResetCommandBuffer</a></p>         <h3 id="_vkresetcommandpool_3">vkResetCommandPool(3)</h3>  <h4 id="_name_130">Name</h4>  <p>vkResetCommandPool - Reset a command pool</p>    <h4 id="_c_specification_130">C Specification</h4>  <p>To reset a command pool, call:</p>  <pre id="vkResetCommandPool" data-language="c++">VkResult vkResetCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolResetFlags                     flags);</pre>   <h4 id="_parameters_130">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the command pool. </li> <li> <code>commandPool</code> is the command pool to reset. </li> <li> <code>flags</code> is a bitmask of <a href="#VkCommandPoolResetFlagBits">VkCommandPoolResetFlagBits</a> controlling the reset operation. </li> </ul>    <h4 id="_description_130">Description</h4>  <p>Resetting a command pool recycles all of the resources from all of the command buffers allocated from the command pool back to the command pool. All command buffers that have been allocated from the command pool are put in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">initial state</a>.</p>   <p>Any primary command buffer allocated from another <a href="#VkCommandPool">VkCommandPool</a> that is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or executable state</a> and has a secondary command buffer allocated from <code>commandPool</code> recorded into it, becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkResetCommandPool-commandPool-00040">  All <code>VkCommandBuffer</code> objects allocated from <code>commandPool</code> <strong>must</strong> not be in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkResetCommandPool-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkResetCommandPool-commandPool-parameter">  <code>commandPool</code> <strong>must</strong> be a valid <code>VkCommandPool</code> handle </li> <li id="VUID-vkResetCommandPool-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkCommandPoolResetFlagBits">VkCommandPoolResetFlagBits</a> values </li> <li id="VUID-vkResetCommandPool-commandPool-parent">  <code>commandPool</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>commandPool</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_130">See Also</h4>  <p><a href="#VkCommandPool">VkCommandPool</a>, <a href="#VkCommandPoolResetFlags">VkCommandPoolResetFlags</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_130">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkResetCommandPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkResetCommandPool</a></p>         <h3 id="_vkresetdescriptorpool_3">vkResetDescriptorPool(3)</h3>  <h4 id="_name_131">Name</h4>  <p>vkResetDescriptorPool - Resets a descriptor pool object</p>    <h4 id="_c_specification_131">C Specification</h4>  <p>To return all descriptor sets allocated from a given pool to the pool, rather than freeing individual descriptor sets, call:</p>  <pre id="vkResetDescriptorPool" data-language="c++">VkResult vkResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags);</pre>   <h4 id="_parameters_131">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the descriptor pool. </li> <li> <code>descriptorPool</code> is the descriptor pool to be reset. </li> <li> <code>flags</code> is reserved for future use. </li> </ul>    <h4 id="_description_131">Description</h4>  <p>Resetting a descriptor pool recycles all of the resources from all of the descriptor sets allocated from the descriptor pool back to the descriptor pool, and the descriptor sets are implicitly freed.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkResetDescriptorPool-descriptorPool-00313">  All uses of <code>descriptorPool</code> (via any allocated descriptor sets) <strong>must</strong> have completed execution </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkResetDescriptorPool-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkResetDescriptorPool-descriptorPool-parameter">  <code>descriptorPool</code> <strong>must</strong> be a valid <code>VkDescriptorPool</code> handle </li> <li id="VUID-vkResetDescriptorPool-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-vkResetDescriptorPool-descriptorPool-parent">  <code>descriptorPool</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>descriptorPool</code> <strong>must</strong> be externally synchronized </li> <li> Host access to any <code>VkDescriptorSet</code> objects allocated from <code>descriptorPool</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_131">See Also</h4>  <p><a href="#VkDescriptorPool">VkDescriptorPool</a>, <a href="#VkDescriptorPoolResetFlags">VkDescriptorPoolResetFlags</a>, <a href="#VkDevice">VkDevice</a></p>    <h4 id="_document_notes_131">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkResetDescriptorPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkResetDescriptorPool</a></p>         <h3 id="_vkresetevent_3">vkResetEvent(3)</h3>  <h4 id="_name_132">Name</h4>  <p>vkResetEvent - Reset an event to non-signaled state</p>    <h4 id="_c_specification_132">C Specification</h4>  <p>To set the state of an event to unsignaled from the host, call:</p>  <pre id="vkResetEvent" data-language="c++">VkResult vkResetEvent(
    VkDevice                                    device,
    VkEvent                                     event);</pre>   <h4 id="_parameters_132">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the event. </li> <li> <code>event</code> is the event to reset. </li> </ul>    <h4 id="_description_132">Description</h4>  <p>When <a href="#vkResetEvent">vkResetEvent</a> is executed on the host, it defines an <em>event unsignal operation</em> which resets the event to the unsignaled state.</p>   <p>If <code>event</code> is already in the unsignaled state when <a href="#vkResetEvent">vkResetEvent</a> is executed, then <a href="#vkResetEvent">vkResetEvent</a> has no effect, and no event unsignal operation occurs.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkResetEvent-event-01148">  <code>event</code> <strong>must</strong> not be waited on by a <code>vkCmdWaitEvents</code> command that is currently executing </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkResetEvent-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkResetEvent-event-parameter">  <code>event</code> <strong>must</strong> be a valid <code>VkEvent</code> handle </li> <li id="VUID-vkResetEvent-event-parent">  <code>event</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>event</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_132">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkEvent">VkEvent</a></p>    <h4 id="_document_notes_132">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkResetEvent">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkResetEvent</a></p>         <h3 id="_vkresetfences_3">vkResetFences(3)</h3>  <h4 id="_name_133">Name</h4>  <p>vkResetFences - Resets one or more fence objects</p>    <h4 id="_c_specification_133">C Specification</h4>  <p>To set the state of fences to unsignaled from the host, call:</p>  <pre id="vkResetFences" data-language="c++">VkResult vkResetFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences);</pre>   <h4 id="_parameters_133">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the fences. </li> <li> <code>fenceCount</code> is the number of fences to reset. </li> <li> <code>pFences</code> is a pointer to an array of fence handles to reset. </li> </ul>    <h4 id="_description_133">Description</h4>  <p>When <a href="#vkResetFences">vkResetFences</a> is executed on the host, it defines a <em>fence unsignal operation</em> for each fence, which resets the fence to the unsignaled state.</p>   <p>If any member of <code>pFences</code> is already in the unsignaled state when <a href="#vkResetFences">vkResetFences</a> is executed, then <a href="#vkResetFences">vkResetFences</a> has no effect on that fence.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkResetFences-pFences-01123">  Any given element of <code>pFences</code> <strong>must</strong> not currently be associated with any queue command that has not yet completed execution on that queue </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkResetFences-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkResetFences-pFences-parameter">  <code>pFences</code> <strong>must</strong> be a pointer to an array of <code>fenceCount</code> valid <code>VkFence</code> handles </li> <li id="VUID-vkResetFences-fenceCount-arraylength">  <code>fenceCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkResetFences-pFences-parent">  Each element of <code>pFences</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to each member of <code>pFences</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_133">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkFence">VkFence</a></p>    <h4 id="_document_notes_133">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkResetFences">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkResetFences</a></p>         <h3 id="_vksetevent_3">vkSetEvent(3)</h3>  <h4 id="_name_134">Name</h4>  <p>vkSetEvent - Set an event to signaled state</p>    <h4 id="_c_specification_134">C Specification</h4>  <p>To set the state of an event to signaled from the host, call:</p>  <pre id="vkSetEvent" data-language="c++">VkResult vkSetEvent(
    VkDevice                                    device,
    VkEvent                                     event);</pre>   <h4 id="_parameters_134">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the event. </li> <li> <code>event</code> is the event to set. </li> </ul>    <h4 id="_description_134">Description</h4>  <p>When <a href="#vkSetEvent">vkSetEvent</a> is executed on the host, it defines an <em>event signal operation</em> which sets the event to the signaled state.</p>   <p>If <code>event</code> is already in the signaled state when <a href="#vkSetEvent">vkSetEvent</a> is executed, then <a href="#vkSetEvent">vkSetEvent</a> has no effect, and no event signal operation occurs.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkSetEvent-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkSetEvent-event-parameter">  <code>event</code> <strong>must</strong> be a valid <code>VkEvent</code> handle </li> <li id="VUID-vkSetEvent-event-parent">  <code>event</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>event</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_134">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkEvent">VkEvent</a></p>    <h4 id="_document_notes_134">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkSetEvent">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkSetEvent</a></p>         <h3 id="_vkunmapmemory_3">vkUnmapMemory(3)</h3>  <h4 id="_name_135">Name</h4>  <p>vkUnmapMemory - Unmap a previously mapped memory object</p>    <h4 id="_c_specification_135">C Specification</h4>  <p>To unmap a memory object once host access to it is no longer needed by the application, call:</p>  <pre id="vkUnmapMemory" data-language="c++">void vkUnmapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory);</pre>   <h4 id="_parameters_135">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the memory. </li> <li> <code>memory</code> is the memory object to be unmapped. </li> </ul>    <h4 id="_description_135">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkUnmapMemory-memory-00689">  <code>memory</code> <strong>must</strong> currently be mapped </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkUnmapMemory-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkUnmapMemory-memory-parameter">  <code>memory</code> <strong>must</strong> be a valid <code>VkDeviceMemory</code> handle </li> <li id="VUID-vkUnmapMemory-memory-parent">  <code>memory</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>memory</code> <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_135">See Also</h4>  <p><a href="#VkDevice">VkDevice</a>, <a href="#VkDeviceMemory">VkDeviceMemory</a></p>    <h4 id="_document_notes_135">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkUnmapMemory">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkUnmapMemory</a></p>         <h3 id="_vkupdatedescriptorsets_3">vkUpdateDescriptorSets(3)</h3>  <h4 id="_name_136">Name</h4>  <p>vkUpdateDescriptorSets - Update the contents of a descriptor set object</p>    <h4 id="_c_specification_136">C Specification</h4>  <p>Once allocated, descriptor sets <strong>can</strong> be updated with a combination of write and copy operations. To update descriptor sets, call:</p>  <pre id="vkUpdateDescriptorSets" data-language="c++">void vkUpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    const VkCopyDescriptorSet*                  pDescriptorCopies);</pre>   <h4 id="_parameters_136">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that updates the descriptor sets. </li> <li> <code>descriptorWriteCount</code> is the number of elements in the <code>pDescriptorWrites</code> array. </li> <li> <code>pDescriptorWrites</code> is a pointer to an array of <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> structures describing the descriptor sets to write to. </li> <li> <code>descriptorCopyCount</code> is the number of elements in the <code>pDescriptorCopies</code> array. </li> <li> <code>pDescriptorCopies</code> is a pointer to an array of <a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a> structures describing the descriptor sets to copy between. </li> </ul>    <h4 id="_description_136">Description</h4>  <p>The operations described by <code>pDescriptorWrites</code> are performed first, followed by the operations described by <code>pDescriptorCopies</code>. Within each array, the operations are performed in the order they appear in the array.</p>   <p>Each element in the <code>pDescriptorWrites</code> array describes an operation updating the descriptor set using descriptors for resources specified in the structure.</p>   <p>Each element in the <code>pDescriptorCopies</code> array is a <a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a> structure describing an operation copying descriptors between sets.</p>   <p>If the <code>dstSet</code> member of any given element of <code>pDescriptorWrites</code> or <code>pDescriptorCopies</code> is bound, accessed, or modified by any command that was recorded to a command buffer which is currently in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">recording or executable state</a>, that command buffer becomes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">invalid</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-vkUpdateDescriptorSets-dstSet-00314">  The <code>dstSet</code> member of any given element of <code>pDescriptorWrites</code> or <code>pDescriptorCopies</code> <strong>must</strong> not be used by any command that was recorded to a command buffer which is in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">pending state</a>. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkUpdateDescriptorSets-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter">  If <code>descriptorWriteCount</code> is not <code>0</code>, <code>pDescriptorWrites</code> <strong>must</strong> be a pointer to an array of <code>descriptorWriteCount</code> valid <code>VkWriteDescriptorSet</code> structures </li> <li id="VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter">  If <code>descriptorCopyCount</code> is not <code>0</code>, <code>pDescriptorCopies</code> <strong>must</strong> be a pointer to an array of <code>descriptorCopyCount</code> valid <code>VkCopyDescriptorSet</code> structures </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Host Synchronization</h5>  <ul> <li> Host access to <code>pDescriptorWrites</code>[].dstSet <strong>must</strong> be externally synchronized </li> <li> Host access to <code>pDescriptorCopies</code>[].dstSet <strong>must</strong> be externally synchronized </li> </ul>   </blockquote>   <h4 id="_see_also_136">See Also</h4>  <p><a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a></p>    <h4 id="_document_notes_136">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkUpdateDescriptorSets">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkUpdateDescriptorSets</a></p>         <h3 id="_vkwaitforfences_3">vkWaitForFences(3)</h3>  <h4 id="_name_137">Name</h4>  <p>vkWaitForFences - Wait for one or more fences to become signaled</p>    <h4 id="_c_specification_137">C Specification</h4>  <p>To wait for one or more fences to enter the signaled state on the host, call:</p>  <pre id="vkWaitForFences" data-language="c++">VkResult vkWaitForFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout);</pre>   <h4 id="_parameters_137">Parameters</h4>  <ul> <li> <code>device</code> is the logical device that owns the fences. </li> <li> <code>fenceCount</code> is the number of fences to wait on. </li> <li> <code>pFences</code> is a pointer to an array of <code>fenceCount</code> fence handles. </li> <li> <code>waitAll</code> is the condition that <strong>must</strong> be satisfied to successfully unblock the wait. If <code>waitAll</code> is <code>VK_TRUE</code>, then the condition is that all fences in <code>pFences</code> are signaled. Otherwise, the condition is that at least one fence in <code>pFences</code> is signaled. </li> <li> <code>timeout</code> is the timeout period in units of nanoseconds. <code>timeout</code> is adjusted to the closest value allowed by the implementation-dependent timeout accuracy, which <strong>may</strong> be substantially longer than one nanosecond, and <strong>may</strong> be longer than the requested period. </li> </ul>    <h4 id="_description_137">Description</h4>  <p>If the condition is satisfied when <code>vkWaitForFences</code> is called, then <code>vkWaitForFences</code> returns immediately. If the condition is not satisfied at the time <code>vkWaitForFences</code> is called, then <code>vkWaitForFences</code> will block and wait up to <code>timeout</code> nanoseconds for the condition to become satisfied.</p>   <p>If <code>timeout</code> is zero, then <code>vkWaitForFences</code> does not wait, but simply returns the current state of the fences. <code>VK_TIMEOUT</code> will be returned in this case if the condition is not satisfied, even though no actual wait was performed.</p>   <p>If the specified timeout period expires before the condition is satisfied, <code>vkWaitForFences</code> returns <code>VK_TIMEOUT</code>. If the condition is satisfied before <code>timeout</code> nanoseconds has expired, <code>vkWaitForFences</code> returns <code>VK_SUCCESS</code>.</p>   <p>If device loss occurs (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device">Lost Device</a>) before the timeout has expired, <code>vkWaitForFences</code> <strong>must</strong> return in finite time with either <code>VK_SUCCESS</code> or <code>VK_DEVICE_LOST</code>.</p>  <blockquote> <h5 class="title">Note</h5>  <p>While we guarantee that <code>vkWaitForFences</code> <strong>must</strong> return in finite time, no guarantees are made that it returns immediately upon device loss. However, the client can reasonably expect that the delay will be on the order of seconds and that calling <code>vkWaitForFences</code> will not result in a permanently (or seemingly permanently) dead process.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-vkWaitForFences-device-parameter">  <code>device</code> <strong>must</strong> be a valid <code>VkDevice</code> handle </li> <li id="VUID-vkWaitForFences-pFences-parameter">  <code>pFences</code> <strong>must</strong> be a pointer to an array of <code>fenceCount</code> valid <code>VkFence</code> handles </li> <li id="VUID-vkWaitForFences-fenceCount-arraylength">  <code>fenceCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-vkWaitForFences-pFences-parent">  Each element of <code>pFences</code> <strong>must</strong> have been created, allocated, or retrieved from <code>device</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Return Codes</h5>  <dl> <dt><a href="#fundamentals-successcodes">Success</a></dt> <dd>  <ul> <li> <code>VK_SUCCESS</code> </li> <li> <code>VK_TIMEOUT</code> </li> </ul>  </dd> <dt><a href="#fundamentals-errorcodes">Failure</a></dt> <dd>  <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> </li> <li> <code>VK_ERROR_DEVICE_LOST</code> </li> </ul>  </dd> </dl>   </blockquote>   <h4 id="_see_also_137">See Also</h4>  <p><code>VkBool32</code>, <a href="#VkDevice">VkDevice</a>, <a href="#VkFence">VkFence</a></p>    <h4 id="_document_notes_137">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkWaitForFences">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkWaitForFences</a></p>           <h2 id="handles">Object Handles</h2>   <h3 id="_vkbuffer_3">VkBuffer(3)</h3>  <h4 id="_name_138">Name</h4>  <p>VkBuffer - Opaque handle to a buffer object</p>    <h4 id="_c_specification_138">C Specification</h4>  <p>Buffers represent linear arrays of data which are used for various purposes by binding them to a graphics or compute pipeline via descriptor sets or via certain commands, or by directly specifying them as parameters to certain commands.</p>   <p>Buffers are represented by <code>VkBuffer</code> handles:</p>  <pre id="VkBuffer" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)</pre>      <h4 id="_see_also_138">See Also</h4>  <p><a href="#VkBufferMemoryBarrier">VkBufferMemoryBarrier</a>, <a href="#VkBufferViewCreateInfo">VkBufferViewCreateInfo</a>, <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a>, <a href="#VkSparseBufferMemoryBindInfo">VkSparseBufferMemoryBindInfo</a>, <a href="#vkBindBufferMemory">vkBindBufferMemory</a>, <a href="#vkCmdBindIndexBuffer">vkCmdBindIndexBuffer</a>, <a href="#vkCmdBindVertexBuffers">vkCmdBindVertexBuffers</a>, <a href="#vkCmdCopyBuffer">vkCmdCopyBuffer</a>, <a href="#vkCmdCopyBufferToImage">vkCmdCopyBufferToImage</a>, <a href="#vkCmdCopyImageToBuffer">vkCmdCopyImageToBuffer</a>, <a href="#vkCmdCopyQueryPoolResults">vkCmdCopyQueryPoolResults</a>, <a href="#vkCmdDispatchIndirect">vkCmdDispatchIndirect</a>, <a href="#vkCmdDrawIndexedIndirect">vkCmdDrawIndexedIndirect</a>, <a href="#vkCmdDrawIndirect">vkCmdDrawIndirect</a>, <a href="#vkCmdFillBuffer">vkCmdFillBuffer</a>, <a href="#vkCmdUpdateBuffer">vkCmdUpdateBuffer</a>, <a href="#vkCreateBuffer">vkCreateBuffer</a>, <a href="#vkDestroyBuffer">vkDestroyBuffer</a>, <a href="#vkGetBufferMemoryRequirements">vkGetBufferMemoryRequirements</a></p>    <h4 id="_document_notes_138">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBuffer</a></p>         <h3 id="_vkbufferview_3">VkBufferView(3)</h3>  <h4 id="_name_139">Name</h4>  <p>VkBufferView - Opaque handle to a buffer view object</p>    <h4 id="_c_specification_139">C Specification</h4>  <p>A <em>buffer view</em> represents a contiguous range of a buffer and a specific format to be used to interpret the data. Buffer views are used to enable shaders to access buffer contents interpreted as formatted data. In order to create a valid buffer view, the buffer <strong>must</strong> have been created with at least one of the following usage flags:</p>   <ul> <li> <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> </li> <li> <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code> </li> </ul>   <p>Buffer views are represented by <code>VkBufferView</code> handles:</p>  <pre id="VkBufferView" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)</pre>      <h4 id="_see_also_139">See Also</h4>  <p><a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>, <a href="#vkCreateBufferView">vkCreateBufferView</a>, <a href="#vkDestroyBufferView">vkDestroyBufferView</a></p>    <h4 id="_document_notes_139">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferView">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferView</a></p>         <h3 id="_vkcommandbuffer_3">VkCommandBuffer(3)</h3>  <h4 id="_name_140">Name</h4>  <p>VkCommandBuffer - Opaque handle to a command buffer object</p>    <h4 id="_c_specification_140">C Specification</h4>  <p>Command buffers are objects used to record commands which <strong>can</strong> be subsequently submitted to a device queue for execution. There are two levels of command buffers - <em>primary command buffers</em>, which <strong>can</strong> execute secondary command buffers, and which are submitted to queues, and <em>secondary command buffers</em>, which <strong>can</strong> be executed by primary command buffers, and which are not directly submitted to queues.</p>   <p>Command buffers are represented by <code>VkCommandBuffer</code> handles:</p>  <pre id="VkCommandBuffer" data-language="c++">VK_DEFINE_HANDLE(VkCommandBuffer)</pre>      <h4 id="_see_also_140">See Also</h4>  <p><a href="#VkSubmitInfo">VkSubmitInfo</a>, <a href="#vkAllocateCommandBuffers">vkAllocateCommandBuffers</a>, <a href="#vkBeginCommandBuffer">vkBeginCommandBuffer</a>, <a href="#vkCmdBeginQuery">vkCmdBeginQuery</a>, <a href="#vkCmdBeginRenderPass">vkCmdBeginRenderPass</a>, <a href="#vkCmdBindDescriptorSets">vkCmdBindDescriptorSets</a>, <a href="#vkCmdBindIndexBuffer">vkCmdBindIndexBuffer</a>, <a href="#vkCmdBindPipeline">vkCmdBindPipeline</a>, <a href="#vkCmdBindVertexBuffers">vkCmdBindVertexBuffers</a>, <a href="#vkCmdBlitImage">vkCmdBlitImage</a>, <a href="#vkCmdClearAttachments">vkCmdClearAttachments</a>, <a href="#vkCmdClearColorImage">vkCmdClearColorImage</a>, <a href="#vkCmdClearDepthStencilImage">vkCmdClearDepthStencilImage</a>, <a href="#vkCmdCopyBuffer">vkCmdCopyBuffer</a>, <a href="#vkCmdCopyBufferToImage">vkCmdCopyBufferToImage</a>, <a href="#vkCmdCopyImage">vkCmdCopyImage</a>, <a href="#vkCmdCopyImageToBuffer">vkCmdCopyImageToBuffer</a>, <a href="#vkCmdCopyQueryPoolResults">vkCmdCopyQueryPoolResults</a>, <a href="#vkCmdDispatch">vkCmdDispatch</a>, <a href="#vkCmdDispatchIndirect">vkCmdDispatchIndirect</a>, <a href="#vkCmdDraw">vkCmdDraw</a>, <a href="#vkCmdDrawIndexed">vkCmdDrawIndexed</a>, <a href="#vkCmdDrawIndexedIndirect">vkCmdDrawIndexedIndirect</a>, <a href="#vkCmdDrawIndirect">vkCmdDrawIndirect</a>, <a href="#vkCmdEndQuery">vkCmdEndQuery</a>, <a href="#vkCmdEndRenderPass">vkCmdEndRenderPass</a>, <a href="#vkCmdExecuteCommands">vkCmdExecuteCommands</a>, <a href="#vkCmdFillBuffer">vkCmdFillBuffer</a>, <a href="#vkCmdNextSubpass">vkCmdNextSubpass</a>, <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a>, <a href="#vkCmdPushConstants">vkCmdPushConstants</a>, <a href="#vkCmdResetEvent">vkCmdResetEvent</a>, <a href="#vkCmdResetQueryPool">vkCmdResetQueryPool</a>, <a href="#vkCmdResolveImage">vkCmdResolveImage</a>, <a href="#vkCmdSetBlendConstants">vkCmdSetBlendConstants</a>, <a href="#vkCmdSetDepthBias">vkCmdSetDepthBias</a>, <a href="#vkCmdSetDepthBounds">vkCmdSetDepthBounds</a>, <a href="#vkCmdSetEvent">vkCmdSetEvent</a>, <a href="#vkCmdSetLineWidth">vkCmdSetLineWidth</a>, <a href="#vkCmdSetScissor">vkCmdSetScissor</a>, <a href="#vkCmdSetStencilCompareMask">vkCmdSetStencilCompareMask</a>, <a href="#vkCmdSetStencilReference">vkCmdSetStencilReference</a>, <a href="#vkCmdSetStencilWriteMask">vkCmdSetStencilWriteMask</a>, <a href="#vkCmdSetViewport">vkCmdSetViewport</a>, <a href="#vkCmdUpdateBuffer">vkCmdUpdateBuffer</a>, <a href="#vkCmdWaitEvents">vkCmdWaitEvents</a>, <a href="#vkCmdWriteTimestamp">vkCmdWriteTimestamp</a>, <a href="#vkEndCommandBuffer">vkEndCommandBuffer</a>, <a href="#vkFreeCommandBuffers">vkFreeCommandBuffers</a>, <a href="#vkResetCommandBuffer">vkResetCommandBuffer</a></p>    <h4 id="_document_notes_140">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBuffer</a></p>         <h3 id="_vkcommandpool_3">VkCommandPool(3)</h3>  <h4 id="_name_141">Name</h4>  <p>VkCommandPool - Opaque handle to a command pool object</p>    <h4 id="_c_specification_141">C Specification</h4>  <p>Command pools are opaque objects that command buffer memory is allocated from, and which allow the implementation to amortize the cost of resource creation across multiple command buffers. Command pools are externally synchronized, meaning that a command pool <strong>must</strong> not be used concurrently in multiple threads. That includes use via recording commands on any command buffers allocated from the pool, as well as operations that allocate, free, and reset command buffers or the pool itself.</p>   <p>Command pools are represented by <code>VkCommandPool</code> handles:</p>  <pre id="VkCommandPool" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)</pre>      <h4 id="_see_also_141">See Also</h4>  <p><a href="#VkCommandBufferAllocateInfo">VkCommandBufferAllocateInfo</a>, <a href="#vkCreateCommandPool">vkCreateCommandPool</a>, <a href="#vkDestroyCommandPool">vkDestroyCommandPool</a>, <a href="#vkFreeCommandBuffers">vkFreeCommandBuffers</a>, <a href="#vkResetCommandPool">vkResetCommandPool</a></p>    <h4 id="_document_notes_141">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPool</a></p>         <h3 id="_vkdescriptorpool_3">VkDescriptorPool(3)</h3>  <h4 id="_name_142">Name</h4>  <p>VkDescriptorPool - Opaque handle to a descriptor pool object</p>    <h4 id="_c_specification_142">C Specification</h4>  <p>A <em>descriptor pool</em> maintains a pool of descriptors, from which descriptor sets are allocated. Descriptor pools are externally synchronized, meaning that the application <strong>must</strong> not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.</p>   <p>Descriptor pools are represented by <code>VkDescriptorPool</code> handles:</p>  <pre id="VkDescriptorPool" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)</pre>      <h4 id="_see_also_142">See Also</h4>  <p><a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a>, <a href="#vkCreateDescriptorPool">vkCreateDescriptorPool</a>, <a href="#vkDestroyDescriptorPool">vkDestroyDescriptorPool</a>, <a href="#vkFreeDescriptorSets">vkFreeDescriptorSets</a>, <a href="#vkResetDescriptorPool">vkResetDescriptorPool</a></p>    <h4 id="_document_notes_142">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPool</a></p>         <h3 id="_vkdescriptorset_3">VkDescriptorSet(3)</h3>  <h4 id="_name_143">Name</h4>  <p>VkDescriptorSet - Opaque handle to a descriptor set object</p>    <h4 id="_c_specification_143">C Specification</h4>  <p>Descriptor sets are allocated from descriptor pool objects, and are represented by <code>VkDescriptorSet</code> handles:</p>  <pre id="VkDescriptorSet" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)</pre>      <h4 id="_see_also_143">See Also</h4>  <p><a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a>, <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>, <a href="#vkAllocateDescriptorSets">vkAllocateDescriptorSets</a>, <a href="#vkCmdBindDescriptorSets">vkCmdBindDescriptorSets</a>, <a href="#vkFreeDescriptorSets">vkFreeDescriptorSets</a></p>    <h4 id="_document_notes_143">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSet">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSet</a></p>         <h3 id="_vkdescriptorsetlayout_3">VkDescriptorSetLayout(3)</h3>  <h4 id="_name_144">Name</h4>  <p>VkDescriptorSetLayout - Opaque handle to a descriptor set layout object</p>    <h4 id="_c_specification_144">C Specification</h4>  <p>A descriptor set layout object is defined by an array of zero or more descriptor bindings. Each individual descriptor binding is specified by a descriptor type, a count (array size) of the number of descriptors in the binding, a set of shader stages that <strong>can</strong> access the binding, and (if using immutable samplers) an array of sampler descriptors.</p>   <p>Descriptor set layout objects are represented by <code>VkDescriptorSetLayout</code> handles:</p>  <pre id="VkDescriptorSetLayout" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)</pre>      <h4 id="_see_also_144">See Also</h4>  <p><a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a>, <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a>, <a href="#vkCreateDescriptorSetLayout">vkCreateDescriptorSetLayout</a>, <a href="#vkDestroyDescriptorSetLayout">vkDestroyDescriptorSetLayout</a></p>    <h4 id="_document_notes_144">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetLayout">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetLayout</a></p>         <h3 id="_vkdevice_3">VkDevice(3)</h3>  <h4 id="_name_145">Name</h4>  <p>VkDevice - Opaque handle to a device object</p>    <h4 id="_c_specification_145">C Specification</h4>  <p>Logical devices are represented by <code>VkDevice</code> handles:</p>  <pre id="VkDevice" data-language="c++">VK_DEFINE_HANDLE(VkDevice)</pre>      <h4 id="_see_also_145">See Also</h4>  <p><a href="#vkAllocateCommandBuffers">vkAllocateCommandBuffers</a>, <a href="#vkAllocateDescriptorSets">vkAllocateDescriptorSets</a>, <a href="#vkAllocateMemory">vkAllocateMemory</a>, <a href="#vkBindBufferMemory">vkBindBufferMemory</a>, <a href="#vkBindImageMemory">vkBindImageMemory</a>, <a href="#vkCreateBuffer">vkCreateBuffer</a>, <a href="#vkCreateBufferView">vkCreateBufferView</a>, <a href="#vkCreateCommandPool">vkCreateCommandPool</a>, <a href="#vkCreateComputePipelines">vkCreateComputePipelines</a>, <a href="#vkCreateDescriptorPool">vkCreateDescriptorPool</a>, <a href="#vkCreateDescriptorSetLayout">vkCreateDescriptorSetLayout</a>, <a href="#vkCreateDevice">vkCreateDevice</a>, <a href="#vkCreateEvent">vkCreateEvent</a>, <a href="#vkCreateFence">vkCreateFence</a>, <a href="#vkCreateFramebuffer">vkCreateFramebuffer</a>, <a href="#vkCreateGraphicsPipelines">vkCreateGraphicsPipelines</a>, <a href="#vkCreateImage">vkCreateImage</a>, <a href="#vkCreateImageView">vkCreateImageView</a>, <a href="#vkCreatePipelineCache">vkCreatePipelineCache</a>, <a href="#vkCreatePipelineLayout">vkCreatePipelineLayout</a>, <a href="#vkCreateQueryPool">vkCreateQueryPool</a>, <a href="#vkCreateRenderPass">vkCreateRenderPass</a>, <a href="#vkCreateSampler">vkCreateSampler</a>, <a href="#vkCreateSemaphore">vkCreateSemaphore</a>, <a href="#vkCreateShaderModule">vkCreateShaderModule</a>, <a href="#vkDestroyBuffer">vkDestroyBuffer</a>, <a href="#vkDestroyBufferView">vkDestroyBufferView</a>, <a href="#vkDestroyCommandPool">vkDestroyCommandPool</a>, <a href="#vkDestroyDescriptorPool">vkDestroyDescriptorPool</a>, <a href="#vkDestroyDescriptorSetLayout">vkDestroyDescriptorSetLayout</a>, <a href="#vkDestroyDevice">vkDestroyDevice</a>, <a href="#vkDestroyEvent">vkDestroyEvent</a>, <a href="#vkDestroyFence">vkDestroyFence</a>, <a href="#vkDestroyFramebuffer">vkDestroyFramebuffer</a>, <a href="#vkDestroyImage">vkDestroyImage</a>, <a href="#vkDestroyImageView">vkDestroyImageView</a>, <a href="#vkDestroyPipeline">vkDestroyPipeline</a>, <a href="#vkDestroyPipelineCache">vkDestroyPipelineCache</a>, <a href="#vkDestroyPipelineLayout">vkDestroyPipelineLayout</a>, <a href="#vkDestroyQueryPool">vkDestroyQueryPool</a>, <a href="#vkDestroyRenderPass">vkDestroyRenderPass</a>, <a href="#vkDestroySampler">vkDestroySampler</a>, <a href="#vkDestroySemaphore">vkDestroySemaphore</a>, <a href="#vkDestroyShaderModule">vkDestroyShaderModule</a>, <a href="#vkDeviceWaitIdle">vkDeviceWaitIdle</a>, <a href="#vkFlushMappedMemoryRanges">vkFlushMappedMemoryRanges</a>, <a href="#vkFreeCommandBuffers">vkFreeCommandBuffers</a>, <a href="#vkFreeDescriptorSets">vkFreeDescriptorSets</a>, <a href="#vkFreeMemory">vkFreeMemory</a>, <a href="#vkGetBufferMemoryRequirements">vkGetBufferMemoryRequirements</a>, <a href="#vkGetDeviceMemoryCommitment">vkGetDeviceMemoryCommitment</a>, <a href="#vkGetDeviceProcAddr">vkGetDeviceProcAddr</a>, <a href="#vkGetDeviceQueue">vkGetDeviceQueue</a>, <a href="#vkGetEventStatus">vkGetEventStatus</a>, <a href="#vkGetFenceStatus">vkGetFenceStatus</a>, <a href="#vkGetImageMemoryRequirements">vkGetImageMemoryRequirements</a>, <a href="#vkGetImageSparseMemoryRequirements">vkGetImageSparseMemoryRequirements</a>, <a href="#vkGetImageSubresourceLayout">vkGetImageSubresourceLayout</a>, <a href="#vkGetPipelineCacheData">vkGetPipelineCacheData</a>, <a href="#vkGetQueryPoolResults">vkGetQueryPoolResults</a>, <a href="#vkGetRenderAreaGranularity">vkGetRenderAreaGranularity</a>, <a href="#vkInvalidateMappedMemoryRanges">vkInvalidateMappedMemoryRanges</a>, <a href="#vkMapMemory">vkMapMemory</a>, <a href="#vkMergePipelineCaches">vkMergePipelineCaches</a>, <a href="#vkResetCommandPool">vkResetCommandPool</a>, <a href="#vkResetDescriptorPool">vkResetDescriptorPool</a>, <a href="#vkResetEvent">vkResetEvent</a>, <a href="#vkResetFences">vkResetFences</a>, <a href="#vkSetEvent">vkSetEvent</a>, <a href="#vkUnmapMemory">vkUnmapMemory</a>, <a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a>, <a href="#vkWaitForFences">vkWaitForFences</a></p>    <h4 id="_document_notes_145">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDevice">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDevice</a></p>         <h3 id="_vkdevicememory_3">VkDeviceMemory(3)</h3>  <h4 id="_name_146">Name</h4>  <p>VkDeviceMemory - Opaque handle to a device memory object</p>    <h4 id="_c_specification_146">C Specification</h4>  <p>A Vulkan device operates on data in device memory via memory objects that are represented in the API by a <code>VkDeviceMemory</code> handle.</p>   <p>Memory objects are represented by <code>VkDeviceMemory</code> handles:</p>  <pre id="VkDeviceMemory" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)</pre>      <h4 id="_see_also_146">See Also</h4>  <p><a href="#VkMappedMemoryRange">VkMappedMemoryRange</a>, <a href="#VkSparseImageMemoryBind">VkSparseImageMemoryBind</a>, <a href="#VkSparseMemoryBind">VkSparseMemoryBind</a>, <a href="#vkAllocateMemory">vkAllocateMemory</a>, <a href="#vkBindBufferMemory">vkBindBufferMemory</a>, <a href="#vkBindImageMemory">vkBindImageMemory</a>, <a href="#vkFreeMemory">vkFreeMemory</a>, <a href="#vkGetDeviceMemoryCommitment">vkGetDeviceMemoryCommitment</a>, <a href="#vkMapMemory">vkMapMemory</a>, <a href="#vkUnmapMemory">vkUnmapMemory</a></p>    <h4 id="_document_notes_146">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceMemory">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceMemory</a></p>         <h3 id="_vkevent_3">VkEvent(3)</h3>  <h4 id="_name_147">Name</h4>  <p>VkEvent - Opaque handle to a event object</p>    <h4 id="_c_specification_147">C Specification</h4>  <p>Events are a synchronization primitive that <strong>can</strong> be used to insert a fine-grained dependency between commands submitted to the same queue, or between the host and a queue. Events have two states - signaled and unsignaled. An application <strong>can</strong> signal an event, or unsignal it, on either the host or the device. A device <strong>can</strong> wait for an event to become signaled before executing further operations. No command exists to wait for an event to become signaled on the host, but the current state of an event <strong>can</strong> be queried.</p>   <p>Events are represented by <code>VkEvent</code> handles:</p>  <pre id="VkEvent" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)</pre>      <h4 id="_see_also_147">See Also</h4>  <p><a href="#vkCmdResetEvent">vkCmdResetEvent</a>, <a href="#vkCmdSetEvent">vkCmdSetEvent</a>, <a href="#vkCmdWaitEvents">vkCmdWaitEvents</a>, <a href="#vkCreateEvent">vkCreateEvent</a>, <a href="#vkDestroyEvent">vkDestroyEvent</a>, <a href="#vkGetEventStatus">vkGetEventStatus</a>, <a href="#vkResetEvent">vkResetEvent</a>, <a href="#vkSetEvent">vkSetEvent</a></p>    <h4 id="_document_notes_147">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkEvent">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkEvent</a></p>         <h3 id="_vkfence_3">VkFence(3)</h3>  <h4 id="_name_148">Name</h4>  <p>VkFence - Opaque handle to a fence object</p>    <h4 id="_c_specification_148">C Specification</h4>  <p>Fences are a synchronization primitive that <strong>can</strong> be used to insert a dependency from a queue to the host. Fences have two states - signaled and unsignaled. A fence <strong>can</strong> be signaled as part of the execution of a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission">queue submission</a> command. Fences <strong>can</strong> be unsignaled on the host with <a href="#vkResetFences">vkResetFences</a>. Fences <strong>can</strong> be waited on by the host with the <a href="#vkWaitForFences">vkWaitForFences</a> command, and the current state <strong>can</strong> be queried with <a href="#vkGetFenceStatus">vkGetFenceStatus</a>.</p>   <p>Fences are represented by <code>VkFence</code> handles:</p>  <pre id="VkFence" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)</pre>      <h4 id="_see_also_148">See Also</h4>  <p><a href="#vkCreateFence">vkCreateFence</a>, <a href="#vkDestroyFence">vkDestroyFence</a>, <a href="#vkGetFenceStatus">vkGetFenceStatus</a>, <a href="#vkQueueBindSparse">vkQueueBindSparse</a>, <a href="#vkQueueSubmit">vkQueueSubmit</a>, <a href="#vkResetFences">vkResetFences</a>, <a href="#vkWaitForFences">vkWaitForFences</a></p>    <h4 id="_document_notes_148">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFence">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFence</a></p>         <h3 id="_vkframebuffer_3">VkFramebuffer(3)</h3>  <h4 id="_name_149">Name</h4>  <p>VkFramebuffer - Opaque handle to a framebuffer object</p>    <h4 id="_c_specification_149">C Specification</h4>  <p>Render passes operate in conjunction with <em>framebuffers</em>. Framebuffers represent a collection of specific memory attachments that a render pass instance uses.</p>   <p>Framebuffers are represented by <code>VkFramebuffer</code> handles:</p>  <pre id="VkFramebuffer" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)</pre>      <h4 id="_see_also_149">See Also</h4>  <p><a href="#VkCommandBufferInheritanceInfo">VkCommandBufferInheritanceInfo</a>, <a href="#VkRenderPassBeginInfo">VkRenderPassBeginInfo</a>, <a href="#vkCreateFramebuffer">vkCreateFramebuffer</a>, <a href="#vkDestroyFramebuffer">vkDestroyFramebuffer</a></p>    <h4 id="_document_notes_149">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFramebuffer">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFramebuffer</a></p>         <h3 id="_vkimage_3">VkImage(3)</h3>  <h4 id="_name_150">Name</h4>  <p>VkImage - Opaque handle to a image object</p>    <h4 id="_c_specification_150">C Specification</h4>  <p>Images represent multidimensional - up to 3 - arrays of data which <strong>can</strong> be used for various purposes (e.g. attachments, textures), by binding them to a graphics or compute pipeline via descriptor sets, or by directly specifying them as parameters to certain commands.</p>   <p>Images are represented by <code>VkImage</code> handles:</p>  <pre id="VkImage" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)</pre>      <h4 id="_see_also_150">See Also</h4>  <p><a href="#VkImageMemoryBarrier">VkImageMemoryBarrier</a>, <a href="#VkImageViewCreateInfo">VkImageViewCreateInfo</a>, <a href="#VkSparseImageMemoryBindInfo">VkSparseImageMemoryBindInfo</a>, <a href="#VkSparseImageOpaqueMemoryBindInfo">VkSparseImageOpaqueMemoryBindInfo</a>, <a href="#vkBindImageMemory">vkBindImageMemory</a>, <a href="#vkCmdBlitImage">vkCmdBlitImage</a>, <a href="#vkCmdClearColorImage">vkCmdClearColorImage</a>, <a href="#vkCmdClearDepthStencilImage">vkCmdClearDepthStencilImage</a>, <a href="#vkCmdCopyBufferToImage">vkCmdCopyBufferToImage</a>, <a href="#vkCmdCopyImage">vkCmdCopyImage</a>, <a href="#vkCmdCopyImageToBuffer">vkCmdCopyImageToBuffer</a>, <a href="#vkCmdResolveImage">vkCmdResolveImage</a>, <a href="#vkCreateImage">vkCreateImage</a>, <a href="#vkDestroyImage">vkDestroyImage</a>, <a href="#vkGetImageMemoryRequirements">vkGetImageMemoryRequirements</a>, <a href="#vkGetImageSparseMemoryRequirements">vkGetImageSparseMemoryRequirements</a>, <a href="#vkGetImageSubresourceLayout">vkGetImageSubresourceLayout</a></p>    <h4 id="_document_notes_150">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImage">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImage</a></p>         <h3 id="_vkimageview_3">VkImageView(3)</h3>  <h4 id="_name_151">Name</h4>  <p>VkImageView - Opaque handle to a image view object</p>    <h4 id="_c_specification_151">C Specification</h4>  <p>Image objects are not directly accessed by pipeline shaders for reading or writing image data. Instead, <em>image views</em> representing contiguous ranges of the image subresources and containing additional metadata are used for that purpose. Views <strong>must</strong> be created on images of compatible types, and <strong>must</strong> represent a valid subset of image subresources.</p>   <p>Image views are represented by <code>VkImageView</code> handles:</p>  <pre id="VkImageView" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)</pre>      <h4 id="_see_also_151">See Also</h4>  <p><a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>, <a href="#VkFramebufferCreateInfo">VkFramebufferCreateInfo</a>, <a href="#vkCreateImageView">vkCreateImageView</a>, <a href="#vkDestroyImageView">vkDestroyImageView</a></p>    <h4 id="_document_notes_151">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageView">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageView</a></p>         <h3 id="_vkinstance_3">VkInstance(3)</h3>  <h4 id="_name_152">Name</h4>  <p>VkInstance - Opaque handle to a instance object</p>    <h4 id="_c_specification_152">C Specification</h4>  <p>There is no global state in Vulkan and all per-application state is stored in a <code>VkInstance</code> object. Creating a <code>VkInstance</code> object initializes the Vulkan library and allows the application to pass information about itself to the implementation.</p>   <p>Instances are represented by <code>VkInstance</code> handles:</p>  <pre id="VkInstance" data-language="c++">VK_DEFINE_HANDLE(VkInstance)</pre>      <h4 id="_see_also_152">See Also</h4>  <p><a href="#vkCreateInstance">vkCreateInstance</a>, <a href="#vkDestroyInstance">vkDestroyInstance</a>, <a href="#vkEnumeratePhysicalDevices">vkEnumeratePhysicalDevices</a>, <a href="#vkGetInstanceProcAddr">vkGetInstanceProcAddr</a></p>    <h4 id="_document_notes_152">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkInstance">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkInstance</a></p>         <h3 id="_vkphysicaldevice_3">VkPhysicalDevice(3)</h3>  <h4 id="_name_153">Name</h4>  <p>VkPhysicalDevice - Opaque handle to a physical device object</p>    <h4 id="_c_specification_153">C Specification</h4>  <p>Vulkan separates the concept of <em>physical</em> and <em>logical</em> devices. A physical device usually represents a single device in a system (perhaps made up of several individual hardware devices working together), of which there are a finite number. A logical device represents an application’s view of the device.</p>   <p>Physical devices are represented by <code>VkPhysicalDevice</code> handles:</p>  <pre id="VkPhysicalDevice" data-language="c++">VK_DEFINE_HANDLE(VkPhysicalDevice)</pre>      <h4 id="_see_also_153">See Also</h4>  <p><a href="#vkCreateDevice">vkCreateDevice</a>, <a href="#vkEnumerateDeviceExtensionProperties">vkEnumerateDeviceExtensionProperties</a>, <a href="#vkEnumerateDeviceLayerProperties">vkEnumerateDeviceLayerProperties</a>, <a href="#vkEnumeratePhysicalDevices">vkEnumeratePhysicalDevices</a>, <a href="#vkGetPhysicalDeviceFeatures">vkGetPhysicalDeviceFeatures</a>, <a href="#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a>, <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a>, <a href="#vkGetPhysicalDeviceMemoryProperties">vkGetPhysicalDeviceMemoryProperties</a>, <a href="#vkGetPhysicalDeviceProperties">vkGetPhysicalDeviceProperties</a>, <a href="#vkGetPhysicalDeviceQueueFamilyProperties">vkGetPhysicalDeviceQueueFamilyProperties</a>, <a href="#vkGetPhysicalDeviceSparseImageFormatProperties">vkGetPhysicalDeviceSparseImageFormatProperties</a></p>    <h4 id="_document_notes_153">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDevice">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDevice</a></p>         <h3 id="_vkpipeline_3">VkPipeline(3)</h3>  <h4 id="_name_154">Name</h4>  <p>VkPipeline - Opaque handle to a pipeline object</p>    <h4 id="_c_specification_154">C Specification</h4>  <p>Compute and graphics pipelines are each represented by <code>VkPipeline</code> handles:</p>  <pre id="VkPipeline" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)</pre>      <h4 id="_see_also_154">See Also</h4>  <p><a href="#VkComputePipelineCreateInfo">VkComputePipelineCreateInfo</a>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#vkCmdBindPipeline">vkCmdBindPipeline</a>, <a href="#vkCreateComputePipelines">vkCreateComputePipelines</a>, <a href="#vkCreateGraphicsPipelines">vkCreateGraphicsPipelines</a>, <a href="#vkDestroyPipeline">vkDestroyPipeline</a></p>    <h4 id="_document_notes_154">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipeline">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipeline</a></p>         <h3 id="_vkpipelinecache_3">VkPipelineCache(3)</h3>  <h4 id="_name_155">Name</h4>  <p>VkPipelineCache - Opaque handle to a pipeline cache object</p>    <h4 id="_c_specification_155">C Specification</h4>  <p>Pipeline cache objects allow the result of pipeline construction to be reused between pipelines and between runs of an application. Reuse between pipelines is achieved by passing the same pipeline cache object when creating multiple related pipelines. Reuse across runs of an application is achieved by retrieving pipeline cache contents in one run of an application, saving the contents, and using them to preinitialize a pipeline cache on a subsequent run. The contents of the pipeline cache objects are managed by the implementation. Applications <strong>can</strong> manage the host memory consumed by a pipeline cache object and control the amount of data retrieved from a pipeline cache object.</p>   <p>Pipeline cache objects are represented by <code>VkPipelineCache</code> handles:</p>  <pre id="VkPipelineCache" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)</pre>      <h4 id="_see_also_155">See Also</h4>  <p><a href="#vkCreateComputePipelines">vkCreateComputePipelines</a>, <a href="#vkCreateGraphicsPipelines">vkCreateGraphicsPipelines</a>, <a href="#vkCreatePipelineCache">vkCreatePipelineCache</a>, <a href="#vkDestroyPipelineCache">vkDestroyPipelineCache</a>, <a href="#vkGetPipelineCacheData">vkGetPipelineCacheData</a>, <a href="#vkMergePipelineCaches">vkMergePipelineCaches</a></p>    <h4 id="_document_notes_155">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCache">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCache</a></p>         <h3 id="_vkpipelinelayout_3">VkPipelineLayout(3)</h3>  <h4 id="_name_156">Name</h4>  <p>VkPipelineLayout - Opaque handle to a pipeline layout object</p>    <h4 id="_c_specification_156">C Specification</h4>  <p>Access to descriptor sets from a pipeline is accomplished through a <em>pipeline layout</em>. Zero or more descriptor set layouts and zero or more push constant ranges are combined to form a pipeline layout object which describes the complete set of resources that <strong>can</strong> be accessed by a pipeline. The pipeline layout represents a sequence of descriptor sets with each having a specific layout. This sequence of layouts is used to determine the interface between shader stages and shader resources. Each pipeline is created using a pipeline layout.</p>   <p>Pipeline layout objects are represented by <code>VkPipelineLayout</code> handles:</p>  <pre id="VkPipelineLayout" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)</pre>      <h4 id="_see_also_156">See Also</h4>  <p><a href="#VkComputePipelineCreateInfo">VkComputePipelineCreateInfo</a>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#vkCmdBindDescriptorSets">vkCmdBindDescriptorSets</a>, <a href="#vkCmdPushConstants">vkCmdPushConstants</a>, <a href="#vkCreatePipelineLayout">vkCreatePipelineLayout</a>, <a href="#vkDestroyPipelineLayout">vkDestroyPipelineLayout</a></p>    <h4 id="_document_notes_156">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineLayout">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineLayout</a></p>         <h3 id="_vkquerypool_3">VkQueryPool(3)</h3>  <h4 id="_name_157">Name</h4>  <p>VkQueryPool - Opaque handle to a query pool object</p>    <h4 id="_c_specification_157">C Specification</h4>  <p>Queries are managed using <em>query pool</em> objects. Each query pool is a collection of a specific number of queries of a particular type.</p>   <p>Query pools are represented by <code>VkQueryPool</code> handles:</p>  <pre id="VkQueryPool" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)</pre>      <h4 id="_see_also_157">See Also</h4>  <p><a href="#vkCmdBeginQuery">vkCmdBeginQuery</a>, <a href="#vkCmdCopyQueryPoolResults">vkCmdCopyQueryPoolResults</a>, <a href="#vkCmdEndQuery">vkCmdEndQuery</a>, <a href="#vkCmdResetQueryPool">vkCmdResetQueryPool</a>, <a href="#vkCmdWriteTimestamp">vkCmdWriteTimestamp</a>, <a href="#vkCreateQueryPool">vkCreateQueryPool</a>, <a href="#vkDestroyQueryPool">vkDestroyQueryPool</a>, <a href="#vkGetQueryPoolResults">vkGetQueryPoolResults</a></p>    <h4 id="_document_notes_157">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryPool">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryPool</a></p>         <h3 id="_vkqueue_3">VkQueue(3)</h3>  <h4 id="_name_158">Name</h4>  <p>VkQueue - Opaque handle to a queue object</p>    <h4 id="_c_specification_158">C Specification</h4>  <p>Creating a logical device also creates the queues associated with that device. The queues to create are described by a set of <a href="#VkDeviceQueueCreateInfo">VkDeviceQueueCreateInfo</a> structures that are passed to <a href="#vkCreateDevice">vkCreateDevice</a> in <code>pQueueCreateInfos</code>.</p>   <p>Queues are represented by <code>VkQueue</code> handles:</p>  <pre id="VkQueue" data-language="c++">VK_DEFINE_HANDLE(VkQueue)</pre>      <h4 id="_see_also_158">See Also</h4>  <p><a href="#vkGetDeviceQueue">vkGetDeviceQueue</a>, <a href="#vkQueueBindSparse">vkQueueBindSparse</a>, <a href="#vkQueueSubmit">vkQueueSubmit</a>, <a href="#vkQueueWaitIdle">vkQueueWaitIdle</a></p>    <h4 id="_document_notes_158">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueue">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueue</a></p>         <h3 id="_vkrenderpass_3">VkRenderPass(3)</h3>  <h4 id="_name_159">Name</h4>  <p>VkRenderPass - Opaque handle to a render pass object</p>    <h4 id="_c_specification_159">C Specification</h4>  <p>A <em>render pass</em> represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses. The use of a render pass in a command buffer is a <em>render pass instance</em>.</p>   <p>Render passes are represented by <code>VkRenderPass</code> handles:</p>  <pre id="VkRenderPass" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)</pre>      <h4 id="_see_also_159">See Also</h4>  <p><a href="#VkCommandBufferInheritanceInfo">VkCommandBufferInheritanceInfo</a>, <a href="#VkFramebufferCreateInfo">VkFramebufferCreateInfo</a>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkRenderPassBeginInfo">VkRenderPassBeginInfo</a>, <a href="#vkCreateRenderPass">vkCreateRenderPass</a>, <a href="#vkDestroyRenderPass">vkDestroyRenderPass</a>, <a href="#vkGetRenderAreaGranularity">vkGetRenderAreaGranularity</a></p>    <h4 id="_document_notes_159">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkRenderPass">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkRenderPass</a></p>         <h3 id="_vksampler_3">VkSampler(3)</h3>  <h4 id="_name_160">Name</h4>  <p>VkSampler - Opaque handle to a sampler object</p>    <h4 id="_c_specification_160">C Specification</h4>  <p><code>VkSampler</code> objects represent the state of an image sampler which is used by the implementation to read image data and apply filtering and other transformations for the shader.</p>   <p>Samplers are represented by <code>VkSampler</code> handles:</p>  <pre id="VkSampler" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)</pre>      <h4 id="_see_also_160">See Also</h4>  <p><a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>, <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a>, <a href="#vkCreateSampler">vkCreateSampler</a>, <a href="#vkDestroySampler">vkDestroySampler</a></p>    <h4 id="_document_notes_160">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSampler">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSampler</a></p>         <h3 id="_vksemaphore_3">VkSemaphore(3)</h3>  <h4 id="_name_161">Name</h4>  <p>VkSemaphore - Opaque handle to a semaphore object</p>    <h4 id="_c_specification_161">C Specification</h4>  <p>Semaphores are a synchronization primitive that <strong>can</strong> be used to insert a dependency between batches submitted to queues. Semaphores have two states - signaled and unsignaled. The state of a semaphore <strong>can</strong> be signaled after execution of a batch of commands is completed. A batch <strong>can</strong> wait for a semaphore to become signaled before it begins execution, and the semaphore is also unsignaled before the batch begins execution.</p>   <p>Semaphores are represented by <code>VkSemaphore</code> handles:</p>  <pre id="VkSemaphore" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)</pre>      <h4 id="_see_also_161">See Also</h4>  <p><a href="#VkBindSparseInfo">VkBindSparseInfo</a>, <a href="#VkSubmitInfo">VkSubmitInfo</a>, <a href="#vkCreateSemaphore">vkCreateSemaphore</a>, <a href="#vkDestroySemaphore">vkDestroySemaphore</a></p>    <h4 id="_document_notes_161">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSemaphore">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSemaphore</a></p>         <h3 id="_vkshadermodule_3">VkShaderModule(3)</h3>  <h4 id="_name_162">Name</h4>  <p>VkShaderModule - Opaque handle to a shader module object</p>    <h4 id="_c_specification_162">C Specification</h4>  <p><em>Shader modules</em> contain <em>shader code</em> and one or more entry points. Shaders are selected from a shader module by specifying an entry point as part of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines">pipeline</a> creation. The stages of a pipeline <strong>can</strong> use shaders that come from different modules. The shader code defining a shader module <strong>must</strong> be in the SPIR-V format, as described by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv">Vulkan Environment for SPIR-V</a> appendix.</p>   <p>Shader modules are represented by <code>VkShaderModule</code> handles:</p>  <pre id="VkShaderModule" data-language="c++">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)</pre>      <h4 id="_see_also_162">See Also</h4>  <p><a href="#VkPipelineShaderStageCreateInfo">VkPipelineShaderStageCreateInfo</a>, <a href="#vkCreateShaderModule">vkCreateShaderModule</a>, <a href="#vkDestroyShaderModule">vkDestroyShaderModule</a></p>    <h4 id="_document_notes_162">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkShaderModule">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkShaderModule</a></p>           <h2 id="structs">Structures</h2>   <h3 id="_vkallocationcallbacks_3">VkAllocationCallbacks(3)</h3>  <h4 id="_name_163">Name</h4>  <p>VkAllocationCallbacks - Structure containing callback function pointers for memory allocation</p>    <h4 id="_c_specification_163">C Specification</h4>  <p>Allocators are provided by the application as a pointer to a <code>VkAllocationCallbacks</code> structure:</p>  <pre id="VkAllocationCallbacks" data-language="c++">typedef struct VkAllocationCallbacks {
    void*                                   pUserData;
    PFN_vkAllocationFunction                pfnAllocation;
    PFN_vkReallocationFunction              pfnReallocation;
    PFN_vkFreeFunction                      pfnFree;
    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    PFN_vkInternalFreeNotification          pfnInternalFree;
} VkAllocationCallbacks;</pre>   <h4 id="_members">Members</h4>  <ul> <li> <code>pUserData</code> is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in <code>VkAllocationCallbacks</code> are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value <strong>can</strong> vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands. </li> <li> <code>pfnAllocation</code> is a pointer to an application-defined memory allocation function of type <a href="#PFN_vkAllocationFunction">PFN_vkAllocationFunction</a>. </li> <li> <code>pfnReallocation</code> is a pointer to an application-defined memory reallocation function of type <a href="#PFN_vkReallocationFunction">PFN_vkReallocationFunction</a>. </li> <li> <code>pfnFree</code> is a pointer to an application-defined memory free function of type <a href="#PFN_vkFreeFunction">PFN_vkFreeFunction</a>. </li> <li> <code>pfnInternalAllocation</code> is a pointer to an application-defined function that is called by the implementation when the implementation makes internal allocations, and it is of type <a href="#PFN_vkInternalAllocationNotification">PFN_vkInternalAllocationNotification</a>. </li> <li> <code>pfnInternalFree</code> is a pointer to an application-defined function that is called by the implementation when the implementation frees internal allocations, and it is of type <a href="#PFN_vkInternalFreeNotification">PFN_vkInternalFreeNotification</a>. </li> </ul>    <h4 id="_description_163">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkAllocationCallbacks-pfnAllocation-00632">  <code>pfnAllocation</code> <strong>must</strong> be a pointer to a valid user-defined <a href="#PFN_vkAllocationFunction">PFN_vkAllocationFunction</a> </li> <li id="VUID-VkAllocationCallbacks-pfnReallocation-00633">  <code>pfnReallocation</code> <strong>must</strong> be a pointer to a valid user-defined <a href="#PFN_vkReallocationFunction">PFN_vkReallocationFunction</a> </li> <li id="VUID-VkAllocationCallbacks-pfnFree-00634">  <code>pfnFree</code> <strong>must</strong> be a pointer to a valid user-defined <a href="#PFN_vkFreeFunction">PFN_vkFreeFunction</a> </li> <li id="VUID-VkAllocationCallbacks-pfnInternalAllocation-00635">  If either of <code>pfnInternalAllocation</code> or <code>pfnInternalFree</code> is not <code>NULL</code>, both <strong>must</strong> be valid callbacks </li> </ul>   </blockquote>   <h4 id="_see_also_163">See Also</h4>  <p><a href="#PFN_vkAllocationFunction">PFN_vkAllocationFunction</a>, <a href="#PFN_vkFreeFunction">PFN_vkFreeFunction</a>, <a href="#PFN_vkInternalAllocationNotification">PFN_vkInternalAllocationNotification</a>, <a href="#PFN_vkInternalFreeNotification">PFN_vkInternalFreeNotification</a>, <a href="#PFN_vkReallocationFunction">PFN_vkReallocationFunction</a>, <a href="#vkAllocateMemory">vkAllocateMemory</a>, <a href="#vkCreateBuffer">vkCreateBuffer</a>, <a href="#vkCreateBufferView">vkCreateBufferView</a>, <a href="#vkCreateCommandPool">vkCreateCommandPool</a>, <a href="#vkCreateComputePipelines">vkCreateComputePipelines</a>, <a href="#vkCreateDescriptorPool">vkCreateDescriptorPool</a>, <a href="#vkCreateDescriptorSetLayout">vkCreateDescriptorSetLayout</a>, <a href="#vkCreateDevice">vkCreateDevice</a>, <a href="#vkCreateEvent">vkCreateEvent</a>, <a href="#vkCreateFence">vkCreateFence</a>, <a href="#vkCreateFramebuffer">vkCreateFramebuffer</a>, <a href="#vkCreateGraphicsPipelines">vkCreateGraphicsPipelines</a>, <a href="#vkCreateImage">vkCreateImage</a>, <a href="#vkCreateImageView">vkCreateImageView</a>, <a href="#vkCreateInstance">vkCreateInstance</a>, <a href="#vkCreatePipelineCache">vkCreatePipelineCache</a>, <a href="#vkCreatePipelineLayout">vkCreatePipelineLayout</a>, <a href="#vkCreateQueryPool">vkCreateQueryPool</a>, <a href="#vkCreateRenderPass">vkCreateRenderPass</a>, <a href="#vkCreateSampler">vkCreateSampler</a>, <a href="#vkCreateSemaphore">vkCreateSemaphore</a>, <a href="#vkCreateShaderModule">vkCreateShaderModule</a>, <a href="#vkDestroyBuffer">vkDestroyBuffer</a>, <a href="#vkDestroyBufferView">vkDestroyBufferView</a>, <a href="#vkDestroyCommandPool">vkDestroyCommandPool</a>, <a href="#vkDestroyDescriptorPool">vkDestroyDescriptorPool</a>, <a href="#vkDestroyDescriptorSetLayout">vkDestroyDescriptorSetLayout</a>, <a href="#vkDestroyDevice">vkDestroyDevice</a>, <a href="#vkDestroyEvent">vkDestroyEvent</a>, <a href="#vkDestroyFence">vkDestroyFence</a>, <a href="#vkDestroyFramebuffer">vkDestroyFramebuffer</a>, <a href="#vkDestroyImage">vkDestroyImage</a>, <a href="#vkDestroyImageView">vkDestroyImageView</a>, <a href="#vkDestroyInstance">vkDestroyInstance</a>, <a href="#vkDestroyPipeline">vkDestroyPipeline</a>, <a href="#vkDestroyPipelineCache">vkDestroyPipelineCache</a>, <a href="#vkDestroyPipelineLayout">vkDestroyPipelineLayout</a>, <a href="#vkDestroyQueryPool">vkDestroyQueryPool</a>, <a href="#vkDestroyRenderPass">vkDestroyRenderPass</a>, <a href="#vkDestroySampler">vkDestroySampler</a>, <a href="#vkDestroySemaphore">vkDestroySemaphore</a>, <a href="#vkDestroyShaderModule">vkDestroyShaderModule</a>, <a href="#vkFreeMemory">vkFreeMemory</a></p>    <h4 id="_document_notes_163">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAllocationCallbacks">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAllocationCallbacks</a></p>         <h3 id="_vkapplicationinfo_3">VkApplicationInfo(3)</h3>  <h4 id="_name_164">Name</h4>  <p>VkApplicationInfo - Structure specifying application info</p>    <h4 id="_c_specification_164">C Specification</h4>  <p>The <code>VkApplicationInfo</code> structure is defined as:</p>  <pre id="VkApplicationInfo" data-language="c++">typedef struct VkApplicationInfo {
    VkStructureType    sType;
    const void*        pNext;
    const char*        pApplicationName;
    uint32_t           applicationVersion;
    const char*        pEngineName;
    uint32_t           engineVersion;
    uint32_t           apiVersion;
} VkApplicationInfo;</pre>   <h4 id="_members_2">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>pApplicationName</code> is <code>NULL</code> or is a pointer to a null-terminated UTF-8 string containing the name of the application. </li> <li> <code>applicationVersion</code> is an unsigned integer variable containing the developer-supplied version number of the application. </li> <li> <code>pEngineName</code> is <code>NULL</code> or is a pointer to a null-terminated UTF-8 string containing the name of the engine (if any) used to create the application. </li> <li> <code>engineVersion</code> is an unsigned integer variable containing the developer-supplied version number of the engine used to create the application. </li> <li> <code>apiVersion</code> is the version of the Vulkan API against which the application expects to run, encoded as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-versionnum">API Version Numbers and Semantics</a> section. If <code>apiVersion</code> is 0 the implementation <strong>must</strong> ignore it, otherwise if the implementation does not support the requested <code>apiVersion</code>, or an effective substitute for <code>apiVersion</code>, it <strong>must</strong> return <code>VK_ERROR_INCOMPATIBLE_DRIVER</code>. The patch version number specified in <code>apiVersion</code> is ignored when creating an instance object. Only the major and minor versions of the instance <strong>must</strong> match those requested in <code>apiVersion</code>. </li> </ul>    <h4 id="_description_164">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkApplicationInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_APPLICATION_INFO</code> </li> <li id="VUID-VkApplicationInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkApplicationInfo-pApplicationName-parameter">  If <code>pApplicationName</code> is not <code>NULL</code>, <code>pApplicationName</code> <strong>must</strong> be a null-terminated UTF-8 string </li> <li id="VUID-VkApplicationInfo-pEngineName-parameter">  If <code>pEngineName</code> is not <code>NULL</code>, <code>pEngineName</code> <strong>must</strong> be a null-terminated UTF-8 string </li> </ul>   </blockquote>   <h4 id="_see_also_164">See Also</h4>  <p><a href="#VkInstanceCreateInfo">VkInstanceCreateInfo</a>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_164">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkApplicationInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkApplicationInfo</a></p>         <h3 id="_vkattachmentdescription_3">VkAttachmentDescription(3)</h3>  <h4 id="_name_165">Name</h4>  <p>VkAttachmentDescription - Structure specifying an attachment description</p>    <h4 id="_c_specification_165">C Specification</h4>  <p>The <code>VkAttachmentDescription</code> structure is defined as:</p>  <pre id="VkAttachmentDescription" data-language="c++">typedef struct VkAttachmentDescription {
    VkAttachmentDescriptionFlags    flags;
    VkFormat                        format;
    VkSampleCountFlagBits           samples;
    VkAttachmentLoadOp              loadOp;
    VkAttachmentStoreOp             storeOp;
    VkAttachmentLoadOp              stencilLoadOp;
    VkAttachmentStoreOp             stencilStoreOp;
    VkImageLayout                   initialLayout;
    VkImageLayout                   finalLayout;
} VkAttachmentDescription;</pre>   <h4 id="_members_3">Members</h4>  <ul> <li> <code>flags</code> is a bitmask of <a href="#VkAttachmentDescriptionFlagBits">VkAttachmentDescriptionFlagBits</a> specifying additional properties of the attachment. </li> <li> <code>format</code> is a <a href="#VkFormat">VkFormat</a> value specifying the format of the image that will be used for the attachment. </li> <li> <code>samples</code> is the number of samples of the image as defined in <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a>. </li> <li> <code>loadOp</code> is a <a href="#VkAttachmentLoadOp">VkAttachmentLoadOp</a> value specifying how the contents of color and depth components of the attachment are treated at the beginning of the subpass where it is first used. </li> <li> <code>storeOp</code> is a <a href="#VkAttachmentStoreOp">VkAttachmentStoreOp</a> value specifying how the contents of color and depth components of the attachment are treated at the end of the subpass where it is last used. </li> <li> <code>stencilLoadOp</code> is a <a href="#VkAttachmentLoadOp">VkAttachmentLoadOp</a> value specifying how the contents of stencil components of the attachment are treated at the beginning of the subpass where it is first used. </li> <li> <code>stencilStoreOp</code> is a <a href="#VkAttachmentStoreOp">VkAttachmentStoreOp</a> value specifying how the contents of stencil components of the attachment are treated at the end of the last subpass where it is used. </li> <li> <code>initialLayout</code> is the layout the attachment image subresource will be in when a render pass instance begins. </li> <li> <code>finalLayout</code> is the layout the attachment image subresource will be transitioned to when a render pass instance ends. During a render pass instance, an attachment <strong>can</strong> use a different layout in each subpass, if desired. </li> </ul>    <h4 id="_description_165">Description</h4>  <p>If the attachment uses a color format, then <code>loadOp</code> and <code>storeOp</code> are used, and <code>stencilLoadOp</code> and <code>stencilStoreOp</code> are ignored. If the format has depth and/or stencil components, <code>loadOp</code> and <code>storeOp</code> apply only to the depth data, while <code>stencilLoadOp</code> and <code>stencilStoreOp</code> define how the stencil data is handled. <code>loadOp</code> and <code>stencilLoadOp</code> define the <em>load operations</em> that execute as part of the first subpass that uses the attachment. <code>storeOp</code> and <code>stencilStoreOp</code> define the <em>store operations</em> that execute as part of the last subpass that uses the attachment.</p>   <p>The load operation for each sample in an attachment happens-before any recorded command which accesses the sample in the first subpass where the attachment is used. Load operations for attachments with a depth/stencil format execute in the <code>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code> pipeline stage. Load operations for attachments with a color format execute in the <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> pipeline stage.</p>   <p>The store operation for each sample in an attachment happens-after any recorded command which accesses the sample in the last subpass where the attachment is used. Store operations for attachments with a depth/stencil format execute in the <code>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</code> pipeline stage. Store operations for attachments with a color format execute in the <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> pipeline stage.</p>   <p>If an attachment is not used by any subpass, then <code>loadOp</code>, <code>storeOp</code>, <code>stencilStoreOp</code>, and <code>stencilLoadOp</code> are ignored, and the attachment’s memory contents will not be modified by execution of a render pass instance.</p>   <p>During a render pass instance, input/color attachments with color formats that have a component size of 8, 16, or 32 bits <strong>must</strong> be represented in the attachment’s format throughout the instance. Attachments with other floating- or fixed-point color formats, or with depth components <strong>may</strong> be represented in a format with a precision higher than the attachment format, but <strong>must</strong> be represented with the same range. When such a component is loaded via the <code>loadOp</code>, it will be converted into an implementation-dependent format used by the render pass. Such components <strong>must</strong> be converted from the render pass format, to the format of the attachment, before they are resolved or stored at the end of a render pass instance via <code>storeOp</code>. Conversions occur as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-numerics">Numeric Representation and Computation</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-fixedconv">Fixed-Point Data Conversions</a>.</p>   <p>If <code>flags</code> includes <code>VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT</code>, then the attachment is treated as if it shares physical memory with another attachment in the same render pass. This information limits the ability of the implementation to reorder certain operations (like layout transitions and the <code>loadOp</code>) such that it is not improperly reordered against other uses of the same physical memory via a different attachment. This is described in more detail below.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkAttachmentDescription-finalLayout-00843">  <code>finalLayout</code> <strong>must</strong> not be <code>VK_IMAGE_LAYOUT_UNDEFINED</code> or <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkAttachmentDescription-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkAttachmentDescriptionFlagBits">VkAttachmentDescriptionFlagBits</a> values </li> <li id="VUID-VkAttachmentDescription-format-parameter">  <code>format</code> <strong>must</strong> be a valid <a href="#VkFormat">VkFormat</a> value </li> <li id="VUID-VkAttachmentDescription-samples-parameter">  <code>samples</code> <strong>must</strong> be a valid <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> value </li> <li id="VUID-VkAttachmentDescription-loadOp-parameter">  <code>loadOp</code> <strong>must</strong> be a valid <a href="#VkAttachmentLoadOp">VkAttachmentLoadOp</a> value </li> <li id="VUID-VkAttachmentDescription-storeOp-parameter">  <code>storeOp</code> <strong>must</strong> be a valid <a href="#VkAttachmentStoreOp">VkAttachmentStoreOp</a> value </li> <li id="VUID-VkAttachmentDescription-stencilLoadOp-parameter">  <code>stencilLoadOp</code> <strong>must</strong> be a valid <a href="#VkAttachmentLoadOp">VkAttachmentLoadOp</a> value </li> <li id="VUID-VkAttachmentDescription-stencilStoreOp-parameter">  <code>stencilStoreOp</code> <strong>must</strong> be a valid <a href="#VkAttachmentStoreOp">VkAttachmentStoreOp</a> value </li> <li id="VUID-VkAttachmentDescription-initialLayout-parameter">  <code>initialLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-VkAttachmentDescription-finalLayout-parameter">  <code>finalLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_165">See Also</h4>  <p><a href="#VkAttachmentDescriptionFlags">VkAttachmentDescriptionFlags</a>, <a href="#VkAttachmentLoadOp">VkAttachmentLoadOp</a>, <a href="#VkAttachmentStoreOp">VkAttachmentStoreOp</a>, <a href="#VkFormat">VkFormat</a>, <a href="#VkImageLayout">VkImageLayout</a>, <a href="#VkRenderPassCreateInfo">VkRenderPassCreateInfo</a>, <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a></p>    <h4 id="_document_notes_165">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentDescription">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentDescription</a></p>         <h3 id="_vkattachmentreference_3">VkAttachmentReference(3)</h3>  <h4 id="_name_166">Name</h4>  <p>VkAttachmentReference - Structure specifying an attachment reference</p>    <h4 id="_c_specification_166">C Specification</h4>  <p>The <code>VkAttachmentReference</code> structure is defined as:</p>  <pre id="VkAttachmentReference" data-language="c++">typedef struct VkAttachmentReference {
    uint32_t         attachment;
    VkImageLayout    layout;
} VkAttachmentReference;</pre>   <h4 id="_members_4">Members</h4>  <ul> <li> <code>attachment</code> is the index of the attachment of the render pass, and corresponds to the index of the corresponding element in the <code>pAttachments</code> array of the <code>VkRenderPassCreateInfo</code> structure. If any color or depth/stencil attachments are <code>VK_ATTACHMENT_UNUSED</code>, then no writes occur for those attachments. </li> <li> <code>layout</code> is a <a href="#VkImageLayout">VkImageLayout</a> value specifying the layout the attachment uses during the subpass. </li> </ul>    <h4 id="_description_166">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkAttachmentReference-layout-00857">  <code>layout</code> <strong>must</strong> not be <code>VK_IMAGE_LAYOUT_UNDEFINED</code> or <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkAttachmentReference-layout-parameter">  <code>layout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_166">See Also</h4>  <p><a href="#VkImageLayout">VkImageLayout</a>, <a href="#VkSubpassDescription">VkSubpassDescription</a></p>    <h4 id="_document_notes_166">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentReference">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentReference</a></p>         <h3 id="_vkbindsparseinfo_3">VkBindSparseInfo(3)</h3>  <h4 id="_name_167">Name</h4>  <p>VkBindSparseInfo - Structure specifying a sparse binding operation</p>    <h4 id="_c_specification_167">C Specification</h4>  <p>The <code>VkBindSparseInfo</code> structure is defined as:</p>  <pre id="VkBindSparseInfo" data-language="c++">typedef struct VkBindSparseInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    uint32_t                                    waitSemaphoreCount;
    const VkSemaphore*                          pWaitSemaphores;
    uint32_t                                    bufferBindCount;
    const VkSparseBufferMemoryBindInfo*         pBufferBinds;
    uint32_t                                    imageOpaqueBindCount;
    const VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
    uint32_t                                    imageBindCount;
    const VkSparseImageMemoryBindInfo*          pImageBinds;
    uint32_t                                    signalSemaphoreCount;
    const VkSemaphore*                          pSignalSemaphores;
} VkBindSparseInfo;</pre>   <h4 id="_members_5">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>waitSemaphoreCount</code> is the number of semaphores upon which to wait before executing the sparse binding operations for the batch. </li> <li> <code>pWaitSemaphores</code> is a pointer to an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores-waiting">semaphore wait operation</a>. </li> <li> <code>bufferBindCount</code> is the number of sparse buffer bindings to perform in the batch. </li> <li> <code>pBufferBinds</code> is a pointer to an array of <a href="#VkSparseBufferMemoryBindInfo">VkSparseBufferMemoryBindInfo</a> structures. </li> <li> <code>imageOpaqueBindCount</code> is the number of opaque sparse image bindings to perform. </li> <li> <code>pImageOpaqueBinds</code> is a pointer to an array of <a href="#VkSparseImageOpaqueMemoryBindInfo">VkSparseImageOpaqueMemoryBindInfo</a> structures, indicating opaque sparse image bindings to perform. </li> <li> <code>imageBindCount</code> is the number of sparse image bindings to perform. </li> <li> <code>pImageBinds</code> is a pointer to an array of <a href="#VkSparseImageMemoryBindInfo">VkSparseImageMemoryBindInfo</a> structures, indicating sparse image bindings to perform. </li> <li> <code>signalSemaphoreCount</code> is the number of semaphores to be signaled once the sparse binding operations specified by the structure have completed execution. </li> <li> <code>pSignalSemaphores</code> is a pointer to an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores-signaling">semaphore signal operation</a>. </li> </ul>    <h4 id="_description_167">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkBindSparseInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_BIND_SPARSE_INFO</code> </li> <li id="VUID-VkBindSparseInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkBindSparseInfo-pWaitSemaphores-parameter">  If <code>waitSemaphoreCount</code> is not <code>0</code>, <code>pWaitSemaphores</code> <strong>must</strong> be a pointer to an array of <code>waitSemaphoreCount</code> valid <code>VkSemaphore</code> handles </li> <li id="VUID-VkBindSparseInfo-pBufferBinds-parameter">  If <code>bufferBindCount</code> is not <code>0</code>, <code>pBufferBinds</code> <strong>must</strong> be a pointer to an array of <code>bufferBindCount</code> valid <code>VkSparseBufferMemoryBindInfo</code> structures </li> <li id="VUID-VkBindSparseInfo-pImageOpaqueBinds-parameter">  If <code>imageOpaqueBindCount</code> is not <code>0</code>, <code>pImageOpaqueBinds</code> <strong>must</strong> be a pointer to an array of <code>imageOpaqueBindCount</code> valid <code>VkSparseImageOpaqueMemoryBindInfo</code> structures </li> <li id="VUID-VkBindSparseInfo-pImageBinds-parameter">  If <code>imageBindCount</code> is not <code>0</code>, <code>pImageBinds</code> <strong>must</strong> be a pointer to an array of <code>imageBindCount</code> valid <code>VkSparseImageMemoryBindInfo</code> structures </li> <li id="VUID-VkBindSparseInfo-pSignalSemaphores-parameter">  If <code>signalSemaphoreCount</code> is not <code>0</code>, <code>pSignalSemaphores</code> <strong>must</strong> be a pointer to an array of <code>signalSemaphoreCount</code> valid <code>VkSemaphore</code> handles </li> <li id="VUID-VkBindSparseInfo-commonparent">  Both of the elements of <code>pSignalSemaphores</code>, and the elements of <code>pWaitSemaphores</code> that are valid handles <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_167">See Also</h4>  <p><a href="#VkSemaphore">VkSemaphore</a>, <a href="#VkSparseBufferMemoryBindInfo">VkSparseBufferMemoryBindInfo</a>, <a href="#VkSparseImageMemoryBindInfo">VkSparseImageMemoryBindInfo</a>, <a href="#VkSparseImageOpaqueMemoryBindInfo">VkSparseImageOpaqueMemoryBindInfo</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkQueueBindSparse">vkQueueBindSparse</a></p>    <h4 id="_document_notes_167">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBindSparseInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBindSparseInfo</a></p>         <h3 id="_vkbuffercopy_3">VkBufferCopy(3)</h3>  <h4 id="_name_168">Name</h4>  <p>VkBufferCopy - Structure specifying a buffer copy operation</p>    <h4 id="_c_specification_168">C Specification</h4>  <p>The <code>VkBufferCopy</code> structure is defined as:</p>  <pre id="VkBufferCopy" data-language="c++">typedef struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
} VkBufferCopy;</pre>   <h4 id="_members_6">Members</h4>  <ul> <li> <code>srcOffset</code> is the starting offset in bytes from the start of <code>srcBuffer</code>. </li> <li> <code>dstOffset</code> is the starting offset in bytes from the start of <code>dstBuffer</code>. </li> <li> <code>size</code> is the number of bytes to copy. </li> </ul>       <h4 id="_see_also_168">See Also</h4>  <p><code>VkDeviceSize</code>, <a href="#vkCmdCopyBuffer">vkCmdCopyBuffer</a></p>    <h4 id="_document_notes_168">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferCopy">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferCopy</a></p>         <h3 id="_vkbuffercreateinfo_3">VkBufferCreateInfo(3)</h3>  <h4 id="_name_169">Name</h4>  <p>VkBufferCreateInfo - Structure specifying the parameters of a newly created buffer object</p>    <h4 id="_c_specification_169">C Specification</h4>  <p>The <code>VkBufferCreateInfo</code> structure is defined as:</p>  <pre id="VkBufferCreateInfo" data-language="c++">typedef struct VkBufferCreateInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkBufferCreateFlags    flags;
    VkDeviceSize           size;
    VkBufferUsageFlags     usage;
    VkSharingMode          sharingMode;
    uint32_t               queueFamilyIndexCount;
    const uint32_t*        pQueueFamilyIndices;
} VkBufferCreateInfo;</pre>   <h4 id="_members_7">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is a bitmask of <a href="#VkBufferCreateFlagBits">VkBufferCreateFlagBits</a> specifying additional parameters of the buffer. </li> <li> <code>size</code> is the size in bytes of the buffer to be created. </li> <li> <code>usage</code> is a bitmask of <a href="#VkBufferUsageFlagBits">VkBufferUsageFlagBits</a> specifying allowed usages of the buffer. </li> <li> <code>sharingMode</code> is a <a href="#VkSharingMode">VkSharingMode</a> value specifying the sharing mode of the buffer when it will be accessed by multiple queue families. </li> <li> <code>queueFamilyIndexCount</code> is the number of entries in the <code>pQueueFamilyIndices</code> array. </li> <li> <code>pQueueFamilyIndices</code> is a list of queue families that will access this buffer (ignored if <code>sharingMode</code> is not <code>VK_SHARING_MODE_CONCURRENT</code>). </li> </ul>    <h4 id="_description_169">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkBufferCreateInfo-size-00912">  <code>size</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkBufferCreateInfo-sharingMode-00913">  If <code>sharingMode</code> is <code>VK_SHARING_MODE_CONCURRENT</code>, <code>pQueueFamilyIndices</code> <strong>must</strong> be a pointer to an array of <code>queueFamilyIndexCount</code> <code>uint32_t</code> values </li> <li id="VUID-VkBufferCreateInfo-sharingMode-00914">  If <code>sharingMode</code> is <code>VK_SHARING_MODE_CONCURRENT</code>, <code>queueFamilyIndexCount</code> <strong>must</strong> be greater than <code>1</code> </li> <li id="VUID-VkBufferCreateInfo-sharingMode-01391">  If <code>sharingMode</code> is <code>VK_SHARING_MODE_CONCURRENT</code>, each element of <code>pQueueFamilyIndices</code> <strong>must</strong> be unique and <strong>must</strong> be less than <code>pQueueFamilyPropertyCount</code> returned by <a href="#vkGetPhysicalDeviceQueueFamilyProperties">vkGetPhysicalDeviceQueueFamilyProperties</a> for the <code>physicalDevice</code> that was used to create <code>device</code> </li> <li id="VUID-VkBufferCreateInfo-flags-00915">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseBinding">sparse bindings</a> feature is not enabled, <code>flags</code> <strong>must</strong> not contain <code>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</code> </li> <li id="VUID-VkBufferCreateInfo-flags-00916">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyBuffer">sparse buffer residency</a> feature is not enabled, <code>flags</code> <strong>must</strong> not contain <code>VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</code> </li> <li id="VUID-VkBufferCreateInfo-flags-00917">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyAliased">sparse aliased residency</a> feature is not enabled, <code>flags</code> <strong>must</strong> not contain <code>VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</code> </li> <li id="VUID-VkBufferCreateInfo-flags-00918">  If <code>flags</code> contains <code>VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</code> or <code>VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</code>, it <strong>must</strong> also contain <code>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkBufferCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</code> </li> <li id="VUID-VkBufferCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkBufferCreateInfo-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkBufferCreateFlagBits">VkBufferCreateFlagBits</a> values </li> <li id="VUID-VkBufferCreateInfo-usage-parameter">  <code>usage</code> <strong>must</strong> be a valid combination of <a href="#VkBufferUsageFlagBits">VkBufferUsageFlagBits</a> values </li> <li id="VUID-VkBufferCreateInfo-usage-requiredbitmask">  <code>usage</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-VkBufferCreateInfo-sharingMode-parameter">  <code>sharingMode</code> <strong>must</strong> be a valid <a href="#VkSharingMode">VkSharingMode</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_169">See Also</h4>  <p><a href="#VkBufferCreateFlags">VkBufferCreateFlags</a>, <a href="#VkBufferUsageFlags">VkBufferUsageFlags</a>, <code>VkDeviceSize</code>, <a href="#VkSharingMode">VkSharingMode</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateBuffer">vkCreateBuffer</a></p>    <h4 id="_document_notes_169">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferCreateInfo</a></p>         <h3 id="_vkbufferimagecopy_3">VkBufferImageCopy(3)</h3>  <h4 id="_name_170">Name</h4>  <p>VkBufferImageCopy - Structure specifying a buffer image copy operation</p>    <h4 id="_c_specification_170">C Specification</h4>  <p>For both <a href="#vkCmdCopyBufferToImage">vkCmdCopyBufferToImage</a> and <a href="#vkCmdCopyImageToBuffer">vkCmdCopyImageToBuffer</a>, each element of <code>pRegions</code> is a structure defined as:</p>  <pre id="VkBufferImageCopy" data-language="c++">typedef struct VkBufferImageCopy {
    VkDeviceSize                bufferOffset;
    uint32_t                    bufferRowLength;
    uint32_t                    bufferImageHeight;
    VkImageSubresourceLayers    imageSubresource;
    VkOffset3D                  imageOffset;
    VkExtent3D                  imageExtent;
} VkBufferImageCopy;</pre>   <h4 id="_members_8">Members</h4>  <ul> <li> <code>bufferOffset</code> is the offset in bytes from the start of the buffer object where the image data is copied from or to. </li> <li> <code>bufferRowLength</code> and <code>bufferImageHeight</code> specify the data in buffer memory as a subregion of a larger two- or three-dimensional image, and control the addressing calculations of data in buffer memory. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the <code>imageExtent</code>. </li> <li> <code>imageSubresource</code> is a <a href="#VkImageSubresourceLayers">VkImageSubresourceLayers</a> used to specify the specific image subresources of the image used for the source or destination image data. </li> <li> <code>imageOffset</code> selects the initial x, y, z offsets in texels of the sub-region of the source or destination image data. </li> <li> <code>imageExtent</code> is the size in texels of the image to copy in <code>width</code>, <code>height</code> and <code>depth</code>. </li> </ul>    <h4 id="_description_170">Description</h4>  <p>When copying to or from a depth or stencil aspect, the data in buffer memory uses a layout that is a (mostly) tightly packed representation of the depth or stencil data. Specifically:</p>   <ul> <li> data copied to or from the stencil aspect of any depth/stencil format is tightly packed with one <code>VK_FORMAT_S8_UINT</code> value per texel. </li> <li> data copied to or from the depth aspect of a <code>VK_FORMAT_D16_UNORM</code> or <code>VK_FORMAT_D16_UNORM_S8_UINT</code> format is tightly packed with one <code>VK_FORMAT_D16_UNORM</code> value per texel. </li> <li> data copied to or from the depth aspect of a <code>VK_FORMAT_D32_SFLOAT</code> or <code>VK_FORMAT_D32_SFLOAT_S8_UINT</code> format is tightly packed with one <code>VK_FORMAT_D32_SFLOAT</code> value per texel. </li> <li> data copied to or from the depth aspect of a <code>VK_FORMAT_X8_D24_UNORM_PACK32</code> or <code>VK_FORMAT_D24_UNORM_S8_UINT</code> format is packed with one 32-bit word per texel with the D24 value in the LSBs of the word, and undefined values in the eight MSBs. </li> </ul>  <blockquote> <h5 class="title">Note</h5>  <p>To copy both the depth and stencil aspects of a depth/stencil format, two entries in <code>pRegions</code> <strong>can</strong> be used, where one specifies the depth aspect in <code>imageSubresource</code>, and the other specifies the stencil aspect.</p>  </blockquote>  <p>Because depth or stencil aspect buffer to image copies <strong>may</strong> require format conversions on some implementations, they are not supported on queues that do not support graphics. When copying to a depth aspect, the data in buffer memory <strong>must</strong> be in the the range [0,1] or undefined results occur.</p>   <p>Copies are done layer by layer starting with image layer <code>baseArrayLayer</code> member of <code>imageSubresource</code>. <code>layerCount</code> layers are copied from the source image or to the destination image.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkBufferImageCopy-bufferOffset-00193">  If the the calling command’s <code>VkImage</code> parameter’s format is not a depth/stencil format, then <code>bufferOffset</code> <strong>must</strong> be a multiple of the format’s element size </li> <li id="VUID-VkBufferImageCopy-bufferOffset-00194">  <code>bufferOffset</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-VkBufferImageCopy-bufferRowLength-00195">  <code>bufferRowLength</code> <strong>must</strong> be <code>0</code>, or greater than or equal to the <code>width</code> member of <code>imageExtent</code> </li> <li id="VUID-VkBufferImageCopy-bufferImageHeight-00196">  <code>bufferImageHeight</code> <strong>must</strong> be <code>0</code>, or greater than or equal to the <code>height</code> member of <code>imageExtent</code> </li> <li id="VUID-VkBufferImageCopy-imageOffset-00197">  <code>imageOffset.x</code> and (<code>imageExtent.width</code> + <code>imageOffset.x</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the image subresource width </li> <li id="VUID-VkBufferImageCopy-imageOffset-00198">  <code>imageOffset.y</code> and (imageExtent.height + <code>imageOffset.y</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the image subresource height </li> <li id="VUID-VkBufferImageCopy-srcImage-00199">  If the calling command’s <code>srcImage</code> (<a href="#vkCmdCopyImageToBuffer">vkCmdCopyImageToBuffer</a>) or <code>dstImage</code> (<a href="#vkCmdCopyBufferToImage">vkCmdCopyBufferToImage</a>) is of type <code>VK_IMAGE_TYPE_1D</code>, then <code>imageOffset.y</code> <strong>must</strong> be <code>0</code> and <code>imageExtent.height</code> <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkBufferImageCopy-imageOffset-00200">  <code>imageOffset.z</code> and (imageExtent.depth + <code>imageOffset.z</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the image subresource depth </li> <li id="VUID-VkBufferImageCopy-srcImage-00201">  If the calling command’s <code>srcImage</code> (<a href="#vkCmdCopyImageToBuffer">vkCmdCopyImageToBuffer</a>) or <code>dstImage</code> (<a href="#vkCmdCopyBufferToImage">vkCmdCopyBufferToImage</a>) is of type <code>VK_IMAGE_TYPE_1D</code> or <code>VK_IMAGE_TYPE_2D</code>, then <code>imageOffset.z</code> <strong>must</strong> be <code>0</code> and <code>imageExtent.depth</code> <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkBufferImageCopy-bufferRowLength-00203">  If the calling command’s <code>VkImage</code> parameter is a compressed format image, <code>bufferRowLength</code> <strong>must</strong> be a multiple of the compressed texel block width </li> <li id="VUID-VkBufferImageCopy-bufferImageHeight-00204">  If the calling command’s <code>VkImage</code> parameter is a compressed format image, <code>bufferImageHeight</code> <strong>must</strong> be a multiple of the compressed texel block height </li> <li id="VUID-VkBufferImageCopy-imageOffset-00205">  If the calling command’s <code>VkImage</code> parameter is a compressed format image, all members of <code>imageOffset</code> <strong>must</strong> be a multiple of the corresponding dimensions of the compressed texel block </li> <li id="VUID-VkBufferImageCopy-bufferOffset-00206">  If the calling command’s <code>VkImage</code> parameter is a compressed format image, <code>bufferOffset</code> <strong>must</strong> be a multiple of the compressed texel block size in bytes </li> <li id="VUID-VkBufferImageCopy-imageExtent-00207">  If the calling command’s <code>VkImage</code> parameter is a compressed format image, <code>imageExtent.width</code> <strong>must</strong> be a multiple of the compressed texel block width or (<code>imageExtent.width</code> + <code>imageOffset.x</code>) <strong>must</strong> equal the image subresource width </li> <li id="VUID-VkBufferImageCopy-imageExtent-00208">  If the calling command’s <code>VkImage</code> parameter is a compressed format image, <code>imageExtent.height</code> <strong>must</strong> be a multiple of the compressed texel block height or (<code>imageExtent.height</code> + <code>imageOffset.y</code>) <strong>must</strong> equal the image subresource height </li> <li id="VUID-VkBufferImageCopy-imageExtent-00209">  If the calling command’s <code>VkImage</code> parameter is a compressed format image, <code>imageExtent.depth</code> <strong>must</strong> be a multiple of the compressed texel block depth or (<code>imageExtent.depth</code> + <code>imageOffset.z</code>) <strong>must</strong> equal the image subresource depth </li> <li id="VUID-VkBufferImageCopy-bufferOffset-00210">  <code>bufferOffset</code>, <code>bufferRowLength</code>, <code>bufferImageHeight</code> and all members of <code>imageOffset</code> and <code>imageExtent</code> <strong>must</strong> respect the image transfer granularity requirements of the queue family that it will be submitted against, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-physical-device-enumeration">Physical Device Enumeration</a> </li> <li id="VUID-VkBufferImageCopy-aspectMask-00211">  The <code>aspectMask</code> member of <code>imageSubresource</code> <strong>must</strong> specify aspects present in the calling command’s <code>VkImage</code> parameter </li> <li id="VUID-VkBufferImageCopy-aspectMask-00212">  The <code>aspectMask</code> member of <code>imageSubresource</code> <strong>must</strong> only have a single bit set </li> <li id="VUID-VkBufferImageCopy-baseArrayLayer-00213">  If the calling command’s <code>VkImage</code> parameter is of <a href="#VkImageType">VkImageType</a> <code>VK_IMAGE_TYPE_3D</code>, the <code>baseArrayLayer</code> and <code>layerCount</code> members of <code>imageSubresource</code> <strong>must</strong> be <code>0</code> and <code>1</code>, respectively </li> <li id="VUID-VkBufferImageCopy-None-00214">  When copying to the depth aspect of an image subresource, the data in the source buffer <strong>must</strong> be in the range [0,1] </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkBufferImageCopy-imageSubresource-parameter">  <code>imageSubresource</code> <strong>must</strong> be a valid <code>VkImageSubresourceLayers</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_170">See Also</h4>  <p><code>VkDeviceSize</code>, <a href="#VkExtent3D">VkExtent3D</a>, <a href="#VkImageSubresourceLayers">VkImageSubresourceLayers</a>, <a href="#VkOffset3D">VkOffset3D</a>, <a href="#vkCmdCopyBufferToImage">vkCmdCopyBufferToImage</a>, <a href="#vkCmdCopyImageToBuffer">vkCmdCopyImageToBuffer</a></p>    <h4 id="_document_notes_170">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferImageCopy">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferImageCopy</a></p>         <h3 id="_vkbuffermemorybarrier_3">VkBufferMemoryBarrier(3)</h3>  <h4 id="_name_171">Name</h4>  <p>VkBufferMemoryBarrier - Structure specifying a buffer memory barrier</p>    <h4 id="_c_specification_171">C Specification</h4>  <p>The <code>VkBufferMemoryBarrier</code> structure is defined as:</p>  <pre id="VkBufferMemoryBarrier" data-language="c++">typedef struct VkBufferMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
    uint32_t           srcQueueFamilyIndex;
    uint32_t           dstQueueFamilyIndex;
    VkBuffer           buffer;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkBufferMemoryBarrier;</pre>   <h4 id="_members_9">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>srcAccessMask</code> is a bitmask of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> specifying a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a>. </li> <li> <code>dstAccessMask</code> is a bitmask of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> specifying a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access mask</a>. </li> <li> <code>srcQueueFamilyIndex</code> is the source queue family for a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers">queue family ownership transfer</a>. </li> <li> <code>dstQueueFamilyIndex</code> is the destination queue family for a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers">queue family ownership transfer</a>. </li> <li> <code>buffer</code> is a handle to the buffer whose backing memory is affected by the barrier. </li> <li> <code>offset</code> is an offset in bytes into the backing memory for <code>buffer</code>; this is relative to the base offset as bound to the buffer (see <a href="#vkBindBufferMemory">vkBindBufferMemory</a>). </li> <li> <code>size</code> is a size in bytes of the affected area of backing memory for <code>buffer</code>, or <code>VK_WHOLE_SIZE</code> to use the range from <code>offset</code> to the end of the buffer. </li> </ul>    <h4 id="_description_171">Description</h4>  <p>The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access to memory through the specified buffer range, via access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a> specified by <code>srcAccessMask</code>. If <code>srcAccessMask</code> includes <code>VK_ACCESS_HOST_WRITE_BIT</code>, memory writes performed by that access type are also made visible, as that access type is not performed through a resource.</p>   <p>The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access to memory through the specified buffer range, via access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access mask</a>. specified by <code>dstAccessMask</code>. If <code>dstAccessMask</code> includes <code>VK_ACCESS_HOST_WRITE_BIT</code> or <code>VK_ACCESS_HOST_READ_BIT</code>, available memory writes are also made visible to accesses of those types, as those access types are not performed through a resource.</p>   <p>If <code>srcQueueFamilyIndex</code> is not equal to <code>dstQueueFamilyIndex</code>, and <code>srcQueueFamilyIndex</code> is equal to the current queue family, then the memory barrier defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-release">queue family release operation</a> for the specified buffer range, and the second access scope includes no access, as if <code>dstAccessMask</code> was <code>0</code>.</p>   <p>If <code>dstQueueFamilyIndex</code> is not equal to <code>srcQueueFamilyIndex</code>, and <code>dstQueueFamilyIndex</code> is equal to the current queue family, then the memory barrier defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-acquire">queue family acquire operation</a> for the specified buffer range, and the first access scope includes no access, as if <code>srcAccessMask</code> was <code>0</code>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkBufferMemoryBarrier-offset-01187">  <code>offset</code> <strong>must</strong> be less than the size of <code>buffer</code> </li> <li id="VUID-VkBufferMemoryBarrier-size-01188">  If <code>size</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>size</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkBufferMemoryBarrier-size-01189">  If <code>size</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>size</code> <strong>must</strong> be less than or equal to than the size of <code>buffer</code> minus <code>offset</code> </li> <li id="VUID-VkBufferMemoryBarrier-buffer-01190">  If <code>buffer</code> was created with a sharing mode of <code>VK_SHARING_MODE_CONCURRENT</code>, <code>srcQueueFamilyIndex</code> and <code>dstQueueFamilyIndex</code> <strong>must</strong> both be <code>VK_QUEUE_FAMILY_IGNORED</code> </li> <li id="VUID-VkBufferMemoryBarrier-buffer-01192">  If <code>buffer</code> was created with a sharing mode of <code>VK_SHARING_MODE_EXCLUSIVE</code>, <code>srcQueueFamilyIndex</code> and <code>dstQueueFamilyIndex</code> <strong>must</strong> either both be <code>VK_QUEUE_FAMILY_IGNORED</code>, or both be a valid queue family (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-queueprops">html/vkspec.html#devsandqueues-queueprops</a>) </li> <li id="VUID-VkBufferMemoryBarrier-buffer-01196">  If <code>buffer</code> was created with a sharing mode of <code>VK_SHARING_MODE_EXCLUSIVE</code>, and <code>srcQueueFamilyIndex</code> and <code>dstQueueFamilyIndex</code> are not <code>VK_QUEUE_FAMILY_IGNORED</code>, at least one of them <strong>must</strong> be the same as the family of the queue that will execute this barrier </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkBufferMemoryBarrier-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER</code> </li> <li id="VUID-VkBufferMemoryBarrier-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkBufferMemoryBarrier-srcAccessMask-parameter">  <code>srcAccessMask</code> <strong>must</strong> be a valid combination of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> values </li> <li id="VUID-VkBufferMemoryBarrier-dstAccessMask-parameter">  <code>dstAccessMask</code> <strong>must</strong> be a valid combination of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> values </li> <li id="VUID-VkBufferMemoryBarrier-buffer-parameter">  <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> </ul>   </blockquote>   <h4 id="_see_also_171">See Also</h4>  <p><a href="#VkAccessFlags">VkAccessFlags</a>, <a href="#VkBuffer">VkBuffer</a>, <code>VkDeviceSize</code>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a>, <a href="#vkCmdWaitEvents">vkCmdWaitEvents</a></p>    <h4 id="_document_notes_171">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferMemoryBarrier">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferMemoryBarrier</a></p>         <h3 id="_vkbufferviewcreateinfo_3">VkBufferViewCreateInfo(3)</h3>  <h4 id="_name_172">Name</h4>  <p>VkBufferViewCreateInfo - Structure specifying parameters of a newly created buffer view</p>    <h4 id="_c_specification_172">C Specification</h4>  <p>The <code>VkBufferViewCreateInfo</code> structure is defined as:</p>  <pre id="VkBufferViewCreateInfo" data-language="c++">typedef struct VkBufferViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkBufferViewCreateFlags    flags;
    VkBuffer                   buffer;
    VkFormat                   format;
    VkDeviceSize               offset;
    VkDeviceSize               range;
} VkBufferViewCreateInfo;</pre>   <h4 id="_members_10">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>buffer</code> is a <code>VkBuffer</code> on which the view will be created. </li> <li> <code>format</code> is a <a href="#VkFormat">VkFormat</a> describing the format of the data elements in the buffer. </li> <li> <code>offset</code> is an offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset. </li> <li> <code>range</code> is a size in bytes of the buffer view. If <code>range</code> is equal to <code>VK_WHOLE_SIZE</code>, the range from <code>offset</code> to the end of the buffer is used. If <code>VK_WHOLE_SIZE</code> is used and the remaining size of the buffer is not a multiple of the element size of <code>format</code>, then the nearest smaller multiple is used. </li> </ul>    <h4 id="_description_172">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkBufferViewCreateInfo-offset-00925">  <code>offset</code> <strong>must</strong> be less than the size of <code>buffer</code> </li> <li id="VUID-VkBufferViewCreateInfo-offset-00926">  <code>offset</code> <strong>must</strong> be a multiple of <code>VkPhysicalDeviceLimits</code>::<code>minTexelBufferOffsetAlignment</code> </li> <li id="VUID-VkBufferViewCreateInfo-range-00928">  If <code>range</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>range</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkBufferViewCreateInfo-range-00929">  If <code>range</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>range</code> <strong>must</strong> be a multiple of the element size of <code>format</code> </li> <li id="VUID-VkBufferViewCreateInfo-range-00930">  If <code>range</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>range</code> divided by the element size of <code>format</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxTexelBufferElements</code> </li> <li id="VUID-VkBufferViewCreateInfo-offset-00931">  If <code>range</code> is not equal to <code>VK_WHOLE_SIZE</code>, the sum of <code>offset</code> and <code>range</code> <strong>must</strong> be less than or equal to the size of <code>buffer</code> </li> <li id="VUID-VkBufferViewCreateInfo-buffer-00932">  <code>buffer</code> <strong>must</strong> have been created with a <code>usage</code> value containing at least one of <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> or <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code> </li> <li id="VUID-VkBufferViewCreateInfo-buffer-00933">  If <code>buffer</code> was created with <code>usage</code> containing <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code>, <code>format</code> <strong>must</strong> be supported for uniform texel buffers, as specified by the <code>VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT</code> flag in <code>VkFormatProperties</code>::<code>bufferFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-VkBufferViewCreateInfo-buffer-00934">  If <code>buffer</code> was created with <code>usage</code> containing <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code>, <code>format</code> <strong>must</strong> be supported for storage texel buffers, as specified by the <code>VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT</code> flag in <code>VkFormatProperties</code>::<code>bufferFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-VkBufferViewCreateInfo-buffer-00935">  If <code>buffer</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkBufferViewCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO</code> </li> <li id="VUID-VkBufferViewCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkBufferViewCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkBufferViewCreateInfo-buffer-parameter">  <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-VkBufferViewCreateInfo-format-parameter">  <code>format</code> <strong>must</strong> be a valid <a href="#VkFormat">VkFormat</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_172">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <a href="#VkBufferViewCreateFlags">VkBufferViewCreateFlags</a>, <code>VkDeviceSize</code>, <a href="#VkFormat">VkFormat</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateBufferView">vkCreateBufferView</a></p>    <h4 id="_document_notes_172">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferViewCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferViewCreateInfo</a></p>         <h3 id="_vkclearattachment_3">VkClearAttachment(3)</h3>  <h4 id="_name_173">Name</h4>  <p>VkClearAttachment - Structure specifying a clear attachment</p>    <h4 id="_c_specification_173">C Specification</h4>  <p>The <code>VkClearAttachment</code> structure is defined as:</p>  <pre id="VkClearAttachment" data-language="c++">typedef struct VkClearAttachment {
    VkImageAspectFlags    aspectMask;
    uint32_t              colorAttachment;
    VkClearValue          clearValue;
} VkClearAttachment;</pre>   <h4 id="_members_11">Members</h4>  <ul> <li> <code>aspectMask</code> is a mask selecting the color, depth and/or stencil aspects of the attachment to be cleared. <code>aspectMask</code> <strong>can</strong> include <code>VK_IMAGE_ASPECT_COLOR_BIT</code> for color attachments, <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> for depth/stencil attachments with a depth component, and <code>VK_IMAGE_ASPECT_STENCIL_BIT</code> for depth/stencil attachments with a stencil component. If the subpass’s depth/stencil attachment is <code>VK_ATTACHMENT_UNUSED</code>, then the clear has no effect. </li> <li> <code>colorAttachment</code> is only meaningful if <code>VK_IMAGE_ASPECT_COLOR_BIT</code> is set in <code>aspectMask</code>, in which case it is an index to the <code>pColorAttachments</code> array in the <a href="#VkSubpassDescription">VkSubpassDescription</a> structure of the current subpass which selects the color attachment to clear. If <code>colorAttachment</code> is <code>VK_ATTACHMENT_UNUSED</code> then the clear has no effect. </li> <li> <code>clearValue</code> is the color or depth/stencil value to clear the attachment to, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#clears-values">Clear Values</a> below. </li> </ul>    <h4 id="_description_173">Description</h4>  <p>No memory barriers are needed between <code>vkCmdClearAttachments</code> and preceding or subsequent draw or attachment clear commands in the same subpass.</p>   <p>The <code>vkCmdClearAttachments</code> command is not affected by the bound pipeline state.</p>   <p>Attachments <strong>can</strong> also be cleared at the beginning of a render pass instance by setting <code>loadOp</code> (or <code>stencilLoadOp</code>) of <a href="#VkAttachmentDescription">VkAttachmentDescription</a> to <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>, as described for <a href="#vkCreateRenderPass">vkCreateRenderPass</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkClearAttachment-aspectMask-00019">  If <code>aspectMask</code> includes <code>VK_IMAGE_ASPECT_COLOR_BIT</code>, it <strong>must</strong> not include <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> or <code>VK_IMAGE_ASPECT_STENCIL_BIT</code> </li> <li id="VUID-VkClearAttachment-aspectMask-00020">  <code>aspectMask</code> <strong>must</strong> not include <code>VK_IMAGE_ASPECT_METADATA_BIT</code> </li> <li id="VUID-VkClearAttachment-clearValue-00021">  <code>clearValue</code> <strong>must</strong> be a valid <code>VkClearValue</code> union </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkClearAttachment-aspectMask-parameter">  <code>aspectMask</code> <strong>must</strong> be a valid combination of <a href="#VkImageAspectFlagBits">VkImageAspectFlagBits</a> values </li> <li id="VUID-VkClearAttachment-aspectMask-requiredbitmask">  <code>aspectMask</code> <strong>must</strong> not be <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_173">See Also</h4>  <p><a href="#VkClearValue">VkClearValue</a>, <a href="#VkImageAspectFlags">VkImageAspectFlags</a>, <a href="#vkCmdClearAttachments">vkCmdClearAttachments</a></p>    <h4 id="_document_notes_173">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkClearAttachment">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkClearAttachment</a></p>         <h3 id="_vkclearcolorvalue_3">VkClearColorValue(3)</h3>  <h4 id="_name_174">Name</h4>  <p>VkClearColorValue - Structure specifying a clear color value</p>    <h4 id="_c_specification_174">C Specification</h4>  <p>The <code>VkClearColorValue</code> structure is defined as:</p>  <pre id="VkClearColorValue" data-language="c++">typedef union VkClearColorValue {
    float       float32[4];
    int32_t     int32[4];
    uint32_t    uint32[4];
} VkClearColorValue;</pre>   <h4 id="_members_12">Members</h4>  <ul> <li> <code>float32</code> are the color clear values when the format of the image or attachment is one of the formats in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-formats-numericformat">Interpretation of Numeric Format</a> table other than signed integer (<code>SINT</code>) or unsigned integer (<code>UINT</code>). Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB. </li> <li> <code>int32</code> are the color clear values when the format of the image or attachment is signed integer (<code>SINT</code>). Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is undefined. </li> <li> <code>uint32</code> are the color clear values when the format of the image or attachment is unsigned integer (<code>UINT</code>). Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits. </li> </ul>    <h4 id="_description_174">Description</h4>  <p>The four array elements of the clear color map to R, G, B, and A components of image formats, in order.</p>   <p>If the image has more than one sample, the same value is written to all samples for any pixels being cleared.</p>    <h4 id="_see_also_174">See Also</h4>  <p><a href="#VkClearValue">VkClearValue</a>, <a href="#vkCmdClearColorImage">vkCmdClearColorImage</a></p>    <h4 id="_document_notes_174">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkClearColorValue">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkClearColorValue</a></p>         <h3 id="_vkcleardepthstencilvalue_3">VkClearDepthStencilValue(3)</h3>  <h4 id="_name_175">Name</h4>  <p>VkClearDepthStencilValue - Structure specifying a clear depth stencil value</p>    <h4 id="_c_specification_175">C Specification</h4>  <p>The <code>VkClearDepthStencilValue</code> structure is defined as:</p>  <pre id="VkClearDepthStencilValue" data-language="c++">typedef struct VkClearDepthStencilValue {
    float       depth;
    uint32_t    stencil;
} VkClearDepthStencilValue;</pre>   <h4 id="_members_13">Members</h4>  <ul> <li> <code>depth</code> is the clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment’s format. </li> <li> <code>stencil</code> is the clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment’s format by taking the appropriate number of LSBs. </li> </ul>    <h4 id="_description_175">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkClearDepthStencilValue-depth-00022">  <code>depth</code> <strong>must</strong> be between <code>0.0</code> and <code>1.0</code>, inclusive </li> </ul>   </blockquote>   <h4 id="_see_also_175">See Also</h4>  <p><a href="#VkClearValue">VkClearValue</a>, <a href="#vkCmdClearDepthStencilImage">vkCmdClearDepthStencilImage</a></p>    <h4 id="_document_notes_175">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkClearDepthStencilValue">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkClearDepthStencilValue</a></p>         <h3 id="_vkclearrect_3">VkClearRect(3)</h3>  <h4 id="_name_176">Name</h4>  <p>VkClearRect - Structure specifying a clear rectangle</p>    <h4 id="_c_specification_176">C Specification</h4>  <p>The <code>VkClearRect</code> structure is defined as:</p>  <pre id="VkClearRect" data-language="c++">typedef struct VkClearRect {
    VkRect2D    rect;
    uint32_t    baseArrayLayer;
    uint32_t    layerCount;
} VkClearRect;</pre>   <h4 id="_members_14">Members</h4>  <ul> <li> <code>rect</code> is the two-dimensional region to be cleared. </li> <li> <code>baseArrayLayer</code> is the first layer to be cleared. </li> <li> <code>layerCount</code> is the number of layers to clear. </li> </ul>    <h4 id="_description_176">Description</h4>  <p>The layers [<code>baseArrayLayer</code>, <code>baseArrayLayer</code> + <code>layerCount</code>) counting from the base layer of the attachment image view are cleared.</p>    <h4 id="_see_also_176">See Also</h4>  <p><a href="#VkRect2D">VkRect2D</a>, <a href="#vkCmdClearAttachments">vkCmdClearAttachments</a></p>    <h4 id="_document_notes_176">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkClearRect">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkClearRect</a></p>         <h3 id="_vkclearvalue_3">VkClearValue(3)</h3>  <h4 id="_name_177">Name</h4>  <p>VkClearValue - Structure specifying a clear value</p>    <h4 id="_c_specification_177">C Specification</h4>  <p>The <code>VkClearValue</code> union is defined as:</p>  <pre id="VkClearValue" data-language="c++">typedef union VkClearValue {
    VkClearColorValue           color;
    VkClearDepthStencilValue    depthStencil;
} VkClearValue;</pre>   <h4 id="_members_15">Members</h4>  <ul> <li> <code>color</code> specifies the color image clear values to use when clearing a color image or attachment. </li> <li> <code>depthStencil</code> specifies the depth and stencil clear values to use when clearing a depth/stencil image or attachment. </li> </ul>    <h4 id="_description_177">Description</h4>  <p>This union is used where part of the API requires either color or depth/stencil clear values, depending on the attachment, and defines the initial clear values in the <a href="#VkRenderPassBeginInfo">VkRenderPassBeginInfo</a> structure.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkClearValue-depthStencil-00023">  <code>depthStencil</code> <strong>must</strong> be a valid <code>VkClearDepthStencilValue</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_177">See Also</h4>  <p><a href="#VkClearAttachment">VkClearAttachment</a>, <a href="#VkClearColorValue">VkClearColorValue</a>, <a href="#VkClearDepthStencilValue">VkClearDepthStencilValue</a>, <a href="#VkRenderPassBeginInfo">VkRenderPassBeginInfo</a></p>    <h4 id="_document_notes_177">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkClearValue">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkClearValue</a></p>         <h3 id="_vkcommandbufferallocateinfo_3">VkCommandBufferAllocateInfo(3)</h3>  <h4 id="_name_178">Name</h4>  <p>VkCommandBufferAllocateInfo - Structure specifying the allocation parameters for command buffer object</p>    <h4 id="_c_specification_178">C Specification</h4>  <p>The <code>VkCommandBufferAllocateInfo</code> structure is defined as:</p>  <pre id="VkCommandBufferAllocateInfo" data-language="c++">typedef struct VkCommandBufferAllocateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkCommandPool           commandPool;
    VkCommandBufferLevel    level;
    uint32_t                commandBufferCount;
} VkCommandBufferAllocateInfo;</pre>   <h4 id="_members_16">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>commandPool</code> is the command pool from which the command buffers are allocated. </li> <li> <code>level</code> is an <a href="#VkCommandBufferLevel">VkCommandBufferLevel</a> value specifying the command buffer level. </li> <li> <code>commandBufferCount</code> is the number of command buffers to allocate from the pool. </li> </ul>    <h4 id="_description_178">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkCommandBufferAllocateInfo-commandBufferCount-00044">  <code>commandBufferCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkCommandBufferAllocateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</code> </li> <li id="VUID-VkCommandBufferAllocateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkCommandBufferAllocateInfo-commandPool-parameter">  <code>commandPool</code> <strong>must</strong> be a valid <code>VkCommandPool</code> handle </li> <li id="VUID-VkCommandBufferAllocateInfo-level-parameter">  <code>level</code> <strong>must</strong> be a valid <a href="#VkCommandBufferLevel">VkCommandBufferLevel</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_178">See Also</h4>  <p><a href="#VkCommandBufferLevel">VkCommandBufferLevel</a>, <a href="#VkCommandPool">VkCommandPool</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkAllocateCommandBuffers">vkAllocateCommandBuffers</a></p>    <h4 id="_document_notes_178">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferAllocateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferAllocateInfo</a></p>         <h3 id="_vkcommandbufferbegininfo_3">VkCommandBufferBeginInfo(3)</h3>  <h4 id="_name_179">Name</h4>  <p>VkCommandBufferBeginInfo - Structure specifying a command buffer begin operation</p>    <h4 id="_c_specification_179">C Specification</h4>  <p>The <code>VkCommandBufferBeginInfo</code> structure is defined as:</p>  <pre id="VkCommandBufferBeginInfo" data-language="c++">typedef struct VkCommandBufferBeginInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkCommandBufferUsageFlags                flags;
    const VkCommandBufferInheritanceInfo*    pInheritanceInfo;
} VkCommandBufferBeginInfo;</pre>   <h4 id="_members_17">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is a bitmask of <a href="#VkCommandBufferUsageFlagBits">VkCommandBufferUsageFlagBits</a> specifying usage behavior for the command buffer. </li> <li> <code>pInheritanceInfo</code> is a pointer to a <code>VkCommandBufferInheritanceInfo</code> structure, which is used if <code>commandBuffer</code> is a secondary command buffer. If this is a primary command buffer, then this value is ignored. </li> </ul>    <h4 id="_description_179">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkCommandBufferBeginInfo-flags-00053">  If <code>flags</code> contains <code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code>, the <code>renderPass</code> member of <code>pInheritanceInfo</code> <strong>must</strong> be a valid <code>VkRenderPass</code> </li> <li id="VUID-VkCommandBufferBeginInfo-flags-00054">  If <code>flags</code> contains <code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code>, the <code>subpass</code> member of <code>pInheritanceInfo</code> <strong>must</strong> be a valid subpass index within the <code>renderPass</code> member of <code>pInheritanceInfo</code> </li> <li id="VUID-VkCommandBufferBeginInfo-flags-00055">  If <code>flags</code> contains <code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code>, the <code>framebuffer</code> member of <code>pInheritanceInfo</code> <strong>must</strong> be either <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, or a valid <code>VkFramebuffer</code> that is compatible with the <code>renderPass</code> member of <code>pInheritanceInfo</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkCommandBufferBeginInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</code> </li> <li id="VUID-VkCommandBufferBeginInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkCommandBufferBeginInfo-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkCommandBufferUsageFlagBits">VkCommandBufferUsageFlagBits</a> values </li> </ul>   </blockquote>   <h4 id="_see_also_179">See Also</h4>  <p><a href="#VkCommandBufferInheritanceInfo">VkCommandBufferInheritanceInfo</a>, <a href="#VkCommandBufferUsageFlags">VkCommandBufferUsageFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkBeginCommandBuffer">vkBeginCommandBuffer</a></p>    <h4 id="_document_notes_179">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferBeginInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferBeginInfo</a></p>         <h3 id="_vkcommandbufferinheritanceinfo_3">VkCommandBufferInheritanceInfo(3)</h3>  <h4 id="_name_180">Name</h4>  <p>VkCommandBufferInheritanceInfo - Structure specifying command buffer inheritance info</p>    <h4 id="_c_specification_180">C Specification</h4>  <p>If the command buffer is a secondary command buffer, then the <code>VkCommandBufferInheritanceInfo</code> structure defines any state that will be inherited from the primary command buffer:</p>  <pre id="VkCommandBufferInheritanceInfo" data-language="c++">typedef struct VkCommandBufferInheritanceInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkRenderPass                     renderPass;
    uint32_t                         subpass;
    VkFramebuffer                    framebuffer;
    VkBool32                         occlusionQueryEnable;
    VkQueryControlFlags              queryFlags;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkCommandBufferInheritanceInfo;</pre>   <h4 id="_members_18">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>renderPass</code> is a <code>VkRenderPass</code> object defining which render passes the <code>VkCommandBuffer</code> will be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a> with and <strong>can</strong> be executed within. If the <code>VkCommandBuffer</code> will not be executed within a render pass instance, <code>renderPass</code> is ignored. </li> <li> <code>subpass</code> is the index of the subpass within the render pass instance that the <code>VkCommandBuffer</code> will be executed within. If the <code>VkCommandBuffer</code> will not be executed within a render pass instance, <code>subpass</code> is ignored. </li> <li> <p><code>framebuffer</code> optionally refers to the <code>VkFramebuffer</code> object that the <code>VkCommandBuffer</code> will be rendering to if it is executed within a render pass instance. It <strong>can</strong> be <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a> if the framebuffer is not known, or if the <code>VkCommandBuffer</code> will not be executed within a render pass instance.</p> <blockquote> <h5 class="title">Note</h5>  <p>Specifying the exact framebuffer that the secondary command buffer will be executed with <strong>may</strong> result in better performance at command buffer execution time.</p>  </blockquote> </li> <li> <code>occlusionQueryEnable</code> indicates whether the command buffer <strong>can</strong> be executed while an occlusion query is active in the primary command buffer. If this is <code>VK_TRUE</code>, then this command buffer <strong>can</strong> be executed whether the primary command buffer has an occlusion query active or not. If this is <code>VK_FALSE</code>, then the primary command buffer <strong>must</strong> not have an occlusion query active. </li> <li> <code>queryFlags</code> indicates the query flags that <strong>can</strong> be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the <code>VK_QUERY_CONTROL_PRECISE_BIT</code> bit, then the active query <strong>can</strong> return boolean results or actual sample counts. If this bit is not set, then the active query <strong>must</strong> not use the <code>VK_QUERY_CONTROL_PRECISE_BIT</code> bit. </li> <li> <code>pipelineStatistics</code> is a bitmask of <a href="#VkQueryPipelineStatisticFlagBits">VkQueryPipelineStatisticFlagBits</a> specifying the set of pipeline statistics that <strong>can</strong> be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer <strong>can</strong> be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query <strong>must</strong> not be from a query pool that counts that statistic. </li> </ul>    <h4 id="_description_180">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkCommandBufferInheritanceInfo-occlusionQueryEnable-00056">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries">inherited queries</a> feature is not enabled, <code>occlusionQueryEnable</code> <strong>must</strong> be <code>VK_FALSE</code> </li> <li id="VUID-VkCommandBufferInheritanceInfo-queryFlags-00057">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries">inherited queries</a> feature is enabled, <code>queryFlags</code> <strong>must</strong> be a valid combination of <a href="#VkQueryControlFlagBits">VkQueryControlFlagBits</a> values </li> <li id="VUID-VkCommandBufferInheritanceInfo-pipelineStatistics-00058">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-pipelineStatisticsQuery">pipeline statistics queries</a> feature is not enabled, <code>pipelineStatistics</code> <strong>must</strong> be <code>0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkCommandBufferInheritanceInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO</code> </li> <li id="VUID-VkCommandBufferInheritanceInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkCommandBufferInheritanceInfo-commonparent">  Both of <code>framebuffer</code>, and <code>renderPass</code> that are valid handles <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_180">See Also</h4>  <p><code>VkBool32</code>, <a href="#VkCommandBufferBeginInfo">VkCommandBufferBeginInfo</a>, <a href="#VkFramebuffer">VkFramebuffer</a>, <a href="#VkQueryControlFlags">VkQueryControlFlags</a>, <a href="#VkQueryPipelineStatisticFlags">VkQueryPipelineStatisticFlags</a>, <a href="#VkRenderPass">VkRenderPass</a>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_180">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferInheritanceInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferInheritanceInfo</a></p>         <h3 id="_vkcommandpoolcreateinfo_3">VkCommandPoolCreateInfo(3)</h3>  <h4 id="_name_181">Name</h4>  <p>VkCommandPoolCreateInfo - Structure specifying parameters of a newly created command pool</p>    <h4 id="_c_specification_181">C Specification</h4>  <p>The <code>VkCommandPoolCreateInfo</code> structure is defined as:</p>  <pre id="VkCommandPoolCreateInfo" data-language="c++">typedef struct VkCommandPoolCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkCommandPoolCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
} VkCommandPoolCreateInfo;</pre>   <h4 id="_members_19">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is a bitmask of <a href="#VkCommandPoolCreateFlagBits">VkCommandPoolCreateFlagBits</a> indicating usage behavior for the pool and command buffers allocated from it. </li> <li> <code>queueFamilyIndex</code> designates a queue family as described in section <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-queueprops">Queue Family Properties</a>. All command buffers allocated from this command pool <strong>must</strong> be submitted on queues from the same queue family. </li> </ul>    <h4 id="_description_181">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkCommandPoolCreateInfo-queueFamilyIndex-00039">  <code>queueFamilyIndex</code> <strong>must</strong> be the index of a queue family available in the calling command’s <code>device</code> parameter </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkCommandPoolCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</code> </li> <li id="VUID-VkCommandPoolCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkCommandPoolCreateInfo-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkCommandPoolCreateFlagBits">VkCommandPoolCreateFlagBits</a> values </li> </ul>   </blockquote>   <h4 id="_see_also_181">See Also</h4>  <p><a href="#VkCommandPoolCreateFlags">VkCommandPoolCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateCommandPool">vkCreateCommandPool</a></p>    <h4 id="_document_notes_181">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPoolCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPoolCreateInfo</a></p>         <h3 id="_vkcomponentmapping_3">VkComponentMapping(3)</h3>  <h4 id="_name_182">Name</h4>  <p>VkComponentMapping - Structure specifying a color component mapping</p>    <h4 id="_c_specification_182">C Specification</h4>  <p>The <code>VkComponentMapping</code> structure is defined as:</p>  <pre id="VkComponentMapping" data-language="c++">typedef struct VkComponentMapping {
    VkComponentSwizzle    r;
    VkComponentSwizzle    g;
    VkComponentSwizzle    b;
    VkComponentSwizzle    a;
} VkComponentMapping;</pre>   <h4 id="_members_20">Members</h4>  <ul> <li> <code>r</code> is a <a href="#VkComponentSwizzle">VkComponentSwizzle</a> specifying the component value placed in the R component of the output vector. </li> <li> <code>g</code> is a <a href="#VkComponentSwizzle">VkComponentSwizzle</a> specifying the component value placed in the G component of the output vector. </li> <li> <code>b</code> is a <a href="#VkComponentSwizzle">VkComponentSwizzle</a> specifying the component value placed in the B component of the output vector. </li> <li> <code>A</code> is a <a href="#VkComponentSwizzle">VkComponentSwizzle</a> specifying the component value placed in the A component of the output vector. </li> </ul>    <h4 id="_description_182">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkComponentMapping-r-parameter">  <code>r</code> <strong>must</strong> be a valid <a href="#VkComponentSwizzle">VkComponentSwizzle</a> value </li> <li id="VUID-VkComponentMapping-g-parameter">  <code>g</code> <strong>must</strong> be a valid <a href="#VkComponentSwizzle">VkComponentSwizzle</a> value </li> <li id="VUID-VkComponentMapping-b-parameter">  <code>b</code> <strong>must</strong> be a valid <a href="#VkComponentSwizzle">VkComponentSwizzle</a> value </li> <li id="VUID-VkComponentMapping-a-parameter">  <code>a</code> <strong>must</strong> be a valid <a href="#VkComponentSwizzle">VkComponentSwizzle</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_182">See Also</h4>  <p><a href="#VkComponentSwizzle">VkComponentSwizzle</a>, <a href="#VkImageViewCreateInfo">VkImageViewCreateInfo</a></p>    <h4 id="_document_notes_182">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkComponentMapping">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkComponentMapping</a></p>         <h3 id="_vkcomputepipelinecreateinfo_3">VkComputePipelineCreateInfo(3)</h3>  <h4 id="_name_183">Name</h4>  <p>VkComputePipelineCreateInfo - Structure specifying parameters of a newly created compute pipeline</p>    <h4 id="_c_specification_183">C Specification</h4>  <p>The <code>VkComputePipelineCreateInfo</code> structure is defined as:</p>  <pre id="VkComputePipelineCreateInfo" data-language="c++">typedef struct VkComputePipelineCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkPipelineCreateFlags              flags;
    VkPipelineShaderStageCreateInfo    stage;
    VkPipelineLayout                   layout;
    VkPipeline                         basePipelineHandle;
    int32_t                            basePipelineIndex;
} VkComputePipelineCreateInfo;</pre>   <h4 id="_members_21">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is a bitmask of <a href="#VkPipelineCreateFlagBits">VkPipelineCreateFlagBits</a> specifying how the pipeline will be generated. </li> <li> <code>stage</code> is a <a href="#VkPipelineShaderStageCreateInfo">VkPipelineShaderStageCreateInfo</a> describing the compute shader. </li> <li> <code>layout</code> is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline. </li> <li> <code>basePipelineHandle</code> is a pipeline to derive from </li> <li> <code>basePipelineIndex</code> is an index into the <code>pCreateInfos</code> parameter to use as a pipeline to derive from </li> </ul>    <h4 id="_description_183">Description</h4>  <p>The parameters <code>basePipelineHandle</code> and <code>basePipelineIndex</code> are described in more detail in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-pipeline-derivatives">Pipeline Derivatives</a>.</p>   <p><code>stage</code> points to a structure of type <code>VkPipelineShaderStageCreateInfo</code>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkComputePipelineCreateInfo-flags-00697">  If <code>flags</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, and <code>basePipelineIndex</code> is -1, <code>basePipelineHandle</code> <strong>must</strong> be a valid handle to a compute <code>VkPipeline</code> </li> <li id="VUID-VkComputePipelineCreateInfo-flags-00698">  If <code>flags</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, and <code>basePipelineHandle</code> is <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>basePipelineIndex</code> <strong>must</strong> be a valid index into the calling command’s <code>pCreateInfos</code> parameter </li> <li id="VUID-VkComputePipelineCreateInfo-flags-00699">  If <code>flags</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, and <code>basePipelineIndex</code> is not -1, <code>basePipelineHandle</code> <strong>must</strong> be <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a> </li> <li id="VUID-VkComputePipelineCreateInfo-flags-00700">  If <code>flags</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, and <code>basePipelineHandle</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>basePipelineIndex</code> <strong>must</strong> be -1 </li> <li id="VUID-VkComputePipelineCreateInfo-stage-00701">  The <code>stage</code> member of <code>stage</code> <strong>must</strong> be <code>VK_SHADER_STAGE_COMPUTE_BIT</code> </li> <li id="VUID-VkComputePipelineCreateInfo-stage-00702">  The shader code for the entry point identified by <code>stage</code> and the rest of the state identified by this structure <strong>must</strong> adhere to the pipeline linking rules described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#interfaces">Shader Interfaces</a> chapter </li> <li id="VUID-VkComputePipelineCreateInfo-layout-00703">  <code>layout</code> <strong>must</strong> be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-pipelinelayout-consistency">consistent</a> with the layout of the compute shader specified in <code>stage</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkComputePipelineCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO</code> </li> <li id="VUID-VkComputePipelineCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkComputePipelineCreateInfo-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkPipelineCreateFlagBits">VkPipelineCreateFlagBits</a> values </li> <li id="VUID-VkComputePipelineCreateInfo-stage-parameter">  <code>stage</code> <strong>must</strong> be a valid <code>VkPipelineShaderStageCreateInfo</code> structure </li> <li id="VUID-VkComputePipelineCreateInfo-layout-parameter">  <code>layout</code> <strong>must</strong> be a valid <code>VkPipelineLayout</code> handle </li> <li id="VUID-VkComputePipelineCreateInfo-commonparent">  Both of <code>basePipelineHandle</code>, and <code>layout</code> that are valid handles <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_183">See Also</h4>  <p><a href="#VkPipeline">VkPipeline</a>, <a href="#VkPipelineCreateFlags">VkPipelineCreateFlags</a>, <a href="#VkPipelineLayout">VkPipelineLayout</a>, <a href="#VkPipelineShaderStageCreateInfo">VkPipelineShaderStageCreateInfo</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateComputePipelines">vkCreateComputePipelines</a></p>    <h4 id="_document_notes_183">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkComputePipelineCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkComputePipelineCreateInfo</a></p>         <h3 id="_vkcopydescriptorset_3">VkCopyDescriptorSet(3)</h3>  <h4 id="_name_184">Name</h4>  <p>VkCopyDescriptorSet - Structure specifying a copy descriptor set operation</p>    <h4 id="_c_specification_184">C Specification</h4>  <p>The <code>VkCopyDescriptorSet</code> structure is defined as:</p>  <pre id="VkCopyDescriptorSet" data-language="c++">typedef struct VkCopyDescriptorSet {
    VkStructureType    sType;
    const void*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet;</pre>   <h4 id="_members_22">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>srcSet</code>, <code>srcBinding</code>, and <code>srcArrayElement</code> are the source set, binding, and array element, respectively. </li> <li> <code>dstSet</code>, <code>dstBinding</code>, and <code>dstArrayElement</code> are the destination set, binding, and array element, respectively. </li> <li> <code>descriptorCount</code> is the number of descriptors to copy from the source to destination. If <code>descriptorCount</code> is greater than the number of remaining array elements in the source or destination binding, those affect consecutive bindings in a manner similar to <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a> above. </li> </ul>    <h4 id="_description_184">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkCopyDescriptorSet-srcBinding-00345">  <code>srcBinding</code> <strong>must</strong> be a valid binding within <code>srcSet</code> </li> <li id="VUID-VkCopyDescriptorSet-srcArrayElement-00346">  The sum of <code>srcArrayElement</code> and <code>descriptorCount</code> <strong>must</strong> be less than or equal to the number of array elements in the descriptor set binding specified by <code>srcBinding</code>, and all applicable consecutive bindings, as described by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive">html/vkspec.html#descriptorsets-updates-consecutive</a> </li> <li id="VUID-VkCopyDescriptorSet-dstBinding-00347">  <code>dstBinding</code> <strong>must</strong> be a valid binding within <code>dstSet</code> </li> <li id="VUID-VkCopyDescriptorSet-dstArrayElement-00348">  The sum of <code>dstArrayElement</code> and <code>descriptorCount</code> <strong>must</strong> be less than or equal to the number of array elements in the descriptor set binding specified by <code>dstBinding</code>, and all applicable consecutive bindings, as described by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive">html/vkspec.html#descriptorsets-updates-consecutive</a> </li> <li id="VUID-VkCopyDescriptorSet-srcSet-00349">  If <code>srcSet</code> is equal to <code>dstSet</code>, then the source and destination ranges of descriptors <strong>must</strong> not overlap, where the ranges <strong>may</strong> include array elements from consecutive bindings as described by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive">html/vkspec.html#descriptorsets-updates-consecutive</a> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkCopyDescriptorSet-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET</code> </li> <li id="VUID-VkCopyDescriptorSet-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkCopyDescriptorSet-srcSet-parameter">  <code>srcSet</code> <strong>must</strong> be a valid <code>VkDescriptorSet</code> handle </li> <li id="VUID-VkCopyDescriptorSet-dstSet-parameter">  <code>dstSet</code> <strong>must</strong> be a valid <code>VkDescriptorSet</code> handle </li> <li id="VUID-VkCopyDescriptorSet-commonparent">  Both of <code>dstSet</code>, and <code>srcSet</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_184">See Also</h4>  <p><a href="#VkDescriptorSet">VkDescriptorSet</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a></p>    <h4 id="_document_notes_184">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCopyDescriptorSet">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCopyDescriptorSet</a></p>         <h3 id="_vkdescriptorbufferinfo_3">VkDescriptorBufferInfo(3)</h3>  <h4 id="_name_185">Name</h4>  <p>VkDescriptorBufferInfo - Structure specifying descriptor buffer info</p>    <h4 id="_c_specification_185">C Specification</h4>  <p>The <code>VkDescriptorBufferInfo</code> structure is defined as:</p>  <pre id="VkDescriptorBufferInfo" data-language="c++">typedef struct VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo;</pre>   <h4 id="_members_23">Members</h4>  <ul> <li> <code>buffer</code> is the buffer resource. </li> <li> <code>offset</code> is the offset in bytes from the start of <code>buffer</code>. Access to buffer memory via this descriptor uses addressing that is relative to this starting offset. </li> <li> <code>range</code> is the size in bytes that is used for this descriptor update, or <code>VK_WHOLE_SIZE</code> to use the range from <code>offset</code> to the end of the buffer. </li> </ul>    <h4 id="_description_185">Description</h4> <blockquote> <h5 class="title">Note</h5>  <p>When setting <code>range</code> to <code>VK_WHOLE_SIZE</code>, the effective range <strong>must</strong> not be larger than the maximum range for the descriptor type (<a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxUniformBufferRange">maxUniformBufferRange</a> or <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxStorageBufferRange">maxStorageBufferRange</a>). This means that <code>VK_WHOLE_SIZE</code> is not typically useful in the common case where uniform buffer descriptors are suballocated from a buffer that is much larger than <code>maxUniformBufferRange</code>.</p>  </blockquote>  <p>For <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> and <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> descriptor types, <code>offset</code> is the base offset from which the dynamic offset is applied and <code>range</code> is the static size used for all dynamic offsets.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDescriptorBufferInfo-offset-00340">  <code>offset</code> <strong>must</strong> be less than the size of <code>buffer</code> </li> <li id="VUID-VkDescriptorBufferInfo-range-00341">  If <code>range</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>range</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkDescriptorBufferInfo-range-00342">  If <code>range</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>range</code> <strong>must</strong> be less than or equal to the size of <code>buffer</code> minus <code>offset</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkDescriptorBufferInfo-buffer-parameter">  <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> </ul>   </blockquote>   <h4 id="_see_also_185">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a>, <code>VkDeviceSize</code>, <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a></p>    <h4 id="_document_notes_185">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorBufferInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorBufferInfo</a></p>         <h3 id="_vkdescriptorimageinfo_3">VkDescriptorImageInfo(3)</h3>  <h4 id="_name_186">Name</h4>  <p>VkDescriptorImageInfo - Structure specifying descriptor image info</p>    <h4 id="_c_specification_186">C Specification</h4>  <p>The <code>VkDescriptorImageInfo</code> structure is defined as:</p>  <pre id="VkDescriptorImageInfo" data-language="c++">typedef struct VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo;</pre>   <h4 id="_members_24">Members</h4>  <ul> <li> <code>sampler</code> is a sampler handle, and is used in descriptor updates for types <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> and <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> if the binding being updated does not use immutable samplers. </li> <li> <code>imageView</code> is an image view handle, and is used in descriptor updates for types <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>. </li> <li> <code>imageLayout</code> is the layout that the image subresources accessible from <code>imageView</code> will be in at the time this descriptor is accessed. <code>imageLayout</code> is used in descriptor updates for types <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>. </li> </ul>    <h4 id="_description_186">Description</h4>  <p>Members of <code>VkDescriptorImageInfo</code> that are not used in an update (as described above) are ignored.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDescriptorImageInfo-imageLayout-00344">  <code>imageLayout</code> <strong>must</strong> match the actual <a href="#VkImageLayout">VkImageLayout</a> of each subresource accessible from <code>imageView</code> at the time this descriptor is accessed </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkDescriptorImageInfo-commonparent">  Both of <code>imageView</code>, and <code>sampler</code> that are valid handles <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_186">See Also</h4>  <p><a href="#VkImageLayout">VkImageLayout</a>, <a href="#VkImageView">VkImageView</a>, <a href="#VkSampler">VkSampler</a>, <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a></p>    <h4 id="_document_notes_186">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorImageInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorImageInfo</a></p>         <h3 id="_vkdescriptorpoolcreateinfo_3">VkDescriptorPoolCreateInfo(3)</h3>  <h4 id="_name_187">Name</h4>  <p>VkDescriptorPoolCreateInfo - Structure specifying parameters of a newly created descriptor pool</p>    <h4 id="_c_specification_187">C Specification</h4>  <p>Additional information about the pool is passed in an instance of the <code>VkDescriptorPoolCreateInfo</code> structure:</p>  <pre id="VkDescriptorPoolCreateInfo" data-language="c++">typedef struct VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    const void*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    const VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;</pre>   <h4 id="_members_25">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is a bitmask of <a href="#VkDescriptorPoolCreateFlagBits">VkDescriptorPoolCreateFlagBits</a> specifying certain supported operations on the pool. </li> <li> <code>maxSets</code> is the maximum number of descriptor sets that <strong>can</strong> be allocated from the pool. </li> <li> <code>poolSizeCount</code> is the number of elements in <code>pPoolSizes</code>. </li> <li> <code>pPoolSizes</code> is a pointer to an array of <code>VkDescriptorPoolSize</code> structures, each containing a descriptor type and number of descriptors of that type to be allocated in the pool. </li> </ul>    <h4 id="_description_187">Description</h4>  <p>If multiple <code>VkDescriptorPoolSize</code> structures appear in the <code>pPoolSizes</code> array then the pool will be created with enough storage for the total number of descriptors of each type.</p>   <p>Fragmentation of a descriptor pool is possible and <strong>may</strong> lead to descriptor set allocation failures. A failure due to fragmentation is defined as failing a descriptor set allocation despite the sum of all outstanding descriptor set allocations from the pool plus the requested allocation requiring no more than the total number of descriptors requested at pool creation. Implementations provide certain guarantees of when fragmentation <strong>must</strong> not cause allocation failure, as described below.</p>   <p>If a descriptor pool has not had any descriptor sets freed since it was created or most recently reset then fragmentation <strong>must</strong> not cause an allocation failure (note that this is always the case for a pool created without the <code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code> bit set). Additionally, if all sets allocated from the pool since it was created or most recently reset use the same number of descriptors (of each type) and the requested allocation also uses that same number of descriptors (of each type), then fragmentation <strong>must</strong> not cause an allocation failure.</p>   <p>If an allocation failure occurs due to fragmentation, an application <strong>can</strong> create an additional descriptor pool to perform further descriptor set allocations.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDescriptorPoolCreateInfo-maxSets-00301">  <code>maxSets</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkDescriptorPoolCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO</code> </li> <li id="VUID-VkDescriptorPoolCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkDescriptorPoolCreateInfo-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkDescriptorPoolCreateFlagBits">VkDescriptorPoolCreateFlagBits</a> values </li> <li id="VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter">  <code>pPoolSizes</code> <strong>must</strong> be a pointer to an array of <code>poolSizeCount</code> valid <code>VkDescriptorPoolSize</code> structures </li> <li id="VUID-VkDescriptorPoolCreateInfo-poolSizeCount-arraylength">  <code>poolSizeCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_187">See Also</h4>  <p><a href="#VkDescriptorPoolCreateFlags">VkDescriptorPoolCreateFlags</a>, <a href="#VkDescriptorPoolSize">VkDescriptorPoolSize</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateDescriptorPool">vkCreateDescriptorPool</a></p>    <h4 id="_document_notes_187">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPoolCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPoolCreateInfo</a></p>         <h3 id="_vkdescriptorpoolsize_3">VkDescriptorPoolSize(3)</h3>  <h4 id="_name_188">Name</h4>  <p>VkDescriptorPoolSize - Structure specifying descriptor pool size</p>    <h4 id="_c_specification_188">C Specification</h4>  <p>The <code>VkDescriptorPoolSize</code> structure is defined as:</p>  <pre id="VkDescriptorPoolSize" data-language="c++">typedef struct VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize;</pre>   <h4 id="_members_26">Members</h4>  <ul> <li> <code>type</code> is the type of descriptor. </li> <li> <code>descriptorCount</code> is the number of descriptors of that type to allocate. </li> </ul>    <h4 id="_description_188">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDescriptorPoolSize-descriptorCount-00302">  <code>descriptorCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkDescriptorPoolSize-type-parameter">  <code>type</code> <strong>must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_188">See Also</h4>  <p><a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>, <a href="#VkDescriptorType">VkDescriptorType</a></p>    <h4 id="_document_notes_188">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPoolSize">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPoolSize</a></p>         <h3 id="_vkdescriptorsetallocateinfo_3">VkDescriptorSetAllocateInfo(3)</h3>  <h4 id="_name_189">Name</h4>  <p>VkDescriptorSetAllocateInfo - Structure specifying the allocation parameters for descriptor sets</p>    <h4 id="_c_specification_189">C Specification</h4>  <p>The <code>VkDescriptorSetAllocateInfo</code> structure is defined as:</p>  <pre id="VkDescriptorSetAllocateInfo" data-language="c++">typedef struct VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    const VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo;</pre>   <h4 id="_members_27">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>descriptorPool</code> is the pool which the sets will be allocated from. </li> <li> <code>descriptorSetCount</code> determines the number of descriptor sets to be allocated from the pool. </li> <li> <code>pSetLayouts</code> is an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated. </li> </ul>    <h4 id="_description_189">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-00306">  <code>descriptorSetCount</code> <strong>must</strong> not be greater than the number of sets that are currently available for allocation in <code>descriptorPool</code> </li> <li id="VUID-VkDescriptorSetAllocateInfo-descriptorPool-00307">  <code>descriptorPool</code> <strong>must</strong> have enough free descriptor capacity remaining to allocate the descriptor sets of the specified layouts </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkDescriptorSetAllocateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO</code> </li> <li id="VUID-VkDescriptorSetAllocateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkDescriptorSetAllocateInfo-descriptorPool-parameter">  <code>descriptorPool</code> <strong>must</strong> be a valid <code>VkDescriptorPool</code> handle </li> <li id="VUID-VkDescriptorSetAllocateInfo-pSetLayouts-parameter">  <code>pSetLayouts</code> <strong>must</strong> be a pointer to an array of <code>descriptorSetCount</code> valid <code>VkDescriptorSetLayout</code> handles </li> <li id="VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength">  <code>descriptorSetCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkDescriptorSetAllocateInfo-commonparent">  Both of <code>descriptorPool</code>, and the elements of <code>pSetLayouts</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_189">See Also</h4>  <p><a href="#VkDescriptorPool">VkDescriptorPool</a>, <a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkAllocateDescriptorSets">vkAllocateDescriptorSets</a></p>    <h4 id="_document_notes_189">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetAllocateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetAllocateInfo</a></p>         <h3 id="_vkdescriptorsetlayoutbinding_3">VkDescriptorSetLayoutBinding(3)</h3>  <h4 id="_name_190">Name</h4>  <p>VkDescriptorSetLayoutBinding - Structure specifying a descriptor set layout binding</p>    <h4 id="_c_specification_190">C Specification</h4>  <p>The <code>VkDescriptorSetLayoutBinding</code> structure is defined as:</p>  <pre id="VkDescriptorSetLayoutBinding" data-language="c++">typedef struct VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    const VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;</pre>   <h4 id="_members_28">Members</h4>  <ul> <li> <code>binding</code> is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages. </li> <li> <code>descriptorType</code> is a <a href="#VkDescriptorType">VkDescriptorType</a> specifying which type of resource descriptors are used for this binding. </li> <li> <code>descriptorCount</code> is the number of descriptors contained in the binding, accessed in a shader as an array. If <code>descriptorCount</code> is zero this binding entry is reserved and the resource <strong>must</strong> not be accessed from any stage via this binding within any pipeline using the set layout. </li> <li> <p><code>stageFlags</code> member is a bitmask of <a href="#VkShaderStageFlagBits">VkShaderStageFlagBits</a> specifying which pipeline shader stages <strong>can</strong> access a resource for this binding. <code>VK_SHADER_STAGE_ALL</code> is a shorthand specifying that all defined shader stages, including any additional stages defined by extensions, <strong>can</strong> access the resource.</p>  <p>If a shader stage is not included in <code>stageFlags</code>, then a resource <strong>must</strong> not be accessed from that stage via this binding within any pipeline using the set layout. Other than input attachments which are limited to the fragment shader, there are no limitations on what combinations of stages <strong>can</strong> be used by a descriptor binding, and in particular a binding <strong>can</strong> be used by both graphics stages and the compute stage.</p>  </li> </ul>    <h4 id="_description_190">Description</h4>  <ul> <li> <code>pImmutableSamplers</code> affects initialization of samplers. If <code>descriptorType</code> specifies a <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> type descriptor, then <code>pImmutableSamplers</code> <strong>can</strong> be used to initialize a set of <em>immutable samplers</em>. Immutable samplers are permanently bound into the set layout; later binding a sampler into an immutable sampler slot in a descriptor set is not allowed. If <code>pImmutableSamplers</code> is not <code>NULL</code>, then it is considered to be a pointer to an array of sampler handles that will be consumed by the set layout and used for the corresponding binding. If <code>pImmutableSamplers</code> is <code>NULL</code>, then the sampler slots are dynamic and sampler handles <strong>must</strong> be bound into descriptor sets using this layout. If <code>descriptorType</code> is not one of these descriptor types, then <code>pImmutableSamplers</code> is ignored. </li> </ul>   <p>The above layout definition allows the descriptor bindings to be specified sparsely such that not all binding numbers between 0 and the maximum binding number need to be specified in the <code>pBindings</code> array. Bindings that are not specified have a <code>descriptorCount</code> and <code>stageFlags</code> of zero, and the <code>descriptorType</code> is treated as undefined. However, all binding numbers between 0 and the maximum binding number in the <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>pBindings</code> array <strong>may</strong> consume memory in the descriptor set layout even if not all descriptor bindings are used, though it <strong>should</strong> not consume additional memory from the descriptor pool.</p>  <blockquote> <h5 class="title">Note</h5>  <p>The maximum binding number specified <strong>should</strong> be as compact as possible to avoid wasted memory.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDescriptorSetLayoutBinding-descriptorType-00282">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and <code>descriptorCount</code> is not <code>0</code> and <code>pImmutableSamplers</code> is not <code>NULL</code>, <code>pImmutableSamplers</code> <strong>must</strong> be a pointer to an array of <code>descriptorCount</code> valid <code>VkSampler</code> handles </li> <li id="VUID-VkDescriptorSetLayoutBinding-descriptorCount-00283">  If <code>descriptorCount</code> is not <code>0</code>, <code>stageFlags</code> <strong>must</strong> be a valid combination of <a href="#VkShaderStageFlagBits">VkShaderStageFlagBits</a> values </li> <li id="VUID-VkDescriptorSetLayoutBinding-descriptorType-01510">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> and <code>descriptorCount</code> is not <code>0</code>, then <code>stageFlags</code> <strong>must</strong> be <code>0</code> or <code>VK_SHADER_STAGE_FRAGMENT_BIT</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter">  <code>descriptorType</code> <strong>must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_190">See Also</h4>  <p><a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>, <a href="#VkDescriptorType">VkDescriptorType</a>, <a href="#VkSampler">VkSampler</a>, <a href="#VkShaderStageFlags">VkShaderStageFlags</a></p>    <h4 id="_document_notes_190">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetLayoutBinding">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetLayoutBinding</a></p>         <h3 id="_vkdescriptorsetlayoutcreateinfo_3">VkDescriptorSetLayoutCreateInfo(3)</h3>  <h4 id="_name_191">Name</h4>  <p>VkDescriptorSetLayoutCreateInfo - Structure specifying parameters of a newly created descriptor set layout</p>    <h4 id="_c_specification_191">C Specification</h4>  <p>Information about the descriptor set layout is passed in an instance of the <code>VkDescriptorSetLayoutCreateInfo</code> structure:</p>  <pre id="VkDescriptorSetLayoutCreateInfo" data-language="c++">typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    const void*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    const VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;</pre>   <h4 id="_members_29">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is a bitmask specifying options for descriptor set layout creation. </li> <li> <code>bindingCount</code> is the number of elements in <code>pBindings</code>. </li> <li> <code>pBindings</code> is a pointer to an array of <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a> structures. </li> </ul>    <h4 id="_description_191">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDescriptorSetLayoutCreateInfo-binding-00279">  The <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a>::<code>binding</code> members of the elements of the <code>pBindings</code> array <strong>must</strong> each have different values. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkDescriptorSetLayoutCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO</code> </li> <li id="VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkDescriptorSetLayoutCreateFlagBits">VkDescriptorSetLayoutCreateFlagBits</a> values </li> <li id="VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter">  If <code>bindingCount</code> is not <code>0</code>, <code>pBindings</code> <strong>must</strong> be a pointer to an array of <code>bindingCount</code> valid <code>VkDescriptorSetLayoutBinding</code> structures </li> </ul>   </blockquote>   <h4 id="_see_also_191">See Also</h4>  <p><a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a>, <a href="#VkDescriptorSetLayoutCreateFlags">VkDescriptorSetLayoutCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateDescriptorSetLayout">vkCreateDescriptorSetLayout</a></p>    <h4 id="_document_notes_191">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetLayoutCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetLayoutCreateInfo</a></p>         <h3 id="_vkdevicecreateinfo_3">VkDeviceCreateInfo(3)</h3>  <h4 id="_name_192">Name</h4>  <p>VkDeviceCreateInfo - Structure specifying parameters of a newly created device</p>    <h4 id="_c_specification_192">C Specification</h4>  <p>The <code>VkDeviceCreateInfo</code> structure is defined as:</p>  <pre id="VkDeviceCreateInfo" data-language="c++">typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;</pre>   <h4 id="_members_30">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>queueCreateInfoCount</code> is the unsigned integer size of the <code>pQueueCreateInfos</code> array. Refer to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-queue-creation">Queue Creation</a> section below for further details. </li> <li> <code>pQueueCreateInfos</code> is a pointer to an array of <a href="#VkDeviceQueueCreateInfo">VkDeviceQueueCreateInfo</a> structures describing the queues that are requested to be created along with the logical device. Refer to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-queue-creation">Queue Creation</a> section below for further details. </li> <li> <code>enabledLayerCount</code> is deprecated and ignored. </li> <li> <code>ppEnabledLayerNames</code> is deprecated and ignored. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#extended-functionality-device-layer-deprecation">Device Layer Deprecation</a>. </li> <li> <code>enabledExtensionCount</code> is the number of device extensions to enable. </li> <li> <code>ppEnabledExtensionNames</code> is a pointer to an array of <code>enabledExtensionCount</code> null-terminated UTF-8 strings containing the names of extensions to enable for the created device. See the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#extended-functionality-extensions">Extensions</a> section for further details. </li> <li> <code>pEnabledFeatures</code> is <code>NULL</code> or a pointer to a <a href="#VkPhysicalDeviceFeatures">VkPhysicalDeviceFeatures</a> structure that contains boolean indicators of all the features to be enabled. Refer to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features">Features</a> section for further details. </li> </ul>    <h4 id="_description_192">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDeviceCreateInfo-queueFamilyIndex-00372">  The <code>queueFamilyIndex</code> member of any given element of <code>pQueueCreateInfos</code> <strong>must</strong> be unique within <code>pQueueCreateInfos</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkDeviceCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</code> </li> <li id="VUID-VkDeviceCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkDeviceCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkDeviceCreateInfo-pQueueCreateInfos-parameter">  <code>pQueueCreateInfos</code> <strong>must</strong> be a pointer to an array of <code>queueCreateInfoCount</code> valid <code>VkDeviceQueueCreateInfo</code> structures </li> <li id="VUID-VkDeviceCreateInfo-ppEnabledLayerNames-parameter">  If <code>enabledLayerCount</code> is not <code>0</code>, <code>ppEnabledLayerNames</code> <strong>must</strong> be a pointer to an array of <code>enabledLayerCount</code> null-terminated UTF-8 strings </li> <li id="VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-parameter">  If <code>enabledExtensionCount</code> is not <code>0</code>, <code>ppEnabledExtensionNames</code> <strong>must</strong> be a pointer to an array of <code>enabledExtensionCount</code> null-terminated UTF-8 strings </li> <li id="VUID-VkDeviceCreateInfo-pEnabledFeatures-parameter">  If <code>pEnabledFeatures</code> is not <code>NULL</code>, <code>pEnabledFeatures</code> <strong>must</strong> be a pointer to a valid <code>VkPhysicalDeviceFeatures</code> structure </li> <li id="VUID-VkDeviceCreateInfo-queueCreateInfoCount-arraylength">  <code>queueCreateInfoCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_192">See Also</h4>  <p><a href="#VkDeviceCreateFlags">VkDeviceCreateFlags</a>, <a href="#VkDeviceQueueCreateInfo">VkDeviceQueueCreateInfo</a>, <a href="#VkPhysicalDeviceFeatures">VkPhysicalDeviceFeatures</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateDevice">vkCreateDevice</a></p>    <h4 id="_document_notes_192">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceCreateInfo</a></p>         <h3 id="_vkdevicequeuecreateinfo_3">VkDeviceQueueCreateInfo(3)</h3>  <h4 id="_name_193">Name</h4>  <p>VkDeviceQueueCreateInfo - Structure specifying parameters of a newly created device queue</p>    <h4 id="_c_specification_193">C Specification</h4>  <p>The <code>VkDeviceQueueCreateInfo</code> structure is defined as:</p>  <pre id="VkDeviceQueueCreateInfo" data-language="c++">typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    const float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;</pre>   <h4 id="_members_31">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>queueFamilyIndex</code> is an unsigned integer indicating the index of the queue family to create on this device. This index corresponds to the index of an element of the <code>pQueueFamilyProperties</code> array that was returned by <code>vkGetPhysicalDeviceQueueFamilyProperties</code>. </li> <li> <code>queueCount</code> is an unsigned integer specifying the number of queues to create in the queue family indicated by <code>queueFamilyIndex</code>. </li> <li> <code>pQueuePriorities</code> is an array of <code>queueCount</code> normalized floating point values, specifying priorities of work that will be submitted to each created queue. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-priority">Queue Priority</a> for more information. </li> </ul>    <h4 id="_description_193">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDeviceQueueCreateInfo-queueFamilyIndex-00381">  <code>queueFamilyIndex</code> <strong>must</strong> be less than <code>pQueueFamilyPropertyCount</code> returned by <code>vkGetPhysicalDeviceQueueFamilyProperties</code> </li> <li id="VUID-VkDeviceQueueCreateInfo-queueCount-00382">  <code>queueCount</code> <strong>must</strong> be less than or equal to the <code>queueCount</code> member of the <code>VkQueueFamilyProperties</code> structure, as returned by <code>vkGetPhysicalDeviceQueueFamilyProperties</code> in the <code>pQueueFamilyProperties</code>[<code>queueFamilyIndex</code>] </li> <li id="VUID-VkDeviceQueueCreateInfo-pQueuePriorities-00383">  Each element of <code>pQueuePriorities</code> <strong>must</strong> be between <code>0.0</code> and <code>1.0</code> inclusive </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkDeviceQueueCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</code> </li> <li id="VUID-VkDeviceQueueCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkDeviceQueueCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkDeviceQueueCreateInfo-pQueuePriorities-parameter">  <code>pQueuePriorities</code> <strong>must</strong> be a pointer to an array of <code>queueCount</code> <code>float</code> values </li> <li id="VUID-VkDeviceQueueCreateInfo-queueCount-arraylength">  <code>queueCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_193">See Also</h4>  <p><a href="#VkDeviceCreateInfo">VkDeviceCreateInfo</a>, <a href="#VkDeviceQueueCreateFlags">VkDeviceQueueCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_193">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceQueueCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceQueueCreateInfo</a></p>         <h3 id="_vkdispatchindirectcommand_3">VkDispatchIndirectCommand(3)</h3>  <h4 id="_name_194">Name</h4>  <p>VkDispatchIndirectCommand - Structure specifying a dispatch indirect command</p>    <h4 id="_c_specification_194">C Specification</h4>  <p>The <code>VkDispatchIndirectCommand</code> structure is defined as:</p>  <pre id="VkDispatchIndirectCommand" data-language="c++">typedef struct VkDispatchIndirectCommand {
    uint32_t    x;
    uint32_t    y;
    uint32_t    z;
} VkDispatchIndirectCommand;</pre>   <h4 id="_members_32">Members</h4>  <ul> <li> <code>x</code> is the number of local workgroups to dispatch in the X dimension. </li> <li> <code>y</code> is the number of local workgroups to dispatch in the Y dimension. </li> <li> <code>z</code> is the number of local workgroups to dispatch in the Z dimension. </li> </ul>    <h4 id="_description_194">Description</h4>  <p>The members of <code>VkDispatchIndirectCommand</code> have the same meaning as the corresponding parameters of <a href="#vkCmdDispatch">vkCmdDispatch</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDispatchIndirectCommand-x-00417">  <code>x</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxComputeWorkGroupCount</code>[0] </li> <li id="VUID-VkDispatchIndirectCommand-y-00418">  <code>y</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxComputeWorkGroupCount</code>[1] </li> <li id="VUID-VkDispatchIndirectCommand-z-00419">  <code>z</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxComputeWorkGroupCount</code>[2] </li> </ul>   </blockquote>   <h4 id="_see_also_194">See Also</h4>  <p><a href="#vkCmdDispatchIndirect">vkCmdDispatchIndirect</a></p>    <h4 id="_document_notes_194">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDispatchIndirectCommand">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDispatchIndirectCommand</a></p>         <h3 id="_vkdrawindexedindirectcommand_3">VkDrawIndexedIndirectCommand(3)</h3>  <h4 id="_name_195">Name</h4>  <p>VkDrawIndexedIndirectCommand - Structure specifying a draw indexed indirect command</p>    <h4 id="_c_specification_195">C Specification</h4>  <p>The <code>VkDrawIndexedIndirectCommand</code> structure is defined as:</p>  <pre id="VkDrawIndexedIndirectCommand" data-language="c++">typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;</pre>   <h4 id="_members_33">Members</h4>  <ul> <li> <code>indexCount</code> is the number of vertices to draw. </li> <li> <code>instanceCount</code> is the number of instances to draw. </li> <li> <code>firstIndex</code> is the base index within the index buffer. </li> <li> <code>vertexOffset</code> is the value added to the vertex index before indexing into the vertex buffer. </li> <li> <code>firstInstance</code> is the instance ID of the first instance to draw. </li> </ul>    <h4 id="_description_195">Description</h4>  <p>The members of <code>VkDrawIndexedIndirectCommand</code> have the same meaning as the similarly named parameters of <a href="#vkCmdDrawIndexed">vkCmdDrawIndexed</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDrawIndexedIndirectCommand-None-00552">  For a given vertex buffer binding, any attribute data fetched <strong>must</strong> be entirely contained within the corresponding vertex buffer binding, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">html/vkspec.html#fxvertex-input</a> </li> <li id="VUID-VkDrawIndexedIndirectCommand-indexSize-00553">  (<code>indexSize</code> * (<code>firstIndex</code> + <code>indexCount</code>) + <code>offset</code>) <strong>must</strong> be less than or equal to the size of the currently bound index buffer, with <code>indexSize</code> being based on the type specified by <code>indexType</code>, where the index buffer, <code>indexType</code>, and <code>offset</code> are specified via <code>vkCmdBindIndexBuffer</code> </li> <li id="VUID-VkDrawIndexedIndirectCommand-firstInstance-00554">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a> feature is not enabled, <code>firstInstance</code> <strong>must</strong> be <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_195">See Also</h4>  <p><a href="#vkCmdDrawIndexedIndirect">vkCmdDrawIndexedIndirect</a></p>    <h4 id="_document_notes_195">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDrawIndexedIndirectCommand">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDrawIndexedIndirectCommand</a></p>         <h3 id="_vkdrawindirectcommand_3">VkDrawIndirectCommand(3)</h3>  <h4 id="_name_196">Name</h4>  <p>VkDrawIndirectCommand - Structure specifying a draw indirect command</p>    <h4 id="_c_specification_196">C Specification</h4>  <p>The <code>VkDrawIndirectCommand</code> structure is defined as:</p>  <pre id="VkDrawIndirectCommand" data-language="c++">typedef struct VkDrawIndirectCommand {
    uint32_t    vertexCount;
    uint32_t    instanceCount;
    uint32_t    firstVertex;
    uint32_t    firstInstance;
} VkDrawIndirectCommand;</pre>   <h4 id="_members_34">Members</h4>  <ul> <li> <code>vertexCount</code> is the number of vertices to draw. </li> <li> <code>instanceCount</code> is the number of instances to draw. </li> <li> <code>firstVertex</code> is the index of the first vertex to draw. </li> <li> <code>firstInstance</code> is the instance ID of the first instance to draw. </li> </ul>    <h4 id="_description_196">Description</h4>  <p>The members of <code>VkDrawIndirectCommand</code> have the same meaning as the similarly named parameters of <a href="#vkCmdDraw">vkCmdDraw</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkDrawIndirectCommand-None-00500">  For a given vertex buffer binding, any attribute data fetched <strong>must</strong> be entirely contained within the corresponding vertex buffer binding, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">html/vkspec.html#fxvertex-input</a> </li> <li id="VUID-VkDrawIndirectCommand-firstInstance-00501">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a> feature is not enabled, <code>firstInstance</code> <strong>must</strong> be <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_196">See Also</h4>  <p><a href="#vkCmdDrawIndirect">vkCmdDrawIndirect</a></p>    <h4 id="_document_notes_196">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDrawIndirectCommand">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDrawIndirectCommand</a></p>         <h3 id="_vkeventcreateinfo_3">VkEventCreateInfo(3)</h3>  <h4 id="_name_197">Name</h4>  <p>VkEventCreateInfo - Structure specifying parameters of a newly created event</p>    <h4 id="_c_specification_197">C Specification</h4>  <p>The <code>VkEventCreateInfo</code> structure is defined as:</p>  <pre id="VkEventCreateInfo" data-language="c++">typedef struct VkEventCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkEventCreateFlags    flags;
} VkEventCreateInfo;</pre>   <h4 id="_members_35">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> </ul>    <h4 id="_description_197">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkEventCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_EVENT_CREATE_INFO</code> </li> <li id="VUID-VkEventCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkEventCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_197">See Also</h4>  <p><a href="#VkEventCreateFlags">VkEventCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateEvent">vkCreateEvent</a></p>    <h4 id="_document_notes_197">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkEventCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkEventCreateInfo</a></p>         <h3 id="_vkextensionproperties_3">VkExtensionProperties(3)</h3>  <h4 id="_name_198">Name</h4>  <p>VkExtensionProperties - Structure specifying a extension properties</p>    <h4 id="_c_specification_198">C Specification</h4>  <p>The <code>VkExtensionProperties</code> structure is defined as:</p>  <pre id="VkExtensionProperties" data-language="c++">typedef struct VkExtensionProperties {
    char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
} VkExtensionProperties;</pre>   <h4 id="_members_36">Members</h4>  <ul> <li> <code>extensionName</code> is a null-terminated string specifying the name of the extension. </li> <li> <code>specVersion</code> is the version of this extension. It is an integer, incremented with backward compatible changes. </li> </ul>       <h4 id="_see_also_198">See Also</h4>  <p><a href="#vkEnumerateDeviceExtensionProperties">vkEnumerateDeviceExtensionProperties</a>, <a href="#vkEnumerateInstanceExtensionProperties">vkEnumerateInstanceExtensionProperties</a></p>    <h4 id="_document_notes_198">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkExtensionProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkExtensionProperties</a></p>         <h3 id="_vkextent2d_3">VkExtent2D(3)</h3>  <h4 id="_name_199">Name</h4>  <p>VkExtent2D - Structure specifying a two-dimensional extent</p>    <h4 id="_c_specification_199">C Specification</h4>  <p>A two-dimensional extent is defined by the structure:</p>  <pre id="VkExtent2D" data-language="c++">typedef struct VkExtent2D {
    uint32_t    width;
    uint32_t    height;
} VkExtent2D;</pre>   <h4 id="_members_37">Members</h4>  <ul> <li> <code>width</code> is the width of the extent. </li> <li> <code>height</code> is the height of the extent. </li> </ul>       <h4 id="_see_also_199">See Also</h4>  <p><a href="#VkRect2D">VkRect2D</a>, <a href="#vkGetRenderAreaGranularity">vkGetRenderAreaGranularity</a></p>    <h4 id="_document_notes_199">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkExtent2D">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkExtent2D</a></p>         <h3 id="_vkextent3d_3">VkExtent3D(3)</h3>  <h4 id="_name_200">Name</h4>  <p>VkExtent3D - Structure specifying a three-dimensional extent</p>    <h4 id="_c_specification_200">C Specification</h4>  <p>A three-dimensional extent is defined by the structure:</p>  <pre id="VkExtent3D" data-language="c++">typedef struct VkExtent3D {
    uint32_t    width;
    uint32_t    height;
    uint32_t    depth;
} VkExtent3D;</pre>   <h4 id="_members_38">Members</h4>  <ul> <li> <code>width</code> is the width of the extent. </li> <li> <code>height</code> is the height of the extent. </li> <li> <code>depth</code> is the depth of the extent. </li> </ul>       <h4 id="_see_also_200">See Also</h4>  <p><a href="#VkBufferImageCopy">VkBufferImageCopy</a>, <a href="#VkImageCopy">VkImageCopy</a>, <a href="#VkImageCreateInfo">VkImageCreateInfo</a>, <a href="#VkImageFormatProperties">VkImageFormatProperties</a>, <a href="#VkImageResolve">VkImageResolve</a>, <a href="#VkQueueFamilyProperties">VkQueueFamilyProperties</a>, <a href="#VkSparseImageFormatProperties">VkSparseImageFormatProperties</a>, <a href="#VkSparseImageMemoryBind">VkSparseImageMemoryBind</a></p>    <h4 id="_document_notes_200">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkExtent3D">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkExtent3D</a></p>         <h3 id="_vkfencecreateinfo_3">VkFenceCreateInfo(3)</h3>  <h4 id="_name_201">Name</h4>  <p>VkFenceCreateInfo - Structure specifying parameters of a newly created fence</p>    <h4 id="_c_specification_201">C Specification</h4>  <p>The <code>VkFenceCreateInfo</code> structure is defined as:</p>  <pre id="VkFenceCreateInfo" data-language="c++">typedef struct VkFenceCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkFenceCreateFlags    flags;
} VkFenceCreateInfo;</pre>   <h4 id="_members_39">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is a bitmask of <a href="#VkFenceCreateFlagBits">VkFenceCreateFlagBits</a> specifying the initial state and behavior of the fence. </li> </ul>    <h4 id="_description_201">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkFenceCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_FENCE_CREATE_INFO</code> </li> <li id="VUID-VkFenceCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkFenceCreateInfo-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkFenceCreateFlagBits">VkFenceCreateFlagBits</a> values </li> </ul>   </blockquote>   <h4 id="_see_also_201">See Also</h4>  <p><a href="#VkFenceCreateFlags">VkFenceCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateFence">vkCreateFence</a></p>    <h4 id="_document_notes_201">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFenceCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFenceCreateInfo</a></p>         <h3 id="_vkformatproperties_3">VkFormatProperties(3)</h3>  <h4 id="_name_202">Name</h4>  <p>VkFormatProperties - Structure specifying image format properties</p>    <h4 id="_c_specification_202">C Specification</h4>  <p>The <code>VkFormatProperties</code> structure is defined as:</p>  <pre id="VkFormatProperties" data-language="c++">typedef struct VkFormatProperties {
    VkFormatFeatureFlags    linearTilingFeatures;
    VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatFeatureFlags    bufferFeatures;
} VkFormatProperties;</pre>   <h4 id="_members_40">Members</h4>  <ul> <li> <code>linearTilingFeatures</code> is a bitmask of <a href="#VkFormatFeatureFlagBits">VkFormatFeatureFlagBits</a> specifying features supported by images created with a <code>tiling</code> parameter of <code>VK_IMAGE_TILING_LINEAR</code>. </li> <li> <code>optimalTilingFeatures</code> is a bitmask of <a href="#VkFormatFeatureFlagBits">VkFormatFeatureFlagBits</a> specifying features supported by images created with a <code>tiling</code> parameter of <code>VK_IMAGE_TILING_OPTIMAL</code>. </li> <li> <code>bufferFeatures</code> is a bitmask of <a href="#VkFormatFeatureFlagBits">VkFormatFeatureFlagBits</a> specifying features supported by buffers. </li> </ul>    <h4 id="_description_202">Description</h4> <blockquote> <h5 class="title">Note</h5>  <p>If no format feature flags are supported, then the only possible use would be image transfers - which alone are not useful. As such, if no format feature flags are supported, the format itself is not supported, and images of that format cannot be created.</p>  </blockquote>  <p>If <code>format</code> is a block-compression format, then buffers <strong>must</strong> not support any features for the format.</p>    <h4 id="_see_also_202">See Also</h4>  <p><a href="#VkFormatFeatureFlags">VkFormatFeatureFlags</a>, <a href="#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a></p>    <h4 id="_document_notes_202">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFormatProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFormatProperties</a></p>         <h3 id="_vkframebuffercreateinfo_3">VkFramebufferCreateInfo(3)</h3>  <h4 id="_name_203">Name</h4>  <p>VkFramebufferCreateInfo - Structure specifying parameters of a newly created framebuffer</p>    <h4 id="_c_specification_203">C Specification</h4>  <p>The <code>VkFramebufferCreateInfo</code> structure is defined as:</p>  <pre id="VkFramebufferCreateInfo" data-language="c++">typedef struct VkFramebufferCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkFramebufferCreateFlags    flags;
    VkRenderPass                renderPass;
    uint32_t                    attachmentCount;
    const VkImageView*          pAttachments;
    uint32_t                    width;
    uint32_t                    height;
    uint32_t                    layers;
} VkFramebufferCreateInfo;</pre>   <h4 id="_members_41">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>renderPass</code> is a render pass that defines what render passes the framebuffer will be compatible with. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">Render Pass Compatibility</a> for details. </li> <li> <code>attachmentCount</code> is the number of attachments. </li> <li> <code>pAttachments</code> is an array of <code>VkImageView</code> handles, each of which will be used as the corresponding attachment in a render pass instance. </li> <li> <code>width</code>, <code>height</code> and <code>layers</code> define the dimensions of the framebuffer. </li> </ul>    <h4 id="_description_203">Description</h4>  <p>Image subresources used as attachments <strong>must</strong> not be accessed in any other way for the duration of a render pass instance.</p>  <blockquote> <h5 class="title">Note</h5>  <p>This restriction means that the render pass has full knowledge of all uses of all of the attachments, so that the implementation is able to make correct decisions about when and how to perform layout transitions, when to overlap execution of subpasses, etc.</p>  </blockquote>  <p>It is legal for a subpass to use no color or depth/stencil attachments, and rather use shader side effects such as image stores and atomics to produce an output. In this case, the subpass continues to use the <code>width</code>, <code>height</code>, and <code>layers</code> of the framebuffer to define the dimensions of the rendering area, and the <code>rasterizationSamples</code> from each pipeline’s <a href="#VkPipelineMultisampleStateCreateInfo">VkPipelineMultisampleStateCreateInfo</a> to define the number of samples used in rasterization; however, if <a href="#VkPhysicalDeviceFeatures">VkPhysicalDeviceFeatures</a>::<code>variableMultisampleRate</code> is <code>VK_FALSE</code>, then all pipelines to be bound with a given zero-attachment subpass <strong>must</strong> have the same value for <a href="#VkPipelineMultisampleStateCreateInfo">VkPipelineMultisampleStateCreateInfo</a>::<code>rasterizationSamples</code>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkFramebufferCreateInfo-attachmentCount-00876">  <code>attachmentCount</code> <strong>must</strong> be equal to the attachment count specified in <code>renderPass</code> </li> <li id="VUID-VkFramebufferCreateInfo-pAttachments-00877">  Any given element of <code>pAttachments</code> that is used as a color attachment or resolve attachment by <code>renderPass</code> <strong>must</strong> have been created with a <code>usage</code> value including <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code> </li> <li id="VUID-VkFramebufferCreateInfo-pAttachments-00878">  Any given element of <code>pAttachments</code> that is used as a depth/stencil attachment by <code>renderPass</code> <strong>must</strong> have been created with a <code>usage</code> value including <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code> </li> <li id="VUID-VkFramebufferCreateInfo-pAttachments-00879">  Any given element of <code>pAttachments</code> that is used as an input attachment by <code>renderPass</code> <strong>must</strong> have been created with a <code>usage</code> value including <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> </li> <li id="VUID-VkFramebufferCreateInfo-pAttachments-00880">  Any given element of <code>pAttachments</code> <strong>must</strong> have been created with an <a href="#VkFormat">VkFormat</a> value that matches the <a href="#VkFormat">VkFormat</a> specified by the corresponding <code>VkAttachmentDescription</code> in <code>renderPass</code> </li> <li id="VUID-VkFramebufferCreateInfo-pAttachments-00881">  Any given element of <code>pAttachments</code> <strong>must</strong> have been created with a <code>samples</code> value that matches the <code>samples</code> value specified by the corresponding <code>VkAttachmentDescription</code> in <code>renderPass</code> </li> <li id="VUID-VkFramebufferCreateInfo-pAttachments-00882">  Any given element of <code>pAttachments</code> <strong>must</strong> have dimensions at least as large as the corresponding framebuffer dimension </li> <li id="VUID-VkFramebufferCreateInfo-pAttachments-00883">  Any given element of <code>pAttachments</code> <strong>must</strong> only specify a single mip level </li> <li id="VUID-VkFramebufferCreateInfo-pAttachments-00884">  Any given element of <code>pAttachments</code> <strong>must</strong> have been created with the identity swizzle </li> <li id="VUID-VkFramebufferCreateInfo-width-00885">  <code>width</code> <strong>must</strong> be greater than <code>0</code>. </li> <li id="VUID-VkFramebufferCreateInfo-width-00886">  <code>width</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxFramebufferWidth</code> </li> <li id="VUID-VkFramebufferCreateInfo-height-00887">  <code>height</code> <strong>must</strong> be greater than <code>0</code>. </li> <li id="VUID-VkFramebufferCreateInfo-height-00888">  <code>height</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxFramebufferHeight</code> </li> <li id="VUID-VkFramebufferCreateInfo-layers-00889">  <code>layers</code> <strong>must</strong> be greater than <code>0</code>. </li> <li id="VUID-VkFramebufferCreateInfo-layers-00890">  <code>layers</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxFramebufferLayers</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkFramebufferCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO</code> </li> <li id="VUID-VkFramebufferCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkFramebufferCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkFramebufferCreateInfo-renderPass-parameter">  <code>renderPass</code> <strong>must</strong> be a valid <code>VkRenderPass</code> handle </li> <li id="VUID-VkFramebufferCreateInfo-pAttachments-parameter">  If <code>attachmentCount</code> is not <code>0</code>, <code>pAttachments</code> <strong>must</strong> be a pointer to an array of <code>attachmentCount</code> valid <code>VkImageView</code> handles </li> <li id="VUID-VkFramebufferCreateInfo-commonparent">  Both of <code>renderPass</code>, and the elements of <code>pAttachments</code> that are valid handles <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_203">See Also</h4>  <p><a href="#VkFramebufferCreateFlags">VkFramebufferCreateFlags</a>, <a href="#VkImageView">VkImageView</a>, <a href="#VkRenderPass">VkRenderPass</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateFramebuffer">vkCreateFramebuffer</a></p>    <h4 id="_document_notes_203">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFramebufferCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFramebufferCreateInfo</a></p>         <h3 id="_vkgraphicspipelinecreateinfo_3">VkGraphicsPipelineCreateInfo(3)</h3>  <h4 id="_name_204">Name</h4>  <p>VkGraphicsPipelineCreateInfo - Structure specifying parameters of a newly created graphics pipeline</p>    <h4 id="_c_specification_204">C Specification</h4>  <p>The <code>VkGraphicsPipelineCreateInfo</code> structure is defined as:</p>  <pre id="VkGraphicsPipelineCreateInfo" data-language="c++">typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType                                  sType;
    const void*                                      pNext;
    VkPipelineCreateFlags                            flags;
    uint32_t                                         stageCount;
    const VkPipelineShaderStageCreateInfo*           pStages;
    const VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    const VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
    const VkPipelineTessellationStateCreateInfo*     pTessellationState;
    const VkPipelineViewportStateCreateInfo*         pViewportState;
    const VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
    const VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
    const VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    const VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    const VkPipelineDynamicStateCreateInfo*          pDynamicState;
    VkPipelineLayout                                 layout;
    VkRenderPass                                     renderPass;
    uint32_t                                         subpass;
    VkPipeline                                       basePipelineHandle;
    int32_t                                          basePipelineIndex;
} VkGraphicsPipelineCreateInfo;</pre>   <h4 id="_members_42">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is a bitmask of <a href="#VkPipelineCreateFlagBits">VkPipelineCreateFlagBits</a> specifying how the pipeline will be generated. </li> <li> <code>stageCount</code> is the number of entries in the <code>pStages</code> array. </li> <li> <code>pStages</code> is an array of size <code>stageCount</code> structures of type <a href="#VkPipelineShaderStageCreateInfo">VkPipelineShaderStageCreateInfo</a> describing the set of the shader stages to be included in the graphics pipeline. </li> <li> <code>pVertexInputState</code> is a pointer to an instance of the <a href="#VkPipelineVertexInputStateCreateInfo">VkPipelineVertexInputStateCreateInfo</a> structure. </li> <li> <code>pInputAssemblyState</code> is a pointer to an instance of the <a href="#VkPipelineInputAssemblyStateCreateInfo">VkPipelineInputAssemblyStateCreateInfo</a> structure which determines input assembly behavior, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#drawing">Drawing Commands</a>. </li> <li> <code>pTessellationState</code> is a pointer to an instance of the <a href="#VkPipelineTessellationStateCreateInfo">VkPipelineTessellationStateCreateInfo</a> structure, and is ignored if the pipeline does not include a tessellation control shader stage and tessellation evaluation shader stage. </li> <li> <code>pViewportState</code> is a pointer to an instance of the <a href="#VkPipelineViewportStateCreateInfo">VkPipelineViewportStateCreateInfo</a> structure, and is ignored if the pipeline has rasterization disabled. </li> <li> <code>pRasterizationState</code> is a pointer to an instance of the <a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a> structure. </li> <li> <code>pMultisampleState</code> is a pointer to an instance of the <a href="#VkPipelineMultisampleStateCreateInfo">VkPipelineMultisampleStateCreateInfo</a>, and is ignored if the pipeline has rasterization disabled. </li> <li> <code>pDepthStencilState</code> is a pointer to an instance of the <a href="#VkPipelineDepthStencilStateCreateInfo">VkPipelineDepthStencilStateCreateInfo</a> structure, and is ignored if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use a depth/stencil attachment. </li> <li> <code>pColorBlendState</code> is a pointer to an instance of the <a href="#VkPipelineColorBlendStateCreateInfo">VkPipelineColorBlendStateCreateInfo</a> structure, and is ignored if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use any color attachments. </li> <li> <code>pDynamicState</code> is a pointer to <a href="#VkPipelineDynamicStateCreateInfo">VkPipelineDynamicStateCreateInfo</a> and is used to indicate which properties of the pipeline state object are dynamic and <strong>can</strong> be changed independently of the pipeline state. This <strong>can</strong> be <code>NULL</code>, which means no state in the pipeline is considered dynamic. </li> <li> <code>layout</code> is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline. </li> <li> <code>renderPass</code> is a handle to a render pass object describing the environment in which the pipeline will be used; the pipeline <strong>must</strong> only be used with an instance of any render pass compatible with the one provided. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">Render Pass Compatibility</a> for more information. </li> <li> <code>subpass</code> is the index of the subpass in the render pass where this pipeline will be used. </li> <li> <code>basePipelineHandle</code> is a pipeline to derive from. </li> <li> <code>basePipelineIndex</code> is an index into the <code>pCreateInfos</code> parameter to use as a pipeline to derive from. </li> </ul>    <h4 id="_description_204">Description</h4>  <p>The parameters <code>basePipelineHandle</code> and <code>basePipelineIndex</code> are described in more detail in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-pipeline-derivatives">Pipeline Derivatives</a>.</p>   <p><code>pStages</code> points to an array of <a href="#VkPipelineShaderStageCreateInfo">VkPipelineShaderStageCreateInfo</a> structures, which were previously described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-compute">Compute Pipelines</a>.</p>   <p><code>pDynamicState</code> points to a structure of type <a href="#VkPipelineDynamicStateCreateInfo">VkPipelineDynamicStateCreateInfo</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkGraphicsPipelineCreateInfo-flags-00722">  If <code>flags</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, and <code>basePipelineIndex</code> is -1, <code>basePipelineHandle</code> <strong>must</strong> be a valid handle to a graphics <code>VkPipeline</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-flags-00723">  If <code>flags</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, and <code>basePipelineHandle</code> is <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>basePipelineIndex</code> <strong>must</strong> be a valid index into the calling command’s <code>pCreateInfos</code> parameter </li> <li id="VUID-VkGraphicsPipelineCreateInfo-flags-00724">  If <code>flags</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, and <code>basePipelineIndex</code> is not -1, <code>basePipelineHandle</code> <strong>must</strong> be <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-flags-00725">  If <code>flags</code> contains the <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> flag, and <code>basePipelineHandle</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>basePipelineIndex</code> <strong>must</strong> be -1 </li> <li id="VUID-VkGraphicsPipelineCreateInfo-stage-00726">  The <code>stage</code> member of each element of <code>pStages</code> <strong>must</strong> be unique </li> <li id="VUID-VkGraphicsPipelineCreateInfo-stage-00727">  The <code>stage</code> member of one element of <code>pStages</code> <strong>must</strong> be <code>VK_SHADER_STAGE_VERTEX_BIT</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-stage-00728">  The <code>stage</code> member of any given element of <code>pStages</code> <strong>must</strong> not be <code>VK_SHADER_STAGE_COMPUTE_BIT</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00729">  If <code>pStages</code> includes a tessellation control shader stage, it <strong>must</strong> include a tessellation evaluation shader stage </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00730">  If <code>pStages</code> includes a tessellation evaluation shader stage, it <strong>must</strong> include a tessellation control shader stage </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00731">  If <code>pStages</code> includes a tessellation control shader stage and a tessellation evaluation shader stage, <code>pTessellationState</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineTessellationStateCreateInfo</code> structure </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00732">  If <code>pStages</code> includes tessellation shader stages, the shader code of at least one stage <strong>must</strong> contain an <code>OpExecutionMode</code> instruction that specifies the type of subdivision in the pipeline </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00733">  If <code>pStages</code> includes tessellation shader stages, and the shader code of both stages contain an <code>OpExecutionMode</code> instruction that specifies the type of subdivision in the pipeline, they <strong>must</strong> both specify the same subdivision mode </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00734">  If <code>pStages</code> includes tessellation shader stages, the shader code of at least one stage <strong>must</strong> contain an <code>OpExecutionMode</code> instruction that specifies the output patch size in the pipeline </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00735">  If <code>pStages</code> includes tessellation shader stages, and the shader code of both contain an <code>OpExecutionMode</code> instruction that specifies the out patch size in the pipeline, they <strong>must</strong> both specify the same patch size </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00736">  If <code>pStages</code> includes tessellation shader stages, the <code>topology</code> member of <code>pInputAssembly</code> <strong>must</strong> be <code>VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-topology-00737">  If the <code>topology</code> member of <code>pInputAssembly</code> is <code>VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</code>, <code>pStages</code> <strong>must</strong> include tessellation shader stages </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00738">  If <code>pStages</code> includes a geometry shader stage, and does not include any tessellation shader stages, its shader code <strong>must</strong> contain an <code>OpExecutionMode</code> instruction that specifies an input primitive type that is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-geometry-execution">compatible</a> with the primitive topology specified in <code>pInputAssembly</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00739">  If <code>pStages</code> includes a geometry shader stage, and also includes tessellation shader stages, its shader code <strong>must</strong> contain an <code>OpExecutionMode</code> instruction that specifies an input primitive type that is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-geometry-execution">compatible</a> with the primitive topology that is output by the tessellation stages </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00740">  If <code>pStages</code> includes a fragment shader stage and a geometry shader stage, and the fragment shader code reads from an input variable that is decorated with <code>PrimitiveID</code>, then the geometry shader code <strong>must</strong> write to a matching output variable, decorated with <code>PrimitiveID</code>, in all execution paths </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00741">  If <code>pStages</code> includes a fragment shader stage, its shader code <strong>must</strong> not read from any input attachment that is defined as <code>VK_ATTACHMENT_UNUSED</code> in <code>subpass</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-00742">  The shader code for the entry points identified by <code>pStages</code>, and the rest of the state identified by this structure <strong>must</strong> adhere to the pipeline linking rules described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#interfaces">Shader Interfaces</a> chapter </li> <li id="VUID-VkGraphicsPipelineCreateInfo-subpass-00743">  If rasterization is not disabled and <code>subpass</code> uses a depth/stencil attachment in <code>renderpass</code> that has a layout of <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code> in the <code>VkAttachmentReference</code> defined by <code>subpass</code>, the <code>depthWriteEnable</code> member of <code>pDepthStencilState</code> <strong>must</strong> be <code>VK_FALSE</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-subpass-00744">  If rasterization is not disabled and <code>subpass</code> uses a depth/stencil attachment in <code>renderpass</code> that has a layout of <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code> in the <code>VkAttachmentReference</code> defined by <code>subpass</code>, the <code>failOp</code>, <code>passOp</code> and <code>depthFailOp</code> members of each of the <code>front</code> and <code>back</code> members of <code>pDepthStencilState</code> <strong>must</strong> be <code>VK_STENCIL_OP_KEEP</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-blendEnable-00745">  If rasterization is not disabled and the subpass uses color attachments, then for each color attachment in the subpass the <code>blendEnable</code> member of the corresponding element of the <code>pAttachment</code> member of <code>pColorBlendState</code> <strong>must</strong> be <code>VK_FALSE</code> if the <code>format</code> of the attachment does not support color blend operations, as specified by the <code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> or <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-attachmentCount-00746">  If rasterization is not disabled and the subpass uses color attachments, the <code>attachmentCount</code> member of <code>pColorBlendState</code> <strong>must</strong> be equal to the <code>colorAttachmentCount</code> used to create <code>subpass</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00747">  If no element of the <code>pDynamicStates</code> member of <code>pDynamicState</code> is <code>VK_DYNAMIC_STATE_VIEWPORT</code>, the <code>pViewports</code> member of <code>pViewportState</code> <strong>must</strong> be a pointer to an array of <code>pViewportState</code>::<code>viewportCount</code> <code>VkViewport</code> structures </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00748">  If no element of the <code>pDynamicStates</code> member of <code>pDynamicState</code> is <code>VK_DYNAMIC_STATE_SCISSOR</code>, the <code>pScissors</code> member of <code>pViewportState</code> <strong>must</strong> be a pointer to an array of <code>pViewportState</code>::<code>scissorCount</code> <code>VkRect2D</code> structures </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00749">  If the wide lines feature is not enabled, and no element of the <code>pDynamicStates</code> member of <code>pDynamicState</code> is <code>VK_DYNAMIC_STATE_LINE_WIDTH</code>, the <code>lineWidth</code> member of <code>pRasterizationState</code> <strong>must</strong> be <code>1.0</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00750">  If the <code>rasterizerDiscardEnable</code> member of <code>pRasterizationState</code> is <code>VK_FALSE</code>, <code>pViewportState</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineViewportStateCreateInfo</code> structure </li> <li id="VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00751">  If the <code>rasterizerDiscardEnable</code> member of <code>pRasterizationState</code> is <code>VK_FALSE</code>, <code>pMultisampleState</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineMultisampleStateCreateInfo</code> structure </li> <li id="VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00752">  If the <code>rasterizerDiscardEnable</code> member of <code>pRasterizationState</code> is <code>VK_FALSE</code>, and <code>subpass</code> uses a depth/stencil attachment, <code>pDepthStencilState</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineDepthStencilStateCreateInfo</code> structure </li> <li id="VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00753">  If the <code>rasterizerDiscardEnable</code> member of <code>pRasterizationState</code> is <code>VK_FALSE</code>, and <code>subpass</code> uses color attachments, <code>pColorBlendState</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineColorBlendStateCreateInfo</code> structure </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00754">  If the depth bias clamping feature is not enabled, no element of the <code>pDynamicStates</code> member of <code>pDynamicState</code> is <code>VK_DYNAMIC_STATE_DEPTH_BIAS</code>, and the <code>depthBiasEnable</code> member of <code>pDepthStencil</code> is <code>VK_TRUE</code>, the <code>depthBiasClamp</code> member of <code>pDepthStencil</code> <strong>must</strong> be <code>0.0</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00755">  If no element of the <code>pDynamicStates</code> member of <code>pDynamicState</code> is <code>VK_DYNAMIC_STATE_DEPTH_BOUNDS</code>, and the <code>depthBoundsTestEnable</code> member of <code>pDepthStencil</code> is <code>VK_TRUE</code>, the <code>minDepthBounds</code> and <code>maxDepthBounds</code> members of <code>pDepthStencil</code> <strong>must</strong> be between <code>0.0</code> and <code>1.0</code>, inclusive </li> <li id="VUID-VkGraphicsPipelineCreateInfo-layout-00756">  <code>layout</code> <strong>must</strong> be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-pipelinelayout-consistency">consistent</a> with all shaders specified in <code>pStages</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-subpass-00757">  If <code>subpass</code> uses color and/or depth/stencil attachments, then the <code>rasterizationSamples</code> member of <code>pMultisampleState</code> <strong>must</strong> be the same as the sample count for those subpass attachments </li> <li id="VUID-VkGraphicsPipelineCreateInfo-subpass-00758">  If <code>subpass</code> does not use any color and/or depth/stencil attachments, then the <code>rasterizationSamples</code> member of <code>pMultisampleState</code> <strong>must</strong> follow the rules for a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-noattachments">zero-attachment subpass</a> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-subpass-00759">  <code>subpass</code> <strong>must</strong> be a valid subpass within <code>renderpass</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkGraphicsPipelineCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkPipelineCreateFlagBits">VkPipelineCreateFlagBits</a> values </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pStages-parameter">  <code>pStages</code> <strong>must</strong> be a pointer to an array of <code>stageCount</code> valid <code>VkPipelineShaderStageCreateInfo</code> structures </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pVertexInputState-parameter">  <code>pVertexInputState</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineVertexInputStateCreateInfo</code> structure </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pInputAssemblyState-parameter">  <code>pInputAssemblyState</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineInputAssemblyStateCreateInfo</code> structure </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-parameter">  <code>pRasterizationState</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineRasterizationStateCreateInfo</code> structure </li> <li id="VUID-VkGraphicsPipelineCreateInfo-pDynamicState-parameter">  If <code>pDynamicState</code> is not <code>NULL</code>, <code>pDynamicState</code> <strong>must</strong> be a pointer to a valid <code>VkPipelineDynamicStateCreateInfo</code> structure </li> <li id="VUID-VkGraphicsPipelineCreateInfo-layout-parameter">  <code>layout</code> <strong>must</strong> be a valid <code>VkPipelineLayout</code> handle </li> <li id="VUID-VkGraphicsPipelineCreateInfo-renderPass-parameter">  <code>renderPass</code> <strong>must</strong> be a valid <code>VkRenderPass</code> handle </li> <li id="VUID-VkGraphicsPipelineCreateInfo-stageCount-arraylength">  <code>stageCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkGraphicsPipelineCreateInfo-commonparent">  Each of <code>basePipelineHandle</code>, <code>layout</code>, and <code>renderPass</code> that are valid handles <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_204">See Also</h4>  <p><a href="#VkPipeline">VkPipeline</a>, <a href="#VkPipelineColorBlendStateCreateInfo">VkPipelineColorBlendStateCreateInfo</a>, <a href="#VkPipelineCreateFlags">VkPipelineCreateFlags</a>, <a href="#VkPipelineDepthStencilStateCreateInfo">VkPipelineDepthStencilStateCreateInfo</a>, <a href="#VkPipelineDynamicStateCreateInfo">VkPipelineDynamicStateCreateInfo</a>, <a href="#VkPipelineInputAssemblyStateCreateInfo">VkPipelineInputAssemblyStateCreateInfo</a>, <a href="#VkPipelineLayout">VkPipelineLayout</a>, <a href="#VkPipelineMultisampleStateCreateInfo">VkPipelineMultisampleStateCreateInfo</a>, <a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a>, <a href="#VkPipelineShaderStageCreateInfo">VkPipelineShaderStageCreateInfo</a>, <a href="#VkPipelineTessellationStateCreateInfo">VkPipelineTessellationStateCreateInfo</a>, <a href="#VkPipelineVertexInputStateCreateInfo">VkPipelineVertexInputStateCreateInfo</a>, <a href="#VkPipelineViewportStateCreateInfo">VkPipelineViewportStateCreateInfo</a>, <a href="#VkRenderPass">VkRenderPass</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateGraphicsPipelines">vkCreateGraphicsPipelines</a></p>    <h4 id="_document_notes_204">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkGraphicsPipelineCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkGraphicsPipelineCreateInfo</a></p>         <h3 id="_vkimageblit_3">VkImageBlit(3)</h3>  <h4 id="_name_205">Name</h4>  <p>VkImageBlit - Structure specifying an image blit operation</p>    <h4 id="_c_specification_205">C Specification</h4>  <p>The <code>VkImageBlit</code> structure is defined as:</p>  <pre id="VkImageBlit" data-language="c++">typedef struct VkImageBlit {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffsets[2];
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffsets[2];
} VkImageBlit;</pre>   <h4 id="_members_43">Members</h4>  <ul> <li> <code>srcSubresource</code> is the subresource to blit from. </li> <li> <code>srcOffsets</code> is an array of two <a href="#VkOffset3D">VkOffset3D</a> structures specifying the bounds of the source region within <code>srcSubresource</code>. </li> <li> <code>dstSubresource</code> is the subresource to blit into. </li> <li> <code>dstOffsets</code> is an array of two <a href="#VkOffset3D">VkOffset3D</a> structures specifying the bounds of the destination region within <code>dstSubresource</code>. </li> </ul>    <h4 id="_description_205">Description</h4>  <p>For each element of the <code>pRegions</code> array, a blit operation is performed the specified source and destination regions.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkImageBlit-aspectMask-00238">  The <code>aspectMask</code> member of <code>srcSubresource</code> and <code>dstSubresource</code> <strong>must</strong> match </li> <li id="VUID-VkImageBlit-layerCount-00239">  The <code>layerCount</code> member of <code>srcSubresource</code> and <code>dstSubresource</code> <strong>must</strong> match </li> <li id="VUID-VkImageBlit-srcImage-00240">  If either of the calling command’s <code>srcImage</code> or <code>dstImage</code> parameters are of <a href="#VkImageType">VkImageType</a> <code>VK_IMAGE_TYPE_3D</code>, the <code>baseArrayLayer</code> and <code>layerCount</code> members of both <code>srcSubresource</code> and <code>dstSubresource</code> <strong>must</strong> be <code>0</code> and <code>1</code>, respectively </li> <li id="VUID-VkImageBlit-aspectMask-00241">  The <code>aspectMask</code> member of <code>srcSubresource</code> <strong>must</strong> specify aspects present in the calling command’s <code>srcImage</code> </li> <li id="VUID-VkImageBlit-aspectMask-00242">  The <code>aspectMask</code> member of <code>dstSubresource</code> <strong>must</strong> specify aspects present in the calling command’s <code>dstImage</code> </li> <li id="VUID-VkImageBlit-srcOffset-00243">  <code>srcOffset</code>[0].<code>x</code> and <code>srcOffset</code>[1].<code>x</code> <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the source image subresource width </li> <li id="VUID-VkImageBlit-srcOffset-00244">  <code>srcOffset</code>[0].<code>y</code> and <code>srcOffset</code>[1].<code>y</code> <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the source image subresource height </li> <li id="VUID-VkImageBlit-srcImage-00245">  If the calling command’s <code>srcImage</code> is of type <code>VK_IMAGE_TYPE_1D</code>, then <code>srcOffset</code>[0].y <strong>must</strong> be <code>0</code> and <code>srcOffset</code>[1].y <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageBlit-srcOffset-00246">  <code>srcOffset</code>[0].<code>z</code> and <code>srcOffset</code>[1].<code>z</code> <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the source image subresource depth </li> <li id="VUID-VkImageBlit-srcImage-00247">  If the calling command’s <code>srcImage</code> is of type <code>VK_IMAGE_TYPE_1D</code> or <code>VK_IMAGE_TYPE_2D</code>, then <code>srcOffset</code>[0].z <strong>must</strong> be <code>0</code> and <code>srcOffset</code>[1].z <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageBlit-dstOffset-00248">  <code>dstOffset</code>[0].<code>x</code> and <code>dstOffset</code>[1].<code>x</code> <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the destination image subresource width </li> <li id="VUID-VkImageBlit-dstOffset-00249">  <code>dstOffset</code>[0].<code>y</code> and <code>dstOffset</code>[1].<code>y</code> <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the destination image subresource height </li> <li id="VUID-VkImageBlit-dstImage-00250">  If the calling command’s <code>dstImage</code> is of type <code>VK_IMAGE_TYPE_1D</code>, then <code>dstOffset</code>[0].y <strong>must</strong> be <code>0</code> and <code>dstOffset</code>[1].y <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageBlit-dstOffset-00251">  <code>dstOffset</code>[0].<code>z</code> and <code>dstOffset</code>[1].<code>z</code> <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the destination image subresource depth </li> <li id="VUID-VkImageBlit-dstImage-00252">  If the calling command’s <code>dstImage</code> is of type <code>VK_IMAGE_TYPE_1D</code> or <code>VK_IMAGE_TYPE_2D</code>, then <code>dstOffset</code>[0].z <strong>must</strong> be <code>0</code> and <code>dstOffset</code>[1].z <strong>must</strong> be <code>1</code>. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkImageBlit-srcSubresource-parameter">  <code>srcSubresource</code> <strong>must</strong> be a valid <code>VkImageSubresourceLayers</code> structure </li> <li id="VUID-VkImageBlit-dstSubresource-parameter">  <code>dstSubresource</code> <strong>must</strong> be a valid <code>VkImageSubresourceLayers</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_205">See Also</h4>  <p><a href="#VkImageSubresourceLayers">VkImageSubresourceLayers</a>, <a href="#VkOffset3D">VkOffset3D</a>, <a href="#vkCmdBlitImage">vkCmdBlitImage</a></p>    <h4 id="_document_notes_205">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageBlit">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageBlit</a></p>         <h3 id="_vkimagecopy_3">VkImageCopy(3)</h3>  <h4 id="_name_206">Name</h4>  <p>VkImageCopy - Structure specifying an image copy operation</p>    <h4 id="_c_specification_206">C Specification</h4>  <p>The <code>VkImageCopy</code> structure is defined as:</p>  <pre id="VkImageCopy" data-language="c++">typedef struct VkImageCopy {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageCopy;</pre>   <h4 id="_members_44">Members</h4>  <ul> <li> <code>srcSubresource</code> and <code>dstSubresource</code> are <a href="#VkImageSubresourceLayers">VkImageSubresourceLayers</a> structures specifying the image subresources of the images used for the source and destination image data, respectively. </li> <li> <code>srcOffset</code> and <code>dstOffset</code> select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data. </li> <li> <code>extent</code> is the size in texels of the source image to copy in <code>width</code>, <code>height</code> and <code>depth</code>. </li> </ul>    <h4 id="_description_206">Description</h4>  <p>Copies are done layer by layer starting with <code>baseArrayLayer</code> member of <code>srcSubresource</code> for the source and <code>dstSubresource</code> for the destination. <code>layerCount</code> layers are copied to the destination image.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkImageCopy-aspectMask-00137">  The <code>aspectMask</code> member of <code>srcSubresource</code> and <code>dstSubresource</code> <strong>must</strong> match </li> <li id="VUID-VkImageCopy-layerCount-00138">  The <code>layerCount</code> member of <code>srcSubresource</code> and <code>dstSubresource</code> <strong>must</strong> match </li> <li id="VUID-VkImageCopy-srcImage-00139">  If either of the calling command’s <code>srcImage</code> or <code>dstImage</code> parameters are of <a href="#VkImageType">VkImageType</a> <code>VK_IMAGE_TYPE_3D</code>, the <code>baseArrayLayer</code> and <code>layerCount</code> members of both <code>srcSubresource</code> and <code>dstSubresource</code> <strong>must</strong> be <code>0</code> and <code>1</code>, respectively </li> <li id="VUID-VkImageCopy-aspectMask-00142">  The <code>aspectMask</code> member of <code>srcSubresource</code> <strong>must</strong> specify aspects present in the calling command’s <code>srcImage</code> </li> <li id="VUID-VkImageCopy-aspectMask-00143">  The <code>aspectMask</code> member of <code>dstSubresource</code> <strong>must</strong> specify aspects present in the calling command’s <code>dstImage</code> </li> <li id="VUID-VkImageCopy-srcOffset-00144">  <code>srcOffset.x</code> and (<code>extent.width</code> + <code>srcOffset.x</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the source image subresource width </li> <li id="VUID-VkImageCopy-srcOffset-00145">  <code>srcOffset.y</code> and (<code>extent.height</code> + <code>srcOffset.y</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the source image subresource height </li> <li id="VUID-VkImageCopy-srcImage-00146">  If the calling command’s <code>srcImage</code> is of type <code>VK_IMAGE_TYPE_1D</code>, then <code>srcOffset.y</code> <strong>must</strong> be <code>0</code> and <code>extent.height</code> <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageCopy-srcOffset-00147">  <code>srcOffset.z</code> and (<code>extent.depth</code> + <code>srcOffset.z</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the source image subresource depth </li> <li id="VUID-VkImageCopy-srcImage-00148">  If the calling command’s <code>srcImage</code> is of type <code>VK_IMAGE_TYPE_1D</code> or <code>VK_IMAGE_TYPE_2D</code>, then <code>srcOffset.z</code> <strong>must</strong> be <code>0</code> and <code>extent.depth</code> <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageCopy-srcSubresource-00149">  <code>srcSubresource.baseArrayLayer</code> <strong>must</strong> be less than and (<code>srcSubresource.layerCount</code> + <code>srcSubresource.baseArrayLayer</code>) <strong>must</strong> be less than or equal to the number of layers in the source image </li> <li id="VUID-VkImageCopy-dstOffset-00150">  <code>dstOffset.x</code> and (<code>extent.width</code> + <code>dstOffset.x</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the destination image subresource width </li> <li id="VUID-VkImageCopy-dstOffset-00151">  <code>dstOffset.y</code> and (<code>extent.height</code> + <code>dstOffset.y</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the destination image subresource height </li> <li id="VUID-VkImageCopy-dstImage-00152">  If the calling command’s <code>dstImage</code> is of type <code>VK_IMAGE_TYPE_1D</code>, then <code>dstOffset.y</code> <strong>must</strong> be <code>0</code> and <code>extent.height</code> <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageCopy-dstOffset-00153">  <code>dstOffset.z</code> and (<code>extent.depth</code> + <code>dstOffset.z</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the destination image subresource depth </li> <li id="VUID-VkImageCopy-dstImage-00154">  If the calling command’s <code>dstImage</code> is of type <code>VK_IMAGE_TYPE_1D</code> or <code>VK_IMAGE_TYPE_2D</code>, then <code>dstOffset.z</code> <strong>must</strong> be <code>0</code> and <code>extent.depth</code> <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageCopy-dstSubresource-00155">  <code>dstSubresource.baseArrayLayer</code> <strong>must</strong> be less than and (<code>dstSubresource.layerCount</code> + <code>dstSubresource.baseArrayLayer</code>) <strong>must</strong> be less than or equal to the number of layers in the destination image </li> <li id="VUID-VkImageCopy-srcOffset-00157">  If the calling command’s <code>srcImage</code> is a compressed format image, all members of <code>srcOffset</code> <strong>must</strong> be a multiple of the corresponding dimensions of the compressed texel block </li> <li id="VUID-VkImageCopy-extent-00158">  If the calling command’s <code>srcImage</code> is a compressed format image, <code>extent.width</code> <strong>must</strong> be a multiple of the compressed texel block width or (<code>extent.width</code> + <code>srcOffset.x</code>) <strong>must</strong> equal the source image subresource width </li> <li id="VUID-VkImageCopy-extent-00159">  If the calling command’s <code>srcImage</code> is a compressed format image, <code>extent.height</code> <strong>must</strong> be a multiple of the compressed texel block height or (<code>extent.height</code> + <code>srcOffset.y</code>) <strong>must</strong> equal the source image subresource height </li> <li id="VUID-VkImageCopy-extent-00160">  If the calling command’s <code>srcImage</code> is a compressed format image, <code>extent.depth</code> <strong>must</strong> be a multiple of the compressed texel block depth or (<code>extent.depth</code> + <code>srcOffset.z</code>) <strong>must</strong> equal the source image subresource depth </li> <li id="VUID-VkImageCopy-dstOffset-00162">  If the calling command’s <code>dstImage</code> is a compressed format image, all members of <code>dstOffset</code> <strong>must</strong> be a multiple of the corresponding dimensions of the compressed texel block </li> <li id="VUID-VkImageCopy-extent-00163">  If the calling command’s <code>dstImage</code> is a compressed format image, <code>extent.width</code> <strong>must</strong> be a multiple of the compressed texel block width or (<code>extent.width</code> + <code>dstOffset.x</code>) <strong>must</strong> equal the destination image subresource width </li> <li id="VUID-VkImageCopy-extent-00164">  If the calling command’s <code>dstImage</code> is a compressed format image, <code>extent.height</code> <strong>must</strong> be a multiple of the compressed texel block height or (<code>extent.height</code> + <code>dstOffset.y</code>) <strong>must</strong> equal the destination image subresource height </li> <li id="VUID-VkImageCopy-extent-00165">  If the calling command’s <code>dstImage</code> is a compressed format image, <code>extent.depth</code> <strong>must</strong> be a multiple of the compressed texel block depth or (<code>extent.depth</code> + <code>dstOffset.z</code>) <strong>must</strong> equal the destination image subresource depth </li> <li id="VUID-VkImageCopy-srcOffset-00166">  <code>srcOffset</code>, <code>dstOffset</code>, and <code>extent</code> <strong>must</strong> respect the image transfer granularity requirements of the queue family that it will be submitted against, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-physical-device-enumeration">Physical Device Enumeration</a> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkImageCopy-srcSubresource-parameter">  <code>srcSubresource</code> <strong>must</strong> be a valid <code>VkImageSubresourceLayers</code> structure </li> <li id="VUID-VkImageCopy-dstSubresource-parameter">  <code>dstSubresource</code> <strong>must</strong> be a valid <code>VkImageSubresourceLayers</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_206">See Also</h4>  <p><a href="#VkExtent3D">VkExtent3D</a>, <a href="#VkImageSubresourceLayers">VkImageSubresourceLayers</a>, <a href="#VkOffset3D">VkOffset3D</a>, <a href="#vkCmdCopyImage">vkCmdCopyImage</a></p>    <h4 id="_document_notes_206">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageCopy">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageCopy</a></p>         <h3 id="_vkimagecreateinfo_3">VkImageCreateInfo(3)</h3>  <h4 id="_name_207">Name</h4>  <p>VkImageCreateInfo - Structure specifying the parameters of a newly created image object</p>    <h4 id="_c_specification_207">C Specification</h4>  <p>The <code>VkImageCreateInfo</code> structure is defined as:</p>  <pre id="VkImageCreateInfo" data-language="c++">typedef struct VkImageCreateInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageCreateFlags       flags;
    VkImageType              imageType;
    VkFormat                 format;
    VkExtent3D               extent;
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;
    VkImageTiling            tiling;
    VkImageUsageFlags        usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    const uint32_t*          pQueueFamilyIndices;
    VkImageLayout            initialLayout;
} VkImageCreateInfo;</pre>   <h4 id="_members_45">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is a bitmask of <a href="#VkImageCreateFlagBits">VkImageCreateFlagBits</a> describing additional parameters of the image. </li> <li> <code>imageType</code> is a <a href="#VkImageType">VkImageType</a> value specifying the basic dimensionality of the image. Layers in array textures do not count as a dimension for the purposes of the image type. </li> <li> <code>format</code> is a <a href="#VkFormat">VkFormat</a> describing the format and type of the data elements that will be contained in the image. </li> <li> <code>extent</code> is a <a href="#VkExtent3D">VkExtent3D</a> describing the number of data elements in each dimension of the base level. </li> <li> <code>mipLevels</code> describes the number of levels of detail available for minified sampling of the image. </li> <li> <code>arrayLayers</code> is the number of layers in the image. </li> <li> <code>samples</code> is the number of sub-data element samples in the image as defined in <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a>. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#primsrast-multisampling">Multisampling</a>. </li> <li> <code>tiling</code> is a <a href="#VkImageTiling">VkImageTiling</a> value specifying the tiling arrangement of the data elements in memory. </li> <li> <code>usage</code> is a bitmask of <a href="#VkImageUsageFlagBits">VkImageUsageFlagBits</a> describing the intended usage of the image. </li> <li> <code>sharingMode</code> is a <a href="#VkSharingMode">VkSharingMode</a> value specifying the sharing mode of the image when it will be accessed by multiple queue families. </li> <li> <code>queueFamilyIndexCount</code> is the number of entries in the <code>pQueueFamilyIndices</code> array. </li> <li> <code>pQueueFamilyIndices</code> is a list of queue families that will access this image (ignored if <code>sharingMode</code> is not <code>VK_SHARING_MODE_CONCURRENT</code>). </li> <li> <code>initialLayout</code> is a <a href="#VkImageLayout">VkImageLayout</a> value specifying the initial <a href="#VkImageLayout">VkImageLayout</a> of all image subresources of the image. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-layouts">Image Layouts</a>. </li> </ul>    <h4 id="_description_207">Description</h4>  <p>Images created with <code>tiling</code> equal to <code>VK_IMAGE_TILING_LINEAR</code> have further restrictions on their limits and capabilities compared to images created with <code>tiling</code> equal to <code>VK_IMAGE_TILING_OPTIMAL</code>. Creation of images with tiling <code>VK_IMAGE_TILING_LINEAR</code> <strong>may</strong> not be supported unless other parameters meet all of the constraints:</p>   <ul> <li> <code>imageType</code> is <code>VK_IMAGE_TYPE_2D</code> </li> <li> <code>format</code> is not a depth/stencil format </li> <li> <code>mipLevels</code> is 1 </li> <li> <code>arrayLayers</code> is 1 </li> <li> <code>samples</code> is <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li> <code>usage</code> only includes <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> and/or <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> </li> </ul>   <p>Implementations <strong>may</strong> support additional limits and capabilities beyond those listed above.</p>   <p>To query an implementation’s specific capabilities for a given combination of <code>format</code>, <code>imageType</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code>, call <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a>. The return value indicates whether that combination of image settings is supported. On success, the <code>VkImageFormatProperties</code> output parameter indicates the set of valid <code>samples</code> bits and the limits for <code>extent</code>, <code>mipLevels</code>, and <code>arrayLayers</code>.</p>   <p>To determine the set of valid <code>usage</code> bits for a given format, call <a href="#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkImageCreateInfo-format-00940">  The combination of <code>format</code>, <code>imageType</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code> <strong>must</strong> be supported, as indicated by a <code>VK_SUCCESS</code> return value from <code>vkGetPhysicalDeviceImageFormatProperties</code> invoked with the same values passed to the corresponding parameters. </li> <li id="VUID-VkImageCreateInfo-sharingMode-00941">  If <code>sharingMode</code> is <code>VK_SHARING_MODE_CONCURRENT</code>, <code>pQueueFamilyIndices</code> <strong>must</strong> be a pointer to an array of <code>queueFamilyIndexCount</code> <code>uint32_t</code> values </li> <li id="VUID-VkImageCreateInfo-sharingMode-00942">  If <code>sharingMode</code> is <code>VK_SHARING_MODE_CONCURRENT</code>, <code>queueFamilyIndexCount</code> <strong>must</strong> be greater than <code>1</code> </li> <li id="VUID-VkImageCreateInfo-sharingMode-01392">  If <code>sharingMode</code> is <code>VK_SHARING_MODE_CONCURRENT</code>, each element of <code>pQueueFamilyIndices</code> <strong>must</strong> be unique and <strong>must</strong> be less than <code>pQueueFamilyPropertyCount</code> returned by <a href="#vkGetPhysicalDeviceQueueFamilyProperties">vkGetPhysicalDeviceQueueFamilyProperties</a> for the <code>physicalDevice</code> that was used to create <code>device</code> </li> <li id="VUID-VkImageCreateInfo-format-00943">  <code>format</code> <strong>must</strong> not be <code>VK_FORMAT_UNDEFINED</code> </li> <li id="VUID-VkImageCreateInfo-extent-00944">  <code>extent</code>::<code>width</code> <strong>must</strong> be greater than <code>0</code>. </li> <li id="VUID-VkImageCreateInfo-extent-00945">  <code>extent</code>::<code>height</code> <strong>must</strong> be greater than <code>0</code>. </li> <li id="VUID-VkImageCreateInfo-extent-00946">  <code>extent</code>::<code>depth</code> <strong>must</strong> be greater than <code>0</code>. </li> <li id="VUID-VkImageCreateInfo-mipLevels-00947">  <code>mipLevels</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkImageCreateInfo-arrayLayers-00948">  <code>arrayLayers</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkImageCreateInfo-flags-00949">  If <code>flags</code> contains <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code>, <code>imageType</code> <strong>must</strong> be <code>VK_IMAGE_TYPE_2D</code> </li> <li id="VUID-VkImageCreateInfo-imageType-00951">  If <code>imageType</code> is <code>VK_IMAGE_TYPE_1D</code>, <code>extent.width</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxImageDimension1D</code>, or <code>VkImageFormatProperties</code>::<code>maxExtent.width</code> (as returned by <code>vkGetPhysicalDeviceImageFormatProperties</code> with <code>format</code>, <code>imageType</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code> equal to those in this structure) - whichever is higher </li> <li id="VUID-VkImageCreateInfo-imageType-00952">  If <code>imageType</code> is <code>VK_IMAGE_TYPE_2D</code> and <code>flags</code> does not contain <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code>, <code>extent.width</code> and <code>extent.height</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxImageDimension2D</code>, or <code>VkImageFormatProperties</code>::<code>maxExtent.width</code>/height (as returned by <code>vkGetPhysicalDeviceImageFormatProperties</code> with <code>format</code>, <code>imageType</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code> equal to those in this structure) - whichever is higher </li> <li id="VUID-VkImageCreateInfo-imageType-00953">  If <code>imageType</code> is <code>VK_IMAGE_TYPE_2D</code> and <code>flags</code> contains <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code>, <code>extent.width</code> and <code>extent.height</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxImageDimensionCube</code>, or <code>VkImageFormatProperties</code>::<code>maxExtent.width</code>/height (as returned by <code>vkGetPhysicalDeviceImageFormatProperties</code> with <code>format</code>, <code>imageType</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code> equal to those in this structure) - whichever is higher </li> <li id="VUID-VkImageCreateInfo-imageType-00954">  If <code>imageType</code> is <code>VK_IMAGE_TYPE_2D</code> and <code>flags</code> contains <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code>, <code>extent.width</code> and <code>extent.height</code> <strong>must</strong> be equal and <code>arrayLayers</code> <strong>must</strong> be greater than or equal to 6 </li> <li id="VUID-VkImageCreateInfo-imageType-00955">  If <code>imageType</code> is <code>VK_IMAGE_TYPE_3D</code>, <code>extent.width</code>, <code>extent.height</code> and <code>extent.depth</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxImageDimension3D</code>, or <code>VkImageFormatProperties</code>::<code>maxExtent.width</code>/height/depth (as returned by <code>vkGetPhysicalDeviceImageFormatProperties</code> with <code>format</code>, <code>imageType</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code> equal to those in this structure) - whichever is higher </li> <li id="VUID-VkImageCreateInfo-imageType-00956">  If <code>imageType</code> is <code>VK_IMAGE_TYPE_1D</code>, both <code>extent.height</code> and <code>extent.depth</code> <strong>must</strong> be <code>1</code> </li> <li id="VUID-VkImageCreateInfo-imageType-00957">  If <code>imageType</code> is <code>VK_IMAGE_TYPE_2D</code>, <code>extent.depth</code> <strong>must</strong> be <code>1</code> </li> <li id="VUID-VkImageCreateInfo-mipLevels-00958">  <code>mipLevels</code> <strong>must</strong> be less than or equal to ⌊log<sub>2</sub>(max(<code>extent.width</code>, <code>extent.height</code>, <code>extent.depth</code>))⌋ + 1. </li> <li id="VUID-VkImageCreateInfo-extent-00959">  If any of <code>extent.width</code>, <code>extent.height</code>, or <code>extent.depth</code> are greater than the equivalently named members of <code>VkPhysicalDeviceLimits</code>::<code>maxImageDimension3D</code>, <code>mipLevels</code> <strong>must</strong> be less than or equal to <code>VkImageFormatProperties</code>::<code>maxMipLevels</code> (as returned by <code>vkGetPhysicalDeviceImageFormatProperties</code> with <code>format</code>, <code>imageType</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code> equal to those in this structure) </li> <li id="VUID-VkImageCreateInfo-arrayLayers-00960">  <code>arrayLayers</code> <strong>must</strong> be less than or equal to <code>VkImageFormatProperties</code>::<code>maxArrayLayers</code> (as returned by <code>vkGetPhysicalDeviceImageFormatProperties</code> with <code>format</code>, <code>imageType</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code> equal to those in this structure) </li> <li id="VUID-VkImageCreateInfo-imageType-00961">  If <code>imageType</code> is <code>VK_IMAGE_TYPE_3D</code>, <code>arrayLayers</code> <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageCreateInfo-samples-00962">  If <code>samples</code> is not <code>VK_SAMPLE_COUNT_1_BIT</code>, <code>imageType</code> <strong>must</strong> be <code>VK_IMAGE_TYPE_2D</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code>, <code>tiling</code> <strong>must</strong> be <code>VK_IMAGE_TILING_OPTIMAL</code>, and <code>mipLevels</code> <strong>must</strong> be equal to <code>1</code> </li> <li id="VUID-VkImageCreateInfo-usage-00963">  If <code>usage</code> includes <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>, then bits other than <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code>, <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code>, and <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> <strong>must</strong> not be set </li> <li id="VUID-VkImageCreateInfo-usage-00964">  If <code>usage</code> includes <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code>, <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code>, <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>, or <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code>, <code>extent.width</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxFramebufferWidth</code> </li> <li id="VUID-VkImageCreateInfo-usage-00965">  If <code>usage</code> includes <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code>, <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code>, <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>, or <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code>, <code>extent.height</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxFramebufferHeight</code> </li> <li id="VUID-VkImageCreateInfo-usage-00966">  If <code>usage</code> includes <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>, <code>usage</code> <strong>must</strong> also contain at least one of <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code>, <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code>, or <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code>. </li> <li id="VUID-VkImageCreateInfo-samples-00967">  <code>samples</code> <strong>must</strong> be a bit value that is set in <code>VkImageFormatProperties</code>::<code>sampleCounts</code> returned by <code>vkGetPhysicalDeviceImageFormatProperties</code> with <code>format</code>, <code>imageType</code>, <code>tiling</code>, <code>usage</code>, and <code>flags</code> equal to those in this structure </li> <li id="VUID-VkImageCreateInfo-usage-00968">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-shaderStorageImageMultisample">multisampled storage images</a> feature is not enabled, and <code>usage</code> contains <code>VK_IMAGE_USAGE_STORAGE_BIT</code>, <code>samples</code> <strong>must</strong> be <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li id="VUID-VkImageCreateInfo-flags-00969">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseBinding">sparse bindings</a> feature is not enabled, <code>flags</code> <strong>must</strong> not contain <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code> </li> <li id="VUID-VkImageCreateInfo-imageType-00970">  If <code>imageType</code> is <code>VK_IMAGE_TYPE_1D</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> </li> <li id="VUID-VkImageCreateInfo-imageType-00971">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyImage2D">sparse residency for 2D images</a> feature is not enabled, and <code>imageType</code> is <code>VK_IMAGE_TYPE_2D</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> </li> <li id="VUID-VkImageCreateInfo-imageType-00972">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyImage3D">sparse residency for 3D images</a> feature is not enabled, and <code>imageType</code> is <code>VK_IMAGE_TYPE_3D</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> </li> <li id="VUID-VkImageCreateInfo-imageType-00973">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency2Samples">sparse residency for images with 2 samples</a> feature is not enabled, <code>imageType</code> is <code>VK_IMAGE_TYPE_2D</code>, and <code>samples</code> is <code>VK_SAMPLE_COUNT_2_BIT</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> </li> <li id="VUID-VkImageCreateInfo-imageType-00974">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency4Samples">sparse residency for images with 4 samples</a> feature is not enabled, <code>imageType</code> is <code>VK_IMAGE_TYPE_2D</code>, and <code>samples</code> is <code>VK_SAMPLE_COUNT_4_BIT</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> </li> <li id="VUID-VkImageCreateInfo-imageType-00975">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency8Samples">sparse residency for images with 8 samples</a> feature is not enabled, <code>imageType</code> is <code>VK_IMAGE_TYPE_2D</code>, and <code>samples</code> is <code>VK_SAMPLE_COUNT_8_BIT</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> </li> <li id="VUID-VkImageCreateInfo-imageType-00976">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency16Samples">sparse residency for images with 16 samples</a> feature is not enabled, <code>imageType</code> is <code>VK_IMAGE_TYPE_2D</code>, and <code>samples</code> is <code>VK_SAMPLE_COUNT_16_BIT</code>, <code>flags</code> <strong>must</strong> not contain <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> </li> <li id="VUID-VkImageCreateInfo-tiling-00977">  If <code>tiling</code> is <code>VK_IMAGE_TILING_LINEAR</code>, <code>format</code> <strong>must</strong> be a format that has at least one supported feature bit present in the value of <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageCreateInfo-tiling-00978">  If <code>tiling</code> is <code>VK_IMAGE_TILING_LINEAR</code>, and <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (as returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code>) does not include <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code>, <code>usage</code> <strong>must</strong> not contain <code>VK_IMAGE_USAGE_SAMPLED_BIT</code> </li> <li id="VUID-VkImageCreateInfo-tiling-00979">  If <code>tiling</code> is <code>VK_IMAGE_TILING_LINEAR</code>, and <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (as returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code>) does not include <code>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</code>, <code>usage</code> <strong>must</strong> not contain <code>VK_IMAGE_USAGE_STORAGE_BIT</code> </li> <li id="VUID-VkImageCreateInfo-tiling-00980">  If <code>tiling</code> is <code>VK_IMAGE_TILING_LINEAR</code>, and <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (as returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code>) does not include <code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</code>, <code>usage</code> <strong>must</strong> not contain <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code> </li> <li id="VUID-VkImageCreateInfo-tiling-00981">  If <code>tiling</code> is <code>VK_IMAGE_TILING_LINEAR</code>, and <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> (as returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code>) does not include <code>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</code>, <code>usage</code> <strong>must</strong> not contain <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code> </li> <li id="VUID-VkImageCreateInfo-tiling-00982">  If <code>tiling</code> is <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>format</code> <strong>must</strong> be a format that has at least one supported feature bit present in the value of <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageCreateInfo-tiling-00983">  If <code>tiling</code> is <code>VK_IMAGE_TILING_OPTIMAL</code>, and <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> (as returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code>) does not include <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code>, <code>usage</code> <strong>must</strong> not contain <code>VK_IMAGE_USAGE_SAMPLED_BIT</code> </li> <li id="VUID-VkImageCreateInfo-tiling-00984">  If <code>tiling</code> is <code>VK_IMAGE_TILING_OPTIMAL</code>, and <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> (as returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code>) does not include <code>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</code>, <code>usage</code> <strong>must</strong> not contain <code>VK_IMAGE_USAGE_STORAGE_BIT</code> </li> <li id="VUID-VkImageCreateInfo-tiling-00985">  If <code>tiling</code> is <code>VK_IMAGE_TILING_OPTIMAL</code>, and <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> (as returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code>) does not include <code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</code>, <code>usage</code> <strong>must</strong> not contain <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code> </li> <li id="VUID-VkImageCreateInfo-tiling-00986">  If <code>tiling</code> is <code>VK_IMAGE_TILING_OPTIMAL</code>, and <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> (as returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code>) does not include <code>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</code>, <code>usage</code> <strong>must</strong> not contain <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code> </li> <li id="VUID-VkImageCreateInfo-flags-00987">  If <code>flags</code> contains <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> or <code>VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</code>, it <strong>must</strong> also contain <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code> </li> <li id="VUID-VkImageCreateInfo-initialLayout-00993">  <code>initialLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_UNDEFINED</code> or <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code>. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkImageCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</code> </li> <li id="VUID-VkImageCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkImageCreateInfo-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkImageCreateFlagBits">VkImageCreateFlagBits</a> values </li> <li id="VUID-VkImageCreateInfo-imageType-parameter">  <code>imageType</code> <strong>must</strong> be a valid <a href="#VkImageType">VkImageType</a> value </li> <li id="VUID-VkImageCreateInfo-format-parameter">  <code>format</code> <strong>must</strong> be a valid <a href="#VkFormat">VkFormat</a> value </li> <li id="VUID-VkImageCreateInfo-samples-parameter">  <code>samples</code> <strong>must</strong> be a valid <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> value </li> <li id="VUID-VkImageCreateInfo-tiling-parameter">  <code>tiling</code> <strong>must</strong> be a valid <a href="#VkImageTiling">VkImageTiling</a> value </li> <li id="VUID-VkImageCreateInfo-usage-parameter">  <code>usage</code> <strong>must</strong> be a valid combination of <a href="#VkImageUsageFlagBits">VkImageUsageFlagBits</a> values </li> <li id="VUID-VkImageCreateInfo-usage-requiredbitmask">  <code>usage</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-VkImageCreateInfo-sharingMode-parameter">  <code>sharingMode</code> <strong>must</strong> be a valid <a href="#VkSharingMode">VkSharingMode</a> value </li> <li id="VUID-VkImageCreateInfo-initialLayout-parameter">  <code>initialLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_207">See Also</h4>  <p><a href="#VkExtent3D">VkExtent3D</a>, <a href="#VkFormat">VkFormat</a>, <a href="#VkImageCreateFlags">VkImageCreateFlags</a>, <a href="#VkImageLayout">VkImageLayout</a>, <a href="#VkImageTiling">VkImageTiling</a>, <a href="#VkImageType">VkImageType</a>, <a href="#VkImageUsageFlags">VkImageUsageFlags</a>, <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a>, <a href="#VkSharingMode">VkSharingMode</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateImage">vkCreateImage</a></p>    <h4 id="_document_notes_207">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageCreateInfo</a></p>         <h3 id="_vkimageformatproperties_3">VkImageFormatProperties(3)</h3>  <h4 id="_name_208">Name</h4>  <p>VkImageFormatProperties - Structure specifying a image format properties</p>    <h4 id="_c_specification_208">C Specification</h4>  <p>The <code>VkImageFormatProperties</code> structure is defined as:</p>  <pre id="VkImageFormatProperties" data-language="c++">typedef struct VkImageFormatProperties {
    VkExtent3D            maxExtent;
    uint32_t              maxMipLevels;
    uint32_t              maxArrayLayers;
    VkSampleCountFlags    sampleCounts;
    VkDeviceSize          maxResourceSize;
} VkImageFormatProperties;</pre>   <h4 id="_members_46">Members</h4>  <ul> <li> <code>maxExtent</code> are the maximum image dimensions. See the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-extentperimagetype">Allowed Extent Values</a> section below for how these values are constrained by <code>type</code>. </li> <li> <code>maxMipLevels</code> is the maximum number of mipmap levels. <code>maxMipLevels</code> <strong>must</strong> either be equal to 1 (valid only if <code>tiling</code> is <code>VK_IMAGE_TILING_LINEAR</code>) or be equal to ⌈log<sub>2</sub>(max(<code>width</code>, <code>height</code>, <code>depth</code>))⌉ + 1. <code>width</code>, <code>height</code>, and <code>depth</code> are taken from the corresponding members of <code>maxExtent</code>. </li> <li> <code>maxArrayLayers</code> is the maximum number of array layers. <code>maxArrayLayers</code> <strong>must</strong> either be equal to 1 or be greater than or equal to the <code>maxImageArrayLayers</code> member of <a href="#VkPhysicalDeviceLimits">VkPhysicalDeviceLimits</a>. A value of 1 is valid only if <code>tiling</code> is <code>VK_IMAGE_TILING_LINEAR</code> or if <code>type</code> is <code>VK_IMAGE_TYPE_3D</code>. </li> <li> <code>sampleCounts</code> is a bitmask of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> specifying all the supported sample counts for this image as described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-supported-sample-counts">below</a>. </li> <li> <code>maxResourceSize</code> is an upper bound on the total image size in bytes, inclusive of all image subresources. Implementations <strong>may</strong> have an address space limit on total size of a resource, which is advertised by this property. <code>maxResourceSize</code> <strong>must</strong> be at least 2<sup>31</sup>. </li> </ul>    <h4 id="_description_208">Description</h4> <blockquote> <h5 class="title">Note</h5>  <p>There is no mechanism to query the size of an image before creating it, to compare that size against <code>maxResourceSize</code>. If an application attempts to create an image that exceeds this limit, the creation will fail or the image will be invalid. While the advertised limit <strong>must</strong> be at least 2<sup>31</sup>, it <strong>may</strong> not be possible to create an image that approaches that size, particularly for <code>VK_IMAGE_TYPE_1D</code>.</p>  </blockquote>  <p>If the combination of parameters to <code>vkGetPhysicalDeviceImageFormatProperties</code> is not supported by the implementation for use in <a href="#vkCreateImage">vkCreateImage</a>, then all members of <code>VkImageFormatProperties</code> will be filled with zero.</p>    <h4 id="_see_also_208">See Also</h4>  <p><code>VkDeviceSize</code>, <a href="#VkExtent3D">VkExtent3D</a>, <a href="#VkSampleCountFlags">VkSampleCountFlags</a>, <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a></p>    <h4 id="_document_notes_208">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageFormatProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageFormatProperties</a></p>         <h3 id="_vkimagememorybarrier_3">VkImageMemoryBarrier(3)</h3>  <h4 id="_name_209">Name</h4>  <p>VkImageMemoryBarrier - Structure specifying the parameters of an image memory barrier</p>    <h4 id="_c_specification_209">C Specification</h4>  <p>The <code>VkImageMemoryBarrier</code> structure is defined as:</p>  <pre id="VkImageMemoryBarrier" data-language="c++">typedef struct VkImageMemoryBarrier {
    VkStructureType            sType;
    const void*                pNext;
    VkAccessFlags              srcAccessMask;
    VkAccessFlags              dstAccessMask;
    VkImageLayout              oldLayout;
    VkImageLayout              newLayout;
    uint32_t                   srcQueueFamilyIndex;
    uint32_t                   dstQueueFamilyIndex;
    VkImage                    image;
    VkImageSubresourceRange    subresourceRange;
} VkImageMemoryBarrier;</pre>   <h4 id="_members_47">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>srcAccessMask</code> is a bitmask of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> specifying a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a>. </li> <li> <code>dstAccessMask</code> is a bitmask of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> specifying a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access mask</a>. </li> <li> <code>oldLayout</code> is the old layout in an <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-image-layout-transitions">image layout transition</a>. </li> <li> <code>newLayout</code> is the new layout in an <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-image-layout-transitions">image layout transition</a>. </li> <li> <code>srcQueueFamilyIndex</code> is the source queue family for a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers">queue family ownership transfer</a>. </li> <li> <code>dstQueueFamilyIndex</code> is the destination queue family for a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers">queue family ownership transfer</a>. </li> <li> <code>image</code> is a handle to the image affected by this barrier. </li> <li> <code>subresourceRange</code> describes the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views">image subresource range</a> within <code>image</code> that is affected by this barrier. </li> </ul>    <h4 id="_description_209">Description</h4>  <p>The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access to memory through the specified image subresource range, via access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a> specified by <code>srcAccessMask</code>. If <code>srcAccessMask</code> includes <code>VK_ACCESS_HOST_WRITE_BIT</code>, memory writes performed by that access type are also made visible, as that access type is not performed through a resource.</p>   <p>The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access to memory through the specified image subresource range, via access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access mask</a> specified by <code>dstAccessMask</code>. If <code>dstAccessMask</code> includes <code>VK_ACCESS_HOST_WRITE_BIT</code> or <code>VK_ACCESS_HOST_READ_BIT</code>, available memory writes are also made visible to accesses of those types, as those access types are not performed through a resource.</p>   <p>If <code>srcQueueFamilyIndex</code> is not equal to <code>dstQueueFamilyIndex</code>, and <code>srcQueueFamilyIndex</code> is equal to the current queue family, then the memory barrier defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-release">queue family release operation</a> for the specified image subresource range, and the second access scope includes no access, as if <code>dstAccessMask</code> was <code>0</code>.</p>   <p>If <code>dstQueueFamilyIndex</code> is not equal to <code>srcQueueFamilyIndex</code>, and <code>dstQueueFamilyIndex</code> is equal to the current queue family, then the memory barrier defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-acquire">queue family acquire operation</a> for the specified image subresource range, and the first access scope includes no access, as if <code>srcAccessMask</code> was <code>0</code>.</p>   <p>If <code>oldLayout</code> is not equal to <code>newLayout</code>, then the memory barrier defines an <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-image-layout-transitions">image layout transition</a> for the specified image subresource range.</p>   <p>Layout transitions that are performed via image memory barriers execute in their entirety in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order">submission order</a>, relative to other image layout transitions submitted to the same queue, including those performed by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass">render passes</a>. In effect there is an implicit execution dependency from each such layout transition to all layout transitions previously submitted to the same queue.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkImageMemoryBarrier-oldLayout-01197">  <code>oldLayout</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_UNDEFINED</code> or the current layout of the image subresources affected by the barrier </li> <li id="VUID-VkImageMemoryBarrier-newLayout-01198">  <code>newLayout</code> <strong>must</strong> not be <code>VK_IMAGE_LAYOUT_UNDEFINED</code> or <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> </li> <li id="VUID-VkImageMemoryBarrier-image-01199">  If <code>image</code> was created with a sharing mode of <code>VK_SHARING_MODE_CONCURRENT</code>, <code>srcQueueFamilyIndex</code> and <code>dstQueueFamilyIndex</code> <strong>must</strong> both be <code>VK_QUEUE_FAMILY_IGNORED</code> </li> <li id="VUID-VkImageMemoryBarrier-image-01200">  If <code>image</code> was created with a sharing mode of <code>VK_SHARING_MODE_EXCLUSIVE</code>, <code>srcQueueFamilyIndex</code> and <code>dstQueueFamilyIndex</code> <strong>must</strong> either both be <code>VK_QUEUE_FAMILY_IGNORED</code>, or both be a valid queue family (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-queueprops">html/vkspec.html#devsandqueues-queueprops</a>). </li> <li id="VUID-VkImageMemoryBarrier-image-01205">  If <code>image</code> was created with a sharing mode of <code>VK_SHARING_MODE_EXCLUSIVE</code>, and <code>srcQueueFamilyIndex</code> and <code>dstQueueFamilyIndex</code> are not <code>VK_QUEUE_FAMILY_IGNORED</code>, at least one of them <strong>must</strong> be the same as the family of the queue that will execute this barrier </li> <li id="VUID-VkImageMemoryBarrier-subresourceRange-01486">  <code>subresourceRange</code>::<code>baseMipLevel</code> <strong>must</strong> be less than the <code>mipLevels</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-VkImageMemoryBarrier-subresourceRange-01487">  If <code>subresourceRange</code>::<code>levelCount</code> is not <code>VK_REMAINING_MIP_LEVELS</code>, <code>subresourceRange</code>::<code>levelCount</code> <strong>must</strong> be non-zero and <code>subresourceRange</code>::<code>baseMipLevel</code> + <code>subresourceRange</code>::<code>levelCount</code> <strong>must</strong> be less than or equal to the <code>mipLevels</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-VkImageMemoryBarrier-subresourceRange-01488">  <code>subresourceRange</code>::<code>baseArrayLayer</code> <strong>must</strong> be less than the <code>arrayLayers</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-VkImageMemoryBarrier-subresourceRange-01489">  If <code>subresourceRange</code>::<code>layerCount</code> is not <code>VK_REMAINING_ARRAY_LAYERS</code>, <code>subresourceRange</code>::<code>layerCount</code> <strong>must</strong> be non-zero and <code>subresourceRange</code>::<code>baseArrayLayer</code> + <code>subresourceRange</code>::<code>layerCount</code> <strong>must</strong> be less than or equal to the <code>arrayLayers</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-VkImageMemoryBarrier-image-01207">  If <code>image</code> has a depth/stencil format with both depth and stencil components, then <code>aspectMask</code> member of <code>subresourceRange</code> <strong>must</strong> include both <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> and <code>VK_IMAGE_ASPECT_STENCIL_BIT</code> </li> <li id="VUID-VkImageMemoryBarrier-oldLayout-01208">  If either <code>oldLayout</code> or <code>newLayout</code> is <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> then <code>image</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code> set </li> <li id="VUID-VkImageMemoryBarrier-oldLayout-01209">  If either <code>oldLayout</code> or <code>newLayout</code> is <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> then <code>image</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code> set </li> <li id="VUID-VkImageMemoryBarrier-oldLayout-01210">  If either <code>oldLayout</code> or <code>newLayout</code> is <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code> then <code>image</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code> set </li> <li id="VUID-VkImageMemoryBarrier-oldLayout-01211">  If either <code>oldLayout</code> or <code>newLayout</code> is <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code> then <code>image</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_SAMPLED_BIT</code> or <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> set </li> <li id="VUID-VkImageMemoryBarrier-oldLayout-01212">  If either <code>oldLayout</code> or <code>newLayout</code> is <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> then <code>image</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> set </li> <li id="VUID-VkImageMemoryBarrier-oldLayout-01213">  If either <code>oldLayout</code> or <code>newLayout</code> is <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> then <code>image</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> set </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkImageMemoryBarrier-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER</code> </li> <li id="VUID-VkImageMemoryBarrier-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkImageMemoryBarrier-srcAccessMask-parameter">  <code>srcAccessMask</code> <strong>must</strong> be a valid combination of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> values </li> <li id="VUID-VkImageMemoryBarrier-dstAccessMask-parameter">  <code>dstAccessMask</code> <strong>must</strong> be a valid combination of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> values </li> <li id="VUID-VkImageMemoryBarrier-oldLayout-parameter">  <code>oldLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-VkImageMemoryBarrier-newLayout-parameter">  <code>newLayout</code> <strong>must</strong> be a valid <a href="#VkImageLayout">VkImageLayout</a> value </li> <li id="VUID-VkImageMemoryBarrier-image-parameter">  <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-VkImageMemoryBarrier-subresourceRange-parameter">  <code>subresourceRange</code> <strong>must</strong> be a valid <code>VkImageSubresourceRange</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_209">See Also</h4>  <p><a href="#VkAccessFlags">VkAccessFlags</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageLayout">VkImageLayout</a>, <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a>, <a href="#vkCmdWaitEvents">vkCmdWaitEvents</a></p>    <h4 id="_document_notes_209">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageMemoryBarrier">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageMemoryBarrier</a></p>         <h3 id="_vkimageresolve_3">VkImageResolve(3)</h3>  <h4 id="_name_210">Name</h4>  <p>VkImageResolve - Structure specifying an image resolve operation</p>    <h4 id="_c_specification_210">C Specification</h4>  <p>The <code>VkImageResolve</code> structure is defined as:</p>  <pre id="VkImageResolve" data-language="c++">typedef struct VkImageResolve {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageResolve;</pre>   <h4 id="_members_48">Members</h4>  <ul> <li> <code>srcSubresource</code> and <code>dstSubresource</code> are <a href="#VkImageSubresourceLayers">VkImageSubresourceLayers</a> structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported. </li> <li> <code>srcOffset</code> and <code>dstOffset</code> select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data. </li> <li> <code>extent</code> is the size in texels of the source image to resolve in <code>width</code>, <code>height</code> and <code>depth</code>. </li> </ul>    <h4 id="_description_210">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkImageResolve-aspectMask-00266">  The <code>aspectMask</code> member of <code>srcSubresource</code> and <code>dstSubresource</code> <strong>must</strong> only contain <code>VK_IMAGE_ASPECT_COLOR_BIT</code> </li> <li id="VUID-VkImageResolve-layerCount-00267">  The <code>layerCount</code> member of <code>srcSubresource</code> and <code>dstSubresource</code> <strong>must</strong> match </li> <li id="VUID-VkImageResolve-srcImage-00268">  If either of the calling command’s <code>srcImage</code> or <code>dstImage</code> parameters are of <a href="#VkImageType">VkImageType</a> <code>VK_IMAGE_TYPE_3D</code>, the <code>baseArrayLayer</code> and <code>layerCount</code> members of both <code>srcSubresource</code> and <code>dstSubresource</code> <strong>must</strong> be <code>0</code> and <code>1</code>, respectively </li> <li id="VUID-VkImageResolve-srcOffset-00269">  <code>srcOffset.x</code> and (<code>extent.width</code> + <code>srcOffset.x</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the source image subresource width </li> <li id="VUID-VkImageResolve-srcOffset-00270">  <code>srcOffset.y</code> and (<code>extent.height</code> + <code>srcOffset.y</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the source image subresource height </li> <li id="VUID-VkImageResolve-srcImage-00271">  If the calling command’s <code>srcImage</code> is of type <code>VK_IMAGE_TYPE_1D</code>, then <code>srcOffset.y</code> <strong>must</strong> be <code>0</code> and <code>extent.height</code> <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageResolve-srcOffset-00272">  <code>srcOffset.z</code> and (<code>extent.depth</code> + <code>srcOffset.z</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the source image subresource depth </li> <li id="VUID-VkImageResolve-srcImage-00273">  If the calling command’s <code>srcImage</code> is of type <code>VK_IMAGE_TYPE_1D</code> or <code>VK_IMAGE_TYPE_2D</code>, then <code>srcOffset.z</code> <strong>must</strong> be <code>0</code> and <code>extent.depth</code> <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageResolve-dstOffset-00274">  <code>dstOffset.x</code> and (<code>extent.width</code> + <code>dstOffset.x</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the destination image subresource width </li> <li id="VUID-VkImageResolve-dstOffset-00275">  <code>dstOffset.y</code> and (<code>extent.height</code> + <code>dstOffset.y</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the destination image subresource height </li> <li id="VUID-VkImageResolve-dstImage-00276">  If the calling command’s <code>dstImage</code> is of type <code>VK_IMAGE_TYPE_1D</code>, then <code>dstOffset.y</code> <strong>must</strong> be <code>0</code> and <code>extent.height</code> <strong>must</strong> be <code>1</code>. </li> <li id="VUID-VkImageResolve-dstOffset-00277">  <code>dstOffset.z</code> and (<code>extent.depth</code> + <code>dstOffset.z</code>) <strong>must</strong> both be greater than or equal to <code>0</code> and less than or equal to the destination image subresource depth </li> <li id="VUID-VkImageResolve-dstImage-00278">  If the calling command’s <code>dstImage</code> is of type <code>VK_IMAGE_TYPE_1D</code> or <code>VK_IMAGE_TYPE_2D</code>, then <code>dstOffset.z</code> <strong>must</strong> be <code>0</code> and <code>extent.depth</code> <strong>must</strong> be <code>1</code>. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkImageResolve-srcSubresource-parameter">  <code>srcSubresource</code> <strong>must</strong> be a valid <code>VkImageSubresourceLayers</code> structure </li> <li id="VUID-VkImageResolve-dstSubresource-parameter">  <code>dstSubresource</code> <strong>must</strong> be a valid <code>VkImageSubresourceLayers</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_210">See Also</h4>  <p><a href="#VkExtent3D">VkExtent3D</a>, <a href="#VkImageSubresourceLayers">VkImageSubresourceLayers</a>, <a href="#VkOffset3D">VkOffset3D</a>, <a href="#vkCmdResolveImage">vkCmdResolveImage</a></p>    <h4 id="_document_notes_210">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageResolve">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageResolve</a></p>         <h3 id="_vkimagesubresource_3">VkImageSubresource(3)</h3>  <h4 id="_name_211">Name</h4>  <p>VkImageSubresource - Structure specifying a image subresource</p>    <h4 id="_c_specification_211">C Specification</h4>  <p>The <code>VkImageSubresource</code> structure is defined as:</p>  <pre id="VkImageSubresource" data-language="c++">typedef struct VkImageSubresource {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              arrayLayer;
} VkImageSubresource;</pre>   <h4 id="_members_49">Members</h4>  <ul> <li> <code>aspectMask</code> is a <a href="#VkImageAspectFlags">VkImageAspectFlags</a> selecting the image <em>aspect</em>. </li> <li> <code>mipLevel</code> selects the mipmap level. </li> <li> <code>arrayLayer</code> selects the array layer. </li> </ul>    <h4 id="_description_211">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkImageSubresource-mipLevel-00998">  <code>mipLevel</code> <strong>must</strong> be less than the <code>mipLevels</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when the image was created </li> <li id="VUID-VkImageSubresource-arrayLayer-00999">  <code>arrayLayer</code> <strong>must</strong> be less than the <code>arrayLayers</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when the image was created </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkImageSubresource-aspectMask-parameter">  <code>aspectMask</code> <strong>must</strong> be a valid combination of <a href="#VkImageAspectFlagBits">VkImageAspectFlagBits</a> values </li> <li id="VUID-VkImageSubresource-aspectMask-requiredbitmask">  <code>aspectMask</code> <strong>must</strong> not be <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_211">See Also</h4>  <p><a href="#VkImageAspectFlags">VkImageAspectFlags</a>, <a href="#VkSparseImageMemoryBind">VkSparseImageMemoryBind</a>, <a href="#vkGetImageSubresourceLayout">vkGetImageSubresourceLayout</a></p>    <h4 id="_document_notes_211">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageSubresource">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageSubresource</a></p>         <h3 id="_vkimagesubresourcelayers_3">VkImageSubresourceLayers(3)</h3>  <h4 id="_name_212">Name</h4>  <p>VkImageSubresourceLayers - Structure specifying a image subresource layers</p>    <h4 id="_c_specification_212">C Specification</h4>  <p>The <code>VkImageSubresourceLayers</code> structure is defined as:</p>  <pre id="VkImageSubresourceLayers" data-language="c++">typedef struct VkImageSubresourceLayers {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceLayers;</pre>   <h4 id="_members_50">Members</h4>  <ul> <li> <code>aspectMask</code> is a combination of <a href="#VkImageAspectFlagBits">VkImageAspectFlagBits</a>, selecting the color, depth and/or stencil aspects to be copied. </li> <li> <code>mipLevel</code> is the mipmap level to copy from. </li> <li> <code>baseArrayLayer</code> and <code>layerCount</code> are the starting layer and number of layers to copy. </li> </ul>    <h4 id="_description_212">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkImageSubresourceLayers-aspectMask-00167">  If <code>aspectMask</code> contains <code>VK_IMAGE_ASPECT_COLOR_BIT</code>, it <strong>must</strong> not contain either of <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> or <code>VK_IMAGE_ASPECT_STENCIL_BIT</code> </li> <li id="VUID-VkImageSubresourceLayers-aspectMask-00168">  <code>aspectMask</code> <strong>must</strong> not contain <code>VK_IMAGE_ASPECT_METADATA_BIT</code> </li> <li id="VUID-VkImageSubresourceLayers-mipLevel-00169">  <code>mipLevel</code> <strong>must</strong> be less than the <code>mipLevels</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when the image was created </li> <li id="VUID-VkImageSubresourceLayers-baseArrayLayer-00170">  (<code>baseArrayLayer</code> + <code>layerCount</code>) <strong>must</strong> be less than or equal to the <code>arrayLayers</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when the image was created </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkImageSubresourceLayers-aspectMask-parameter">  <code>aspectMask</code> <strong>must</strong> be a valid combination of <a href="#VkImageAspectFlagBits">VkImageAspectFlagBits</a> values </li> <li id="VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask">  <code>aspectMask</code> <strong>must</strong> not be <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_212">See Also</h4>  <p><a href="#VkBufferImageCopy">VkBufferImageCopy</a>, <a href="#VkImageAspectFlags">VkImageAspectFlags</a>, <a href="#VkImageBlit">VkImageBlit</a>, <a href="#VkImageCopy">VkImageCopy</a>, <a href="#VkImageResolve">VkImageResolve</a></p>    <h4 id="_document_notes_212">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageSubresourceLayers">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageSubresourceLayers</a></p>         <h3 id="_vkimagesubresourcerange_3">VkImageSubresourceRange(3)</h3>  <h4 id="_name_213">Name</h4>  <p>VkImageSubresourceRange - Structure specifying a image subresource range</p>    <h4 id="_c_specification_213">C Specification</h4>  <p>The <code>VkImageSubresourceRange</code> structure is defined as:</p>  <pre id="VkImageSubresourceRange" data-language="c++">typedef struct VkImageSubresourceRange {
    VkImageAspectFlags    aspectMask;
    uint32_t              baseMipLevel;
    uint32_t              levelCount;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceRange;</pre>   <h4 id="_members_51">Members</h4>  <ul> <li> <code>aspectMask</code> is a bitmask of <a href="#VkImageAspectFlagBits">VkImageAspectFlagBits</a> specifying which aspect(s) of the image are included in the view. </li> <li> <code>baseMipLevel</code> is the first mipmap level accessible to the view. </li> <li> <code>levelCount</code> is the number of mipmap levels (starting from <code>baseMipLevel</code>) accessible to the view. </li> <li> <code>baseArrayLayer</code> is the first array layer accessible to the view. </li> <li> <code>layerCount</code> is the number of array layers (starting from <code>baseArrayLayer</code>) accessible to the view. </li> </ul>    <h4 id="_description_213">Description</h4>  <p>The number of mipmap levels and array layers <strong>must</strong> be a subset of the image subresources in the image. If an application wants to use all mip levels or layers in an image after the <code>baseMipLevel</code> or <code>baseArrayLayer</code>, it <strong>can</strong> set <code>levelCount</code> and <code>layerCount</code> to the special values <code>VK_REMAINING_MIP_LEVELS</code> and <code>VK_REMAINING_ARRAY_LAYERS</code> without knowing the exact number of mip levels or layers.</p>   <p>For cube and cube array image views, the layers of the image view starting at <code>baseArrayLayer</code> correspond to faces in the order +X, -X, +Y, -Y, +Z, -Z. For cube arrays, each set of six sequential layers is a single cube, so the number of cube maps in a cube map array view is <em><code>layerCount</code> / 6</em>, and image array layer (<code>baseArrayLayer</code> + i) is face index (i mod 6) of cube <em>i / 6</em>. If the number of layers in the view, whether set explicitly in <code>layerCount</code> or implied by <code>VK_REMAINING_ARRAY_LAYERS</code>, is not a multiple of 6, behavior when indexing the last cube is undefined.</p>   <p><code>aspectMask</code> <strong>must</strong> be only <code>VK_IMAGE_ASPECT_COLOR_BIT</code>, <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> or <code>VK_IMAGE_ASPECT_STENCIL_BIT</code> if <code>format</code> is a color, depth-only or stencil-only format, respectively. If using a depth/stencil format with both depth and stencil components, <code>aspectMask</code> <strong>must</strong> include at least one of <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> and <code>VK_IMAGE_ASPECT_STENCIL_BIT</code>, and <strong>can</strong> include both.</p>   <p>When using an imageView of a depth/stencil image to populate a descriptor set (e.g. for sampling in the shader, or for use as an input attachment), the <code>aspectMask</code> <strong>must</strong> only include one bit and selects whether the imageView is used for depth reads (i.e. using a floating-point sampler or input attachment in the shader) or stencil reads (i.e. using an unsigned integer sampler or input attachment in the shader). When an imageView of a depth/stencil image is used as a depth/stencil framebuffer attachment, the <code>aspectMask</code> is ignored and both depth and stencil image subresources are used.</p>   <p>The <code>components</code> member is of type <a href="#VkComponentMapping">VkComponentMapping</a>, and describes a remapping from components of the image to components of the vector returned by shader image instructions. This remapping <strong>must</strong> be identity for storage image descriptors, input attachment descriptors, and framebuffer attachments.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkImageSubresourceRange-aspectMask-parameter">  <code>aspectMask</code> <strong>must</strong> be a valid combination of <a href="#VkImageAspectFlagBits">VkImageAspectFlagBits</a> values </li> <li id="VUID-VkImageSubresourceRange-aspectMask-requiredbitmask">  <code>aspectMask</code> <strong>must</strong> not be <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_213">See Also</h4>  <p><a href="#VkImageAspectFlags">VkImageAspectFlags</a>, <a href="#VkImageMemoryBarrier">VkImageMemoryBarrier</a>, <a href="#VkImageViewCreateInfo">VkImageViewCreateInfo</a>, <a href="#vkCmdClearColorImage">vkCmdClearColorImage</a>, <a href="#vkCmdClearDepthStencilImage">vkCmdClearDepthStencilImage</a></p>    <h4 id="_document_notes_213">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageSubresourceRange">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageSubresourceRange</a></p>         <h3 id="_vkimageviewcreateinfo_3">VkImageViewCreateInfo(3)</h3>  <h4 id="_name_214">Name</h4>  <p>VkImageViewCreateInfo - Structure specifying parameters of a newly created image view</p>    <h4 id="_c_specification_214">C Specification</h4>  <p>The <code>VkImageViewCreateInfo</code> structure is defined as:</p>  <pre id="VkImageViewCreateInfo" data-language="c++">typedef struct VkImageViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkImageViewCreateFlags     flags;
    VkImage                    image;
    VkImageViewType            viewType;
    VkFormat                   format;
    VkComponentMapping         components;
    VkImageSubresourceRange    subresourceRange;
} VkImageViewCreateInfo;</pre>   <h4 id="_members_52">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>image</code> is a <code>VkImage</code> on which the view will be created. </li> <li> <code>viewType</code> is an <a href="#VkImageViewType">VkImageViewType</a> value specifying the type of the image view. </li> <li> <code>format</code> is a <a href="#VkFormat">VkFormat</a> describing the format and type used to interpret data elements in the image. </li> <li> <code>components</code> is a <a href="#VkComponentMapping">VkComponentMapping</a> specifies a remapping of color components (or of depth or stencil components after they have been converted into color components). </li> <li> <code>subresourceRange</code> is a <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a> selecting the set of mipmap levels and array layers to be accessible to the view. </li> </ul>    <h4 id="_description_214">Description</h4>  <p>If <code>image</code> was created with the <code>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</code> flag, <code>format</code> <strong>can</strong> be different from the image’s format, but if they are not equal they <strong>must</strong> be <em>compatible</em>. Image format compatibility is defined in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-formats-compatibility-classes">Format Compatibility Classes</a> section. Views of compatible formats will have the same mapping between texel coordinates and memory locations irrespective of the <code>format</code>, with only the interpretation of the bit pattern changing.</p>  <blockquote> <h5 class="title">Note</h5>  <p>Values intended to be used with one view format <strong>may</strong> not be exactly preserved when written or read through a different format. For example, an integer value that happens to have the bit pattern of a floating point denorm or NaN <strong>may</strong> be flushed or canonicalized when written or read through a view with a floating point format. Similarly, a value written through a signed normalized format that has a bit pattern exactly equal to -2<sup>b</sup> <strong>may</strong> be changed to -2<sup>b</sup> + 1 as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-fixedfpconv">Conversion from Normalized Fixed-Point to Floating-Point</a>.</p>  </blockquote> <div class="_table"><table id="resources-image-views-compatibility" class="tableblock frame-all grid-all spread"> <caption class="title">Table 6. Image and image view parameter compatibility requirements</caption> <colgroup> <col style="width: 15%;"> <col style="width: 35%;"> <col style="width: 50%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Dim, Arrayed, MS</th> <th class="tableblock halign-left valign-top">Image parameters</th> <th class="tableblock halign-left valign-top">View parameters</th> </tr> </thead> <tbody> <tr> <th class="tableblock halign-left valign-top"></th> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code> = ci.<code>imageType</code><br> <code>width</code> = ci.<code>extent.width</code><br> <code>height</code> = ci.<code>extent.height</code><br> <code>depth</code> = ci.<code>extent.depth</code><br> <code>arrayLayers</code> = ci.<code>arrayLayers</code><br> <code>samples</code> = ci.<code>samples</code><br> <code>flags</code> = ci.<code>flags</code><br> where ci is the <a href="#VkImageCreateInfo">VkImageCreateInfo</a> used to create <code>image</code>.</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>baseArrayLayer</code> and <code>layerCount</code> are members of the <code>subresourceRange</code> member.</p></td> </tr> <tr> <th class="tableblock halign-left valign-top"><p class="tableblock">1D, 0, 0</p></th> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code> = <code>VK_IMAGE_TYPE_1D</code><br> <code>width</code> ≥ 1<br> <code>height</code> = 1<br> <code>depth</code> = 1<br> <code>arrayLayers</code> ≥ 1<br> <code>samples</code> = 1</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_1D</code><br> <code>baseArrayLayer</code> ≥ 0<br> <code>layerCount</code> = 1</p></td> </tr> <tr> <th class="tableblock halign-left valign-top"><p class="tableblock">1D, 1, 0</p></th> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code> = <code>VK_IMAGE_TYPE_1D</code><br> <code>width</code> ≥ 1<br> <code>height</code> = 1<br> <code>depth</code> = 1<br> <code>arrayLayers</code> ≥ 1<br> <code>samples</code> = 1</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_1D_ARRAY</code><br> <code>baseArrayLayer</code> ≥ 0<br> <code>layerCount</code> ≥ 1</p></td> </tr> <tr> <th class="tableblock halign-left valign-top"><p class="tableblock">2D, 0, 0</p></th> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br> <code>width</code> ≥ 1<br> <code>height</code> ≥ 1<br> <code>depth</code> = 1<br> <code>arrayLayers</code> ≥ 1<br> <code>samples</code> = 1</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_2D</code><br> <code>baseArrayLayer</code> ≥ 0<br> <code>layerCount</code> = 1</p></td> </tr> <tr> <th class="tableblock halign-left valign-top"><p class="tableblock">2D, 1, 0</p></th> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br> <code>width</code> ≥ 1<br> <code>height</code> ≥ 1<br> <code>depth</code> = 1<br> <code>arrayLayers</code> ≥ 1<br> <code>samples</code> = 1</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code><br> <code>baseArrayLayer</code> ≥ 0<br> <code>layerCount</code> ≥ 1</p></td> </tr> <tr> <th class="tableblock halign-left valign-top"><p class="tableblock">2D, 0, 1</p></th> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br> <code>width</code> ≥ 1<br> <code>height</code> ≥ 1<br> <code>depth</code> = 1<br> <code>arrayLayers</code> ≥ 1<br> <code>samples</code> &gt; 1</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_2D</code><br> <code>baseArrayLayer</code> ≥ 0<br> <code>layerCount</code> = 1</p></td> </tr> <tr> <th class="tableblock halign-left valign-top"><p class="tableblock">2D, 1, 1</p></th> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br> <code>width</code> ≥ 1<br> <code>height</code> ≥ 1<br> <code>depth</code> = 1<br> <code>arrayLayers</code> ≥ 1<br> <code>samples</code> &gt; 1</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code><br> <code>baseArrayLayer</code> ≥ 0<br> <code>layerCount</code> ≥ 1</p></td> </tr> <tr> <th class="tableblock halign-left valign-top"><p class="tableblock">CUBE, 0, 0</p></th> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br> <code>width</code> ≥ 1<br> <code>height</code> = <code>width</code><br> <code>depth</code> = 1<br> <code>arrayLayers</code> ≥ 6<br> <code>samples</code> = 1<br> <code>flags</code> includes <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_CUBE</code><br> <code>baseArrayLayer</code> ≥ 0<br> <code>layerCount</code> = 6</p></td> </tr> <tr> <th class="tableblock halign-left valign-top"><p class="tableblock">CUBE, 1, 0</p></th> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br> <code>width</code> ≥ 1<br> <code>height</code> = width<br> <code>depth</code> = 1<br> <em>N</em> ≥ 1<br> <code>arrayLayers</code> ≥ 6 × <em>N</em><br> <code>samples</code> = 1<br> <code>flags</code> includes <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code><br> <code>baseArrayLayer</code> ≥ 0<br> <code>layerCount</code> = 6 × <em>N</em>, <em>N</em> ≥ 1</p></td> </tr> <tr> <th class="tableblock halign-left valign-top"><p class="tableblock">3D, 0, 0</p></th> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageType</code> = <code>VK_IMAGE_TYPE_3D</code><br> <code>width</code> ≥ 1<br> <code>height</code> ≥ 1<br> <code>depth</code> ≥ 1<br> <code>arrayLayers</code> = 1<br> <code>samples</code> = 1</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_3D</code><br> <code>baseArrayLayer</code> = 0<br> <code>layerCount</code> = 1</p></td> </tr> </tbody> </table></div> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkImageViewCreateInfo-image-01003">  If <code>image</code> was not created with <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code> then <code>viewType</code> <strong>must</strong> not be <code>VK_IMAGE_VIEW_TYPE_CUBE</code> or <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code> </li> <li id="VUID-VkImageViewCreateInfo-viewType-01004">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-imageCubeArray">image cubemap arrays</a> feature is not enabled, <code>viewType</code> <strong>must</strong> not be <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01006">  If <code>image</code> was created with <code>VK_IMAGE_TILING_LINEAR</code>, <code>format</code> <strong>must</strong> be format that has at least one supported feature bit present in the value of <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01007">  <code>image</code> <strong>must</strong> have been created with a <code>usage</code> value containing at least one of <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, <code>VK_IMAGE_USAGE_STORAGE_BIT</code>, <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code>, <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code>, or <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01008">  If <code>image</code> was created with <code>VK_IMAGE_TILING_LINEAR</code> and <code>usage</code> contains <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, <code>format</code> <strong>must</strong> be supported for sampled images, as specified by the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01009">  If <code>image</code> was created with <code>VK_IMAGE_TILING_LINEAR</code> and <code>usage</code> contains <code>VK_IMAGE_USAGE_STORAGE_BIT</code>, <code>format</code> <strong>must</strong> be supported for storage images, as specified by the <code>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01010">  If <code>image</code> was created with <code>VK_IMAGE_TILING_LINEAR</code> and <code>usage</code> contains <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code>, <code>format</code> <strong>must</strong> be supported for color attachments, as specified by the <code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01011">  If <code>image</code> was created with <code>VK_IMAGE_TILING_LINEAR</code> and <code>usage</code> contains <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code>, <code>format</code> <strong>must</strong> be supported for depth/stencil attachments, as specified by the <code>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</code> flag in <code>VkFormatProperties</code>::<code>linearTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01012">  If <code>image</code> was created with <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>format</code> <strong>must</strong> be format that has at least one supported feature bit present in the value of <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01013">  If <code>image</code> was created with <code>VK_IMAGE_TILING_OPTIMAL</code> and <code>usage</code> contains <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, <code>format</code> <strong>must</strong> be supported for sampled images, as specified by the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code> flag in <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01014">  If <code>image</code> was created with <code>VK_IMAGE_TILING_OPTIMAL</code> and <code>usage</code> contains <code>VK_IMAGE_USAGE_STORAGE_BIT</code>, <code>format</code> <strong>must</strong> be supported for storage images, as specified by the <code>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</code> flag in <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01015">  If <code>image</code> was created with <code>VK_IMAGE_TILING_OPTIMAL</code> and <code>usage</code> contains <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code>, <code>format</code> <strong>must</strong> be supported for color attachments, as specified by the <code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</code> flag in <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01016">  If <code>image</code> was created with <code>VK_IMAGE_TILING_OPTIMAL</code> and <code>usage</code> contains <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code>, <code>format</code> <strong>must</strong> be supported for depth/stencil attachments, as specified by the <code>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</code> flag in <code>VkFormatProperties</code>::<code>optimalTilingFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> with the same value of <code>format</code> </li> <li id="VUID-VkImageViewCreateInfo-subresourceRange-01478">  <code>subresourceRange</code>::<code>baseMipLevel</code> <strong>must</strong> be less than the <code>mipLevels</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-VkImageViewCreateInfo-subresourceRange-01479">  If <code>subresourceRange</code>::<code>levelCount</code> is not <code>VK_REMAINING_MIP_LEVELS</code>, <code>subresourceRange</code>::<code>levelCount</code> <strong>must</strong> be non-zero and <code>subresourceRange</code>::<code>baseMipLevel</code> + <code>subresourceRange</code>::<code>levelCount</code> <strong>must</strong> be less than or equal to the <code>mipLevels</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-VkImageViewCreateInfo-subresourceRange-01480">  <code>subresourceRange</code>::<code>baseArrayLayer</code> <strong>must</strong> be less than the <code>arrayLayers</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-VkImageViewCreateInfo-subresourceRange-01481">  If <code>subresourceRange</code>::<code>layerCount</code> is not <code>VK_REMAINING_ARRAY_LAYERS</code>, <code>subresourceRange</code>::<code>layerCount</code> <strong>must</strong> be non-zero and <code>subresourceRange</code>::<code>baseArrayLayer</code> + <code>subresourceRange</code>::<code>layerCount</code> <strong>must</strong> be less than or equal to the <code>arrayLayers</code> specified in <a href="#VkImageCreateInfo">VkImageCreateInfo</a> when <code>image</code> was created </li> <li id="VUID-VkImageViewCreateInfo-image-01018">  If <code>image</code> was created with the <code>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</code> flag, <code>format</code> <strong>must</strong> be compatible with the <code>format</code> used to create <code>image</code>, as defined in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-formats-compatibility-classes">Format Compatibility Classes</a> </li> <li id="VUID-VkImageViewCreateInfo-image-01019">  If <code>image</code> was not created with the <code>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</code> flag, <code>format</code> <strong>must</strong> be identical to the <code>format</code> used to create <code>image</code> </li> <li id="VUID-VkImageViewCreateInfo-image-01020">  If <code>image</code> is non-sparse then it <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-VkImageViewCreateInfo-subResourceRange-01021">  <code>subresourceRange</code> and <code>viewType</code> <strong>must</strong> be compatible with the image, as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views-compatibility">compatibility table</a> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkImageViewCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</code> </li> <li id="VUID-VkImageViewCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkImageViewCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkImageViewCreateInfo-image-parameter">  <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-VkImageViewCreateInfo-viewType-parameter">  <code>viewType</code> <strong>must</strong> be a valid <a href="#VkImageViewType">VkImageViewType</a> value </li> <li id="VUID-VkImageViewCreateInfo-format-parameter">  <code>format</code> <strong>must</strong> be a valid <a href="#VkFormat">VkFormat</a> value </li> <li id="VUID-VkImageViewCreateInfo-components-parameter">  <code>components</code> <strong>must</strong> be a valid <code>VkComponentMapping</code> structure </li> <li id="VUID-VkImageViewCreateInfo-subresourceRange-parameter">  <code>subresourceRange</code> <strong>must</strong> be a valid <code>VkImageSubresourceRange</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_214">See Also</h4>  <p><a href="#VkComponentMapping">VkComponentMapping</a>, <a href="#VkFormat">VkFormat</a>, <a href="#VkImage">VkImage</a>, <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>, <a href="#VkImageViewCreateFlags">VkImageViewCreateFlags</a>, <a href="#VkImageViewType">VkImageViewType</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateImageView">vkCreateImageView</a></p>    <h4 id="_document_notes_214">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageViewCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageViewCreateInfo</a></p>         <h3 id="_vkinstancecreateinfo_3">VkInstanceCreateInfo(3)</h3>  <h4 id="_name_215">Name</h4>  <p>VkInstanceCreateInfo - Structure specifying parameters of a newly created instance</p>    <h4 id="_c_specification_215">C Specification</h4>  <p>The <code>VkInstanceCreateInfo</code> structure is defined as:</p>  <pre id="VkInstanceCreateInfo" data-language="c++">typedef struct VkInstanceCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkInstanceCreateFlags       flags;
    const VkApplicationInfo*    pApplicationInfo;
    uint32_t                    enabledLayerCount;
    const char* const*          ppEnabledLayerNames;
    uint32_t                    enabledExtensionCount;
    const char* const*          ppEnabledExtensionNames;
} VkInstanceCreateInfo;</pre>   <h4 id="_members_53">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>pApplicationInfo</code> is <code>NULL</code> or a pointer to an instance of <code>VkApplicationInfo</code>. If not <code>NULL</code>, this information helps implementations recognize behavior inherent to classes of applications. <a href="#VkApplicationInfo">VkApplicationInfo</a> is defined in detail below. </li> <li> <code>enabledLayerCount</code> is the number of global layers to enable. </li> <li> <code>ppEnabledLayerNames</code> is a pointer to an array of <code>enabledLayerCount</code> null-terminated UTF-8 strings containing the names of layers to enable for the created instance. See the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#extended-functionality-layers">Layers</a> section for further details. </li> <li> <code>enabledExtensionCount</code> is the number of global extensions to enable. </li> <li> <code>ppEnabledExtensionNames</code> is a pointer to an array of <code>enabledExtensionCount</code> null-terminated UTF-8 strings containing the names of extensions to enable. </li> </ul>    <h4 id="_description_215">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkInstanceCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</code> </li> <li id="VUID-VkInstanceCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkInstanceCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkInstanceCreateInfo-pApplicationInfo-parameter">  If <code>pApplicationInfo</code> is not <code>NULL</code>, <code>pApplicationInfo</code> <strong>must</strong> be a pointer to a valid <code>VkApplicationInfo</code> structure </li> <li id="VUID-VkInstanceCreateInfo-ppEnabledLayerNames-parameter">  If <code>enabledLayerCount</code> is not <code>0</code>, <code>ppEnabledLayerNames</code> <strong>must</strong> be a pointer to an array of <code>enabledLayerCount</code> null-terminated UTF-8 strings </li> <li id="VUID-VkInstanceCreateInfo-ppEnabledExtensionNames-parameter">  If <code>enabledExtensionCount</code> is not <code>0</code>, <code>ppEnabledExtensionNames</code> <strong>must</strong> be a pointer to an array of <code>enabledExtensionCount</code> null-terminated UTF-8 strings </li> </ul>   </blockquote>   <h4 id="_see_also_215">See Also</h4>  <p><a href="#VkApplicationInfo">VkApplicationInfo</a>, <a href="#VkInstanceCreateFlags">VkInstanceCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateInstance">vkCreateInstance</a></p>    <h4 id="_document_notes_215">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkInstanceCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkInstanceCreateInfo</a></p>         <h3 id="_vklayerproperties_3">VkLayerProperties(3)</h3>  <h4 id="_name_216">Name</h4>  <p>VkLayerProperties - Structure specifying layer properties</p>    <h4 id="_c_specification_216">C Specification</h4>  <p>The <code>VkLayerProperties</code> structure is defined as:</p>  <pre id="VkLayerProperties" data-language="c++">typedef struct VkLayerProperties {
    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
    uint32_t    implementationVersion;
    char        description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties;</pre>   <h4 id="_members_54">Members</h4>  <ul> <li> <code>layerName</code> is a null-terminated UTF-8 string specifying the name of the layer. Use this name in the <code>ppEnabledLayerNames</code> array passed in the <a href="#VkInstanceCreateInfo">VkInstanceCreateInfo</a> structure to enable this layer for an instance. </li> <li> <code>specVersion</code> is the Vulkan version the layer was written to, encoded as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-versionnum">API Version Numbers and Semantics</a> section. </li> <li> <code>implementationVersion</code> is the version of this layer. It is an integer, increasing with backward compatible changes. </li> <li> <code>description</code> is a null-terminated UTF-8 string providing additional details that <strong>can</strong> be used by the application to identify the layer. </li> </ul>       <h4 id="_see_also_216">See Also</h4>  <p><a href="#vkEnumerateDeviceLayerProperties">vkEnumerateDeviceLayerProperties</a>, <a href="#vkEnumerateInstanceLayerProperties">vkEnumerateInstanceLayerProperties</a></p>    <h4 id="_document_notes_216">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkLayerProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkLayerProperties</a></p>         <h3 id="_vkmappedmemoryrange_3">VkMappedMemoryRange(3)</h3>  <h4 id="_name_217">Name</h4>  <p>VkMappedMemoryRange - Structure specifying a mapped memory range</p>    <h4 id="_c_specification_217">C Specification</h4>  <p>The <code>VkMappedMemoryRange</code> structure is defined as:</p>  <pre id="VkMappedMemoryRange" data-language="c++">typedef struct VkMappedMemoryRange {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkMappedMemoryRange;</pre>   <h4 id="_members_55">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>memory</code> is the memory object to which this range belongs. </li> <li> <code>offset</code> is the zero-based byte offset from the beginning of the memory object. </li> <li> <code>size</code> is either the size of range, or <code>VK_WHOLE_SIZE</code> to affect the range from <code>offset</code> to the end of the current mapping of the allocation. </li> </ul>    <h4 id="_description_217">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkMappedMemoryRange-memory-00684">  <code>memory</code> <strong>must</strong> currently be mapped </li> <li id="VUID-VkMappedMemoryRange-size-00685">  If <code>size</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>offset</code> and <code>size</code> <strong>must</strong> specify a range contained within the currently mapped range of <code>memory</code> </li> <li id="VUID-VkMappedMemoryRange-size-00686">  If <code>size</code> is equal to <code>VK_WHOLE_SIZE</code>, <code>offset</code> <strong>must</strong> be within the currently mapped range of <code>memory</code> </li> <li id="VUID-VkMappedMemoryRange-size-01389">  If <code>size</code> is equal to <code>VK_WHOLE_SIZE</code>, the end of the current mapping of <code>memory</code> <strong>must</strong> be a multiple of <code>VkPhysicalDeviceLimits</code>::<code>nonCoherentAtomSize</code> bytes from the beginning of the memory object. </li> <li id="VUID-VkMappedMemoryRange-offset-00687">  <code>offset</code> <strong>must</strong> be a multiple of <code>VkPhysicalDeviceLimits</code>::<code>nonCoherentAtomSize</code> </li> <li id="VUID-VkMappedMemoryRange-size-01390">  If <code>size</code> is not equal to <code>VK_WHOLE_SIZE</code>, <code>size</code> <strong>must</strong> either be a multiple of <code>VkPhysicalDeviceLimits</code>::<code>nonCoherentAtomSize</code>, or <code>offset</code> plus <code>size</code> <strong>must</strong> equal the size of <code>memory</code>. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkMappedMemoryRange-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE</code> </li> <li id="VUID-VkMappedMemoryRange-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkMappedMemoryRange-memory-parameter">  <code>memory</code> <strong>must</strong> be a valid <code>VkDeviceMemory</code> handle </li> </ul>   </blockquote>   <h4 id="_see_also_217">See Also</h4>  <p><a href="#VkDeviceMemory">VkDeviceMemory</a>, <code>VkDeviceSize</code>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkFlushMappedMemoryRanges">vkFlushMappedMemoryRanges</a>, <a href="#vkInvalidateMappedMemoryRanges">vkInvalidateMappedMemoryRanges</a></p>    <h4 id="_document_notes_217">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMappedMemoryRange">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMappedMemoryRange</a></p>         <h3 id="_vkmemoryallocateinfo_3">VkMemoryAllocateInfo(3)</h3>  <h4 id="_name_218">Name</h4>  <p>VkMemoryAllocateInfo - Structure containing parameters of a memory allocation</p>    <h4 id="_c_specification_218">C Specification</h4>  <p>The <code>VkMemoryAllocateInfo</code> structure is defined as:</p>  <pre id="VkMemoryAllocateInfo" data-language="c++">typedef struct VkMemoryAllocateInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo;</pre>   <h4 id="_members_56">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>allocationSize</code> is the size of the allocation in bytes </li> <li> <code>memoryTypeIndex</code> is the memory type index, which selects the properties of the memory to be allocated, as well as the heap the memory will come from. </li> </ul>    <h4 id="_description_218">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkMemoryAllocateInfo-allocationSize-00637">  <code>allocationSize</code> <strong>must</strong> be less than or equal to the amount of memory available to the <code>VkMemoryHeap</code> specified by <code>memoryTypeIndex</code> and the calling command’s <code>VkDevice</code> </li> <li id="VUID-VkMemoryAllocateInfo-allocationSize-00638">  <code>allocationSize</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkMemoryAllocateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</code> </li> <li id="VUID-VkMemoryAllocateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> </ul>   </blockquote>   <h4 id="_see_also_218">See Also</h4>  <p><code>VkDeviceSize</code>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkAllocateMemory">vkAllocateMemory</a></p>    <h4 id="_document_notes_218">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryAllocateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryAllocateInfo</a></p>         <h3 id="_vkmemorybarrier_3">VkMemoryBarrier(3)</h3>  <h4 id="_name_219">Name</h4>  <p>VkMemoryBarrier - Structure specifying a global memory barrier</p>    <h4 id="_c_specification_219">C Specification</h4>  <p>The <code>VkMemoryBarrier</code> structure is defined as:</p>  <pre id="VkMemoryBarrier" data-language="c++">typedef struct VkMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
} VkMemoryBarrier;</pre>   <h4 id="_members_57">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>srcAccessMask</code> is a bitmask of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> specifying a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a>. </li> <li> <code>dstAccessMask</code> is a bitmask of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> specifying a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access mask</a>. </li> </ul>    <h4 id="_description_219">Description</h4>  <p>The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a> specified by <code>srcAccessMask</code>.</p>   <p>The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access mask</a> specified by <code>dstAccessMask</code>.</p>  <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkMemoryBarrier-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_MEMORY_BARRIER</code> </li> <li id="VUID-VkMemoryBarrier-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkMemoryBarrier-srcAccessMask-parameter">  <code>srcAccessMask</code> <strong>must</strong> be a valid combination of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> values </li> <li id="VUID-VkMemoryBarrier-dstAccessMask-parameter">  <code>dstAccessMask</code> <strong>must</strong> be a valid combination of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> values </li> </ul>   </blockquote>   <h4 id="_see_also_219">See Also</h4>  <p><a href="#VkAccessFlags">VkAccessFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a>, <a href="#vkCmdWaitEvents">vkCmdWaitEvents</a></p>    <h4 id="_document_notes_219">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryBarrier">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryBarrier</a></p>         <h3 id="_vkmemoryheap_3">VkMemoryHeap(3)</h3>  <h4 id="_name_220">Name</h4>  <p>VkMemoryHeap - Structure specifying a memory heap</p>    <h4 id="_c_specification_220">C Specification</h4>  <p>The <code>VkMemoryHeap</code> structure is defined as:</p>  <pre id="VkMemoryHeap" data-language="c++">typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap;</pre>   <h4 id="_members_58">Members</h4>  <ul> <li> <code>size</code> is the total memory size in bytes in the heap. </li> <li> <code>flags</code> is a bitmask of <a href="#VkMemoryHeapFlagBits">VkMemoryHeapFlagBits</a> specifying attribute flags for the heap. </li> </ul>       <h4 id="_see_also_220">See Also</h4>  <p><code>VkDeviceSize</code>, <a href="#VkMemoryHeapFlags">VkMemoryHeapFlags</a>, <a href="#VkPhysicalDeviceMemoryProperties">VkPhysicalDeviceMemoryProperties</a></p>    <h4 id="_document_notes_220">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryHeap">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryHeap</a></p>         <h3 id="_vkmemoryrequirements_3">VkMemoryRequirements(3)</h3>  <h4 id="_name_221">Name</h4>  <p>VkMemoryRequirements - Structure specifying memory requirements</p>    <h4 id="_c_specification_221">C Specification</h4>  <p>The <code>VkMemoryRequirements</code> structure is defined as:</p>  <pre id="VkMemoryRequirements" data-language="c++">typedef struct VkMemoryRequirements {
    VkDeviceSize    size;
    VkDeviceSize    alignment;
    uint32_t        memoryTypeBits;
} VkMemoryRequirements;</pre>   <h4 id="_members_59">Members</h4>  <ul> <li> <code>size</code> is the size, in bytes, of the memory allocation <strong>required</strong> for the resource. </li> <li> <code>alignment</code> is the alignment, in bytes, of the offset within the allocation <strong>required</strong> for the resource. </li> <li> <code>memoryTypeBits</code> is a bitmask and contains one bit set for every supported memory type for the resource. Bit <code>i</code> is set if and only if the memory type <code>i</code> in the <code>VkPhysicalDeviceMemoryProperties</code> structure for the physical device is supported for the resource. </li> </ul>       <h4 id="_see_also_221">See Also</h4>  <p><code>VkDeviceSize</code>, <a href="#vkGetBufferMemoryRequirements">vkGetBufferMemoryRequirements</a>, <a href="#vkGetImageMemoryRequirements">vkGetImageMemoryRequirements</a></p>    <h4 id="_document_notes_221">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryRequirements">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryRequirements</a></p>         <h3 id="_vkmemorytype_3">VkMemoryType(3)</h3>  <h4 id="_name_222">Name</h4>  <p>VkMemoryType - Structure specifying memory type</p>    <h4 id="_c_specification_222">C Specification</h4>  <p>The <code>VkMemoryType</code> structure is defined as:</p>  <pre id="VkMemoryType" data-language="c++">typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;</pre>   <h4 id="_members_60">Members</h4>  <ul> <li> <code>heapIndex</code> describes which memory heap this memory type corresponds to, and <strong>must</strong> be less than <code>memoryHeapCount</code> from the <code>VkPhysicalDeviceMemoryProperties</code> structure. </li> <li> <code>propertyFlags</code> is a bitmask of <a href="#VkMemoryPropertyFlagBits">VkMemoryPropertyFlagBits</a> of properties for this memory type. </li> </ul>       <h4 id="_see_also_222">See Also</h4>  <p><a href="#VkMemoryPropertyFlags">VkMemoryPropertyFlags</a>, <a href="#VkPhysicalDeviceMemoryProperties">VkPhysicalDeviceMemoryProperties</a></p>    <h4 id="_document_notes_222">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryType">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryType</a></p>         <h3 id="_vkoffset2d_3">VkOffset2D(3)</h3>  <h4 id="_name_223">Name</h4>  <p>VkOffset2D - Structure specifying a two-dimensional offset</p>    <h4 id="_c_specification_223">C Specification</h4>  <p>A two-dimensional offsets is defined by the structure:</p>  <pre id="VkOffset2D" data-language="c++">typedef struct VkOffset2D {
    int32_t    x;
    int32_t    y;
} VkOffset2D;</pre>   <h4 id="_members_61">Members</h4>  <ul> <li> <code>x</code> is the x offset. </li> <li> <code>y</code> is the y offset. </li> </ul>       <h4 id="_see_also_223">See Also</h4>  <p><a href="#VkRect2D">VkRect2D</a></p>    <h4 id="_document_notes_223">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkOffset2D">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkOffset2D</a></p>         <h3 id="_vkoffset3d_3">VkOffset3D(3)</h3>  <h4 id="_name_224">Name</h4>  <p>VkOffset3D - Structure specifying a three-dimensional offset</p>    <h4 id="_c_specification_224">C Specification</h4>  <p>A three-dimensional offset is defined by the structure:</p>  <pre id="VkOffset3D" data-language="c++">typedef struct VkOffset3D {
    int32_t    x;
    int32_t    y;
    int32_t    z;
} VkOffset3D;</pre>   <h4 id="_members_62">Members</h4>  <ul> <li> <code>x</code> is the x offset. </li> <li> <code>y</code> is the y offset. </li> <li> <code>z</code> is the z offset. </li> </ul>       <h4 id="_see_also_224">See Also</h4>  <p><a href="#VkBufferImageCopy">VkBufferImageCopy</a>, <a href="#VkImageBlit">VkImageBlit</a>, <a href="#VkImageCopy">VkImageCopy</a>, <a href="#VkImageResolve">VkImageResolve</a>, <a href="#VkSparseImageMemoryBind">VkSparseImageMemoryBind</a></p>    <h4 id="_document_notes_224">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkOffset3D">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkOffset3D</a></p>         <h3 id="_vkphysicaldevicefeatures_3">VkPhysicalDeviceFeatures(3)</h3>  <h4 id="_name_225">Name</h4>  <p>VkPhysicalDeviceFeatures - Structure describing the fine-grained features that can be supported by an implementation</p>    <h4 id="_c_specification_225">C Specification</h4>  <p>The <code>VkPhysicalDeviceFeatures</code> structure is defined as:</p>  <pre id="VkPhysicalDeviceFeatures" data-language="c++">typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures;</pre>   <h4 id="_members_63">Members</h4>  <p>The members of the <code>VkPhysicalDeviceFeatures</code> structure describe the following features:</p>    <h4 id="_description_225">Description</h4>  <ul> <li> <p id="features-features-robustBufferAccess"> <code>robustBufferAccess</code> indicates that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by <code>VkDescriptorBufferInfo</code>::<code>range</code>, <code>VkBufferViewCreateInfo</code>::<code>range</code>, or the size of the buffer). Out of bounds accesses <strong>must</strong> not cause application termination, and the effects of shader loads, stores, and atomics <strong>must</strong> conform to an implementation-dependent behavior as described below.</p>  <ul> <li> <p>A buffer access is considered to be out of bounds if any of the following are true:</p>  <ul> <li> The pointer was formed by <code>OpImageTexelPointer</code> and the coordinate is less than zero or greater than or equal to the number of whole elements in the bound range. </li> <li> <p>The pointer was not formed by <code>OpImageTexelPointer</code> and the object pointed to is not wholly contained within the bound range.</p> <blockquote> <h5 class="title">Note</h5>  <p>If a SPIR-V <code>OpLoad</code> instruction loads a structure and the tail end of the structure is out of bounds, then all members of the structure are considered out of bounds even if the members at the end are not statically used.</p>  </blockquote> </li> <li> If any buffer access in a given SPIR-V block is determined to be out of bounds, then any other access of the same type (load, store, or atomic) in the same SPIR-V block that accesses an address less than 16 bytes away from the out of bounds address <strong>may</strong> also be considered out of bounds. </li> </ul>  </li> <li> <p>Out-of-bounds buffer loads will return any of the following values:</p>  <ul> <li> Values from anywhere within the memory range(s) bound to the buffer (possibly including bytes of memory past the end of the buffer, up to the end of the bound range). </li> <li> <p>Zero values, or (0,0,0,x) vectors for vector reads where x is a valid value represented in the type of the vector components and <strong>may</strong> be any of:</p>  <ul> <li> 0, 1, or the maximum representable positive integer value, for signed or unsigned integer components </li> <li> 0.0 or 1.0, for floating-point components </li> </ul>  </li> </ul>  </li> <li> Out-of-bounds writes <strong>may</strong> modify values within the memory range(s) bound to the buffer, but <strong>must</strong> not modify any other memory. </li> <li> Out-of-bounds atomics <strong>may</strong> modify values within the memory range(s) bound to the buffer, but <strong>must</strong> not modify any other memory, and return an undefined value. </li> <li> <p>Vertex input attributes are considered out of bounds if the address of the attribute plus the size of the attribute is greater than the size of the bound buffer. Further, if any vertex input attribute using a specific vertex input binding is out of bounds, then all vertex input attributes using that vertex input binding for that vertex shader invocation are considered out of bounds.</p>  <ul> <li> <p>If a vertex input attribute is out of bounds, it will be assigned one of the following values:</p>  <ul> <li> Values from anywhere within the memory range(s) bound to the buffer, converted according to the format of the attribute. </li> <li> Zero values, format converted according to the format of the attribute. </li> <li> Zero values, or (0,0,0,x) vectors, as described above. </li> </ul>  </li> </ul>  </li> <li> If <code>robustBufferAccess</code> is not enabled, out of bounds accesses <strong>may</strong> corrupt any memory within the process and cause undefined behavior up to and including application termination. </li> </ul>  </li> <li id="features-features-fullDrawIndexUint32">  <code>fullDrawIndexUint32</code> indicates the full 32-bit range of indices is supported for indexed draw calls when using a <a href="#VkIndexType">VkIndexType</a> of <code>VK_INDEX_TYPE_UINT32</code>. <code>maxDrawIndexedIndexValue</code> is the maximum index value that <strong>may</strong> be used (aside from the primitive restart index, which is always 2<sup>32</sup>-1 when the <a href="#VkIndexType">VkIndexType</a> is <code>VK_INDEX_TYPE_UINT32</code>). If this feature is supported, <code>maxDrawIndexedIndexValue</code> <strong>must</strong> be 2<sup>32</sup>-1; otherwise it <strong>must</strong> be no smaller than 2<sup>24</sup>-1. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxDrawIndexedIndexValue">maxDrawIndexedIndexValue</a>. </li> <li id="features-features-imageCubeArray">  <code>imageCubeArray</code> indicates whether image views with a <a href="#VkImageViewType">VkImageViewType</a> of <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code> <strong>can</strong> be created, and that the corresponding <code>SampledCubeArray</code> and <code>ImageCubeArray</code> SPIR-V capabilities <strong>can</strong> be used in shader code. </li> <li id="features-features-independentBlend">  <code>independentBlend</code> indicates whether the <code>VkPipelineColorBlendAttachmentState</code> settings are controlled independently per-attachment. If this feature is not enabled, the <code>VkPipelineColorBlendAttachmentState</code> settings for all color attachments <strong>must</strong> be identical. Otherwise, a different <code>VkPipelineColorBlendAttachmentState</code> <strong>can</strong> be provided for each bound color attachment. </li> <li id="features-features-geometryShader">  <code>geometryShader</code> indicates whether geometry shaders are supported. If this feature is not enabled, the <code>VK_SHADER_STAGE_GEOMETRY_BIT</code> and <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> enum values <strong>must</strong> not be used. This also indicates whether shader modules <strong>can</strong> declare the <code>Geometry</code> capability. </li> <li id="features-features-tessellationShader">  <code>tessellationShader</code> indicates whether tessellation control and evaluation shaders are supported. If this feature is not enabled, the <code>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT</code>, <code>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</code>, <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code>, and <code>VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO</code> enum values <strong>must</strong> not be used. This also indicates whether shader modules <strong>can</strong> declare the <code>Tessellation</code> capability. </li> <li id="features-features-sampleRateShading">  <code>sampleRateShading</code> indicates whether per-sample shading and multisample interpolation are supported. If this feature is not enabled, the <code>sampleShadingEnable</code> member of the <code>VkPipelineMultisampleStateCreateInfo</code> structure <strong>must</strong> be set to <code>VK_FALSE</code> and the <code>minSampleShading</code> member is ignored. This also indicates whether shader modules <strong>can</strong> declare the <code>SampleRateShading</code> capability. </li> <li id="features-features-dualSrcBlend">  <code>dualSrcBlend</code> indicates whether blend operations which take two sources are supported. If this feature is not enabled, the <code>VK_BLEND_FACTOR_SRC1_COLOR</code>, <code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</code>, <code>VK_BLEND_FACTOR_SRC1_ALPHA</code>, and <code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</code> enum values <strong>must</strong> not be used as source or destination blending factors. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-dsb">html/vkspec.html#framebuffer-dsb</a>. </li> <li id="features-features-logicOp">  <code>logicOp</code> indicates whether logic operations are supported. If this feature is not enabled, the <code>logicOpEnable</code> member of the <code>VkPipelineColorBlendStateCreateInfo</code> structure <strong>must</strong> be set to <code>VK_FALSE</code>, and the <code>logicOp</code> member is ignored. </li> <li id="features-features-multiDrawIndirect">  <code>multiDrawIndirect</code> indicates whether multiple draw indirect is supported. If this feature is not enabled, the <code>drawCount</code> parameter to the <code>vkCmdDrawIndirect</code> and <code>vkCmdDrawIndexedIndirect</code> commands <strong>must</strong> be 0 or 1. The <code>maxDrawIndirectCount</code> member of the <code>VkPhysicalDeviceLimits</code> structure <strong>must</strong> also be 1 if this feature is not supported. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxDrawIndirectCount">maxDrawIndirectCount</a>. </li> <li id="features-features-drawIndirectFirstInstance">  <code>drawIndirectFirstInstance</code> indicates whether indirect draw calls support the <code>firstInstance</code> parameter. If this feature is not enabled, the <code>firstInstance</code> member of all <code>VkDrawIndirectCommand</code> and <code>VkDrawIndexedIndirectCommand</code> structures that are provided to the <code>vkCmdDrawIndirect</code> and <code>vkCmdDrawIndexedIndirect</code> commands <strong>must</strong> be 0. </li> <li id="features-features-depthClamp">  <code>depthClamp</code> indicates whether depth clamping is supported. If this feature is not enabled, the <code>depthClampEnable</code> member of the <code>VkPipelineRasterizationStateCreateInfo</code> structure <strong>must</strong> be set to <code>VK_FALSE</code>. Otherwise, setting <code>depthClampEnable</code> to <code>VK_TRUE</code> will enable depth clamping. </li> <li id="features-features-depthBiasClamp">  <code>depthBiasClamp</code> indicates whether depth bias clamping is supported. If this feature is not enabled, the <code>depthBiasClamp</code> member of the <code>VkPipelineRasterizationStateCreateInfo</code> structure <strong>must</strong> be set to 0.0 unless the <code>VK_DYNAMIC_STATE_DEPTH_BIAS</code> dynamic state is enabled, and the <code>depthBiasClamp</code> parameter to <code>vkCmdSetDepthBias</code> <strong>must</strong> be set to 0.0. </li> <li id="features-features-fillModeNonSolid">  <code>fillModeNonSolid</code> indicates whether point and wireframe fill modes are supported. If this feature is not enabled, the <code>VK_POLYGON_MODE_POINT</code> and <code>VK_POLYGON_MODE_LINE</code> enum values <strong>must</strong> not be used. </li> <li id="features-features-depthBounds">  <code>depthBounds</code> indicates whether depth bounds tests are supported. If this feature is not enabled, the <code>depthBoundsTestEnable</code> member of the <code>VkPipelineDepthStencilStateCreateInfo</code> structure <strong>must</strong> be set to <code>VK_FALSE</code>. When <code>depthBoundsTestEnable</code> is set to <code>VK_FALSE</code>, the <code>minDepthBounds</code> and <code>maxDepthBounds</code> members of the <code>VkPipelineDepthStencilStateCreateInfo</code> structure are ignored. </li> <li id="features-features-wideLines">  <code>wideLines</code> indicates whether lines with width other than 1.0 are supported. If this feature is not enabled, the <code>lineWidth</code> member of the <code>VkPipelineRasterizationStateCreateInfo</code> structure <strong>must</strong> be set to 1.0 unless the <code>VK_DYNAMIC_STATE_LINE_WIDTH</code> dynamic state is enabled, and the <code>lineWidth</code> parameter to <code>vkCmdSetLineWidth</code> <strong>must</strong> be set to 1.0. When this feature is supported, the range and granularity of supported line widths are indicated by the <code>lineWidthRange</code> and <code>lineWidthGranularity</code> members of the <code>VkPhysicalDeviceLimits</code> structure, respectively. </li> <li id="features-features-largePoints">  <code>largePoints</code> indicates whether points with size greater than 1.0 are supported. If this feature is not enabled, only a point size of 1.0 written by a shader is supported. The range and granularity of supported point sizes are indicated by the <code>pointSizeRange</code> and <code>pointSizeGranularity</code> members of the <code>VkPhysicalDeviceLimits</code> structure, respectively. </li> <li id="features-features-alphaToOne">  <code>alphaToOne</code> indicates whether the implementation is able to replace the alpha value of the color fragment output from the fragment shader with the maximum representable alpha value for fixed-point colors or 1.0 for floating-point colors. If this feature is not enabled, then the <code>alphaToOneEnable</code> member of the <code>VkPipelineMultisampleStateCreateInfo</code> structure <strong>must</strong> be set to <code>VK_FALSE</code>. Otherwise setting <code>alphaToOneEnable</code> to <code>VK_TRUE</code> will enable alpha-to-one behavior. </li> <li id="features-features-multiViewport">  <code>multiViewport</code> indicates whether more than one viewport is supported. If this feature is not enabled, the <code>viewportCount</code> and <code>scissorCount</code> members of the <code>VkPipelineViewportStateCreateInfo</code> structure <strong>must</strong> be set to 1. Similarly, the <code>viewportCount</code> parameter to the <code>vkCmdSetViewport</code> command and the <code>scissorCount</code> parameter to the <code>vkCmdSetScissor</code> command <strong>must</strong> be 1, and the <code>firstViewport</code> parameter to the <code>vkCmdSetViewport</code> command and the <code>firstScissor</code> parameter to the <code>vkCmdSetScissor</code> command <strong>must</strong> be 0. </li> <li id="features-features-samplerAnisotropy">  <code>samplerAnisotropy</code> indicates whether anisotropic filtering is supported. If this feature is not enabled, the <code>maxAnisotropy</code> member of the <code>VkSamplerCreateInfo</code> structure <strong>must</strong> be 1.0. </li> <li> <p id="features-features-textureCompressionETC2"> <code>textureCompressionETC2</code> indicates whether all of the ETC2 and EAC compressed texture formats are supported. If this feature is enabled, then the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code>, <code>VK_FORMAT_FEATURE_BLIT_SRC_BIT</code> and <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> features <strong>must</strong> be supported in <code>optimalTilingFeatures</code> for the following formats:</p>  <ul> <li> <code>VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_EAC_R11_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_EAC_R11_SNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_EAC_R11G11_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_EAC_R11G11_SNORM_BLOCK</code> </li> </ul>   <p><a href="#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> and <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a> <strong>can</strong> be used to check for additional supported properties of individual formats.</p>  </li> <li> <p id="features-features-textureCompressionASTC_LDR"> <code>textureCompressionASTC_LDR</code> indicates whether all of the ASTC LDR compressed texture formats are supported. If this feature is enabled, then the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code>, <code>VK_FORMAT_FEATURE_BLIT_SRC_BIT</code> and <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> features <strong>must</strong> be supported in <code>optimalTilingFeatures</code> for the following formats:</p>  <ul> <li> <code>VK_FORMAT_ASTC_4x4_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_4x4_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_5x4_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_5x4_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_5x5_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_5x5_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_6x5_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_6x5_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_6x6_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_6x6_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_8x5_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_8x5_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_8x6_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_8x6_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_8x8_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_8x8_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_10x5_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_10x5_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_10x6_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_10x6_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_10x8_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_10x8_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_10x10_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_10x10_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_12x10_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_12x10_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_12x12_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_ASTC_12x12_SRGB_BLOCK</code> </li> </ul>   <p><a href="#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> and <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a> <strong>can</strong> be used to check for additional supported properties of individual formats.</p>  </li> <li> <p id="features-features-textureCompressionBC"> <code>textureCompressionBC</code> indicates whether all of the BC compressed texture formats are supported. If this feature is enabled, then the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code>, <code>VK_FORMAT_FEATURE_BLIT_SRC_BIT</code> and <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> features <strong>must</strong> be supported in <code>optimalTilingFeatures</code> for the following formats:</p>  <ul> <li> <code>VK_FORMAT_BC1_RGB_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_BC1_RGB_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_BC1_RGBA_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_BC1_RGBA_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_BC2_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_BC2_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_BC3_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_BC3_SRGB_BLOCK</code> </li> <li> <code>VK_FORMAT_BC4_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_BC4_SNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_BC5_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_BC5_SNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_BC6H_UFLOAT_BLOCK</code> </li> <li> <code>VK_FORMAT_BC6H_SFLOAT_BLOCK</code> </li> <li> <code>VK_FORMAT_BC7_UNORM_BLOCK</code> </li> <li> <code>VK_FORMAT_BC7_SRGB_BLOCK</code> </li> </ul>   <p><a href="#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a> and <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a> <strong>can</strong> be used to check for additional supported properties of individual formats.</p>  </li> <li id="features-features-occlusionQueryPrecise">  <code>occlusionQueryPrecise</code> indicates whether occlusion queries returning actual sample counts are supported. Occlusion queries are created in a <code>VkQueryPool</code> by specifying the <code>queryType</code> of <code>VK_QUERY_TYPE_OCCLUSION</code> in the <code>VkQueryPoolCreateInfo</code> structure which is passed to <code>vkCreateQueryPool</code>. If this feature is enabled, queries of this type <strong>can</strong> enable <code>VK_QUERY_CONTROL_PRECISE_BIT</code> in the <code>flags</code> parameter to <code>vkCmdBeginQuery</code>. If this feature is not supported, the implementation supports only boolean occlusion queries. When any samples are passed, boolean queries will return a non-zero result value, otherwise a result value of zero is returned. When this feature is enabled and <code>VK_QUERY_CONTROL_PRECISE_BIT</code> is set, occlusion queries will report the actual number of samples passed. </li> <li id="features-features-pipelineStatisticsQuery">  <code>pipelineStatisticsQuery</code> indicates whether the pipeline statistics queries are supported. If this feature is not enabled, queries of type <code>VK_QUERY_TYPE_PIPELINE_STATISTICS</code> <strong>cannot</strong> be created, and none of the <a href="#VkQueryPipelineStatisticFlagBits">VkQueryPipelineStatisticFlagBits</a> bits <strong>can</strong> be set in the <code>pipelineStatistics</code> member of the <code>VkQueryPoolCreateInfo</code> structure. </li> <li id="features-features-vertexPipelineStoresAndAtomics">  <code>vertexPipelineStoresAndAtomics</code> indicates whether storage buffers and images support stores and atomic operations in the vertex, tessellation, and geometry shader stages. If this feature is not enabled, all storage image, storage texel buffers, and storage buffer variables used by these stages in shader modules <strong>must</strong> be decorated with the <code>NonWriteable</code> decoration (or the <code>readonly</code> memory qualifier in GLSL). </li> <li id="features-features-fragmentStoresAndAtomics">  <code>fragmentStoresAndAtomics</code> indicates whether storage buffers and images support stores and atomic operations in the fragment shader stage. If this feature is not enabled, all storage image, storage texel buffers, and storage buffer variables used by the fragment stage in shader modules <strong>must</strong> be decorated with the <code>NonWriteable</code> decoration (or the <code>readonly</code> memory qualifier in GLSL). </li> <li id="features-features-shaderTessellationAndGeometryPointSize">  <code>shaderTessellationAndGeometryPointSize</code> indicates whether the <code>PointSize</code> built-in decoration is available in the tessellation control, tessellation evaluation, and geometry shader stages. If this feature is not enabled, members decorated with the <code>PointSize</code> built-in decoration <strong>must</strong> not be read from or written to and all points written from a tessellation or geometry shader will have a size of 1.0. This also indicates whether shader modules <strong>can</strong> declare the <code>TessellationPointSize</code> capability for tessellation control and evaluation shaders, or if the shader modules <strong>can</strong> declare the <code>GeometryPointSize</code> capability for geometry shaders. An implementation supporting this feature <strong>must</strong> also support one or both of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader"><code>tessellationShader</code></a> or <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader"><code>geometryShader</code></a> features. </li> <li id="features-features-shaderImageGatherExtended">  <code>shaderImageGatherExtended</code> indicates whether the extended set of image gather instructions are available in shader code. If this feature is not enabled, the <code>OpImage</code>*<code>Gather</code> instructions do not support the <code>Offset</code> and <code>ConstOffsets</code> operands. This also indicates whether shader modules <strong>can</strong> declare the <code>ImageGatherExtended</code> capability. </li> <li id="features-features-shaderStorageImageExtendedFormats">  <code>shaderStorageImageExtendedFormats</code> indicates whether the extended storage image formats are available in shader code. If this feature is not enabled, the formats requiring the <code>StorageImageExtendedFormats</code> capability are not supported for storage images. This also indicates whether shader modules <strong>can</strong> declare the <code>StorageImageExtendedFormats</code> capability. </li> <li id="features-features-shaderStorageImageMultisample">  <code>shaderStorageImageMultisample</code> indicates whether multisampled storage images are supported. If this feature is not enabled, images that are created with a <code>usage</code> that includes <code>VK_IMAGE_USAGE_STORAGE_BIT</code> <strong>must</strong> be created with <code>samples</code> equal to <code>VK_SAMPLE_COUNT_1_BIT</code>. This also indicates whether shader modules <strong>can</strong> declare the <code>StorageImageMultisample</code> capability. </li> <li id="features-features-shaderStorageImageReadWithoutFormat">  <code>shaderStorageImageReadWithoutFormat</code> indicates whether storage images require a format qualifier to be specified when reading from storage images. If this feature is not enabled, the <code>OpImageRead</code> instruction <strong>must</strong> not have an <code>OpTypeImage</code> of <code>Unknown</code>. This also indicates whether shader modules <strong>can</strong> declare the <code>StorageImageReadWithoutFormat</code> capability. </li> <li id="features-features-shaderStorageImageWriteWithoutFormat">  <code>shaderStorageImageWriteWithoutFormat</code> indicates whether storage images require a format qualifier to be specified when writing to storage images. If this feature is not enabled, the <code>OpImageWrite</code> instruction <strong>must</strong> not have an <code>OpTypeImage</code> of <code>Unknown</code>. This also indicates whether shader modules <strong>can</strong> declare the <code>StorageImageWriteWithoutFormat</code> capability. </li> <li id="features-features-shaderUniformBufferArrayDynamicIndexing">  <code>shaderUniformBufferArrayDynamicIndexing</code> indicates whether arrays of uniform buffers <strong>can</strong> be indexed by <em>dynamically uniform</em> integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> <strong>must</strong> be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules <strong>can</strong> declare the <code>UniformBufferArrayDynamicIndexing</code> capability. </li> <li id="features-features-shaderSampledImageArrayDynamicIndexing">  <code>shaderSampledImageArrayDynamicIndexing</code> indicates whether arrays of samplers or sampled images <strong>can</strong> be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, or <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> <strong>must</strong> be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules <strong>can</strong> declare the <code>SampledImageArrayDynamicIndexing</code> capability. </li> <li id="features-features-shaderStorageBufferArrayDynamicIndexing">  <code>shaderStorageBufferArrayDynamicIndexing</code> indicates whether arrays of storage buffers <strong>can</strong> be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> <strong>must</strong> be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules <strong>can</strong> declare the <code>StorageBufferArrayDynamicIndexing</code> capability. </li> <li id="features-features-shaderStorageImageArrayDynamicIndexing">  <code>shaderStorageImageArrayDynamicIndexing</code> indicates whether arrays of storage images <strong>can</strong> be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code> <strong>must</strong> be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules <strong>can</strong> declare the <code>StorageImageArrayDynamicIndexing</code> capability. </li> <li id="features-features-shaderClipDistance">  <code>shaderClipDistance</code> indicates whether clip distances are supported in shader code. If this feature is not enabled, any members decorated with the <code>ClipDistance</code> built-in decoration <strong>must</strong> not be read from or written to in shader modules. This also indicates whether shader modules <strong>can</strong> declare the <code>ClipDistance</code> capability. </li> <li id="features-features-shaderCullDistance">  <code>shaderCullDistance</code> indicates whether cull distances are supported in shader code. If this feature is not enabled, any members decorated with the <code>CullDistance</code> built-in decoration <strong>must</strong> not be read from or written to in shader modules. This also indicates whether shader modules <strong>can</strong> declare the <code>CullDistance</code> capability. </li> <li id="features-features-shaderFloat64">  <code>shaderFloat64</code> indicates whether 64-bit floats (doubles) are supported in shader code. If this feature is not enabled, 64-bit floating-point types <strong>must</strong> not be used in shader code. This also indicates whether shader modules <strong>can</strong> declare the <code>Float64</code> capability. </li> <li id="features-features-shaderInt64">  <code>shaderInt64</code> indicates whether 64-bit integers (signed and unsigned) are supported in shader code. If this feature is not enabled, 64-bit integer types <strong>must</strong> not be used in shader code. This also indicates whether shader modules <strong>can</strong> declare the <code>Int64</code> capability. </li> <li id="features-features-shaderInt16">  <code>shaderInt16</code> indicates whether 16-bit integers (signed and unsigned) are supported in shader code. If this feature is not enabled, 16-bit integer types <strong>must</strong> not be used in shader code. This also indicates whether shader modules <strong>can</strong> declare the <code>Int16</code> capability. </li> <li id="features-features-shaderResourceResidency">  <code>shaderResourceResidency</code> indicates whether image operations that return resource residency information are supported in shader code. If this feature is not enabled, the <code>OpImageSparse</code>* instructions <strong>must</strong> not be used in shader code. This also indicates whether shader modules <strong>can</strong> declare the <code>SparseResidency</code> capability. The feature requires at least one of the <code>sparseResidency</code>* features to be supported. </li> <li id="features-features-shaderResourceMinLod">  <code>shaderResourceMinLod</code> indicates whether image operations that specify the minimum resource level-of-detail (LOD) are supported in shader code. If this feature is not enabled, the <code>MinLod</code> image operand <strong>must</strong> not be used in shader code. This also indicates whether shader modules <strong>can</strong> declare the <code>MinLod</code> capability. </li> <li id="features-features-sparseBinding">  <code>sparseBinding</code> indicates whether resource memory <strong>can</strong> be managed at opaque sparse block level instead of at the object level. If this feature is not enabled, resource memory <strong>must</strong> be bound only on a per-object basis using the <code>vkBindBufferMemory</code> and <code>vkBindImageMemory</code> commands. In this case, buffers and images <strong>must</strong> not be created with <code>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</code> and <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code> set in the <code>flags</code> member of the <code>VkBufferCreateInfo</code> and <code>VkImageCreateInfo</code> structures, respectively. Otherwise resource memory <strong>can</strong> be managed as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseresourcefeatures">Sparse Resource Features</a>. </li> <li id="features-features-sparseResidencyBuffer">  <code>sparseResidencyBuffer</code> indicates whether the device <strong>can</strong> access partially resident buffers. If this feature is not enabled, buffers <strong>must</strong> not be created with <code>VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</code> set in the <code>flags</code> member of the <code>VkBufferCreateInfo</code> structure. </li> <li id="features-features-sparseResidencyImage2D">  <code>sparseResidencyImage2D</code> indicates whether the device <strong>can</strong> access partially resident 2D images with 1 sample per pixel. If this feature is not enabled, images with an <code>imageType</code> of <code>VK_IMAGE_TYPE_2D</code> and <code>samples</code> set to <code>VK_SAMPLE_COUNT_1_BIT</code> <strong>must</strong> not be created with <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> set in the <code>flags</code> member of the <code>VkImageCreateInfo</code> structure. </li> <li id="features-features-sparseResidencyImage3D">  <code>sparseResidencyImage3D</code> indicates whether the device <strong>can</strong> access partially resident 3D images. If this feature is not enabled, images with an <code>imageType</code> of <code>VK_IMAGE_TYPE_3D</code> <strong>must</strong> not be created with <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> set in the <code>flags</code> member of the <code>VkImageCreateInfo</code> structure. </li> <li id="features-features-sparseResidency2Samples">  <code>sparseResidency2Samples</code> indicates whether the physical device <strong>can</strong> access partially resident 2D images with 2 samples per pixel. If this feature is not enabled, images with an <code>imageType</code> of <code>VK_IMAGE_TYPE_2D</code> and <code>samples</code> set to <code>VK_SAMPLE_COUNT_2_BIT</code> <strong>must</strong> not be created with <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> set in the <code>flags</code> member of the <code>VkImageCreateInfo</code> structure. </li> <li id="features-features-sparseResidency4Samples">  <code>sparseResidency4Samples</code> indicates whether the physical device <strong>can</strong> access partially resident 2D images with 4 samples per pixel. If this feature is not enabled, images with an <code>imageType</code> of <code>VK_IMAGE_TYPE_2D</code> and <code>samples</code> set to <code>VK_SAMPLE_COUNT_4_BIT</code> <strong>must</strong> not be created with <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> set in the <code>flags</code> member of the <code>VkImageCreateInfo</code> structure. </li> <li id="features-features-sparseResidency8Samples">  <code>sparseResidency8Samples</code> indicates whether the physical device <strong>can</strong> access partially resident 2D images with 8 samples per pixel. If this feature is not enabled, images with an <code>imageType</code> of <code>VK_IMAGE_TYPE_2D</code> and <code>samples</code> set to <code>VK_SAMPLE_COUNT_8_BIT</code> <strong>must</strong> not be created with <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> set in the <code>flags</code> member of the <code>VkImageCreateInfo</code> structure. </li> <li id="features-features-sparseResidency16Samples">  <code>sparseResidency16Samples</code> indicates whether the physical device <strong>can</strong> access partially resident 2D images with 16 samples per pixel. If this feature is not enabled, images with an <code>imageType</code> of <code>VK_IMAGE_TYPE_2D</code> and <code>samples</code> set to <code>VK_SAMPLE_COUNT_16_BIT</code> <strong>must</strong> not be created with <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> set in the <code>flags</code> member of the <code>VkImageCreateInfo</code> structure. </li> <li id="features-features-sparseResidencyAliased">  <code>sparseResidencyAliased</code> indicates whether the physical device <strong>can</strong> correctly access data aliased into multiple locations. If this feature is not enabled, the <code>VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</code> and <code>VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</code> enum values <strong>must</strong> not be used in <code>flags</code> members of the <code>VkBufferCreateInfo</code> and <code>VkImageCreateInfo</code> structures, respectively. </li> <li id="features-features-variableMultisampleRate">  <code>variableMultisampleRate</code> indicates whether all pipelines that will be bound to a command buffer during a subpass with no attachments <strong>must</strong> have the same value for <code>VkPipelineMultisampleStateCreateInfo</code>::<code>rasterizationSamples</code>. If set to <code>VK_TRUE</code>, the implementation supports variable multisample rates in a subpass with no attachments. If set to <code>VK_FALSE</code>, then all pipelines bound in such a subpass <strong>must</strong> have the same multisample rate. This has no effect in situations where a subpass uses any attachments. </li> <li id="features-features-inheritedQueries">  <code>inheritedQueries</code> indicates whether a secondary command buffer <strong>may</strong> be executed while a query is active. </li> </ul>    <h4 id="_see_also_225">See Also</h4>  <p><code>VkBool32</code>, <a href="#VkDeviceCreateInfo">VkDeviceCreateInfo</a>, <a href="#vkGetPhysicalDeviceFeatures">vkGetPhysicalDeviceFeatures</a></p>    <h4 id="_document_notes_225">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceFeatures">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceFeatures</a></p>         <h3 id="_vkphysicaldevicelimits_3">VkPhysicalDeviceLimits(3)</h3>  <h4 id="_name_226">Name</h4>  <p>VkPhysicalDeviceLimits - Structure reporting implementation-dependent physical device limits</p>    <h4 id="_c_specification_226">C Specification</h4>  <p>The <code>VkPhysicalDeviceLimits</code> structure is defined as:</p>  <pre id="VkPhysicalDeviceLimits" data-language="c++">typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits;</pre>   <h4 id="_members_64">Members</h4>  <ul> <li id="features-limits-maxImageDimension1D">  <code>maxImageDimension1D</code> is the maximum dimension (<code>width</code>) supported for all images created with an <code>imageType</code> of <code>VK_IMAGE_TYPE_1D</code>. </li> <li id="features-limits-maxImageDimension2D">  <code>maxImageDimension2D</code> is the maximum dimension (<code>width</code> or <code>height</code>) supported for all images created with an <code>imageType</code> of <code>VK_IMAGE_TYPE_2D</code> and without <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code> set in <code>flags</code>. </li> <li id="features-limits-maxImageDimension3D">  <code>maxImageDimension3D</code> is the maximum dimension (<code>width</code>, <code>height</code>, or <code>depth</code>) supported for all images created with an <code>imageType</code> of <code>VK_IMAGE_TYPE_3D</code>. </li> <li id="features-limits-maxImageDimensionCube">  <code>maxImageDimensionCube</code> is the maximum dimension (<code>width</code> or <code>height</code>) supported for all images created with an <code>imageType</code> of <code>VK_IMAGE_TYPE_2D</code> and with <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code> set in <code>flags</code>. </li> <li id="features-limits-maxImageArrayLayers">  <code>maxImageArrayLayers</code> is the maximum number of layers (<code>arrayLayers</code>) for an image. </li> <li id="features-limits-maxTexelBufferElements">  <code>maxTexelBufferElements</code> is the maximum number of addressable texels for a buffer view created on a buffer which was created with the <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> or <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code> set in the <code>usage</code> member of the <code>VkBufferCreateInfo</code> structure. </li> <li id="features-limits-maxUniformBufferRange">  <code>maxUniformBufferRange</code> is the maximum value that <strong>can</strong> be specified in the <code>range</code> member of any <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> structures passed to a call to <a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a> for descriptors of type <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>. </li> <li id="features-limits-maxStorageBufferRange">  <code>maxStorageBufferRange</code> is the maximum value that <strong>can</strong> be specified in the <code>range</code> member of any <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> structures passed to a call to <a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a> for descriptors of type <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>. </li> <li id="features-limits-maxPushConstantsSize">  <code>maxPushConstantsSize</code> is the maximum size, in bytes, of the pool of push constant memory. For each of the push constant ranges indicated by the <code>pPushConstantRanges</code> member of the <code>VkPipelineLayoutCreateInfo</code> structure, (<code>offset</code> + <code>size</code>) <strong>must</strong> be less than or equal to this limit. </li> <li id="features-limits-maxMemoryAllocationCount">  <code>maxMemoryAllocationCount</code> is the maximum number of device memory allocations, as created by <a href="#vkAllocateMemory">vkAllocateMemory</a>, which <strong>can</strong> simultaneously exist. </li> <li id="features-limits-maxSamplerAllocationCount">  <code>maxSamplerAllocationCount</code> is the maximum number of sampler objects, as created by <a href="#vkCreateSampler">vkCreateSampler</a>, which <strong>can</strong> simultaneously exist on a device. </li> <li id="features-limits-bufferImageGranularity">  <code>bufferImageGranularity</code> is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources <strong>can</strong> be bound to adjacent offsets in the same <code>VkDeviceMemory</code> object without aliasing. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-bufferimagegranularity">Buffer-Image Granularity</a> for more details. </li> <li id="features-limits-sparseAddressSpaceSize">  <code>sparseAddressSpaceSize</code> is the total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them. </li> <li id="features-limits-maxBoundDescriptorSets">  <code>maxBoundDescriptorSets</code> is the maximum number of descriptor sets that <strong>can</strong> be simultaneously used by a pipeline. All <code>DescriptorSet</code> decorations in shader modules <strong>must</strong> have a value less than <code>maxBoundDescriptorSets</code>. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-sets">html/vkspec.html#descriptorsets-sets</a>. </li> <li id="features-limits-maxPerStageDescriptorSamplers">  <code>maxPerStageDescriptorSamplers</code> is the maximum number of samplers that <strong>can</strong> be accessible to a single shader stage in a pipeline layout. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> count against this limit. A descriptor is accessible to a shader stage when the <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code> structure has the bit for that shader stage set. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-sampler">html/vkspec.html#descriptorsets-sampler</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-combinedimagesampler">html/vkspec.html#descriptorsets-combinedimagesampler</a>. </li> <li id="features-limits-maxPerStageDescriptorUniformBuffers">  <code>maxPerStageDescriptorUniformBuffers</code> is the maximum number of uniform buffers that <strong>can</strong> be accessible to a single shader stage in a pipeline layout. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> count against this limit. A descriptor is accessible to a shader stage when the <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code> structure has the bit for that shader stage set. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-uniformbuffer">html/vkspec.html#descriptorsets-uniformbuffer</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-uniformbufferdynamic">html/vkspec.html#descriptorsets-uniformbufferdynamic</a>. </li> <li id="features-limits-maxPerStageDescriptorStorageBuffers">  <code>maxPerStageDescriptorStorageBuffers</code> is the maximum number of storage buffers that <strong>can</strong> be accessible to a single shader stage in a pipeline layout. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> count against this limit. A descriptor is accessible to a pipeline shader stage when the <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code> structure has the bit for that shader stage set. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagebuffer">html/vkspec.html#descriptorsets-storagebuffer</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagebufferdynamic">html/vkspec.html#descriptorsets-storagebufferdynamic</a>. </li> <li id="features-limits-maxPerStageDescriptorSampledImages">  <code>maxPerStageDescriptorSampledImages</code> is the maximum number of sampled images that <strong>can</strong> be accessible to a single shader stage in a pipeline layout. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, or <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> count against this limit. A descriptor is accessible to a pipeline shader stage when the <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code> structure has the bit for that shader stage set. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-combinedimagesampler">html/vkspec.html#descriptorsets-combinedimagesampler</a>, <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-sampledimage">html/vkspec.html#descriptorsets-sampledimage</a>, and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-uniformtexelbuffer">html/vkspec.html#descriptorsets-uniformtexelbuffer</a>. </li> <li id="features-limits-maxPerStageDescriptorStorageImages">  <code>maxPerStageDescriptorStorageImages</code> is the maximum number of storage images that <strong>can</strong> be accessible to a single shader stage in a pipeline layout. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> count against this limit. A descriptor is accessible to a pipeline shader stage when the <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code> structure has the bit for that shader stage set. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storageimage">html/vkspec.html#descriptorsets-storageimage</a>, and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagetexelbuffer">html/vkspec.html#descriptorsets-storagetexelbuffer</a>. </li> <li id="features-limits-maxPerStageDescriptorInputAttachments">  <code>maxPerStageDescriptorInputAttachments</code> is the maximum number of input attachments that <strong>can</strong> be accessible to a single shader stage in a pipeline layout. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> count against this limit. A descriptor is accessible to a pipeline shader stage when the <code>stageFlags</code> member of the <code>VkDescriptorSetLayoutBinding</code> structure has the bit for that shader stage set. These are only supported for the fragment stage. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-inputattachment">html/vkspec.html#descriptorsets-inputattachment</a>. </li> <li id="features-limits-maxPerStageResources">  <code>maxPerStageResources</code> is the maximum number of resources that <strong>can</strong> be accessible to a single shader stage in a pipeline layout. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>, <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>, <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, or <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> count against this limit. For the fragment shader stage the framebuffer color attachments also count against this limit. </li> <li id="features-limits-maxDescriptorSetSamplers">  <code>maxDescriptorSetSamplers</code> is the maximum number of samplers that <strong>can</strong> be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> count against this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-sampler">html/vkspec.html#descriptorsets-sampler</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-combinedimagesampler">html/vkspec.html#descriptorsets-combinedimagesampler</a>. </li> <li id="features-limits-maxDescriptorSetUniformBuffers">  <code>maxDescriptorSetUniformBuffers</code> is the maximum number of uniform buffers that <strong>can</strong> be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> count against this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-uniformbuffer">html/vkspec.html#descriptorsets-uniformbuffer</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-uniformbufferdynamic">html/vkspec.html#descriptorsets-uniformbufferdynamic</a>. </li> <li id="features-limits-maxDescriptorSetUniformBuffersDynamic">  <code>maxDescriptorSetUniformBuffersDynamic</code> is the maximum number of dynamic uniform buffers that <strong>can</strong> be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> count against this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-uniformbufferdynamic">html/vkspec.html#descriptorsets-uniformbufferdynamic</a>. </li> <li id="features-limits-maxDescriptorSetStorageBuffers">  <code>maxDescriptorSetStorageBuffers</code> is the maximum number of storage buffers that <strong>can</strong> be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> count against this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagebuffer">html/vkspec.html#descriptorsets-storagebuffer</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagebufferdynamic">html/vkspec.html#descriptorsets-storagebufferdynamic</a>. </li> <li id="features-limits-maxDescriptorSetStorageBuffersDynamic">  <code>maxDescriptorSetStorageBuffersDynamic</code> is the maximum number of dynamic storage buffers that <strong>can</strong> be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> count against this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagebufferdynamic">html/vkspec.html#descriptorsets-storagebufferdynamic</a>. </li> <li id="features-limits-maxDescriptorSetSampledImages">  <code>maxDescriptorSetSampledImages</code> is the maximum number of sampled images that <strong>can</strong> be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, or <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> count against this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-combinedimagesampler">html/vkspec.html#descriptorsets-combinedimagesampler</a>, <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-sampledimage">html/vkspec.html#descriptorsets-sampledimage</a>, and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-uniformtexelbuffer">html/vkspec.html#descriptorsets-uniformtexelbuffer</a>. </li> <li id="features-limits-maxDescriptorSetStorageImages">  <code>maxDescriptorSetStorageImages</code> is the maximum number of storage images that <strong>can</strong> be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> count against this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storageimage">html/vkspec.html#descriptorsets-storageimage</a>, and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagetexelbuffer">html/vkspec.html#descriptorsets-storagetexelbuffer</a>. </li> <li id="features-limits-maxDescriptorSetInputAttachments">  <code>maxDescriptorSetInputAttachments</code> is the maximum number of input attachments that <strong>can</strong> be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> count against this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-inputattachment">html/vkspec.html#descriptorsets-inputattachment</a>. </li> <li id="features-limits-maxVertexInputAttributes">  <code>maxVertexInputAttributes</code> is the maximum number of vertex input attributes that <strong>can</strong> be specified for a graphics pipeline. These are described in the array of <code>VkVertexInputAttributeDescription</code> structures that are provided at graphics pipeline creation time via the <code>pVertexAttributeDescriptions</code> member of the <code>VkPipelineVertexInputStateCreateInfo</code> structure. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-attrib">html/vkspec.html#fxvertex-attrib</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">html/vkspec.html#fxvertex-input</a>. </li> <li id="features-limits-maxVertexInputBindings">  <code>maxVertexInputBindings</code> is the maximum number of vertex buffers that <strong>can</strong> be specified for providing vertex attributes to a graphics pipeline. These are described in the array of <code>VkVertexInputBindingDescription</code> structures that are provided at graphics pipeline creation time via the <code>pVertexBindingDescriptions</code> member of the <code>VkPipelineVertexInputStateCreateInfo</code> structure. The <code>binding</code> member of <code>VkVertexInputBindingDescription</code> <strong>must</strong> be less than this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">html/vkspec.html#fxvertex-input</a>. </li> <li id="features-limits-maxVertexInputAttributeOffset">  <code>maxVertexInputAttributeOffset</code> is the maximum vertex input attribute offset that <strong>can</strong> be added to the vertex input binding stride. The <code>offset</code> member of the <code>VkVertexInputAttributeDescription</code> structure <strong>must</strong> be less than or equal to this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">html/vkspec.html#fxvertex-input</a>. </li> <li id="features-limits-maxVertexInputBindingStride">  <code>maxVertexInputBindingStride</code> is the maximum vertex input binding stride that <strong>can</strong> be specified in a vertex input binding. The <code>stride</code> member of the <code>VkVertexInputBindingDescription</code> structure <strong>must</strong> be less than or equal to this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fxvertex-input">html/vkspec.html#fxvertex-input</a>. </li> <li id="features-limits-maxVertexOutputComponents">  <code>maxVertexOutputComponents</code> is the maximum number of components of output variables which <strong>can</strong> be output by a vertex shader. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-vertex">html/vkspec.html#shaders-vertex</a>. </li> <li id="features-limits-maxTessellationGenerationLevel">  <code>maxTessellationGenerationLevel</code> is the maximum tessellation generation level supported by the fixed-function tessellation primitive generator. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#tessellation">html/vkspec.html#tessellation</a>. </li> <li id="features-limits-maxTessellationPatchSize">  <code>maxTessellationPatchSize</code> is the maximum patch size, in vertices, of patches that <strong>can</strong> be processed by the tessellation control shader and tessellation primitive generator. The <code>patchControlPoints</code> member of the <code>VkPipelineTessellationStateCreateInfo</code> structure specified at pipeline creation time and the value provided in the <code>OutputVertices</code> execution mode of shader modules <strong>must</strong> be less than or equal to this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#tessellation">html/vkspec.html#tessellation</a>. </li> <li id="features-limits-maxTessellationControlPerVertexInputComponents">  <code>maxTessellationControlPerVertexInputComponents</code> is the maximum number of components of input variables which <strong>can</strong> be provided as per-vertex inputs to the tessellation control shader stage. </li> <li id="features-limits-maxTessellationControlPerVertexOutputComponents">  <code>maxTessellationControlPerVertexOutputComponents</code> is the maximum number of components of per-vertex output variables which <strong>can</strong> be output from the tessellation control shader stage. </li> <li id="features-limits-maxTessellationControlPerPatchOutputComponents">  <code>maxTessellationControlPerPatchOutputComponents</code> is the maximum number of components of per-patch output variables which <strong>can</strong> be output from the tessellation control shader stage. </li> <li id="features-limits-maxTessellationControlTotalOutputComponents">  <code>maxTessellationControlTotalOutputComponents</code> is the maximum total number of components of per-vertex and per-patch output variables which <strong>can</strong> be output from the tessellation control shader stage. </li> <li id="features-limits-maxTessellationEvaluationInputComponents">  <code>maxTessellationEvaluationInputComponents</code> is the maximum number of components of input variables which <strong>can</strong> be provided as per-vertex inputs to the tessellation evaluation shader stage. </li> <li id="features-limits-maxTessellationEvaluationOutputComponents">  <code>maxTessellationEvaluationOutputComponents</code> is the maximum number of components of per-vertex output variables which <strong>can</strong> be output from the tessellation evaluation shader stage. </li> <li id="features-limits-maxGeometryShaderInvocations">  <code>maxGeometryShaderInvocations</code> is the maximum invocation count supported for instanced geometry shaders. The value provided in the <code>Invocations</code> execution mode of shader modules <strong>must</strong> be less than or equal to this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#geometry">html/vkspec.html#geometry</a>. </li> <li id="features-limits-maxGeometryInputComponents">  <code>maxGeometryInputComponents</code> is the maximum number of components of input variables which <strong>can</strong> be provided as inputs to the geometry shader stage. </li> <li id="features-limits-maxGeometryOutputComponents">  <code>maxGeometryOutputComponents</code> is the maximum number of components of output variables which <strong>can</strong> be output from the geometry shader stage. </li> <li id="features-limits-maxGeometryOutputVertices">  <code>maxGeometryOutputVertices</code> is the maximum number of vertices which <strong>can</strong> be emitted by any geometry shader. </li> <li id="features-limits-maxGeometryTotalOutputComponents">  <code>maxGeometryTotalOutputComponents</code> is the maximum total number of components of output, across all emitted vertices, which <strong>can</strong> be output from the geometry shader stage. </li> <li id="features-limits-maxFragmentInputComponents">  <code>maxFragmentInputComponents</code> is the maximum number of components of input variables which <strong>can</strong> be provided as inputs to the fragment shader stage. </li> <li id="features-limits-maxFragmentOutputAttachments">  <code>maxFragmentOutputAttachments</code> is the maximum number of output attachments which <strong>can</strong> be written to by the fragment shader stage. </li> <li id="features-limits-maxFragmentDualSrcAttachments">  <code>maxFragmentDualSrcAttachments</code> is the maximum number of output attachments which <strong>can</strong> be written to by the fragment shader stage when blending is enabled and one of the dual source blend modes is in use. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-dsb">html/vkspec.html#framebuffer-dsb</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend">dualSrcBlend</a>. </li> <li id="features-limits-maxFragmentCombinedOutputResources">  <code>maxFragmentCombinedOutputResources</code> is the total number of storage buffers, storage images, and output buffers which <strong>can</strong> be used in the fragment shader stage. </li> <li id="features-limits-maxComputeSharedMemorySize">  <code>maxComputeSharedMemorySize</code> is the maximum total storage size, in bytes, of all variables declared with the <code>WorkgroupLocal</code> storage class in shader modules (or with the <code>shared</code> storage qualifier in GLSL) in the compute shader stage. </li> <li id="features-limits-maxComputeWorkGroupCount">  <code>maxComputeWorkGroupCount</code>[3] is the maximum number of local workgroups that <strong>can</strong> be dispatched by a single dispatch command. These three values represent the maximum number of local workgroups for the X, Y, and Z dimensions, respectively. The workgroup count parameters to the dispatch commands <strong>must</strong> be less than or equal to the corresponding limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#dispatch">html/vkspec.html#dispatch</a>. </li> <li id="features-limits-maxComputeWorkGroupInvocations">  <code>maxComputeWorkGroupInvocations</code> is the maximum total number of compute shader invocations in a single local workgroup. The product of the X, Y, and Z sizes as specified by the <code>LocalSize</code> execution mode in shader modules and by the object decorated by the <code>WorkgroupSize</code> decoration <strong>must</strong> be less than or equal to this limit. </li> <li id="features-limits-maxComputeWorkGroupSize">  <code>maxComputeWorkGroupSize</code>[3] is the maximum size of a local compute workgroup, per dimension. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The <code>x</code>, <code>y</code>, and <code>z</code> sizes specified by the <code>LocalSize</code> execution mode and by the object decorated by the <code>WorkgroupSize</code> decoration in shader modules <strong>must</strong> be less than or equal to the corresponding limit. </li> <li id="features-limits-subPixelPrecisionBits">  <code>subPixelPrecisionBits</code> is the number of bits of subpixel precision in framebuffer coordinates x<sub>f</sub> and y<sub>f</sub>. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#primsrast">html/vkspec.html#primsrast</a>. </li> <li id="features-limits-subTexelPrecisionBits">  <code>subTexelPrecisionBits</code> is the number of bits of precision in the division along an axis of an image used for minification and magnification filters. 2<sup><code>subTexelPrecisionBits</code></sup> is the actual number of divisions along each axis of the image represented. The filtering hardware will snap to these locations when computing the filtered results. </li> <li> <p id="features-limits-mipmapPrecisionBits"> <code>mipmapPrecisionBits</code> is the number of bits of division that the LOD calculation for mipmap fetching get snapped to when determining the contribution from each mip level to the mip filtered results. 2<sup><code>mipmapPrecisionBits</code></sup> is the actual number of divisions.</p> <blockquote> <h5 class="title">Note</h5>  <p>For example, if this value is 2 bits then when linearly filtering between two levels, each level could: contribute: 0%, 33%, 66%, or 100% (this is just an example and the amount of contribution <strong>should</strong> be covered by different equations in the spec).</p>  </blockquote> </li> <li id="features-limits-maxDrawIndexedIndexValue">  <code>maxDrawIndexedIndexValue</code> is the maximum index value that <strong>can</strong> be used for indexed draw calls when using 32-bit indices. This excludes the primitive restart index value of 0xFFFFFFFF. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-fullDrawIndexUint32">fullDrawIndexUint32</a>. </li> <li id="features-limits-maxDrawIndirectCount">  <code>maxDrawIndirectCount</code> is the maximum draw count that is supported for indirect draw calls. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiDrawIndirect">multiDrawIndirect</a>. </li> <li id="features-limits-maxSamplerLodBias">  <code>maxSamplerLodBias</code> is the maximum absolute sampler level of detail bias. The sum of the <code>mipLodBias</code> member of the <code>VkSamplerCreateInfo</code> structure and the <code>Bias</code> operand of image sampling operations in shader modules (or 0 if no <code>Bias</code> operand is provided to an image sampling operation) are clamped to the range [-<code>maxSamplerLodBias</code>,+<code>maxSamplerLodBias</code>]. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#samplers-mipLodBias">html/vkspec.html#samplers-mipLodBias</a>. </li> <li id="features-limits-maxSamplerAnisotropy">  <code>maxSamplerAnisotropy</code> is the maximum degree of sampler anisotropy. The maximum degree of anisotropic filtering used for an image sampling operation is the minimum of the <code>maxAnisotropy</code> member of the <code>VkSamplerCreateInfo</code> structure and this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#samplers-maxAnisotropy">html/vkspec.html#samplers-maxAnisotropy</a>. </li> <li id="features-limits-maxViewports">  <code>maxViewports</code> is the maximum number of active viewports. The <code>viewportCount</code> member of the <code>VkPipelineViewportStateCreateInfo</code> structure that is provided at pipeline creation <strong>must</strong> be less than or equal to this limit. </li> <li id="features-limits-maxViewportDimensions">  <code>maxViewportDimensions</code>[2] are the maximum viewport dimensions in the X (width) and Y (height) dimensions, respectively. The maximum viewport dimensions <strong>must</strong> be greater than or equal to the largest image which <strong>can</strong> be created and used as a framebuffer attachment. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vertexpostproc-viewport">Controlling the Viewport</a>. </li> <li> <p id="features-limits-viewportboundsrange"> <code>viewportBoundsRange</code>[2] is the [minimum, maximum] range that the corners of a viewport <strong>must</strong> be contained in. This range <strong>must</strong> be at least [-2 × <code>size</code>, 2 × <code>size</code> - 1], where <code>size</code> = max(<code>maxViewportDimensions</code>[0], <code>maxViewportDimensions</code>[1]). See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vertexpostproc-viewport">Controlling the Viewport</a>.</p> <blockquote> <h5 class="title">Note</h5>  <p>The intent of the <code>viewportBoundsRange</code> limit is to allow a maximum sized viewport to be arbitrarily shifted relative to the output target as long as at least some portion intersects. This would give a bounds limit of [-<code>size</code> + 1, 2 × <code>size</code> - 1] which would allow all possible non-empty-set intersections of the output target and the viewport. Since these numbers are typically powers of two, picking the signed number range using the smallest possible number of bits ends up with the specified range.</p>  </blockquote> </li> <li id="features-limits-viewportSubPixelBits">  <code>viewportSubPixelBits</code> is the number of bits of subpixel precision for viewport bounds. The subpixel precision that floating-point viewport bounds are interpreted at is given by this limit. </li> <li id="features-limits-minMemoryMapAlignment">  <code>minMemoryMapAlignment</code> is the minimum <strong>required</strong> alignment, in bytes, of host visible memory allocations within the host address space. When mapping a memory allocation with <a href="#vkMapMemory">vkMapMemory</a>, subtracting <code>offset</code> bytes from the returned pointer will always produce an integer multiple of this limit. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-device-hostaccess">html/vkspec.html#memory-device-hostaccess</a>. </li> <li id="features-limits-minTexelBufferOffsetAlignment">  <code>minTexelBufferOffsetAlignment</code> is the minimum <strong>required</strong> alignment, in bytes, for the <code>offset</code> member of the <code>VkBufferViewCreateInfo</code> structure for texel buffers. When a buffer view is created for a buffer which was created with <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> or <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code> set in the <code>usage</code> member of the <code>VkBufferCreateInfo</code> structure, the <code>offset</code> <strong>must</strong> be an integer multiple of this limit. </li> <li id="features-limits-minUniformBufferOffsetAlignment">  <code>minUniformBufferOffsetAlignment</code> is the minimum <strong>required</strong> alignment, in bytes, for the <code>offset</code> member of the <code>VkDescriptorBufferInfo</code> structure for uniform buffers. When a descriptor of type <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> is updated, the <code>offset</code> <strong>must</strong> be an integer multiple of this limit. Similarly, dynamic offsets for uniform buffers <strong>must</strong> be multiples of this limit. </li> <li id="features-limits-minStorageBufferOffsetAlignment">  <code>minStorageBufferOffsetAlignment</code> is the minimum <strong>required</strong> alignment, in bytes, for the <code>offset</code> member of the <code>VkDescriptorBufferInfo</code> structure for storage buffers. When a descriptor of type <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> is updated, the <code>offset</code> <strong>must</strong> be an integer multiple of this limit. Similarly, dynamic offsets for storage buffers <strong>must</strong> be multiples of this limit. </li> <li id="features-limits-minTexelOffset">  <code>minTexelOffset</code> is the minimum offset value for the <code>ConstOffset</code> image operand of any of the <code>OpImageSample</code>* or <code>OpImageFetch</code>* image instructions. </li> <li id="features-limits-maxTexelOffset">  <code>maxTexelOffset</code> is the maximum offset value for the <code>ConstOffset</code> image operand of any of the <code>OpImageSample</code>* or <code>OpImageFetch</code>* image instructions. </li> <li id="features-limits-minTexelGatherOffset">  <code>minTexelGatherOffset</code> is the minimum offset value for the <code>Offset</code> or <code>ConstOffsets</code> image operands of any of the <code>OpImage</code>*<code>Gather</code> image instructions. </li> <li id="features-limits-maxTexelGatherOffset">  <code>maxTexelGatherOffset</code> is the maximum offset value for the <code>Offset</code> or <code>ConstOffsets</code> image operands of any of the <code>OpImage</code>*<code>Gather</code> image instructions. </li> <li id="features-limits-minInterpolationOffset">  <code>minInterpolationOffset</code> is the minimum negative offset value for the <code>offset</code> operand of the <code>InterpolateAtOffset</code> extended instruction. </li> <li id="features-limits-maxInterpolationOffset">  <code>maxInterpolationOffset</code> is the maximum positive offset value for the <code>offset</code> operand of the <code>InterpolateAtOffset</code> extended instruction. </li> <li id="features-limits-subPixelInterpolationOffsetBits">  <code>subPixelInterpolationOffsetBits</code> is the number of subpixel fractional bits that the <code>x</code> and <code>y</code> offsets to the <code>InterpolateAtOffset</code> extended instruction <strong>may</strong> be rounded to as fixed-point values. </li> <li id="features-limits-maxFramebufferWidth">  <code>maxFramebufferWidth</code> is the maximum width for a framebuffer. The <code>width</code> member of the <code>VkFramebufferCreateInfo</code> structure <strong>must</strong> be less than or equal to this limit. </li> <li id="features-limits-maxFramebufferHeight">  <code>maxFramebufferHeight</code> is the maximum height for a framebuffer. The <code>height</code> member of the <code>VkFramebufferCreateInfo</code> structure <strong>must</strong> be less than or equal to this limit. </li> <li id="features-limits-maxFramebufferLayers">  <code>maxFramebufferLayers</code> is the maximum layer count for a layered framebuffer. The <code>layers</code> member of the <code>VkFramebufferCreateInfo</code> structure <strong>must</strong> be less than or equal to this limit. </li> <li id="features-limits-framebufferColorSampleCounts">  <code>framebufferColorSampleCounts</code> is a bitmask<sup>1</sup> of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> indicating the color sample counts that are supported for all framebuffer color attachments with floating- or fixed-point formats. There is no limit that indicates the color sample counts that are supported for all color attachments with integer formats. </li> <li id="features-limits-framebufferDepthSampleCounts">  <code>framebufferDepthSampleCounts</code> is a bitmask<sup>1</sup> of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> indicating the supported depth sample counts for all framebuffer depth/stencil attachments, when the format includes a depth component. </li> <li> <code>framebufferStencilSampleCounts</code> is a bitmask<sup>1</sup> of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> indicating the supported stencil sample counts for all framebuffer depth/stencil attachments, when the format includes a stencil component. </li> <li> <code>framebufferNoAttachmentsSampleCounts</code> is a bitmask<sup>1</sup> of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> indicating the supported sample counts for a framebuffer with no attachments. </li> <li id="features-limits-maxColorAttachments">  <code>maxColorAttachments</code> is the maximum number of color attachments that <strong>can</strong> be used by a subpass in a render pass. The <code>colorAttachmentCount</code> member of the <code>VkSubpassDescription</code> structure <strong>must</strong> be less than or equal to this limit. </li> <li id="features-limits-sampledImageColorSampleCounts">  <code>sampledImageColorSampleCounts</code> is a bitmask<sup>1</sup> of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> indicating the sample counts supported for all 2D images created with <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>usage</code> containing <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, and a non-integer color format. </li> <li id="features-limits-sampledImageIntegerSampleCounts">  <code>sampledImageIntegerSampleCounts</code> is a bitmask<sup>1</sup> of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> indicating the sample counts supported for all 2D images created with <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>usage</code> containing <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, and an integer color format. </li> <li id="features-limits-sampledImageDepthSampleCounts">  <code>sampledImageDepthSampleCounts</code> is a bitmask<sup>1</sup> of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> indicating the sample counts supported for all 2D images created with <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>usage</code> containing <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, and a depth format. </li> <li id="features-limits-sampledImageStencilSampleCounts">  <code>sampledImageStencilSampleCounts</code> is a bitmask<sup>1</sup> of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> indicating the sample supported for all 2D images created with <code>VK_IMAGE_TILING_OPTIMAL</code>, <code>usage</code> containing <code>VK_IMAGE_USAGE_SAMPLED_BIT</code>, and a stencil format. </li> <li id="features-limits-storageImageSampleCounts">  <code>storageImageSampleCounts</code> is a bitmask<sup>1</sup> of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> indicating the sample counts supported for all 2D images created with <code>VK_IMAGE_TILING_OPTIMAL</code>, and <code>usage</code> containing <code>VK_IMAGE_USAGE_STORAGE_BIT</code>. </li> <li id="features-limits-maxSampleMaskWords">  <code>maxSampleMaskWords</code> is the maximum number of array elements of a variable decorated with the <code>SampleMask</code> built-in decoration. </li> <li id="features-limits-timestampComputeAndGraphics">  <code>timestampComputeAndGraphics</code> indicates support for timestamps on all graphics and compute queues. If this limit is set to <code>VK_TRUE</code>, all queues that advertise the <code>VK_QUEUE_GRAPHICS_BIT</code> or <code>VK_QUEUE_COMPUTE_BIT</code> in the <code>VkQueueFamilyProperties</code>::<code>queueFlags</code> support <code>VkQueueFamilyProperties</code>::<code>timestampValidBits</code> of at least 36. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-timestamps">Timestamp Queries</a>. </li> <li id="features-limits-timestampPeriod">  <code>timestampPeriod</code> is the number of nanoseconds <strong>required</strong> for a timestamp query to be incremented by 1. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-timestamps">Timestamp Queries</a>. </li> <li id="features-limits-maxClipDistances">  <code>maxClipDistances</code> is the maximum number of clip distances that <strong>can</strong> be used in a single shader stage. The size of any array declared with the <code>ClipDistance</code> built-in decoration in a shader module <strong>must</strong> be less than or equal to this limit. </li> <li id="features-limits-maxCullDistances">  <code>maxCullDistances</code> is the maximum number of cull distances that <strong>can</strong> be used in a single shader stage. The size of any array declared with the <code>CullDistance</code> built-in decoration in a shader module <strong>must</strong> be less than or equal to this limit. </li> <li id="features-limits-maxCombinedClipAndCullDistances">  <code>maxCombinedClipAndCullDistances</code> is the maximum combined number of clip and cull distances that <strong>can</strong> be used in a single shader stage. The sum of the sizes of any pair of arrays declared with the <code>ClipDistance</code> and <code>CullDistance</code> built-in decoration used by a single shader stage in a shader module <strong>must</strong> be less than or equal to this limit. </li> <li id="features-limits-discreteQueuePriorities">  <code>discreteQueuePriorities</code> is the number of discrete priorities that <strong>can</strong> be assigned to a queue based on the value of each member of <code>VkDeviceQueueCreateInfo</code>::<code>pQueuePriorities</code>. This <strong>must</strong> be at least 2, and levels <strong>must</strong> be spread evenly over the range, with at least one level at 1.0, and another at 0.0. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-priority">html/vkspec.html#devsandqueues-priority</a>. </li> <li id="features-limits-pointSizeRange">  <code>pointSizeRange</code>[2] is the range [<code>minimum</code>,<code>maximum</code>] of supported sizes for points. Values written to variables decorated with the <code>PointSize</code> built-in decoration are clamped to this range. </li> <li id="features-limits-lineWidthRange">  <code>lineWidthRange</code>[2] is the range [<code>minimum</code>,<code>maximum</code>] of supported widths for lines. Values specified by the <code>lineWidth</code> member of the <code>VkPipelineRasterizationStateCreateInfo</code> or the <code>lineWidth</code> parameter to <code>vkCmdSetLineWidth</code> are clamped to this range. </li> <li id="features-limits-pointSizeGranularity">  <code>pointSizeGranularity</code> is the granularity of supported point sizes. Not all point sizes in the range defined by <code>pointSizeRange</code> are supported. This limit specifies the granularity (or increment) between successive supported point sizes. </li> <li id="features-limits-lineWidthGranularity">  <code>lineWidthGranularity</code> is the granularity of supported line widths. Not all line widths in the range defined by <code>lineWidthRange</code> are supported. This limit specifies the granularity (or increment) between successive supported line widths. </li> <li id="features-limits-strictLines">  <code>strictLines</code> indicates whether lines are rasterized according to the preferred method of rasterization. If set to <code>VK_FALSE</code>, lines <strong>may</strong> be rasterized under a relaxed set of rules. If set to <code>VK_TRUE</code>, lines are rasterized as per the strict definition. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#primsrast-lines-basic">Basic Line Segment Rasterization</a>. </li> <li id="features-limits-standardSampleLocations">  <code>standardSampleLocations</code> indicates whether rasterization uses the standard sample locations as documented in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#primsrast-multisampling">Multisampling</a>. If set to <code>VK_TRUE</code>, the implementation uses the documented sample locations. If set to <code>VK_FALSE</code>, the implementation <strong>may</strong> use different sample locations. </li> <li id="features-limits-optimalBufferCopyOffsetAlignment">  <code>optimalBufferCopyOffsetAlignment</code> is the optimal buffer offset alignment in bytes for <code>vkCmdCopyBufferToImage</code> and <code>vkCmdCopyImageToBuffer</code>. The per texel alignment requirements are enforced, but applications <strong>should</strong> use the optimal alignment for optimal performance and power use. </li> <li id="features-limits-optimalBufferCopyRowPitchAlignment">  <code>optimalBufferCopyRowPitchAlignment</code> is the optimal buffer row pitch alignment in bytes for <code>vkCmdCopyBufferToImage</code> and <code>vkCmdCopyImageToBuffer</code>. Row pitch is the number of bytes between texels with the same X coordinate in adjacent rows (Y coordinates differ by one). The per texel alignment requirements are enforced, but applications <strong>should</strong> use the optimal alignment for optimal performance and power use. </li> <li id="features-limits-nonCoherentAtomSize">  <code>nonCoherentAtomSize</code> is the size and alignment in bytes that bounds concurrent access to <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-device-hostaccess">host-mapped device memory</a>. </li> </ul>    <h4 id="_description_226">Description</h4> <div class="dlist"> <dl> <dt>1</dt> <dd> For all bitmasks of <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a>, the sample count limits defined above represent the minimum supported sample counts for each image type. Individual images <strong>may</strong> support additional sample counts, which are queried using <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a> as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-supported-sample-counts">Supported Sample Counts</a>. </dd> </dl> </div>   <h4 id="_see_also_226">See Also</h4>  <p><code>VkBool32</code>, <code>VkDeviceSize</code>, <a href="#VkPhysicalDeviceProperties">VkPhysicalDeviceProperties</a>, <a href="#VkSampleCountFlags">VkSampleCountFlags</a></p>    <h4 id="_document_notes_226">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceLimits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceLimits</a></p>         <h3 id="_vkphysicaldevicememoryproperties_3">VkPhysicalDeviceMemoryProperties(3)</h3>  <h4 id="_name_227">Name</h4>  <p>VkPhysicalDeviceMemoryProperties - Structure specifying physical device memory properties</p>    <h4 id="_c_specification_227">C Specification</h4>  <p>The <code>VkPhysicalDeviceMemoryProperties</code> structure is defined as:</p>  <pre id="VkPhysicalDeviceMemoryProperties" data-language="c++">typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;</pre>   <h4 id="_members_65">Members</h4>  <ul> <li> <code>memoryTypeCount</code> is the number of valid elements in the <code>memoryTypes</code> array. </li> <li> <code>memoryTypes</code> is an array of <a href="#VkMemoryType">VkMemoryType</a> structures describing the <em>memory types</em> that <strong>can</strong> be used to access memory allocated from the heaps specified by <code>memoryHeaps</code>. </li> <li> <code>memoryHeapCount</code> is the number of valid elements in the <code>memoryHeaps</code> array. </li> <li> <code>memoryHeaps</code> is an array of <a href="#VkMemoryHeap">VkMemoryHeap</a> structures describing the <em>memory heaps</em> from which memory <strong>can</strong> be allocated. </li> </ul>    <h4 id="_description_227">Description</h4>  <p>The <code>VkPhysicalDeviceMemoryProperties</code> structure describes a number of <em>memory heaps</em> as well as a number of <em>memory types</em> that <strong>can</strong> be used to access memory allocated in those heaps. Each heap describes a memory resource of a particular size, and each memory type describes a set of memory properties (e.g. host cached vs uncached) that <strong>can</strong> be used with a given memory heap. Allocations using a particular memory type will consume resources from the heap indicated by that memory type’s heap index. More than one memory type <strong>may</strong> share each heap, and the heaps and memory types provide a mechanism to advertise an accurate size of the physical memory resources while allowing the memory to be used with a variety of different properties.</p>   <p>The number of memory heaps is given by <code>memoryHeapCount</code> and is less than or equal to <code>VK_MAX_MEMORY_HEAPS</code>. Each heap is described by an element of the <code>memoryHeaps</code> array, as a <code>VkMemoryHeap</code> structure. The number of memory types available across all memory heaps is given by <code>memoryTypeCount</code> and is less than or equal to <code>VK_MAX_MEMORY_TYPES</code>. Each memory type is described by an element of the <code>memoryTypes</code> array, as a <code>VkMemoryType</code> structure.</p>   <p>At least one heap <strong>must</strong> include <code>VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code> in <a href="#VkMemoryHeap">VkMemoryHeap</a>::<code>flags</code>. If there are multiple heaps that all have similar performance characteristics, they <strong>may</strong> all include <code>VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code>. In a unified memory architecture (UMA) system, there is often only a single memory heap which is considered to be equally “local” to the host and to the device, and such an implementation <strong>must</strong> advertise the heap as device-local.</p>   <p>Each memory type returned by <a href="#vkGetPhysicalDeviceMemoryProperties">vkGetPhysicalDeviceMemoryProperties</a> <strong>must</strong> have its <code>propertyFlags</code> set to one of the following values:</p>   <ul> <li> 0 </li> <li> <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> </li> <li> <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> </li> <li> <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> </li> <li> <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> </li> <li> <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> </li> <li> <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> </li> <li> <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> | <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> </li> <li> <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> | <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code> </li> </ul>   <p>There <strong>must</strong> be at least one memory type with both the <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> bits set in its <code>propertyFlags</code>. There <strong>must</strong> be at least one memory type with the <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> bit set in its <code>propertyFlags</code>.</p>   <p>The memory types are sorted according to a preorder which serves to aid in easily selecting an appropriate memory type. Given two memory types X and Y, the preorder defines X ≤ Y if:</p>   <ul> <li> the memory property bits set for X are a strict subset of the memory property bits set for Y. Or, </li> <li> the memory property bits set for X are the same as the memory property bits set for Y, and X uses a memory heap with greater or equal performance (as determined in an implementation-specific manner). </li> </ul>   <p>Memory types are ordered in the list such that X is assigned a lesser <code>memoryTypeIndex</code> than Y if (X ≤ Y) ∧ ¬ (Y ≤ X) according to the preorder. Note that the list of all allowed memory property flag combinations above satisfies this preorder, but other orders would as well. The goal of this ordering is to enable applications to use a simple search loop in selecting the proper memory type, along the lines of:</p>  <pre data-language="c++">// Find a memory type in "memoryTypeBits" that includes all of "properties"
int32_t FindProperties(uint32_t memoryTypeBits, VkMemoryPropertyFlags properties)
{
    for (int32_t i = 0; i &lt; memoryTypeCount; ++i)
    {
        if ((memoryTypeBits &amp; (1 &lt;&lt; i)) &amp;&amp;
            ((memoryTypes[i].propertyFlags &amp; properties) == properties))
            return i;
    }
    return -1;
}

// Try to find an optimal memory type, or if it does not exist
// find any compatible memory type
VkMemoryRequirements memoryRequirements;
vkGetImageMemoryRequirements(device, image, &amp;memoryRequirements);
int32_t memoryType = FindProperties(memoryRequirements.memoryTypeBits, optimalProperties);
if (memoryType == -1)
    memoryType = FindProperties(memoryRequirements.memoryTypeBits, requiredProperties);</pre>  <p>The loop will find the first supported memory type that has all bits requested in <code>properties</code> set. If there is no exact match, it will find a closest match (i.e. a memory type with the fewest additional bits set), which has some additional bits set but which are not detrimental to the behaviors requested by <code>properties</code>. The application <strong>can</strong> first search for the optimal properties, e.g. a memory type that is device-local or supports coherent cached accesses, as appropriate for the intended usage, and if such a memory type is not present <strong>can</strong> fallback to searching for a less optimal but guaranteed set of properties such as "0" or "host-visible and coherent".</p>    <h4 id="_see_also_227">See Also</h4>  <p><a href="#VkMemoryHeap">VkMemoryHeap</a>, <a href="#VkMemoryType">VkMemoryType</a>, <a href="#vkGetPhysicalDeviceMemoryProperties">vkGetPhysicalDeviceMemoryProperties</a></p>    <h4 id="_document_notes_227">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceMemoryProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceMemoryProperties</a></p>         <h3 id="_vkphysicaldeviceproperties_3">VkPhysicalDeviceProperties(3)</h3>  <h4 id="_name_228">Name</h4>  <p>VkPhysicalDeviceProperties - Structure specifying physical device properties</p>    <h4 id="_c_specification_228">C Specification</h4>  <p>The <code>VkPhysicalDeviceProperties</code> structure is defined as:</p>  <pre id="VkPhysicalDeviceProperties" data-language="c++">typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties;</pre>   <h4 id="_members_66">Members</h4>  <ul> <li> <code>apiVersion</code> is the version of Vulkan supported by the device, encoded as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-versionnum">API Version Numbers and Semantics</a> section. </li> <li> <code>driverVersion</code> is the vendor-specified version of the driver. </li> <li> <code>vendorID</code> is a unique identifier for the <em>vendor</em> (see below) of the physical device. </li> <li> <code>deviceID</code> is a unique identifier for the physical device among devices available from the vendor. </li> <li> <code>deviceType</code> is a <a href="#VkPhysicalDeviceType">VkPhysicalDeviceType</a> specifying the type of device. </li> <li> <code>deviceName</code> is a null-terminated UTF-8 string containing the name of the device. </li> <li> <code>pipelineCacheUUID</code> is an array of size <code>VK_UUID_SIZE</code>, containing 8-bit values that represent a universally unique identifier for the device. </li> <li> <code>limits</code> is the <a href="#VkPhysicalDeviceLimits">VkPhysicalDeviceLimits</a> structure which specifies device-specific limits of the physical device. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits">Limits</a> for details. </li> <li> <code>sparseProperties</code> is the <a href="#VkPhysicalDeviceSparseProperties">VkPhysicalDeviceSparseProperties</a> structure which specifies various sparse related properties of the physical device. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-physicalprops">Sparse Properties</a> for details. </li> </ul>    <h4 id="_description_228">Description</h4>  <p>The <code>vendorID</code> and <code>deviceID</code> fields are provided to allow applications to adapt to device characteristics that are not adequately exposed by other Vulkan queries. These <strong>may</strong> include performance profiles, hardware errata, or other characteristics. In PCI-based implementations, the low sixteen bits of <code>vendorID</code> and <code>deviceID</code> <strong>must</strong> contain (respectively) the PCI vendor and device IDs associated with the hardware device, and the remaining bits <strong>must</strong> be set to zero. In non-PCI implementations, the choice of what values to return <strong>may</strong> be dictated by operating system or platform policies. It is otherwise at the discretion of the implementer, subject to the following constraints and guidelines:</p>   <ul> <li> For purposes of physical device identification, the <em>vendor</em> of a physical device is the entity responsible for the most salient characteristics of the hardware represented by the physical device handle. In the case of a discrete GPU, this <strong>should</strong> be the GPU chipset vendor. In the case of a GPU or other accelerator integrated into a system-on-chip (SoC), this <strong>should</strong> be the supplier of the silicon IP used to create the GPU or other accelerator. </li> <li> If the vendor of the physical device has a valid PCI vendor ID issued by <a href="https://pcisig.com/">PCI-SIG</a>, that ID <strong>should</strong> be used to construct <code>vendorID</code> as described above for PCI-based implementations. Implementations that do not return a PCI vendor ID in <code>vendorID</code> <strong>must</strong> return a valid Khronos vendor ID, obtained as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vulkan-styleguide">Vulkan Documentation and Extensions</a> document in the section “Registering a Vendor ID with Khronos”. Khronos vendor IDs are allocated starting at 0x10000, to distinguish them from the PCI vendor ID namespace. </li> <li> The vendor of the physical device is responsible for selecting <code>deviceID</code>. The value selected <strong>should</strong> uniquely identify both the device version and any major configuration options (for example, core count in the case of multicore devices). The same device ID <strong>should</strong> be used for all physical implementations of that device version and configuration. For example, all uses of a specific silicon IP GPU version and configuration <strong>should</strong> use the same device ID, even if those uses occur in different SoCs. </li> </ul>    <h4 id="_see_also_228">See Also</h4>  <p><a href="#VkPhysicalDeviceLimits">VkPhysicalDeviceLimits</a>, <a href="#VkPhysicalDeviceSparseProperties">VkPhysicalDeviceSparseProperties</a>, <a href="#VkPhysicalDeviceType">VkPhysicalDeviceType</a>, <a href="#vkGetPhysicalDeviceProperties">vkGetPhysicalDeviceProperties</a></p>    <h4 id="_document_notes_228">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceProperties</a></p>         <h3 id="_vkphysicaldevicesparseproperties_3">VkPhysicalDeviceSparseProperties(3)</h3>  <h4 id="_name_229">Name</h4>  <p>VkPhysicalDeviceSparseProperties - Structure specifying physical device sparse memory properties</p>    <h4 id="_c_specification_229">C Specification</h4>  <p>The <code>VkPhysicalDeviceSparseProperties</code> structure is defined as:</p>  <pre id="VkPhysicalDeviceSparseProperties" data-language="c++">typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32    residencyStandard2DBlockShape;
    VkBool32    residencyStandard2DMultisampleBlockShape;
    VkBool32    residencyStandard3DBlockShape;
    VkBool32    residencyAlignedMipSize;
    VkBool32    residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;</pre>   <h4 id="_members_67">Members</h4>  <ul> <li> <code>residencyStandard2DBlockShape</code> is <code>VK_TRUE</code> if the physical device will access all single-sample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseblockshapessingle">Standard Sparse Image Block Shapes (Single Sample)</a> table. If this property is not supported the value returned in the <code>imageGranularity</code> member of the <code>VkSparseImageFormatProperties</code> structure for single-sample 2D images is not <strong>required</strong> to match the standard sparse image block dimensions listed in the table. </li> <li> <code>residencyStandard2DMultisampleBlockShape</code> is <code>VK_TRUE</code> if the physical device will access all multisample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseblockshapesmsaa">Standard Sparse Image Block Shapes (MSAA)</a> table. If this property is not supported, the value returned in the <code>imageGranularity</code> member of the <code>VkSparseImageFormatProperties</code> structure for multisample 2D images is not <strong>required</strong> to match the standard sparse image block dimensions listed in the table. </li> <li> <code>residencyStandard3DBlockShape</code> is <code>VK_TRUE</code> if the physical device will access all 3D sparse resources using the standard sparse image block shapes (based on image format), as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseblockshapessingle">Standard Sparse Image Block Shapes (Single Sample)</a> table. If this property is not supported, the value returned in the <code>imageGranularity</code> member of the <code>VkSparseImageFormatProperties</code> structure for 3D images is not <strong>required</strong> to match the standard sparse image block dimensions listed in the table. </li> <li> <code>residencyAlignedMipSize</code> is <code>VK_TRUE</code> if images with mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block <strong>may</strong> be placed in the mip tail. If this property is not reported, only mip levels with dimensions smaller than the <code>imageGranularity</code> member of the <code>VkSparseImageFormatProperties</code> structure will be placed in the mip tail. If this property is reported the implementation is allowed to return <code>VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT</code> in the <code>flags</code> member of <code>VkSparseImageFormatProperties</code>, indicating that mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block will be placed in the mip tail. </li> <li> <code>residencyNonResidentStrict</code> specifies whether the physical device <strong>can</strong> consistently access non-resident regions of a resource. If this property is <code>VK_TRUE</code>, access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded. </li> </ul>       <h4 id="_see_also_229">See Also</h4>  <p><code>VkBool32</code>, <a href="#VkPhysicalDeviceProperties">VkPhysicalDeviceProperties</a></p>    <h4 id="_document_notes_229">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceSparseProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceSparseProperties</a></p>         <h3 id="_vkpipelinecachecreateinfo_3">VkPipelineCacheCreateInfo(3)</h3>  <h4 id="_name_230">Name</h4>  <p>VkPipelineCacheCreateInfo - Structure specifying parameters of a newly created pipeline cache</p>    <h4 id="_c_specification_230">C Specification</h4>  <p>The <code>VkPipelineCacheCreateInfo</code> structure is defined as:</p>  <pre id="VkPipelineCacheCreateInfo" data-language="c++">typedef struct VkPipelineCacheCreateInfo {
    VkStructureType               sType;
    const void*                   pNext;
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;
    const void*                   pInitialData;
} VkPipelineCacheCreateInfo;</pre>   <h4 id="_members_68">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>initialDataSize</code> is the number of bytes in <code>pInitialData</code>. If <code>initialDataSize</code> is zero, the pipeline cache will initially be empty. </li> <li> <code>pInitialData</code> is a pointer to previously retrieved pipeline cache data. If the pipeline cache data is incompatible (as defined below) with the device, the pipeline cache will be initially empty. If <code>initialDataSize</code> is zero, <code>pInitialData</code> is ignored. </li> </ul>    <h4 id="_description_230">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineCacheCreateInfo-initialDataSize-00768">  If <code>initialDataSize</code> is not <code>0</code>, it <strong>must</strong> be equal to the size of <code>pInitialData</code>, as returned by <code>vkGetPipelineCacheData</code> when <code>pInitialData</code> was originally retrieved </li> <li id="VUID-VkPipelineCacheCreateInfo-initialDataSize-00769">  If <code>initialDataSize</code> is not <code>0</code>, <code>pInitialData</code> <strong>must</strong> have been retrieved from a previous call to <code>vkGetPipelineCacheData</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineCacheCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineCacheCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineCacheCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineCacheCreateInfo-pInitialData-parameter">  If <code>initialDataSize</code> is not <code>0</code>, <code>pInitialData</code> <strong>must</strong> be a pointer to an array of <code>initialDataSize</code> bytes </li> </ul>   </blockquote>   <h4 id="_see_also_230">See Also</h4>  <p><a href="#VkPipelineCacheCreateFlags">VkPipelineCacheCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreatePipelineCache">vkCreatePipelineCache</a></p>    <h4 id="_document_notes_230">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCacheCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCacheCreateInfo</a></p>         <h3 id="_vkpipelinecolorblendattachmentstate_3">VkPipelineColorBlendAttachmentState(3)</h3>  <h4 id="_name_231">Name</h4>  <p>VkPipelineColorBlendAttachmentState - Structure specifying a pipeline color blend attachment state</p>    <h4 id="_c_specification_231">C Specification</h4>  <p>The <code>VkPipelineColorBlendAttachmentState</code> structure is defined as:</p>  <pre id="VkPipelineColorBlendAttachmentState" data-language="c++">typedef struct VkPipelineColorBlendAttachmentState {
    VkBool32                 blendEnable;
    VkBlendFactor            srcColorBlendFactor;
    VkBlendFactor            dstColorBlendFactor;
    VkBlendOp                colorBlendOp;
    VkBlendFactor            srcAlphaBlendFactor;
    VkBlendFactor            dstAlphaBlendFactor;
    VkBlendOp                alphaBlendOp;
    VkColorComponentFlags    colorWriteMask;
} VkPipelineColorBlendAttachmentState;</pre>   <h4 id="_members_69">Members</h4>  <ul> <li> <code>blendEnable</code> controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment’s color for that attachment is passed through unmodified. </li> <li> <code>srcColorBlendFactor</code> selects which blend factor is used to determine the source factors (S<sub>r</sub>,S<sub>g</sub>,S<sub>b</sub>). </li> <li> <code>dstColorBlendFactor</code> selects which blend factor is used to determine the destination factors (D<sub>r</sub>,D<sub>g</sub>,D<sub>b</sub>). </li> <li> <code>colorBlendOp</code> selects which blend operation is used to calculate the RGB values to write to the color attachment. </li> <li> <code>srcAlphaBlendFactor</code> selects which blend factor is used to determine the source factor S<sub>a</sub>. </li> <li> <code>dstAlphaBlendFactor</code> selects which blend factor is used to determine the destination factor D<sub>a</sub>. </li> <li> <code>alphaBlendOp</code> selects which blend operation is use to calculate the alpha values to write to the color attachment. </li> <li> <code>colorWriteMask</code> is a bitmask of <a href="#VkColorComponentFlagBits">VkColorComponentFlagBits</a> specifying which of the R, G, B, and/or A components are enabled for writing, as described for the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-color-write-mask">Color Write Mask</a>. </li> </ul>    <h4 id="_description_231">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-00608">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend">dual source blending</a> feature is not enabled, <code>srcColorBlendFactor</code> <strong>must</strong> not be <code>VK_BLEND_FACTOR_SRC1_COLOR</code>, <code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</code>, <code>VK_BLEND_FACTOR_SRC1_ALPHA</code>, or <code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</code> </li> <li id="VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-00609">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend">dual source blending</a> feature is not enabled, <code>dstColorBlendFactor</code> <strong>must</strong> not be <code>VK_BLEND_FACTOR_SRC1_COLOR</code>, <code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</code>, <code>VK_BLEND_FACTOR_SRC1_ALPHA</code>, or <code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</code> </li> <li id="VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-00610">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend">dual source blending</a> feature is not enabled, <code>srcAlphaBlendFactor</code> <strong>must</strong> not be <code>VK_BLEND_FACTOR_SRC1_COLOR</code>, <code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</code>, <code>VK_BLEND_FACTOR_SRC1_ALPHA</code>, or <code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</code> </li> <li id="VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-00611">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend">dual source blending</a> feature is not enabled, <code>dstAlphaBlendFactor</code> <strong>must</strong> not be <code>VK_BLEND_FACTOR_SRC1_COLOR</code>, <code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</code>, <code>VK_BLEND_FACTOR_SRC1_ALPHA</code>, or <code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-parameter">  <code>srcColorBlendFactor</code> <strong>must</strong> be a valid <a href="#VkBlendFactor">VkBlendFactor</a> value </li> <li id="VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-parameter">  <code>dstColorBlendFactor</code> <strong>must</strong> be a valid <a href="#VkBlendFactor">VkBlendFactor</a> value </li> <li id="VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-parameter">  <code>colorBlendOp</code> <strong>must</strong> be a valid <a href="#VkBlendOp">VkBlendOp</a> value </li> <li id="VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-parameter">  <code>srcAlphaBlendFactor</code> <strong>must</strong> be a valid <a href="#VkBlendFactor">VkBlendFactor</a> value </li> <li id="VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-parameter">  <code>dstAlphaBlendFactor</code> <strong>must</strong> be a valid <a href="#VkBlendFactor">VkBlendFactor</a> value </li> <li id="VUID-VkPipelineColorBlendAttachmentState-alphaBlendOp-parameter">  <code>alphaBlendOp</code> <strong>must</strong> be a valid <a href="#VkBlendOp">VkBlendOp</a> value </li> <li id="VUID-VkPipelineColorBlendAttachmentState-colorWriteMask-parameter">  <code>colorWriteMask</code> <strong>must</strong> be a valid combination of <a href="#VkColorComponentFlagBits">VkColorComponentFlagBits</a> values </li> </ul>   </blockquote>   <h4 id="_see_also_231">See Also</h4>  <p><a href="#VkBlendFactor">VkBlendFactor</a>, <a href="#VkBlendOp">VkBlendOp</a>, <code>VkBool32</code>, <a href="#VkColorComponentFlags">VkColorComponentFlags</a>, <a href="#VkPipelineColorBlendStateCreateInfo">VkPipelineColorBlendStateCreateInfo</a></p>    <h4 id="_document_notes_231">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineColorBlendAttachmentState">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineColorBlendAttachmentState</a></p>         <h3 id="_vkpipelinecolorblendstatecreateinfo_3">VkPipelineColorBlendStateCreateInfo(3)</h3>  <h4 id="_name_232">Name</h4>  <p>VkPipelineColorBlendStateCreateInfo - Structure specifying parameters of a newly created pipeline color blend state</p>    <h4 id="_c_specification_232">C Specification</h4>  <p>The <code>VkPipelineColorBlendStateCreateInfo</code> structure is defined as:</p>  <pre id="VkPipelineColorBlendStateCreateInfo" data-language="c++">typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType                               sType;
    const void*                                   pNext;
    VkPipelineColorBlendStateCreateFlags          flags;
    VkBool32                                      logicOpEnable;
    VkLogicOp                                     logicOp;
    uint32_t                                      attachmentCount;
    const VkPipelineColorBlendAttachmentState*    pAttachments;
    float                                         blendConstants[4];
} VkPipelineColorBlendStateCreateInfo;</pre>   <h4 id="_members_70">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>logicOpEnable</code> controls whether to apply <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-logicop">Logical Operations</a>. </li> <li> <code>logicOp</code> selects which logical operation to apply. </li> <li> <code>attachmentCount</code> is the number of <code>VkPipelineColorBlendAttachmentState</code> elements in <code>pAttachments</code>. This value <strong>must</strong> equal the <code>colorAttachmentCount</code> for the subpass in which this pipeline is used. </li> <li> <code>pAttachments</code>: is a pointer to array of per target attachment states. </li> <li> <code>blendConstants</code> is an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-blendfactors">blend factor</a>. </li> </ul>    <h4 id="_description_232">Description</h4>  <p>Each element of the <code>pAttachments</code> array is a <a href="#VkPipelineColorBlendAttachmentState">VkPipelineColorBlendAttachmentState</a> structure specifying per-target blending state for each individual color attachment. If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-independentBlend">independent blending</a> feature is not enabled on the device, all <a href="#VkPipelineColorBlendAttachmentState">VkPipelineColorBlendAttachmentState</a> elements in the <code>pAttachments</code> array <strong>must</strong> be identical.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-00605">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-independentBlend">independent blending</a> feature is not enabled, all elements of <code>pAttachments</code> <strong>must</strong> be identical </li> <li id="VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00606">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-logicOp">logic operations</a> feature is not enabled, <code>logicOpEnable</code> <strong>must</strong> be <code>VK_FALSE</code> </li> <li id="VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00607">  If <code>logicOpEnable</code> is <code>VK_TRUE</code>, <code>logicOp</code> <strong>must</strong> be a valid <a href="#VkLogicOp">VkLogicOp</a> value </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineColorBlendStateCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineColorBlendStateCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineColorBlendStateCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-parameter">  If <code>attachmentCount</code> is not <code>0</code>, <code>pAttachments</code> <strong>must</strong> be a pointer to an array of <code>attachmentCount</code> valid <code>VkPipelineColorBlendAttachmentState</code> structures </li> </ul>   </blockquote>   <h4 id="_see_also_232">See Also</h4>  <p><code>VkBool32</code>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkLogicOp">VkLogicOp</a>, <a href="#VkPipelineColorBlendAttachmentState">VkPipelineColorBlendAttachmentState</a>, <a href="#VkPipelineColorBlendStateCreateFlags">VkPipelineColorBlendStateCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_232">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineColorBlendStateCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineColorBlendStateCreateInfo</a></p>         <h3 id="_vkpipelinedepthstencilstatecreateinfo_3">VkPipelineDepthStencilStateCreateInfo(3)</h3>  <h4 id="_name_233">Name</h4>  <p>VkPipelineDepthStencilStateCreateInfo - Structure specifying parameters of a newly created pipeline depth stencil state</p>    <h4 id="_c_specification_233">C Specification</h4>  <p>The <code>VkPipelineDepthStencilStateCreateInfo</code> structure is defined as:</p>  <pre id="VkPipelineDepthStencilStateCreateInfo" data-language="c++">typedef struct VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineDepthStencilStateCreateFlags    flags;
    VkBool32                                  depthTestEnable;
    VkBool32                                  depthWriteEnable;
    VkCompareOp                               depthCompareOp;
    VkBool32                                  depthBoundsTestEnable;
    VkBool32                                  stencilTestEnable;
    VkStencilOpState                          front;
    VkStencilOpState                          back;
    float                                     minDepthBounds;
    float                                     maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo;</pre>   <h4 id="_members_71">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>depthTestEnable</code> controls whether <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-depth">depth testing</a> is enabled. </li> <li> <code>depthWriteEnable</code> controls whether <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-depth-write">depth writes</a> are enabled when <code>depthTestEnable</code> is <code>VK_TRUE</code>. Depth writes are always disabled when <code>depthTestEnable</code> is <code>VK_FALSE</code>. </li> <li> <code>depthCompareOp</code> is the comparison operator used in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-depth">depth test</a>. </li> <li> <code>depthBoundsTestEnable</code> controls whether <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-dbt">depth bounds testing</a> is enabled. </li> <li> <code>stencilTestEnable</code> controls whether <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-stencil">stencil testing</a> is enabled. </li> <li> <code>front</code> and <code>back</code> control the parameters of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-stencil">stencil test</a>. </li> <li> <code>minDepthBounds</code> and <code>maxDepthBounds</code> define the range of values used in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-dbt">depth bounds test</a>. </li> </ul>    <h4 id="_description_233">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineDepthStencilStateCreateInfo-depthBoundsTestEnable-00598">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthBounds">depth bounds testing</a> feature is not enabled, <code>depthBoundsTestEnable</code> <strong>must</strong> be <code>VK_FALSE</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineDepthStencilStateCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineDepthStencilStateCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineDepthStencilStateCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineDepthStencilStateCreateInfo-depthCompareOp-parameter">  <code>depthCompareOp</code> <strong>must</strong> be a valid <a href="#VkCompareOp">VkCompareOp</a> value </li> <li id="VUID-VkPipelineDepthStencilStateCreateInfo-front-parameter">  <code>front</code> <strong>must</strong> be a valid <code>VkStencilOpState</code> structure </li> <li id="VUID-VkPipelineDepthStencilStateCreateInfo-back-parameter">  <code>back</code> <strong>must</strong> be a valid <code>VkStencilOpState</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_233">See Also</h4>  <p><code>VkBool32</code>, <a href="#VkCompareOp">VkCompareOp</a>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipelineDepthStencilStateCreateFlags">VkPipelineDepthStencilStateCreateFlags</a>, <a href="#VkStencilOpState">VkStencilOpState</a>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_233">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineDepthStencilStateCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineDepthStencilStateCreateInfo</a></p>         <h3 id="_vkpipelinedynamicstatecreateinfo_3">VkPipelineDynamicStateCreateInfo(3)</h3>  <h4 id="_name_234">Name</h4>  <p>VkPipelineDynamicStateCreateInfo - Structure specifying parameters of a newly created pipeline dynamic state</p>    <h4 id="_c_specification_234">C Specification</h4>  <p>The <code>VkPipelineDynamicStateCreateInfo</code> structure is defined as:</p>  <pre id="VkPipelineDynamicStateCreateInfo" data-language="c++">typedef struct VkPipelineDynamicStateCreateInfo {
    VkStructureType                      sType;
    const void*                          pNext;
    VkPipelineDynamicStateCreateFlags    flags;
    uint32_t                             dynamicStateCount;
    const VkDynamicState*                pDynamicStates;
} VkPipelineDynamicStateCreateInfo;</pre>   <h4 id="_members_72">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>dynamicStateCount</code> is the number of elements in the <code>pDynamicStates</code> array. </li> <li> <code>pDynamicStates</code> is an array of <a href="#VkDynamicState">VkDynamicState</a> values specifying which pieces of pipeline state will use the values from dynamic state commands rather than from pipeline state creation info. </li> </ul>    <h4 id="_description_234">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-01442">  Each element of <code>pDynamicStates</code> <strong>must</strong> be unique </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineDynamicStateCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-parameter">  <code>pDynamicStates</code> <strong>must</strong> be a pointer to an array of <code>dynamicStateCount</code> valid <a href="#VkDynamicState">VkDynamicState</a> values </li> <li id="VUID-VkPipelineDynamicStateCreateInfo-dynamicStateCount-arraylength">  <code>dynamicStateCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_234">See Also</h4>  <p><a href="#VkDynamicState">VkDynamicState</a>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipelineDynamicStateCreateFlags">VkPipelineDynamicStateCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_234">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineDynamicStateCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineDynamicStateCreateInfo</a></p>         <h3 id="_vkpipelineinputassemblystatecreateinfo_3">VkPipelineInputAssemblyStateCreateInfo(3)</h3>  <h4 id="_name_235">Name</h4>  <p>VkPipelineInputAssemblyStateCreateInfo - Structure specifying parameters of a newly created pipeline input assembly state</p>    <h4 id="_c_specification_235">C Specification</h4>  <p>Each draw is made up of zero or more vertices and zero or more instances, which are processed by the device and result in the assembly of primitives. Primitives are assembled according to the <code>pInputAssemblyState</code> member of the <code>VkGraphicsPipelineCreateInfo</code> structure, which is of type <code>VkPipelineInputAssemblyStateCreateInfo</code>:</p>  <pre id="VkPipelineInputAssemblyStateCreateInfo" data-language="c++">typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineInputAssemblyStateCreateFlags    flags;
    VkPrimitiveTopology                        topology;
    VkBool32                                   primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo;</pre>   <h4 id="_members_73">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>topology</code> is a <a href="#VkPrimitiveTopology">VkPrimitiveTopology</a> defining the primitive topology, as described below. </li> <li> <code>primitiveRestartEnable</code> controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws (<a href="#vkCmdDrawIndexed">vkCmdDrawIndexed</a> and <a href="#vkCmdDrawIndexedIndirect">vkCmdDrawIndexedIndirect</a>), and the special index value is either 0xFFFFFFFF when the <code>indexType</code> parameter of <code>vkCmdBindIndexBuffer</code> is equal to <code>VK_INDEX_TYPE_UINT32</code>, or 0xFFFF when <code>indexType</code> is equal to <code>VK_INDEX_TYPE_UINT16</code>. Primitive restart is not allowed for “list” topologies. </li> </ul>    <h4 id="_description_235">Description</h4>  <p>Restarting the assembly of primitives discards the most recent index values if those elements formed an incomplete primitive, and restarts the primitive assembly using the subsequent indices, but only assembling the immediately following element through the end of the originally specified elements. The primitive restart index value comparison is performed before adding the <code>vertexOffset</code> value to the index value.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00428">  If <code>topology</code> is <code>VK_PRIMITIVE_TOPOLOGY_POINT_LIST</code>, <code>VK_PRIMITIVE_TOPOLOGY_LINE_LIST</code>, <code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code>, <code>VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY</code>, <code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY</code> or <code>VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</code>, <code>primitiveRestartEnable</code> <strong>must</strong> be <code>VK_FALSE</code> </li> <li id="VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00429">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, <code>topology</code> <strong>must</strong> not be any of <code>VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY</code>, <code>VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY</code>, <code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY</code> or <code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY</code> </li> <li id="VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00430">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, <code>topology</code> <strong>must</strong> not be <code>VK_PRIMITIVE_TOPOLOGY_PATCH_LIST</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineInputAssemblyStateCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineInputAssemblyStateCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineInputAssemblyStateCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineInputAssemblyStateCreateInfo-topology-parameter">  <code>topology</code> <strong>must</strong> be a valid <a href="#VkPrimitiveTopology">VkPrimitiveTopology</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_235">See Also</h4>  <p><code>VkBool32</code>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipelineInputAssemblyStateCreateFlags">VkPipelineInputAssemblyStateCreateFlags</a>, <a href="#VkPrimitiveTopology">VkPrimitiveTopology</a>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_235">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineInputAssemblyStateCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineInputAssemblyStateCreateInfo</a></p>         <h3 id="_vkpipelinelayoutcreateinfo_3">VkPipelineLayoutCreateInfo(3)</h3>  <h4 id="_name_236">Name</h4>  <p>VkPipelineLayoutCreateInfo - Structure specifying the parameters of a newly created pipeline layout object</p>    <h4 id="_c_specification_236">C Specification</h4>  <p>The <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a> structure is defined as:</p>  <pre id="VkPipelineLayoutCreateInfo" data-language="c++">typedef struct VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    const VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    const VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;</pre>   <h4 id="_members_74">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>setLayoutCount</code> is the number of descriptor sets included in the pipeline layout. </li> <li> <code>pSetLayouts</code> is a pointer to an array of <code>VkDescriptorSetLayout</code> objects. </li> <li> <code>pushConstantRangeCount</code> is the number of push constant ranges included in the pipeline layout. </li> <li> <p><code>pPushConstantRanges</code> is a pointer to an array of <code>VkPushConstantRange</code> structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants <strong>can</strong> be accessed by each stage of the pipeline.</p> <blockquote> <h5 class="title">Note</h5>  <p>Push constants represent a high speed path to modify constant data in pipelines that is expected to outperform memory-backed resource updates.</p>  </blockquote> </li> </ul>    <h4 id="_description_236">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286">  <code>setLayoutCount</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxBoundDescriptorSets</code> </li> <li id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00287">  The total number of descriptors of the type <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> and <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code> accessible to any given shader stage across all elements of <code>pSetLayouts</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorSamplers</code> </li> <li id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00288">  The total number of descriptors of the type <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> and <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code> accessible to any given shader stage across all elements of <code>pSetLayouts</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorUniformBuffers</code> </li> <li id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00289">  The total number of descriptors of the type <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> and <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> accessible to any given shader stage across all elements of <code>pSetLayouts</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorStorageBuffers</code> </li> <li id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00290">  The total number of descriptors of the type <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, and <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> accessible to any given shader stage across all elements of <code>pSetLayouts</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorSampledImages</code> </li> <li id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00291">  The total number of descriptors of the type <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, and <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> accessible to any given shader stage across all elements of <code>pSetLayouts</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxPerStageDescriptorStorageImages</code> </li> <li id="VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292">  Any two elements of <code>pPushConstantRanges</code> <strong>must</strong> not include the same stage in <code>stageFlags</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineLayoutCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO</code> </li> <li id="VUID-VkPipelineLayoutCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineLayoutCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-parameter">  If <code>setLayoutCount</code> is not <code>0</code>, <code>pSetLayouts</code> <strong>must</strong> be a pointer to an array of <code>setLayoutCount</code> valid <code>VkDescriptorSetLayout</code> handles </li> <li id="VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter">  If <code>pushConstantRangeCount</code> is not <code>0</code>, <code>pPushConstantRanges</code> <strong>must</strong> be a pointer to an array of <code>pushConstantRangeCount</code> valid <code>VkPushConstantRange</code> structures </li> </ul>   </blockquote>   <h4 id="_see_also_236">See Also</h4>  <p><a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a>, <a href="#VkPipelineLayoutCreateFlags">VkPipelineLayoutCreateFlags</a>, <a href="#VkPushConstantRange">VkPushConstantRange</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreatePipelineLayout">vkCreatePipelineLayout</a></p>    <h4 id="_document_notes_236">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineLayoutCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineLayoutCreateInfo</a></p>         <h3 id="_vkpipelinemultisamplestatecreateinfo_3">VkPipelineMultisampleStateCreateInfo(3)</h3>  <h4 id="_name_237">Name</h4>  <p>VkPipelineMultisampleStateCreateInfo - Structure specifying parameters of a newly created pipeline multisample state</p>    <h4 id="_c_specification_237">C Specification</h4>  <p>The <code>VkPipelineMultisampleStateCreateInfo</code> structure is defined as:</p>  <pre id="VkPipelineMultisampleStateCreateInfo" data-language="c++">typedef struct VkPipelineMultisampleStateCreateInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkPipelineMultisampleStateCreateFlags    flags;
    VkSampleCountFlagBits                    rasterizationSamples;
    VkBool32                                 sampleShadingEnable;
    float                                    minSampleShading;
    const VkSampleMask*                      pSampleMask;
    VkBool32                                 alphaToCoverageEnable;
    VkBool32                                 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo;</pre>   <h4 id="_members_75">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>rasterizationSamples</code> is a <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> specifying the number of samples per pixel used in rasterization. </li> <li> <code>sampleShadingEnable</code> specifies that fragment shading executes per-sample if <code>VK_TRUE</code>, or per-fragment if <code>VK_FALSE</code>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#primsrast-sampleshading">Sample Shading</a>. </li> <li> <code>minSampleShading</code> is the minimum fraction of sample shading, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#primsrast-sampleshading">Sample Shading</a>. </li> <li> <code>pSampleMask</code> is a bitmask of static coverage information that is ANDed with the coverage information generated during rasterization, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-samplemask">Sample Mask</a>. </li> <li> <code>alphaToCoverageEnable</code> controls whether a temporary coverage value is generated based on the alpha component of the fragment’s first color output as specified in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-covg">Multisample Coverage</a> section. </li> <li> <code>alphaToOneEnable</code> controls whether the alpha component of the fragment’s first color output is replaced with one as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-covg">Multisample Coverage</a>. </li> </ul>    <h4 id="_description_237">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineMultisampleStateCreateInfo-sampleShadingEnable-00784">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sampleRateShading">sample rate shading</a> feature is not enabled, <code>sampleShadingEnable</code> <strong>must</strong> be <code>VK_FALSE</code> </li> <li id="VUID-VkPipelineMultisampleStateCreateInfo-alphaToOneEnable-00785">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-alphaToOne">alpha to one</a> feature is not enabled, <code>alphaToOneEnable</code> <strong>must</strong> be <code>VK_FALSE</code> </li> <li id="VUID-VkPipelineMultisampleStateCreateInfo-minSampleShading-00786">  <code>minSampleShading</code> <strong>must</strong> be in the range [0,1] </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineMultisampleStateCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineMultisampleStateCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineMultisampleStateCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-parameter">  <code>rasterizationSamples</code> <strong>must</strong> be a valid <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a> value </li> <li id="VUID-VkPipelineMultisampleStateCreateInfo-pSampleMask-parameter">  If <code>pSampleMask</code> is not <code>NULL</code>, <code>pSampleMask</code> <strong>must</strong> be a pointer to an array of \(\lceil{\mathit{rasterizationSamples} \over 32}\rceil\) <code>VkSampleMask</code> values </li> </ul>   </blockquote>   <h4 id="_see_also_237">See Also</h4>  <p><code>VkBool32</code>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipelineMultisampleStateCreateFlags">VkPipelineMultisampleStateCreateFlags</a>, <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a>, <code>VkSampleMask</code>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_237">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineMultisampleStateCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineMultisampleStateCreateInfo</a></p>         <h3 id="_vkpipelinerasterizationstatecreateinfo_3">VkPipelineRasterizationStateCreateInfo(3)</h3>  <h4 id="_name_238">Name</h4>  <p>VkPipelineRasterizationStateCreateInfo - Structure specifying parameters of a newly created pipeline rasterization state</p>    <h4 id="_c_specification_238">C Specification</h4>  <p>The <code>VkPipelineRasterizationStateCreateInfo</code> structure is defined as:</p>  <pre id="VkPipelineRasterizationStateCreateInfo" data-language="c++">typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineRasterizationStateCreateFlags    flags;
    VkBool32                                   depthClampEnable;
    VkBool32                                   rasterizerDiscardEnable;
    VkPolygonMode                              polygonMode;
    VkCullModeFlags                            cullMode;
    VkFrontFace                                frontFace;
    VkBool32                                   depthBiasEnable;
    float                                      depthBiasConstantFactor;
    float                                      depthBiasClamp;
    float                                      depthBiasSlopeFactor;
    float                                      lineWidth;
} VkPipelineRasterizationStateCreateInfo;</pre>   <h4 id="_members_76">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>depthClampEnable</code> controls whether to clamp the fragment’s depth values instead of clipping primitives to the z planes of the frustum, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vertexpostproc-clipping">Primitive Clipping</a>. </li> <li> <code>rasterizerDiscardEnable</code> controls whether primitives are discarded immediately before the rasterization stage. </li> <li> <code>polygonMode</code> is the triangle rendering mode. See <a href="#VkPolygonMode">VkPolygonMode</a>. </li> <li> <code>cullMode</code> is the triangle facing direction used for primitive culling. See <a href="#VkCullModeFlagBits">VkCullModeFlagBits</a>. </li> <li> <code>frontFace</code> is a <a href="#VkFrontFace">VkFrontFace</a> value specifying the front-facing triangle orientation to be used for culling. </li> <li> <code>depthBiasEnable</code> controls whether to bias fragment depth values. </li> <li> <code>depthBiasConstantFactor</code> is a scalar factor controlling the constant depth value added to each fragment. </li> <li> <code>depthBiasClamp</code> is the maximum (or minimum) depth bias of a fragment. </li> <li> <code>depthBiasSlopeFactor</code> is a scalar factor applied to a fragment’s slope in depth bias calculations. </li> <li> <code>lineWidth</code> is the width of rasterized line segments. </li> </ul>    <h4 id="_description_238">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineRasterizationStateCreateInfo-depthClampEnable-00782">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthClamp">depth clamping</a> feature is not enabled, <code>depthClampEnable</code> <strong>must</strong> be <code>VK_FALSE</code> </li> <li id="VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01413">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-fillModeNonSolid">non-solid fill modes</a> feature is not enabled, <code>polygonMode</code> <strong>must</strong> be <code>VK_POLYGON_MODE_FILL</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineRasterizationStateCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineRasterizationStateCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineRasterizationStateCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-parameter">  <code>polygonMode</code> <strong>must</strong> be a valid <a href="#VkPolygonMode">VkPolygonMode</a> value </li> <li id="VUID-VkPipelineRasterizationStateCreateInfo-cullMode-parameter">  <code>cullMode</code> <strong>must</strong> be a valid combination of <a href="#VkCullModeFlagBits">VkCullModeFlagBits</a> values </li> <li id="VUID-VkPipelineRasterizationStateCreateInfo-frontFace-parameter">  <code>frontFace</code> <strong>must</strong> be a valid <a href="#VkFrontFace">VkFrontFace</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_238">See Also</h4>  <p><code>VkBool32</code>, <a href="#VkCullModeFlags">VkCullModeFlags</a>, <a href="#VkFrontFace">VkFrontFace</a>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipelineRasterizationStateCreateFlags">VkPipelineRasterizationStateCreateFlags</a>, <a href="#VkPolygonMode">VkPolygonMode</a>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_238">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineRasterizationStateCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineRasterizationStateCreateInfo</a></p>         <h3 id="_vkpipelineshaderstagecreateinfo_3">VkPipelineShaderStageCreateInfo(3)</h3>  <h4 id="_name_239">Name</h4>  <p>VkPipelineShaderStageCreateInfo - Structure specifying parameters of a newly created pipeline shader stage</p>    <h4 id="_c_specification_239">C Specification</h4>  <p>The <code>VkPipelineShaderStageCreateInfo</code> structure is defined as:</p>  <pre id="VkPipelineShaderStageCreateInfo" data-language="c++">typedef struct VkPipelineShaderStageCreateInfo {
    VkStructureType                     sType;
    const void*                         pNext;
    VkPipelineShaderStageCreateFlags    flags;
    VkShaderStageFlagBits               stage;
    VkShaderModule                      module;
    const char*                         pName;
    const VkSpecializationInfo*         pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;</pre>   <h4 id="_members_77">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>stage</code> is a <a href="#VkShaderStageFlagBits">VkShaderStageFlagBits</a> value specifying a single pipeline stage. </li> <li> <code>module</code> is a <code>VkShaderModule</code> object that contains the shader for this stage. </li> <li> <code>pName</code> is a pointer to a null-terminated UTF-8 string specifying the entry point name of the shader for this stage. </li> <li> <code>pSpecializationInfo</code> is a pointer to <a href="#VkSpecializationInfo">VkSpecializationInfo</a>, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-specialization-constants">Specialization Constants</a>, and <strong>can</strong> be <code>NULL</code>. </li> </ul>    <h4 id="_description_239">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00704">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, <code>stage</code> <strong>must</strong> not be <code>VK_SHADER_STAGE_GEOMETRY_BIT</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00705">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, <code>stage</code> <strong>must</strong> not be <code>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT</code> or <code>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00706">  <code>stage</code> <strong>must</strong> not be <code>VK_SHADER_STAGE_ALL_GRAPHICS</code>, or <code>VK_SHADER_STAGE_ALL</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-pName-00707">  <code>pName</code> <strong>must</strong> be the name of an <code>OpEntryPoint</code> in <code>module</code> with an execution model that matches <code>stage</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-maxClipDistances-00708">  If the identified entry point includes any variable in its interface that is declared with the <code>ClipDistance</code> <code>BuiltIn</code> decoration, that variable <strong>must</strong> not have an array size greater than <code>VkPhysicalDeviceLimits</code>::<code>maxClipDistances</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-maxCullDistances-00709">  If the identified entry point includes any variable in its interface that is declared with the <code>CullDistance</code> <code>BuiltIn</code> decoration, that variable <strong>must</strong> not have an array size greater than <code>VkPhysicalDeviceLimits</code>::<code>maxCullDistances</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-maxCombinedClipAndCullDistances-00710">  If the identified entry point includes any variables in its interface that are declared with the <code>ClipDistance</code> or <code>CullDistance</code> <code>BuiltIn</code> decoration, those variables <strong>must</strong> not have array sizes which sum to more than <code>VkPhysicalDeviceLimits</code>::<code>maxCombinedClipAndCullDistances</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-maxSampleMaskWords-00711">  If the identified entry point includes any variable in its interface that is declared with the <code>SampleMask</code> <code>BuiltIn</code> decoration, that variable <strong>must</strong> not have an array size greater than <code>VkPhysicalDeviceLimits</code>::<code>maxSampleMaskWords</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00712">  If <code>stage</code> is <code>VK_SHADER_STAGE_VERTEX_BIT</code>, the identified entry point <strong>must</strong> not include any input variable in its interface that is decorated with <code>CullDistance</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00713">  If <code>stage</code> is <code>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT</code> or <code>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</code>, and the identified entry point has an <code>OpExecutionMode</code> instruction that specifies a patch size with <code>OutputVertices</code>, the patch size <strong>must</strong> be greater than <code>0</code> and less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxTessellationPatchSize</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00714">  If <code>stage</code> is <code>VK_SHADER_STAGE_GEOMETRY_BIT</code>, the identified entry point <strong>must</strong> have an <code>OpExecutionMode</code> instruction that specifies a maximum output vertex count that is greater than <code>0</code> and less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxGeometryOutputVertices</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00715">  If <code>stage</code> is <code>VK_SHADER_STAGE_GEOMETRY_BIT</code>, the identified entry point <strong>must</strong> have an <code>OpExecutionMode</code> instruction that specifies an invocation count that is greater than <code>0</code> and less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxGeometryShaderInvocations</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00716">  If <code>stage</code> is <code>VK_SHADER_STAGE_GEOMETRY_BIT</code>, and the identified entry point writes to <code>Layer</code> for any primitive, it <strong>must</strong> write the same value to <code>Layer</code> for all vertices of a given primitive </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00717">  If <code>stage</code> is <code>VK_SHADER_STAGE_GEOMETRY_BIT</code>, and the identified entry point writes to <code>ViewportIndex</code> for any primitive, it <strong>must</strong> write the same value to <code>ViewportIndex</code> for all vertices of a given primitive </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00718">  If <code>stage</code> is <code>VK_SHADER_STAGE_FRAGMENT_BIT</code>, the identified entry point <strong>must</strong> not include any output variables in its interface decorated with <code>CullDistance</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-00719">  If <code>stage</code> is <code>VK_SHADER_STAGE_FRAGMENT_BIT</code>, and the identified entry point writes to <code>FragDepth</code> in any execution path, it <strong>must</strong> write to <code>FragDepth</code> in all execution paths </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineShaderStageCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineShaderStageCreateInfo-stage-parameter">  <code>stage</code> <strong>must</strong> be a valid <a href="#VkShaderStageFlagBits">VkShaderStageFlagBits</a> value </li> <li id="VUID-VkPipelineShaderStageCreateInfo-module-parameter">  <code>module</code> <strong>must</strong> be a valid <code>VkShaderModule</code> handle </li> <li id="VUID-VkPipelineShaderStageCreateInfo-pName-parameter">  <code>pName</code> <strong>must</strong> be a null-terminated UTF-8 string </li> <li id="VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-parameter">  If <code>pSpecializationInfo</code> is not <code>NULL</code>, <code>pSpecializationInfo</code> <strong>must</strong> be a pointer to a valid <code>VkSpecializationInfo</code> structure </li> </ul>   </blockquote>   <h4 id="_see_also_239">See Also</h4>  <p><a href="#VkComputePipelineCreateInfo">VkComputePipelineCreateInfo</a>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipelineShaderStageCreateFlags">VkPipelineShaderStageCreateFlags</a>, <a href="#VkShaderModule">VkShaderModule</a>, <a href="#VkShaderStageFlagBits">VkShaderStageFlagBits</a>, <a href="#VkSpecializationInfo">VkSpecializationInfo</a>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_239">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineShaderStageCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineShaderStageCreateInfo</a></p>         <h3 id="_vkpipelinetessellationstatecreateinfo_3">VkPipelineTessellationStateCreateInfo(3)</h3>  <h4 id="_name_240">Name</h4>  <p>VkPipelineTessellationStateCreateInfo - Structure specifying parameters of a newly created pipeline tessellation state</p>    <h4 id="_c_specification_240">C Specification</h4>  <p>The <code>VkPipelineTessellationStateCreateInfo</code> structure is defined as:</p>  <pre id="VkPipelineTessellationStateCreateInfo" data-language="c++">typedef struct VkPipelineTessellationStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineTessellationStateCreateFlags    flags;
    uint32_t                                  patchControlPoints;
} VkPipelineTessellationStateCreateInfo;</pre>   <h4 id="_members_78">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>patchControlPoints</code> number of control points per patch. </li> </ul>    <h4 id="_description_240">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineTessellationStateCreateInfo-patchControlPoints-01214">  <code>patchControlPoints</code> <strong>must</strong> be greater than zero and less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxTessellationPatchSize</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineTessellationStateCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineTessellationStateCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineTessellationStateCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_240">See Also</h4>  <p><a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipelineTessellationStateCreateFlags">VkPipelineTessellationStateCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a></p>    <h4 id="_document_notes_240">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineTessellationStateCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineTessellationStateCreateInfo</a></p>         <h3 id="_vkpipelinevertexinputstatecreateinfo_3">VkPipelineVertexInputStateCreateInfo(3)</h3>  <h4 id="_name_241">Name</h4>  <p>VkPipelineVertexInputStateCreateInfo - Structure specifying parameters of a newly created pipeline vertex input state</p>    <h4 id="_c_specification_241">C Specification</h4>  <p>The <code>VkPipelineVertexInputStateCreateInfo</code> structure is defined as:</p>  <pre id="VkPipelineVertexInputStateCreateInfo" data-language="c++">typedef struct VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                    vertexBindingDescriptionCount;
    const VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    uint32_t                                    vertexAttributeDescriptionCount;
    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo;</pre>   <h4 id="_members_79">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>vertexBindingDescriptionCount</code> is the number of vertex binding descriptions provided in <code>pVertexBindingDescriptions</code>. </li> <li> <code>pVertexBindingDescriptions</code> is a pointer to an array of <code>VkVertexInputBindingDescription</code> structures. </li> <li> <code>vertexAttributeDescriptionCount</code> is the number of vertex attribute descriptions provided in <code>pVertexAttributeDescriptions</code>. </li> <li> <code>pVertexAttributeDescriptions</code> is a pointer to an array of <code>VkVertexInputAttributeDescription</code> structures. </li> </ul>    <h4 id="_description_241">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineVertexInputStateCreateInfo-vertexBindingDescriptionCount-00613">  <code>vertexBindingDescriptionCount</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxVertexInputBindings</code> </li> <li id="VUID-VkPipelineVertexInputStateCreateInfo-vertexAttributeDescriptionCount-00614">  <code>vertexAttributeDescriptionCount</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxVertexInputAttributes</code> </li> <li id="VUID-VkPipelineVertexInputStateCreateInfo-binding-00615">  For every <code>binding</code> specified by any given element of <code>pVertexAttributeDescriptions</code>, a <code>VkVertexInputBindingDescription</code> <strong>must</strong> exist in <code>pVertexBindingDescriptions</code> with the same value of <code>binding</code> </li> <li id="VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-00616">  All elements of <code>pVertexBindingDescriptions</code> <strong>must</strong> describe distinct binding numbers </li> <li id="VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-00617">  All elements of <code>pVertexAttributeDescriptions</code> <strong>must</strong> describe distinct attribute locations </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineVertexInputStateCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineVertexInputStateCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineVertexInputStateCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-parameter">  If <code>vertexBindingDescriptionCount</code> is not <code>0</code>, <code>pVertexBindingDescriptions</code> <strong>must</strong> be a pointer to an array of <code>vertexBindingDescriptionCount</code> valid <code>VkVertexInputBindingDescription</code> structures </li> <li id="VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-parameter">  If <code>vertexAttributeDescriptionCount</code> is not <code>0</code>, <code>pVertexAttributeDescriptions</code> <strong>must</strong> be a pointer to an array of <code>vertexAttributeDescriptionCount</code> valid <code>VkVertexInputAttributeDescription</code> structures </li> </ul>   </blockquote>   <h4 id="_see_also_241">See Also</h4>  <p><a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipelineVertexInputStateCreateFlags">VkPipelineVertexInputStateCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#VkVertexInputAttributeDescription">VkVertexInputAttributeDescription</a>, <a href="#VkVertexInputBindingDescription">VkVertexInputBindingDescription</a></p>    <h4 id="_document_notes_241">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineVertexInputStateCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineVertexInputStateCreateInfo</a></p>         <h3 id="_vkpipelineviewportstatecreateinfo_3">VkPipelineViewportStateCreateInfo(3)</h3>  <h4 id="_name_242">Name</h4>  <p>VkPipelineViewportStateCreateInfo - Structure specifying parameters of a newly created pipeline viewport state</p>    <h4 id="_c_specification_242">C Specification</h4>  <p>The <code>VkPipelineViewportStateCreateInfo</code> structure is defined as:</p>  <pre id="VkPipelineViewportStateCreateInfo" data-language="c++">typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkPipelineViewportStateCreateFlags    flags;
    uint32_t                              viewportCount;
    const VkViewport*                     pViewports;
    uint32_t                              scissorCount;
    const VkRect2D*                       pScissors;
} VkPipelineViewportStateCreateInfo;</pre>   <h4 id="_members_80">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>viewportCount</code> is the number of viewports used by the pipeline. </li> <li> <code>pViewports</code> is a pointer to an array of <a href="#VkViewport">VkViewport</a> structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored. </li> <li> <code>scissorCount</code> is the number of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-scissor">scissors</a> and <strong>must</strong> match the number of viewports. </li> <li> <code>pScissors</code> is a pointer to an array of <code>VkRect2D</code> structures which define the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored. </li> </ul>    <h4 id="_description_242">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPipelineViewportStateCreateInfo-viewportCount-01216">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is not enabled, <code>viewportCount</code> <strong>must</strong> be <code>1</code> </li> <li id="VUID-VkPipelineViewportStateCreateInfo-scissorCount-01217">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport">multiple viewports</a> feature is not enabled, <code>scissorCount</code> <strong>must</strong> be <code>1</code> </li> <li id="VUID-VkPipelineViewportStateCreateInfo-viewportCount-01218">  <code>viewportCount</code> <strong>must</strong> be between <code>1</code> and <code>VkPhysicalDeviceLimits</code>::<code>maxViewports</code>, inclusive </li> <li id="VUID-VkPipelineViewportStateCreateInfo-scissorCount-01219">  <code>scissorCount</code> <strong>must</strong> be between <code>1</code> and <code>VkPhysicalDeviceLimits</code>::<code>maxViewports</code>, inclusive </li> <li id="VUID-VkPipelineViewportStateCreateInfo-scissorCount-01220">  <code>scissorCount</code> and <code>viewportCount</code> <strong>must</strong> be identical </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPipelineViewportStateCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO</code> </li> <li id="VUID-VkPipelineViewportStateCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkPipelineViewportStateCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkPipelineViewportStateCreateInfo-viewportCount-arraylength">  <code>viewportCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkPipelineViewportStateCreateInfo-scissorCount-arraylength">  <code>scissorCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_242">See Also</h4>  <p><a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipelineViewportStateCreateFlags">VkPipelineViewportStateCreateFlags</a>, <a href="#VkRect2D">VkRect2D</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#VkViewport">VkViewport</a></p>    <h4 id="_document_notes_242">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineViewportStateCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineViewportStateCreateInfo</a></p>         <h3 id="_vkpushconstantrange_3">VkPushConstantRange(3)</h3>  <h4 id="_name_243">Name</h4>  <p>VkPushConstantRange - Structure specifying a push constant range</p>    <h4 id="_c_specification_243">C Specification</h4>  <p>The <code>VkPushConstantRange</code> structure is defined as:</p>  <pre id="VkPushConstantRange" data-language="c++">typedef struct VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange;</pre>   <h4 id="_members_81">Members</h4>  <ul> <li> <code>stageFlags</code> is a set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will result in undefined data being read. </li> <li> <code>offset</code> and <code>size</code> are the start offset and size, respectively, consumed by the range. Both <code>offset</code> and <code>size</code> are in units of bytes and <strong>must</strong> be a multiple of 4. The layout of the push constant variables is specified in the shader. </li> </ul>    <h4 id="_description_243">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkPushConstantRange-offset-00294">  <code>offset</code> <strong>must</strong> be less than <code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code> </li> <li id="VUID-VkPushConstantRange-offset-00295">  <code>offset</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-VkPushConstantRange-size-00296">  <code>size</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkPushConstantRange-size-00297">  <code>size</code> <strong>must</strong> be a multiple of <code>4</code> </li> <li id="VUID-VkPushConstantRange-size-00298">  <code>size</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxPushConstantsSize</code> minus <code>offset</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkPushConstantRange-stageFlags-parameter">  <code>stageFlags</code> <strong>must</strong> be a valid combination of <a href="#VkShaderStageFlagBits">VkShaderStageFlagBits</a> values </li> <li id="VUID-VkPushConstantRange-stageFlags-requiredbitmask">  <code>stageFlags</code> <strong>must</strong> not be <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_243">See Also</h4>  <p><a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a>, <a href="#VkShaderStageFlags">VkShaderStageFlags</a></p>    <h4 id="_document_notes_243">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPushConstantRange">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPushConstantRange</a></p>         <h3 id="_vkquerypoolcreateinfo_3">VkQueryPoolCreateInfo(3)</h3>  <h4 id="_name_244">Name</h4>  <p>VkQueryPoolCreateInfo - Structure specifying parameters of a newly created query pool</p>    <h4 id="_c_specification_244">C Specification</h4>  <p>The <code>VkQueryPoolCreateInfo</code> structure is defined as:</p>  <pre id="VkQueryPoolCreateInfo" data-language="c++">typedef struct VkQueryPoolCreateInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkQueryPoolCreateFlags           flags;
    VkQueryType                      queryType;
    uint32_t                         queryCount;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkQueryPoolCreateInfo;</pre>   <h4 id="_members_82">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>queryType</code> is a <a href="#VkQueryType">VkQueryType</a> value specifying the type of queries managed by the pool. </li> <li> <code>queryCount</code> is the number of queries managed by the pool. </li> <li> <code>pipelineStatistics</code> is a bitmask of <a href="#VkQueryPipelineStatisticFlagBits">VkQueryPipelineStatisticFlagBits</a> specifying which counters will be returned in queries on the new pool, as described below in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-pipestats">html/vkspec.html#queries-pipestats</a>. </li> </ul>    <h4 id="_description_244">Description</h4>  <p><code>pipelineStatistics</code> is ignored if <code>queryType</code> is not <code>VK_QUERY_TYPE_PIPELINE_STATISTICS</code>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkQueryPoolCreateInfo-queryType-00791">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-pipelineStatisticsQuery">pipeline statistics queries</a> feature is not enabled, <code>queryType</code> <strong>must</strong> not be <code>VK_QUERY_TYPE_PIPELINE_STATISTICS</code> </li> <li id="VUID-VkQueryPoolCreateInfo-queryType-00792">  If <code>queryType</code> is <code>VK_QUERY_TYPE_PIPELINE_STATISTICS</code>, <code>pipelineStatistics</code> <strong>must</strong> be a valid combination of <a href="#VkQueryPipelineStatisticFlagBits">VkQueryPipelineStatisticFlagBits</a> values </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkQueryPoolCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO</code> </li> <li id="VUID-VkQueryPoolCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkQueryPoolCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkQueryPoolCreateInfo-queryType-parameter">  <code>queryType</code> <strong>must</strong> be a valid <a href="#VkQueryType">VkQueryType</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_244">See Also</h4>  <p><a href="#VkQueryPipelineStatisticFlags">VkQueryPipelineStatisticFlags</a>, <a href="#VkQueryPoolCreateFlags">VkQueryPoolCreateFlags</a>, <a href="#VkQueryType">VkQueryType</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateQueryPool">vkCreateQueryPool</a></p>    <h4 id="_document_notes_244">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryPoolCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryPoolCreateInfo</a></p>         <h3 id="_vkqueuefamilyproperties_3">VkQueueFamilyProperties(3)</h3>  <h4 id="_name_245">Name</h4>  <p>VkQueueFamilyProperties - Structure providing information about a queue family</p>    <h4 id="_c_specification_245">C Specification</h4>  <p>The <code>VkQueueFamilyProperties</code> structure is defined as:</p>  <pre id="VkQueueFamilyProperties" data-language="c++">typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;</pre>   <h4 id="_members_83">Members</h4>  <ul> <li> <code>queueFlags</code> is a bitmask of <a href="#VkQueueFlagBits">VkQueueFlagBits</a> indicating capabilities of the queues in this queue family. </li> <li> <code>queueCount</code> is the unsigned integer count of queues in this queue family. </li> <li> <code>timestampValidBits</code> is the unsigned integer count of meaningful bits in the timestamps written via <code>vkCmdWriteTimestamp</code>. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros. </li> <li> <code>minImageTransferGranularity</code> is the minimum granularity supported for image transfer operations on the queues in this queue family. </li> </ul>    <h4 id="_description_245">Description</h4>  <p>The value returned in <code>minImageTransferGranularity</code> has a unit of compressed texel blocks for images having a block-compressed format, and a unit of texels otherwise.</p>   <p>Possible values of <code>minImageTransferGranularity</code> are:</p>   <ul> <li> <p>(0,0,0) which indicates that only whole mip levels <strong>must</strong> be transferred using the image transfer operations on the corresponding queues. In this case, the following restrictions apply to all offset and extent parameters of image transfer operations:</p>  <ul> <li> The <code>x</code>, <code>y</code>, and <code>z</code> members of a <a href="#VkOffset3D">VkOffset3D</a> parameter <strong>must</strong> always be zero. </li> <li> The <code>width</code>, <code>height</code>, and <code>depth</code> members of a <a href="#VkExtent3D">VkExtent3D</a> parameter <strong>must</strong> always match the width, height, and depth of the image subresource corresponding to the parameter, respectively. </li> </ul>  </li> <li> <p>(A<sub>x</sub>, A<sub>y</sub>, A<sub>z</sub>) where A<sub>x</sub>, A<sub>y</sub>, and A<sub>z</sub> are all integer powers of two. In this case the following restrictions apply to all image transfer operations:</p>  <ul> <li> <code>x</code>, <code>y</code>, and <code>z</code> of a <a href="#VkOffset3D">VkOffset3D</a> parameter <strong>must</strong> be integer multiples of A<sub>x</sub>, A<sub>y</sub>, and A<sub>z</sub>, respectively. </li> <li> <code>width</code> of a <a href="#VkExtent3D">VkExtent3D</a> parameter <strong>must</strong> be an integer multiple of A<sub>x</sub>, or else <code>x</code> + <code>width</code> <strong>must</strong> equal the width of the image subresource corresponding to the parameter. </li> <li> <code>height</code> of a <a href="#VkExtent3D">VkExtent3D</a> parameter <strong>must</strong> be an integer multiple of A<sub>y</sub>, or else <code>y</code> + <code>height</code> <strong>must</strong> equal the height of the image subresource corresponding to the parameter. </li> <li> <code>depth</code> of a <a href="#VkExtent3D">VkExtent3D</a> parameter <strong>must</strong> be an integer multiple of A<sub>z</sub>, or else <code>z</code> + <code>depth</code> <strong>must</strong> equal the depth of the image subresource corresponding to the parameter. </li> <li> If the format of the image corresponding to the parameters is one of the block-compressed formats then for the purposes of the above calculations the granularity <strong>must</strong> be scaled up by the compressed texel block dimensions. </li> </ul>  </li> </ul>   <p>Queues supporting graphics and/or compute operations <strong>must</strong> report (1,1,1) in <code>minImageTransferGranularity</code>, meaning that there are no additional restrictions on the granularity of image transfer operations for these queues. Other queues supporting image transfer operations are only <strong>required</strong> to support whole mip level transfers, thus <code>minImageTransferGranularity</code> for queues belonging to such queue families <strong>may</strong> be (0,0,0).</p>   <p>The <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-device">Device Memory</a> section describes memory properties queried from the physical device.</p>   <p>For physical device feature queries see the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features">Features</a> chapter.</p>    <h4 id="_see_also_245">See Also</h4>  <p><a href="#VkExtent3D">VkExtent3D</a>, <a href="#VkQueueFlags">VkQueueFlags</a>, <a href="#vkGetPhysicalDeviceQueueFamilyProperties">vkGetPhysicalDeviceQueueFamilyProperties</a></p>    <h4 id="_document_notes_245">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueueFamilyProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueueFamilyProperties</a></p>         <h3 id="_vkrect2d_3">VkRect2D(3)</h3>  <h4 id="_name_246">Name</h4>  <p>VkRect2D - Structure specifying a two-dimensional subregion</p>    <h4 id="_c_specification_246">C Specification</h4>  <p>Rectangles are used to describe a specified rectangular region of pixels within an image or framebuffer. Rectangles include both an offset and an extent of the same dimensionality, as described above. Two-dimensional rectangles are defined by the structure</p>  <pre id="VkRect2D" data-language="c++">typedef struct VkRect2D {
    VkOffset2D    offset;
    VkExtent2D    extent;
} VkRect2D;</pre>   <h4 id="_members_84">Members</h4>  <ul> <li> <code>offset</code> is a <a href="#VkOffset2D">VkOffset2D</a> specifying the rectangle offset. </li> <li> <code>extent</code> is a <a href="#VkExtent2D">VkExtent2D</a> specifying the rectangle extent. </li> </ul>       <h4 id="_see_also_246">See Also</h4>  <p><a href="#VkClearRect">VkClearRect</a>, <a href="#VkExtent2D">VkExtent2D</a>, <a href="#VkOffset2D">VkOffset2D</a>, <a href="#VkPipelineViewportStateCreateInfo">VkPipelineViewportStateCreateInfo</a>, <a href="#VkRenderPassBeginInfo">VkRenderPassBeginInfo</a>, <a href="#vkCmdSetScissor">vkCmdSetScissor</a></p>    <h4 id="_document_notes_246">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkRect2D">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkRect2D</a></p>         <h3 id="_vkrenderpassbegininfo_3">VkRenderPassBeginInfo(3)</h3>  <h4 id="_name_247">Name</h4>  <p>VkRenderPassBeginInfo - Structure specifying render pass begin info</p>    <h4 id="_c_specification_247">C Specification</h4>  <p>The <code>VkRenderPassBeginInfo</code> structure is defined as:</p>  <pre id="VkRenderPassBeginInfo" data-language="c++">typedef struct VkRenderPassBeginInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkRenderPass           renderPass;
    VkFramebuffer          framebuffer;
    VkRect2D               renderArea;
    uint32_t               clearValueCount;
    const VkClearValue*    pClearValues;
} VkRenderPassBeginInfo;</pre>   <h4 id="_members_85">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>renderPass</code> is the render pass to begin an instance of. </li> <li> <code>framebuffer</code> is the framebuffer containing the attachments that are used with the render pass. </li> <li> <code>renderArea</code> is the render area that is affected by the render pass instance, and is described in more detail below. </li> <li> <code>clearValueCount</code> is the number of elements in <code>pClearValues</code>. </li> <li> <code>pClearValues</code> is an array of <a href="#VkClearValue">VkClearValue</a> structures that contains clear values for each attachment, if the attachment uses a <code>loadOp</code> value of <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code> or if the attachment has a depth/stencil format and uses a <code>stencilLoadOp</code> value of <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of <code>pClearValues</code> are ignored. </li> </ul>    <h4 id="_description_247">Description</h4>  <p><code>renderArea</code> is the render area that is affected by the render pass instance. The effects of attachment load, store and multisample resolve operations are restricted to the pixels whose x and y coordinates fall within the render area on all attachments. The render area extends to all layers of <code>framebuffer</code>. The application <strong>must</strong> ensure (using scissor if necessary) that all rendering is contained within the render area, otherwise the pixels outside of the render area become undefined and shader side effects <strong>may</strong> occur for fragments outside the render area. The render area <strong>must</strong> be contained within the framebuffer dimensions.</p>  <blockquote> <h5 class="title">Note</h5>  <p>There <strong>may</strong> be a performance cost for using a render area smaller than the framebuffer, unless it matches the render area granularity for the render pass.</p>  </blockquote> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkRenderPassBeginInfo-clearValueCount-00902">  <code>clearValueCount</code> <strong>must</strong> be greater than the largest attachment index in <code>renderPass</code> that specifies a <code>loadOp</code> (or <code>stencilLoadOp</code>, if the attachment has a depth/stencil format) of <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code> </li> <li id="VUID-VkRenderPassBeginInfo-clearValueCount-00903">  If <code>clearValueCount</code> is not <code>0</code>, <code>pClearValues</code> <strong>must</strong> be a pointer to an array of <code>clearValueCount</code> valid <code>VkClearValue</code> unions </li> <li id="VUID-VkRenderPassBeginInfo-renderPass-00904">  <code>renderPass</code> <strong>must</strong> be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility">compatible</a> with the <code>renderPass</code> member of the <code>VkFramebufferCreateInfo</code> structure specified when creating <code>framebuffer</code>. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkRenderPassBeginInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO</code> </li> <li id="VUID-VkRenderPassBeginInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkRenderPassBeginInfo-renderPass-parameter">  <code>renderPass</code> <strong>must</strong> be a valid <code>VkRenderPass</code> handle </li> <li id="VUID-VkRenderPassBeginInfo-framebuffer-parameter">  <code>framebuffer</code> <strong>must</strong> be a valid <code>VkFramebuffer</code> handle </li> <li id="VUID-VkRenderPassBeginInfo-commonparent">  Both of <code>framebuffer</code>, and <code>renderPass</code> <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_247">See Also</h4>  <p><a href="#VkClearValue">VkClearValue</a>, <a href="#VkFramebuffer">VkFramebuffer</a>, <a href="#VkRect2D">VkRect2D</a>, <a href="#VkRenderPass">VkRenderPass</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCmdBeginRenderPass">vkCmdBeginRenderPass</a></p>    <h4 id="_document_notes_247">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkRenderPassBeginInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkRenderPassBeginInfo</a></p>         <h3 id="_vkrenderpasscreateinfo_3">VkRenderPassCreateInfo(3)</h3>  <h4 id="_name_248">Name</h4>  <p>VkRenderPassCreateInfo - Structure specifying parameters of a newly created render pass</p>    <h4 id="_c_specification_248">C Specification</h4>  <p>The <code>VkRenderPassCreateInfo</code> structure is defined as:</p>  <pre id="VkRenderPassCreateInfo" data-language="c++">typedef struct VkRenderPassCreateInfo {
    VkStructureType                   sType;
    const void*                       pNext;
    VkRenderPassCreateFlags           flags;
    uint32_t                          attachmentCount;
    const VkAttachmentDescription*    pAttachments;
    uint32_t                          subpassCount;
    const VkSubpassDescription*       pSubpasses;
    uint32_t                          dependencyCount;
    const VkSubpassDependency*        pDependencies;
} VkRenderPassCreateInfo;</pre>   <h4 id="_members_86">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>attachmentCount</code> is the number of attachments used by this render pass, or zero indicating no attachments. Attachments are referred to by zero-based indices in the range [0,<code>attachmentCount</code>). </li> <li> <code>pAttachments</code> points to an array of <code>attachmentCount</code> number of <a href="#VkAttachmentDescription">VkAttachmentDescription</a> structures describing properties of the attachments, or <code>NULL</code> if <code>attachmentCount</code> is zero. </li> <li> <code>subpassCount</code> is the number of subpasses to create for this render pass. Subpasses are referred to by zero-based indices in the range [0,<code>subpassCount</code>). A render pass <strong>must</strong> have at least one subpass. </li> <li> <code>pSubpasses</code> points to an array of <code>subpassCount</code> number of <a href="#VkSubpassDescription">VkSubpassDescription</a> structures describing properties of the subpasses. </li> <li> <code>dependencyCount</code> is the number of dependencies between pairs of subpasses, or zero indicating no dependencies. </li> <li> <code>pDependencies</code> points to an array of <code>dependencyCount</code> number of <a href="#VkSubpassDependency">VkSubpassDependency</a> structures describing dependencies between pairs of subpasses, or <code>NULL</code> if <code>dependencyCount</code> is zero. </li> </ul>    <h4 id="_description_248">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkRenderPassCreateInfo-None-00832">  If any two subpasses operate on attachments with overlapping ranges of the same <code>VkDeviceMemory</code> object, and at least one subpass writes to that area of <code>VkDeviceMemory</code>, a subpass dependency <strong>must</strong> be included (either directly or via some intermediate subpasses) between them </li> <li id="VUID-VkRenderPassCreateInfo-attachment-00833">  If the <code>attachment</code> member of any element of <code>pInputAttachments</code>, <code>pColorAttachments</code>, <code>pResolveAttachments</code> or <code>pDepthStencilAttachment</code>, or the attachment indexed by any element of <code>pPreserveAttachments</code> in any given element of <code>pSubpasses</code> is bound to a range of a <code>VkDeviceMemory</code> object that overlaps with any other attachment in any subpass (including the same subpass), the <code>VkAttachmentDescription</code> structures describing them <strong>must</strong> include <code>VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT</code> in <code>flags</code> </li> <li id="VUID-VkRenderPassCreateInfo-attachment-00834">  If the <code>attachment</code> member of any element of <code>pInputAttachments</code>, <code>pColorAttachments</code>, <code>pResolveAttachments</code> or <code>pDepthStencilAttachment</code>, or any element of <code>pPreserveAttachments</code> in any given element of <code>pSubpasses</code> is not <code>VK_ATTACHMENT_UNUSED</code>, it <strong>must</strong> be less than <code>attachmentCount</code> </li> <li id="VUID-VkRenderPassCreateInfo-pPreserveAttachments-00835">  The value of any element of the <code>pPreserveAttachments</code> member in any given element of <code>pSubpasses</code> <strong>must</strong> not be <code>VK_ATTACHMENT_UNUSED</code> </li> <li id="VUID-VkRenderPassCreateInfo-pAttachments-00836">  For any member of <code>pAttachments</code> with a <code>loadOp</code> equal to <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>, the first use of that attachment <strong>must</strong> not specify a <code>layout</code> equal to <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code>. </li> <li id="VUID-VkRenderPassCreateInfo-pDependencies-00837">  For any element of <code>pDependencies</code>, if the <code>srcSubpass</code> is not <code>VK_SUBPASS_EXTERNAL</code>, all stage flags included in the <code>srcStageMask</code> member of that dependency <strong>must</strong> be a pipeline stage supported by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-types">pipeline</a> identified by the <code>pipelineBindPoint</code> member of the source subpass. </li> <li id="VUID-VkRenderPassCreateInfo-pDependencies-00838">  For any element of <code>pDependencies</code>, if the <code>dstSubpass</code> is not <code>VK_SUBPASS_EXTERNAL</code>, all stage flags included in the <code>dstStageMask</code> member of that dependency <strong>must</strong> be a pipeline stage supported by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-types">pipeline</a> identified by the <code>pipelineBindPoint</code> member of the source subpass. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkRenderPassCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO</code> </li> <li id="VUID-VkRenderPassCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkRenderPassCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkRenderPassCreateInfo-pAttachments-parameter">  If <code>attachmentCount</code> is not <code>0</code>, <code>pAttachments</code> <strong>must</strong> be a pointer to an array of <code>attachmentCount</code> valid <code>VkAttachmentDescription</code> structures </li> <li id="VUID-VkRenderPassCreateInfo-pSubpasses-parameter">  <code>pSubpasses</code> <strong>must</strong> be a pointer to an array of <code>subpassCount</code> valid <code>VkSubpassDescription</code> structures </li> <li id="VUID-VkRenderPassCreateInfo-pDependencies-parameter">  If <code>dependencyCount</code> is not <code>0</code>, <code>pDependencies</code> <strong>must</strong> be a pointer to an array of <code>dependencyCount</code> valid <code>VkSubpassDependency</code> structures </li> <li id="VUID-VkRenderPassCreateInfo-subpassCount-arraylength">  <code>subpassCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_248">See Also</h4>  <p><a href="#VkAttachmentDescription">VkAttachmentDescription</a>, <a href="#VkRenderPassCreateFlags">VkRenderPassCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#VkSubpassDependency">VkSubpassDependency</a>, <a href="#VkSubpassDescription">VkSubpassDescription</a>, <a href="#vkCreateRenderPass">vkCreateRenderPass</a></p>    <h4 id="_document_notes_248">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkRenderPassCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkRenderPassCreateInfo</a></p>         <h3 id="_vksamplercreateinfo_3">VkSamplerCreateInfo(3)</h3>  <h4 id="_name_249">Name</h4>  <p>VkSamplerCreateInfo - Structure specifying parameters of a newly created sampler</p>    <h4 id="_c_specification_249">C Specification</h4>  <p>The <code>VkSamplerCreateInfo</code> structure is defined as:</p>  <pre id="VkSamplerCreateInfo" data-language="c++">typedef struct VkSamplerCreateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkSamplerCreateFlags    flags;
    VkFilter                magFilter;
    VkFilter                minFilter;
    VkSamplerMipmapMode     mipmapMode;
    VkSamplerAddressMode    addressModeU;
    VkSamplerAddressMode    addressModeV;
    VkSamplerAddressMode    addressModeW;
    float                   mipLodBias;
    VkBool32                anisotropyEnable;
    float                   maxAnisotropy;
    VkBool32                compareEnable;
    VkCompareOp             compareOp;
    float                   minLod;
    float                   maxLod;
    VkBorderColor           borderColor;
    VkBool32                unnormalizedCoordinates;
} VkSamplerCreateInfo;</pre>   <h4 id="_members_87">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>magFilter</code> is a <a href="#VkFilter">VkFilter</a> value specifying the magnification filter to apply to lookups. </li> <li> <code>minFilter</code> is a <a href="#VkFilter">VkFilter</a> value specifying the minification filter to apply to lookups. </li> <li> <code>mipmapMode</code> is a <a href="#VkSamplerMipmapMode">VkSamplerMipmapMode</a> value specifying the mipmap filter to apply to lookups. </li> <li> <code>addressModeU</code> is a <a href="#VkSamplerAddressMode">VkSamplerAddressMode</a> value specifying the addressing mode for outside [0..1] range for U coordinate. </li> <li> <code>addressModeV</code> is a <a href="#VkSamplerAddressMode">VkSamplerAddressMode</a> value specifying the addressing mode for outside [0..1] range for V coordinate. </li> <li> <code>addressModeW</code> is a <a href="#VkSamplerAddressMode">VkSamplerAddressMode</a> value specifying the addressing mode for outside [0..1] range for W coordinate. </li> <li id="samplers-mipLodBias">  <code>mipLodBias</code> is the bias to be added to mipmap LOD calculation and bias provided by image sampling functions in SPIR-V, as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-level-of-detail-operation">Level-of-Detail Operation</a> section. </li> <li id="samplers-maxAnisotropy">  <code>anisotropyEnable</code> is <code>VK_TRUE</code> to enable anisotropic filtering, as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-anisotropic-filtering">Texel Anisotropic Filtering</a> section, or <code>VK_FALSE</code> otherwise. </li> <li> <code>maxAnisotropy</code> is the anisotropy value clamp. </li> <li> <p><code>compareEnable</code> is <code>VK_TRUE</code> to enable comparison against a reference value during lookups, or <code>VK_FALSE</code> otherwise.</p>  <ul> <li> Note: Some implementations will default to shader state if this member does not match. </li> </ul>  </li> <li> <code>compareOp</code> is a <a href="#VkCompareOp">VkCompareOp</a> value specifying the comparison function to apply to fetched data before filtering as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-depth-compare-operation">Depth Compare Operation</a> section. </li> <li> <code>minLod</code> and <code>maxLod</code> are the values used to clamp the computed level-of-detail value, as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-level-of-detail-operation">Level-of-Detail Operation</a> section. <code>maxLod</code> <strong>must</strong> be greater than or equal to <code>minLod</code>. </li> <li> <code>borderColor</code> is a <a href="#VkBorderColor">VkBorderColor</a> value specifying the predefined border color to use. </li> <li> <p id="samplers-unnormalizedCoordinates"> <code>unnormalizedCoordinates</code> controls whether to use unnormalized or normalized texel coordinates to address texels of the image. When set to <code>VK_TRUE</code>, the range of the image coordinates used to lookup the texel is in the range of zero to the image dimensions for x, y and z. When set to <code>VK_FALSE</code> the range of image coordinates is zero to one. When <code>unnormalizedCoordinates</code> is <code>VK_TRUE</code>, samplers have the following requirements:</p>  <ul> <li> <code>minFilter</code> and <code>magFilter</code> <strong>must</strong> be equal. </li> <li> <code>mipmapMode</code> <strong>must</strong> be <code>VK_SAMPLER_MIPMAP_MODE_NEAREST</code>. </li> <li> <code>minLod</code> and <code>maxLod</code> <strong>must</strong> be zero. </li> <li> <code>addressModeU</code> and <code>addressModeV</code> <strong>must</strong> each be either <code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</code> or <code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</code>. </li> <li> <code>anisotropyEnable</code> <strong>must</strong> be <code>VK_FALSE</code>. </li> <li> <code>compareEnable</code> <strong>must</strong> be <code>VK_FALSE</code>. </li> </ul>  </li> <li> <p>When <code>unnormalizedCoordinates</code> is <code>VK_TRUE</code>, images the sampler is used with in the shader have the following requirements:</p>  <ul> <li> The <code>viewType</code> <strong>must</strong> be either <code>VK_IMAGE_VIEW_TYPE_1D</code> or <code>VK_IMAGE_VIEW_TYPE_2D</code>. </li> <li> The image view <strong>must</strong> have a single layer and a single mip level. </li> </ul>  </li> <li> <p>When <code>unnormalizedCoordinates</code> is <code>VK_TRUE</code>, image built-in functions in the shader that use the sampler have the following requirements:</p>  <ul> <li> The functions <strong>must</strong> not use projection. </li> <li> The functions <strong>must</strong> not use offsets. </li> </ul>  </li> </ul>    <h4 id="_description_249">Description</h4> <blockquote> <h5 class="title">Mapping of OpenGL to Vulkan filter modes</h5>  <p><code>magFilter</code> values of <code>VK_FILTER_NEAREST</code> and <code>VK_FILTER_LINEAR</code> directly correspond to <code>GL_NEAREST</code> and <code>GL_LINEAR</code> magnification filters. <code>minFilter</code> and <code>mipmapMode</code> combine to correspond to the similarly named OpenGL minification filter of <code>GL_minFilter_MIPMAP_mipmapMode</code> (e.g. <code>minFilter</code> of <code>VK_FILTER_LINEAR</code> and <code>mipmapMode</code> of <code>VK_SAMPLER_MIPMAP_MODE_NEAREST</code> correspond to <code>GL_LINEAR_MIPMAP_NEAREST</code>).</p>   <p>There are no Vulkan filter modes that directly correspond to OpenGL minification filters of <code>GL_LINEAR</code> or <code>GL_NEAREST</code>, but they <strong>can</strong> be emulated using <code>VK_SAMPLER_MIPMAP_MODE_NEAREST</code>, <code>minLod</code> = 0, and <code>maxLod</code> = 0.25, and using <code>minFilter</code> = <code>VK_FILTER_LINEAR</code> or <code>minFilter</code> = <code>VK_FILTER_NEAREST</code>, respectively.</p>   <p>Note that using a <code>maxLod</code> of zero would cause <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-filtering">magnification</a> to always be performed, and the <code>magFilter</code> to always be used. This is valid, just not an exact match for OpenGL behavior. Clamping the maximum LOD to 0.25 allows the λ value to be non-zero and minification to be performed, while still always rounding down to the base level. If the <code>minFilter</code> and <code>magFilter</code> are equal, then using a <code>maxLod</code> of zero also works.</p>  </blockquote>  <p>The maximum number of sampler objects which <strong>can</strong> be simultaneously created on a device is implementation-dependent and specified by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxSamplerAllocationCount"><code>maxSamplerAllocationCount</code></a> member of the <a href="#VkPhysicalDeviceLimits">VkPhysicalDeviceLimits</a> structure. If <code>maxSamplerAllocationCount</code> is exceeded, <code>vkCreateSampler</code> will return <code>VK_ERROR_TOO_MANY_OBJECTS</code>.</p>   <p>Since <a href="#VkSampler">VkSampler</a> is a non-dispatchable handle type, implementations <strong>may</strong> return the same handle for sampler state vectors that are identical. In such cases, all such objects would only count once against the <code>maxSamplerAllocationCount</code> limit.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkSamplerCreateInfo-mipLodBias-01069">  The absolute value of <code>mipLodBias</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxSamplerLodBias</code> </li> <li id="VUID-VkSamplerCreateInfo-anisotropyEnable-01070">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-samplerAnisotropy">anisotropic sampling</a> feature is not enabled, <code>anisotropyEnable</code> <strong>must</strong> be <code>VK_FALSE</code> </li> <li id="VUID-VkSamplerCreateInfo-anisotropyEnable-01071">  If <code>anisotropyEnable</code> is <code>VK_TRUE</code>, <code>maxAnisotropy</code> <strong>must</strong> be between <code>1.0</code> and <code>VkPhysicalDeviceLimits</code>::<code>maxSamplerAnisotropy</code>, inclusive </li> <li id="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01072">  If <code>unnormalizedCoordinates</code> is <code>VK_TRUE</code>, <code>minFilter</code> and <code>magFilter</code> <strong>must</strong> be equal </li> <li id="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01073">  If <code>unnormalizedCoordinates</code> is <code>VK_TRUE</code>, <code>mipmapMode</code> <strong>must</strong> be <code>VK_SAMPLER_MIPMAP_MODE_NEAREST</code> </li> <li id="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01074">  If <code>unnormalizedCoordinates</code> is <code>VK_TRUE</code>, <code>minLod</code> and <code>maxLod</code> <strong>must</strong> be zero </li> <li id="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01075">  If <code>unnormalizedCoordinates</code> is <code>VK_TRUE</code>, <code>addressModeU</code> and <code>addressModeV</code> <strong>must</strong> each be either <code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</code> or <code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</code> </li> <li id="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01076">  If <code>unnormalizedCoordinates</code> is <code>VK_TRUE</code>, <code>anisotropyEnable</code> <strong>must</strong> be <code>VK_FALSE</code> </li> <li id="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01077">  If <code>unnormalizedCoordinates</code> is <code>VK_TRUE</code>, <code>compareEnable</code> <strong>must</strong> be <code>VK_FALSE</code> </li> <li id="VUID-VkSamplerCreateInfo-addressModeU-01078">  If any of <code>addressModeU</code>, <code>addressModeV</code> or <code>addressModeW</code> are <code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</code>, <code>borderColor</code> <strong>must</strong> be a valid <a href="#VkBorderColor">VkBorderColor</a> value </li> <li id="VUID-VkSamplerCreateInfo-addressModeU-01079">  If the VK_KHR_sampler_mirror_clamp_to_edge extension is not enabled, <code>addressModeU</code>, <code>addressModeV</code> and <code>addressModeW</code> <strong>must</strong> not be <code>VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE</code> </li> <li id="VUID-VkSamplerCreateInfo-compareEnable-01080">  If <code>compareEnable</code> is <code>VK_TRUE</code>, <code>compareOp</code> <strong>must</strong> be a valid <a href="#VkCompareOp">VkCompareOp</a> value </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSamplerCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO</code> </li> <li id="VUID-VkSamplerCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkSamplerCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkSamplerCreateInfo-magFilter-parameter">  <code>magFilter</code> <strong>must</strong> be a valid <a href="#VkFilter">VkFilter</a> value </li> <li id="VUID-VkSamplerCreateInfo-minFilter-parameter">  <code>minFilter</code> <strong>must</strong> be a valid <a href="#VkFilter">VkFilter</a> value </li> <li id="VUID-VkSamplerCreateInfo-mipmapMode-parameter">  <code>mipmapMode</code> <strong>must</strong> be a valid <a href="#VkSamplerMipmapMode">VkSamplerMipmapMode</a> value </li> <li id="VUID-VkSamplerCreateInfo-addressModeU-parameter">  <code>addressModeU</code> <strong>must</strong> be a valid <a href="#VkSamplerAddressMode">VkSamplerAddressMode</a> value </li> <li id="VUID-VkSamplerCreateInfo-addressModeV-parameter">  <code>addressModeV</code> <strong>must</strong> be a valid <a href="#VkSamplerAddressMode">VkSamplerAddressMode</a> value </li> <li id="VUID-VkSamplerCreateInfo-addressModeW-parameter">  <code>addressModeW</code> <strong>must</strong> be a valid <a href="#VkSamplerAddressMode">VkSamplerAddressMode</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_249">See Also</h4>  <p><code>VkBool32</code>, <a href="#VkBorderColor">VkBorderColor</a>, <a href="#VkCompareOp">VkCompareOp</a>, <a href="#VkFilter">VkFilter</a>, <a href="#VkSamplerAddressMode">VkSamplerAddressMode</a>, <a href="#VkSamplerCreateFlags">VkSamplerCreateFlags</a>, <a href="#VkSamplerMipmapMode">VkSamplerMipmapMode</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateSampler">vkCreateSampler</a></p>    <h4 id="_document_notes_249">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSamplerCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSamplerCreateInfo</a></p>         <h3 id="_vksemaphorecreateinfo_3">VkSemaphoreCreateInfo(3)</h3>  <h4 id="_name_250">Name</h4>  <p>VkSemaphoreCreateInfo - Structure specifying parameters of a newly created semaphore</p>    <h4 id="_c_specification_250">C Specification</h4>  <p>The <code>VkSemaphoreCreateInfo</code> structure is defined as:</p>  <pre id="VkSemaphoreCreateInfo" data-language="c++">typedef struct VkSemaphoreCreateInfo {
    VkStructureType           sType;
    const void*               pNext;
    VkSemaphoreCreateFlags    flags;
} VkSemaphoreCreateInfo;</pre>   <h4 id="_members_88">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> </ul>    <h4 id="_description_250">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSemaphoreCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO</code> </li> <li id="VUID-VkSemaphoreCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkSemaphoreCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_250">See Also</h4>  <p><a href="#VkSemaphoreCreateFlags">VkSemaphoreCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateSemaphore">vkCreateSemaphore</a></p>    <h4 id="_document_notes_250">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSemaphoreCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSemaphoreCreateInfo</a></p>         <h3 id="_vkshadermodulecreateinfo_3">VkShaderModuleCreateInfo(3)</h3>  <h4 id="_name_251">Name</h4>  <p>VkShaderModuleCreateInfo - Structure specifying parameters of a newly created shader module</p>    <h4 id="_c_specification_251">C Specification</h4>  <p>The <code>VkShaderModuleCreateInfo</code> structure is defined as:</p>  <pre id="VkShaderModuleCreateInfo" data-language="c++">typedef struct VkShaderModuleCreateInfo {
    VkStructureType              sType;
    const void*                  pNext;
    VkShaderModuleCreateFlags    flags;
    size_t                       codeSize;
    const uint32_t*              pCode;
} VkShaderModuleCreateInfo;</pre>   <h4 id="_members_89">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>flags</code> is reserved for future use. </li> <li> <code>codeSize</code> is the size, in bytes, of the code pointed to by <code>pCode</code>. </li> <li> <code>pCode</code> points to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by <code>pCode</code>. </li> </ul>    <h4 id="_description_251">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkShaderModuleCreateInfo-codeSize-01085">  <code>codeSize</code> <strong>must</strong> be greater than 0 </li> <li id="VUID-VkShaderModuleCreateInfo-codeSize-01086">  <code>codeSize</code> <strong>must</strong> be a multiple of 4 </li> <li id="VUID-VkShaderModuleCreateInfo-pCode-01087">  <code>pCode</code> <strong>must</strong> point to valid SPIR-V code, formatted and packed as described by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirv-spec">Khronos SPIR-V Specification</a> </li> <li id="VUID-VkShaderModuleCreateInfo-pCode-01088">  <code>pCode</code> <strong>must</strong> adhere to the validation rules described by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-module-validation">Validation Rules within a Module</a> section of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-capabilities">SPIR-V Environment</a> appendix </li> <li id="VUID-VkShaderModuleCreateInfo-pCode-01089">  <code>pCode</code> <strong>must</strong> declare the <code>Shader</code> capability for SPIR-V code </li> <li id="VUID-VkShaderModuleCreateInfo-pCode-01090">  <code>pCode</code> <strong>must</strong> not declare any capability that is not supported by the API, as described by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-module-validation">Capabilities</a> section of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-capabilities">SPIR-V Environment</a> appendix </li> <li id="VUID-VkShaderModuleCreateInfo-pCode-01091">  If <code>pCode</code> declares any of the capabilities that are listed as not required by the implementation, the relevant feature <strong>must</strong> be enabled, as listed in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-capabilities-table">SPIR-V Environment</a> appendix </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkShaderModuleCreateInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO</code> </li> <li id="VUID-VkShaderModuleCreateInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkShaderModuleCreateInfo-flags-zerobitmask">  <code>flags</code> <strong>must</strong> be <code>0</code> </li> <li id="VUID-VkShaderModuleCreateInfo-pCode-parameter">  <code>pCode</code> <strong>must</strong> be a pointer to an array of \(codeSize \over 4\) <code>uint32_t</code> values </li> </ul>   </blockquote>   <h4 id="_see_also_251">See Also</h4>  <p><a href="#VkShaderModuleCreateFlags">VkShaderModuleCreateFlags</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkCreateShaderModule">vkCreateShaderModule</a></p>    <h4 id="_document_notes_251">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkShaderModuleCreateInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkShaderModuleCreateInfo</a></p>         <h3 id="_vksparsebuffermemorybindinfo_3">VkSparseBufferMemoryBindInfo(3)</h3>  <h4 id="_name_252">Name</h4>  <p>VkSparseBufferMemoryBindInfo - Structure specifying a sparse buffer memory bind operation</p>    <h4 id="_c_specification_252">C Specification</h4>  <p>Memory is bound to <code>VkBuffer</code> objects created with the <code>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</code> flag using the following structure:</p>  <pre id="VkSparseBufferMemoryBindInfo" data-language="c++">typedef struct VkSparseBufferMemoryBindInfo {
    VkBuffer                     buffer;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseBufferMemoryBindInfo;</pre>   <h4 id="_members_90">Members</h4>  <ul> <li> <code>buffer</code> is the <code>VkBuffer</code> object to be bound. </li> <li> <code>bindCount</code> is the number of <code>VkSparseMemoryBind</code> structures in the <code>pBinds</code> array. </li> <li> <code>pBinds</code> is a pointer to array of <code>VkSparseMemoryBind</code> structures. </li> </ul>    <h4 id="_description_252">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSparseBufferMemoryBindInfo-buffer-parameter">  <code>buffer</code> <strong>must</strong> be a valid <code>VkBuffer</code> handle </li> <li id="VUID-VkSparseBufferMemoryBindInfo-pBinds-parameter">  <code>pBinds</code> <strong>must</strong> be a pointer to an array of <code>bindCount</code> valid <code>VkSparseMemoryBind</code> structures </li> <li id="VUID-VkSparseBufferMemoryBindInfo-bindCount-arraylength">  <code>bindCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_252">See Also</h4>  <p><a href="#VkBindSparseInfo">VkBindSparseInfo</a>, <a href="#VkBuffer">VkBuffer</a>, <a href="#VkSparseMemoryBind">VkSparseMemoryBind</a></p>    <h4 id="_document_notes_252">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseBufferMemoryBindInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseBufferMemoryBindInfo</a></p>         <h3 id="_vksparseimageformatproperties_3">VkSparseImageFormatProperties(3)</h3>  <h4 id="_name_253">Name</h4>  <p>VkSparseImageFormatProperties - Structure specifying sparse image format properties</p>    <h4 id="_c_specification_253">C Specification</h4>  <p>The <code>VkSparseImageFormatProperties</code> structure is defined as:</p>  <pre id="VkSparseImageFormatProperties" data-language="c++">typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags          aspectMask;
    VkExtent3D                  imageGranularity;
    VkSparseImageFormatFlags    flags;
} VkSparseImageFormatProperties;</pre>   <h4 id="_members_91">Members</h4>  <ul> <li> <code>aspectMask</code> is a bitmask <a href="#VkImageAspectFlagBits">VkImageAspectFlagBits</a> specifying which aspects of the image the properties apply to. </li> <li> <code>imageGranularity</code> is the width, height, and depth of the sparse image block in texels or compressed texel blocks. </li> <li> <code>flags</code> is a bitmask of <a href="#VkSparseImageFormatFlagBits">VkSparseImageFormatFlagBits</a> specifying additional information about the sparse resource. </li> </ul>       <h4 id="_see_also_253">See Also</h4>  <p><a href="#VkExtent3D">VkExtent3D</a>, <a href="#VkImageAspectFlags">VkImageAspectFlags</a>, <a href="#VkSparseImageFormatFlags">VkSparseImageFormatFlags</a>, <a href="#VkSparseImageMemoryRequirements">VkSparseImageMemoryRequirements</a>, <a href="#vkGetPhysicalDeviceSparseImageFormatProperties">vkGetPhysicalDeviceSparseImageFormatProperties</a></p>    <h4 id="_document_notes_253">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageFormatProperties">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageFormatProperties</a></p>         <h3 id="_vksparseimagememorybind_3">VkSparseImageMemoryBind(3)</h3>  <h4 id="_name_254">Name</h4>  <p>VkSparseImageMemoryBind - Structure specifying sparse image memory bind</p>    <h4 id="_c_specification_254">C Specification</h4>  <p>The <code>VkSparseImageMemoryBind</code> structure is defined as:</p>  <pre id="VkSparseImageMemoryBind" data-language="c++">typedef struct VkSparseImageMemoryBind {
    VkImageSubresource         subresource;
    VkOffset3D                 offset;
    VkExtent3D                 extent;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseImageMemoryBind;</pre>   <h4 id="_members_92">Members</h4>  <ul> <li> <code>subresource</code> is the aspectMask and region of interest in the image. </li> <li> <code>offset</code> are the coordinates of the first texel within the image subresource to bind. </li> <li> <code>extent</code> is the size in texels of the region within the image subresource to bind. The extent <strong>must</strong> be a multiple of the sparse image block dimensions, except when binding sparse image blocks along the edge of an image subresource it <strong>can</strong> instead be such that any coordinate of <code>offset</code> + <code>extent</code> equals the corresponding dimensions of the image subresource. </li> <li> <code>memory</code> is the <code>VkDeviceMemory</code> object that the sparse image blocks of the image are bound to. If <code>memory</code> is <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, the sparse image blocks are unbound. </li> <li> <code>memoryOffset</code> is an offset into <code>VkDeviceMemory</code> object. If <code>memory</code> is <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, this value is ignored. </li> <li> <code>flags</code> are sparse memory binding flags. </li> </ul>    <h4 id="_description_254">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkSparseImageMemoryBind-memory-01104">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyAliased">sparse aliased residency</a> feature is not enabled, and if any other resources are bound to ranges of <code>memory</code>, the range of <code>memory</code> being bound <strong>must</strong> not overlap with those bound ranges </li> <li id="VUID-VkSparseImageMemoryBind-memory-01105">  <code>memory</code> and <code>memoryOffset</code> <strong>must</strong> match the memory requirements of the calling command’s <code>image</code>, as described in section <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-association">html/vkspec.html#resources-association</a> </li> <li id="VUID-VkSparseImageMemoryBind-subresource-01106">  <code>subresource</code> <strong>must</strong> be a valid image subresource for <code>image</code> (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views">html/vkspec.html#resources-image-views</a>) </li> <li id="VUID-VkSparseImageMemoryBind-offset-01107">  <code>offset.x</code> <strong>must</strong> be a multiple of the sparse image block width (<code>VkSparseImageFormatProperties</code>::<code>imageGranularity.width</code>) of the image </li> <li id="VUID-VkSparseImageMemoryBind-extent-01108">  <code>extent.width</code> <strong>must</strong> either be a multiple of the sparse image block width of the image, or else (<code>extent.width</code> + <code>offset.x</code>) <strong>must</strong> equal the width of the image subresource </li> <li id="VUID-VkSparseImageMemoryBind-offset-01109">  <code>offset.y</code> <strong>must</strong> be a multiple of the sparse image block height (<code>VkSparseImageFormatProperties</code>::<code>imageGranularity.height</code>) of the image </li> <li id="VUID-VkSparseImageMemoryBind-extent-01110">  <code>extent.height</code> <strong>must</strong> either be a multiple of the sparse image block height of the image, or else (<code>extent.height</code> + <code>offset.y</code>) <strong>must</strong> equal the height of the image subresource </li> <li id="VUID-VkSparseImageMemoryBind-offset-01111">  <code>offset.z</code> <strong>must</strong> be a multiple of the sparse image block depth (<code>VkSparseImageFormatProperties</code>::<code>imageGranularity.depth</code>) of the image </li> <li id="VUID-VkSparseImageMemoryBind-extent-01112">  <code>extent.depth</code> <strong>must</strong> either be a multiple of the sparse image block depth of the image, or else (<code>extent.depth</code> + <code>offset.z</code>) <strong>must</strong> equal the depth of the image subresource </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSparseImageMemoryBind-subresource-parameter">  <code>subresource</code> <strong>must</strong> be a valid <code>VkImageSubresource</code> structure </li> <li id="VUID-VkSparseImageMemoryBind-memory-parameter">  If <code>memory</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>memory</code> <strong>must</strong> be a valid <code>VkDeviceMemory</code> handle </li> <li id="VUID-VkSparseImageMemoryBind-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkSparseMemoryBindFlagBits">VkSparseMemoryBindFlagBits</a> values </li> </ul>   </blockquote>   <h4 id="_see_also_254">See Also</h4>  <p><a href="#VkDeviceMemory">VkDeviceMemory</a>, <code>VkDeviceSize</code>, <a href="#VkExtent3D">VkExtent3D</a>, <a href="#VkImageSubresource">VkImageSubresource</a>, <a href="#VkOffset3D">VkOffset3D</a>, <a href="#VkSparseImageMemoryBindInfo">VkSparseImageMemoryBindInfo</a>, <a href="#VkSparseMemoryBindFlags">VkSparseMemoryBindFlags</a></p>    <h4 id="_document_notes_254">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageMemoryBind">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageMemoryBind</a></p>         <h3 id="_vksparseimagememorybindinfo_3">VkSparseImageMemoryBindInfo(3)</h3>  <h4 id="_name_255">Name</h4>  <p>VkSparseImageMemoryBindInfo - Structure specifying sparse image memory bind info</p>    <h4 id="_c_specification_255">C Specification</h4>  <p>Memory <strong>can</strong> be bound to sparse image blocks of <code>VkImage</code> objects created with the <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> flag using the following structure:</p>  <pre id="VkSparseImageMemoryBindInfo" data-language="c++">typedef struct VkSparseImageMemoryBindInfo {
    VkImage                           image;
    uint32_t                          bindCount;
    const VkSparseImageMemoryBind*    pBinds;
} VkSparseImageMemoryBindInfo;</pre>   <h4 id="_members_93">Members</h4>  <ul> <li> <code>image</code> is the <code>VkImage</code> object to be bound </li> <li> <code>bindCount</code> is the number of <code>VkSparseImageMemoryBind</code> structures in pBinds array </li> <li> <code>pBinds</code> is a pointer to array of <code>VkSparseImageMemoryBind</code> structures </li> </ul>    <h4 id="_description_255">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSparseImageMemoryBindInfo-image-parameter">  <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-VkSparseImageMemoryBindInfo-pBinds-parameter">  <code>pBinds</code> <strong>must</strong> be a pointer to an array of <code>bindCount</code> valid <code>VkSparseImageMemoryBind</code> structures </li> <li id="VUID-VkSparseImageMemoryBindInfo-bindCount-arraylength">  <code>bindCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_255">See Also</h4>  <p><a href="#VkBindSparseInfo">VkBindSparseInfo</a>, <a href="#VkImage">VkImage</a>, <a href="#VkSparseImageMemoryBind">VkSparseImageMemoryBind</a></p>    <h4 id="_document_notes_255">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageMemoryBindInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageMemoryBindInfo</a></p>         <h3 id="_vksparseimagememoryrequirements_3">VkSparseImageMemoryRequirements(3)</h3>  <h4 id="_name_256">Name</h4>  <p>VkSparseImageMemoryRequirements - Structure specifying sparse image memory requirements</p>    <h4 id="_c_specification_256">C Specification</h4>  <p>The <code>VkSparseImageMemoryRequirements</code> structure is defined as:</p>  <pre id="VkSparseImageMemoryRequirements" data-language="c++">typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties    formatProperties;
    uint32_t                         imageMipTailFirstLod;
    VkDeviceSize                     imageMipTailSize;
    VkDeviceSize                     imageMipTailOffset;
    VkDeviceSize                     imageMipTailStride;
} VkSparseImageMemoryRequirements;</pre>   <h4 id="_members_94">Members</h4>  <ul> <li> <code>formatProperties.aspectMask</code> is the set of aspects of the image that this sparse memory requirement applies to. This will usually have a single aspect specified. However, depth/stencil images <strong>may</strong> have depth and stencil data interleaved in the same sparse block, in which case both <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> and <code>VK_IMAGE_ASPECT_STENCIL_BIT</code> would be present. </li> <li> <code>formatProperties.imageGranularity</code> describes the dimensions of a single bindable sparse image block in pixel units. For aspect <code>VK_IMAGE_ASPECT_METADATA_BIT</code>, all dimensions will be zero pixels. All metadata is located in the mip tail region. </li> <li> <p><code>formatProperties.flags</code> is a bitmask of <a href="#VkSparseImageFormatFlagBits">VkSparseImageFormatFlagBits</a>:</p>  <ul> <li> If <code>VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT</code> is set the image uses a single mip tail region for all array layers. </li> <li> If <code>VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT</code> is set the dimensions of mip levels <strong>must</strong> be integer multiples of the corresponding dimensions of the sparse image block for levels not located in the mip tail. </li> <li> If <code>VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT</code> is set the image uses non-standard sparse image block dimensions. The <code>formatProperties.imageGranularity</code> values do not match the standard sparse image block dimension corresponding to the image’s pixel format. </li> </ul>  </li> <li> <code>imageMipTailFirstLod</code> is the first mip level at which image subresources are included in the mip tail region. </li> <li> <code>imageMipTailSize</code> is the memory size (in bytes) of the mip tail region. If <code>formatProperties.flags</code> contains <code>VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT</code>, this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes. </li> <li> <code>imageMipTailOffset</code> is the opaque memory offset used with <a href="#VkSparseImageOpaqueMemoryBindInfo">VkSparseImageOpaqueMemoryBindInfo</a> to bind the mip tail region(s). </li> <li> <code>imageMipTailStride</code> is the offset stride between each array-layer’s mip tail, if <code>formatProperties.flags</code> does not contain <code>VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT</code> (otherwise the value is undefined). </li> </ul>       <h4 id="_see_also_256">See Also</h4>  <p><code>VkDeviceSize</code>, <a href="#VkSparseImageFormatProperties">VkSparseImageFormatProperties</a>, <a href="#vkGetImageSparseMemoryRequirements">vkGetImageSparseMemoryRequirements</a></p>    <h4 id="_document_notes_256">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageMemoryRequirements">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageMemoryRequirements</a></p>         <h3 id="_vksparseimageopaquememorybindinfo_3">VkSparseImageOpaqueMemoryBindInfo(3)</h3>  <h4 id="_name_257">Name</h4>  <p>VkSparseImageOpaqueMemoryBindInfo - Structure specifying sparse image opaque memory bind info</p>    <h4 id="_c_specification_257">C Specification</h4>  <p>Memory is bound to opaque regions of <code>VkImage</code> objects created with the <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code> flag using the following structure:</p>  <pre id="VkSparseImageOpaqueMemoryBindInfo" data-language="c++">typedef struct VkSparseImageOpaqueMemoryBindInfo {
    VkImage                      image;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseImageOpaqueMemoryBindInfo;</pre>   <h4 id="_members_95">Members</h4>  <ul> <li> <code>image</code> is the <code>VkImage</code> object to be bound. </li> <li> <code>bindCount</code> is the number of <code>VkSparseMemoryBind</code> structures in the <code>pBinds</code> array. </li> <li> <code>pBinds</code> is a pointer to array of <code>VkSparseMemoryBind</code> structures. </li> </ul>    <h4 id="_description_257">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-01103">  For any given element of <code>pBinds</code>, if the <code>flags</code> member of that element contains <code>VK_SPARSE_MEMORY_BIND_METADATA_BIT</code>, the binding range defined <strong>must</strong> be within the mip tail region of the metadata aspect of <code>image</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSparseImageOpaqueMemoryBindInfo-image-parameter">  <code>image</code> <strong>must</strong> be a valid <code>VkImage</code> handle </li> <li id="VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-parameter">  <code>pBinds</code> <strong>must</strong> be a pointer to an array of <code>bindCount</code> valid <code>VkSparseMemoryBind</code> structures </li> <li id="VUID-VkSparseImageOpaqueMemoryBindInfo-bindCount-arraylength">  <code>bindCount</code> <strong>must</strong> be greater than <code>0</code> </li> </ul>   </blockquote>   <h4 id="_see_also_257">See Also</h4>  <p><a href="#VkBindSparseInfo">VkBindSparseInfo</a>, <a href="#VkImage">VkImage</a>, <a href="#VkSparseMemoryBind">VkSparseMemoryBind</a></p>    <h4 id="_document_notes_257">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageOpaqueMemoryBindInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageOpaqueMemoryBindInfo</a></p>         <h3 id="_vksparsememorybind_3">VkSparseMemoryBind(3)</h3>  <h4 id="_name_258">Name</h4>  <p>VkSparseMemoryBind - Structure specifying a sparse memory bind operation</p>    <h4 id="_c_specification_258">C Specification</h4>  <p>The <code>VkSparseMemoryBind</code> structure is defined as:</p>  <pre id="VkSparseMemoryBind" data-language="c++">typedef struct VkSparseMemoryBind {
    VkDeviceSize               resourceOffset;
    VkDeviceSize               size;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseMemoryBind;</pre>   <h4 id="_members_96">Members</h4>  <ul> <li> <code>resourceOffset</code> is the offset into the resource. </li> <li> <code>size</code> is the size of the memory region to be bound. </li> <li> <code>memory</code> is the <code>VkDeviceMemory</code> object that the range of the resource is bound to. If <code>memory</code> is <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, the range is unbound. </li> <li> <code>memoryOffset</code> is the offset into the <code>VkDeviceMemory</code> object to bind the resource range to. If <code>memory</code> is <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, this value is ignored. </li> <li> <code>flags</code> is a bitmask of <a href="#VkSparseMemoryBindFlagBits">VkSparseMemoryBindFlagBits</a> specifying usage of the binding operation. </li> </ul>    <h4 id="_description_258">Description</h4>  <p>The <em>binding range</em> [<code>resourceOffset</code>, <code>resourceOffset</code> + <code>size</code>) has different constraints based on <code>flags</code>. If <code>flags</code> contains <code>VK_SPARSE_MEMORY_BIND_METADATA_BIT</code>, the binding range <strong>must</strong> be within the mip tail region of the metadata aspect. This metadata region is defined by:</p>  <div class="dlist"> <dl>  <dd> metadataRegion = [base, base + <code>imageMipTailSize</code>) </dd>  <dd> base = <code>imageMipTailOffset</code> + <code>imageMipTailStride</code> × n </dd> </dl> </div>  <p>and <code>imageMipTailOffset</code>, <code>imageMipTailSize</code>, and <code>imageMipTailStride</code> values are from the <a href="#VkSparseImageMemoryRequirements">VkSparseImageMemoryRequirements</a> corresponding to the metadata aspect of the image, and n is a valid array layer index for the image,</p>   <p><code>imageMipTailStride</code> is considered to be zero for aspects where <code>VkSparseImageMemoryRequirements</code>::<code>formatProperties.flags</code> contains <code>VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT</code>.</p>   <p>If <code>flags</code> does not contain <code>VK_SPARSE_MEMORY_BIND_METADATA_BIT</code>, the binding range <strong>must</strong> be within the range [0,<a href="#VkMemoryRequirements">VkMemoryRequirements</a>::<code>size</code>).</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkSparseMemoryBind-memory-01096">  If <code>memory</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>memory</code> and <code>memoryOffset</code> <strong>must</strong> match the memory requirements of the resource, as described in section <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-association">html/vkspec.html#resources-association</a> </li> <li id="VUID-VkSparseMemoryBind-memory-01097">  If <code>memory</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>memory</code> <strong>must</strong> not have been created with a memory type that reports <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code> bit set </li> <li id="VUID-VkSparseMemoryBind-size-01098">  <code>size</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkSparseMemoryBind-resourceOffset-01099">  <code>resourceOffset</code> <strong>must</strong> be less than the size of the resource </li> <li id="VUID-VkSparseMemoryBind-size-01100">  <code>size</code> <strong>must</strong> be less than or equal to the size of the resource minus <code>resourceOffset</code> </li> <li id="VUID-VkSparseMemoryBind-memoryOffset-01101">  <code>memoryOffset</code> <strong>must</strong> be less than the size of <code>memory</code> </li> <li id="VUID-VkSparseMemoryBind-size-01102">  <code>size</code> <strong>must</strong> be less than or equal to the size of <code>memory</code> minus <code>memoryOffset</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSparseMemoryBind-memory-parameter">  If <code>memory</code> is not <a href="#VK_NULL_HANDLE">VK_NULL_HANDLE</a>, <code>memory</code> <strong>must</strong> be a valid <code>VkDeviceMemory</code> handle </li> <li id="VUID-VkSparseMemoryBind-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkSparseMemoryBindFlagBits">VkSparseMemoryBindFlagBits</a> values </li> </ul>   </blockquote>   <h4 id="_see_also_258">See Also</h4>  <p><a href="#VkDeviceMemory">VkDeviceMemory</a>, <code>VkDeviceSize</code>, <a href="#VkSparseBufferMemoryBindInfo">VkSparseBufferMemoryBindInfo</a>, <a href="#VkSparseImageOpaqueMemoryBindInfo">VkSparseImageOpaqueMemoryBindInfo</a>, <a href="#VkSparseMemoryBindFlags">VkSparseMemoryBindFlags</a></p>    <h4 id="_document_notes_258">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseMemoryBind">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseMemoryBind</a></p>         <h3 id="_vkspecializationinfo_3">VkSpecializationInfo(3)</h3>  <h4 id="_name_259">Name</h4>  <p>VkSpecializationInfo - Structure specifying specialization info</p>    <h4 id="_c_specification_259">C Specification</h4>  <p>The <code>VkSpecializationInfo</code> structure is defined as:</p>  <pre id="VkSpecializationInfo" data-language="c++">typedef struct VkSpecializationInfo {
    uint32_t                           mapEntryCount;
    const VkSpecializationMapEntry*    pMapEntries;
    size_t                             dataSize;
    const void*                        pData;
} VkSpecializationInfo;</pre>   <h4 id="_members_97">Members</h4>  <ul> <li> <code>mapEntryCount</code> is the number of entries in the <code>pMapEntries</code> array. </li> <li> <code>pMapEntries</code> is a pointer to an array of <code>VkSpecializationMapEntry</code> which maps constant IDs to offsets in <code>pData</code>. </li> <li> <code>dataSize</code> is the byte size of the <code>pData</code> buffer. </li> <li> <code>pData</code> contains the actual constant values to specialize with. </li> </ul>    <h4 id="_description_259">Description</h4>  <p><code>pMapEntries</code> points to a structure of type <a href="#VkSpecializationMapEntry">VkSpecializationMapEntry</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkSpecializationInfo-offset-00773">  The <code>offset</code> member of any given element of <code>pMapEntries</code> <strong>must</strong> be less than <code>dataSize</code> </li> <li id="VUID-VkSpecializationInfo-pMapEntries-00774">  For any given element of <code>pMapEntries</code>, <code>size</code> <strong>must</strong> be less than or equal to <code>dataSize</code> minus <code>offset</code> </li> <li id="VUID-VkSpecializationInfo-mapEntryCount-00775">  If <code>mapEntryCount</code> is not <code>0</code>, <code>pMapEntries</code> <strong>must</strong> be a pointer to an array of <code>mapEntryCount</code> valid <code>VkSpecializationMapEntry</code> structures </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSpecializationInfo-pData-parameter">  If <code>dataSize</code> is not <code>0</code>, <code>pData</code> <strong>must</strong> be a pointer to an array of <code>dataSize</code> bytes </li> </ul>   </blockquote>   <h4 id="_see_also_259">See Also</h4>  <p><a href="#VkPipelineShaderStageCreateInfo">VkPipelineShaderStageCreateInfo</a>, <a href="#VkSpecializationMapEntry">VkSpecializationMapEntry</a></p>    <h4 id="_document_notes_259">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSpecializationInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSpecializationInfo</a></p>         <h3 id="_vkspecializationmapentry_3">VkSpecializationMapEntry(3)</h3>  <h4 id="_name_260">Name</h4>  <p>VkSpecializationMapEntry - Structure specifying a specialization map entry</p>    <h4 id="_c_specification_260">C Specification</h4>  <p>The <code>VkSpecializationMapEntry</code> structure is defined as:</p>  <pre id="VkSpecializationMapEntry" data-language="c++">typedef struct VkSpecializationMapEntry {
    uint32_t    constantID;
    uint32_t    offset;
    size_t      size;
} VkSpecializationMapEntry;</pre>   <h4 id="_members_98">Members</h4>  <ul> <li> <code>constantID</code> is the ID of the specialization constant in SPIR-V. </li> <li> <code>offset</code> is the byte offset of the specialization constant value within the supplied data buffer. </li> <li> <code>size</code> is the byte size of the specialization constant value within the supplied data buffer. </li> </ul>    <h4 id="_description_260">Description</h4>  <p>If a <code>constantID</code> value is not a specialization constant ID used in the shader, that map entry does not affect the behavior of the pipeline.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkSpecializationMapEntry-constantID-00776">  For a <code>constantID</code> specialization constant declared in a shader, <code>size</code> <strong>must</strong> match the byte size of the <code>constantID</code>. If the specialization constant is of type <code>boolean</code>, <code>size</code> <strong>must</strong> be the byte size of <code>VkBool32</code> </li> </ul>   </blockquote>   <h4 id="_see_also_260">See Also</h4>  <p><a href="#VkSpecializationInfo">VkSpecializationInfo</a></p>    <h4 id="_document_notes_260">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSpecializationMapEntry">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSpecializationMapEntry</a></p>         <h3 id="_vkstencilopstate_3">VkStencilOpState(3)</h3>  <h4 id="_name_261">Name</h4>  <p>VkStencilOpState - Structure specifying stencil operation state</p>    <h4 id="_c_specification_261">C Specification</h4>  <p>The <code>VkStencilOpState</code> structure is defined as:</p>  <pre id="VkStencilOpState" data-language="c++">typedef struct VkStencilOpState {
    VkStencilOp    failOp;
    VkStencilOp    passOp;
    VkStencilOp    depthFailOp;
    VkCompareOp    compareOp;
    uint32_t       compareMask;
    uint32_t       writeMask;
    uint32_t       reference;
} VkStencilOpState;</pre>   <h4 id="_members_99">Members</h4>  <ul> <li> <code>failOp</code> is a <a href="#VkStencilOp">VkStencilOp</a> value specifying the action performed on samples that fail the stencil test. </li> <li> <code>passOp</code> is a <a href="#VkStencilOp">VkStencilOp</a> value specifying the action performed on samples that pass both the depth and stencil tests. </li> <li> <code>depthFailOp</code> is a <a href="#VkStencilOp">VkStencilOp</a> value specifying the action performed on samples that pass the stencil test and fail the depth test. </li> <li> <code>compareOp</code> is a <a href="#VkCompareOp">VkCompareOp</a> value specifying the comparison operator used in the stencil test. </li> <li> <code>compareMask</code> selects the bits of the unsigned integer stencil values participating in the stencil test. </li> <li> <code>writeMask</code> selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment. </li> <li> <code>reference</code> is an integer reference value that is used in the unsigned stencil comparison. </li> </ul>    <h4 id="_description_261">Description</h4> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkStencilOpState-failOp-parameter">  <code>failOp</code> <strong>must</strong> be a valid <a href="#VkStencilOp">VkStencilOp</a> value </li> <li id="VUID-VkStencilOpState-passOp-parameter">  <code>passOp</code> <strong>must</strong> be a valid <a href="#VkStencilOp">VkStencilOp</a> value </li> <li id="VUID-VkStencilOpState-depthFailOp-parameter">  <code>depthFailOp</code> <strong>must</strong> be a valid <a href="#VkStencilOp">VkStencilOp</a> value </li> <li id="VUID-VkStencilOpState-compareOp-parameter">  <code>compareOp</code> <strong>must</strong> be a valid <a href="#VkCompareOp">VkCompareOp</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_261">See Also</h4>  <p><a href="#VkCompareOp">VkCompareOp</a>, <a href="#VkPipelineDepthStencilStateCreateInfo">VkPipelineDepthStencilStateCreateInfo</a>, <a href="#VkStencilOp">VkStencilOp</a></p>    <h4 id="_document_notes_261">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkStencilOpState">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkStencilOpState</a></p>         <h3 id="_vksubmitinfo_3">VkSubmitInfo(3)</h3>  <h4 id="_name_262">Name</h4>  <p>VkSubmitInfo - Structure specifying a queue submit operation</p>    <h4 id="_c_specification_262">C Specification</h4>  <p>The <code>VkSubmitInfo</code> structure is defined as:</p>  <pre id="VkSubmitInfo" data-language="c++">typedef struct VkSubmitInfo {
    VkStructureType                sType;
    const void*                    pNext;
    uint32_t                       waitSemaphoreCount;
    const VkSemaphore*             pWaitSemaphores;
    const VkPipelineStageFlags*    pWaitDstStageMask;
    uint32_t                       commandBufferCount;
    const VkCommandBuffer*         pCommandBuffers;
    uint32_t                       signalSemaphoreCount;
    const VkSemaphore*             pSignalSemaphores;
} VkSubmitInfo;</pre>   <h4 id="_members_100">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>waitSemaphoreCount</code> is the number of semaphores upon which to wait before executing the command buffers for the batch. </li> <li> <code>pWaitSemaphores</code> is a pointer to an array of semaphores upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores-waiting">semaphore wait operation</a>. </li> <li> <code>pWaitDstStageMask</code> is a pointer to an array of pipeline stages at which each corresponding semaphore wait will occur. </li> <li> <code>commandBufferCount</code> is the number of command buffers to execute in the batch. </li> <li> <code>pCommandBuffers</code> is a pointer to an array of command buffers to execute in the batch. </li> <li> <code>signalSemaphoreCount</code> is the number of semaphores to be signaled once the commands specified in <code>pCommandBuffers</code> have completed execution. </li> <li> <code>pSignalSemaphores</code> is a pointer to an array of semaphores which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-semaphores-signaling">semaphore signal operation</a>. </li> </ul>    <h4 id="_description_262">Description</h4>  <p>The order that command buffers appear in <code>pCommandBuffers</code> is used to determine <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order">submission order</a>, and thus all the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-implicit">implicit ordering guarantees</a> that respect it. Other than these implicit ordering guarantees and any <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">explicit synchronization primitives</a>, these command buffers <strong>may</strong> overlap or otherwise execute out of order.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkSubmitInfo-pCommandBuffers-00075">  Any given element of <code>pCommandBuffers</code> <strong>must</strong> not have been allocated with <code>VK_COMMAND_BUFFER_LEVEL_SECONDARY</code> </li> <li id="VUID-VkSubmitInfo-pWaitDstStageMask-00076">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, any given element of <code>pWaitDstStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> </li> <li id="VUID-VkSubmitInfo-pWaitDstStageMask-00077">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, any given element of <code>pWaitDstStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> or <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> </li> <li id="VUID-VkSubmitInfo-pWaitDstStageMask-00078">  Any given element of <code>pWaitDstStageMask</code> <strong>must</strong> not include <code>VK_PIPELINE_STAGE_HOST_BIT</code>. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSubmitInfo-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_SUBMIT_INFO</code> </li> <li id="VUID-VkSubmitInfo-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkSubmitInfo-pWaitSemaphores-parameter">  If <code>waitSemaphoreCount</code> is not <code>0</code>, <code>pWaitSemaphores</code> <strong>must</strong> be a pointer to an array of <code>waitSemaphoreCount</code> valid <code>VkSemaphore</code> handles </li> <li id="VUID-VkSubmitInfo-pWaitDstStageMask-parameter">  If <code>waitSemaphoreCount</code> is not <code>0</code>, <code>pWaitDstStageMask</code> <strong>must</strong> be a pointer to an array of <code>waitSemaphoreCount</code> valid combinations of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> values </li> <li id="VUID-VkSubmitInfo-pWaitDstStageMask-requiredbitmask">  Each element of <code>pWaitDstStageMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-VkSubmitInfo-pCommandBuffers-parameter">  If <code>commandBufferCount</code> is not <code>0</code>, <code>pCommandBuffers</code> <strong>must</strong> be a pointer to an array of <code>commandBufferCount</code> valid <code>VkCommandBuffer</code> handles </li> <li id="VUID-VkSubmitInfo-pSignalSemaphores-parameter">  If <code>signalSemaphoreCount</code> is not <code>0</code>, <code>pSignalSemaphores</code> <strong>must</strong> be a pointer to an array of <code>signalSemaphoreCount</code> valid <code>VkSemaphore</code> handles </li> <li id="VUID-VkSubmitInfo-commonparent">  Each of the elements of <code>pCommandBuffers</code>, the elements of <code>pSignalSemaphores</code>, and the elements of <code>pWaitSemaphores</code> that are valid handles <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_262">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkPipelineStageFlags">VkPipelineStageFlags</a>, <a href="#VkSemaphore">VkSemaphore</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkQueueSubmit">vkQueueSubmit</a></p>    <h4 id="_document_notes_262">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubmitInfo">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubmitInfo</a></p>         <h3 id="_vksubpassdependency_3">VkSubpassDependency(3)</h3>  <h4 id="_name_263">Name</h4>  <p>VkSubpassDependency - Structure specifying a subpass dependency</p>    <h4 id="_c_specification_263">C Specification</h4>  <p>The <code>VkSubpassDependency</code> structure is defined as:</p>  <pre id="VkSubpassDependency" data-language="c++">typedef struct VkSubpassDependency {
    uint32_t                srcSubpass;
    uint32_t                dstSubpass;
    VkPipelineStageFlags    srcStageMask;
    VkPipelineStageFlags    dstStageMask;
    VkAccessFlags           srcAccessMask;
    VkAccessFlags           dstAccessMask;
    VkDependencyFlags       dependencyFlags;
} VkSubpassDependency;</pre>   <h4 id="_members_101">Members</h4>  <ul> <li> <code>srcSubpass</code> is the subpass index of the first subpass in the dependency, or <code>VK_SUBPASS_EXTERNAL</code>. </li> <li> <code>dstSubpass</code> is the subpass index of the second subpass in the dependency, or <code>VK_SUBPASS_EXTERNAL</code>. </li> <li> <code>srcStageMask</code> is a bitmask of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> specifying the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a>. </li> <li> <code>dstStageMask</code> is a bitmask of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> specifying the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> </li> <li> <code>srcAccessMask</code> is a bitmask of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> specifying a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a>. </li> <li> <code>dstAccessMask</code> is a bitmask of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> specifying a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access mask</a>. </li> <li> <code>dependencyFlags</code> is a bitmask of <a href="#VkDependencyFlagBits">VkDependencyFlagBits</a>. </li> </ul>    <h4 id="_description_263">Description</h4>  <p>If <code>srcSubpass</code> is equal to <code>dstSubpass</code> then the <a href="#VkSubpassDependency">VkSubpassDependency</a> describes a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies">subpass self-dependency</a>, and only constrains the pipeline barriers allowed within a subpass instance. Otherwise, when a render pass instance which includes a subpass dependency is submitted to a queue, it defines a memory dependency between the subpasses identified by <code>srcSubpass</code> and <code>dstSubpass</code>.</p>   <p>If <code>srcSubpass</code> is equal to <code>VK_SUBPASS_EXTERNAL</code>, the first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes commands submitted to the queue before the render pass instance began. Otherwise, the first set of commands includes all commands submitted as part of the subpass instance identified by <code>srcSubpass</code> and any load, store or multisample resolve operations on attachments used in <code>srcSubpass</code>. In either case, the first synchronization scope is limited to operations on the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by <code>srcStageMask</code>.</p>   <p>If <code>dstSubpass</code> is equal to <code>VK_SUBPASS_EXTERNAL</code>, the second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scope</a> includes commands submitted after the render pass instance is ended. Otherwise, the second set of commands includes all commands submitted as part of the subpass instance identified by <code>dstSubpass</code> and any load, store or multisample resolve operations on attachments used in <code>dstSubpass</code>. In either case, the second synchronization scope is limited to operations on the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified by <code>dstStageMask</code>.</p>   <p>The first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access in the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">source stage mask</a> specified by <code>srcStageMask</code>. It is also limited to access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">source access mask</a> specified by <code>srcAccessMask</code>.</p>   <p>The second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> is limited to access in the pipeline stages determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks">destination stage mask</a> specified by <code>dstStageMask</code>. It is also limited to access types in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks">destination access mask</a> specified by <code>dstAccessMask</code>.</p>   <p>The <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-available-and-visible">availability and visibility operations</a> defined by a subpass dependency affect the execution of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-layout-transitions">image layout transitions</a> within the render pass.</p>  <blockquote> <h5 class="title">Note</h5>  <p>For non-attachment resources, the memory dependency expressed by subpass dependency is nearly identical to that of a <a href="#VkMemoryBarrier">VkMemoryBarrier</a> (with matching <code>srcAccessMask</code>/<code>dstAccessMask</code> parameters) submitted as a part of a <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a> (with matching <code>srcStageMask</code>/<code>dstStageMask</code> parameters). The only difference being that its scopes are limited to the identified subpasses rather than potentially affecting everything before and after.</p>   <p>For attachments however, subpass dependencies work more like an <a href="#VkImageMemoryBarrier">VkImageMemoryBarrier</a> defined similarly to the <a href="#VkMemoryBarrier">VkMemoryBarrier</a> above, the queue family indices set to <code>VK_QUEUE_FAMILY_IGNORED</code>, and layouts as follows:</p>   <ul> <li> The equivalent to <code>oldLayout</code> is the attachment’s layout according to the subpass description for <code>srcSubpass</code>. </li> <li> The equivalent to <code>newLayout</code> is the attachment’s layout according to the subpass description for <code>dstSubpass</code>. </li> </ul>  </blockquote> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkSubpassDependency-srcSubpass-00858">  If <code>srcSubpass</code> is not <code>VK_SUBPASS_EXTERNAL</code>, <code>srcStageMask</code> <strong>must</strong> not include <code>VK_PIPELINE_STAGE_HOST_BIT</code> </li> <li id="VUID-VkSubpassDependency-dstSubpass-00859">  If <code>dstSubpass</code> is not <code>VK_SUBPASS_EXTERNAL</code>, <code>dstStageMask</code> <strong>must</strong> not include <code>VK_PIPELINE_STAGE_HOST_BIT</code> </li> <li id="VUID-VkSubpassDependency-srcStageMask-00860">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, <code>srcStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> </li> <li id="VUID-VkSubpassDependency-dstStageMask-00861">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader">geometry shaders</a> feature is not enabled, <code>dstStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> </li> <li id="VUID-VkSubpassDependency-srcStageMask-00862">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, <code>srcStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> or <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> </li> <li id="VUID-VkSubpassDependency-dstStageMask-00863">  If the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader">tessellation shaders</a> feature is not enabled, <code>dstStageMask</code> <strong>must</strong> not contain <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> or <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> </li> <li id="VUID-VkSubpassDependency-srcSubpass-00864">  <code>srcSubpass</code> <strong>must</strong> be less than or equal to <code>dstSubpass</code>, unless one of them is <code>VK_SUBPASS_EXTERNAL</code>, to avoid cyclic dependencies and ensure a valid execution order </li> <li id="VUID-VkSubpassDependency-srcSubpass-00865">  <code>srcSubpass</code> and <code>dstSubpass</code> <strong>must</strong> not both be equal to <code>VK_SUBPASS_EXTERNAL</code> </li> <li id="VUID-VkSubpassDependency-srcSubpass-00866">  If <code>srcSubpass</code> is equal to <code>dstSubpass</code>, <code>srcStageMask</code> and <code>dstStageMask</code> <strong>must</strong> only contain one of <code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>, <code>VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT</code>, <code>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</code>, <code>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code>, <code>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</code>, <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code>, <code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code>, or <code>VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT</code> </li> <li id="VUID-VkSubpassDependency-srcSubpass-00867">  If <code>srcSubpass</code> is equal to <code>dstSubpass</code> and not all of the stages in <code>srcStageMask</code> and <code>dstStageMask</code> are <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions">framebuffer-space stages</a>, the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically latest</a> pipeline stage in <code>srcStageMask</code> <strong>must</strong> be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically earlier</a> than or equal to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order">logically earliest</a> pipeline stage in <code>dstStageMask</code> </li> <li id="VUID-VkSubpassDependency-srcAccessMask-00868">  Any access flag included in <code>srcAccessMask</code> <strong>must</strong> be supported by one of the pipeline stages in <code>srcStageMask</code>, as specified in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access types</a>. </li> <li id="VUID-VkSubpassDependency-dstAccessMask-00869">  Any access flag included in <code>dstAccessMask</code> <strong>must</strong> be supported by one of the pipeline stages in <code>dstStageMask</code>, as specified in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">table of supported access types</a>. </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSubpassDependency-srcStageMask-parameter">  <code>srcStageMask</code> <strong>must</strong> be a valid combination of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> values </li> <li id="VUID-VkSubpassDependency-srcStageMask-requiredbitmask">  <code>srcStageMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-VkSubpassDependency-dstStageMask-parameter">  <code>dstStageMask</code> <strong>must</strong> be a valid combination of <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a> values </li> <li id="VUID-VkSubpassDependency-dstStageMask-requiredbitmask">  <code>dstStageMask</code> <strong>must</strong> not be <code>0</code> </li> <li id="VUID-VkSubpassDependency-srcAccessMask-parameter">  <code>srcAccessMask</code> <strong>must</strong> be a valid combination of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> values </li> <li id="VUID-VkSubpassDependency-dstAccessMask-parameter">  <code>dstAccessMask</code> <strong>must</strong> be a valid combination of <a href="#VkAccessFlagBits">VkAccessFlagBits</a> values </li> <li id="VUID-VkSubpassDependency-dependencyFlags-parameter">  <code>dependencyFlags</code> <strong>must</strong> be a valid combination of <a href="#VkDependencyFlagBits">VkDependencyFlagBits</a> values </li> </ul>   </blockquote>   <h4 id="_see_also_263">See Also</h4>  <p><a href="#VkAccessFlags">VkAccessFlags</a>, <a href="#VkDependencyFlags">VkDependencyFlags</a>, <a href="#VkPipelineStageFlags">VkPipelineStageFlags</a>, <a href="#VkRenderPassCreateInfo">VkRenderPassCreateInfo</a></p>    <h4 id="_document_notes_263">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubpassDependency">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubpassDependency</a></p>         <h3 id="_vksubpassdescription_3">VkSubpassDescription(3)</h3>  <h4 id="_name_264">Name</h4>  <p>VkSubpassDescription - Structure specifying a subpass description</p>    <h4 id="_c_specification_264">C Specification</h4>  <p>The <code>VkSubpassDescription</code> structure is defined as:</p>  <pre id="VkSubpassDescription" data-language="c++">typedef struct VkSubpassDescription {
    VkSubpassDescriptionFlags       flags;
    VkPipelineBindPoint             pipelineBindPoint;
    uint32_t                        inputAttachmentCount;
    const VkAttachmentReference*    pInputAttachments;
    uint32_t                        colorAttachmentCount;
    const VkAttachmentReference*    pColorAttachments;
    const VkAttachmentReference*    pResolveAttachments;
    const VkAttachmentReference*    pDepthStencilAttachment;
    uint32_t                        preserveAttachmentCount;
    const uint32_t*                 pPreserveAttachments;
} VkSubpassDescription;</pre>   <h4 id="_members_102">Members</h4>  <ul> <li> <code>flags</code> is a bitmask of <a href="#VkSubpassDescriptionFlagBits">VkSubpassDescriptionFlagBits</a> specifying usage of the subpass. </li> <li> <code>pipelineBindPoint</code> is a <a href="#VkPipelineBindPoint">VkPipelineBindPoint</a> value specifying whether this is a compute or graphics subpass. Currently, only graphics subpasses are supported. </li> <li> <code>inputAttachmentCount</code> is the number of input attachments. </li> <li> <code>pInputAttachments</code> is an array of <a href="#VkAttachmentReference">VkAttachmentReference</a> structures (defined below) that lists which of the render pass’s attachments <strong>can</strong> be read in the shader during the subpass, and what layout each attachment will be in during the subpass. Each element of the array corresponds to an input attachment unit number in the shader, i.e. if the shader declares an input variable <code>layout(input_attachment_index=X, set=Y, binding=Z)</code> then it uses the attachment provided in <code>pInputAttachments</code>[X]. Input attachments <strong>must</strong> also be bound to the pipeline with a descriptor set, with the input attachment descriptor written in the location (set=Y, binding=Z). </li> <li> <code>colorAttachmentCount</code> is the number of color attachments. </li> <li> <code>pColorAttachments</code> is an array of <code>colorAttachmentCount</code> <a href="#VkAttachmentReference">VkAttachmentReference</a> structures that lists which of the render pass’s attachments will be used as color attachments in the subpass, and what layout each attachment will be in during the subpass. Each element of the array corresponds to a fragment shader output location, i.e. if the shader declared an output variable <code>layout(location=X)</code> then it uses the attachment provided in <code>pColorAttachments</code>[X]. </li> <li> <code>pResolveAttachments</code> is <code>NULL</code> or an array of <code>colorAttachmentCount</code> <a href="#VkAttachmentReference">VkAttachmentReference</a> structures that lists which of the render pass’s attachments are resolved to at the end of the subpass, and what layout each attachment will be in during the multisample resolve operation. If <code>pResolveAttachments</code> is not <code>NULL</code>, each of its elements corresponds to a color attachment (the element in <code>pColorAttachments</code> at the same index), and a multisample resolve operation is defined for each attachment. At the end of each subpass, multisample resolve operations read the subpass’s color attachments, and resolve the samples for each pixel to the same pixel location in the corresponding resolve attachments, unless the resolve attachment index is <code>VK_ATTACHMENT_UNUSED</code>. If the first use of an attachment in a render pass is as a resolve attachment, then the <code>loadOp</code> is effectively ignored as the resolve is guaranteed to overwrite all pixels in the render area. </li> <li> <code>pDepthStencilAttachment</code> is a pointer to a <a href="#VkAttachmentReference">VkAttachmentReference</a> specifying which attachment will be used for depth/stencil data and the layout it will be in during the subpass. Setting the attachment index to <code>VK_ATTACHMENT_UNUSED</code> or leaving this pointer as <code>NULL</code> indicates that no depth/stencil attachment will be used in the subpass. </li> <li> <code>preserveAttachmentCount</code> is the number of preserved attachments. </li> <li> <code>pPreserveAttachments</code> is an array of <code>preserveAttachmentCount</code> render pass attachment indices describing the attachments that are not used by a subpass, but whose contents <strong>must</strong> be preserved throughout the subpass. </li> </ul>    <h4 id="_description_264">Description</h4>  <p>The contents of an attachment within the render area become undefined at the start of a subpass <strong>S</strong> if all of the following conditions are true:</p>   <ul> <li> The attachment is used as a color, depth/stencil, or resolve attachment in any subpass in the render pass. </li> <li> There is a subpass <strong>S<sub>1</sub></strong> that uses or preserves the attachment, and a subpass dependency from <strong>S<sub>1</sub></strong> to <strong>S</strong>. </li> <li> The attachment is not used or preserved in subpass <strong>S</strong>. </li> </ul>   <p>Once the contents of an attachment become undefined in subpass <strong>S</strong>, they remain undefined for subpasses in subpass dependency chains starting with subpass <strong>S</strong> until they are written again. However, they remain valid for subpasses in other subpass dependency chains starting with subpass <strong>S<sub>1</sub></strong> if those subpasses use or preserve the attachment.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkSubpassDescription-pipelineBindPoint-00844">  <code>pipelineBindPoint</code> <strong>must</strong> be <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> </li> <li id="VUID-VkSubpassDescription-colorAttachmentCount-00845">  <code>colorAttachmentCount</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxColorAttachments</code> </li> <li id="VUID-VkSubpassDescription-loadOp-00846">  If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then <code>loadOp</code> <strong>must</strong> not be <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code> </li> <li id="VUID-VkSubpassDescription-pResolveAttachments-00847">  If <code>pResolveAttachments</code> is not <code>NULL</code>, for each resolve attachment that does not have the value <code>VK_ATTACHMENT_UNUSED</code>, the corresponding color attachment <strong>must</strong> not have the value <code>VK_ATTACHMENT_UNUSED</code> </li> <li id="VUID-VkSubpassDescription-pResolveAttachments-00848">  If <code>pResolveAttachments</code> is not <code>NULL</code>, the sample count of each element of <code>pColorAttachments</code> <strong>must</strong> be anything other than <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li id="VUID-VkSubpassDescription-pResolveAttachments-00849">  Any given element of <code>pResolveAttachments</code> <strong>must</strong> have a sample count of <code>VK_SAMPLE_COUNT_1_BIT</code> </li> <li id="VUID-VkSubpassDescription-pResolveAttachments-00850">  Any given element of <code>pResolveAttachments</code> <strong>must</strong> have the same <a href="#VkFormat">VkFormat</a> as its corresponding color attachment </li> <li id="VUID-VkSubpassDescription-pColorAttachments-01417">  All attachments in <code>pColorAttachments</code> that are not <code>VK_ATTACHMENT_UNUSED</code> <strong>must</strong> have the same sample count </li> <li id="VUID-VkSubpassDescription-pDepthStencilAttachment-01418">  If <code>pDepthStencilAttachment</code> is not <code>VK_ATTACHMENT_UNUSED</code> and any attachments in <code>pColorAttachments</code> are not <code>VK_ATTACHMENT_UNUSED</code>, they <strong>must</strong> have the same sample count </li> <li id="VUID-VkSubpassDescription-None-00852">  If any input attachments are <code>VK_ATTACHMENT_UNUSED</code>, then any pipelines bound during the subpass <strong>must</strong> not access those input attachments from the fragment shader </li> <li id="VUID-VkSubpassDescription-attachment-00853">  The <code>attachment</code> member of any element of <code>pPreserveAttachments</code> <strong>must</strong> not be <code>VK_ATTACHMENT_UNUSED</code> </li> <li id="VUID-VkSubpassDescription-pPreserveAttachments-00854">  Any given element of <code>pPreserveAttachments</code> <strong>must</strong> not also be an element of any other member of the subpass description </li> <li id="VUID-VkSubpassDescription-layout-00855">  If any attachment is used as both an input attachment and a color or depth/stencil attachment, then each use <strong>must</strong> use the same <code>layout</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkSubpassDescription-flags-parameter">  <code>flags</code> <strong>must</strong> be a valid combination of <a href="#VkSubpassDescriptionFlagBits">VkSubpassDescriptionFlagBits</a> values </li> <li id="VUID-VkSubpassDescription-pipelineBindPoint-parameter">  <code>pipelineBindPoint</code> <strong>must</strong> be a valid <a href="#VkPipelineBindPoint">VkPipelineBindPoint</a> value </li> <li id="VUID-VkSubpassDescription-pInputAttachments-parameter">  If <code>inputAttachmentCount</code> is not <code>0</code>, <code>pInputAttachments</code> <strong>must</strong> be a pointer to an array of <code>inputAttachmentCount</code> valid <code>VkAttachmentReference</code> structures </li> <li id="VUID-VkSubpassDescription-pColorAttachments-parameter">  If <code>colorAttachmentCount</code> is not <code>0</code>, <code>pColorAttachments</code> <strong>must</strong> be a pointer to an array of <code>colorAttachmentCount</code> valid <code>VkAttachmentReference</code> structures </li> <li id="VUID-VkSubpassDescription-pResolveAttachments-parameter">  If <code>colorAttachmentCount</code> is not <code>0</code>, and <code>pResolveAttachments</code> is not <code>NULL</code>, <code>pResolveAttachments</code> <strong>must</strong> be a pointer to an array of <code>colorAttachmentCount</code> valid <code>VkAttachmentReference</code> structures </li> <li id="VUID-VkSubpassDescription-pDepthStencilAttachment-parameter">  If <code>pDepthStencilAttachment</code> is not <code>NULL</code>, <code>pDepthStencilAttachment</code> <strong>must</strong> be a pointer to a valid <code>VkAttachmentReference</code> structure </li> <li id="VUID-VkSubpassDescription-pPreserveAttachments-parameter">  If <code>preserveAttachmentCount</code> is not <code>0</code>, <code>pPreserveAttachments</code> <strong>must</strong> be a pointer to an array of <code>preserveAttachmentCount</code> <code>uint32_t</code> values </li> </ul>   </blockquote>   <h4 id="_see_also_264">See Also</h4>  <p><a href="#VkAttachmentReference">VkAttachmentReference</a>, <a href="#VkPipelineBindPoint">VkPipelineBindPoint</a>, <a href="#VkRenderPassCreateInfo">VkRenderPassCreateInfo</a>, <a href="#VkSubpassDescriptionFlags">VkSubpassDescriptionFlags</a></p>    <h4 id="_document_notes_264">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubpassDescription">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubpassDescription</a></p>         <h3 id="_vksubresourcelayout_3">VkSubresourceLayout(3)</h3>  <h4 id="_name_265">Name</h4>  <p>VkSubresourceLayout - Structure specifying subresource layout</p>    <h4 id="_c_specification_265">C Specification</h4>  <p>Information about the layout of the image subresource is returned in a <code>VkSubresourceLayout</code> structure:</p>  <pre id="VkSubresourceLayout" data-language="c++">typedef struct VkSubresourceLayout {
    VkDeviceSize    offset;
    VkDeviceSize    size;
    VkDeviceSize    rowPitch;
    VkDeviceSize    arrayPitch;
    VkDeviceSize    depthPitch;
} VkSubresourceLayout;</pre>   <h4 id="_members_103">Members</h4>  <ul> <li> <code>offset</code> is the byte offset from the start of the image where the image subresource begins. </li> <li> <code>size</code> is the size in bytes of the image subresource. <code>size</code> includes any extra memory that is required based on <code>rowPitch</code>. </li> <li> <code>rowPitch</code> describes the number of bytes between each row of texels in an image. </li> <li> <code>arrayPitch</code> describes the number of bytes between each array layer of an image. </li> <li> <code>depthPitch</code> describes the number of bytes between each slice of 3D image. </li> </ul>    <h4 id="_description_265">Description</h4>  <p>For images created with linear tiling, <code>rowPitch</code>, <code>arrayPitch</code> and <code>depthPitch</code> describe the layout of the image subresource in linear memory. For uncompressed formats, <code>rowPitch</code> is the number of bytes between texels with the same x coordinate in adjacent rows (y coordinates differ by one). <code>arrayPitch</code> is the number of bytes between texels with the same x and y coordinate in adjacent array layers of the image (array layer values differ by one). <code>depthPitch</code> is the number of bytes between texels with the same x and y coordinate in adjacent slices of a 3D image (z coordinates differ by one). Expressed as an addressing formula, the starting byte of a texel in the image subresource has address:</p>  <pre data-language="c">// (x,y,z,layer) are in texel coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*elementSize + offset</pre>  <p>For compressed formats, the <code>rowPitch</code> is the number of bytes between compressed texel blocks in adjacent rows. <code>arrayPitch</code> is the number of bytes between compressed texel blocks in adjacent array layers. <code>depthPitch</code> is the number of bytes between compressed texel blocks in adjacent slices of a 3D image.</p>  <pre data-language="c">// (x,y,z,layer) are in compressed texel block coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*compressedTexelBlockByteSize + offset;</pre>  <p><code>arrayPitch</code> is undefined for images that were not created as arrays. <code>depthPitch</code> is defined only for 3D images.</p>   <p>For color formats, the <code>aspectMask</code> member of <code>VkImageSubresource</code> <strong>must</strong> be <code>VK_IMAGE_ASPECT_COLOR_BIT</code>. For depth/stencil formats, <code>aspectMask</code> <strong>must</strong> be either <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> or <code>VK_IMAGE_ASPECT_STENCIL_BIT</code>. On implementations that store depth and stencil aspects separately, querying each of these image subresource layouts will return a different <code>offset</code> and <code>size</code> representing the region of memory used for that aspect. On implementations that store depth and stencil aspects interleaved, the same <code>offset</code> and <code>size</code> are returned and represent the interleaved memory allocation.</p>    <h4 id="_see_also_265">See Also</h4>  <p><code>VkDeviceSize</code>, <a href="#vkGetImageSubresourceLayout">vkGetImageSubresourceLayout</a></p>    <h4 id="_document_notes_265">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubresourceLayout">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubresourceLayout</a></p>         <h3 id="_vkvertexinputattributedescription_3">VkVertexInputAttributeDescription(3)</h3>  <h4 id="_name_266">Name</h4>  <p>VkVertexInputAttributeDescription - Structure specifying vertex input attribute description</p>    <h4 id="_c_specification_266">C Specification</h4>  <p>Each vertex input attribute is specified by an instance of the <code>VkVertexInputAttributeDescription</code> structure.</p>   <p>The <code>VkVertexInputAttributeDescription</code> structure is defined as:</p>  <pre id="VkVertexInputAttributeDescription" data-language="c++">typedef struct VkVertexInputAttributeDescription {
    uint32_t    location;
    uint32_t    binding;
    VkFormat    format;
    uint32_t    offset;
} VkVertexInputAttributeDescription;</pre>   <h4 id="_members_104">Members</h4>  <ul> <li> <code>location</code> is the shader binding location number for this attribute. </li> <li> <code>binding</code> is the binding number which this attribute takes its data from. </li> <li> <code>format</code> is the size and type of the vertex attribute data. </li> <li> <code>offset</code> is a byte offset of this attribute relative to the start of an element in the vertex input binding. </li> </ul>    <h4 id="_description_266">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkVertexInputAttributeDescription-location-00620">  <code>location</code> <strong>must</strong> be less than <code>VkPhysicalDeviceLimits</code>::<code>maxVertexInputAttributes</code> </li> <li id="VUID-VkVertexInputAttributeDescription-binding-00621">  <code>binding</code> <strong>must</strong> be less than <code>VkPhysicalDeviceLimits</code>::<code>maxVertexInputBindings</code> </li> <li id="VUID-VkVertexInputAttributeDescription-offset-00622">  <code>offset</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxVertexInputAttributeOffset</code> </li> <li id="VUID-VkVertexInputAttributeDescription-format-00623">  <code>format</code> <strong>must</strong> be allowed as a vertex buffer format, as specified by the <code>VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT</code> flag in <code>VkFormatProperties</code>::<code>bufferFeatures</code> returned by <code>vkGetPhysicalDeviceFormatProperties</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkVertexInputAttributeDescription-format-parameter">  <code>format</code> <strong>must</strong> be a valid <a href="#VkFormat">VkFormat</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_266">See Also</h4>  <p><a href="#VkFormat">VkFormat</a>, <a href="#VkPipelineVertexInputStateCreateInfo">VkPipelineVertexInputStateCreateInfo</a></p>    <h4 id="_document_notes_266">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkVertexInputAttributeDescription">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkVertexInputAttributeDescription</a></p>         <h3 id="_vkvertexinputbindingdescription_3">VkVertexInputBindingDescription(3)</h3>  <h4 id="_name_267">Name</h4>  <p>VkVertexInputBindingDescription - Structure specifying vertex input binding description</p>    <h4 id="_c_specification_267">C Specification</h4>  <p>The <code>VkVertexInputBindingDescription</code> structure is defined as:</p>  <pre id="VkVertexInputBindingDescription" data-language="c++">typedef struct VkVertexInputBindingDescription {
    uint32_t             binding;
    uint32_t             stride;
    VkVertexInputRate    inputRate;
} VkVertexInputBindingDescription;</pre>   <h4 id="_members_105">Members</h4>  <ul> <li> <code>binding</code> is the binding number that this structure describes. </li> <li> <code>stride</code> is the distance in bytes between two consecutive elements within the buffer. </li> <li> <code>inputRate</code> is a <a href="#VkVertexInputRate">VkVertexInputRate</a> value specifying whether vertex attribute addressing is a function of the vertex index or of the instance index. </li> </ul>    <h4 id="_description_267">Description</h4> <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkVertexInputBindingDescription-binding-00618">  <code>binding</code> <strong>must</strong> be less than <code>VkPhysicalDeviceLimits</code>::<code>maxVertexInputBindings</code> </li> <li id="VUID-VkVertexInputBindingDescription-stride-00619">  <code>stride</code> <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxVertexInputBindingStride</code> </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkVertexInputBindingDescription-inputRate-parameter">  <code>inputRate</code> <strong>must</strong> be a valid <a href="#VkVertexInputRate">VkVertexInputRate</a> value </li> </ul>   </blockquote>   <h4 id="_see_also_267">See Also</h4>  <p><a href="#VkPipelineVertexInputStateCreateInfo">VkPipelineVertexInputStateCreateInfo</a>, <a href="#VkVertexInputRate">VkVertexInputRate</a></p>    <h4 id="_document_notes_267">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkVertexInputBindingDescription">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkVertexInputBindingDescription</a></p>         <h3 id="_vkviewport_3">VkViewport(3)</h3>  <h4 id="_name_268">Name</h4>  <p>VkViewport - Structure specifying a viewport</p>    <h4 id="_c_specification_268">C Specification</h4>  <p>The <code>VkViewport</code> structure is defined as:</p>  <pre id="VkViewport" data-language="c++">typedef struct VkViewport {
    float    x;
    float    y;
    float    width;
    float    height;
    float    minDepth;
    float    maxDepth;
} VkViewport;</pre>   <h4 id="_members_106">Members</h4>  <ul> <li> <code>x</code> and <code>y</code> are the viewport’s upper left corner (x,y). </li> <li> <code>width</code> and <code>height</code> are the viewport’s width and height, respectively. </li> <li> <code>minDepth</code> and <code>maxDepth</code> are the depth range for the viewport. It is valid for <code>minDepth</code> to be greater than or equal to <code>maxDepth</code>. </li> </ul>    <h4 id="_description_268">Description</h4>  <p>The framebuffer depth coordinate <code>z</code><sub>f</sub> <strong>may</strong> be represented using either a fixed-point or floating-point representation. However, a floating-point representation <strong>must</strong> be used if the depth/stencil attachment has a floating-point depth component. If an m-bit fixed-point representation is used, we assume that it represents each value \(\frac{k}{2^m - 1}\), where k ∈ { 0, 1, …​, 2<sup>m</sup>-1 }, as k (e.g. 1.0 is represented in binary as a string of all ones).</p>   <p>The viewport parameters shown in the above equations are found from these values as</p>  <div class="dlist"> <dl>  <dd> o<sub>x</sub> = <code>x</code> + <code>width</code> / 2 </dd>  <dd> o<sub>y</sub> = <code>y</code> + <code>height</code> / 2 </dd>  <dd> o<sub>z</sub> = <code>minDepth</code> </dd>  <dd> p<sub>x</sub> = <code>width</code> </dd>  <dd> p<sub>y</sub> = <code>height</code> </dd>  <dd> p<sub>z</sub> = <code>maxDepth</code> - <code>minDepth</code>. </dd> </dl> </div>  <p>The width and height of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxViewportDimensions">implementation-dependent maximum viewport dimensions</a> <strong>must</strong> be greater than or equal to the width and height of the largest image which <strong>can</strong> be created and attached to a framebuffer.</p>   <p>The floating-point viewport bounds are represented with an <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-viewportSubPixelBits">implementation-dependent precision</a>.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkViewport-width-01227">  <code>width</code> <strong>must</strong> be greater than <code>0.0</code> and less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxViewportDimensions</code>[0] </li> <li id="VUID-VkViewport-height-01228">  <code>height</code> <strong>must</strong> be greater than <code>0.0</code> and less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxViewportDimensions</code>[1] </li> <li id="VUID-VkViewport-x-01231">  <code>x</code> and <code>y</code> <strong>must</strong> each be between <code>viewportBoundsRange</code>[0] and <code>viewportBoundsRange</code>[1], inclusive </li> <li id="VUID-VkViewport-x-01232">  (<code>x</code> + <code>width</code>) <strong>must</strong> be less than or equal to <code>viewportBoundsRange</code>[1] </li> <li id="VUID-VkViewport-y-01233">  (<code>y</code> + <code>height</code>) <strong>must</strong> be less than or equal to <code>viewportBoundsRange</code>[1] </li> <li id="VUID-VkViewport-minDepth-01234">  <code>minDepth</code> <strong>must</strong> be between <code>0.0</code> and <code>1.0</code>, inclusive </li> <li id="VUID-VkViewport-maxDepth-01235">  <code>maxDepth</code> <strong>must</strong> be between <code>0.0</code> and <code>1.0</code>, inclusive </li> </ul>   </blockquote>   <h4 id="_see_also_268">See Also</h4>  <p><a href="#VkPipelineViewportStateCreateInfo">VkPipelineViewportStateCreateInfo</a>, <a href="#vkCmdSetViewport">vkCmdSetViewport</a></p>    <h4 id="_document_notes_268">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkViewport">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkViewport</a></p>         <h3 id="_vkwritedescriptorset_3">VkWriteDescriptorSet(3)</h3>  <h4 id="_name_269">Name</h4>  <p>VkWriteDescriptorSet - Structure specifying the parameters of a descriptor set write operation</p>    <h4 id="_c_specification_269">C Specification</h4>  <p>The <code>VkWriteDescriptorSet</code> structure is defined as:</p>  <pre id="VkWriteDescriptorSet" data-language="c++">typedef struct VkWriteDescriptorSet {
    VkStructureType                  sType;
    const void*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    const VkDescriptorImageInfo*     pImageInfo;
    const VkDescriptorBufferInfo*    pBufferInfo;
    const VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet;</pre>   <h4 id="_members_107">Members</h4>  <ul> <li> <code>sType</code> is the type of this structure. </li> <li> <code>pNext</code> is <code>NULL</code> or a pointer to an extension-specific structure. </li> <li> <code>dstSet</code> is the destination descriptor set to update. </li> <li> <code>dstBinding</code> is the descriptor binding within that set. </li> <li> <code>dstArrayElement</code> is the starting element in that array. </li> <li> <code>descriptorCount</code> is the number of descriptors to update (the number of elements in <code>pImageInfo</code>, <code>pBufferInfo</code>, or <code>pTexelBufferView</code>). </li> <li> <code>descriptorType</code> is a <a href="#VkDescriptorType">VkDescriptorType</a> specifying the type of each descriptor in <code>pImageInfo</code>, <code>pBufferInfo</code>, or <code>pTexelBufferView</code>, as described below. It <strong>must</strong> be the same type as that specified in <code>VkDescriptorSetLayoutBinding</code> for <code>dstSet</code> at <code>dstBinding</code>. The type of the descriptor also controls which array the descriptors are taken from. </li> <li> <code>pImageInfo</code> points to an array of <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a> structures or is ignored, as described below. </li> <li> <code>pBufferInfo</code> points to an array of <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> structures or is ignored, as described below. </li> <li> <code>pTexelBufferView</code> points to an array of <a href="#VkBufferView">VkBufferView</a> handles as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-buffer-views">Buffer Views</a> section or is ignored, as described below. </li> </ul>    <h4 id="_description_269">Description</h4>  <p>Only one of <code>pImageInfo</code>, <code>pBufferInfo</code>, or <code>pTexelBufferView</code> members is used according to the descriptor type specified in the <code>descriptorType</code> member of the containing <code>VkWriteDescriptorSet</code> structure, as specified below.</p>   <p>If the <code>dstBinding</code> has fewer than <code>descriptorCount</code> array elements remaining starting from <code>dstArrayElement</code>, then the remainder will be used to update the subsequent binding - <code>dstBinding</code>+1 starting at array element zero. If a binding has a <code>descriptorCount</code> of zero, it is skipped. This behavior applies recursively, with the update affecting consecutive bindings as needed to update all <code>descriptorCount</code> descriptors.</p>  <blockquote>  <h5 class="title">Valid Usage</h5>  <ul> <li id="VUID-VkWriteDescriptorSet-dstBinding-00315">  <code>dstBinding</code> <strong>must</strong> be less than or equal to the maximum value of <code>binding</code> of all <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a> structures specified when <code>dstSet</code>’s descriptor set layout was created </li> <li id="VUID-VkWriteDescriptorSet-dstBinding-00316">  <code>dstBinding</code> <strong>must</strong> be a binding with a non-zero <code>descriptorCount</code> </li> <li id="VUID-VkWriteDescriptorSet-descriptorCount-00317">  All consecutive bindings updated via a single <code>VkWriteDescriptorSet</code> structure, except those with a <code>descriptorCount</code> of zero, <strong>must</strong> have identical <code>descriptorType</code> and <code>stageFlags</code>. </li> <li id="VUID-VkWriteDescriptorSet-descriptorCount-00318">  All consecutive bindings updated via a single <code>VkWriteDescriptorSet</code> structure, except those with a <code>descriptorCount</code> of zero, <strong>must</strong> all either use immutable samplers or <strong>must</strong> all not use immutable samplers. </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00319">  <code>descriptorType</code> <strong>must</strong> match the type of <code>dstBinding</code> within <code>dstSet</code> </li> <li id="VUID-VkWriteDescriptorSet-dstSet-00320">  <code>dstSet</code> <strong>must</strong> be a valid <a href="#VkDescriptorSet">VkDescriptorSet</a> handle </li> <li id="VUID-VkWriteDescriptorSet-dstArrayElement-00321">  The sum of <code>dstArrayElement</code> and <code>descriptorCount</code> <strong>must</strong> be less than or equal to the number of array elements in the descriptor set binding specified by <code>dstBinding</code>, and all applicable consecutive bindings, as described by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive">html/vkspec.html#descriptorsets-updates-consecutive</a> </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00322">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, <code>pImageInfo</code> <strong>must</strong> be a pointer to an array of <code>descriptorCount</code> valid <code>VkDescriptorImageInfo</code> structures </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00323">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>, <code>pTexelBufferView</code> <strong>must</strong> be a pointer to an array of <code>descriptorCount</code> valid <code>VkBufferView</code> handles </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00324">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>, <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, <code>pBufferInfo</code> <strong>must</strong> be a pointer to an array of <code>descriptorCount</code> valid <code>VkDescriptorBufferInfo</code> structures </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00325">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLER</code> or <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and <code>dstSet</code> was not allocated with a layout that included immutable samplers for <code>dstBinding</code> with <code>descriptorType</code>, the <code>sampler</code> member of any given element of <code>pImageInfo</code> <strong>must</strong> be a valid <code>VkSampler</code> object </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00326">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, the <code>imageView</code> and <code>imageLayout</code> members of any given element of <code>pImageInfo</code> <strong>must</strong> be a valid <code>VkImageView</code> and <a href="#VkImageLayout">VkImageLayout</a>, respectively </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-01402">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, for each descriptor that will be accessed via load or store operations the <code>imageLayout</code> member for corresponding elements of <code>pImageInfo</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00327">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, the <code>offset</code> member of any given element of <code>pBufferInfo</code> <strong>must</strong> be a multiple of <code>VkPhysicalDeviceLimits</code>::<code>minUniformBufferOffsetAlignment</code> </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00328">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, the <code>offset</code> member of any given element of <code>pBufferInfo</code> <strong>must</strong> be a multiple of <code>VkPhysicalDeviceLimits</code>::<code>minStorageBufferOffsetAlignment</code> </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00329">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>, <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>, or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, the <code>buffer</code> member of any given element of <code>pBufferInfo</code> that is non-sparse <strong>must</strong> be bound completely and contiguously to a single <code>VkDeviceMemory</code> object </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00330">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, the <code>buffer</code> member of any given element of <code>pBufferInfo</code> <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</code> set </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00331">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, the <code>buffer</code> member of any given element of <code>pBufferInfo</code> <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</code> set </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00332">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, the <code>range</code> member of any given element of <code>pBufferInfo</code>, or the effective range if <code>range</code> is <code>VK_WHOLE_SIZE</code>, <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxUniformBufferRange</code> </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00333">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>, the <code>range</code> member of any given element of <code>pBufferInfo</code>, or the effective range if <code>range</code> is <code>VK_WHOLE_SIZE</code>, <strong>must</strong> be less than or equal to <code>VkPhysicalDeviceLimits</code>::<code>maxStorageBufferRange</code> </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00334">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>, the <code>VkBuffer</code> that any given element of <code>pTexelBufferView</code> was created from <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> set </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00335">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>, the <code>VkBuffer</code> that any given element of <code>pTexelBufferView</code> was created from <strong>must</strong> have been created with <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code> set </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00336">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code> or <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, the <code>imageView</code> member of any given element of <code>pImageInfo</code> <strong>must</strong> have been created with the identity swizzle </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00337">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> or <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, the <code>imageView</code> member of any given element of <code>pImageInfo</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_SAMPLED_BIT</code> set </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-01403">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> or <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, the <code>imageLayout</code> member of any given element of <code>pImageInfo</code> <strong>must</strong> be <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>, <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code> or <code>VK_IMAGE_LAYOUT_GENERAL</code> </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00338">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>, the <code>imageView</code> member of any given element of <code>pImageInfo</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> set </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-00339">  If <code>descriptorType</code> is <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, the <code>imageView</code> member of any given element of <code>pImageInfo</code> <strong>must</strong> have been created with <code>VK_IMAGE_USAGE_STORAGE_BIT</code> set </li> </ul>   </blockquote> <blockquote>  <h5 class="title">Valid Usage (Implicit)</h5>  <ul> <li id="VUID-VkWriteDescriptorSet-sType-sType">  <code>sType</code> <strong>must</strong> be <code>VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET</code> </li> <li id="VUID-VkWriteDescriptorSet-pNext-pNext">  <code>pNext</code> <strong>must</strong> be <code>NULL</code> </li> <li id="VUID-VkWriteDescriptorSet-descriptorType-parameter">  <code>descriptorType</code> <strong>must</strong> be a valid <a href="#VkDescriptorType">VkDescriptorType</a> value </li> <li id="VUID-VkWriteDescriptorSet-descriptorCount-arraylength">  <code>descriptorCount</code> <strong>must</strong> be greater than <code>0</code> </li> <li id="VUID-VkWriteDescriptorSet-commonparent">  Both of <code>dstSet</code>, and the elements of <code>pTexelBufferView</code> that are valid handles <strong>must</strong> have been created, allocated, or retrieved from the same <code>VkDevice</code> </li> </ul>   </blockquote>   <h4 id="_see_also_269">See Also</h4>  <p><a href="#VkBufferView">VkBufferView</a>, <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a>, <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>, <a href="#VkDescriptorSet">VkDescriptorSet</a>, <a href="#VkDescriptorType">VkDescriptorType</a>, <a href="#VkStructureType">VkStructureType</a>, <a href="#vkUpdateDescriptorSets">vkUpdateDescriptorSets</a></p>    <h4 id="_document_notes_269">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkWriteDescriptorSet">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkWriteDescriptorSet</a></p>           <h2 id="enums">Enumerations</h2>   <h3 id="_vkaccessflagbits_3">VkAccessFlagBits(3)</h3>  <h4 id="_name_270">Name</h4>  <p>VkAccessFlagBits - Bitmask specifying memory access types that will participate in a memory dependency</p>    <h4 id="_c_specification_270">C Specification</h4>  <p>Memory in Vulkan <strong>can</strong> be accessed from within shader invocations and via some fixed-function stages of the pipeline. The <em>access type</em> is a function of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets">descriptor type</a> used, or how a fixed-function stage accesses memory. Each access type corresponds to a bit flag in <a href="#VkAccessFlagBits">VkAccessFlagBits</a>.</p>   <p>Some synchronization commands take sets of access types as parameters to define the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scopes</a> of a memory dependency. If a synchronization command includes a source access mask, its first <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> only includes accesses via the access types specified in that mask. Similarly, if a synchronization command includes a destination access mask, its second <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scope</a> only includes accesses via the access types specified in that mask.</p>   <p>Access types that <strong>can</strong> be set in an access mask include:</p>  <pre id="VkAccessFlagBits" data-language="c++">typedef enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
    VK_ACCESS_HOST_READ_BIT = 0x00002000,
    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
} VkAccessFlagBits;</pre>   <h4 id="_description_270">Description</h4>  <ul> <li> <code>VK_ACCESS_INDIRECT_COMMAND_READ_BIT</code> specifies read access to an indirect command structure read as part of an indirect drawing or dispatch command. </li> <li> <code>VK_ACCESS_INDEX_READ_BIT</code> specifies read access to an index buffer as part of an indexed drawing command, bound by <a href="#vkCmdBindIndexBuffer">vkCmdBindIndexBuffer</a>. </li> <li> <code>VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT</code> specifies read access to a vertex buffer as part of a drawing command, bound by <a href="#vkCmdBindVertexBuffers">vkCmdBindVertexBuffers</a>. </li> <li> <code>VK_ACCESS_UNIFORM_READ_BIT</code> specifies read access to a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-uniformbuffer">uniform buffer</a>. </li> <li> <code>VK_ACCESS_INPUT_ATTACHMENT_READ_BIT</code> specifies read access to an <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass">input attachment</a> within a renderpass during fragment shading. </li> <li> <code>VK_ACCESS_SHADER_READ_BIT</code> specifies read access to a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagebuffer">storage buffer</a>, <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-uniformtexelbuffer">uniform texel buffer</a>, <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagetexelbuffer">storage texel buffer</a>, <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-sampledimage">sampled image</a>, or <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storageimage">storage image</a>. </li> <li> <code>VK_ACCESS_SHADER_WRITE_BIT</code> specifies write access to a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagebuffer">storage buffer</a>, <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storagetexelbuffer">storage texel buffer</a>, or <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storageimage">storage image</a>. </li> <li> <code>VK_ACCESS_COLOR_ATTACHMENT_READ_BIT</code> specifies read access to a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass">color attachment</a>, such as via <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-blending">blending</a>, <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-logicop">logic operations</a>, or via certain <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-load-store-ops">subpass load operations</a>. </li> <li> <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code> specifies write access to a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass">color or resolve attachment</a> during a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass">render pass</a> or via certain <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-load-store-ops">subpass load and store operations</a>. </li> <li> <code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT</code> specifies read access to a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass">depth/stencil attachment</a>, via <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-ds-state">depth or stencil operations</a> or via certain <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-load-store-ops">subpass load operations</a>. </li> <li> <code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</code> specifies write access to a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass">depth/stencil attachment</a>, via <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fragops-ds-state">depth or stencil operations</a> or via certain <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-load-store-ops">subpass load and store operations</a>. </li> <li> <code>VK_ACCESS_TRANSFER_READ_BIT</code> specifies read access to an image or buffer in a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#copies">copy</a> operation. </li> <li> <code>VK_ACCESS_TRANSFER_WRITE_BIT</code> specifies write access to an image or buffer in a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#clears">clear</a> or <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#copies">copy</a> operation. </li> <li> <code>VK_ACCESS_HOST_READ_BIT</code> specifies read access by a host operation. Accesses of this type are not performed through a resource, but directly on memory. </li> <li> <code>VK_ACCESS_HOST_WRITE_BIT</code> specifies write access by a host operation. Accesses of this type are not performed through a resource, but directly on memory. </li> <li> <code>VK_ACCESS_MEMORY_READ_BIT</code> specifies read access via non-specific entities. These entities include the Vulkan device and host, but <strong>may</strong> also include entities external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in a destination access mask, makes all available writes visible to all future read accesses on entities known to the Vulkan device. </li> <li> <code>VK_ACCESS_MEMORY_WRITE_BIT</code> specifies write access via non-specific entities. These entities include the Vulkan device and host, but <strong>may</strong> also include entities external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in a source access mask, all writes that are performed by entities known to the Vulkan device are made available. When included in a destination access mask, makes all available writes visible to all future write accesses on entities known to the Vulkan device. </li> </ul>   <p>Certain access types are only performed by a subset of pipeline stages. Any synchronization command that takes both stage masks and access masks uses both to define the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes">access scopes</a> - only the specified access types performed by the specified stages are included in the access scope. An application <strong>must</strong> not specify an access flag in a synchronization command if it does not include a pipeline stage in the corresponding stage mask that is able to perform accesses of that type. The following table lists, for each access flag, which pipeline stages <strong>can</strong> perform that type of access.</p>  <div class="_table"><table id="synchronization-access-types-supported" class="tableblock frame-all grid-all spread"> <caption class="title">Table 7. Supported access types</caption> <colgroup> <col style="width: 50%;"> <col style="width: 50%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Access flag</th> <th class="tableblock halign-left valign-top">Supported pipeline stages</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_INDIRECT_COMMAND_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_INDEX_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_UNIFORM_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code>, or <code>VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_INPUT_ATTACHMENT_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_SHADER_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code>, or <code>VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_SHADER_WRITE_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code>, <code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code>, or <code>VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_COLOR_ATTACHMENT_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code>, or <code>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code>, or <code>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_TRANSFER_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_TRANSFER_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_TRANSFER_WRITE_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_TRANSFER_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_HOST_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_HOST_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_HOST_WRITE_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_PIPELINE_STAGE_HOST_BIT</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_MEMORY_READ_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_ACCESS_MEMORY_WRITE_BIT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td> </tr> </tbody> </table></div>  <p>If a memory object does not have the <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> property, then <a href="#vkFlushMappedMemoryRanges">vkFlushMappedMemoryRanges</a> <strong>must</strong> be called in order to guarantee that writes to the memory object from the host are made visible to the <code>VK_ACCESS_HOST_WRITE_BIT</code> <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types">access type</a>, where it <strong>can</strong> be further made available to the device by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization">synchronization commands</a>. Similarly, <a href="#vkInvalidateMappedMemoryRanges">vkInvalidateMappedMemoryRanges</a> <strong>must</strong> be called to guarantee that writes which are visible to the <code>VK_ACCESS_HOST_READ_BIT</code> <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types">access type</a> are made visible to host operations.</p>   <p>If the memory object does have the <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> property flag, writes to the memory object from the host are automatically made visible to the <code>VK_ACCESS_HOST_WRITE_BIT</code> <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types">access type</a>. Similarly, writes made visible to the <code>VK_ACCESS_HOST_READ_BIT</code> <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types">access type</a> are automatically made visible to the host.</p>  <blockquote> <h5 class="title">Note</h5>  <p>The <a href="#vkQueueSubmit">vkQueueSubmit</a> command <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-host-writes">automatically guarantees that host writes flushed to <code>VK_ACCESS_HOST_WRITE_BIT</code> are made available</a> if they were flushed before the command executed, so in most cases an explicit memory barrier is not needed for this case. In the few circumstances where a submit does not occur between the host write and the device read access, writes <strong>can</strong> be made available by using an explicit memory barrier.</p>  </blockquote>   <h4 id="_see_also_270">See Also</h4>  <p><a href="#VkAccessFlags">VkAccessFlags</a></p>    <h4 id="_document_notes_270">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAccessFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAccessFlagBits</a></p>         <h3 id="_vkattachmentdescriptionflagbits_3">VkAttachmentDescriptionFlagBits(3)</h3>  <h4 id="_name_271">Name</h4>  <p>VkAttachmentDescriptionFlagBits - Bitmask specifying additional properties of an attachment</p>    <h4 id="_c_specification_271">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkAttachmentDescription">VkAttachmentDescription</a>::<code>flags</code> describing additional properties of the attachment are:</p>  <pre id="VkAttachmentDescriptionFlagBits" data-language="c++">typedef enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
} VkAttachmentDescriptionFlagBits;</pre>   <h4 id="_description_271">Description</h4>  <ul> <li> <code>VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT</code> specifies that the attachment aliases the same device memory as other attachments. </li> </ul>    <h4 id="_see_also_271">See Also</h4>  <p><a href="#VkAttachmentDescriptionFlags">VkAttachmentDescriptionFlags</a></p>    <h4 id="_document_notes_271">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentDescriptionFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentDescriptionFlagBits</a></p>         <h3 id="_vkattachmentloadop_3">VkAttachmentLoadOp(3)</h3>  <h4 id="_name_272">Name</h4>  <p>VkAttachmentLoadOp - Specify how contents of an attachment are treated at the beginning of a subpass</p>    <h4 id="_c_specification_272">C Specification</h4>  <p>Possible values of <a href="#VkAttachmentDescription">VkAttachmentDescription</a>::<code>loadOp</code> and <code>stencilLoadOp</code>, specifying how the contents of the attachment are treated, are:</p>  <pre id="VkAttachmentLoadOp" data-language="c++">typedef enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
} VkAttachmentLoadOp;</pre>   <h4 id="_description_272">Description</h4>  <ul> <li> <code>VK_ATTACHMENT_LOAD_OP_LOAD</code> specifies that the previous contents of the image within the render area will be preserved. For attachments with a depth/stencil format, this uses the access type <code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT</code>. For attachments with a color format, this uses the access type <code>VK_ACCESS_COLOR_ATTACHMENT_READ_BIT</code>. </li> <li> <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code> specifies that the contents within the render area will be cleared to a uniform value, which is specified when a render pass instance is begun. For attachments with a depth/stencil format, this uses the access type <code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</code>. For attachments with a color format, this uses the access type <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code>. </li> <li> <code>VK_ATTACHMENT_LOAD_OP_DONT_CARE</code> specifies that the previous contents within the area need not be preserved; the contents of the attachment will be undefined inside the render area. For attachments with a depth/stencil format, this uses the access type <code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</code>. For attachments with a color format, this uses the access type <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code>. </li> </ul>    <h4 id="_see_also_272">See Also</h4>  <p><a href="#VkAttachmentDescription">VkAttachmentDescription</a></p>    <h4 id="_document_notes_272">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentLoadOp">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentLoadOp</a></p>         <h3 id="_vkattachmentstoreop_3">VkAttachmentStoreOp(3)</h3>  <h4 id="_name_273">Name</h4>  <p>VkAttachmentStoreOp - Specify how contents of an attachment are treated at the end of a subpass</p>    <h4 id="_c_specification_273">C Specification</h4>  <p>Possible values of <a href="#VkAttachmentDescription">VkAttachmentDescription</a>::<code>storeOp</code> and <code>stencilStoreOp</code>, specifying how the contents of the attachment are treated, are:</p>  <pre id="VkAttachmentStoreOp" data-language="c++">typedef enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
} VkAttachmentStoreOp;</pre>   <h4 id="_description_273">Description</h4>  <ul> <li> <code>VK_ATTACHMENT_STORE_OP_STORE</code> specifies the contents generated during the render pass and within the render area are written to memory. For attachments with a depth/stencil format, this uses the access type <code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</code>. For attachments with a color format, this uses the access type <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code>. </li> <li> <code>VK_ATTACHMENT_STORE_OP_DONT_CARE</code> specifies the contents within the render area are not needed after rendering, and <strong>may</strong> be discarded; the contents of the attachment will be undefined inside the render area. For attachments with a depth/stencil format, this uses the access type <code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</code>. For attachments with a color format, this uses the access type <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code>. </li> </ul>    <h4 id="_see_also_273">See Also</h4>  <p><a href="#VkAttachmentDescription">VkAttachmentDescription</a></p>    <h4 id="_document_notes_273">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentStoreOp">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentStoreOp</a></p>         <h3 id="_vkblendfactor_3">VkBlendFactor(3)</h3>  <h4 id="_name_274">Name</h4>  <p>VkBlendFactor - Framebuffer blending factors</p>    <h4 id="_c_specification_274">C Specification</h4>  <p>The source and destination color and alpha blending factors are selected from the enum:</p>  <pre id="VkBlendFactor" data-language="c++">typedef enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
} VkBlendFactor;</pre>   <h4 id="_description_274">Description</h4>  <p>The semantics of each enum value is described in the table below:</p>  <div class="_table"><table class="tableblock frame-all grid-all spread"> <caption class="title">Table 8. Blend Factors</caption> <colgroup> <col style="width: 59%;"> <col style="width: 28%;"> <col style="width: 13%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">VkBlendFactor</th> <th class="tableblock halign-left valign-top">RGB Blend Factors (S<sub>r</sub>,S<sub>g</sub>,S<sub>b</sub>) or (D<sub>r</sub>,D<sub>g</sub>,D<sub>b</sub>)</th> <th class="tableblock halign-left valign-top">Alpha Blend Factor (S<sub>a</sub> or D<sub>a</sub>)</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_ZERO</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(0,0,0)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_ONE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(1,1,1)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_SRC_COLOR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(R<sub>s0</sub>,G<sub>s0</sub>,B<sub>s0</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A<sub>s0</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(1-R<sub>s0</sub>,1-G<sub>s0</sub>,1-B<sub>s0</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">1-A<sub>s0</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_DST_COLOR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(R<sub>d</sub>,G<sub>d</sub>,B<sub>d</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A<sub>d</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(1-R<sub>d</sub>,1-G<sub>d</sub>,1-B<sub>d</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">1-A<sub>d</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_SRC_ALPHA</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(A<sub>s0</sub>,A<sub>s0</sub>,A<sub>s0</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A<sub>s0</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(1-A<sub>s0</sub>,1-A<sub>s0</sub>,1-A<sub>s0</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">1-A<sub>s0</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_DST_ALPHA</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(A<sub>d</sub>,A<sub>d</sub>,A<sub>d</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A<sub>d</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(1-A<sub>d</sub>,1-A<sub>d</sub>,1-A<sub>d</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">1-A<sub>d</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_CONSTANT_COLOR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(R<sub>c</sub>,G<sub>c</sub>,B<sub>c</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A<sub>c</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(1-R<sub>c</sub>,1-G<sub>c</sub>,1-B<sub>c</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">1-A<sub>c</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_CONSTANT_ALPHA</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(A<sub>c</sub>,A<sub>c</sub>,A<sub>c</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A<sub>c</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(1-A<sub>c</sub>,1-A<sub>c</sub>,1-A<sub>c</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">1-A<sub>c</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_SRC_ALPHA_SATURATE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(f,f,f); f = min(A<sub>s0</sub>,1-A<sub>d</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_SRC1_COLOR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(R<sub>s1</sub>,G<sub>s1</sub>,B<sub>s1</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A<sub>s1</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(1-R<sub>s1</sub>,1-G<sub>s1</sub>,1-B<sub>s1</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">1-A<sub>s1</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_SRC1_ALPHA</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(A<sub>s1</sub>,A<sub>s1</sub>,A<sub>s1</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A<sub>s1</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">(1-A<sub>s1</sub>,1-A<sub>s1</sub>,1-A<sub>s1</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">1-A<sub>s1</sub></p></td> </tr> </tbody> </table></div>  <p>In this table, the following conventions are used:</p>   <ul> <li> R<sub>s0</sub>,G<sub>s0</sub>,B<sub>s0</sub> and A<sub>s0</sub> represent the first source color R, G, B, and A components, respectively, for the fragment output location corresponding to the color attachment being blended. </li> <li> R<sub>s1</sub>,G<sub>s1</sub>,B<sub>s1</sub> and A<sub>s1</sub> represent the second source color R, G, B, and A components, respectively, used in dual source blending modes, for the fragment output location corresponding to the color attachment being blended. </li> <li> R<sub>d</sub>,G<sub>d</sub>,B<sub>d</sub> and A<sub>d</sub> represent the R, G, B, and A components of the destination color. That is, the color currently in the corresponding color attachment for this fragment/sample. </li> <li> R<sub>c</sub>,G<sub>c</sub>,B<sub>c</sub> and A<sub>c</sub> represent the blend constant R, G, B, and A components, respectively. </li> </ul>    <h4 id="_see_also_274">See Also</h4>  <p><a href="#VkPipelineColorBlendAttachmentState">VkPipelineColorBlendAttachmentState</a></p>    <h4 id="_document_notes_274">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBlendFactor">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBlendFactor</a></p>         <h3 id="_vkblendop_3">VkBlendOp(3)</h3>  <h4 id="_name_275">Name</h4>  <p>VkBlendOp - Framebuffer blending operations</p>    <h4 id="_c_specification_275">C Specification</h4>  <p>Once the source and destination blend factors have been selected, they along with the source and destination components are passed to the blending operations. RGB and alpha components <strong>can</strong> use different operations. Possible values of <a href="#VkBlendOp">VkBlendOp</a>, specifying the operations, are:</p>  <pre id="VkBlendOp" data-language="c++">typedef enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
} VkBlendOp;</pre>   <h4 id="_description_275">Description</h4>   <p>The semantics of each basic blend operations is described in the table below:</p>  <div class="_table"><table class="tableblock frame-all grid-all spread"> <caption class="title">Table 9. Basic Blend Operations</caption> <colgroup> <col style="width: 45%;"> <col style="width: 30%;"> <col style="width: 25%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">VkBlendOp</th> <th class="tableblock halign-left valign-top">RGB Components</th> <th class="tableblock halign-left valign-top">Alpha Component</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_OP_ADD</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">R = R<sub>s0</sub> × S<sub>r</sub> + R<sub>d</sub> × D<sub>r</sub><br> G = G<sub>s0</sub> × S<sub>g</sub> + G<sub>d</sub> × D<sub>g</sub><br> B = B<sub>s0</sub> × S<sub>b</sub> + B<sub>d</sub> × D<sub>b</sub></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A = A<sub>s0</sub> × S<sub>a</sub> + A<sub>d</sub> × D<sub>a</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_OP_SUBTRACT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">R = R<sub>s0</sub> × S<sub>r</sub> - R<sub>d</sub> × D<sub>r</sub><br> G = G<sub>s0</sub> × S<sub>g</sub> - G<sub>d</sub> × D<sub>g</sub><br> B = B<sub>s0</sub> × S<sub>b</sub> - B<sub>d</sub> × D<sub>b</sub></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A = A<sub>s0</sub> × S<sub>a</sub> - A<sub>d</sub> × D<sub>a</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_OP_REVERSE_SUBTRACT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">R = R<sub>d</sub> × D<sub>r</sub> - R<sub>s0</sub> × S<sub>r</sub><br> G = G<sub>d</sub> × D<sub>g</sub> - G<sub>s0</sub> × S<sub>g</sub><br> B = B<sub>d</sub> × D<sub>b</sub> - B<sub>s0</sub> × S<sub>b</sub></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A = A<sub>d</sub> × D<sub>a</sub> - A<sub>s0</sub> × S<sub>a</sub></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_OP_MIN</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">R = min(R<sub>s0</sub>,R<sub>d</sub>)<br> G = min(G<sub>s0</sub>,G<sub>d</sub>)<br> B = min(B<sub>s0</sub>,B<sub>d</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A = min(A<sub>s0</sub>,A<sub>d</sub>)</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_BLEND_OP_MAX</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">R = max(R<sub>s0</sub>,R<sub>d</sub>)<br> G = max(G<sub>s0</sub>,G<sub>d</sub>)<br> B = max(B<sub>s0</sub>,B<sub>d</sub>)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A = max(A<sub>s0</sub>,A<sub>d</sub>)</p></td> </tr> </tbody> </table></div>  <p>In this table, the following conventions are used:</p>   <ul> <li> R<sub>s0</sub>, G<sub>s0</sub>, B<sub>s0</sub> and A<sub>s0</sub> represent the first source color R, G, B, and A components, respectively. </li> <li> R<sub>d</sub>, G<sub>d</sub>, B<sub>d</sub> and A<sub>d</sub> represent the R, G, B, and A components of the destination color. That is, the color currently in the corresponding color attachment for this fragment/sample. </li> <li> S<sub>r</sub>, S<sub>g</sub>, S<sub>b</sub> and S<sub>a</sub> represent the source blend factor R, G, B, and A components, respectively. </li> <li> D<sub>r</sub>, D<sub>g</sub>, D<sub>b</sub> and D<sub>a</sub> represent the destination blend factor R, G, B, and A components, respectively. </li> </ul>   <p>The blending operation produces a new set of values R, G, B and A, which are written to the framebuffer attachment. If blending is not enabled for this attachment, then R, G, B and A are assigned R<sub>s0</sub>, G<sub>s0</sub>, B<sub>s0</sub> and A<sub>s0</sub>, respectively.</p>   <p>If the color attachment is fixed-point, the components of the source and destination values and blend factors are each clamped to [0,1] or [-1,1] respectively for an unsigned normalized or signed normalized color attachment prior to evaluating the blend operations. If the color attachment is floating-point, no clamping occurs.</p>    <h4 id="_see_also_275">See Also</h4>  <p><a href="#VkPipelineColorBlendAttachmentState">VkPipelineColorBlendAttachmentState</a></p>    <h4 id="_document_notes_275">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBlendOp">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBlendOp</a></p>         <h3 id="_vkbordercolor_3">VkBorderColor(3)</h3>  <h4 id="_name_276">Name</h4>  <p>VkBorderColor - Specify border color used for texture lookups</p>    <h4 id="_c_specification_276">C Specification</h4>  <p>Possible values of <a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a>::<code>borderColor</code>, specifying the border color used for texture lookups, are:</p>  <pre id="VkBorderColor" data-language="c++">typedef enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
} VkBorderColor;</pre>   <h4 id="_description_276">Description</h4>  <ul> <li> <code>VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK</code> specifies a transparent, floating-point format, black color. </li> <li> <code>VK_BORDER_COLOR_INT_TRANSPARENT_BLACK</code> specifies a transparent, integer format, black color. </li> <li> <code>VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK</code> specifies an opaque, floating-point format, black color. </li> <li> <code>VK_BORDER_COLOR_INT_OPAQUE_BLACK</code> specifies an opaque, integer format, black color. </li> <li> <code>VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE</code> specifies an opaque, floating-point format, white color. </li> <li> <code>VK_BORDER_COLOR_INT_OPAQUE_WHITE</code> specifies an opaque, integer format, white color. </li> </ul>   <p>These colors are described in detail in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-replacement">Texel Replacement</a>.</p>    <h4 id="_see_also_276">See Also</h4>  <p><a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a></p>    <h4 id="_document_notes_276">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBorderColor">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBorderColor</a></p>         <h3 id="_vkbuffercreateflagbits_3">VkBufferCreateFlagBits(3)</h3>  <h4 id="_name_277">Name</h4>  <p>VkBufferCreateFlagBits - Bitmask specifying additional parameters of a buffer</p>    <h4 id="_c_specification_277">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkBufferCreateInfo">VkBufferCreateInfo</a>::<code>flags</code>, specifying additional parameters of a buffer, are:</p>  <pre id="VkBufferCreateFlagBits" data-language="c++">typedef enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
} VkBufferCreateFlagBits;</pre>   <h4 id="_description_277">Description</h4>  <ul> <li> <code>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</code> specifies that the buffer will be backed using sparse memory binding. </li> <li> <code>VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT</code> specifies that the buffer <strong>can</strong> be partially backed using sparse memory binding. Buffers created with this flag <strong>must</strong> also be created with the <code>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</code> flag. </li> <li> <code>VK_BUFFER_CREATE_SPARSE_ALIASED_BIT</code> specifies that the buffer will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another buffer (or another portion of the same buffer). Buffers created with this flag <strong>must</strong> also be created with the <code>VK_BUFFER_CREATE_SPARSE_BINDING_BIT</code> flag. </li> </ul>   <p>See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseresourcefeatures">Sparse Resource Features</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features">Physical Device Features</a> for details of the sparse memory features supported on a device.</p>    <h4 id="_see_also_277">See Also</h4>  <p><a href="#VkBufferCreateFlags">VkBufferCreateFlags</a></p>    <h4 id="_document_notes_277">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferCreateFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferCreateFlagBits</a></p>         <h3 id="_vkbufferusageflagbits_3">VkBufferUsageFlagBits(3)</h3>  <h4 id="_name_278">Name</h4>  <p>VkBufferUsageFlagBits - Bitmask specifying allowed usage of a buffer</p>    <h4 id="_c_specification_278">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkBufferCreateInfo">VkBufferCreateInfo</a>::<code>usage</code>, specifying usage behavior of a buffer, are:</p>  <pre id="VkBufferUsageFlagBits" data-language="c++">typedef enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
} VkBufferUsageFlagBits;</pre>   <h4 id="_description_278">Description</h4>  <ul> <li> <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> specifies that the buffer <strong>can</strong> be used as the source of a <em>transfer command</em> (see the definition of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-transfer"><code>VK_PIPELINE_STAGE_TRANSFER_BIT</code></a>). </li> <li> <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> specifies that the buffer <strong>can</strong> be used as the destination of a transfer command. </li> <li> <code>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</code> specifies that the buffer <strong>can</strong> be used to create a <code>VkBufferView</code> suitable for occupying a <code>VkDescriptorSet</code> slot of type <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code>. </li> <li> <code>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</code> specifies that the buffer <strong>can</strong> be used to create a <code>VkBufferView</code> suitable for occupying a <code>VkDescriptorSet</code> slot of type <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code>. </li> <li> <code>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</code> specifies that the buffer <strong>can</strong> be used in a <code>VkDescriptorBufferInfo</code> suitable for occupying a <code>VkDescriptorSet</code> slot either of type <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>. </li> <li> <code>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</code> specifies that the buffer <strong>can</strong> be used in a <code>VkDescriptorBufferInfo</code> suitable for occupying a <code>VkDescriptorSet</code> slot either of type <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code>. </li> <li> <code>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</code> specifies that the buffer is suitable for passing as the <code>buffer</code> parameter to <code>vkCmdBindIndexBuffer</code>. </li> <li> <code>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</code> specifies that the buffer is suitable for passing as an element of the <code>pBuffers</code> array to <code>vkCmdBindVertexBuffers</code>. </li> <li> <code>VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT</code> specifies that the buffer is suitable for passing as the <code>buffer</code> parameter to <code>vkCmdDrawIndirect</code>, <code>vkCmdDrawIndexedIndirect</code>, or <code>vkCmdDispatchIndirect</code>. </li> </ul>    <h4 id="_see_also_278">See Also</h4>  <p><a href="#VkBufferUsageFlags">VkBufferUsageFlags</a></p>    <h4 id="_document_notes_278">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferUsageFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferUsageFlagBits</a></p>         <h3 id="_vkcolorcomponentflagbits_3">VkColorComponentFlagBits(3)</h3>  <h4 id="_name_279">Name</h4>  <p>VkColorComponentFlagBits - Bitmask controlling which components are written to the framebuffer</p>    <h4 id="_c_specification_279">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkPipelineColorBlendAttachmentState">VkPipelineColorBlendAttachmentState</a>::<code>colorWriteMask</code> to determine whether the final color values R, G, B and A are written to the framebuffer attachment are:</p>  <pre id="VkColorComponentFlagBits" data-language="c++">typedef enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
} VkColorComponentFlagBits;</pre>   <h4 id="_description_279">Description</h4>  <ul> <li> <code>VK_COLOR_COMPONENT_R_BIT</code> specifies that the R value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified. </li> <li> <code>VK_COLOR_COMPONENT_G_BIT</code> specifies that the G value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified. </li> <li> <code>VK_COLOR_COMPONENT_B_BIT</code> specifies that the B value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified. </li> <li> <code>VK_COLOR_COMPONENT_A_BIT</code> specifies that the A value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified. </li> </ul>   <p>The color write mask operation is applied regardless of whether blending is enabled.</p>    <h4 id="_see_also_279">See Also</h4>  <p><a href="#VkColorComponentFlags">VkColorComponentFlags</a></p>    <h4 id="_document_notes_279">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkColorComponentFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkColorComponentFlagBits</a></p>         <h3 id="_vkcommandbufferlevel_3">VkCommandBufferLevel(3)</h3>  <h4 id="_name_280">Name</h4>  <p>VkCommandBufferLevel - Enumerant specifying a command buffer level</p>    <h4 id="_c_specification_280">C Specification</h4>  <p>Possible values of <a href="#VkCommandBufferAllocateInfo">VkCommandBufferAllocateInfo</a>::<code>flags</code>, specifying the command buffer level, are:</p>  <pre id="VkCommandBufferLevel" data-language="c++">typedef enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
} VkCommandBufferLevel;</pre>   <h4 id="_description_280">Description</h4>  <ul> <li> <code>VK_COMMAND_BUFFER_LEVEL_PRIMARY</code> specifies a primary command buffer. </li> <li> <code>VK_COMMAND_BUFFER_LEVEL_SECONDARY</code> specifies a secondary command buffer. </li> </ul>    <h4 id="_see_also_280">See Also</h4>  <p><a href="#VkCommandBufferAllocateInfo">VkCommandBufferAllocateInfo</a></p>    <h4 id="_document_notes_280">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferLevel">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferLevel</a></p>         <h3 id="_vkcommandbufferresetflagbits_3">VkCommandBufferResetFlagBits(3)</h3>  <h4 id="_name_281">Name</h4>  <p>VkCommandBufferResetFlagBits - Bitmask controlling behavior of a command buffer reset</p>    <h4 id="_c_specification_281">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#vkResetCommandBuffer">vkResetCommandBuffer</a>::<code>flags</code> to control the reset operation are:</p>  <pre id="VkCommandBufferResetFlagBits" data-language="c++">typedef enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
} VkCommandBufferResetFlagBits;</pre>   <h4 id="_description_281">Description</h4>  <ul> <li> <code>VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT</code> specifies that most or all memory resources currently owned by the command buffer <strong>should</strong> be returned to the parent command pool. If this flag is not set, then the command buffer <strong>may</strong> hold onto memory resources and reuse them when recording commands. <code>commandBuffer</code> is moved to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">initial state</a>. </li> </ul>    <h4 id="_see_also_281">See Also</h4>  <p><a href="#VkCommandBufferResetFlags">VkCommandBufferResetFlags</a></p>    <h4 id="_document_notes_281">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferResetFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferResetFlagBits</a></p>         <h3 id="_vkcommandbufferusageflagbits_3">VkCommandBufferUsageFlagBits(3)</h3>  <h4 id="_name_282">Name</h4>  <p>VkCommandBufferUsageFlagBits - Bitmask specifying usage behavior for command buffer</p>    <h4 id="_c_specification_282">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkCommandBufferBeginInfo">VkCommandBufferBeginInfo</a>::<code>flags</code> to specify usage behavior for a command buffer are:</p>  <pre id="VkCommandBufferUsageFlagBits" data-language="c++">typedef enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
} VkCommandBufferUsageFlagBits;</pre>   <h4 id="_description_282">Description</h4>  <ul> <li> <code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code> specifies that each recording of the command buffer will only be submitted once, and the command buffer will be reset and recorded again between each submission. </li> <li> <code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code> specifies that a secondary command buffer is considered to be entirely inside a render pass. If this is a primary command buffer, then this bit is ignored. </li> <li> <code>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</code> specifies that a command buffer <strong>can</strong> be resubmitted to a queue while it is in the <em>pending state</em>, and recorded into multiple primary command buffers. </li> </ul>    <h4 id="_see_also_282">See Also</h4>  <p><a href="#VkCommandBufferUsageFlags">VkCommandBufferUsageFlags</a></p>    <h4 id="_document_notes_282">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferUsageFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferUsageFlagBits</a></p>         <h3 id="_vkcommandpoolcreateflagbits_3">VkCommandPoolCreateFlagBits(3)</h3>  <h4 id="_name_283">Name</h4>  <p>VkCommandPoolCreateFlagBits - Bitmask specifying usage behavior for a command pool</p>    <h4 id="_c_specification_283">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkCommandPoolCreateInfo">VkCommandPoolCreateInfo</a>::<code>flags</code> to specify usage behavior for a command pool are:</p>  <pre id="VkCommandPoolCreateFlagBits" data-language="c++">typedef enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
} VkCommandPoolCreateFlagBits;</pre>   <h4 id="_description_283">Description</h4>  <ul> <li> <code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code> indicates that command buffers allocated from the pool will be short-lived, meaning that they will be reset or freed in a relatively short timeframe. This flag <strong>may</strong> be used by the implementation to control memory allocation behavior within the pool. </li> <li> <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code> allows any command buffer allocated from a pool to be individually reset to the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle">initial state</a>; either by calling <a href="#vkResetCommandBuffer">vkResetCommandBuffer</a>, or via the implicit reset when calling <a href="#vkBeginCommandBuffer">vkBeginCommandBuffer</a>. If this flag is not set on a pool, then <code>vkResetCommandBuffer</code> <strong>must</strong> not be called for any command buffer allocated from that pool. </li> </ul>    <h4 id="_see_also_283">See Also</h4>  <p><a href="#VkCommandPoolCreateFlags">VkCommandPoolCreateFlags</a></p>    <h4 id="_document_notes_283">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPoolCreateFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPoolCreateFlagBits</a></p>         <h3 id="_vkcommandpoolresetflagbits_3">VkCommandPoolResetFlagBits(3)</h3>  <h4 id="_name_284">Name</h4>  <p>VkCommandPoolResetFlagBits - Bitmask controlling behavior of a command pool reset</p>    <h4 id="_c_specification_284">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#vkResetCommandPool">vkResetCommandPool</a>::<code>flags</code> to control the reset operation are:</p>  <pre id="VkCommandPoolResetFlagBits" data-language="c++">typedef enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
} VkCommandPoolResetFlagBits;</pre>   <h4 id="_description_284">Description</h4>  <ul> <li> <code>VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT</code> specifies that resetting a command pool recycles all of the resources from the command pool back to the system. </li> </ul>    <h4 id="_see_also_284">See Also</h4>  <p><a href="#VkCommandPoolResetFlags">VkCommandPoolResetFlags</a></p>    <h4 id="_document_notes_284">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPoolResetFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPoolResetFlagBits</a></p>         <h3 id="_vkcompareop_3">VkCompareOp(3)</h3>  <h4 id="_name_285">Name</h4>  <p>VkCompareOp - Stencil comparison function</p>    <h4 id="_c_specification_285">C Specification</h4>  <p>Possible values of VkStencilOpState::<code>compareOp</code>, specifying the stencil comparison function, are:</p>  <pre id="VkCompareOp" data-language="c++">typedef enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
} VkCompareOp;</pre>   <h4 id="_description_285">Description</h4>  <ul> <li> <code>VK_COMPARE_OP_NEVER</code> specifies that the test never passes. </li> <li> <code>VK_COMPARE_OP_LESS</code> specifies that the test passes when R &lt; S. </li> <li> <code>VK_COMPARE_OP_EQUAL</code> specifies that the test passes when R = S. </li> <li> <code>VK_COMPARE_OP_LESS_OR_EQUAL</code> specifies that the test passes when R ≤ S. </li> <li> <code>VK_COMPARE_OP_GREATER</code> specifies that the test passes when R &gt; S. </li> <li> <code>VK_COMPARE_OP_NOT_EQUAL</code> specifies that the test passes when R ≠ S. </li> <li> <code>VK_COMPARE_OP_GREATER_OR_EQUAL</code> specifies that the test passes when R ≥ S. </li> <li> <code>VK_COMPARE_OP_ALWAYS</code> specifies that the test always passes. </li> </ul>    <h4 id="_see_also_285">See Also</h4>  <p><a href="#VkPipelineDepthStencilStateCreateInfo">VkPipelineDepthStencilStateCreateInfo</a>, <a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a>, <a href="#VkStencilOpState">VkStencilOpState</a></p>    <h4 id="_document_notes_285">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCompareOp">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCompareOp</a></p>         <h3 id="_vkcomponentswizzle_3">VkComponentSwizzle(3)</h3>  <h4 id="_name_286">Name</h4>  <p>VkComponentSwizzle - Specify how a component is swizzled</p>    <h4 id="_c_specification_286">C Specification</h4>  <p>Possible values of the members of <a href="#VkComponentMapping">VkComponentMapping</a>, specifying the component values placed in each component of the output vector, are:</p>  <pre id="VkComponentSwizzle" data-language="c++">typedef enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
} VkComponentSwizzle;</pre>   <h4 id="_description_286">Description</h4>  <ul> <li> <code>VK_COMPONENT_SWIZZLE_IDENTITY</code> specifies that the component is set to the identity swizzle. </li> <li> <code>VK_COMPONENT_SWIZZLE_ZERO</code> specifies that the component is set to zero. </li> <li> <code>VK_COMPONENT_SWIZZLE_ONE</code> specifies that the component is set to either 1 or 1.0, depending on whether the type of the image view format is integer or floating-point respectively, as determined by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-formats-definition">Format Definition</a> section for each <a href="#VkFormat">VkFormat</a>. </li> <li> <code>VK_COMPONENT_SWIZZLE_R</code> specifies that the component is set to the value of the R component of the image. </li> <li> <code>VK_COMPONENT_SWIZZLE_G</code> specifies that the component is set to the value of the G component of the image. </li> <li> <code>VK_COMPONENT_SWIZZLE_B</code> specifies that the component is set to the value of the B component of the image. </li> <li> <code>VK_COMPONENT_SWIZZLE_A</code> specifies that the component is set to the value of the A component of the image. </li> </ul>   <p>Setting the identity swizzle on a component is equivalent to setting the identity mapping on that component. That is:</p>  <div class="_table"><table id="resources-image-views-identity-mappings" class="tableblock frame-all grid-all spread"> <caption class="title">Table 10. Component Mappings Equivalent To <code>VK_COMPONENT_SWIZZLE_IDENTITY</code>
</caption> <colgroup> <col style="width: 50%;"> <col style="width: 50%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Component</th> <th class="tableblock halign-left valign-top">Identity Mapping</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>components.r</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_COMPONENT_SWIZZLE_R</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>components.g</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_COMPONENT_SWIZZLE_G</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>components.b</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_COMPONENT_SWIZZLE_B</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>components.a</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_COMPONENT_SWIZZLE_A</code></p></td> </tr> </tbody> </table></div>   <h4 id="_see_also_286">See Also</h4>  <p><a href="#VkComponentMapping">VkComponentMapping</a></p>    <h4 id="_document_notes_286">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkComponentSwizzle">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkComponentSwizzle</a></p>         <h3 id="_vkcullmodeflagbits_3">VkCullModeFlagBits(3)</h3>  <h4 id="_name_287">Name</h4>  <p>VkCullModeFlagBits - Bitmask controlling triangle culling</p>    <h4 id="_c_specification_287">C Specification</h4>  <p>Once the orientation of triangles is determined, they are culled according to the <a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a>::<code>cullMode</code> property of the currently active pipeline. Possible values are:</p>  <pre id="VkCullModeFlagBits" data-language="c++">typedef enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 0x00000001,
    VK_CULL_MODE_BACK_BIT = 0x00000002,
    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
} VkCullModeFlagBits;</pre>   <h4 id="_description_287">Description</h4>  <ul> <li> <code>VK_CULL_MODE_NONE</code> specifies that no triangles are discarded </li> <li> <code>VK_CULL_MODE_FRONT_BIT</code> specifies that front-facing triangles are discarded </li> <li> <code>VK_CULL_MODE_BACK_BIT</code> specifies that back-facing triangles are discarded </li> <li> <code>VK_CULL_MODE_FRONT_AND_BACK</code> specifies that all triangles are discarded. </li> </ul>   <p>Following culling, fragments are produced for any triangles which have not been discarded.</p>    <h4 id="_see_also_287">See Also</h4>  <p><a href="#VkCullModeFlags">VkCullModeFlags</a></p>    <h4 id="_document_notes_287">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCullModeFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCullModeFlagBits</a></p>         <h3 id="_vkdependencyflagbits_3">VkDependencyFlagBits(3)</h3>  <h4 id="_name_288">Name</h4>  <p>VkDependencyFlagBits - Bitmask specifying how execution and memory dependencies are formed</p>    <h4 id="_c_specification_288">C Specification</h4>  <p>Bits which <strong>can</strong> be set in vkCmdPipelineBarrier::<code>dependencyFlags</code>, specifying how execution and memory dependencies are formed, are:</p>  <pre id="VkDependencyFlagBits" data-language="c++">typedef enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
} VkDependencyFlagBits;</pre>   <h4 id="_description_288">Description</h4>  <ul> <li> <code>VK_DEPENDENCY_BY_REGION_BIT</code> specifies that dependencies will be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions">framebuffer-local</a>. </li> </ul>    <h4 id="_see_also_288">See Also</h4>  <p><a href="#VkDependencyFlags">VkDependencyFlags</a></p>    <h4 id="_document_notes_288">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDependencyFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDependencyFlagBits</a></p>         <h3 id="_vkdescriptorpoolcreateflagbits_3">VkDescriptorPoolCreateFlagBits(3)</h3>  <h4 id="_name_289">Name</h4>  <p>VkDescriptorPoolCreateFlagBits - Bitmask specifying certain supported operations on a descriptor pool</p>    <h4 id="_c_specification_289">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>::<code>flags</code> to enable operations on a descriptor pool are:</p>  <pre id="VkDescriptorPoolCreateFlagBits" data-language="c++">typedef enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
} VkDescriptorPoolCreateFlagBits;</pre>   <h4 id="_description_289">Description</h4>  <ul> <li> <code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code> specifies that descriptor sets <strong>can</strong> return their individual allocations to the pool, i.e. all of <a href="#vkAllocateDescriptorSets">vkAllocateDescriptorSets</a>, <a href="#vkFreeDescriptorSets">vkFreeDescriptorSets</a>, and <a href="#vkResetDescriptorPool">vkResetDescriptorPool</a> are allowed. Otherwise, descriptor sets allocated from the pool <strong>must</strong> not be individually freed back to the pool, i.e. only <a href="#vkAllocateDescriptorSets">vkAllocateDescriptorSets</a> and <a href="#vkResetDescriptorPool">vkResetDescriptorPool</a> are allowed. </li> </ul>    <h4 id="_see_also_289">See Also</h4>  <p><a href="#VkDescriptorPoolCreateFlags">VkDescriptorPoolCreateFlags</a></p>    <h4 id="_document_notes_289">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPoolCreateFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPoolCreateFlagBits</a></p>         <h3 id="_vkdescriptorsetlayoutcreateflagbits_3">VkDescriptorSetLayoutCreateFlagBits(3)</h3>  <h4 id="_name_290">Name</h4>  <p>VkDescriptorSetLayoutCreateFlagBits - Bitmask specifying descriptor set layout properties</p>    <h4 id="_c_specification_290">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>::<code>flags</code> to specify options for descriptor set layout are:</p>  <pre id="VkDescriptorSetLayoutCreateFlagBits" data-language="c++">typedef enum VkDescriptorSetLayoutCreateFlagBits {
} VkDescriptorSetLayoutCreateFlagBits;</pre>      <h4 id="_see_also_290">See Also</h4>  <p><a href="#VkDescriptorSetLayoutCreateFlags">VkDescriptorSetLayoutCreateFlags</a></p>    <h4 id="_document_notes_290">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetLayoutCreateFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetLayoutCreateFlagBits</a></p>         <h3 id="_vkdescriptortype_3">VkDescriptorType(3)</h3>  <h4 id="_name_291">Name</h4>  <p>VkDescriptorType - Specifies the type of a descriptor in a descriptor set</p>    <h4 id="_c_specification_291">C Specification</h4>  <p>The type of descriptors in a descriptor set is specified by <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>descriptorType</code>, which <strong>must</strong> be one of the values:</p>  <pre id="VkDescriptorType" data-language="c++">typedef enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
} VkDescriptorType;</pre>   <h4 id="_description_291">Description</h4>  <ul> <li> <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>, <code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</code>, or <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</code> specify that the elements of the <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pBufferInfo</code> array of <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a> structures will be used to update the descriptors, and other arrays will be ignored. </li> <li> <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> or <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> specify that the <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pTexelBufferView</code> array will be used to update the descriptors, and other arrays will be ignored. </li> <li> <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>, or <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code> specify that the elements of the <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a>::<code>pImageInfo</code> array of <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a> structures will be used to update the descriptors, and other arrays will be ignored. </li> </ul>    <h4 id="_see_also_291">See Also</h4>  <p><a href="#VkDescriptorPoolSize">VkDescriptorPoolSize</a>, <a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a>, <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a></p>    <h4 id="_document_notes_291">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorType">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorType</a></p>         <h3 id="_vkdynamicstate_3">VkDynamicState(3)</h3>  <h4 id="_name_292">Name</h4>  <p>VkDynamicState - Indicate which dynamic state is taken from dynamic state commands</p>    <h4 id="_c_specification_292">C Specification</h4>  <p>The source of different pieces of dynamic state is specified by the <a href="#VkPipelineDynamicStateCreateInfo">VkPipelineDynamicStateCreateInfo</a>::<code>pDynamicStates</code> property of the currently active pipeline, each of whose elements <strong>must</strong> be one of the values:</p>  <pre id="VkDynamicState" data-language="c++">typedef enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
} VkDynamicState;</pre>   <h4 id="_description_292">Description</h4>  <ul> <li> <code>VK_DYNAMIC_STATE_VIEWPORT</code> specifies that the <code>pViewports</code> state in <code>VkPipelineViewportStateCreateInfo</code> will be ignored and <strong>must</strong> be set dynamically with <a href="#vkCmdSetViewport">vkCmdSetViewport</a> before any draw commands. The number of viewports used by a pipeline is still specified by the <code>viewportCount</code> member of <code>VkPipelineViewportStateCreateInfo</code>. </li> <li> <code>VK_DYNAMIC_STATE_SCISSOR</code> specifies that the <code>pScissors</code> state in <code>VkPipelineViewportStateCreateInfo</code> will be ignored and <strong>must</strong> be set dynamically with <a href="#vkCmdSetScissor">vkCmdSetScissor</a> before any draw commands. The number of scissor rectangles used by a pipeline is still specified by the <code>scissorCount</code> member of <code>VkPipelineViewportStateCreateInfo</code>. </li> <li> <code>VK_DYNAMIC_STATE_LINE_WIDTH</code> specifies that the <code>lineWidth</code> state in <code>VkPipelineRasterizationStateCreateInfo</code> will be ignored and <strong>must</strong> be set dynamically with <a href="#vkCmdSetLineWidth">vkCmdSetLineWidth</a> before any draw commands that generate line primitives for the rasterizer. </li> <li> <code>VK_DYNAMIC_STATE_DEPTH_BIAS</code> specifies that the <code>depthBiasConstantFactor</code>, <code>depthBiasClamp</code> and <code>depthBiasSlopeFactor</code> states in <code>VkPipelineRasterizationStateCreateInfo</code> will be ignored and <strong>must</strong> be set dynamically with <a href="#vkCmdSetDepthBias">vkCmdSetDepthBias</a> before any draws are performed with <code>depthBiasEnable</code> in <code>VkPipelineRasterizationStateCreateInfo</code> set to <code>VK_TRUE</code>. </li> <li> <code>VK_DYNAMIC_STATE_BLEND_CONSTANTS</code> specifies that the <code>blendConstants</code> state in <code>VkPipelineColorBlendStateCreateInfo</code> will be ignored and <strong>must</strong> be set dynamically with <a href="#vkCmdSetBlendConstants">vkCmdSetBlendConstants</a> before any draws are performed with a pipeline state with <code>VkPipelineColorBlendAttachmentState</code> member <code>blendEnable</code> set to <code>VK_TRUE</code> and any of the blend functions using a constant blend color. </li> <li> <code>VK_DYNAMIC_STATE_DEPTH_BOUNDS</code> specifies that the <code>minDepthBounds</code> and <code>maxDepthBounds</code> states of <a href="#VkPipelineDepthStencilStateCreateInfo">VkPipelineDepthStencilStateCreateInfo</a> will be ignored and <strong>must</strong> be set dynamically with <a href="#vkCmdSetDepthBounds">vkCmdSetDepthBounds</a> before any draws are performed with a pipeline state with <code>VkPipelineDepthStencilStateCreateInfo</code> member <code>depthBoundsTestEnable</code> set to <code>VK_TRUE</code>. </li> <li> <code>VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK</code> specifies that the <code>compareMask</code> state in <code>VkPipelineDepthStencilStateCreateInfo</code> for both <code>front</code> and <code>back</code> will be ignored and <strong>must</strong> be set dynamically with <a href="#vkCmdSetStencilCompareMask">vkCmdSetStencilCompareMask</a> before any draws are performed with a pipeline state with <code>VkPipelineDepthStencilStateCreateInfo</code> member <code>stencilTestEnable</code> set to <code>VK_TRUE</code> </li> <li> <code>VK_DYNAMIC_STATE_STENCIL_WRITE_MASK</code> specifies that the <code>writeMask</code> state in <code>VkPipelineDepthStencilStateCreateInfo</code> for both <code>front</code> and <code>back</code> will be ignored and <strong>must</strong> be set dynamically with <a href="#vkCmdSetStencilWriteMask">vkCmdSetStencilWriteMask</a> before any draws are performed with a pipeline state with <code>VkPipelineDepthStencilStateCreateInfo</code> member <code>stencilTestEnable</code> set to <code>VK_TRUE</code> </li> <li> <code>VK_DYNAMIC_STATE_STENCIL_REFERENCE</code> specifies that the <code>reference</code> state in <code>VkPipelineDepthStencilStateCreateInfo</code> for both <code>front</code> and <code>back</code> will be ignored and <strong>must</strong> be set dynamically with <a href="#vkCmdSetStencilReference">vkCmdSetStencilReference</a> before any draws are performed with a pipeline state with <code>VkPipelineDepthStencilStateCreateInfo</code> member <code>stencilTestEnable</code> set to <code>VK_TRUE</code> </li> </ul>    <h4 id="_see_also_292">See Also</h4>  <p><a href="#VkPipelineDynamicStateCreateInfo">VkPipelineDynamicStateCreateInfo</a></p>    <h4 id="_document_notes_292">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDynamicState">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDynamicState</a></p>         <h3 id="_vkfencecreateflagbits_3">VkFenceCreateFlagBits(3)</h3>  <h4 id="_name_293">Name</h4>  <p>VkFenceCreateFlagBits - Bitmask specifying initial state and behavior of a fence</p>    <h4 id="_c_specification_293">C Specification</h4> <pre id="VkFenceCreateFlagBits" data-language="c++">typedef enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
} VkFenceCreateFlagBits;</pre>   <h4 id="_description_293">Description</h4>  <ul> <li> <code>VK_FENCE_CREATE_SIGNALED_BIT</code> specifies that the fence object is created in the signaled state. Otherwise, it is created in the unsignaled state. </li> </ul>    <h4 id="_see_also_293">See Also</h4>  <p><a href="#VkFenceCreateFlags">VkFenceCreateFlags</a></p>    <h4 id="_document_notes_293">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFenceCreateFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFenceCreateFlagBits</a></p>         <h3 id="_vkfilter_3">VkFilter(3)</h3>  <h4 id="_name_294">Name</h4>  <p>VkFilter - Specify filters used for texture lookups</p>    <h4 id="_c_specification_294">C Specification</h4>  <p>Possible values of the <a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a>::<code>magFilter</code> and <code>minFilter</code> parameters, specifying filters used for texture lookups, are:</p>  <pre id="VkFilter" data-language="c++">typedef enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
} VkFilter;</pre>   <h4 id="_description_294">Description</h4>  <ul> <li> <code>VK_FILTER_NEAREST</code> specifies nearest filtering. </li> <li> <code>VK_FILTER_LINEAR</code> specifies linear filtering. </li> </ul>   <p>These filters are described in detail in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-filtering">Texel Filtering</a>.</p>    <h4 id="_see_also_294">See Also</h4>  <p><a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a>, <a href="#vkCmdBlitImage">vkCmdBlitImage</a></p>    <h4 id="_document_notes_294">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFilter">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFilter</a></p>         <h3 id="_vkformat_3">VkFormat(3)</h3>  <h4 id="_name_295">Name</h4>  <p>VkFormat - Available image formats</p>    <h4 id="_c_specification_295">C Specification</h4>  <p>Image formats which <strong>can</strong> be passed to, and <strong>may</strong> be returned from Vulkan commands, are:</p>  <pre id="VkFormat" data-language="c++">typedef enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
} VkFormat;</pre>   <h4 id="_description_295">Description</h4>  <ul> <li> <code>VK_FORMAT_UNDEFINED</code> indicates that the format is not specified. </li> <li> <code>VK_FORMAT_R4G4_UNORM_PACK8</code> specifies a two-component, 8-bit packed unsigned normalized format that has a 4-bit R component in bits 4..7, and a 4-bit G component in bits 0..3. </li> <li> <code>VK_FORMAT_R4G4B4A4_UNORM_PACK16</code> specifies a four-component, 16-bit packed unsigned normalized format that has a 4-bit R component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit B component in bits 4..7, and a 4-bit A component in bits 0..3. </li> <li> <code>VK_FORMAT_B4G4R4A4_UNORM_PACK16</code> specifies a four-component, 16-bit packed unsigned normalized format that has a 4-bit B component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit R component in bits 4..7, and a 4-bit A component in bits 0..3. </li> <li> <code>VK_FORMAT_R5G6B5_UNORM_PACK16</code> specifies a three-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit B component in bits 0..4. </li> <li> <code>VK_FORMAT_B5G6R5_UNORM_PACK16</code> specifies a three-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit R component in bits 0..4. </li> <li> <code>VK_FORMAT_R5G5B5A1_UNORM_PACK16</code> specifies a four-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit B component in bits 1..5, and a 1-bit A component in bit 0. </li> <li> <code>VK_FORMAT_B5G5R5A1_UNORM_PACK16</code> specifies a four-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit R component in bits 1..5, and a 1-bit A component in bit 0. </li> <li> <code>VK_FORMAT_A1R5G5B5_UNORM_PACK16</code> specifies a four-component, 16-bit packed unsigned normalized format that has a 1-bit A component in bit 15, a 5-bit R component in bits 10..14, a 5-bit G component in bits 5..9, and a 5-bit B component in bits 0..4. </li> <li> <code>VK_FORMAT_R8_UNORM</code> specifies a one-component, 8-bit unsigned normalized format that has a single 8-bit R component. </li> <li> <code>VK_FORMAT_R8_SNORM</code> specifies a one-component, 8-bit signed normalized format that has a single 8-bit R component. </li> <li> <code>VK_FORMAT_R8_USCALED</code> specifies a one-component, 8-bit unsigned scaled integer format that has a single 8-bit R component. </li> <li> <code>VK_FORMAT_R8_SSCALED</code> specifies a one-component, 8-bit signed scaled integer format that has a single 8-bit R component. </li> <li> <code>VK_FORMAT_R8_UINT</code> specifies a one-component, 8-bit unsigned integer format that has a single 8-bit R component. </li> <li> <code>VK_FORMAT_R8_SINT</code> specifies a one-component, 8-bit signed integer format that has a single 8-bit R component. </li> <li> <code>VK_FORMAT_R8_SRGB</code> specifies a one-component, 8-bit unsigned normalized format that has a single 8-bit R component stored with sRGB nonlinear encoding. </li> <li> <code>VK_FORMAT_R8G8_UNORM</code> specifies a two-component, 16-bit unsigned normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1. </li> <li> <code>VK_FORMAT_R8G8_SNORM</code> specifies a two-component, 16-bit signed normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1. </li> <li> <code>VK_FORMAT_R8G8_USCALED</code> specifies a two-component, 16-bit unsigned scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1. </li> <li> <code>VK_FORMAT_R8G8_SSCALED</code> specifies a two-component, 16-bit signed scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1. </li> <li> <code>VK_FORMAT_R8G8_UINT</code> specifies a two-component, 16-bit unsigned integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1. </li> <li> <code>VK_FORMAT_R8G8_SINT</code> specifies a two-component, 16-bit signed integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1. </li> <li> <code>VK_FORMAT_R8G8_SRGB</code> specifies a two-component, 16-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, and an 8-bit G component stored with sRGB nonlinear encoding in byte 1. </li> <li> <code>VK_FORMAT_R8G8B8_UNORM</code> specifies a three-component, 24-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2. </li> <li> <code>VK_FORMAT_R8G8B8_SNORM</code> specifies a three-component, 24-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2. </li> <li> <code>VK_FORMAT_R8G8B8_USCALED</code> specifies a three-component, 24-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2. </li> <li> <code>VK_FORMAT_R8G8B8_SSCALED</code> specifies a three-component, 24-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2. </li> <li> <code>VK_FORMAT_R8G8B8_UINT</code> specifies a three-component, 24-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2. </li> <li> <code>VK_FORMAT_R8G8B8_SINT</code> specifies a three-component, 24-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2. </li> <li> <code>VK_FORMAT_R8G8B8_SRGB</code> specifies a three-component, 24-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit B component stored with sRGB nonlinear encoding in byte 2. </li> <li> <code>VK_FORMAT_B8G8R8_UNORM</code> specifies a three-component, 24-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2. </li> <li> <code>VK_FORMAT_B8G8R8_SNORM</code> specifies a three-component, 24-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2. </li> <li> <code>VK_FORMAT_B8G8R8_USCALED</code> specifies a three-component, 24-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2. </li> <li> <code>VK_FORMAT_B8G8R8_SSCALED</code> specifies a three-component, 24-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2. </li> <li> <code>VK_FORMAT_B8G8R8_UINT</code> specifies a three-component, 24-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2. </li> <li> <code>VK_FORMAT_B8G8R8_SINT</code> specifies a three-component, 24-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2. </li> <li> <code>VK_FORMAT_B8G8R8_SRGB</code> specifies a three-component, 24-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit R component stored with sRGB nonlinear encoding in byte 2. </li> <li> <code>VK_FORMAT_R8G8B8A8_UNORM</code> specifies a four-component, 32-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_R8G8B8A8_SNORM</code> specifies a four-component, 32-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_R8G8B8A8_USCALED</code> specifies a four-component, 32-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_R8G8B8A8_SSCALED</code> specifies a four-component, 32-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_R8G8B8A8_UINT</code> specifies a four-component, 32-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_R8G8B8A8_SINT</code> specifies a four-component, 32-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_R8G8B8A8_SRGB</code> specifies a four-component, 32-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit B component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_B8G8R8A8_UNORM</code> specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_B8G8R8A8_SNORM</code> specifies a four-component, 32-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_B8G8R8A8_USCALED</code> specifies a four-component, 32-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_B8G8R8A8_SSCALED</code> specifies a four-component, 32-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_B8G8R8A8_UINT</code> specifies a four-component, 32-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_B8G8R8A8_SINT</code> specifies a four-component, 32-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_B8G8R8A8_SRGB</code> specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3. </li> <li> <code>VK_FORMAT_A8B8G8R8_UNORM_PACK32</code> specifies a four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7. </li> <li> <code>VK_FORMAT_A8B8G8R8_SNORM_PACK32</code> specifies a four-component, 32-bit packed signed normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7. </li> <li> <code>VK_FORMAT_A8B8G8R8_USCALED_PACK32</code> specifies a four-component, 32-bit packed unsigned scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7. </li> <li> <code>VK_FORMAT_A8B8G8R8_SSCALED_PACK32</code> specifies a four-component, 32-bit packed signed scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7. </li> <li> <code>VK_FORMAT_A8B8G8R8_UINT_PACK32</code> specifies a four-component, 32-bit packed unsigned integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7. </li> <li> <code>VK_FORMAT_A8B8G8R8_SINT_PACK32</code> specifies a four-component, 32-bit packed signed integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7. </li> <li> <code>VK_FORMAT_A8B8G8R8_SRGB_PACK32</code> specifies a four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component stored with sRGB nonlinear encoding in bits 16..23, an 8-bit G component stored with sRGB nonlinear encoding in bits 8..15, and an 8-bit R component stored with sRGB nonlinear encoding in bits 0..7. </li> <li> <code>VK_FORMAT_A2R10G10B10_UNORM_PACK32</code> specifies a four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9. </li> <li> <code>VK_FORMAT_A2R10G10B10_SNORM_PACK32</code> specifies a four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9. </li> <li> <code>VK_FORMAT_A2R10G10B10_USCALED_PACK32</code> specifies a four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9. </li> <li> <code>VK_FORMAT_A2R10G10B10_SSCALED_PACK32</code> specifies a four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9. </li> <li> <code>VK_FORMAT_A2R10G10B10_UINT_PACK32</code> specifies a four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9. </li> <li> <code>VK_FORMAT_A2R10G10B10_SINT_PACK32</code> specifies a four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9. </li> <li> <code>VK_FORMAT_A2B10G10R10_UNORM_PACK32</code> specifies a four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9. </li> <li> <code>VK_FORMAT_A2B10G10R10_SNORM_PACK32</code> specifies a four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9. </li> <li> <code>VK_FORMAT_A2B10G10R10_USCALED_PACK32</code> specifies a four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9. </li> <li> <code>VK_FORMAT_A2B10G10R10_SSCALED_PACK32</code> specifies a four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9. </li> <li> <code>VK_FORMAT_A2B10G10R10_UINT_PACK32</code> specifies a four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9. </li> <li> <code>VK_FORMAT_A2B10G10R10_SINT_PACK32</code> specifies a four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9. </li> <li> <code>VK_FORMAT_R16_UNORM</code> specifies a one-component, 16-bit unsigned normalized format that has a single 16-bit R component. </li> <li> <code>VK_FORMAT_R16_SNORM</code> specifies a one-component, 16-bit signed normalized format that has a single 16-bit R component. </li> <li> <code>VK_FORMAT_R16_USCALED</code> specifies a one-component, 16-bit unsigned scaled integer format that has a single 16-bit R component. </li> <li> <code>VK_FORMAT_R16_SSCALED</code> specifies a one-component, 16-bit signed scaled integer format that has a single 16-bit R component. </li> <li> <code>VK_FORMAT_R16_UINT</code> specifies a one-component, 16-bit unsigned integer format that has a single 16-bit R component. </li> <li> <code>VK_FORMAT_R16_SINT</code> specifies a one-component, 16-bit signed integer format that has a single 16-bit R component. </li> <li> <code>VK_FORMAT_R16_SFLOAT</code> specifies a one-component, 16-bit signed floating-point format that has a single 16-bit R component. </li> <li> <code>VK_FORMAT_R16G16_UNORM</code> specifies a two-component, 32-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3. </li> <li> <code>VK_FORMAT_R16G16_SNORM</code> specifies a two-component, 32-bit signed normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3. </li> <li> <code>VK_FORMAT_R16G16_USCALED</code> specifies a two-component, 32-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3. </li> <li> <code>VK_FORMAT_R16G16_SSCALED</code> specifies a two-component, 32-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3. </li> <li> <code>VK_FORMAT_R16G16_UINT</code> specifies a two-component, 32-bit unsigned integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3. </li> <li> <code>VK_FORMAT_R16G16_SINT</code> specifies a two-component, 32-bit signed integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3. </li> <li> <code>VK_FORMAT_R16G16_SFLOAT</code> specifies a two-component, 32-bit signed floating-point format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3. </li> <li> <code>VK_FORMAT_R16G16B16_UNORM</code> specifies a three-component, 48-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5. </li> <li> <code>VK_FORMAT_R16G16B16_SNORM</code> specifies a three-component, 48-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5. </li> <li> <code>VK_FORMAT_R16G16B16_USCALED</code> specifies a three-component, 48-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5. </li> <li> <code>VK_FORMAT_R16G16B16_SSCALED</code> specifies a three-component, 48-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5. </li> <li> <code>VK_FORMAT_R16G16B16_UINT</code> specifies a three-component, 48-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5. </li> <li> <code>VK_FORMAT_R16G16B16_SINT</code> specifies a three-component, 48-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5. </li> <li> <code>VK_FORMAT_R16G16B16_SFLOAT</code> specifies a three-component, 48-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5. </li> <li> <code>VK_FORMAT_R16G16B16A16_UNORM</code> specifies a four-component, 64-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7. </li> <li> <code>VK_FORMAT_R16G16B16A16_SNORM</code> specifies a four-component, 64-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7. </li> <li> <code>VK_FORMAT_R16G16B16A16_USCALED</code> specifies a four-component, 64-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7. </li> <li> <code>VK_FORMAT_R16G16B16A16_SSCALED</code> specifies a four-component, 64-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7. </li> <li> <code>VK_FORMAT_R16G16B16A16_UINT</code> specifies a four-component, 64-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7. </li> <li> <code>VK_FORMAT_R16G16B16A16_SINT</code> specifies a four-component, 64-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7. </li> <li> <code>VK_FORMAT_R16G16B16A16_SFLOAT</code> specifies a four-component, 64-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7. </li> <li> <code>VK_FORMAT_R32_UINT</code> specifies a one-component, 32-bit unsigned integer format that has a single 32-bit R component. </li> <li> <code>VK_FORMAT_R32_SINT</code> specifies a one-component, 32-bit signed integer format that has a single 32-bit R component. </li> <li> <code>VK_FORMAT_R32_SFLOAT</code> specifies a one-component, 32-bit signed floating-point format that has a single 32-bit R component. </li> <li> <code>VK_FORMAT_R32G32_UINT</code> specifies a two-component, 64-bit unsigned integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7. </li> <li> <code>VK_FORMAT_R32G32_SINT</code> specifies a two-component, 64-bit signed integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7. </li> <li> <code>VK_FORMAT_R32G32_SFLOAT</code> specifies a two-component, 64-bit signed floating-point format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7. </li> <li> <code>VK_FORMAT_R32G32B32_UINT</code> specifies a three-component, 96-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11. </li> <li> <code>VK_FORMAT_R32G32B32_SINT</code> specifies a three-component, 96-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11. </li> <li> <code>VK_FORMAT_R32G32B32_SFLOAT</code> specifies a three-component, 96-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11. </li> <li> <code>VK_FORMAT_R32G32B32A32_UINT</code> specifies a four-component, 128-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15. </li> <li> <code>VK_FORMAT_R32G32B32A32_SINT</code> specifies a four-component, 128-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15. </li> <li> <code>VK_FORMAT_R32G32B32A32_SFLOAT</code> specifies a four-component, 128-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15. </li> <li> <code>VK_FORMAT_R64_UINT</code> specifies a one-component, 64-bit unsigned integer format that has a single 64-bit R component. </li> <li> <code>VK_FORMAT_R64_SINT</code> specifies a one-component, 64-bit signed integer format that has a single 64-bit R component. </li> <li> <code>VK_FORMAT_R64_SFLOAT</code> specifies a one-component, 64-bit signed floating-point format that has a single 64-bit R component. </li> <li> <code>VK_FORMAT_R64G64_UINT</code> specifies a two-component, 128-bit unsigned integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15. </li> <li> <code>VK_FORMAT_R64G64_SINT</code> specifies a two-component, 128-bit signed integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15. </li> <li> <code>VK_FORMAT_R64G64_SFLOAT</code> specifies a two-component, 128-bit signed floating-point format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15. </li> <li> <code>VK_FORMAT_R64G64B64_UINT</code> specifies a three-component, 192-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23. </li> <li> <code>VK_FORMAT_R64G64B64_SINT</code> specifies a three-component, 192-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23. </li> <li> <code>VK_FORMAT_R64G64B64_SFLOAT</code> specifies a three-component, 192-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23. </li> <li> <code>VK_FORMAT_R64G64B64A64_UINT</code> specifies a four-component, 256-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31. </li> <li> <code>VK_FORMAT_R64G64B64A64_SINT</code> specifies a four-component, 256-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31. </li> <li> <code>VK_FORMAT_R64G64B64A64_SFLOAT</code> specifies a four-component, 256-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31. </li> <li> <code>VK_FORMAT_B10G11R11_UFLOAT_PACK32</code> specifies a three-component, 32-bit packed unsigned floating-point format that has a 10-bit B component in bits 22..31, an 11-bit G component in bits 11..21, an 11-bit R component in bits 0..10. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-fp10">html/vkspec.html#fundamentals-fp10</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-fp11">html/vkspec.html#fundamentals-fp11</a>. </li> <li> <code>VK_FORMAT_E5B9G9R9_UFLOAT_PACK32</code> specifies a three-component, 32-bit packed unsigned floating-point format that has a 5-bit shared exponent in bits 27..31, a 9-bit B component mantissa in bits 18..26, a 9-bit G component mantissa in bits 9..17, and a 9-bit R component mantissa in bits 0..8. </li> <li> <code>VK_FORMAT_D16_UNORM</code> specifies a one-component, 16-bit unsigned normalized format that has a single 16-bit depth component. </li> <li> <code>VK_FORMAT_X8_D24_UNORM_PACK32</code> specifies a two-component, 32-bit format that has 24 unsigned normalized bits in the depth component and, optionally:, 8 bits that are unused. </li> <li> <code>VK_FORMAT_D32_SFLOAT</code> specifies a one-component, 32-bit signed floating-point format that has 32-bits in the depth component. </li> <li> <code>VK_FORMAT_S8_UINT</code> specifies a one-component, 8-bit unsigned integer format that has 8-bits in the stencil component. </li> <li> <code>VK_FORMAT_D16_UNORM_S8_UINT</code> specifies a two-component, 24-bit format that has 16 unsigned normalized bits in the depth component and 8 unsigned integer bits in the stencil component. </li> <li> <code>VK_FORMAT_D24_UNORM_S8_UINT</code> specifies a two-component, 32-bit packed format that has 8 unsigned integer bits in the stencil component, and 24 unsigned normalized bits in the depth component. </li> <li> <code>VK_FORMAT_D32_SFLOAT_S8_UINT</code> specifies a two-component format that has 32 signed float bits in the depth component and 8 unsigned integer bits in the stencil component. There are optionally: 24-bits that are unused. </li> <li> <code>VK_FORMAT_BC1_RGB_UNORM_BLOCK</code> specifies a three-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque. </li> <li> <code>VK_FORMAT_BC1_RGB_SRGB_BLOCK</code> specifies a three-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque. </li> <li> <code>VK_FORMAT_BC1_RGBA_UNORM_BLOCK</code> specifies a four-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha. </li> <li> <code>VK_FORMAT_BC1_RGBA_SRGB_BLOCK</code> specifies a four-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha. </li> <li> <code>VK_FORMAT_BC2_UNORM_BLOCK</code> specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values. </li> <li> <code>VK_FORMAT_BC2_SRGB_BLOCK</code> specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding. </li> <li> <code>VK_FORMAT_BC3_UNORM_BLOCK</code> specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values. </li> <li> <code>VK_FORMAT_BC3_SRGB_BLOCK</code> specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding. </li> <li> <code>VK_FORMAT_BC4_UNORM_BLOCK</code> specifies a one-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized red texel data. </li> <li> <code>VK_FORMAT_BC4_SNORM_BLOCK</code> specifies a one-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of signed normalized red texel data. </li> <li> <code>VK_FORMAT_BC5_UNORM_BLOCK</code> specifies a two-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values. </li> <li> <code>VK_FORMAT_BC5_SNORM_BLOCK</code> specifies a two-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values. </li> <li> <code>VK_FORMAT_BC6H_UFLOAT_BLOCK</code> specifies a three-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned floating-point RGB texel data. </li> <li> <code>VK_FORMAT_BC6H_SFLOAT_BLOCK</code> specifies a three-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of signed floating-point RGB texel data. </li> <li> <code>VK_FORMAT_BC7_UNORM_BLOCK</code> specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_BC7_SRGB_BLOCK</code> specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK</code> specifies a three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque. </li> <li> <code>VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK</code> specifies a three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque. </li> <li> <code>VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK</code> specifies a four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha. </li> <li> <code>VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK</code> specifies a four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha. </li> <li> <code>VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK</code> specifies a four-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values. </li> <li> <code>VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK</code> specifies a four-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding applied. </li> <li> <code>VK_FORMAT_EAC_R11_UNORM_BLOCK</code> specifies a one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized red texel data. </li> <li> <code>VK_FORMAT_EAC_R11_SNORM_BLOCK</code> specifies a one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of signed normalized red texel data. </li> <li> <code>VK_FORMAT_EAC_R11G11_UNORM_BLOCK</code> specifies a two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values. </li> <li> <code>VK_FORMAT_EAC_R11G11_SNORM_BLOCK</code> specifies a two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values. </li> <li> <code>VK_FORMAT_ASTC_4x4_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_4x4_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_5x4_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5×4 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_5x4_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5×4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_5x5_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5×5 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_5x5_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5×5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_6x5_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6×5 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_6x5_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6×5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_6x6_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6×6 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_6x6_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6×6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_8x5_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×5 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_8x5_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_8x6_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×6 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_8x6_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_8x8_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×8 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_8x8_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_10x5_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×5 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_10x5_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_10x6_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×6 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_10x6_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_10x8_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×8 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_10x8_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_10x10_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×10 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_10x10_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_12x10_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12×10 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_12x10_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12×10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> <li> <code>VK_FORMAT_ASTC_12x12_UNORM_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12×12 rectangle of unsigned normalized RGBA texel data. </li> <li> <code>VK_FORMAT_ASTC_12x12_SRGB_BLOCK</code> specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12×12 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components. </li> </ul>    <h4 id="_see_also_295">See Also</h4>  <p><a href="#VkAttachmentDescription">VkAttachmentDescription</a>, <a href="#VkBufferViewCreateInfo">VkBufferViewCreateInfo</a>, <a href="#VkImageCreateInfo">VkImageCreateInfo</a>, <a href="#VkImageViewCreateInfo">VkImageViewCreateInfo</a>, <a href="#VkVertexInputAttributeDescription">VkVertexInputAttributeDescription</a>, <a href="#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a>, <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a>, <a href="#vkGetPhysicalDeviceSparseImageFormatProperties">vkGetPhysicalDeviceSparseImageFormatProperties</a></p>    <h4 id="_document_notes_295">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFormat">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFormat</a></p>         <h3 id="_vkformatfeatureflagbits_3">VkFormatFeatureFlagBits(3)</h3>  <h4 id="_name_296">Name</h4>  <p>VkFormatFeatureFlagBits - Bitmask specifying features supported by a buffer</p>    <h4 id="_c_specification_296">C Specification</h4>  <p>Bits which <strong>can</strong> be set in the <a href="#VkFormatProperties">VkFormatProperties</a> features <code>linearTilingFeatures</code>, <code>optimalTilingFeatures</code>, and <code>bufferFeatures</code> are:</p>  <pre id="VkFormatFeatureFlagBits" data-language="c++">typedef enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
} VkFormatFeatureFlagBits;</pre>   <h4 id="_description_296">Description</h4>  <p>The following bits <strong>may</strong> be set in <code>linearTilingFeatures</code> and <code>optimalTilingFeatures</code>, specifying that the features are supported by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImage">images</a> or <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageView">image views</a> created with the queried <a href="#vkGetPhysicalDeviceFormatProperties">vkGetPhysicalDeviceFormatProperties</a>::<code>format</code>:</p>   <ul> <li> <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code> specifies that an image view <strong>can</strong> be <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-sampledimage">sampled from</a>. </li> <li> <code>VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT</code> specifies that an image view <strong>can</strong> be used as a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-storageimage">storage images</a>. </li> <li> <code>VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT</code> specifies that an image view <strong>can</strong> be used as storage image that supports atomic operations. </li> <li> <code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT</code> specifies that an image view <strong>can</strong> be used as a framebuffer color attachment and as an input attachment. </li> <li> <code>VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT</code> specifies that an image view <strong>can</strong> be used as a framebuffer color attachment that supports blending and as an input attachment. </li> <li> <code>VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</code> specifies that an image view <strong>can</strong> be used as a framebuffer depth/stencil attachment and as an input attachment. </li> <li> <code>VK_FORMAT_FEATURE_BLIT_SRC_BIT</code> specifies that an image <strong>can</strong> be used as <code>srcImage</code> for the <code>vkCmdBlitImage</code> command. </li> <li> <code>VK_FORMAT_FEATURE_BLIT_DST_BIT</code> specifies that an image <strong>can</strong> be used as <code>dstImage</code> for the <code>vkCmdBlitImage</code> command. </li> <li> <p><code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> specifies that if <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code> is also set, an image view <strong>can</strong> be used with a sampler that has either of <code>magFilter</code> or <code>minFilter</code> set to <code>VK_FILTER_LINEAR</code>, or <code>mipmapMode</code> set to <code>VK_SAMPLER_MIPMAP_MODE_LINEAR</code>. If <code>VK_FORMAT_FEATURE_BLIT_SRC_BIT</code> is also set, an image can be used as the <code>srcImage</code> to <a href="#vkCmdBlitImage">vkCmdBlitImage</a> with a <code>filter</code> of <code>VK_FILTER_LINEAR</code>. This bit <strong>must</strong> only be exposed for formats that also support the <code>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</code> or <code>VK_FORMAT_FEATURE_BLIT_SRC_BIT</code>.</p>  <p>If the format being queried is a depth/stencil format, this bit only indicates that the depth aspect (not the stencil aspect) of an image of this format supports linear filtering, and that linear filtering of the depth aspect is supported whether depth compare is enabled in the sampler or not. If this bit is not present, linear filtering with depth compare disabled is unsupported and linear filtering with depth compare enabled is supported, but <strong>may</strong> compute the filtered value in an implementation-dependent manner which differs from the normal rules of linear filtering. The resulting value <strong>must</strong> be in the range [0,1] and <strong>should</strong> be proportional to, or a weighted average of, the number of comparison passes or failures.</p>  </li> </ul>   <p>The following bits <strong>may</strong> be set in <code>bufferFeatures</code>, specifying that the features are supported by <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBuffer">buffers</a> or <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferView">buffer views</a> created with the queried <a href="#vkGetPhysicalDeviceProperties">vkGetPhysicalDeviceProperties</a>::<code>format</code>:</p>   <ul> <li> <code>VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT</code> specifies that the format <strong>can</strong> be used to create a buffer view that <strong>can</strong> be bound to a <code>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</code> descriptor. </li> <li> <code>VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT</code> specifies that the format <strong>can</strong> be used to create a buffer view that <strong>can</strong> be bound to a <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> descriptor. </li> <li> <code>VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT</code> specifies that atomic operations are supported on <code>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</code> with this format. </li> <li> <code>VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT</code> specifies that the format <strong>can</strong> be used as a vertex attribute format (<code>VkVertexInputAttributeDescription</code>::<code>format</code>). </li> </ul>    <h4 id="_see_also_296">See Also</h4>  <p><a href="#VkFormatFeatureFlags">VkFormatFeatureFlags</a></p>    <h4 id="_document_notes_296">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFormatFeatureFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFormatFeatureFlagBits</a></p>         <h3 id="_vkfrontface_3">VkFrontFace(3)</h3>  <h4 id="_name_297">Name</h4>  <p>VkFrontFace - Interpret polygon front-facing orientation</p>    <h4 id="_c_specification_297">C Specification</h4>  <p>The first step of polygon rasterization is to determine whether the triangle is <em>back-facing</em> or <em>front-facing</em>. This determination is made based on the sign of the (clipped or unclipped) polygon’s area computed in framebuffer coordinates. One way to compute this area is:</p>  <div class="stemblock"> <div class="content"> \[a = -{1 \over 2}\sum_{i=0}^{n-1} x_f^i y_f^{i \oplus 1} - x_f^{i \oplus 1} y_f^i\] </div> </div>  <p>where \(x_f^i\) and \(y_f^i\) are the x and y framebuffer coordinates of the ith vertex of the n-vertex polygon (vertices are numbered starting at zero for the purposes of this computation) and i ⊕ 1 is (i + 1) mod n.</p>   <p>The interpretation of the sign of a is determined by the <a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a>::<code>frontFace</code> property of the currently active pipeline. Possible values are:</p>  <pre id="VkFrontFace" data-language="c++">typedef enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
} VkFrontFace;</pre>   <h4 id="_description_297">Description</h4>  <ul> <li> <code>VK_FRONT_FACE_COUNTER_CLOCKWISE</code> specifies that a triangle with positive area is considered front-facing. </li> <li> <code>VK_FRONT_FACE_CLOCKWISE</code> specifies that a triangle with negative area is considered front-facing. </li> </ul>   <p>Any triangle which is not front-facing is back-facing, including zero-area triangles.</p>    <h4 id="_see_also_297">See Also</h4>  <p><a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a></p>    <h4 id="_document_notes_297">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFrontFace">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFrontFace</a></p>         <h3 id="_vkimageaspectflagbits_3">VkImageAspectFlagBits(3)</h3>  <h4 id="_name_298">Name</h4>  <p>VkImageAspectFlagBits - Bitmask specifying which aspects of an image are included in a view</p>    <h4 id="_c_specification_298">C Specification</h4>  <p>Bits which <strong>can</strong> be set in an aspect mask to specify aspects of an image for purposes such as identifying a subresource, are:</p>  <pre id="VkImageAspectFlagBits" data-language="c++">typedef enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
} VkImageAspectFlagBits;</pre>   <h4 id="_description_298">Description</h4>  <ul> <li> <code>VK_IMAGE_ASPECT_COLOR_BIT</code> specifies the color aspect. </li> <li> <code>VK_IMAGE_ASPECT_DEPTH_BIT</code> specifies the depth aspect. </li> <li> <code>VK_IMAGE_ASPECT_STENCIL_BIT</code> specifies the stencil aspect. </li> <li> <code>VK_IMAGE_ASPECT_METADATA_BIT</code> specifies the metadata aspect, used for sparse <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory">sparse resource</a> operations. </li> </ul>    <h4 id="_see_also_298">See Also</h4>  <p><a href="#VkImageAspectFlags">VkImageAspectFlags</a></p>    <h4 id="_document_notes_298">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageAspectFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageAspectFlagBits</a></p>         <h3 id="_vkimagecreateflagbits_3">VkImageCreateFlagBits(3)</h3>  <h4 id="_name_299">Name</h4>  <p>VkImageCreateFlagBits - Bitmask specifying additional parameters of an image</p>    <h4 id="_c_specification_299">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkImageCreateInfo">VkImageCreateInfo</a>::<code>flags</code>, specifying additional parameters of an image, are:</p>  <pre id="VkImageCreateFlagBits" data-language="c++">typedef enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
} VkImageCreateFlagBits;</pre>   <h4 id="_description_299">Description</h4>  <ul> <li> <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code> specifies that the image will be backed using sparse memory binding. </li> <li> <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code> specifies that the image <strong>can</strong> be partially backed using sparse memory binding. Images created with this flag <strong>must</strong> also be created with the <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code> flag. </li> <li> <code>VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</code> specifies that the image will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another image (or another portion of the same image). Images created with this flag <strong>must</strong> also be created with the <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code> flag </li> <li> <code>VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT</code> specifies that the image <strong>can</strong> be used to create a <code>VkImageView</code> with a different format from the image. </li> <li> <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code> specifies that the image <strong>can</strong> be used to create a <code>VkImageView</code> of type <code>VK_IMAGE_VIEW_TYPE_CUBE</code> or <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>. </li> </ul>   <p>If any of the bits <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code>, <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code>, or <code>VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</code> are set, <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code> <strong>must</strong> not also be set.</p>   <p>See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseresourcefeatures">Sparse Resource Features</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-physicalfeatures">Sparse Physical Device Features</a> for more details.</p>    <h4 id="_see_also_299">See Also</h4>  <p><a href="#VkImageCreateFlags">VkImageCreateFlags</a></p>    <h4 id="_document_notes_299">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageCreateFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageCreateFlagBits</a></p>         <h3 id="_vkimagelayout_3">VkImageLayout(3)</h3>  <h4 id="_name_300">Name</h4>  <p>VkImageLayout - Layout of image and image subresources</p>    <h4 id="_c_specification_300">C Specification</h4>  <p>The set of image layouts consists of:</p>  <pre id="VkImageLayout" data-language="c++">typedef enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
} VkImageLayout;</pre>   <h4 id="_description_300">Description</h4>  <p>The type(s) of device access supported by each layout are:</p>   <ul> <li> <code>VK_IMAGE_LAYOUT_UNDEFINED</code> does not support device access. This layout <strong>must</strong> only be used as the <code>initialLayout</code> member of <code>VkImageCreateInfo</code> or <code>VkAttachmentDescription</code>, or as the <code>oldLayout</code> in an image transition. When transitioning out of this layout, the contents of the memory are not guaranteed to be preserved. </li> <li> <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> does not support device access. This layout <strong>must</strong> only be used as the <code>initialLayout</code> member of <code>VkImageCreateInfo</code> or <code>VkAttachmentDescription</code>, or as the <code>oldLayout</code> in an image transition. When transitioning out of this layout, the contents of the memory are preserved. This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data <strong>can</strong> be written to memory immediately, without first executing a layout transition. Currently, <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> is only useful with <code>VK_IMAGE_TILING_LINEAR</code> images because there is not a standard layout defined for <code>VK_IMAGE_TILING_OPTIMAL</code> images. </li> <li> <code>VK_IMAGE_LAYOUT_GENERAL</code> supports all types of device access. </li> <li> <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> <strong>must</strong> only be used as a color or resolve attachment in a <code>VkFramebuffer</code>. This layout is valid only for image subresources of images created with the <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code> usage bit enabled. </li> <li> <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> <strong>must</strong> only be used as a depth/stencil attachment in a <code>VkFramebuffer</code>. This layout is valid only for image subresources of images created with the <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code> usage bit enabled. </li> <li> <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL</code> <strong>must</strong> only be used as a read-only depth/stencil attachment in a <code>VkFramebuffer</code> and/or as a read-only image in a shader (which <strong>can</strong> be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code> usage bit enabled. Only image subresources of images created with <code>VK_IMAGE_USAGE_SAMPLED_BIT</code> <strong>can</strong> be used as a sampled image or combined image/sampler in a shader. Similarly, only image subresources of images created with <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> <strong>can</strong> be used as input attachments. </li> <li> <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code> <strong>must</strong> only be used as a read-only image in a shader (which <strong>can</strong> be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the <code>VK_IMAGE_USAGE_SAMPLED_BIT</code> or <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> usage bit enabled. </li> <li> <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> <strong>must</strong> only be used as a source image of a transfer command (see the definition of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-transfer"><code>VK_PIPELINE_STAGE_TRANSFER_BIT</code></a>). This layout is valid only for image subresources of images created with the <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> usage bit enabled. </li> <li> <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> <strong>must</strong> only be used as a destination image of a transfer command. This layout is valid only for image subresources of images created with the <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> usage bit enabled. </li> </ul>   <p>For each mechanism of accessing an image in the API, there is a parameter or structure member that controls the image layout used to access the image. For transfer commands, this is a parameter to the command (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#clears">html/vkspec.html#clears</a> and <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#copies">html/vkspec.html#copies</a>). For use as a framebuffer attachment, this is a member in the substructures of the <code>VkRenderPassCreateInfo</code> (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass">Render Pass</a>). For use in a descriptor set, this is a member in the <code>VkDescriptorImageInfo</code> structure (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates">html/vkspec.html#descriptorsets-updates</a>). At the time that any command buffer command accessing an image executes on any queue, the layouts of the image subresources that are accessed <strong>must</strong> all match the layout specified via the API controlling those accesses.</p>   <p>The image layout of each image subresource <strong>must</strong> be well-defined at each point in the image subresource’s lifetime. This means that when performing a layout transition on the image subresource, the old layout value <strong>must</strong> either equal the current layout of the image subresource (at the time the transition executes), or else be <code>VK_IMAGE_LAYOUT_UNDEFINED</code> (implying that the contents of the image subresource need not be preserved). The new layout used in a transition <strong>must</strong> not be <code>VK_IMAGE_LAYOUT_UNDEFINED</code> or <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code>.</p>    <h4 id="_see_also_300">See Also</h4>  <p><a href="#VkAttachmentDescription">VkAttachmentDescription</a>, <a href="#VkAttachmentReference">VkAttachmentReference</a>, <a href="#VkDescriptorImageInfo">VkDescriptorImageInfo</a>, <a href="#VkImageCreateInfo">VkImageCreateInfo</a>, <a href="#VkImageMemoryBarrier">VkImageMemoryBarrier</a>, <a href="#vkCmdBlitImage">vkCmdBlitImage</a>, <a href="#vkCmdClearColorImage">vkCmdClearColorImage</a>, <a href="#vkCmdClearDepthStencilImage">vkCmdClearDepthStencilImage</a>, <a href="#vkCmdCopyBufferToImage">vkCmdCopyBufferToImage</a>, <a href="#vkCmdCopyImage">vkCmdCopyImage</a>, <a href="#vkCmdCopyImageToBuffer">vkCmdCopyImageToBuffer</a>, <a href="#vkCmdResolveImage">vkCmdResolveImage</a></p>    <h4 id="_document_notes_300">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageLayout">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageLayout</a></p>         <h3 id="_vkimagetiling_3">VkImageTiling(3)</h3>  <h4 id="_name_301">Name</h4>  <p>VkImageTiling - Specifies the tiling arrangement of data in an image</p>    <h4 id="_c_specification_301">C Specification</h4>  <p>Possible values of <a href="#VkImageCreateInfo">VkImageCreateInfo</a>::<code>tiling</code>, specifying the tiling arrangement of data elements in an image, are:</p>  <pre id="VkImageTiling" data-language="c++">typedef enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
} VkImageTiling;</pre>   <h4 id="_description_301">Description</h4>  <ul> <li> <code>VK_IMAGE_TILING_OPTIMAL</code> specifies optimal tiling (texels are laid out in an implementation-dependent arrangement, for more optimal memory access). </li> <li> <code>VK_IMAGE_TILING_LINEAR</code> specifies linear tiling (texels are laid out in memory in row-major order, possibly with some padding on each row). </li> </ul>    <h4 id="_see_also_301">See Also</h4>  <p><a href="#VkImageCreateInfo">VkImageCreateInfo</a>, <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a>, <a href="#vkGetPhysicalDeviceSparseImageFormatProperties">vkGetPhysicalDeviceSparseImageFormatProperties</a></p>    <h4 id="_document_notes_301">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageTiling">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageTiling</a></p>         <h3 id="_vkimagetype_3">VkImageType(3)</h3>  <h4 id="_name_302">Name</h4>  <p>VkImageType - Specifies the type of an image object</p>    <h4 id="_c_specification_302">C Specification</h4>  <p>Possible values of <a href="#VkImageCreateInfo">VkImageCreateInfo</a>::<code>imageType</code>, specifying the basic dimensionality of an image, are:</p>  <pre id="VkImageType" data-language="c++">typedef enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
} VkImageType;</pre>   <h4 id="_description_302">Description</h4>  <ul> <li> <code>VK_IMAGE_TYPE_1D</code> specifies a one-dimensional image. </li> <li> <code>VK_IMAGE_TYPE_2D</code> specifies a two-dimensional image. </li> <li> <code>VK_IMAGE_TYPE_3D</code> specifies a three-dimensional image. </li> </ul>    <h4 id="_see_also_302">See Also</h4>  <p><a href="#VkImageCreateInfo">VkImageCreateInfo</a>, <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a>, <a href="#vkGetPhysicalDeviceSparseImageFormatProperties">vkGetPhysicalDeviceSparseImageFormatProperties</a></p>    <h4 id="_document_notes_302">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageType">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageType</a></p>         <h3 id="_vkimageusageflagbits_3">VkImageUsageFlagBits(3)</h3>  <h4 id="_name_303">Name</h4>  <p>VkImageUsageFlagBits - Bitmask specifying intended usage of an image</p>    <h4 id="_c_specification_303">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkImageCreateInfo">VkImageCreateInfo</a>::<code>usage</code>, specifying intended usage of an image, are:</p>  <pre id="VkImageUsageFlagBits" data-language="c++">typedef enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
} VkImageUsageFlagBits;</pre>   <h4 id="_description_303">Description</h4>  <ul> <li> <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> specifies that the image <strong>can</strong> be used as the source of a transfer command. </li> <li> <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> specifies that the image <strong>can</strong> be used as the destination of a transfer command. </li> <li> <code>VK_IMAGE_USAGE_SAMPLED_BIT</code> specifies that the image <strong>can</strong> be used to create a <code>VkImageView</code> suitable for occupying a <code>VkDescriptorSet</code> slot either of type <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code> or <code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>, and be sampled by a shader. </li> <li> <code>VK_IMAGE_USAGE_STORAGE_BIT</code> specifies that the image <strong>can</strong> be used to create a <code>VkImageView</code> suitable for occupying a <code>VkDescriptorSet</code> slot of type <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>. </li> <li> <code>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</code> specifies that the image <strong>can</strong> be used to create a <code>VkImageView</code> suitable for use as a color or resolve attachment in a <code>VkFramebuffer</code>. </li> <li> <code>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</code> specifies that the image <strong>can</strong> be used to create a <code>VkImageView</code> suitable for use as a depth/stencil attachment in a <code>VkFramebuffer</code>. </li> <li> <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code> specifies that the memory bound to this image will have been allocated with the <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code> (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory">html/vkspec.html#memory</a> for more detail). This bit <strong>can</strong> be set for any image that <strong>can</strong> be used to create a <code>VkImageView</code> suitable for use as a color, resolve, depth/stencil, or input attachment. </li> <li> <code>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</code> specifies that the image <strong>can</strong> be used to create a <code>VkImageView</code> suitable for occupying <code>VkDescriptorSet</code> slot of type <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>; be read from a shader as an input attachment; and be used as an input attachment in a framebuffer. </li> </ul>    <h4 id="_see_also_303">See Also</h4>  <p><a href="#VkImageUsageFlags">VkImageUsageFlags</a></p>    <h4 id="_document_notes_303">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageUsageFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageUsageFlagBits</a></p>         <h3 id="_vkimageviewtype_3">VkImageViewType(3)</h3>  <h4 id="_name_304">Name</h4>  <p>VkImageViewType - Image view types</p>    <h4 id="_c_specification_304">C Specification</h4>  <p>The types of image views that <strong>can</strong> be created are:</p>  <pre id="VkImageViewType" data-language="c++">typedef enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
} VkImageViewType;</pre>   <h4 id="_description_304">Description</h4>  <p>The exact image view type is partially implicit, based on the image’s type and sample count, as well as the view creation parameters as described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views-compatibility">image view compatibility table</a> for <a href="#vkCreateImageView">vkCreateImageView</a>. This table also shows which SPIR-V <code>OpTypeImage</code> <code>Dim</code> and <code>Arrayed</code> parameters correspond to each image view type.</p>    <h4 id="_see_also_304">See Also</h4>  <p><a href="#VkImageViewCreateInfo">VkImageViewCreateInfo</a></p>    <h4 id="_document_notes_304">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageViewType">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageViewType</a></p>         <h3 id="_vkindextype_3">VkIndexType(3)</h3>  <h4 id="_name_305">Name</h4>  <p>VkIndexType - Type of index buffer indices</p>    <h4 id="_c_specification_305">C Specification</h4>  <p>Possible values of <a href="#vkCmdBindIndexBuffer">vkCmdBindIndexBuffer</a>::<code>indexType</code>, specifying the size of indices, are:</p>  <pre id="VkIndexType" data-language="c++">typedef enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
} VkIndexType;</pre>   <h4 id="_description_305">Description</h4>  <ul> <li> <code>VK_INDEX_TYPE_UINT16</code> specifies that indices are 16-bit unsigned integer values. </li> <li> <code>VK_INDEX_TYPE_UINT32</code> specifies that indices are 32-bit unsigned integer values. </li> </ul>    <h4 id="_see_also_305">See Also</h4>  <p><a href="#vkCmdBindIndexBuffer">vkCmdBindIndexBuffer</a></p>    <h4 id="_document_notes_305">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkIndexType">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkIndexType</a></p>         <h3 id="_vkinternalallocationtype_3">VkInternalAllocationType(3)</h3>  <h4 id="_name_306">Name</h4>  <p>VkInternalAllocationType - Allocation type</p>    <h4 id="_c_specification_306">C Specification</h4>  <p>The <code>allocationType</code> parameter to the <code>pfnInternalAllocation</code> and <code>pfnInternalFree</code> functions <strong>may</strong> be one of the following values:</p>  <pre id="VkInternalAllocationType" data-language="c++">typedef enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
} VkInternalAllocationType;</pre>   <h4 id="_description_306">Description</h4>  <ul> <li> <code>VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE</code> specifies that the allocation is intended for execution by the host. </li> </ul>    <h4 id="_see_also_306">See Also</h4>  <p><a href="#PFN_vkInternalAllocationNotification">PFN_vkInternalAllocationNotification</a>, <a href="#PFN_vkInternalFreeNotification">PFN_vkInternalFreeNotification</a></p>    <h4 id="_document_notes_306">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkInternalAllocationType">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkInternalAllocationType</a></p>         <h3 id="_vklogicop_3">VkLogicOp(3)</h3>  <h4 id="_name_307">Name</h4>  <p>VkLogicOp - Framebuffer logical operations</p>    <h4 id="_c_specification_307">C Specification</h4>  <p>Logical operations are controlled by the <code>logicOpEnable</code> and <code>logicOp</code> members of <a href="#VkPipelineColorBlendStateCreateInfo">VkPipelineColorBlendStateCreateInfo</a>. If <code>logicOpEnable</code> is <code>VK_TRUE</code>, then a logical operation selected by <code>logicOp</code> is applied between each color attachment and the fragment’s corresponding output value, and blending of all attachments is treated as if it were disabled. Any attachments using color formats for which logical operations are not supported simply pass through the color values unmodified. The logical operation is applied independently for each of the red, green, blue, and alpha components. The <code>logicOp</code> is selected from the following operations:</p>  <pre id="VkLogicOp" data-language="c++">typedef enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
} VkLogicOp;</pre>   <h4 id="_description_307">Description</h4>   <p>The logical operations supported by Vulkan are summarized in the following table in which</p>   <ul> <li> ¬ is bitwise invert, </li> <li> ∧ is bitwise and, </li> <li> ∨ is bitwise or, </li> <li> ⊕ is bitwise exclusive or, </li> <li> s is the fragment’s R<sub>s0</sub>, G<sub>s0</sub>, B<sub>s0</sub> or A<sub>s0</sub> component value for the fragment output corresponding to the color attachment being updated, and </li> <li> d is the color attachment’s R, G, B or A component value: </li> </ul>  <div class="_table"><table class="tableblock frame-all grid-all" style="width: 75%;"> <caption class="title">Table 11. Logical Operations</caption> <colgroup> <col style="width: 50%;"> <col style="width: 50%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Mode</th> <th class="tableblock halign-left valign-top">Operation</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_CLEAR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_AND</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">s ∧ d</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_AND_REVERSE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">s ∧ ¬ d</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_COPY</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">s</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_AND_INVERTED</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">¬ s ∧ d</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_NO_OP</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">d</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_XOR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">s ⊕ d</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_OR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">s ∨ d</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_NOR</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">¬ (s ∨ d)</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_EQUIVALENT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">¬ (s ⊕ d)</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_INVERT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">¬ d</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_OR_REVERSE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">s ∨ ¬ d</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_COPY_INVERTED</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">¬ s</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_OR_INVERTED</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">¬ s ∨ d</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_NAND</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">¬ (s ∧ d)</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_LOGIC_OP_SET</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">all 1s</p></td> </tr> </tbody> </table></div>  <p>The result of the logical operation is then written to the color attachment as controlled by the component write mask, described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-blendoperations">Blend Operations</a>.</p>    <h4 id="_see_also_307">See Also</h4>  <p><a href="#VkPipelineColorBlendStateCreateInfo">VkPipelineColorBlendStateCreateInfo</a></p>    <h4 id="_document_notes_307">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkLogicOp">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkLogicOp</a></p>         <h3 id="_vkmemoryheapflagbits_3">VkMemoryHeapFlagBits(3)</h3>  <h4 id="_name_308">Name</h4>  <p>VkMemoryHeapFlagBits - Bitmask specifying attribute flags for a heap</p>    <h4 id="_c_specification_308">C Specification</h4>  <p>Bits which <strong>may</strong> be set in <a href="#VkMemoryHeap">VkMemoryHeap</a>::<code>flags</code>, indicating attribute flags for the heap, are:</p>  <pre id="VkMemoryHeapFlagBits" data-language="c++">typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
} VkMemoryHeapFlagBits;</pre>   <h4 id="_description_308">Description</h4>  <ul> <li> <code>VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code> indicates that the heap corresponds to device local memory. Device local memory <strong>may</strong> have different performance characteristics than host local memory, and <strong>may</strong> support different memory property flags. </li> </ul>    <h4 id="_see_also_308">See Also</h4>  <p><a href="#VkMemoryHeapFlags">VkMemoryHeapFlags</a></p>    <h4 id="_document_notes_308">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryHeapFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryHeapFlagBits</a></p>         <h3 id="_vkmemorypropertyflagbits_3">VkMemoryPropertyFlagBits(3)</h3>  <h4 id="_name_309">Name</h4>  <p>VkMemoryPropertyFlagBits - Bitmask specifying properties for a memory type</p>    <h4 id="_c_specification_309">C Specification</h4>  <p>Bits which <strong>may</strong> be set in <a href="#VkMemoryType">VkMemoryType</a>::<code>propertyFlags</code>, indicating properties of a memory heap, are:</p>  <pre id="VkMemoryPropertyFlagBits" data-language="c++">typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
} VkMemoryPropertyFlagBits;</pre>   <h4 id="_description_309">Description</h4>  <ul> <li> <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> bit indicates that memory allocated with this type is the most efficient for device access. This property will only be set for memory types belonging to heaps with the <code>VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code> set. </li> <li> <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> bit indicates that memory allocated with this type <strong>can</strong> be mapped for host access using <a href="#vkMapMemory">vkMapMemory</a>. </li> <li> <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> bit indicates that the host cache management commands <a href="#vkFlushMappedMemoryRanges">vkFlushMappedMemoryRanges</a> and <a href="#vkInvalidateMappedMemoryRanges">vkInvalidateMappedMemoryRanges</a> are not needed to flush host writes to the device or make device writes visible to the host, respectively. </li> <li> <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> bit indicates that memory allocated with this type is cached on the host. Host memory accesses to uncached memory are slower than to cached memory, however uncached memory is always host coherent. </li> <li> <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code> bit indicates that the memory type only allows device access to the memory. Memory types <strong>must</strong> not have both <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> set. Additionally, the object’s backing memory <strong>may</strong> be provided by the implementation lazily as specified in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-device-lazy_allocation">Lazily Allocated Memory</a>. </li> </ul>    <h4 id="_see_also_309">See Also</h4>  <p><a href="#VkMemoryPropertyFlags">VkMemoryPropertyFlags</a></p>    <h4 id="_document_notes_309">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryPropertyFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryPropertyFlagBits</a></p>         <h3 id="_vkobjecttype_3">VkObjectType(3)</h3>  <h4 id="_name_310">Name</h4>  <p>VkObjectType - Specify an enumeration to track object handle types</p>    <h4 id="_c_specification_310">C Specification</h4>  <p>The <a href="#VkObjectType">VkObjectType</a> enumeration defines values, each of which corresponds to a specific Vulkan handle type. These values <strong>can</strong> be used to associate debug information with a particular type of object through one or more extensions.</p>  <pre id="VkObjectType" data-language="c++">typedef enum VkObjectType {
    VK_OBJECT_TYPE_UNKNOWN = 0,
    VK_OBJECT_TYPE_INSTANCE = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
    VK_OBJECT_TYPE_DEVICE = 3,
    VK_OBJECT_TYPE_QUEUE = 4,
    VK_OBJECT_TYPE_SEMAPHORE = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
    VK_OBJECT_TYPE_FENCE = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
    VK_OBJECT_TYPE_BUFFER = 9,
    VK_OBJECT_TYPE_IMAGE = 10,
    VK_OBJECT_TYPE_EVENT = 11,
    VK_OBJECT_TYPE_QUERY_POOL = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
    VK_OBJECT_TYPE_SHADER_MODULE = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
    VK_OBJECT_TYPE_RENDER_PASS = 18,
    VK_OBJECT_TYPE_PIPELINE = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
    VK_OBJECT_TYPE_SAMPLER = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
    VK_OBJECT_TYPE_COMMAND_POOL = 25,
} VkObjectType;</pre>   <h4 id="_description_310">Description</h4> <div class="_table"><table id="debugging-object-types" class="tableblock frame-all grid-all" style="width: 80%;"> <caption class="title">Table 12. VkObjectType and Vulkan Handle Relationship</caption> <colgroup> <col style="width: 60.3448%;"> <col style="width: 39.6552%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top"><a href="#VkObjectType">VkObjectType</a></th> <th class="tableblock halign-left valign-top">Vulkan Handle Type</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_UNKNOWN</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Unknown/Undefined Handle</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_INSTANCE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkInstance">VkInstance</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_PHYSICAL_DEVICE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkPhysicalDevice">VkPhysicalDevice</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_DEVICE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkDevice">VkDevice</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_QUEUE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkQueue">VkQueue</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_SEMAPHORE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkSemaphore">VkSemaphore</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_COMMAND_BUFFER</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkCommandBuffer">VkCommandBuffer</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_FENCE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkFence">VkFence</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_DEVICE_MEMORY</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkDeviceMemory">VkDeviceMemory</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_BUFFER</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkBuffer">VkBuffer</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_IMAGE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkImage">VkImage</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_EVENT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkEvent">VkEvent</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_QUERY_POOL</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkQueryPool">VkQueryPool</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_BUFFER_VIEW</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkBufferView">VkBufferView</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_IMAGE_VIEW</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkImageView">VkImageView</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_SHADER_MODULE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkShaderModule">VkShaderModule</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_PIPELINE_CACHE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkPipelineCache">VkPipelineCache</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_PIPELINE_LAYOUT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkPipelineLayout">VkPipelineLayout</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_RENDER_PASS</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkRenderPass">VkRenderPass</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_PIPELINE</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkPipeline">VkPipeline</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkDescriptorSetLayout">VkDescriptorSetLayout</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_SAMPLER</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkSampler">VkSampler</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_DESCRIPTOR_POOL</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkDescriptorPool">VkDescriptorPool</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_DESCRIPTOR_SET</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkDescriptorSet">VkDescriptorSet</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_FRAMEBUFFER</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkFramebuffer">VkFramebuffer</a></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>VK_OBJECT_TYPE_COMMAND_POOL</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#VkCommandPool">VkCommandPool</a></p></td> </tr> </tbody> </table></div>   <h4 id="_see_also_310">See Also</h4>  <p>No cross-references are available</p>    <h4 id="_document_notes_310">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkObjectType">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkObjectType</a></p>         <h3 id="_vkphysicaldevicetype_3">VkPhysicalDeviceType(3)</h3>  <h4 id="_name_311">Name</h4>  <p>VkPhysicalDeviceType - Supported physical device types</p>    <h4 id="_c_specification_311">C Specification</h4>  <p>The physical device types which <strong>may</strong> be returned in <a href="#VkPhysicalDeviceProperties">VkPhysicalDeviceProperties</a>::<code>deviceType</code> are:</p>  <pre id="VkPhysicalDeviceType" data-language="c++">typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
} VkPhysicalDeviceType;</pre>   <h4 id="_description_311">Description</h4>  <ul> <li> <code>VK_PHYSICAL_DEVICE_TYPE_OTHER</code> - the device does not match any other available types. </li> <li> <code>VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</code> - the device is typically one embedded in or tightly coupled with the host. </li> <li> <code>VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</code> - the device is typically a separate processor connected to the host via an interlink. </li> <li> <code>VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU</code> - the device is typically a virtual node in a virtualization environment. </li> <li> <code>VK_PHYSICAL_DEVICE_TYPE_CPU</code> - the device is typically running on the same processors as the host. </li> </ul>   <p>The physical device type is advertised for informational purposes only, and does not directly affect the operation of the system. However, the device type <strong>may</strong> correlate with other advertised properties or capabilities of the system, such as how many memory heaps there are.</p>    <h4 id="_see_also_311">See Also</h4>  <p><a href="#VkPhysicalDeviceProperties">VkPhysicalDeviceProperties</a></p>    <h4 id="_document_notes_311">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceType">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPhysicalDeviceType</a></p>         <h3 id="_vkpipelinebindpoint_3">VkPipelineBindPoint(3)</h3>  <h4 id="_name_312">Name</h4>  <p>VkPipelineBindPoint - Specify the bind point of a pipeline object to a command buffer</p>    <h4 id="_c_specification_312">C Specification</h4>  <p>Possible values of <a href="#vkCmdBindPipeline">vkCmdBindPipeline</a>::<code>pipelineBindPoint</code>, specifying the bind point of a pipeline object, are:</p>  <pre id="VkPipelineBindPoint" data-language="c++">typedef enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
} VkPipelineBindPoint;</pre>   <h4 id="_description_312">Description</h4>  <ul> <li> <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> specifies binding as a compute pipeline. </li> <li> <code>VK_PIPELINE_BIND_POINT_GRAPHICS</code> specifies binding as a graphics pipeline. </li> </ul>    <h4 id="_see_also_312">See Also</h4>  <p><a href="#VkSubpassDescription">VkSubpassDescription</a>, <a href="#vkCmdBindDescriptorSets">vkCmdBindDescriptorSets</a>, <a href="#vkCmdBindPipeline">vkCmdBindPipeline</a></p>    <h4 id="_document_notes_312">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineBindPoint">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineBindPoint</a></p>         <h3 id="_vkpipelinecacheheaderversion_3">VkPipelineCacheHeaderVersion(3)</h3>  <h4 id="_name_313">Name</h4>  <p>VkPipelineCacheHeaderVersion - Encode pipeline cache version</p>    <h4 id="_c_specification_313">C Specification</h4>  <p>Possible values of the second group of four bytes in the header returned by <a href="#vkGetPipelineCacheData">vkGetPipelineCacheData</a>, encoding the pipeline cache version, are:</p>  <pre id="VkPipelineCacheHeaderVersion" data-language="c++">typedef enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
} VkPipelineCacheHeaderVersion;</pre>   <h4 id="_description_313">Description</h4>  <ul> <li> <code>VK_PIPELINE_CACHE_HEADER_VERSION_ONE</code> specifies version one of the pipeline cache. </li> </ul>    <h4 id="_see_also_313">See Also</h4>  <p><a href="#vkCreatePipelineCache">vkCreatePipelineCache</a>, <a href="#vkGetPipelineCacheData">vkGetPipelineCacheData</a></p>    <h4 id="_document_notes_313">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCacheHeaderVersion">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCacheHeaderVersion</a></p>         <h3 id="_vkpipelinecreateflagbits_3">VkPipelineCreateFlagBits(3)</h3>  <h4 id="_name_314">Name</h4>  <p>VkPipelineCreateFlagBits - Bitmask controlling how a pipeline is created</p>    <h4 id="_c_specification_314">C Specification</h4>  <p>Possible values of the <code>flags</code> member of <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a> and <a href="#VkComputePipelineCreateInfo">VkComputePipelineCreateInfo</a>, specifying how a pipeline is created, are:</p>  <pre id="VkPipelineCreateFlagBits" data-language="c++">typedef enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
} VkPipelineCreateFlagBits;</pre>   <h4 id="_description_314">Description</h4>  <ul> <li> <code>VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT</code> specifies that the created pipeline will not be optimized. Using this flag <strong>may</strong> reduce the time taken to create the pipeline. </li> <li> <code>VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT</code> specifies that the pipeline to be created is allowed to be the parent of a pipeline that will be created in a subsequent call to <a href="#vkCreateGraphicsPipelines">vkCreateGraphicsPipelines</a> or <a href="#vkCreateComputePipelines">vkCreateComputePipelines</a>. </li> <li> <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code> specifies that the pipeline to be created will be a child of a previously created parent pipeline. </li> </ul>   <p>It is valid to set both <code>VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT</code> and <code>VK_PIPELINE_CREATE_DERIVATIVE_BIT</code>. This allows a pipeline to be both a parent and possibly a child in a pipeline hierarchy. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-pipeline-derivatives">Pipeline Derivatives</a> for more information.</p>    <h4 id="_see_also_314">See Also</h4>  <p><a href="#VkPipelineCreateFlags">VkPipelineCreateFlags</a></p>    <h4 id="_document_notes_314">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCreateFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCreateFlagBits</a></p>         <h3 id="_vkpipelinestageflagbits_3">VkPipelineStageFlagBits(3)</h3>  <h4 id="_name_315">Name</h4>  <p>VkPipelineStageFlagBits - Bitmask specifying pipeline stages</p>    <h4 id="_c_specification_315">C Specification</h4>  <p>Several of the synchronization commands include pipeline stage parameters, restricting the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes">synchronization scopes</a> for that command to just those stages. This allows fine grained control over the exact execution dependencies and accesses performed by action commands. Implementations <strong>should</strong> use these pipeline stages to avoid unnecessary stalls or cache flushing.</p>   <p>Bits which can be set, specifying pipeline stages, are:</p>  <pre id="VkPipelineStageFlagBits" data-language="c++">typedef enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
} VkPipelineStageFlagBits;</pre>   <h4 id="_description_315">Description</h4>  <ul> <li> <code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code> specifies the stage of the pipeline where any commands are initially received by the queue. </li> <li> <code>VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT</code> specifies the stage of the pipeline where Draw/DispatchIndirect data structures are consumed. </li> <li> <code>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</code> specifies the stage of the pipeline where vertex and index buffers are consumed. </li> <li> <code>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT</code> specifies the vertex shader stage. </li> <li> <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> specifies the tessellation control shader stage. </li> <li> <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> specifies the tessellation evaluation shader stage. </li> <li> <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> specifies the geometry shader stage. </li> <li> <code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code> specifies the fragment shader stage. </li> <li> <code>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code> specifies the stage of the pipeline where early fragment tests (depth and stencil tests before fragment shading) are performed. This stage also includes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-load-store-ops">subpass load operations</a> for framebuffer attachments with a depth/stencil format. </li> <li> <code>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</code> specifies the stage of the pipeline where late fragment tests (depth and stencil tests after fragment shading) are performed. This stage also includes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-load-store-ops">subpass store operations</a> for framebuffer attachments with a depth/stencil format. </li> <li> <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> specifies the stage of the pipeline after blending where the final color values are output from the pipeline. This stage also includes <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-load-store-ops">subpass load and store operations</a> and multisample resolve operations for framebuffer attachments with a color format. </li> <li id="synchronization-pipeline-stages-transfer">  <code>VK_PIPELINE_STAGE_TRANSFER_BIT</code> specifies the execution of copy commands. This includes the operations resulting from all <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#copies">copy commands</a>, <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#clears">clear commands</a> (with the exception of <a href="#vkCmdClearAttachments">vkCmdClearAttachments</a>), and <a href="#vkCmdCopyQueryPoolResults">vkCmdCopyQueryPoolResults</a>. </li> <li> <code>VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT</code> specifies the execution of a compute shader. </li> <li> <code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> specifies the final stage in the pipeline where operations generated by all commands complete execution. </li> <li> <code>VK_PIPELINE_STAGE_HOST_BIT</code> specifies a pseudo-stage indicating execution on the host of reads/writes of device memory. This stage is not invoked by any commands recorded in a command buffer. </li> <li> <p><code>VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT</code> specifies the execution of all graphics pipeline stages, and is equivalent to the logical OR of:</p>  <ul> <li> <code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> </li> <li> <code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> </li> </ul>  </li> <li> <code>VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code> is equivalent to the logical OR of every other pipeline stage flag that is supported on the queue it is used with. </li> </ul>  <blockquote> <h5 class="title">Note</h5>  <p>An execution dependency with only <code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> in the destination stage mask will only prevent that stage from executing in subsequently submitted commands. As this stage does not perform any actual execution, this is not observable - in effect, it does not delay processing of subsequent commands. Similarly an execution dependency with only <code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code> in the source stage mask will effectively not wait for any prior commands to complete.</p>   <p>When defining a memory dependency, using only <code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> or <code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code> would never make any accesses available and/or visible because these stages do not access memory.</p>   <p><code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> and <code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code> are useful for accomplishing layout transitions and queue ownership operations when the required execution dependency is satisfied by other means - for example, semaphore operations between queues.</p>  </blockquote>   <h4 id="_see_also_315">See Also</h4>  <p><a href="#VkPipelineStageFlags">VkPipelineStageFlags</a>, <a href="#vkCmdWriteTimestamp">vkCmdWriteTimestamp</a></p>    <h4 id="_document_notes_315">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineStageFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineStageFlagBits</a></p>         <h3 id="_vkpolygonmode_3">VkPolygonMode(3)</h3>  <h4 id="_name_316">Name</h4>  <p>VkPolygonMode - Control polygon rasterization mode</p>    <h4 id="_c_specification_316">C Specification</h4>  <p>Possible values of the <a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a>::<code>polygonMode</code> property of the currently active pipeline, specifying the method of rasterization for polygons, are:</p>  <pre id="VkPolygonMode" data-language="c++">typedef enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
} VkPolygonMode;</pre>   <h4 id="_description_316">Description</h4>  <ul> <li> <code>VK_POLYGON_MODE_POINT</code> specifies that polygon vertices are drawn as points. </li> <li> <code>VK_POLYGON_MODE_LINE</code> specifies that polygon edges are drawn as line segments. </li> <li> <code>VK_POLYGON_MODE_FILL</code> specifies that polygons are rendered using the polygon rasterization rules in this section. </li> </ul>   <p>These modes affect only the final rasterization of polygons: in particular, a polygon’s vertices are shaded and the polygon is clipped and possibly culled before these modes are applied.</p>    <h4 id="_see_also_316">See Also</h4>  <p><a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a></p>    <h4 id="_document_notes_316">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPolygonMode">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPolygonMode</a></p>         <h3 id="_vkprimitivetopology_3">VkPrimitiveTopology(3)</h3>  <h4 id="_name_317">Name</h4>  <p>VkPrimitiveTopology - Supported primitive topologies</p>    <h4 id="_c_specification_317">C Specification</h4>  <p><em>Primitive topology</em> determines how consecutive vertices are organized into primitives, and determines the type of primitive that is used at the beginning of the graphics pipeline. The effective topology for later stages of the pipeline is altered by tessellation or geometry shading (if either is in use) and depends on the execution modes of those shaders. Supported topologies are defined by <a href="#VkPrimitiveTopology">VkPrimitiveTopology</a> and include:</p>  <pre id="VkPrimitiveTopology" data-language="c++">typedef enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
} VkPrimitiveTopology;</pre>      <h4 id="_see_also_317">See Also</h4>  <p><a href="#VkPipelineInputAssemblyStateCreateInfo">VkPipelineInputAssemblyStateCreateInfo</a></p>    <h4 id="_document_notes_317">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPrimitiveTopology">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPrimitiveTopology</a></p>         <h3 id="_vkquerycontrolflagbits_3">VkQueryControlFlagBits(3)</h3>  <h4 id="_name_318">Name</h4>  <p>VkQueryControlFlagBits - Bitmask specifying constraints on a query</p>    <h4 id="_c_specification_318">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#vkCmdBeginQuery">vkCmdBeginQuery</a>::<code>flags</code>, specifying constraints on the types of queries that <strong>can</strong> be performed, are:</p>  <pre id="VkQueryControlFlagBits" data-language="c++">typedef enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
} VkQueryControlFlagBits;</pre>   <h4 id="_description_318">Description</h4>  <ul> <li> <code>VK_QUERY_CONTROL_PRECISE_BIT</code> specifies the precision of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-occlusion">occlusion queries</a>. </li> </ul>    <h4 id="_see_also_318">See Also</h4>  <p><a href="#VkQueryControlFlags">VkQueryControlFlags</a></p>    <h4 id="_document_notes_318">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryControlFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryControlFlagBits</a></p>         <h3 id="_vkquerypipelinestatisticflagbits_3">VkQueryPipelineStatisticFlagBits(3)</h3>  <h4 id="_name_319">Name</h4>  <p>VkQueryPipelineStatisticFlagBits - Bitmask specifying queried pipeline statistics</p>    <h4 id="_c_specification_319">C Specification</h4>  <p>Bits which <strong>can</strong> be set to individually enable pipeline statistics counters for query pools with <a href="#VkQueryPoolCreateInfo">VkQueryPoolCreateInfo</a>::<code>pipelineStatistics</code>, and for secondary command buffers with <a href="#VkCommandBufferInheritanceInfo">VkCommandBufferInheritanceInfo</a>::<code>pipelineStatistics</code>, are:</p>  <pre id="VkQueryPipelineStatisticFlagBits" data-language="c++">typedef enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
} VkQueryPipelineStatisticFlagBits;</pre>   <h4 id="_description_319">Description</h4>  <ul> <li> <code>VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT</code> specifies that queries managed by the pool will count the number of vertices processed by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#drawing">input assembly</a> stage. Vertices corresponding to incomplete primitives <strong>may</strong> contribute to the count. </li> <li> <code>VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT</code> specifies that queries managed by the pool will count the number of primitives processed by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#drawing">input assembly</a> stage. If primitive restart is enabled, restarting the primitive topology has no effect on the count. Incomplete primitives <strong>may</strong> be counted. </li> <li> <code>VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT</code> specifies that queries managed by the pool will count the number of vertex shader invocations. This counter’s value is incremented each time a vertex shader is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-vertex-execution">invoked</a>. </li> <li> <code>VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT</code> specifies that queries managed by the pool will count the number of geometry shader invocations. This counter’s value is incremented each time a geometry shader is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-geometry-execution">invoked</a>. In the case of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#geometry-invocations">instanced geometry shaders</a>, the geometry shader invocations count is incremented for each separate instanced invocation. </li> <li> <code>VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT</code> specifies that queries managed by the pool will count the number of primitives generated by geometry shader invocations. The counter’s value is incremented each time the geometry shader emits a primitive. Restarting primitive topology using the SPIR-V instructions <code>OpEndPrimitive</code> or <code>OpEndStreamPrimitive</code> has no effect on the geometry shader output primitives count. </li> <li> <code>VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT</code> specifies that queries managed by the pool will count the number of primitives processed by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vertexpostproc-clipping">Primitive Clipping</a> stage of the pipeline. The counter’s value is incremented each time a primitive reaches the primitive clipping stage. </li> <li> <p><code>VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT</code> specifies that queries managed by the pool will count the number of primitives output by the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vertexpostproc-clipping">Primitive Clipping</a> stage of the pipeline. The counter’s value is incremented each time a primitive passes the primitive clipping stage. The actual number of primitives output by the primitive clipping stage for a particular input primitive is implementation-dependent but <strong>must</strong> satisfy the following conditions:</p>  <ul> <li> If at least one vertex of the input primitive lies inside the clipping volume, the counter is incremented by one or more. </li> <li> Otherwise, the counter is incremented by zero or more. </li> </ul>  </li> <li> <code>VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT</code> specifies that queries managed by the pool will count the number of fragment shader invocations. The counter’s value is incremented each time the fragment shader is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-fragment-execution">invoked</a>. </li> <li> <code>VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT</code> specifies that queries managed by the pool will count the number of patches processed by the tessellation control shader. The counter’s value is incremented once for each patch for which a tessellation control shader is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-tessellation-control-execution">invoked</a>. </li> <li> <code>VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT</code> specifies that queries managed by the pool will count the number of invocations of the tessellation evaluation shader. The counter’s value is incremented each time the tessellation evaluation shader is <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-tessellation-evaluation-execution">invoked</a>. </li> <li> <code>VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT</code> specifies that queries managed by the pool will count the number of compute shader invocations. The counter’s value is incremented every time the compute shader is invoked. Implementations <strong>may</strong> skip the execution of certain compute shader invocations or execute additional compute shader invocations for implementation-dependent reasons as long as the results of rendering otherwise remain unchanged. </li> </ul>   <p>These values are intended to measure relative statistics on one implementation. Various device architectures will count these values differently. Any or all counters <strong>may</strong> be affected by the issues described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-undefined">Query Operation</a>.</p>  <blockquote> <h5 class="title">Note</h5>  <p>For example, tile-based rendering devices <strong>may</strong> need to replay the scene multiple times, affecting some of the counts.</p>  </blockquote>  <p>If a pipeline has <code>rasterizerDiscardEnable</code> enabled, implementations <strong>may</strong> discard primitives after the final vertex processing stage. As a result, if <code>rasterizerDiscardEnable</code> is enabled, the clipping input and output primitives counters <strong>may</strong> not be incremented.</p>   <p>When a pipeline statistics query finishes, the result for that query is marked as available. The application <strong>can</strong> copy the result to a buffer (via <code>vkCmdCopyQueryPoolResults</code>), or request it be put into host memory (via <code>vkGetQueryPoolResults</code>).</p>    <h4 id="_see_also_319">See Also</h4>  <p><a href="#VkQueryPipelineStatisticFlags">VkQueryPipelineStatisticFlags</a></p>    <h4 id="_document_notes_319">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryPipelineStatisticFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryPipelineStatisticFlagBits</a></p>         <h3 id="_vkqueryresultflagbits_3">VkQueryResultFlagBits(3)</h3>  <h4 id="_name_320">Name</h4>  <p>VkQueryResultFlagBits - Bitmask specifying how and when query results are returned</p>    <h4 id="_c_specification_320">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#vkGetQueryPoolResults">vkGetQueryPoolResults</a>::<code>flags</code> and <a href="#vkCmdCopyQueryPoolResults">vkCmdCopyQueryPoolResults</a>::<code>flags</code>, specifying how and when results are returned, are:</p>  <pre id="VkQueryResultFlagBits" data-language="c++">typedef enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 0x00000001,
    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
} VkQueryResultFlagBits;</pre>   <h4 id="_description_320">Description</h4>  <ul> <li> <code>VK_QUERY_RESULT_64_BIT</code> specifies the results will be written as an array of 64-bit unsigned integer values. If this bit is not set, the results will be written as an array of 32-bit unsigned integer values. </li> <li> <code>VK_QUERY_RESULT_WAIT_BIT</code> specifies that Vulkan will wait for each query’s status to become available before retrieving its results. </li> <li> <code>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</code> specifies that the availability status accompanies the results. </li> <li> <code>VK_QUERY_RESULT_PARTIAL_BIT</code> specifies that returning partial results is acceptable. </li> </ul>    <h4 id="_see_also_320">See Also</h4>  <p><a href="#VkQueryResultFlags">VkQueryResultFlags</a></p>    <h4 id="_document_notes_320">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryResultFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryResultFlagBits</a></p>         <h3 id="_vkquerytype_3">VkQueryType(3)</h3>  <h4 id="_name_321">Name</h4>  <p>VkQueryType - Specify the type of queries managed by a query pool</p>    <h4 id="_c_specification_321">C Specification</h4>  <p>Possible values of <a href="#VkQueryPoolCreateInfo">VkQueryPoolCreateInfo</a>::<code>queryType</code>, specifying the type of queries managed by the pool, are:</p>  <pre id="VkQueryType" data-language="c++">typedef enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
} VkQueryType;</pre>   <h4 id="_description_321">Description</h4>  <ul> <li> <code>VK_QUERY_TYPE_OCCLUSION</code> specifies an <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-occlusion">occlusion query</a>. </li> <li> <code>VK_QUERY_TYPE_PIPELINE_STATISTICS</code> specifies a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-pipestats">pipeline statistics query</a>. </li> <li> <code>VK_QUERY_TYPE_TIMESTAMP</code> specifies a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-timestamps">timestamp query</a>. </li> </ul>    <h4 id="_see_also_321">See Also</h4>  <p><a href="#VkQueryPoolCreateInfo">VkQueryPoolCreateInfo</a></p>    <h4 id="_document_notes_321">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryType">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryType</a></p>         <h3 id="_vkqueueflagbits_3">VkQueueFlagBits(3)</h3>  <h4 id="_name_322">Name</h4>  <p>VkQueueFlagBits - Bitmask specifying capabilities of queues in a queue family</p>    <h4 id="_c_specification_322">C Specification</h4>  <p>Bits which <strong>may</strong> be set in <a href="#VkQueueFamilyProperties">VkQueueFamilyProperties</a>::<code>queueFlags</code> indicating capabilities of queues in a queue family are:</p>  <pre id="VkQueueFlagBits" data-language="c++">typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
} VkQueueFlagBits;</pre>   <h4 id="_description_322">Description</h4>  <ul> <li> <code>VK_QUEUE_GRAPHICS_BIT</code> indicates that queues in this queue family support graphics operations. </li> <li> <code>VK_QUEUE_COMPUTE_BIT</code> indicates that queues in this queue family support compute operations. </li> <li> <code>VK_QUEUE_TRANSFER_BIT</code> indicates that queues in this queue family support transfer operations. </li> <li> <code>VK_QUEUE_SPARSE_BINDING_BIT</code> indicates that queues in this queue family support sparse memory management operations (see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory">Sparse Resources</a>). If any of the sparse resource features are enabled, then at least one queue family <strong>must</strong> support this bit. </li> </ul>   <p>If an implementation exposes any queue family that supports graphics operations, at least one queue family of at least one physical device exposed by the implementation <strong>must</strong> support both graphics and compute operations.</p>  <blockquote> <h5 class="title">Note</h5>  <p>All commands that are allowed on a queue that supports transfer operations are also allowed on a queue that supports either graphics or compute operations. Thus, if the capabilities of a queue family include <code>VK_QUEUE_GRAPHICS_BIT</code> or <code>VK_QUEUE_COMPUTE_BIT</code>, then reporting the <code>VK_QUEUE_TRANSFER_BIT</code> capability separately for that queue family is <strong>optional</strong>.</p>  </blockquote>  <p>For further details see <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-queues">Queues</a>.</p>    <h4 id="_see_also_322">See Also</h4>  <p><a href="#VkQueueFlags">VkQueueFlags</a></p>    <h4 id="_document_notes_322">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueueFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueueFlagBits</a></p>         <h3 id="_vkresult_3">VkResult(3)</h3>  <h4 id="_name_323">Name</h4>  <p>VkResult - Vulkan command return codes</p>    <h4 id="_c_specification_323">C Specification</h4>  <p>While the core Vulkan API is not designed to capture incorrect usage, some circumstances still require return codes. Commands in Vulkan return their status via return codes that are in one of two categories:</p>   <ul> <li> Successful completion codes are returned when a command needs to communicate success or status information. All successful completion codes are non-negative values. </li> <li> Run time error codes are returned when a command needs to communicate a failure that could only be detected at run time. All run time error codes are negative values. </li> </ul>   <p>All return codes in Vulkan are reported via <a href="#VkResult">VkResult</a> return values. The possible codes are:</p>  <pre id="VkResult" data-language="c++">typedef enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
} VkResult;</pre>   <h4 id="_description_323">Description</h4>  <div class="title">Success Codes</div> <ul> <li> <code>VK_SUCCESS</code> Command successfully completed </li> <li> <code>VK_NOT_READY</code> A fence or query has not yet completed </li> <li> <code>VK_TIMEOUT</code> A wait operation has not completed in the specified time </li> <li> <code>VK_EVENT_SET</code> An event is signaled </li> <li> <code>VK_EVENT_RESET</code> An event is unsignaled </li> <li> <code>VK_INCOMPLETE</code> A return array was too small for the result </li> </ul>   <div class="title">Error codes</div> <ul> <li> <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> A host memory allocation has failed. </li> <li> <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> A device memory allocation has failed. </li> <li> <code>VK_ERROR_INITIALIZATION_FAILED</code> Initialization of an object could not be completed for implementation-specific reasons. </li> <li> <code>VK_ERROR_DEVICE_LOST</code> The logical or physical device has been lost. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device">Lost Device</a> </li> <li> <code>VK_ERROR_MEMORY_MAP_FAILED</code> Mapping of a memory object has failed. </li> <li> <code>VK_ERROR_LAYER_NOT_PRESENT</code> A requested layer is not present or could not be loaded. </li> <li> <code>VK_ERROR_EXTENSION_NOT_PRESENT</code> A requested extension is not supported. </li> <li> <code>VK_ERROR_FEATURE_NOT_PRESENT</code> A requested feature is not supported. </li> <li> <code>VK_ERROR_INCOMPATIBLE_DRIVER</code> The requested version of Vulkan is not supported by the driver or is otherwise incompatible for implementation-specific reasons. </li> <li> <code>VK_ERROR_TOO_MANY_OBJECTS</code> Too many objects of the type have already been created. </li> <li> <code>VK_ERROR_FORMAT_NOT_SUPPORTED</code> A requested format is not supported on this device. </li> <li> <code>VK_ERROR_FRAGMENTED_POOL</code> A pool allocation has failed due to fragmentation of the pool’s memory. This <strong>must</strong> only be returned if no attempt to allocate host or device memory was made to accomodate the new allocation. </li> </ul>   <p>If a command returns a run time error, it will leave any result pointers unmodified, unless other behavior is explicitly defined in the specification.</p>   <p>Out of memory errors do not damage any currently existing Vulkan objects. Objects that have already been successfully created <strong>can</strong> still be used by the application.</p>   <p>Performance-critical commands generally do not have return codes. If a run time error occurs in such commands, the implementation will defer reporting the error until a specified point. For commands that record into command buffers (<code>vkCmd*</code>) run time errors are reported by <code>vkEndCommandBuffer</code>.</p>    <h4 id="_see_also_323">See Also</h4>  <p>No cross-references are available</p>    <h4 id="_document_notes_323">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkResult">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkResult</a></p>         <h3 id="_vksamplecountflagbits_3">VkSampleCountFlagBits(3)</h3>  <h4 id="_name_324">Name</h4>  <p>VkSampleCountFlagBits - Bitmask specifying sample counts supported for an image used for storage operations</p>    <h4 id="_c_specification_324">C Specification</h4>  <p>Bits which <strong>may</strong> be set in the sample count limits returned by <a href="#VkPhysicalDeviceLimits">VkPhysicalDeviceLimits</a>, as well as in other queries and structures representing image sample counts, are:</p>  <pre id="VkSampleCountFlagBits" data-language="c++">typedef enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
} VkSampleCountFlagBits;</pre>   <h4 id="_description_324">Description</h4>  <ul> <li> <code>VK_SAMPLE_COUNT_1_BIT</code> specifies an image with one sample per pixel. </li> <li> <code>VK_SAMPLE_COUNT_2_BIT</code> specifies an image with 2 samples per pixel. </li> <li> <code>VK_SAMPLE_COUNT_4_BIT</code> specifies an image with 4 samples per pixel. </li> <li> <code>VK_SAMPLE_COUNT_8_BIT</code> specifies an image with 8 samples per pixel. </li> <li> <code>VK_SAMPLE_COUNT_16_BIT</code> specifies an image with 16 samples per pixel. </li> <li> <code>VK_SAMPLE_COUNT_32_BIT</code> specifies an image with 32 samples per pixel. </li> <li> <code>VK_SAMPLE_COUNT_64_BIT</code> specifies an image with 64 samples per pixel. </li> </ul>    <h4 id="_see_also_324">See Also</h4>  <p><a href="#VkAttachmentDescription">VkAttachmentDescription</a>, <a href="#VkImageCreateInfo">VkImageCreateInfo</a>, <a href="#VkPipelineMultisampleStateCreateInfo">VkPipelineMultisampleStateCreateInfo</a>, <a href="#VkSampleCountFlags">VkSampleCountFlags</a>, <a href="#vkGetPhysicalDeviceSparseImageFormatProperties">vkGetPhysicalDeviceSparseImageFormatProperties</a></p>    <h4 id="_document_notes_324">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSampleCountFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSampleCountFlagBits</a></p>         <h3 id="_vksampleraddressmode_3">VkSamplerAddressMode(3)</h3>  <h4 id="_name_325">Name</h4>  <p>VkSamplerAddressMode - Specify behavior of sampling with texture coordinates outside an image</p>    <h4 id="_c_specification_325">C Specification</h4>  <p>Possible values of the <a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a>::<code>addressMode</code>* parameters, specifying the behavior of sampling with coordinates outside the range [0,1] for the respective u, v, or w coordinate as defined in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-wrapping-operation">Wrapping Operation</a> section, are:</p>  <pre id="VkSamplerAddressMode" data-language="c++">typedef enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
} VkSamplerAddressMode;</pre>   <h4 id="_description_325">Description</h4>  <ul> <li> <code>VK_SAMPLER_ADDRESS_MODE_REPEAT</code> specifies that the repeat wrap mode will be used. </li> <li> <code>VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT</code> specifies that the mirrored repeat wrap mode will be used. </li> <li> <code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</code> specifies that the clamp to edge wrap mode will be used. </li> <li> <code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</code> specifies that the clamp to border wrap mode will be used. </li> <li> <code>VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE</code> specifies that the mirror clamp to edge wrap mode will be used. This is only valid if the VK_KHR_mirror_clamp_to_edge extension is enabled. </li> </ul>    <h4 id="_see_also_325">See Also</h4>  <p><a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a></p>    <h4 id="_document_notes_325">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSamplerAddressMode">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSamplerAddressMode</a></p>         <h3 id="_vksamplermipmapmode_3">VkSamplerMipmapMode(3)</h3>  <h4 id="_name_326">Name</h4>  <p>VkSamplerMipmapMode - Specify mipmap mode used for texture lookups</p>    <h4 id="_c_specification_326">C Specification</h4>  <p>Possible values of the <a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a>::<code>mipmapMode</code>, specifying the mipmap mode used for texture lookups, are:</p>  <pre id="VkSamplerMipmapMode" data-language="c++">typedef enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
} VkSamplerMipmapMode;</pre>   <h4 id="_description_326">Description</h4>  <ul> <li> <code>VK_SAMPLER_MIPMAP_MODE_NEAREST</code> specifies nearest filtering. </li> <li> <code>VK_SAMPLER_MIPMAP_MODE_LINEAR</code> specifies linear filtering. </li> </ul>   <p>These modes are described in detail in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-filtering">Texel Filtering</a>.</p>    <h4 id="_see_also_326">See Also</h4>  <p><a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a></p>    <h4 id="_document_notes_326">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSamplerMipmapMode">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSamplerMipmapMode</a></p>         <h3 id="_vkshaderstageflagbits_3">VkShaderStageFlagBits(3)</h3>  <h4 id="_name_327">Name</h4>  <p>VkShaderStageFlagBits - Bitmask specifying a pipeline stage</p>    <h4 id="_c_specification_327">C Specification</h4>  <p>Commands and structures which need to specify one or more shader stages do so using a bitmask whose bits correspond to stages. Bits which <strong>can</strong> be set to specify shader stages are:</p>  <pre id="VkShaderStageFlagBits" data-language="c++">typedef enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
} VkShaderStageFlagBits;</pre>   <h4 id="_description_327">Description</h4>  <ul> <li> <code>VK_SHADER_STAGE_VERTEX_BIT</code> specifies the vertex stage. </li> <li> <code>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT</code> specifies the tessellation control stage. </li> <li> <code>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT</code> specifies the tessellation evaluation stage. </li> <li> <code>VK_SHADER_STAGE_GEOMETRY_BIT</code> specifies the geometry stage. </li> <li> <code>VK_SHADER_STAGE_FRAGMENT_BIT</code> specifies the fragment stage. </li> <li> <code>VK_SHADER_STAGE_COMPUTE_BIT</code> specifies the compute stage. </li> <li> <code>VK_SHADER_STAGE_ALL_GRAPHICS</code> is a combination of bits used as shorthand to specify all graphics stages defined above (excluding the compute stage). </li> <li> <code>VK_SHADER_STAGE_ALL</code> is a combination of bits used as shorthand to specify all shader stages supported by the device, including all additional stages which are introduced by extensions. </li> </ul>    <h4 id="_see_also_327">See Also</h4>  <p><a href="#VkPipelineShaderStageCreateInfo">VkPipelineShaderStageCreateInfo</a>, <a href="#VkShaderStageFlags">VkShaderStageFlags</a></p>    <h4 id="_document_notes_327">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkShaderStageFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkShaderStageFlagBits</a></p>         <h3 id="_vksharingmode_3">VkSharingMode(3)</h3>  <h4 id="_name_328">Name</h4>  <p>VkSharingMode - Buffer and image sharing modes</p>    <h4 id="_c_specification_328">C Specification</h4>  <p>Buffer and image objects are created with a <em>sharing mode</em> controlling how they <strong>can</strong> be accessed from queues. The supported sharing modes are:</p>  <pre id="VkSharingMode" data-language="c++">typedef enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
} VkSharingMode;</pre>   <h4 id="_description_328">Description</h4>  <ul> <li> <code>VK_SHARING_MODE_EXCLUSIVE</code> specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time. </li> <li> <code>VK_SHARING_MODE_CONCURRENT</code> specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported. </li> </ul>  <blockquote> <h5 class="title">Note</h5>  <p><code>VK_SHARING_MODE_CONCURRENT</code> <strong>may</strong> result in lower performance access to the buffer or image than <code>VK_SHARING_MODE_EXCLUSIVE</code>.</p>  </blockquote>  <p>Ranges of buffers and image subresources of image objects created using <code>VK_SHARING_MODE_EXCLUSIVE</code> <strong>must</strong> only be accessed by queues in the same queue family at any given time. In order for a different queue family to be able to interpret the memory contents of a range or image subresource, the application <strong>must</strong> perform a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers">queue family ownership transfer</a>.</p>   <p>Upon creation, resources using <code>VK_SHARING_MODE_EXCLUSIVE</code> are not owned by any queue family. A buffer or image memory barrier is not required to acquire <em>ownership</em> when no queue family owns the resource - it is implicitly acquired upon first use within a queue.</p>  <blockquote> <h5 class="title">Note</h5>  <p>Images still require a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-layouts">layout transition</a> from <code>VK_IMAGE_LAYOUT_UNDEFINED</code> or <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> before being used on the first queue.</p>  </blockquote>  <p>A queue family <strong>can</strong> take ownership of an image subresource or buffer range of a resource created with <code>VK_SHARING_MODE_EXCLUSIVE</code>, without an ownership transfer, in the same way as for a resource that was just created; however, taking ownership in this way has the effect that the contents of the image subresource or buffer range are undefined.</p>   <p>Ranges of buffers and image subresources of image objects created using <code>VK_SHARING_MODE_CONCURRENT</code> <strong>must</strong> only be accessed by queues from the queue families specified through the <code>queueFamilyIndexCount</code> and <code>pQueueFamilyIndices</code> members of the corresponding create info structures.</p>    <h4 id="_see_also_328">See Also</h4>  <p><a href="#VkBufferCreateInfo">VkBufferCreateInfo</a>, <a href="#VkImageCreateInfo">VkImageCreateInfo</a></p>    <h4 id="_document_notes_328">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSharingMode">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSharingMode</a></p>         <h3 id="_vksparseimageformatflagbits_3">VkSparseImageFormatFlagBits(3)</h3>  <h4 id="_name_329">Name</h4>  <p>VkSparseImageFormatFlagBits - Bitmask specifying additional information about a sparse image resource</p>    <h4 id="_c_specification_329">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkSparseImageFormatProperties">VkSparseImageFormatProperties</a>::<code>flags</code>, specifying additional information about the sparse resource, are:</p>  <pre id="VkSparseImageFormatFlagBits" data-language="c++">typedef enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
} VkSparseImageFormatFlagBits;</pre>   <h4 id="_description_329">Description</h4>  <ul> <li> <code>VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT</code> specifies that the image uses a single mip tail region for all array layers. </li> <li> <code>VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT</code> specifies that the first mip level whose dimensions are not integer multiples of the corresponding dimensions of the sparse image block begins the mip tail region. </li> <li> <code>VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT</code> specifies that the image uses non-standard sparse image block dimensions, and the <code>imageGranularity</code> values do not match the standard sparse image block dimensions for the given pixel format. </li> </ul>    <h4 id="_see_also_329">See Also</h4>  <p><a href="#VkSparseImageFormatFlags">VkSparseImageFormatFlags</a></p>    <h4 id="_document_notes_329">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageFormatFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageFormatFlagBits</a></p>         <h3 id="_vksparsememorybindflagbits_3">VkSparseMemoryBindFlagBits(3)</h3>  <h4 id="_name_330">Name</h4>  <p>VkSparseMemoryBindFlagBits - Bitmask specifying usage of a sparse memory binding operation</p>    <h4 id="_c_specification_330">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkSparseMemoryBind">VkSparseMemoryBind</a>::<code>flags</code>, specifying usage of a sparse memory binding operation, are:</p>  <pre id="VkSparseMemoryBindFlagBits" data-language="c++">typedef enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
} VkSparseMemoryBindFlagBits;</pre>   <h4 id="_description_330">Description</h4>  <ul> <li> <code>VK_SPARSE_MEMORY_BIND_METADATA_BIT</code> specifies that the memory being bound is only for the metadata aspect. </li> </ul>    <h4 id="_see_also_330">See Also</h4>  <p><a href="#VkSparseMemoryBindFlags">VkSparseMemoryBindFlags</a></p>    <h4 id="_document_notes_330">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseMemoryBindFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseMemoryBindFlagBits</a></p>         <h3 id="_vkstencilfaceflagbits_3">VkStencilFaceFlagBits(3)</h3>  <h4 id="_name_331">Name</h4>  <p>VkStencilFaceFlagBits - Bitmask specifying sets of stencil state for which to update the compare mask</p>    <h4 id="_c_specification_331">C Specification</h4>  <p>Bits which <strong>can</strong> be set in the <a href="#vkCmdSetStencilCompareMask">vkCmdSetStencilCompareMask</a>::<code>faceMask</code> parameter, and similar parameters of other commands specifying which stencil state to update stencil masks for, are:</p>  <pre id="VkStencilFaceFlagBits" data-language="c++">typedef enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
    VK_STENCIL_FRONT_AND_BACK = 0x00000003,
} VkStencilFaceFlagBits;</pre>   <h4 id="_description_331">Description</h4>  <ul> <li> <code>VK_STENCIL_FACE_FRONT_BIT</code> specifies that only the front set of stencil state is updated. </li> <li> <code>VK_STENCIL_FACE_BACK_BIT</code> specifies that only the back set of stencil state is updated. </li> <li> <code>VK_STENCIL_FRONT_AND_BACK</code> is the combination of <code>VK_STENCIL_FACE_FRONT_BIT</code> and <code>VK_STENCIL_FACE_BACK_BIT</code>, and specifies that both sets of stencil state are updated. </li> </ul>    <h4 id="_see_also_331">See Also</h4>  <p><a href="#VkStencilFaceFlags">VkStencilFaceFlags</a></p>    <h4 id="_document_notes_331">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkStencilFaceFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkStencilFaceFlagBits</a></p>         <h3 id="_vkstencilop_3">VkStencilOp(3)</h3>  <h4 id="_name_332">Name</h4>  <p>VkStencilOp - Stencil comparison function</p>    <h4 id="_c_specification_332">C Specification</h4>  <p>Possible values of the <code>failOp</code>, <code>passOp</code>, and <code>depthFailOp</code> members of <a href="#VkStencilOpState">VkStencilOpState</a>, specifying what happens to the stored stencil value if this or certain subsequent tests fail or pass, are:</p>  <pre id="VkStencilOp" data-language="c++">typedef enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
} VkStencilOp;</pre>   <h4 id="_description_332">Description</h4>  <ul> <li> <code>VK_STENCIL_OP_KEEP</code> keeps the current value. </li> <li> <code>VK_STENCIL_OP_ZERO</code> sets the value to 0. </li> <li> <code>VK_STENCIL_OP_REPLACE</code> sets the value to <code>reference</code>. </li> <li> <code>VK_STENCIL_OP_INCREMENT_AND_CLAMP</code> increments the current value and clamps to the maximum representable unsigned value. </li> <li> <code>VK_STENCIL_OP_DECREMENT_AND_CLAMP</code> decrements the current value and clamps to 0. </li> <li> <code>VK_STENCIL_OP_INVERT</code> bitwise-inverts the current value. </li> <li> <code>VK_STENCIL_OP_INCREMENT_AND_WRAP</code> increments the current value and wraps to 0 when the maximum value would have been exceeded. </li> <li> <code>VK_STENCIL_OP_DECREMENT_AND_WRAP</code> decrements the current value and wraps to the maximum possible value when the value would go below 0. </li> </ul>   <p>For purposes of increment and decrement, the stencil bits are considered as an unsigned integer.</p>   <p>If the stencil test fails, the sample’s coverage bit is cleared in the fragment. If there is no stencil framebuffer attachment, stencil modification <strong>cannot</strong> occur, and it is as if the stencil tests always pass.</p>   <p>If the stencil test passes, the <code>writeMask</code> member of the <a href="#VkStencilOpState">VkStencilOpState</a> structures controls how the updated stencil value is written to the stencil framebuffer attachment.</p>   <p>The least significant s bits of <code>writeMask</code>, where s is the number of bits in the stencil framebuffer attachment, specify an integer mask. Where a 1 appears in this mask, the corresponding bit in the stencil value in the depth/stencil attachment is written; where a 0 appears, the bit is not written. The <code>writeMask</code> value uses either the front-facing or back-facing state based on the facingness of the fragment. Fragments generated by front-facing primitives use the front mask and fragments generated by back-facing primitives use the back mask.</p>    <h4 id="_see_also_332">See Also</h4>  <p><a href="#VkStencilOpState">VkStencilOpState</a></p>    <h4 id="_document_notes_332">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkStencilOp">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkStencilOp</a></p>         <h3 id="_vkstructuretype_3">VkStructureType(3)</h3>  <h4 id="_name_333">Name</h4>  <p>VkStructureType - Vulkan structure types (<code>stype</code>)</p>    <h4 id="_c_specification_333">C Specification</h4>  <p>Vulkan structures containing <code>sType</code> members <strong>must</strong> have a value of <code>sType</code> matching the type of the structure, as described more fully in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-validusage-sType">Valid Usage for Structure Types</a>. Structure types supported by the Vulkan API include:</p>  <pre id="VkStructureType" data-language="c++">typedef enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
} VkStructureType;</pre>      <h4 id="_see_also_333">See Also</h4>  <p><a href="#VkApplicationInfo">VkApplicationInfo</a>, <a href="#VkBindSparseInfo">VkBindSparseInfo</a>, <a href="#VkBufferCreateInfo">VkBufferCreateInfo</a>, <a href="#VkBufferMemoryBarrier">VkBufferMemoryBarrier</a>, <a href="#VkBufferViewCreateInfo">VkBufferViewCreateInfo</a>, <a href="#VkCommandBufferAllocateInfo">VkCommandBufferAllocateInfo</a>, <a href="#VkCommandBufferBeginInfo">VkCommandBufferBeginInfo</a>, <a href="#VkCommandBufferInheritanceInfo">VkCommandBufferInheritanceInfo</a>, <a href="#VkCommandPoolCreateInfo">VkCommandPoolCreateInfo</a>, <a href="#VkComputePipelineCreateInfo">VkComputePipelineCreateInfo</a>, <a href="#VkCopyDescriptorSet">VkCopyDescriptorSet</a>, <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a>, <a href="#VkDescriptorSetAllocateInfo">VkDescriptorSetAllocateInfo</a>, <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a>, <a href="#VkDeviceCreateInfo">VkDeviceCreateInfo</a>, <a href="#VkDeviceQueueCreateInfo">VkDeviceQueueCreateInfo</a>, <a href="#VkEventCreateInfo">VkEventCreateInfo</a>, <a href="#VkFenceCreateInfo">VkFenceCreateInfo</a>, <a href="#VkFramebufferCreateInfo">VkFramebufferCreateInfo</a>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkImageCreateInfo">VkImageCreateInfo</a>, <a href="#VkImageMemoryBarrier">VkImageMemoryBarrier</a>, <a href="#VkImageViewCreateInfo">VkImageViewCreateInfo</a>, <a href="#VkInstanceCreateInfo">VkInstanceCreateInfo</a>, <a href="#VkMappedMemoryRange">VkMappedMemoryRange</a>, <a href="#VkMemoryAllocateInfo">VkMemoryAllocateInfo</a>, <a href="#VkMemoryBarrier">VkMemoryBarrier</a>, <a href="#VkPipelineCacheCreateInfo">VkPipelineCacheCreateInfo</a>, <a href="#VkPipelineColorBlendStateCreateInfo">VkPipelineColorBlendStateCreateInfo</a>, <a href="#VkPipelineDepthStencilStateCreateInfo">VkPipelineDepthStencilStateCreateInfo</a>, <a href="#VkPipelineDynamicStateCreateInfo">VkPipelineDynamicStateCreateInfo</a>, <a href="#VkPipelineInputAssemblyStateCreateInfo">VkPipelineInputAssemblyStateCreateInfo</a>, <a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a>, <a href="#VkPipelineMultisampleStateCreateInfo">VkPipelineMultisampleStateCreateInfo</a>, <a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a>, <a href="#VkPipelineShaderStageCreateInfo">VkPipelineShaderStageCreateInfo</a>, <a href="#VkPipelineTessellationStateCreateInfo">VkPipelineTessellationStateCreateInfo</a>, <a href="#VkPipelineVertexInputStateCreateInfo">VkPipelineVertexInputStateCreateInfo</a>, <a href="#VkPipelineViewportStateCreateInfo">VkPipelineViewportStateCreateInfo</a>, <a href="#VkQueryPoolCreateInfo">VkQueryPoolCreateInfo</a>, <a href="#VkRenderPassBeginInfo">VkRenderPassBeginInfo</a>, <a href="#VkRenderPassCreateInfo">VkRenderPassCreateInfo</a>, <a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a>, <a href="#VkSemaphoreCreateInfo">VkSemaphoreCreateInfo</a>, <a href="#VkShaderModuleCreateInfo">VkShaderModuleCreateInfo</a>, <a href="#VkSubmitInfo">VkSubmitInfo</a>, <a href="#VkWriteDescriptorSet">VkWriteDescriptorSet</a></p>    <h4 id="_document_notes_333">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkStructureType">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkStructureType</a></p>         <h3 id="_vksubpasscontents_3">VkSubpassContents(3)</h3>  <h4 id="_name_334">Name</h4>  <p>VkSubpassContents - Specify how commands in the first subpass of a render pass are provided</p>    <h4 id="_c_specification_334">C Specification</h4>  <p>Possible values of <a href="#vkCmdBeginRenderPass">vkCmdBeginRenderPass</a>::<code>contents</code>, specifying how the commands in the first subpass will be provided, are:</p>  <pre id="VkSubpassContents" data-language="c++">typedef enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
} VkSubpassContents;</pre>   <h4 id="_description_334">Description</h4>  <ul> <li> <code>VK_SUBPASS_CONTENTS_INLINE</code> specifies that the contents of the subpass will be recorded inline in the primary command buffer, and secondary command buffers <strong>must</strong> not be executed within the subpass. </li> <li> <code>VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS</code> specifies that the contents are recorded in secondary command buffers that will be called from the primary command buffer, and <a href="#vkCmdExecuteCommands">vkCmdExecuteCommands</a> is the only valid command on the command buffer until <a href="#vkCmdNextSubpass">vkCmdNextSubpass</a> or <a href="#vkCmdEndRenderPass">vkCmdEndRenderPass</a>. </li> </ul>    <h4 id="_see_also_334">See Also</h4>  <p><a href="#vkCmdBeginRenderPass">vkCmdBeginRenderPass</a>, <a href="#vkCmdNextSubpass">vkCmdNextSubpass</a></p>    <h4 id="_document_notes_334">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubpassContents">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubpassContents</a></p>         <h3 id="_vksubpassdescriptionflagbits_3">VkSubpassDescriptionFlagBits(3)</h3>  <h4 id="_name_335">Name</h4>  <p>VkSubpassDescriptionFlagBits - Bitmask specifying usage of a subpass</p>    <h4 id="_c_specification_335">C Specification</h4>  <p>Bits which <strong>can</strong> be set in <a href="#VkSubpassDescription">VkSubpassDescription</a>::<code>flags</code>, specifying usage of the subpass, are:</p>  <pre id="VkSubpassDescriptionFlagBits" data-language="c++">typedef enum VkSubpassDescriptionFlagBits {
} VkSubpassDescriptionFlagBits;</pre>      <h4 id="_see_also_335">See Also</h4>  <p><a href="#VkSubpassDescriptionFlags">VkSubpassDescriptionFlags</a></p>    <h4 id="_document_notes_335">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubpassDescriptionFlagBits">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubpassDescriptionFlagBits</a></p>         <h3 id="_vksystemallocationscope_3">VkSystemAllocationScope(3)</h3>  <h4 id="_name_336">Name</h4>  <p>VkSystemAllocationScope - Allocation scope</p>    <h4 id="_c_specification_336">C Specification</h4>  <p>Each allocation has an <em>allocation scope</em> which defines its lifetime and which object it is associated with. Possible values passed to the <code>allocationScope</code> parameter of the callback functions specified by <a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>, indicating the allocation scope, are:</p>  <pre id="VkSystemAllocationScope" data-language="c++">typedef enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
} VkSystemAllocationScope;</pre>   <h4 id="_description_336">Description</h4>  <ul> <li> <code>VK_SYSTEM_ALLOCATION_SCOPE_COMMAND</code> specifies that the allocation is scoped to the duration of the Vulkan command. </li> <li> <code>VK_SYSTEM_ALLOCATION_SCOPE_OBJECT</code> specifies that the allocation is scoped to the lifetime of the Vulkan object that is being created or used. </li> <li> <code>VK_SYSTEM_ALLOCATION_SCOPE_CACHE</code> specifies that the allocation is scoped to the lifetime of a <code>VkPipelineCache</code> object. </li> <li> <code>VK_SYSTEM_ALLOCATION_SCOPE_DEVICE</code> specifies that the allocation is scoped to the lifetime of the Vulkan device. </li> <li> <code>VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE</code> specifies that the allocation is scoped to the lifetime of the Vulkan instance. </li> </ul>   <p>Most Vulkan commands operate on a single object, or there is a sole object that is being created or manipulated. When an allocation uses an allocation scope of <code>VK_SYSTEM_ALLOCATION_SCOPE_OBJECT</code> or <code>VK_SYSTEM_ALLOCATION_SCOPE_CACHE</code>, the allocation is scoped to the object being created or manipulated.</p>   <p>When an implementation requires host memory, it will make callbacks to the application using the most specific allocator and allocation scope available:</p>   <ul> <li> If an allocation is scoped to the duration of a command, the allocator will use the <code>VK_SYSTEM_ALLOCATION_SCOPE_COMMAND</code> allocation scope. The most specific allocator available is used: if the object being created or manipulated has an allocator, that object’s allocator will be used, else if the parent <code>VkDevice</code> has an allocator it will be used, else if the parent <code>VkInstance</code> has an allocator it will be used. Else, </li> <li> If an allocation is associated with an object of type <code>VkPipelineCache</code>, the allocator will use the <code>VK_SYSTEM_ALLOCATION_SCOPE_CACHE</code> allocation scope. The most specific allocator available is used (pipeline cache, else device, else instance). Else, </li> <li> If an allocation is scoped to the lifetime of an object, that object is being created or manipulated by the command, and that object’s type is not <code>VkDevice</code> or <code>VkInstance</code>, the allocator will use an allocation scope of <code>VK_SYSTEM_ALLOCATION_SCOPE_OBJECT</code>. The most specific allocator available is used (object, else device, else instance). Else, </li> <li> If an allocation is scoped to the lifetime of a device, the allocator will use an allocation scope of <code>VK_SYSTEM_ALLOCATION_SCOPE_DEVICE</code>. The most specific allocator available is used (device, else instance). Else, </li> <li> If the allocation is scoped to the lifetime of an instance and the instance has an allocator, its allocator will be used with an allocation scope of <code>VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE</code>. </li> <li> Otherwise an implementation will allocate memory through an alternative mechanism that is unspecified. </li> </ul>    <h4 id="_see_also_336">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a></p>    <h4 id="_document_notes_336">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSystemAllocationScope">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSystemAllocationScope</a></p>         <h3 id="_vkvertexinputrate_3">VkVertexInputRate(3)</h3>  <h4 id="_name_337">Name</h4>  <p>VkVertexInputRate - Specify rate at which vertex attributes are pulled from buffers</p>    <h4 id="_c_specification_337">C Specification</h4>  <p>Possible values of <a href="#VkVertexInputBindingDescription">VkVertexInputBindingDescription</a>::<code>inputRate</code>, specifying the rate at which vertex attributes are pulled from buffers, are:</p>  <pre id="VkVertexInputRate" data-language="c++">typedef enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
} VkVertexInputRate;</pre>   <h4 id="_description_337">Description</h4>  <ul> <li> <code>VK_VERTEX_INPUT_RATE_VERTEX</code> specifies that vertex attribute addressing is a function of the vertex index. </li> <li> <code>VK_VERTEX_INPUT_RATE_INSTANCE</code> specifies that vertex attribute addressing is a function of the instance index. </li> </ul>    <h4 id="_see_also_337">See Also</h4>  <p><a href="#VkVertexInputBindingDescription">VkVertexInputBindingDescription</a></p>    <h4 id="_document_notes_337">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkVertexInputRate">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkVertexInputRate</a></p>           <h2 id="flags">Flags</h2>   <h3 id="_vkaccessflags_3">VkAccessFlags(3)</h3>  <h4 id="_name_338">Name</h4>  <p>VkAccessFlags - Bitmask of VkAccessFlagBits</p>    <h4 id="_c_specification_338">C Specification</h4> <pre id="VkAccessFlags" data-language="c++">typedef VkFlags VkAccessFlags;</pre>   <h4 id="_description_338">Description</h4>  <p><code>VkAccessFlags</code> is a mask of zero or more <a href="#VkAccessFlagBits">VkAccessFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_338">See Also</h4>  <p><a href="#VkAccessFlagBits">VkAccessFlagBits</a>, <a href="#VkBufferMemoryBarrier">VkBufferMemoryBarrier</a>, <a href="#VkImageMemoryBarrier">VkImageMemoryBarrier</a>, <a href="#VkMemoryBarrier">VkMemoryBarrier</a>, <a href="#VkSubpassDependency">VkSubpassDependency</a></p>    <h4 id="_document_notes_338">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAccessFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAccessFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkattachmentdescriptionflags_3">VkAttachmentDescriptionFlags(3)</h3>  <h4 id="_name_339">Name</h4>  <p>VkAttachmentDescriptionFlags - Bitmask of VkAttachmentDescriptionFlagBits</p>    <h4 id="_c_specification_339">C Specification</h4> <pre id="VkAttachmentDescriptionFlags" data-language="c++">typedef VkFlags VkAttachmentDescriptionFlags;</pre>   <h4 id="_description_339">Description</h4>  <p><code>VkAttachmentDescriptionFlags</code> is a mask of zero or more <a href="#VkAttachmentDescriptionFlagBits">VkAttachmentDescriptionFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_339">See Also</h4>  <p><a href="#VkAttachmentDescription">VkAttachmentDescription</a>, <a href="#VkAttachmentDescriptionFlagBits">VkAttachmentDescriptionFlagBits</a></p>    <h4 id="_document_notes_339">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentDescriptionFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkAttachmentDescriptionFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkbuffercreateflags_3">VkBufferCreateFlags(3)</h3>  <h4 id="_name_340">Name</h4>  <p>VkBufferCreateFlags - Bitmask of VkBufferCreateFlagBits</p>    <h4 id="_c_specification_340">C Specification</h4> <pre id="VkBufferCreateFlags" data-language="c++">typedef VkFlags VkBufferCreateFlags;</pre>   <h4 id="_description_340">Description</h4>  <p><code>VkBufferCreateFlags</code> is a mask of zero or more <a href="#VkBufferCreateFlagBits">VkBufferCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_340">See Also</h4>  <p><a href="#VkBufferCreateFlagBits">VkBufferCreateFlagBits</a>, <a href="#VkBufferCreateInfo">VkBufferCreateInfo</a></p>    <h4 id="_document_notes_340">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkbufferusageflags_3">VkBufferUsageFlags(3)</h3>  <h4 id="_name_341">Name</h4>  <p>VkBufferUsageFlags - Bitmask of VkBufferUsageFlagBits</p>    <h4 id="_c_specification_341">C Specification</h4> <pre id="VkBufferUsageFlags" data-language="c++">typedef VkFlags VkBufferUsageFlags;</pre>   <h4 id="_description_341">Description</h4>  <p><code>VkBufferUsageFlags</code> is a mask of zero or more <a href="#VkBufferUsageFlagBits">VkBufferUsageFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_341">See Also</h4>  <p><a href="#VkBufferCreateInfo">VkBufferCreateInfo</a>, <a href="#VkBufferUsageFlagBits">VkBufferUsageFlagBits</a></p>    <h4 id="_document_notes_341">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferUsageFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferUsageFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkbufferviewcreateflags_3">VkBufferViewCreateFlags(3)</h3>  <h4 id="_name_342">Name</h4>  <p>VkBufferViewCreateFlags - Bitmask of VkBufferViewCreateFlagBits</p>    <h4 id="_c_specification_342">C Specification</h4> <pre id="VkBufferViewCreateFlags" data-language="c++">typedef VkFlags VkBufferViewCreateFlags;</pre>   <h4 id="_description_342">Description</h4>  <p><code>VkBufferViewCreateFlags</code> is a mask of zero or more <a href="#VkBufferViewCreateFlagBits">VkBufferViewCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_342">See Also</h4>  <p><a href="#VkBufferViewCreateInfo">VkBufferViewCreateInfo</a></p>    <h4 id="_document_notes_342">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferViewCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferViewCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkcolorcomponentflags_3">VkColorComponentFlags(3)</h3>  <h4 id="_name_343">Name</h4>  <p>VkColorComponentFlags - Bitmask of VkColorComponentFlagBits</p>    <h4 id="_c_specification_343">C Specification</h4> <pre id="VkColorComponentFlags" data-language="c++">typedef VkFlags VkColorComponentFlags;</pre>   <h4 id="_description_343">Description</h4>  <p><code>VkColorComponentFlags</code> is a mask of zero or more <a href="#VkColorComponentFlagBits">VkColorComponentFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_343">See Also</h4>  <p><a href="#VkColorComponentFlagBits">VkColorComponentFlagBits</a>, <a href="#VkPipelineColorBlendAttachmentState">VkPipelineColorBlendAttachmentState</a></p>    <h4 id="_document_notes_343">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkColorComponentFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkColorComponentFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkcommandbufferresetflags_3">VkCommandBufferResetFlags(3)</h3>  <h4 id="_name_344">Name</h4>  <p>VkCommandBufferResetFlags - Bitmask of VkCommandBufferResetFlagBits</p>    <h4 id="_c_specification_344">C Specification</h4> <pre id="VkCommandBufferResetFlags" data-language="c++">typedef VkFlags VkCommandBufferResetFlags;</pre>   <h4 id="_description_344">Description</h4>  <p><code>VkCommandBufferResetFlags</code> is a mask of zero or more <a href="#VkCommandBufferResetFlagBits">VkCommandBufferResetFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_344">See Also</h4>  <p><a href="#VkCommandBufferResetFlagBits">VkCommandBufferResetFlagBits</a>, <a href="#vkResetCommandBuffer">vkResetCommandBuffer</a></p>    <h4 id="_document_notes_344">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferResetFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferResetFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkcommandbufferusageflags_3">VkCommandBufferUsageFlags(3)</h3>  <h4 id="_name_345">Name</h4>  <p>VkCommandBufferUsageFlags - Bitmask of VkCommandBufferUsageFlagBits</p>    <h4 id="_c_specification_345">C Specification</h4> <pre id="VkCommandBufferUsageFlags" data-language="c++">typedef VkFlags VkCommandBufferUsageFlags;</pre>   <h4 id="_description_345">Description</h4>  <p><code>VkCommandBufferUsageFlags</code> is a mask of zero or more <a href="#VkCommandBufferUsageFlagBits">VkCommandBufferUsageFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_345">See Also</h4>  <p><a href="#VkCommandBufferBeginInfo">VkCommandBufferBeginInfo</a>, <a href="#VkCommandBufferUsageFlagBits">VkCommandBufferUsageFlagBits</a></p>    <h4 id="_document_notes_345">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferUsageFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandBufferUsageFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkcommandpoolcreateflags_3">VkCommandPoolCreateFlags(3)</h3>  <h4 id="_name_346">Name</h4>  <p>VkCommandPoolCreateFlags - Bitmask of VkCommandPoolCreateFlagBits</p>    <h4 id="_c_specification_346">C Specification</h4> <pre id="VkCommandPoolCreateFlags" data-language="c++">typedef VkFlags VkCommandPoolCreateFlags;</pre>   <h4 id="_description_346">Description</h4>  <p><code>VkCommandPoolCreateFlags</code> is a mask of zero or more <a href="#VkCommandPoolCreateFlagBits">VkCommandPoolCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_346">See Also</h4>  <p><a href="#VkCommandPoolCreateFlagBits">VkCommandPoolCreateFlagBits</a>, <a href="#VkCommandPoolCreateInfo">VkCommandPoolCreateInfo</a></p>    <h4 id="_document_notes_346">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPoolCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPoolCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkcommandpoolresetflags_3">VkCommandPoolResetFlags(3)</h3>  <h4 id="_name_347">Name</h4>  <p>VkCommandPoolResetFlags - Bitmask of VkCommandPoolResetFlagBits</p>    <h4 id="_c_specification_347">C Specification</h4> <pre id="VkCommandPoolResetFlags" data-language="c++">typedef VkFlags VkCommandPoolResetFlags;</pre>   <h4 id="_description_347">Description</h4>  <p><code>VkCommandPoolResetFlags</code> is a mask of zero or more <a href="#VkCommandPoolResetFlagBits">VkCommandPoolResetFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_347">See Also</h4>  <p><a href="#VkCommandPoolResetFlagBits">VkCommandPoolResetFlagBits</a>, <a href="#vkResetCommandPool">vkResetCommandPool</a></p>    <h4 id="_document_notes_347">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPoolResetFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCommandPoolResetFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkcullmodeflags_3">VkCullModeFlags(3)</h3>  <h4 id="_name_348">Name</h4>  <p>VkCullModeFlags - Bitmask of VkCullModeFlagBits</p>    <h4 id="_c_specification_348">C Specification</h4> <pre id="VkCullModeFlags" data-language="c++">typedef VkFlags VkCullModeFlags;</pre>   <h4 id="_description_348">Description</h4>  <p><code>VkCullModeFlags</code> is a mask of zero or more <a href="#VkCullModeFlagBits">VkCullModeFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_348">See Also</h4>  <p><a href="#VkCullModeFlagBits">VkCullModeFlagBits</a>, <a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a></p>    <h4 id="_document_notes_348">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCullModeFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkCullModeFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkdependencyflags_3">VkDependencyFlags(3)</h3>  <h4 id="_name_349">Name</h4>  <p>VkDependencyFlags - Bitmask of VkDependencyFlagBits</p>    <h4 id="_c_specification_349">C Specification</h4> <pre id="VkDependencyFlags" data-language="c++">typedef VkFlags VkDependencyFlags;</pre>   <h4 id="_description_349">Description</h4>  <p><code>VkDependencyFlags</code> is a mask of zero or more <a href="#VkDependencyFlagBits">VkDependencyFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_349">See Also</h4>  <p><a href="#VkDependencyFlagBits">VkDependencyFlagBits</a>, <a href="#VkSubpassDependency">VkSubpassDependency</a>, <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a></p>    <h4 id="_document_notes_349">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDependencyFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDependencyFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkdescriptorpoolcreateflags_3">VkDescriptorPoolCreateFlags(3)</h3>  <h4 id="_name_350">Name</h4>  <p>VkDescriptorPoolCreateFlags - Bitmask of VkDescriptorPoolCreateFlagBits</p>    <h4 id="_c_specification_350">C Specification</h4> <pre id="VkDescriptorPoolCreateFlags" data-language="c++">typedef VkFlags VkDescriptorPoolCreateFlags;</pre>   <h4 id="_description_350">Description</h4>  <p><code>VkDescriptorPoolCreateFlags</code> is a mask of zero or more <a href="#VkDescriptorPoolCreateFlagBits">VkDescriptorPoolCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_350">See Also</h4>  <p><a href="#VkDescriptorPoolCreateFlagBits">VkDescriptorPoolCreateFlagBits</a>, <a href="#VkDescriptorPoolCreateInfo">VkDescriptorPoolCreateInfo</a></p>    <h4 id="_document_notes_350">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPoolCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPoolCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkdescriptorpoolresetflags_3">VkDescriptorPoolResetFlags(3)</h3>  <h4 id="_name_351">Name</h4>  <p>VkDescriptorPoolResetFlags - Bitmask of VkDescriptorPoolResetFlagBits</p>    <h4 id="_c_specification_351">C Specification</h4> <pre id="VkDescriptorPoolResetFlags" data-language="c++">typedef VkFlags VkDescriptorPoolResetFlags;</pre>   <h4 id="_description_351">Description</h4>  <p><code>VkDescriptorPoolResetFlags</code> is a mask of zero or more <a href="#VkDescriptorPoolResetFlagBits">VkDescriptorPoolResetFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_351">See Also</h4>  <p><a href="#vkResetDescriptorPool">vkResetDescriptorPool</a></p>    <h4 id="_document_notes_351">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPoolResetFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorPoolResetFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkdescriptorsetlayoutcreateflags_3">VkDescriptorSetLayoutCreateFlags(3)</h3>  <h4 id="_name_352">Name</h4>  <p>VkDescriptorSetLayoutCreateFlags - Bitmask of VkDescriptorSetLayoutCreateFlagBits</p>    <h4 id="_c_specification_352">C Specification</h4> <pre id="VkDescriptorSetLayoutCreateFlags" data-language="c++">typedef VkFlags VkDescriptorSetLayoutCreateFlags;</pre>   <h4 id="_description_352">Description</h4>  <p><code>VkDescriptorSetLayoutCreateFlags</code> is a mask of zero or more <a href="#VkDescriptorSetLayoutCreateFlagBits">VkDescriptorSetLayoutCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_352">See Also</h4>  <p><a href="#VkDescriptorSetLayoutCreateFlagBits">VkDescriptorSetLayoutCreateFlagBits</a>, <a href="#VkDescriptorSetLayoutCreateInfo">VkDescriptorSetLayoutCreateInfo</a></p>    <h4 id="_document_notes_352">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetLayoutCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDescriptorSetLayoutCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkdevicecreateflags_3">VkDeviceCreateFlags(3)</h3>  <h4 id="_name_353">Name</h4>  <p>VkDeviceCreateFlags - Bitmask of VkDeviceCreateFlagBits</p>    <h4 id="_c_specification_353">C Specification</h4> <pre id="VkDeviceCreateFlags" data-language="c++">typedef VkFlags VkDeviceCreateFlags;</pre>   <h4 id="_description_353">Description</h4>  <p><code>VkDeviceCreateFlags</code> is a mask of zero or more <a href="#VkDeviceCreateFlagBits">VkDeviceCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_353">See Also</h4>  <p><a href="#VkDeviceCreateInfo">VkDeviceCreateInfo</a></p>    <h4 id="_document_notes_353">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkdevicequeuecreateflags_3">VkDeviceQueueCreateFlags(3)</h3>  <h4 id="_name_354">Name</h4>  <p>VkDeviceQueueCreateFlags - Bitmask of VkDeviceQueueCreateFlagBits</p>    <h4 id="_c_specification_354">C Specification</h4> <pre id="VkDeviceQueueCreateFlags" data-language="c++">typedef VkFlags VkDeviceQueueCreateFlags;</pre>   <h4 id="_description_354">Description</h4>  <p><code>VkDeviceQueueCreateFlags</code> is a mask of zero or more <a href="#VkDeviceQueueCreateFlagBits">VkDeviceQueueCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_354">See Also</h4>  <p><a href="#VkDeviceQueueCreateInfo">VkDeviceQueueCreateInfo</a></p>    <h4 id="_document_notes_354">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceQueueCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceQueueCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkeventcreateflags_3">VkEventCreateFlags(3)</h3>  <h4 id="_name_355">Name</h4>  <p>VkEventCreateFlags - Bitmask of VkEventCreateFlagBits</p>    <h4 id="_c_specification_355">C Specification</h4> <pre id="VkEventCreateFlags" data-language="c++">typedef VkFlags VkEventCreateFlags;</pre>   <h4 id="_description_355">Description</h4>  <p><code>VkEventCreateFlags</code> is a mask of zero or more <a href="#VkEventCreateFlagBits">VkEventCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_355">See Also</h4>  <p><a href="#VkEventCreateInfo">VkEventCreateInfo</a></p>    <h4 id="_document_notes_355">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkEventCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkEventCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkfencecreateflags_3">VkFenceCreateFlags(3)</h3>  <h4 id="_name_356">Name</h4>  <p>VkFenceCreateFlags - Bitmask of VkFenceCreateFlagBits</p>    <h4 id="_c_specification_356">C Specification</h4> <pre id="VkFenceCreateFlags" data-language="c++">typedef VkFlags VkFenceCreateFlags;</pre>   <h4 id="_description_356">Description</h4>  <p><code>VkFenceCreateFlags</code> is a mask of zero or more <a href="#VkFenceCreateFlagBits">VkFenceCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_356">See Also</h4>  <p><a href="#VkFenceCreateFlagBits">VkFenceCreateFlagBits</a>, <a href="#VkFenceCreateInfo">VkFenceCreateInfo</a></p>    <h4 id="_document_notes_356">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFenceCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFenceCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkformatfeatureflags_3">VkFormatFeatureFlags(3)</h3>  <h4 id="_name_357">Name</h4>  <p>VkFormatFeatureFlags - Bitmask of VkFormatFeatureFlagBits</p>    <h4 id="_c_specification_357">C Specification</h4> <pre id="VkFormatFeatureFlags" data-language="c++">typedef VkFlags VkFormatFeatureFlags;</pre>   <h4 id="_description_357">Description</h4>  <p><code>VkFormatFeatureFlags</code> is a mask of zero or more <a href="#VkFormatFeatureFlagBits">VkFormatFeatureFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_357">See Also</h4>  <p><a href="#VkFormatFeatureFlagBits">VkFormatFeatureFlagBits</a>, <a href="#VkFormatProperties">VkFormatProperties</a></p>    <h4 id="_document_notes_357">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFormatFeatureFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFormatFeatureFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkframebuffercreateflags_3">VkFramebufferCreateFlags(3)</h3>  <h4 id="_name_358">Name</h4>  <p>VkFramebufferCreateFlags - Bitmask of VkFramebufferCreateFlagBits</p>    <h4 id="_c_specification_358">C Specification</h4> <pre id="VkFramebufferCreateFlags" data-language="c++">typedef VkFlags VkFramebufferCreateFlags;</pre>   <h4 id="_description_358">Description</h4>  <p><code>VkFramebufferCreateFlags</code> is a mask of zero or more <a href="#VkFramebufferCreateFlagBits">VkFramebufferCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_358">See Also</h4>  <p><a href="#VkFramebufferCreateInfo">VkFramebufferCreateInfo</a></p>    <h4 id="_document_notes_358">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFramebufferCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFramebufferCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkimageaspectflags_3">VkImageAspectFlags(3)</h3>  <h4 id="_name_359">Name</h4>  <p>VkImageAspectFlags - Bitmask of VkImageAspectFlagBits</p>    <h4 id="_c_specification_359">C Specification</h4> <pre id="VkImageAspectFlags" data-language="c++">typedef VkFlags VkImageAspectFlags;</pre>   <h4 id="_description_359">Description</h4>  <p><code>VkImageAspectFlags</code> is a mask of zero or more <a href="#VkImageAspectFlagBits">VkImageAspectFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_359">See Also</h4>  <p><a href="#VkClearAttachment">VkClearAttachment</a>, <a href="#VkImageAspectFlagBits">VkImageAspectFlagBits</a>, <a href="#VkImageSubresource">VkImageSubresource</a>, <a href="#VkImageSubresourceLayers">VkImageSubresourceLayers</a>, <a href="#VkImageSubresourceRange">VkImageSubresourceRange</a>, <a href="#VkSparseImageFormatProperties">VkSparseImageFormatProperties</a></p>    <h4 id="_document_notes_359">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageAspectFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageAspectFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkimagecreateflags_3">VkImageCreateFlags(3)</h3>  <h4 id="_name_360">Name</h4>  <p>VkImageCreateFlags - Bitmask of VkImageCreateFlagBits</p>    <h4 id="_c_specification_360">C Specification</h4> <pre id="VkImageCreateFlags" data-language="c++">typedef VkFlags VkImageCreateFlags;</pre>   <h4 id="_description_360">Description</h4>  <p><code>VkImageCreateFlags</code> is a mask of zero or more <a href="#VkImageCreateFlagBits">VkImageCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_360">See Also</h4>  <p><a href="#VkImageCreateFlagBits">VkImageCreateFlagBits</a>, <a href="#VkImageCreateInfo">VkImageCreateInfo</a>, <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a></p>    <h4 id="_document_notes_360">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkimageusageflags_3">VkImageUsageFlags(3)</h3>  <h4 id="_name_361">Name</h4>  <p>VkImageUsageFlags - Bitmask of VkImageUsageFlagBits</p>    <h4 id="_c_specification_361">C Specification</h4> <pre id="VkImageUsageFlags" data-language="c++">typedef VkFlags VkImageUsageFlags;</pre>   <h4 id="_description_361">Description</h4>  <p><code>VkImageUsageFlags</code> is a mask of zero or more <a href="#VkImageUsageFlagBits">VkImageUsageFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_361">See Also</h4>  <p><a href="#VkImageCreateInfo">VkImageCreateInfo</a>, <a href="#VkImageUsageFlagBits">VkImageUsageFlagBits</a>, <a href="#vkGetPhysicalDeviceImageFormatProperties">vkGetPhysicalDeviceImageFormatProperties</a>, <a href="#vkGetPhysicalDeviceSparseImageFormatProperties">vkGetPhysicalDeviceSparseImageFormatProperties</a></p>    <h4 id="_document_notes_361">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageUsageFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageUsageFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkimageviewcreateflags_3">VkImageViewCreateFlags(3)</h3>  <h4 id="_name_362">Name</h4>  <p>VkImageViewCreateFlags - Bitmask of VkImageViewCreateFlagBits</p>    <h4 id="_c_specification_362">C Specification</h4> <pre id="VkImageViewCreateFlags" data-language="c++">typedef VkFlags VkImageViewCreateFlags;</pre>   <h4 id="_description_362">Description</h4>  <p><code>VkImageViewCreateFlags</code> is a mask of zero or more <a href="#VkImageViewCreateFlagBits">VkImageViewCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_362">See Also</h4>  <p><a href="#VkImageViewCreateInfo">VkImageViewCreateInfo</a></p>    <h4 id="_document_notes_362">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageViewCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageViewCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkinstancecreateflags_3">VkInstanceCreateFlags(3)</h3>  <h4 id="_name_363">Name</h4>  <p>VkInstanceCreateFlags - Bitmask of VkInstanceCreateFlagBits</p>    <h4 id="_c_specification_363">C Specification</h4> <pre id="VkInstanceCreateFlags" data-language="c++">typedef VkFlags VkInstanceCreateFlags;</pre>   <h4 id="_description_363">Description</h4>  <p><code>VkInstanceCreateFlags</code> is a mask of zero or more <a href="#VkInstanceCreateFlagBits">VkInstanceCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_363">See Also</h4>  <p><a href="#VkInstanceCreateInfo">VkInstanceCreateInfo</a></p>    <h4 id="_document_notes_363">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkInstanceCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkInstanceCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkmemoryheapflags_3">VkMemoryHeapFlags(3)</h3>  <h4 id="_name_364">Name</h4>  <p>VkMemoryHeapFlags - Bitmask of VkMemoryHeapFlagBits</p>    <h4 id="_c_specification_364">C Specification</h4> <pre id="VkMemoryHeapFlags" data-language="c++">typedef VkFlags VkMemoryHeapFlags;</pre>   <h4 id="_description_364">Description</h4>  <p><code>VkMemoryHeapFlags</code> is a mask of zero or more <a href="#VkMemoryHeapFlagBits">VkMemoryHeapFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_364">See Also</h4>  <p><a href="#VkMemoryHeap">VkMemoryHeap</a>, <a href="#VkMemoryHeapFlagBits">VkMemoryHeapFlagBits</a></p>    <h4 id="_document_notes_364">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryHeapFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryHeapFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkmemorymapflags_3">VkMemoryMapFlags(3)</h3>  <h4 id="_name_365">Name</h4>  <p>VkMemoryMapFlags - Bitmask of VkMemoryMapFlagBits</p>    <h4 id="_c_specification_365">C Specification</h4> <pre id="VkMemoryMapFlags" data-language="c++">typedef VkFlags VkMemoryMapFlags;</pre>   <h4 id="_description_365">Description</h4>  <p><code>VkMemoryMapFlags</code> is a mask of zero or more <a href="#VkMemoryMapFlagBits">VkMemoryMapFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_365">See Also</h4>  <p><a href="#vkMapMemory">vkMapMemory</a></p>    <h4 id="_document_notes_365">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryMapFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryMapFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkmemorypropertyflags_3">VkMemoryPropertyFlags(3)</h3>  <h4 id="_name_366">Name</h4>  <p>VkMemoryPropertyFlags - Bitmask of VkMemoryPropertyFlagBits</p>    <h4 id="_c_specification_366">C Specification</h4> <pre id="VkMemoryPropertyFlags" data-language="c++">typedef VkFlags VkMemoryPropertyFlags;</pre>   <h4 id="_description_366">Description</h4>  <p><code>VkMemoryPropertyFlags</code> is a mask of zero or more <a href="#VkMemoryPropertyFlagBits">VkMemoryPropertyFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_366">See Also</h4>  <p><a href="#VkMemoryPropertyFlagBits">VkMemoryPropertyFlagBits</a>, <a href="#VkMemoryType">VkMemoryType</a></p>    <h4 id="_document_notes_366">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryPropertyFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkMemoryPropertyFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinecachecreateflags_3">VkPipelineCacheCreateFlags(3)</h3>  <h4 id="_name_367">Name</h4>  <p>VkPipelineCacheCreateFlags - Bitmask of VkPipelineCacheCreateFlagBits</p>    <h4 id="_c_specification_367">C Specification</h4> <pre id="VkPipelineCacheCreateFlags" data-language="c++">typedef VkFlags VkPipelineCacheCreateFlags;</pre>   <h4 id="_description_367">Description</h4>  <p><code>VkPipelineCacheCreateFlags</code> is a mask of zero or more <a href="#VkPipelineCacheCreateFlagBits">VkPipelineCacheCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_367">See Also</h4>  <p><a href="#VkPipelineCacheCreateInfo">VkPipelineCacheCreateInfo</a></p>    <h4 id="_document_notes_367">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCacheCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCacheCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinecolorblendstatecreateflags_3">VkPipelineColorBlendStateCreateFlags(3)</h3>  <h4 id="_name_368">Name</h4>  <p>VkPipelineColorBlendStateCreateFlags - Bitmask of VkPipelineColorBlendStateCreateFlagBits</p>    <h4 id="_c_specification_368">C Specification</h4> <pre id="VkPipelineColorBlendStateCreateFlags" data-language="c++">typedef VkFlags VkPipelineColorBlendStateCreateFlags;</pre>   <h4 id="_description_368">Description</h4>  <p><code>VkPipelineColorBlendStateCreateFlags</code> is a mask of zero or more <a href="#VkPipelineColorBlendStateCreateFlagBits">VkPipelineColorBlendStateCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_368">See Also</h4>  <p><a href="#VkPipelineColorBlendStateCreateInfo">VkPipelineColorBlendStateCreateInfo</a></p>    <h4 id="_document_notes_368">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineColorBlendStateCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineColorBlendStateCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinecreateflags_3">VkPipelineCreateFlags(3)</h3>  <h4 id="_name_369">Name</h4>  <p>VkPipelineCreateFlags - Bitmask of VkPipelineCreateFlagBits</p>    <h4 id="_c_specification_369">C Specification</h4> <pre id="VkPipelineCreateFlags" data-language="c++">typedef VkFlags VkPipelineCreateFlags;</pre>   <h4 id="_description_369">Description</h4>  <p><code>VkPipelineCreateFlags</code> is a mask of zero or more <a href="#VkPipelineCreateFlagBits">VkPipelineCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_369">See Also</h4>  <p><a href="#VkComputePipelineCreateInfo">VkComputePipelineCreateInfo</a>, <a href="#VkGraphicsPipelineCreateInfo">VkGraphicsPipelineCreateInfo</a>, <a href="#VkPipelineCreateFlagBits">VkPipelineCreateFlagBits</a></p>    <h4 id="_document_notes_369">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinedepthstencilstatecreateflags_3">VkPipelineDepthStencilStateCreateFlags(3)</h3>  <h4 id="_name_370">Name</h4>  <p>VkPipelineDepthStencilStateCreateFlags - Bitmask of VkPipelineDepthStencilStateCreateFlagBits</p>    <h4 id="_c_specification_370">C Specification</h4> <pre id="VkPipelineDepthStencilStateCreateFlags" data-language="c++">typedef VkFlags VkPipelineDepthStencilStateCreateFlags;</pre>   <h4 id="_description_370">Description</h4>  <p><code>VkPipelineDepthStencilStateCreateFlags</code> is a mask of zero or more <a href="#VkPipelineDepthStencilStateCreateFlagBits">VkPipelineDepthStencilStateCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_370">See Also</h4>  <p><a href="#VkPipelineDepthStencilStateCreateInfo">VkPipelineDepthStencilStateCreateInfo</a></p>    <h4 id="_document_notes_370">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineDepthStencilStateCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineDepthStencilStateCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinedynamicstatecreateflags_3">VkPipelineDynamicStateCreateFlags(3)</h3>  <h4 id="_name_371">Name</h4>  <p>VkPipelineDynamicStateCreateFlags - Bitmask of VkPipelineDynamicStateCreateFlagBits</p>    <h4 id="_c_specification_371">C Specification</h4> <pre id="VkPipelineDynamicStateCreateFlags" data-language="c++">typedef VkFlags VkPipelineDynamicStateCreateFlags;</pre>   <h4 id="_description_371">Description</h4>  <p><code>VkPipelineDynamicStateCreateFlags</code> is a mask of zero or more <a href="#VkPipelineDynamicStateCreateFlagBits">VkPipelineDynamicStateCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_371">See Also</h4>  <p><a href="#VkPipelineDynamicStateCreateInfo">VkPipelineDynamicStateCreateInfo</a></p>    <h4 id="_document_notes_371">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineDynamicStateCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineDynamicStateCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelineinputassemblystatecreateflags_3">VkPipelineInputAssemblyStateCreateFlags(3)</h3>  <h4 id="_name_372">Name</h4>  <p>VkPipelineInputAssemblyStateCreateFlags - Bitmask of VkPipelineInputAssemblyStateCreateFlagBits</p>    <h4 id="_c_specification_372">C Specification</h4> <pre id="VkPipelineInputAssemblyStateCreateFlags" data-language="c++">typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;</pre>   <h4 id="_description_372">Description</h4>  <p><code>VkPipelineInputAssemblyStateCreateFlags</code> is a mask of zero or more <a href="#VkPipelineInputAssemblyStateCreateFlagBits">VkPipelineInputAssemblyStateCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_372">See Also</h4>  <p><a href="#VkPipelineInputAssemblyStateCreateInfo">VkPipelineInputAssemblyStateCreateInfo</a></p>    <h4 id="_document_notes_372">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineInputAssemblyStateCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineInputAssemblyStateCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinelayoutcreateflags_3">VkPipelineLayoutCreateFlags(3)</h3>  <h4 id="_name_373">Name</h4>  <p>VkPipelineLayoutCreateFlags - Bitmask of VkPipelineLayoutCreateFlagBits</p>    <h4 id="_c_specification_373">C Specification</h4> <pre id="VkPipelineLayoutCreateFlags" data-language="c++">typedef VkFlags VkPipelineLayoutCreateFlags;</pre>   <h4 id="_description_373">Description</h4>  <p><code>VkPipelineLayoutCreateFlags</code> is a mask of zero or more <a href="#VkPipelineLayoutCreateFlagBits">VkPipelineLayoutCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_373">See Also</h4>  <p><a href="#VkPipelineLayoutCreateInfo">VkPipelineLayoutCreateInfo</a></p>    <h4 id="_document_notes_373">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineLayoutCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineLayoutCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinemultisamplestatecreateflags_3">VkPipelineMultisampleStateCreateFlags(3)</h3>  <h4 id="_name_374">Name</h4>  <p>VkPipelineMultisampleStateCreateFlags - Bitmask of VkPipelineMultisampleStateCreateFlagBits</p>    <h4 id="_c_specification_374">C Specification</h4> <pre id="VkPipelineMultisampleStateCreateFlags" data-language="c++">typedef VkFlags VkPipelineMultisampleStateCreateFlags;</pre>   <h4 id="_description_374">Description</h4>  <p><code>VkPipelineMultisampleStateCreateFlags</code> is a mask of zero or more <a href="#VkPipelineMultisampleStateCreateFlagBits">VkPipelineMultisampleStateCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_374">See Also</h4>  <p><a href="#VkPipelineMultisampleStateCreateInfo">VkPipelineMultisampleStateCreateInfo</a></p>    <h4 id="_document_notes_374">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineMultisampleStateCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineMultisampleStateCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinerasterizationstatecreateflags_3">VkPipelineRasterizationStateCreateFlags(3)</h3>  <h4 id="_name_375">Name</h4>  <p>VkPipelineRasterizationStateCreateFlags - Bitmask of VkPipelineRasterizationStateCreateFlagBits</p>    <h4 id="_c_specification_375">C Specification</h4> <pre id="VkPipelineRasterizationStateCreateFlags" data-language="c++">typedef VkFlags VkPipelineRasterizationStateCreateFlags;</pre>   <h4 id="_description_375">Description</h4>  <p><code>VkPipelineRasterizationStateCreateFlags</code> is a mask of zero or more <a href="#VkPipelineRasterizationStateCreateFlagBits">VkPipelineRasterizationStateCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_375">See Also</h4>  <p><a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a></p>    <h4 id="_document_notes_375">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineRasterizationStateCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineRasterizationStateCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelineshaderstagecreateflags_3">VkPipelineShaderStageCreateFlags(3)</h3>  <h4 id="_name_376">Name</h4>  <p>VkPipelineShaderStageCreateFlags - Bitmask of VkPipelineShaderStageCreateFlagBits</p>    <h4 id="_c_specification_376">C Specification</h4> <pre id="VkPipelineShaderStageCreateFlags" data-language="c++">typedef VkFlags VkPipelineShaderStageCreateFlags;</pre>   <h4 id="_description_376">Description</h4>  <p><code>VkPipelineShaderStageCreateFlags</code> is a mask of zero or more <a href="#VkPipelineShaderStageCreateFlagBits">VkPipelineShaderStageCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_376">See Also</h4>  <p><a href="#VkPipelineShaderStageCreateInfo">VkPipelineShaderStageCreateInfo</a></p>    <h4 id="_document_notes_376">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineShaderStageCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineShaderStageCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinestageflags_3">VkPipelineStageFlags(3)</h3>  <h4 id="_name_377">Name</h4>  <p>VkPipelineStageFlags - Bitmask of VkPipelineStageFlagBits</p>    <h4 id="_c_specification_377">C Specification</h4> <pre id="VkPipelineStageFlags" data-language="c++">typedef VkFlags VkPipelineStageFlags;</pre>   <h4 id="_description_377">Description</h4>  <p><code>VkPipelineStageFlags</code> is a mask of zero or more <a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_377">See Also</h4>  <p><a href="#VkPipelineStageFlagBits">VkPipelineStageFlagBits</a>, <a href="#VkSubmitInfo">VkSubmitInfo</a>, <a href="#VkSubpassDependency">VkSubpassDependency</a>, <a href="#vkCmdPipelineBarrier">vkCmdPipelineBarrier</a>, <a href="#vkCmdResetEvent">vkCmdResetEvent</a>, <a href="#vkCmdSetEvent">vkCmdSetEvent</a>, <a href="#vkCmdWaitEvents">vkCmdWaitEvents</a></p>    <h4 id="_document_notes_377">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineStageFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineStageFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinetessellationstatecreateflags_3">VkPipelineTessellationStateCreateFlags(3)</h3>  <h4 id="_name_378">Name</h4>  <p>VkPipelineTessellationStateCreateFlags - Bitmask of VkPipelineTessellationStateCreateFlagBits</p>    <h4 id="_c_specification_378">C Specification</h4> <pre id="VkPipelineTessellationStateCreateFlags" data-language="c++">typedef VkFlags VkPipelineTessellationStateCreateFlags;</pre>   <h4 id="_description_378">Description</h4>  <p><code>VkPipelineTessellationStateCreateFlags</code> is a mask of zero or more <a href="#VkPipelineTessellationStateCreateFlagBits">VkPipelineTessellationStateCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_378">See Also</h4>  <p><a href="#VkPipelineTessellationStateCreateInfo">VkPipelineTessellationStateCreateInfo</a></p>    <h4 id="_document_notes_378">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineTessellationStateCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineTessellationStateCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelinevertexinputstatecreateflags_3">VkPipelineVertexInputStateCreateFlags(3)</h3>  <h4 id="_name_379">Name</h4>  <p>VkPipelineVertexInputStateCreateFlags - Bitmask of VkPipelineVertexInputStateCreateFlagBits</p>    <h4 id="_c_specification_379">C Specification</h4> <pre id="VkPipelineVertexInputStateCreateFlags" data-language="c++">typedef VkFlags VkPipelineVertexInputStateCreateFlags;</pre>   <h4 id="_description_379">Description</h4>  <p><code>VkPipelineVertexInputStateCreateFlags</code> is a mask of zero or more <a href="#VkPipelineVertexInputStateCreateFlagBits">VkPipelineVertexInputStateCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_379">See Also</h4>  <p><a href="#VkPipelineVertexInputStateCreateInfo">VkPipelineVertexInputStateCreateInfo</a></p>    <h4 id="_document_notes_379">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineVertexInputStateCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineVertexInputStateCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkpipelineviewportstatecreateflags_3">VkPipelineViewportStateCreateFlags(3)</h3>  <h4 id="_name_380">Name</h4>  <p>VkPipelineViewportStateCreateFlags - Bitmask of VkPipelineViewportStateCreateFlagBits</p>    <h4 id="_c_specification_380">C Specification</h4> <pre id="VkPipelineViewportStateCreateFlags" data-language="c++">typedef VkFlags VkPipelineViewportStateCreateFlags;</pre>   <h4 id="_description_380">Description</h4>  <p><code>VkPipelineViewportStateCreateFlags</code> is a mask of zero or more <a href="#VkPipelineViewportStateCreateFlagBits">VkPipelineViewportStateCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_380">See Also</h4>  <p><a href="#VkPipelineViewportStateCreateInfo">VkPipelineViewportStateCreateInfo</a></p>    <h4 id="_document_notes_380">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineViewportStateCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkPipelineViewportStateCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkquerycontrolflags_3">VkQueryControlFlags(3)</h3>  <h4 id="_name_381">Name</h4>  <p>VkQueryControlFlags - Bitmask of VkQueryControlFlagBits</p>    <h4 id="_c_specification_381">C Specification</h4> <pre id="VkQueryControlFlags" data-language="c++">typedef VkFlags VkQueryControlFlags;</pre>   <h4 id="_description_381">Description</h4>  <p><code>VkQueryControlFlags</code> is a mask of zero or more <a href="#VkQueryControlFlagBits">VkQueryControlFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_381">See Also</h4>  <p><a href="#VkCommandBufferInheritanceInfo">VkCommandBufferInheritanceInfo</a>, <a href="#VkQueryControlFlagBits">VkQueryControlFlagBits</a>, <a href="#vkCmdBeginQuery">vkCmdBeginQuery</a></p>    <h4 id="_document_notes_381">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryControlFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryControlFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkquerypipelinestatisticflags_3">VkQueryPipelineStatisticFlags(3)</h3>  <h4 id="_name_382">Name</h4>  <p>VkQueryPipelineStatisticFlags - Bitmask of VkQueryPipelineStatisticFlagBits</p>    <h4 id="_c_specification_382">C Specification</h4> <pre id="VkQueryPipelineStatisticFlags" data-language="c++">typedef VkFlags VkQueryPipelineStatisticFlags;</pre>   <h4 id="_description_382">Description</h4>  <p><code>VkQueryPipelineStatisticFlags</code> is a mask of zero or more <a href="#VkQueryPipelineStatisticFlagBits">VkQueryPipelineStatisticFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_382">See Also</h4>  <p><a href="#VkCommandBufferInheritanceInfo">VkCommandBufferInheritanceInfo</a>, <a href="#VkQueryPipelineStatisticFlagBits">VkQueryPipelineStatisticFlagBits</a>, <a href="#VkQueryPoolCreateInfo">VkQueryPoolCreateInfo</a></p>    <h4 id="_document_notes_382">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryPipelineStatisticFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryPipelineStatisticFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkquerypoolcreateflags_3">VkQueryPoolCreateFlags(3)</h3>  <h4 id="_name_383">Name</h4>  <p>VkQueryPoolCreateFlags - Bitmask of VkQueryPoolCreateFlagBits</p>    <h4 id="_c_specification_383">C Specification</h4> <pre id="VkQueryPoolCreateFlags" data-language="c++">typedef VkFlags VkQueryPoolCreateFlags;</pre>   <h4 id="_description_383">Description</h4>  <p><code>VkQueryPoolCreateFlags</code> is a mask of zero or more <a href="#VkQueryPoolCreateFlagBits">VkQueryPoolCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_383">See Also</h4>  <p><a href="#VkQueryPoolCreateInfo">VkQueryPoolCreateInfo</a></p>    <h4 id="_document_notes_383">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryPoolCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryPoolCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkqueryresultflags_3">VkQueryResultFlags(3)</h3>  <h4 id="_name_384">Name</h4>  <p>VkQueryResultFlags - Bitmask of VkQueryResultFlagBits</p>    <h4 id="_c_specification_384">C Specification</h4> <pre id="VkQueryResultFlags" data-language="c++">typedef VkFlags VkQueryResultFlags;</pre>   <h4 id="_description_384">Description</h4>  <p><code>VkQueryResultFlags</code> is a mask of zero or more <a href="#VkQueryResultFlagBits">VkQueryResultFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_384">See Also</h4>  <p><a href="#VkQueryResultFlagBits">VkQueryResultFlagBits</a>, <a href="#vkCmdCopyQueryPoolResults">vkCmdCopyQueryPoolResults</a>, <a href="#vkGetQueryPoolResults">vkGetQueryPoolResults</a></p>    <h4 id="_document_notes_384">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryResultFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueryResultFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkqueueflags_3">VkQueueFlags(3)</h3>  <h4 id="_name_385">Name</h4>  <p>VkQueueFlags - Bitmask of VkQueueFlagBits</p>    <h4 id="_c_specification_385">C Specification</h4> <pre id="VkQueueFlags" data-language="c++">typedef VkFlags VkQueueFlags;</pre>   <h4 id="_description_385">Description</h4>  <p><code>VkQueueFlags</code> is a mask of zero or more <a href="#VkQueueFlagBits">VkQueueFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_385">See Also</h4>  <p><a href="#VkQueueFamilyProperties">VkQueueFamilyProperties</a>, <a href="#VkQueueFlagBits">VkQueueFlagBits</a></p>    <h4 id="_document_notes_385">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueueFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkQueueFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkrenderpasscreateflags_3">VkRenderPassCreateFlags(3)</h3>  <h4 id="_name_386">Name</h4>  <p>VkRenderPassCreateFlags - Bitmask of VkRenderPassCreateFlagBits</p>    <h4 id="_c_specification_386">C Specification</h4> <pre id="VkRenderPassCreateFlags" data-language="c++">typedef VkFlags VkRenderPassCreateFlags;</pre>   <h4 id="_description_386">Description</h4>  <p><code>VkRenderPassCreateFlags</code> is a mask of zero or more <a href="#VkRenderPassCreateFlagBits">VkRenderPassCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_386">See Also</h4>  <p><a href="#VkRenderPassCreateInfo">VkRenderPassCreateInfo</a></p>    <h4 id="_document_notes_386">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkRenderPassCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkRenderPassCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vksamplecountflags_3">VkSampleCountFlags(3)</h3>  <h4 id="_name_387">Name</h4>  <p>VkSampleCountFlags - Bitmask of VkSampleCountFlagBits</p>    <h4 id="_c_specification_387">C Specification</h4> <pre id="VkSampleCountFlags" data-language="c++">typedef VkFlags VkSampleCountFlags;</pre>   <h4 id="_description_387">Description</h4>  <p><code>VkSampleCountFlags</code> is a mask of zero or more <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_387">See Also</h4>  <p><a href="#VkImageFormatProperties">VkImageFormatProperties</a>, <a href="#VkPhysicalDeviceLimits">VkPhysicalDeviceLimits</a>, <a href="#VkSampleCountFlagBits">VkSampleCountFlagBits</a></p>    <h4 id="_document_notes_387">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSampleCountFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSampleCountFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vksamplercreateflags_3">VkSamplerCreateFlags(3)</h3>  <h4 id="_name_388">Name</h4>  <p>VkSamplerCreateFlags - Bitmask of VkSamplerCreateFlagBits</p>    <h4 id="_c_specification_388">C Specification</h4> <pre id="VkSamplerCreateFlags" data-language="c++">typedef VkFlags VkSamplerCreateFlags;</pre>   <h4 id="_description_388">Description</h4>  <p><code>VkSamplerCreateFlags</code> is a mask of zero or more <a href="#VkSamplerCreateFlagBits">VkSamplerCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_388">See Also</h4>  <p><a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a></p>    <h4 id="_document_notes_388">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSamplerCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSamplerCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vksemaphorecreateflags_3">VkSemaphoreCreateFlags(3)</h3>  <h4 id="_name_389">Name</h4>  <p>VkSemaphoreCreateFlags - Bitmask of VkSemaphoreCreateFlagBits</p>    <h4 id="_c_specification_389">C Specification</h4> <pre id="VkSemaphoreCreateFlags" data-language="c++">typedef VkFlags VkSemaphoreCreateFlags;</pre>   <h4 id="_description_389">Description</h4>  <p><code>VkSemaphoreCreateFlags</code> is a mask of zero or more <a href="#VkSemaphoreCreateFlagBits">VkSemaphoreCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_389">See Also</h4>  <p><a href="#VkSemaphoreCreateInfo">VkSemaphoreCreateInfo</a></p>    <h4 id="_document_notes_389">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSemaphoreCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSemaphoreCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkshadermodulecreateflags_3">VkShaderModuleCreateFlags(3)</h3>  <h4 id="_name_390">Name</h4>  <p>VkShaderModuleCreateFlags - Bitmask of VkShaderModuleCreateFlagBits</p>    <h4 id="_c_specification_390">C Specification</h4> <pre id="VkShaderModuleCreateFlags" data-language="c++">typedef VkFlags VkShaderModuleCreateFlags;</pre>   <h4 id="_description_390">Description</h4>  <p><code>VkShaderModuleCreateFlags</code> is a mask of zero or more <a href="#VkShaderModuleCreateFlagBits">VkShaderModuleCreateFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_390">See Also</h4>  <p><a href="#VkShaderModuleCreateInfo">VkShaderModuleCreateInfo</a></p>    <h4 id="_document_notes_390">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkShaderModuleCreateFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkShaderModuleCreateFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkshaderstageflags_3">VkShaderStageFlags(3)</h3>  <h4 id="_name_391">Name</h4>  <p>VkShaderStageFlags - Bitmask of VkShaderStageFlagBits</p>    <h4 id="_c_specification_391">C Specification</h4> <pre id="VkShaderStageFlags" data-language="c++">typedef VkFlags VkShaderStageFlags;</pre>   <h4 id="_description_391">Description</h4>  <p><code>VkShaderStageFlags</code> is a mask of zero or more <a href="#VkShaderStageFlagBits">VkShaderStageFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_391">See Also</h4>  <p><a href="#VkDescriptorSetLayoutBinding">VkDescriptorSetLayoutBinding</a>, <a href="#VkPushConstantRange">VkPushConstantRange</a>, <a href="#VkShaderStageFlagBits">VkShaderStageFlagBits</a>, <a href="#vkCmdPushConstants">vkCmdPushConstants</a></p>    <h4 id="_document_notes_391">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkShaderStageFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkShaderStageFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vksparseimageformatflags_3">VkSparseImageFormatFlags(3)</h3>  <h4 id="_name_392">Name</h4>  <p>VkSparseImageFormatFlags - Bitmask of VkSparseImageFormatFlagBits</p>    <h4 id="_c_specification_392">C Specification</h4> <pre id="VkSparseImageFormatFlags" data-language="c++">typedef VkFlags VkSparseImageFormatFlags;</pre>   <h4 id="_description_392">Description</h4>  <p><code>VkSparseImageFormatFlags</code> is a mask of zero or more <a href="#VkSparseImageFormatFlagBits">VkSparseImageFormatFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_392">See Also</h4>  <p><a href="#VkSparseImageFormatFlagBits">VkSparseImageFormatFlagBits</a>, <a href="#VkSparseImageFormatProperties">VkSparseImageFormatProperties</a></p>    <h4 id="_document_notes_392">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageFormatFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseImageFormatFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vksparsememorybindflags_3">VkSparseMemoryBindFlags(3)</h3>  <h4 id="_name_393">Name</h4>  <p>VkSparseMemoryBindFlags - Bitmask of VkSparseMemoryBindFlagBits</p>    <h4 id="_c_specification_393">C Specification</h4> <pre id="VkSparseMemoryBindFlags" data-language="c++">typedef VkFlags VkSparseMemoryBindFlags;</pre>   <h4 id="_description_393">Description</h4>  <p><code>VkSparseMemoryBindFlags</code> is a mask of zero or more <a href="#VkSparseMemoryBindFlagBits">VkSparseMemoryBindFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_393">See Also</h4>  <p><a href="#VkSparseImageMemoryBind">VkSparseImageMemoryBind</a>, <a href="#VkSparseMemoryBind">VkSparseMemoryBind</a>, <a href="#VkSparseMemoryBindFlagBits">VkSparseMemoryBindFlagBits</a></p>    <h4 id="_document_notes_393">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseMemoryBindFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSparseMemoryBindFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vkstencilfaceflags_3">VkStencilFaceFlags(3)</h3>  <h4 id="_name_394">Name</h4>  <p>VkStencilFaceFlags - Bitmask of VkStencilFaceFlagBits</p>    <h4 id="_c_specification_394">C Specification</h4> <pre id="VkStencilFaceFlags" data-language="c++">typedef VkFlags VkStencilFaceFlags;</pre>   <h4 id="_description_394">Description</h4>  <p><code>VkStencilFaceFlags</code> is a mask of zero or more <a href="#VkStencilFaceFlagBits">VkStencilFaceFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_394">See Also</h4>  <p><a href="#VkStencilFaceFlagBits">VkStencilFaceFlagBits</a>, <a href="#vkCmdSetStencilCompareMask">vkCmdSetStencilCompareMask</a>, <a href="#vkCmdSetStencilReference">vkCmdSetStencilReference</a>, <a href="#vkCmdSetStencilWriteMask">vkCmdSetStencilWriteMask</a></p>    <h4 id="_document_notes_394">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkStencilFaceFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkStencilFaceFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>      <h3 id="_vksubpassdescriptionflags_3">VkSubpassDescriptionFlags(3)</h3>  <h4 id="_name_395">Name</h4>  <p>VkSubpassDescriptionFlags - Bitmask of VkSubpassDescriptionFlagBits</p>    <h4 id="_c_specification_395">C Specification</h4> <pre id="VkSubpassDescriptionFlags" data-language="c++">typedef VkFlags VkSubpassDescriptionFlags;</pre>   <h4 id="_description_395">Description</h4>  <p><code>VkSubpassDescriptionFlags</code> is a mask of zero or more <a href="#VkSubpassDescriptionFlagBits">VkSubpassDescriptionFlagBits</a>. It is used as a member and/or parameter of the structures and commands in the See Also section below.</p>    <h4 id="_see_also_395">See Also</h4>  <p><a href="#VkSubpassDescription">VkSubpassDescription</a>, <a href="#VkSubpassDescriptionFlagBits">VkSubpassDescriptionFlagBits</a></p>    <h4 id="_document_notes_395">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubpassDescriptionFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSubpassDescriptionFlags</a></p>   <p>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</p>        <h2 id="funcpointers">Function Pointer Types</h2>   <h3 id="_pfn_vkallocationfunction_3">PFN_vkAllocationFunction(3)</h3>  <h4 id="_name_396">Name</h4>  <p>PFN_vkAllocationFunction - Application-defined memory allocation function</p>    <h4 id="_c_specification_396">C Specification</h4>  <p>The type of <code>pfnAllocation</code> is:</p>  <pre id="PFN_vkAllocationFunction" data-language="c++">typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);</pre>   <h4 id="_parameters_138">Parameters</h4>  <ul> <li> <code>pUserData</code> is the value specified for <a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>::<code>pUserData</code> in the allocator specified by the application. </li> <li> <code>size</code> is the size in bytes of the requested allocation. </li> <li> <code>alignment</code> is the requested alignment of the allocation in bytes and <strong>must</strong> be a power of two. </li> <li> <code>allocationScope</code> is a <a href="#VkSystemAllocationScope">VkSystemAllocationScope</a> value specifying the allocation scope of the lifetime of the allocation, as described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-host-allocation-scope">here</a>. </li> </ul>    <h4 id="_description_396">Description</h4>  <p>If <code>pfnAllocation</code> is unable to allocate the requested memory, it <strong>must</strong> return <code>NULL</code>. If the allocation was successful, it <strong>must</strong> return a valid pointer to memory allocation containing at least <code>size</code> bytes, and with the pointer value being a multiple of <code>alignment</code>.</p>  <blockquote> <h5 class="title">Note</h5>  <p>Correct Vulkan operation <strong>cannot</strong> be assumed if the application does not follow these rules.</p>   <p>For example, <code>pfnAllocation</code> (or <code>pfnReallocation</code>) could cause termination of running Vulkan instance(s) on a failed allocation for debugging purposes, either directly or indirectly. In these circumstances, it <strong>cannot</strong> be assumed that any part of any affected VkInstance objects are going to operate correctly (even <a href="#vkDestroyInstance">vkDestroyInstance</a>), and the application <strong>must</strong> ensure it cleans up properly via other means (e.g. process termination).</p>  </blockquote>  <p>If <code>pfnAllocation</code> returns <code>NULL</code>, and if the implementation is unable to continue correct processing of the current command without the requested allocation, it <strong>must</strong> treat this as a run-time error, and generate <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> at the appropriate time for the command in which the condition was detected, as described in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-errorcodes">Return Codes</a>.</p>   <p>If the implementation is able to continue correct processing of the current command without the requested allocation, then it <strong>may</strong> do so, and <strong>must</strong> not generate <code>VK_ERROR_OUT_OF_HOST_MEMORY</code> as a result of this failed allocation.</p>    <h4 id="_see_also_396">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a></p>    <h4 id="_document_notes_396">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkAllocationFunction">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkAllocationFunction</a></p>         <h3 id="_pfn_vkfreefunction_3">PFN_vkFreeFunction(3)</h3>  <h4 id="_name_397">Name</h4>  <p>PFN_vkFreeFunction - Application-defined memory free function</p>    <h4 id="_c_specification_397">C Specification</h4>  <p>The type of <code>pfnFree</code> is:</p>  <pre id="PFN_vkFreeFunction" data-language="c++">typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);</pre>   <h4 id="_parameters_139">Parameters</h4>  <ul> <li> <code>pUserData</code> is the value specified for <a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>::<code>pUserData</code> in the allocator specified by the application. </li> <li> <code>pMemory</code> is the allocation to be freed. </li> </ul>    <h4 id="_description_397">Description</h4>  <p><code>pMemory</code> <strong>may</strong> be <code>NULL</code>, which the callback <strong>must</strong> handle safely. If <code>pMemory</code> is non-<code>NULL</code>, it <strong>must</strong> be a pointer previously allocated by <code>pfnAllocation</code> or <code>pfnReallocation</code>. The application <strong>should</strong> free this memory.</p>    <h4 id="_see_also_397">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a></p>    <h4 id="_document_notes_397">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkFreeFunction">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkFreeFunction</a></p>         <h3 id="_pfn_vkinternalallocationnotification_3">PFN_vkInternalAllocationNotification(3)</h3>  <h4 id="_name_398">Name</h4>  <p>PFN_vkInternalAllocationNotification - Application-defined memory allocation notification function</p>    <h4 id="_c_specification_398">C Specification</h4>  <p>The type of <code>pfnInternalAllocation</code> is:</p>  <pre id="PFN_vkInternalAllocationNotification" data-language="c++">typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);</pre>   <h4 id="_parameters_140">Parameters</h4>  <ul> <li> <code>pUserData</code> is the value specified for <a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>::<code>pUserData</code> in the allocator specified by the application. </li> <li> <code>size</code> is the requested size of an allocation. </li> <li> <code>allocationType</code> is a <a href="#VkInternalAllocationType">VkInternalAllocationType</a> value specifying the requested type of an allocation. </li> <li> <code>allocationScope</code> is a <a href="#VkSystemAllocationScope">VkSystemAllocationScope</a> value specifying the allocation scope of the lifetime of the allocation, as described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-host-allocation-scope">here</a>. </li> </ul>    <h4 id="_description_398">Description</h4>  <p>This is a purely informational callback.</p>    <h4 id="_see_also_398">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a></p>    <h4 id="_document_notes_398">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkInternalAllocationNotification">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkInternalAllocationNotification</a></p>         <h3 id="_pfn_vkinternalfreenotification_3">PFN_vkInternalFreeNotification(3)</h3>  <h4 id="_name_399">Name</h4>  <p>PFN_vkInternalFreeNotification - Application-defined memory free notification function</p>    <h4 id="_c_specification_399">C Specification</h4>  <p>The type of <code>pfnInternalFree</code> is:</p>  <pre id="PFN_vkInternalFreeNotification" data-language="c++">typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);</pre>   <h4 id="_parameters_141">Parameters</h4>  <ul> <li> <code>pUserData</code> is the value specified for <a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>::<code>pUserData</code> in the allocator specified by the application. </li> <li> <code>size</code> is the requested size of an allocation. </li> <li> <code>allocationType</code> is a <a href="#VkInternalAllocationType">VkInternalAllocationType</a> value specifying the requested type of an allocation. </li> <li> <code>allocationScope</code> is a <a href="#VkSystemAllocationScope">VkSystemAllocationScope</a> value specifying the allocation scope of the lifetime of the allocation, as described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-host-allocation-scope">here</a>. </li> </ul>       <h4 id="_see_also_399">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a></p>    <h4 id="_document_notes_399">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkInternalFreeNotification">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkInternalFreeNotification</a></p>         <h3 id="_pfn_vkreallocationfunction_3">PFN_vkReallocationFunction(3)</h3>  <h4 id="_name_400">Name</h4>  <p>PFN_vkReallocationFunction - Application-defined memory reallocation function</p>    <h4 id="_c_specification_400">C Specification</h4>  <p>The type of <code>pfnReallocation</code> is:</p>  <pre id="PFN_vkReallocationFunction" data-language="c++">typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);</pre>   <h4 id="_parameters_142">Parameters</h4>  <ul> <li> <code>pUserData</code> is the value specified for <a href="#VkAllocationCallbacks">VkAllocationCallbacks</a>::<code>pUserData</code> in the allocator specified by the application. </li> <li> <code>pOriginal</code> <strong>must</strong> be either <code>NULL</code> or a pointer previously returned by <code>pfnReallocation</code> or <code>pfnAllocation</code> of the same allocator. </li> <li> <code>size</code> is the size in bytes of the requested allocation. </li> <li> <code>alignment</code> is the requested alignment of the allocation in bytes and <strong>must</strong> be a power of two. </li> <li> <code>allocationScope</code> is a <a href="#VkSystemAllocationScope">VkSystemAllocationScope</a> value specifying the allocation scope of the lifetime of the allocation, as described <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-host-allocation-scope">here</a>. </li> </ul>    <h4 id="_description_400">Description</h4>  <p><code>pfnReallocation</code> <strong>must</strong> return an allocation with enough space for <code>size</code> bytes, and the contents of the original allocation from bytes zero to min(original size, new size) - 1 <strong>must</strong> be preserved in the returned allocation. If <code>size</code> is larger than the old size, the contents of the additional space are undefined. If satisfying these requirements involves creating a new allocation, then the old allocation <strong>should</strong> be freed.</p>   <p>If <code>pOriginal</code> is <code>NULL</code>, then <code>pfnReallocation</code> <strong>must</strong> behave equivalently to a call to <a href="#PFN_vkAllocationFunction">PFN_vkAllocationFunction</a> with the same parameter values (without <code>pOriginal</code>).</p>   <p>If <code>size</code> is zero, then <code>pfnReallocation</code> <strong>must</strong> behave equivalently to a call to <a href="#PFN_vkFreeFunction">PFN_vkFreeFunction</a> with the same <code>pUserData</code> parameter value, and <code>pMemory</code> equal to <code>pOriginal</code>.</p>   <p>If <code>pOriginal</code> is non-<code>NULL</code>, the implementation <strong>must</strong> ensure that <code>alignment</code> is equal to the <code>alignment</code> used to originally allocate <code>pOriginal</code>.</p>   <p>If this function fails and <code>pOriginal</code> is non-<code>NULL</code> the application <strong>must</strong> not free the old allocation.</p>   <p><code>pfnReallocation</code> <strong>must</strong> follow the same <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vkAllocationFunction_return_rules">rules for return values as <code>PFN_vkAllocationFunction</code></a>.</p>    <h4 id="_see_also_400">See Also</h4>  <p><a href="#VkAllocationCallbacks">VkAllocationCallbacks</a></p>    <h4 id="_document_notes_400">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkReallocationFunction">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkReallocationFunction</a></p>         <h3 id="_pfn_vkvoidfunction_3">PFN_vkVoidFunction(3)</h3>  <h4 id="_name_401">Name</h4>  <p>PFN_vkVoidFunction - Dummy function pointer type returned by queries</p>    <h4 id="_c_specification_401">C Specification</h4>  <p>The definition of <a href="#PFN_vkVoidFunction">PFN_vkVoidFunction</a> is:</p>  <pre id="PFN_vkVoidFunction" data-language="c++">typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);</pre>         <h4 id="_see_also_401">See Also</h4>  <p><a href="#vkGetDeviceProcAddr">vkGetDeviceProcAddr</a>, <a href="#vkGetInstanceProcAddr">vkGetInstanceProcAddr</a></p>    <h4 id="_document_notes_401">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkVoidFunction">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#PFN_vkVoidFunction</a></p>           <h2 id="basetypes">Vulkan Scalar types</h2>   <h3 id="_vkbool32_3">VkBool32(3)</h3>  <h4 id="_name_402">Name</h4>  <p>VkBool32 - Vulkan boolean type</p>    <h4 id="_c_specification_402">C Specification</h4>  <p><code>VkBool32</code> represents boolean <code>True</code> and <code>False</code> values, since C does not have a sufficiently portable built-in boolean type:</p>  <pre id="VkBool32" data-language="c++">typedef uint32_t VkBool32;</pre>   <h4 id="_description_402">Description</h4>  <p><code>VK_TRUE</code> represents a boolean <strong>True</strong> (integer 1) value, and <code>VK_FALSE</code> a boolean <strong>False</strong> (integer 0) value.</p>   <p>All values returned from a Vulkan implementation in a <code>VkBool32</code> will be either <code>VK_TRUE</code> or <code>VK_FALSE</code>.</p>   <p>Applications <strong>must</strong> not pass any other values than <code>VK_TRUE</code> or <code>VK_FALSE</code> into a Vulkan implementation where a <code>VkBool32</code> is expected.</p>    <h4 id="_see_also_402">See Also</h4>  <p><a href="#VkCommandBufferInheritanceInfo">VkCommandBufferInheritanceInfo</a>, <a href="#VkPhysicalDeviceFeatures">VkPhysicalDeviceFeatures</a>, <a href="#VkPhysicalDeviceLimits">VkPhysicalDeviceLimits</a>, <a href="#VkPhysicalDeviceSparseProperties">VkPhysicalDeviceSparseProperties</a>, <a href="#VkPipelineColorBlendAttachmentState">VkPipelineColorBlendAttachmentState</a>, <a href="#VkPipelineColorBlendStateCreateInfo">VkPipelineColorBlendStateCreateInfo</a>, <a href="#VkPipelineDepthStencilStateCreateInfo">VkPipelineDepthStencilStateCreateInfo</a>, <a href="#VkPipelineInputAssemblyStateCreateInfo">VkPipelineInputAssemblyStateCreateInfo</a>, <a href="#VkPipelineMultisampleStateCreateInfo">VkPipelineMultisampleStateCreateInfo</a>, <a href="#VkPipelineRasterizationStateCreateInfo">VkPipelineRasterizationStateCreateInfo</a>, <a href="#VkSamplerCreateInfo">VkSamplerCreateInfo</a>, <a href="#vkWaitForFences">vkWaitForFences</a></p>    <h4 id="_document_notes_402">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBool32">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBool32</a></p>         <h3 id="_vkdevicesize_3">VkDeviceSize(3)</h3>  <h4 id="_name_403">Name</h4>  <p>VkDeviceSize - Vulkan device memory size and offsets</p>    <h4 id="_c_specification_403">C Specification</h4>  <p><code>VkDeviceSize</code> represents device memory size and offset values:</p>  <pre id="VkDeviceSize" data-language="c++">typedef uint64_t VkDeviceSize;</pre>      <h4 id="_see_also_403">See Also</h4>  <p><a href="#VkBufferCopy">VkBufferCopy</a>, <a href="#VkBufferCreateInfo">VkBufferCreateInfo</a>, <a href="#VkBufferImageCopy">VkBufferImageCopy</a>, <a href="#VkBufferMemoryBarrier">VkBufferMemoryBarrier</a>, <a href="#VkBufferViewCreateInfo">VkBufferViewCreateInfo</a>, <a href="#VkDescriptorBufferInfo">VkDescriptorBufferInfo</a>, <a href="#VkImageFormatProperties">VkImageFormatProperties</a>, <a href="#VkMappedMemoryRange">VkMappedMemoryRange</a>, <a href="#VkMemoryAllocateInfo">VkMemoryAllocateInfo</a>, <a href="#VkMemoryHeap">VkMemoryHeap</a>, <a href="#VkMemoryRequirements">VkMemoryRequirements</a>, <a href="#VkPhysicalDeviceLimits">VkPhysicalDeviceLimits</a>, <a href="#VkSparseImageMemoryBind">VkSparseImageMemoryBind</a>, <a href="#VkSparseImageMemoryRequirements">VkSparseImageMemoryRequirements</a>, <a href="#VkSparseMemoryBind">VkSparseMemoryBind</a>, <a href="#VkSubresourceLayout">VkSubresourceLayout</a>, <a href="#vkBindBufferMemory">vkBindBufferMemory</a>, <a href="#vkBindImageMemory">vkBindImageMemory</a>, <a href="#vkCmdBindIndexBuffer">vkCmdBindIndexBuffer</a>, <a href="#vkCmdBindVertexBuffers">vkCmdBindVertexBuffers</a>, <a href="#vkCmdCopyQueryPoolResults">vkCmdCopyQueryPoolResults</a>, <a href="#vkCmdDispatchIndirect">vkCmdDispatchIndirect</a>, <a href="#vkCmdDrawIndexedIndirect">vkCmdDrawIndexedIndirect</a>, <a href="#vkCmdDrawIndirect">vkCmdDrawIndirect</a>, <a href="#vkCmdFillBuffer">vkCmdFillBuffer</a>, <a href="#vkCmdUpdateBuffer">vkCmdUpdateBuffer</a>, <a href="#vkGetDeviceMemoryCommitment">vkGetDeviceMemoryCommitment</a>, <a href="#vkGetQueryPoolResults">vkGetQueryPoolResults</a>, <a href="#vkMapMemory">vkMapMemory</a></p>    <h4 id="_document_notes_403">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceSize">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkDeviceSize</a></p>         <h3 id="_vkflags_3">VkFlags(3)</h3>  <h4 id="_name_404">Name</h4>  <p>VkFlags - Vulkan bitmasks</p>    <h4 id="_c_specification_404">C Specification</h4>  <p>A collection of flags is represented by a bitmask using the type <code>VkFlags</code>:</p>  <pre id="VkFlags" data-language="c++">typedef uint32_t VkFlags;</pre>   <h4 id="_description_404">Description</h4>  <p>Bitmasks are passed to many commands and structures to compactly represent options, but <code>VkFlags</code> is not used directly in the API. Instead, a <code>Vk*Flags</code> type which is an alias of <code>VkFlags</code>, and whose name matches the corresponding <code>Vk*FlagBits</code> that are valid for that type, is used. These aliases are described in the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#boilerplate-flags">Flag Types</a> appendix of the Specification.</p>    <h4 id="_see_also_404">See Also</h4>  <p><a href="#VkColorComponentFlags">VkColorComponentFlags</a></p>    <h4 id="_document_notes_404">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFlags">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkFlags</a></p>         <h3 id="_vksamplemask_3">VkSampleMask(3)</h3>  <h4 id="_name_405">Name</h4>  <p>VkSampleMask - Mask of sample coverage information</p>    <h4 id="_c_specification_405">C Specification</h4>  <p>The elements of the sample mask array are of type <code>VkSampleMask</code>, each representing 32 bits of coverage information:</p>  <pre id="VkSampleMask" data-language="c++">typedef uint32_t VkSampleMask;</pre>      <h4 id="_see_also_405">See Also</h4>  <p><a href="#VkPipelineMultisampleStateCreateInfo">VkPipelineMultisampleStateCreateInfo</a></p>    <h4 id="_document_notes_405">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSampleMask">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkSampleMask</a></p>           <h2 id="defines">C Macro Definitions</h2>   <h3 id="_vk_api_version_3">VK_API_VERSION(3)</h3>  <h4 id="_name_406">Name</h4>  <p>VK_API_VERSION - Deprecated version number macro</p>    <h4 id="_c_specification_406">C Specification</h4>  <p><code>VK_API_VERSION</code> is now commented out of vulkan.h and <strong>cannot</strong> be used.</p>  <pre id="VK_API_VERSION" data-language="c++">// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define VK_API_VERSION VK_MAKE_VERSION(1, 0, 0) // Patch version should always be set to 0</pre>      <h4 id="_see_also_406">See Also</h4>  <p>No cross-references are available</p>    <h4 id="_document_notes_406">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_API_VERSION">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_API_VERSION</a></p>         <h3 id="_vk_api_version_1_0_3">VK_API_VERSION_1_0(3)</h3>  <h4 id="_name_407">Name</h4>  <p>VK_API_VERSION_1_0 - Return API version number for Vulkan 1.0</p>    <h4 id="_c_specification_407">C Specification</h4>  <p><code>VK_API_VERSION_1_0</code> returns the API version number for Vulkan 1.0. The patch version number in this macro will always be zero. The supported patch version for a physical device <strong>can</strong> be queried with <a href="#vkGetPhysicalDeviceProperties">vkGetPhysicalDeviceProperties</a>.</p>  <pre id="VK_API_VERSION_1_0" data-language="c++">// Vulkan 1.0 version number
#define VK_API_VERSION_1_0 VK_MAKE_VERSION(1, 0, 0)// Patch version should always be set to 0</pre>      <h4 id="_see_also_407">See Also</h4>  <p><a href="#vkCreateInstance">vkCreateInstance</a>, <a href="#vkGetPhysicalDeviceProperties">vkGetPhysicalDeviceProperties</a></p>    <h4 id="_document_notes_407">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_API_VERSION_1_0">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_API_VERSION_1_0</a></p>         <h3 id="_vk_define_handle_3">VK_DEFINE_HANDLE(3)</h3>  <h4 id="_name_408">Name</h4>  <p>VK_DEFINE_HANDLE - Declare a dispatchable object handle</p>    <h4 id="_c_specification_408">C Specification</h4>  <p><code>VK_DEFINE_HANDLE</code> defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-objectmodel-overview">dispatchable handle</a> type.</p>  <pre id="VK_DEFINE_HANDLE" data-language="c++">#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;</pre>   <h4 id="_description_408">Description</h4>  <ul> <li> <code>object</code> is the name of the resulting C type. </li> </ul>   <p>The only dispatchable handle types are those related to device and instance management, such as <a href="#VkDevice">VkDevice</a>.</p>    <h4 id="_see_also_408">See Also</h4>  <p><a href="#VkCommandBuffer">VkCommandBuffer</a>, <a href="#VkDevice">VkDevice</a>, <a href="#VkInstance">VkInstance</a>, <a href="#VkPhysicalDevice">VkPhysicalDevice</a>, <a href="#VkQueue">VkQueue</a></p>    <h4 id="_document_notes_408">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_DEFINE_HANDLE">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_DEFINE_HANDLE</a></p>         <h3 id="_vk_define_non_dispatchable_handle_3">VK_DEFINE_NON_DISPATCHABLE_HANDLE(3)</h3>  <h4 id="_name_409">Name</h4>  <p>VK_DEFINE_NON_DISPATCHABLE_HANDLE - Declare a non-dispatchable object handle</p>    <h4 id="_c_specification_409">C Specification</h4>  <p><code>VK_DEFINE_NON_DISPATCHABLE_HANDLE</code> defines a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-objectmodel-overview">non-dispatchable handle</a> type.</p>  <pre id="VK_DEFINE_NON_DISPATCHABLE_HANDLE" data-language="c++">#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) &amp;&amp; !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif</pre>   <h4 id="_description_409">Description</h4>  <ul> <li> <code>object</code> is the name of the resulting C type. </li> </ul>   <p>Most Vulkan handle types, such as <a href="#VkBuffer">VkBuffer</a>, are non-dispatchable.</p>  <blockquote> <h5 class="title">Note</h5>  <p>The vulkan.h header allows the <code>VK_DEFINE_NON_DISPATCHABLE_HANDLE</code> definition to be overridden by the application. If <code>VK_DEFINE_NON_DISPATCHABLE_HANDLE</code> is already defined when the vulkan.h header is compiled the default definition is skipped. This allows the application to define a binary-compatible custom handle which <strong>may</strong> provide more type-safety or other features needed by the application. Behavior is undefined if the application defines a non-binary-compatible handle and <strong>may</strong> result in memory corruption or application termination. Binary compatibility is platform dependent so the application <strong>must</strong> be careful if it overrides the default <code>VK_DEFINE_NON_DISPATCHABLE_HANDLE</code> definition.</p>  </blockquote>   <h4 id="_see_also_409">See Also</h4>  <p><a href="#VkBuffer">VkBuffer</a></p>    <h4 id="_document_notes_409">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_DEFINE_NON_DISPATCHABLE_HANDLE">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_DEFINE_NON_DISPATCHABLE_HANDLE</a></p>         <h3 id="_vk_header_version_3">VK_HEADER_VERSION(3)</h3>  <h4 id="_name_410">Name</h4>  <p>VK_HEADER_VERSION - Vulkan header file version number</p>    <h4 id="_c_specification_410">C Specification</h4>  <p><code>VK_HEADER_VERSION</code> is the version number of the vulkan.h header. This value is currently kept synchronized with the release number of the Specification. However, it is not guaranteed to remain synchronized, since most Specification updates have no effect on vulkan.h.</p>  <pre id="VK_HEADER_VERSION" data-language="c++">// Version of this file
#define VK_HEADER_VERSION 59</pre>      <h4 id="_see_also_410">See Also</h4>  <p>No cross-references are available</p>    <h4 id="_document_notes_410">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_HEADER_VERSION">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_HEADER_VERSION</a></p>         <h3 id="_vk_make_version_3">VK_MAKE_VERSION(3)</h3>  <h4 id="_name_411">Name</h4>  <p>VK_MAKE_VERSION - Construct an API version number</p>    <h4 id="_c_specification_411">C Specification</h4>  <p><code>VK_MAKE_VERSION</code> constructs an API version number.</p>  <pre id="VK_MAKE_VERSION" data-language="c++">#define VK_MAKE_VERSION(major, minor, patch) \
    (((major) &lt;&lt; 22) | ((minor) &lt;&lt; 12) | (patch))</pre>   <h4 id="_description_411">Description</h4>  <ul> <li> <code>major</code> is the major version number. </li> <li> <code>minor</code> is the minor version number. </li> <li> <code>patch</code> is the patch version number. </li> </ul>   <p>This macro <strong>can</strong> be used when constructing the <a href="#VkApplicationInfo">VkApplicationInfo</a>::<code>apiVersion</code> parameter passed to <a href="#vkCreateInstance">vkCreateInstance</a>.</p>    <h4 id="_see_also_411">See Also</h4>  <p><a href="#VkApplicationInfo">VkApplicationInfo</a>, <a href="#vkCreateInstance">vkCreateInstance</a></p>    <h4 id="_document_notes_411">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_MAKE_VERSION">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_MAKE_VERSION</a></p>         <h3 id="_vk_null_handle_3">VK_NULL_HANDLE(3)</h3>  <h4 id="_name_412">Name</h4>  <p>VK_NULL_HANDLE - Reserved non-valid object handle</p>    <h4 id="_c_specification_412">C Specification</h4>  <p><code>VK_NULL_HANDLE</code> is a reserved value representing a non-valid object handle. It may be passed to and returned from Vulkan commands only when <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-validusage-handles">specifically allowed</a>.</p>  <pre id="VK_NULL_HANDLE" data-language="c++">#define VK_NULL_HANDLE 0</pre>      <h4 id="_see_also_412">See Also</h4>  <p>No cross-references are available</p>    <h4 id="_document_notes_412">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_NULL_HANDLE">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_NULL_HANDLE</a></p>         <h3 id="_vk_version_major_3">VK_VERSION_MAJOR(3)</h3>  <h4 id="_name_413">Name</h4>  <p>VK_VERSION_MAJOR - Extract API major version number</p>    <h4 id="_c_specification_413">C Specification</h4>  <p><code>VK_VERSION_MAJOR</code> extracts the API major version number from a packed version number:</p>  <pre id="VK_VERSION_MAJOR" data-language="c++">#define VK_VERSION_MAJOR(version) ((uint32_t)(version) &gt;&gt; 22)</pre>      <h4 id="_see_also_413">See Also</h4>  <p>No cross-references are available</p>    <h4 id="_document_notes_413">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_VERSION_MAJOR">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_VERSION_MAJOR</a></p>         <h3 id="_vk_version_minor_3">VK_VERSION_MINOR(3)</h3>  <h4 id="_name_414">Name</h4>  <p>VK_VERSION_MINOR - Extract API minor version number</p>    <h4 id="_c_specification_414">C Specification</h4>  <p><code>VK_VERSION_MINOR</code> extracts the API minor version number from a packed version number:</p>  <pre id="VK_VERSION_MINOR" data-language="c++">#define VK_VERSION_MINOR(version) (((uint32_t)(version) &gt;&gt; 12) &amp; 0x3ff)</pre>      <h4 id="_see_also_414">See Also</h4>  <p>No cross-references are available</p>    <h4 id="_document_notes_414">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_VERSION_MINOR">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_VERSION_MINOR</a></p>         <h3 id="_vk_version_patch_3">VK_VERSION_PATCH(3)</h3>  <h4 id="_name_415">Name</h4>  <p>VK_VERSION_PATCH - Extract API patch version number</p>    <h4 id="_c_specification_415">C Specification</h4>  <p><code>VK_VERSION_PATCH</code> extracts the API patch version number from a packed version number:</p>  <pre id="VK_VERSION_PATCH" data-language="c++">#define VK_VERSION_PATCH(version) ((uint32_t)(version) &amp; 0xfff)</pre>      <h4 id="_see_also_415">See Also</h4>  <p>No cross-references are available</p>    <h4 id="_document_notes_415">Document Notes</h4>  <p>For more information, see the Vulkan Specification at URL</p>   <p><a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_VERSION_PATCH">https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VK_VERSION_PATCH</a></p>     <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2017 Khronos Group Inc.<br>Licensed under the Creative Commons Attribution 4.0 International License.<br>Vulkan and the Vulkan logo are registered trademarks of the Khronos Group Inc.<br>
    <a href="https://www.khronos.org/registry/vulkan/specs/1.0/apispec.html" class="_attribution-link">https://www.khronos.org/registry/vulkan/specs/1.0/apispec.html</a>
  </p>
</div>
