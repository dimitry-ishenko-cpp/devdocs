<h1>Package org.omg.CosNaming</h1>  <p>Provides a naming service for Java IDL.</p>  <p>See: <a href="#package.description">Description</a></p>   <table>  <tr> <th scope="col">Interface</th> <th scope="col">Description</th> </tr>  <tr> <td><a href="bindingiterator.html">BindingIterator</a></td> <td> <p>The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.</p> </td> </tr> <tr> <td><a href="bindingiteratoroperations.html">BindingIteratorOperations</a></td> <td> <p>The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.</p> </td> </tr> <tr> <td><a href="namingcontext.html">NamingContext</a></td> <td> <p>A naming context is an object that contains a set of name bindings in which each name is unique.</p> </td> </tr> <tr> <td><a href="namingcontextext.html">NamingContextExt</a></td> <td> <p><code>NamingContextExt</code> is the extension of <code>NamingContext</code> which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.</p> </td> </tr> <tr> <td><a href="namingcontextextoperations.html">NamingContextExtOperations</a></td> <td> <p><code>NamingContextExt</code> is the extension of <code>NamingContext</code> which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.</p> </td> </tr> <tr> <td><a href="namingcontextoperations.html">NamingContextOperations</a></td> <td> <p>A naming context is an object that contains a set of name bindings in which each name is unique.</p> </td> </tr>  </table>
<table>  <tr> <th scope="col">Class</th> <th scope="col">Description</th> </tr>  <tr> <td><a href="_bindingiteratorimplbase.html">_BindingIteratorImplBase</a></td> <td> </td> </tr> <tr> <td><a href="_bindingiteratorstub.html">_BindingIteratorStub</a></td> <td> <p>The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.</p> </td> </tr> <tr> <td><a href="_namingcontextextstub.html">_NamingContextExtStub</a></td> <td> <p><code>NamingContextExt</code> is the extension of <code>NamingContext</code> which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.</p> </td> </tr> <tr> <td><a href="_namingcontextimplbase.html">_NamingContextImplBase</a></td> <td> </td> </tr> <tr> <td><a href="_namingcontextstub.html">_NamingContextStub</a></td> <td> <p>A naming context is an object that contains a set of name bindings in which each name is unique.</p> </td> </tr> <tr> <td><a href="binding.html">Binding</a></td> <td> <p>org/omg/CosNaming/Binding.java .</p> </td> </tr> <tr> <td><a href="bindinghelper.html">BindingHelper</a></td> <td> <p>org/omg/CosNaming/BindingHelper.java .</p> </td> </tr> <tr> <td><a href="bindingholder.html">BindingHolder</a></td> <td> <p>org/omg/CosNaming/BindingHolder.java .</p> </td> </tr> <tr> <td><a href="bindingiteratorhelper.html">BindingIteratorHelper</a></td> <td> <p>The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.</p> </td> </tr> <tr> <td><a href="bindingiteratorholder.html">BindingIteratorHolder</a></td> <td> <p>The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.</p> </td> </tr> <tr> <td><a href="bindingiteratorpoa.html">BindingIteratorPOA</a></td> <td> <p>The BindingIterator interface allows a client to iterate through the bindings using the next_one or next_n operations.</p> </td> </tr> <tr> <td><a href="bindinglisthelper.html">BindingListHelper</a></td> <td> <p>List of Bindings.</p> </td> </tr> <tr> <td><a href="bindinglistholder.html">BindingListHolder</a></td> <td> <p>List of Bindings.</p> </td> </tr> <tr> <td><a href="bindingtype.html">BindingType</a></td> <td> <p>Specifies whether the given binding is for a object (that is not a naming context) or for a naming context.</p> </td> </tr> <tr> <td><a href="bindingtypehelper.html">BindingTypeHelper</a></td> <td> <p>Specifies whether the given binding is for a object (that is not a naming context) or for a naming context.</p> </td> </tr> <tr> <td><a href="bindingtypeholder.html">BindingTypeHolder</a></td> <td> <p>Specifies whether the given binding is for a object (that is not a naming context) or for a naming context.</p> </td> </tr> <tr> <td><a href="istringhelper.html">IstringHelper</a></td> <td> <p>org/omg/CosNaming/IstringHelper.java .</p> </td> </tr> <tr> <td><a href="namecomponent.html">NameComponent</a></td> <td> <p>org/omg/CosNaming/NameComponent.java .</p> </td> </tr> <tr> <td><a href="namecomponenthelper.html">NameComponentHelper</a></td> <td> <p>org/omg/CosNaming/NameComponentHelper.java .</p> </td> </tr> <tr> <td><a href="namecomponentholder.html">NameComponentHolder</a></td> <td> <p>org/omg/CosNaming/NameComponentHolder.java .</p> </td> </tr> <tr> <td><a href="namehelper.html">NameHelper</a></td> <td> <p>A name is a sequence of name components.</p> </td> </tr> <tr> <td><a href="nameholder.html">NameHolder</a></td> <td> <p>A name is a sequence of name components.</p> </td> </tr> <tr> <td><a href="namingcontextexthelper.html">NamingContextExtHelper</a></td> <td> <p><code>NamingContextExt</code> is the extension of <code>NamingContext</code> which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.</p> </td> </tr> <tr> <td><a href="namingcontextextholder.html">NamingContextExtHolder</a></td> <td> <p><code>NamingContextExt</code> is the extension of <code>NamingContext</code> which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.</p> </td> </tr> <tr> <td><a href="namingcontextextpoa.html">NamingContextExtPOA</a></td> <td> <p><code>NamingContextExt</code> is the extension of <code>NamingContext</code> which contains a set of name bindings in which each name is unique and is part of Interoperable Naming Service.</p> </td> </tr> <tr> <td><a href="namingcontexthelper.html">NamingContextHelper</a></td> <td> <p>A naming context is an object that contains a set of name bindings in which each name is unique.</p> </td> </tr> <tr> <td><a href="namingcontextholder.html">NamingContextHolder</a></td> <td> <p>A naming context is an object that contains a set of name bindings in which each name is unique.</p> </td> </tr> <tr> <td><a href="namingcontextpoa.html">NamingContextPOA</a></td> <td> <p>A naming context is an object that contains a set of name bindings in which each name is unique.</p> </td> </tr>  </table>
  <h2 id="package.description">Package org.omg.CosNaming Description</h2> <div>
<p>Provides a naming service for Java IDL. The Object Request Broker Daemon (ORBD) also includes both a transient and persistent naming service. </p>
<p> The package and all its classes and interfaces were generated by running the tool <code>idlj</code> on the file <code>nameservice.idl</code>, which is a module written in OMG IDL. </p>
<h2>Package Specification</h2> <p>For a precise list of supported sections of official specifications with which the Java[tm] Platform, Standard Edition 6, ORB complies, see <a href="https://docs.oracle.com/javase/8/docs/api/org/omg/CORBA/doc-files/compliance.html">Official Specifications for CORBA support in Java[tm] SE 6</a>. </p>

<h2>Interfaces</h2> The package <code>org.omg.CosNaming</code> contains two public interfaces and several auxiliary classes. <p> The interfaces are: </p>
<ul> <li>
<code>NamingContext</code> </li>
<li>
<code>BindingIterator</code> </li>
</ul> <p> These two interfaces provide the means to bind/unbind names and object references, to retrieve bound object references, and to iterate through a list of bindings. The <code>NamingContext</code> interface supplies the main functionality for the naming service, and <code>BindingIterator</code> provides a means of iterating through a list of name/object reference bindings. </p>

<h2>Auxiliary Classes</h2> In order to map an OMG IDL interface to the Java programming language, the idlj compiler creates Java classes that can be thought of as auxiliary classes. Comments for the generated auxiliary classes used by the interfaces <code>NamingContext</code> and <code>BindingIterator</code> are included here. 
<h2>Classes Used by <code>NamingContext</code> and <code>BindingIterator</code>
</h2> The following are classes used by the naming service. (Helper and holder classes, which are generated for each of the classes listed here, are discussed below.) <ul> <li>
<code>public final class <b>NameComponent</b></code> -- a building block for names. (Names are bound to object references in a naming context.) <p>A name is an array of one or more <code>NameComponent</code> objects. A name with a single <code>NameComponent</code> is called a <i>simple name</i>; a name with multiple <code>NameComponent</code> objects is called a <i>compound name</i>. </p>
<p> A <code><b>NameComponent</b></code> object consists of two fields: </p>
<ol> <li>
<code><b>id</b></code> -- a <code>String</code> used as an identifier </li>
<li>
<code><b>kind</b></code> -- a <code>String</code> that can be used for any descriptive purpose. Its importance is that it can be used to describe an object without affecting syntax. The C programming language, for example, uses the the syntactic convention of appending the extension ".c" to a file name to indicate that it is a source code file. In a <code>NameComponent</code> object, the <code>kind</code> field can be used to describe the type of object rather than a file extension or some other syntactic convention. Examples of the value of the <code>kind</code> field include the strings <code>"c_source"</code>, <code>"object_code"</code>, <code>"executable"</code>, <code>"postscript"</code>, and <code>""</code>. It is not unusual for the <code>kind</code> field to be the empty string. </li>
</ol> <p> In a name, each <code>NameComponent</code> object except the last denotes a <code>NamingContext</code> object; the last <code>NameComponent</code> object denotes the bound object reference. This is similar to a path name, in which the last name is the file name, and all names before it are directory names.</p>


</li>
<li>
<code>public final class <b>Binding</b></code> -- an object that associates a name with an object reference or a naming context. A <code>Binding</code> object has two fields: <ol> <li>
<code><b>binding_name</b></code> - an array of one or more <code>NameComponent</code> objects that represents the bound name </li>
<li>
<code><b>binding_type</b></code> - a <code>BindingType</code> object indicating whether the binding is between a name and an object reference or between a name and a naming context </li>
</ol> <p> The interface <code>NamingContext</code> has methods for binding/unbinding names with object references or naming contexts, for listing bindings, and for resolving bindings (given a name, the method <code>resolve</code> returns the object reference bound to it). </p>

</li>
<li>
<code>public final class <b>BindingType</b></code> -- an object that specifies whether the given <code>Binding</code> object is a binding between a name and an object reference (that is, not a naming context) or between a name and a naming context. <p> The class<code>BindingType</code> consists of two methods and four constants. Two of these constants are <code>BindingType</code> objects, and two are <code>int</code>s. </p>
<p> The <code>BindingType</code> objects can be passed to the constructor for the class <code>Binding</code> or used as parameters or return values. These <code>BindingType</code> objects are: </p>
<ul> <li>
<code>public static final BindingType <b>nobject</b></code> -- to indicate that the binding is with an object reference </li>
<li>
<code>public static final BindingType <b>ncontext</b></code> -- to indicate that the binding is with a naming context </li>
</ul> <p> The <code>int</code> constants can be supplied to the method <code>from_int</code> to create <code>BindingType</code> objects, or they can be return values for the method <code>value</code>. These constants are: </p>
<ul> <li>
<code>public static final int <b>_nobject</b></code> </li>
<li>
<code>public static final int <b>_ncontext</b></code> </li>
</ul> If the method <code>from_int</code> is supplied with anything other than <code>_nobject</code> or <code>_ncontext</code>, it will throw the exception <code>org.omg.CORBA.BAD_PARAM</code>. <p>Usage is as follows: </p>
<pre data-language="java">BindingType btObject = from_int(_nobject);
       BindingType btContext = from_int(_ncontext);</pre> The variable <code>btObject</code> refers to a <code>BindingType</code> object initialized to represent a binding with an object reference. The variable <code>btContext</code> refers to a <code>BindingType</code> object initialized to represent a binding with a <code>NamingContex</code> object. <p> The method <code>value</code> returns either <code>_nobject</code> or <code>_ncontext</code>, so in the following line of code, the variable <code>bt</code> will contain <code>_nobject</code> or <code>_ncontext</code>: </p>
<pre data-language="java">int bt = BindingType.value();</pre> </li>
</ul> <h2>Holder Classes</h2> OMG IDL uses OUT and INOUT parameters for returning values from operations. The mapping to the Java programming language, which does not have OUT and INOUT parameters, creates a special class for each type, called a holder class. An instance of a holder class can be passed to a Java method as a parameter, and a value can be assigned to its <code>value</code> field. This allows it to perform the function of an OUT or INOUT parameter. <p>The following holder classes are generated for the package <code>org.omg.CosNaming</code>: </p>
<ul> <li>
<code>NamingContextHolder</code> </li>
<li>
<code>BindingIteratorHolder</code> </li>
<li>
<code>BindingHolder</code> </li>
<li>
<code>BindingListHolder</code> </li>
<li>
<code>BindingTypeHolder</code> </li>
<li>
<code>NameComponentHolder</code> </li>
<li>
<code>NameHolder</code> </li>
</ul> <p> Note that in the <code>org.omg.CORBA</code> package, there is a holder class for each of the basic Java types: <code>IntHolder</code>, <code>ShortHolder</code>, <code>StringHolder</code>, and so on. </p>
<p> Note also that there is a <code>NameHolder</code> class even though there is no <code>Name</code> class; similarly, there is a <code>BindingListHolder</code> class even though there is no <code>BindingList</code> class. This is true because in the OMG IDL interface, <code>Name</code> and <code>BindingList</code> are <code>typedef</code>s. There is no mapping from an IDL <code>typedef</code> to a Java construct, but holder classes are generated if the <code>typedef</code> is for a sequence or an array. As mapped to the Java programming language, <code>Name</code> is an array of <code>NameComponent</code> objects, and a <code>BindingList</code> is an array of <code>Binding</code> objects. All holder classes have at least two constructors and one field: </p>
<ul> <li>
<code><b>value</b></code> field -- an instance of the type being used as an OUT or INOUT parameter. For example, the <code>value</code> field of a <code>NamingContextHolder</code> will be a <code>NamingContext</code> object. </li>
<li>default constructor -- a constructor that creates a new holder object initialized with the default value for the type. For example, a new <code>BindingHolder</code> object created with the default constructor will have its <code>value</code> field set to <code>null</code> because that is the default value for an object. Other defaults are <code>false</code> for <code>boolean</code>, <code>0</code> for numeric and char types, and <code>null</code> for object references. </li>
<li>constructor from an instance -- a constructor that creates a new holder object whose <code>value</code> field is initialized with the instance supplied </li>
</ul> <p> A holder class for a user-defined type (a Java class) has three more methods, but application developers do not use them directly. </p>
<h2>Helper Classes</h2> Helper classes, which are generated for all user-defined types in an OMG IDL interface, supply static methods needed to manipulate those types. <p> There is only one method in a helper class that an application programmer uses: the method <code>narrow</code>. Only Java interfaces mapped from IDL interfaces will have a helper class that includes a <code>narrow</code> method, so in the <code>CosNaming</code> package, only the classes <code>NamingContextHelper</code> and <code>BindingIteratorHelper</code> have a <code>narrow</code> method. </p>
<ul> <li>
<code>public static NamingContext
  <b>narrow</b>(org.omg.CORBA.Object obj)</code> -- converts the given CORBA object to a <code>NamingContext</code> object </li>
<li>
<code>public static BindingIterator
  <b>narrow</b>(org.omg.CORBA.Object obj)</code> -- converts the given CORBA object to a <code>BindingIterator</code> object </li>
</ul> <h2>Package <code>org.omg.CosNaming.NamingContextPackage</code>
</h2> This package supplies Helper and Holder classes for the exceptions used in the package <code>org.omg.CosNaming</code> and also for the class <code>NotFoundReason</code>, which supplies a reason for the exception <code>NotFound</code>. <p> There are Helper and Holder classes for the following exceptions: </p>
<ul> <li>
<code>AlreadyBound</code> </li>
<li>
<code>CannotProceed</code> </li>
<li>
<code>InvalidName</code> </li>
<li>
<code>NotEmpty</code> </li>
<li>
<code>NotFound</code> </li>
</ul> <h2>Naming Service Compatibility</h2> Sun's implementation of the <code>CosNaming</code> package complies with the OMG <code>COSNaming</code> specification. In other words, the APIs in Sun's naming service are implemented according to the guidelines for a naming service provided by OMG. Therefore, if a third-party vendor has implemented a naming service that is OMG compliant, it is possible to switch between Sun's implementation of <code>CosNaming</code> and the third-party vendor's implementation. However, it is important to understand that there can be minor variations in the way different vendors implement the naming service, such as differences in the exception strings. <h2>Instructions for Using a Third Party's Naming Service</h2> Although we encourage using an ORB and ORB services that are both from one vendor, it is possible to plug in a third party's <code>COSNaming</code> implementation with Sun's RMI-IIOP ORB. Here are the steps to follow: <ol> <li>Create a properties file for the Bootstrap server and give it two entries. For example, you could call this properties file <code>/tmp/services</code> and put the following in it: <code>NameService, &lt;Stringified IOR of the Root Naming 
Context&gt;</code>. <p> This associates <code>NameService</code> with the Root Naming Context of the <code>CosNaming</code> implementation that you want to use. </p>

</li>
<li>Start the standalone Bootstrap server using the following command: <pre data-language="java">java -classpath $(CLASSPATH)
      com.sun.corba.ee.internal.CosNaming.BootstrapServer -InitialServicesFile
      "/tmp/services" [-ORBInitialPort port]</pre> <p> Note that the square brackets at the end of the command indicate that specifying a port number is optional. </p>
</li>
</ol> <p> Now when an application calls the method <code>org.omg.CORBA.ORB.resolve_initial_references</code>, CORBA processes will contact the Bootstrap Server to get the Root Naming Context. </p>
</div> <dl> <dt>Since:</dt> <dd>JDK1.3</dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/javase/8/docs/api/org/omg/CosNaming/package-summary.html" class="_attribution-link">https://docs.oracle.com/javase/8/docs/api/org/omg/CosNaming/package-summary.html</a>
  </p>
</div>
