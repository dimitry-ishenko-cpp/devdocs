<h1>Trait scala.concurrent.Future</h1>
<h3><span class="morelinks"><div>Companion <a href="future%24.html" title="See companion object">object Future</a>
</div></span></h3>
<h2 id="signature">
<span class="modifier_kind"> <span class="kind">trait</span></span> <span class="symbol"><span class="name">Future</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <a href="awaitable.html" name="scala.concurrent.Awaitable" id="scala.concurrent.Awaitable" class="extype">Awaitable</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]</span></span>
</h2>
<div id="comment" class="fullcommenttop">
<div class="comment cmt">
<p>A <code>Future</code> represents a value which may or may not *currently* be available, but will be available at some point, or an exception if that value could not be made available.</p>
<p> Asynchronous computations that yield futures are created with the <code>Future.apply</code> call and are computed using a supplied <code>ExecutionContext</code>, which can be backed by a Thread pool.</p>
<pre data-language="scala">import ExecutionContext.Implicits.global
val s = "Hello"
val f: Future[String] = Future {
  s + " future!"
}
f foreach {
  msg =&gt; println(msg)
}</pre>
</div>
<dl class="attributes block">
<dt>Source</dt>
<dd><a href="https://github.com/scala/scala/tree/v2.13.0/src/library/scala/concurrent/Future.scala#L99" target="_blank">Future.scala</a></dd>
<dt>See also</dt>
<dd><span class="cmt"><p><a href="http://docs.scala-lang.org/overviews/core/futures.html" target="_blank">Futures and Promises</a></p></span></dd>
<dt>Linear Supertypes</dt>
<dd>
<a href="awaitable.html" name="scala.concurrent.Awaitable" id="scala.concurrent.Awaitable" class="extype">Awaitable</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>], <a href="../anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
<dt>Known Subclasses</dt>
<dd><a href="future%24%24never%24.html" name="scala.concurrent.Future.never" id="scala.concurrent.Future.never" class="extype">never</a></dd>
</dl>


</div>
<div id="template"><div id="allMembers">
<div class="values members">
<h2>Abstract Value Members</h2>
<h3 id="isCompleted">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def </span></span><span class="symbol"><span class="name">isCompleted</span><span class="result">: <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Returns whether the future had already been completed with a value or an exception.</p>
<p> Note: using this method yields nondeterministic dataflow programs.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the future was completed, <code>false</code> otherwise</p></dd>
</dl>
</div>
<h3 id="onComplete">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def </span></span><span class="symbol"><span class="name">onComplete</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<a href="../util/try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]) =&gt; <span name="scala.concurrent.Future.onComplete.U" class="extype">U</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="../unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>When this future is completed, either through an exception, or a value, apply the provided function.</p>
<p> If the future has already been completed, this will either be applied immediately or be scheduled asynchronously.</p>
<p> Note that the returned value of <code>f</code> will be discarded.</p>
<p> Since this method executes asynchronously and does not produce a return value, any non-fatal exceptions thrown will be reported to the <code>ExecutionContext</code>.</p>
<p> Multiple callbacks may be registered; there is no guarantee that they will be executed in a particular order.</p>
<p>The provided callback always runs in the provided implicit <code>ExecutionContext</code>, though there is no guarantee that the <code>execute()</code> method on the <code>ExecutionContext</code> will be called once per callback or that <code>execute()</code> will be called in the current thread. That is, the implementation may run multiple callbacks in a batch within a single <code>execute()</code> and it may run <code>execute()</code> either immediately or asynchronously. Completion of the Future must *happen-before* the invocation of the callback. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>only used to accept any return type of the given callback function</p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>the function to be executed when this <code>Future</code> completes</p></dd>
</dl>
</div>
<h3 id="ready">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def </span></span><span class="symbol"><span class="name">ready</span><span class="params">(<span name="atMost">atMost: <a href="duration/duration.html" name="scala.concurrent.duration.Duration" id="scala.concurrent.duration.Duration" class="extype">Duration</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="permit">permit: <a href="canawait.html" name="scala.concurrent.CanAwait" id="scala.concurrent.CanAwait" class="extype">CanAwait</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>.this.type</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Await the "completed" state of this <code>Awaitable</code>.</p>
<p><b><i>This method should not be called directly; use <a href="await%24.html#ready%5BT%5D(awaitable:scala.concurrent.Awaitable%5BT%5D,atMost:scala.concurrent.duration.Duration):awaitable.type" name="scala.concurrent.Await#ready" id="scala.concurrent.Await#ready" class="extmbr">Await.ready</a> instead.</i></b> </p>
</div>
<dl class="paramcmts block">
<dt class="param">atMost</dt>
<dd class="cmt"><p> maximum wait time, which may be negative (no waiting is done), <a href="duration/duration%24.html#Inf:scala.concurrent.duration.Duration.Infinite" name="scala.concurrent.duration.Duration#Inf" id="scala.concurrent.duration.Duration#Inf" class="extmbr">Duration.Inf</a> for unbounded waiting, or a finite positive duration</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>this <code>Awaitable</code></p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd><a href="awaitable.html" name="scala.concurrent.Awaitable" id="scala.concurrent.Awaitable" class="extype">Awaitable</a></dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="symbol">classOf[TimeoutException]</span></span>)</span> <span class="name">@<a href="../throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="symbol">classOf[InterruptedException]</span></span>)</span> </dd>
<dt>Exceptions thrown</dt>
<dd>
<span class="cmt"><p><a href="../index.html#IllegalArgumentException=IllegalArgumentException" name="scala.IllegalArgumentException" id="scala.IllegalArgumentException" class="extmbr"><code>IllegalArgumentException</code></a> if <code>atMost</code> is <a href="duration/duration%24.html#Undefined:scala.concurrent.duration.Duration.Infinite" name="scala.concurrent.duration.Duration#Undefined" id="scala.concurrent.duration.Duration#Undefined" class="extmbr">Duration.Undefined</a></p></span><span class="cmt"><p><a href="../index.html#InterruptedException=InterruptedException" name="scala.InterruptedException" id="scala.InterruptedException" class="extmbr"><code>InterruptedException</code></a> if the current thread is interrupted while waiting</p></span><span class="cmt"><p><a href="index.html#TimeoutException=java.util.concurrent.TimeoutException" name="scala.concurrent.TimeoutException" id="scala.concurrent.TimeoutException" class="extmbr"><code>TimeoutException</code></a> if after waiting for the specified time this <code>Awaitable</code> is still not ready</p></span>
</dd>
</dl>
</div>
<h3 id="result">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def </span></span><span class="symbol"><span class="name">result</span><span class="params">(<span name="atMost">atMost: <a href="duration/duration.html" name="scala.concurrent.duration.Duration" id="scala.concurrent.duration.Duration" class="extype">Duration</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="permit">permit: <a href="canawait.html" name="scala.concurrent.CanAwait" id="scala.concurrent.CanAwait" class="extype">CanAwait</a></span>)</span><span class="result">: <span name="scala.concurrent.Future.T" class="extype">T</span></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Await and return the result (of type <code>T</code>) of this <code>Awaitable</code>.</p>
<p><b><i>This method should not be called directly; use <a href="await%24.html#result%5BT%5D(awaitable:scala.concurrent.Awaitable%5BT%5D,atMost:scala.concurrent.duration.Duration):T" name="scala.concurrent.Await#result" id="scala.concurrent.Await#result" class="extmbr">Await.result</a> instead.</i></b> </p>
</div>
<dl class="paramcmts block">
<dt class="param">atMost</dt>
<dd class="cmt"><p> maximum wait time, which may be negative (no waiting is done), <a href="duration/duration%24.html#Inf:scala.concurrent.duration.Duration.Infinite" name="scala.concurrent.duration.Duration#Inf" id="scala.concurrent.duration.Duration#Inf" class="extmbr">Duration.Inf</a> for unbounded waiting, or a finite positive duration</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the result value if the <code>Awaitable</code> is completed within the specific maximum wait time</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd><a href="awaitable.html" name="scala.concurrent.Awaitable" id="scala.concurrent.Awaitable" class="extype">Awaitable</a></dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="symbol">classOf[Exception]</span></span>)</span> </dd>
<dt>Exceptions thrown</dt>
<dd>
<span class="cmt"><p><a href="../index.html#IllegalArgumentException=IllegalArgumentException" name="scala.IllegalArgumentException" id="scala.IllegalArgumentException" class="extmbr"><code>IllegalArgumentException</code></a> if <code>atMost</code> is <a href="duration/duration%24.html#Undefined:scala.concurrent.duration.Duration.Infinite" name="scala.concurrent.duration.Duration#Undefined" id="scala.concurrent.duration.Duration#Undefined" class="extmbr">Duration.Undefined</a></p></span><span class="cmt"><p><a href="../index.html#InterruptedException=InterruptedException" name="scala.InterruptedException" id="scala.InterruptedException" class="extmbr"><code>InterruptedException</code></a> if the current thread is interrupted while waiting</p></span><span class="cmt"><p><a href="index.html#TimeoutException=java.util.concurrent.TimeoutException" name="scala.concurrent.TimeoutException" id="scala.concurrent.TimeoutException" class="extmbr"><code>TimeoutException</code></a> if after waiting for the specified time this <code>Awaitable</code> is still not ready</p></span>
</dd>
</dl>
</div>
<h3 id="transform">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def </span></span><span class="symbol"><span class="name">transform</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="f">f: (<a href="../util/try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]) =&gt; <a href="../util/try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="scala.concurrent.Future.transform.S" class="extype">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.transform.S" class="extype">S</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Creates a new Future by applying the specified function to the result of this Future. If there is any non-fatal exception thrown when 'f' is applied then that exception will be propagated to the resulting future. </p></div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of the returned <code>Future</code></p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>function that transforms the result of this future</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> that will be completed with the transformed value</p></dd>
</dl>
</div>
<h3 id="transformWith">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def </span></span><span class="symbol"><span class="name">transformWith</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="f">f: (<a href="../util/try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]) =&gt; <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.transformWith.S" class="extype">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.transformWith.S" class="extype">S</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Creates a new Future by applying the specified function, which produces a Future, to the result of this Future. If there is any non-fatal exception thrown when 'f' is applied then that exception will be propagated to the resulting future. </p></div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of the returned <code>Future</code></p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>function that transforms the result of this future</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> that will be completed with the transformed value</p></dd>
</dl>
</div>
<h3 id="value">
<span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def </span></span><span class="symbol"><span class="name">value</span><span class="result">: <a href="../option.html" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="../util/try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>The current value of this <code>Future</code>.</p>
<p> Note: using this method yields nondeterministic dataflow programs.</p>
<p> If the future was not completed the returned value will be <code>None</code>. If the future was completed the value will be <code>Some(Success(t))</code> if it contained a valid result, or <code>Some(Failure(error))</code> if it contained an exception. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>None</code> if the <code>Future</code> wasn't completed, <code>Some</code> if it was.</p></dd>
</dl>
</div>
</div>
<div class="values members">
<h2>Concrete Value Members</h2>
<h3 id="!=">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Test two objects for inequality. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if !(this == that), false otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>
</div>
<h3 id="">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <a href="../int.html" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Equivalent to <code>x.hashCode</code> except for boxed numeric types and <code>null</code>. For numerics, it returns a hash value which is consistent with value equality: if two value type instances compare as true, then ## will produce the same hash value for each of them. For <code>null</code> returns a hashcode where <code>null.hashCode</code> throws a <code>NullPointerException</code>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a hash value consistent with ==</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>
</div>
<h3 id="+">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="implicit" title="gt4s: $plus">+</span><span class="params">(<span name="other">other: <a href="../predef%24.html#String=String" name="scala.Predef.String" id="scala.Predef.String" class="extmbr">String</a></span>)</span><span class="result">: <a href="../predef%24.html#String=String" name="scala.Predef.String" id="scala.Predef.String" class="extmbr">String</a></span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt class="implicit">Implicit</dt>
<dd>This member is added by an implicit conversion from <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>] to<a href="../predef%24%24any2stringadd.html" name="scala.Predef.any2stringadd" id="scala.Predef.any2stringadd" class="extype">any2stringadd</a>[<a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]] performed by method any2stringadd in <a href="../predef%24.html" name="scala.Predef" id="scala.Predef" class="extype">scala.Predef</a>.</dd>
<dt>Definition Classes</dt>
<dd><a href="../predef%24%24any2stringadd.html" name="scala.Predef.any2stringadd" id="scala.Predef.any2stringadd" class="extype">any2stringadd</a></dd>
</dl></div>
<h3 id="-&gt;">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="implicit" title="gt4s: $minus$greater">-&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span></span>)</span><span class="result">: (<a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>], <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span>)</span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt class="implicit">Implicit</dt>
<dd>This member is added by an implicit conversion from <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>] to<a href="../predef%24%24arrowassoc.html" name="scala.Predef.ArrowAssoc" id="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</a>[<a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]] performed by method ArrowAssoc in <a href="../predef%24.html" name="scala.Predef" id="scala.Predef" class="extype">scala.Predef</a>.</dd>
<dt>Definition Classes</dt>
<dd><a href="../predef%24%24arrowassoc.html" name="scala.Predef.ArrowAssoc" id="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</a></dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../inline.html" name="scala.inline" id="scala.inline" class="extype">inline</a></span><span class="args">()</span> </dd>
</dl></div>
<h3 id="==">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>The expression <code>x == that</code> is equivalent to <code>if (x eq null) that eq null else x.equals(that)</code>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>
</div>
<h3 id="andThen">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">andThen</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="pf">pf: <a href="../partialfunction.html" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<a href="../util/try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>], <span name="scala.concurrent.Future.andThen.U" class="extype">U</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Applies the side-effecting function to the result of this future, and returns a new future with the result of this future.</p>
<p> This method allows one to enforce that the callbacks are executed in a specified order.</p>
<p> Note that if one of the chained <code>andThen</code> callbacks throws an exception, that exception is not propagated to the subsequent <code>andThen</code> callbacks. Instead, the subsequent <code>andThen</code> callbacks are given the original value of this future.</p>
<p> The following example prints out <code>5</code>:</p>
<pre data-language="scala">val f = Future { 5 }
f andThen {
  case r =&gt; throw new RuntimeException("runtime exception")
} andThen {
  case Failure(t) =&gt; println(t)
  case Success(v) =&gt; println(v)
}</pre>
<p> Since this method executes asynchronously and does not produce a return value, any non-fatal exceptions thrown will be reported to the <code>ExecutionContext</code>.</p>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>only used to accept any return type of the given <code>PartialFunction</code></p></dd>
<dt class="param">pf</dt>
<dd class="cmt"><p>a <code>PartialFunction</code> which will be conditionally applied to the outcome of this <code>Future</code></p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> which will be completed with the exact same outcome as this <code>Future</code> but after the <code>PartialFunction</code> has been executed.</p></dd>
</dl>
</div>
<h3 id="asInstanceOf">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Cast the receiver object to be of type <code>T0</code>.</p>
<p> Note that the success of a cast at runtime is modulo Scala's erasure semantics. Therefore the expression <code>1.asInstanceOf[String]</code> will throw a <code>ClassCastException</code> at runtime, while the expression <code>List(1).asInstanceOf[List[String]]</code> will not. In the latter example, because the type argument is erased as part of compilation it is not possible to check whether the contents of the list are of the requested type. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the receiver object.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd><a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a></dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../index.html#ClassCastException=ClassCastException" name="scala.ClassCastException" id="scala.ClassCastException" class="extmbr"><code>ClassCastException</code></a> if the receiver object is not an instance of the erasure of type <code>T0</code>.</p></span></dd>
</dl>
</div>
<h3 id="clone">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="../anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Create a copy of the receiver object.</p>
<p> The default implementation of the <code>clone</code> method is platform dependent. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a copy of the receiver object.</p></dd>
</dl>
<dl class="attributes block">
<dt>Attributes</dt>
<dd>protected[<a href="../../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd>
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@<a href="../native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div>
<h3 id="collect">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">collect</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="pf">pf: <a href="../partialfunction.html" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>, <span name="scala.concurrent.Future.collect.S" class="extype">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.collect.S" class="extype">S</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Creates a new future by mapping the value of the current future, if the given partial function is defined at that value.</p>
<p> If the current future contains a value for which the partial function is defined, the new future will also hold that value. Otherwise, the resulting future will fail with a <code>NoSuchElementException</code>.</p>
<p> If the current future fails, then the resulting future also fails.</p>
<p> Example:</p>
<pre data-language="scala">val f = Future { -5 }
val g = f collect {
  case x if x &lt; 0 =&gt; -x
}
val h = f collect {
  case x if x &gt; 0 =&gt; x * 2
}
g foreach println // Eventually prints 5
Await.result(h, Duration.Zero) // throw a NoSuchElementException</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of the returned <code>Future</code></p></dd>
<dt class="param">pf</dt>
<dd class="cmt"><p>the <code>PartialFunction</code> to apply to the successful result of this <code>Future</code></p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> holding the result of application of the <code>PartialFunction</code> or a <code>NoSuchElementException</code></p></dd>
</dl>
</div>
<h3 id="ensuring">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]) =&gt; <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>, <span name="msg">msg: =&gt; <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]</span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt class="implicit">Implicit</dt>
<dd>This member is added by an implicit conversion from <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>] to<a href="../predef%24%24ensuring.html" name="scala.Predef.Ensuring" id="scala.Predef.Ensuring" class="extype">Ensuring</a>[<a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]] performed by method Ensuring in <a href="../predef%24.html" name="scala.Predef" id="scala.Predef" class="extype">scala.Predef</a>.</dd>
<dt>Definition Classes</dt>
<dd><a href="../predef%24%24ensuring.html" name="scala.Predef.Ensuring" id="scala.Predef.Ensuring" class="extype">Ensuring</a></dd>
</dl></div>
<h3 id="ensuring">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]) =&gt; <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]</span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt class="implicit">Implicit</dt>
<dd>This member is added by an implicit conversion from <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>] to<a href="../predef%24%24ensuring.html" name="scala.Predef.Ensuring" id="scala.Predef.Ensuring" class="extype">Ensuring</a>[<a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]] performed by method Ensuring in <a href="../predef%24.html" name="scala.Predef" id="scala.Predef" class="extype">scala.Predef</a>.</dd>
<dt>Definition Classes</dt>
<dd><a href="../predef%24%24ensuring.html" name="scala.Predef.Ensuring" id="scala.Predef.Ensuring" class="extype">Ensuring</a></dd>
</dl></div>
<h3 id="ensuring">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>, <span name="msg">msg: =&gt; <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]</span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt class="implicit">Implicit</dt>
<dd>This member is added by an implicit conversion from <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>] to<a href="../predef%24%24ensuring.html" name="scala.Predef.Ensuring" id="scala.Predef.Ensuring" class="extype">Ensuring</a>[<a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]] performed by method Ensuring in <a href="../predef%24.html" name="scala.Predef" id="scala.Predef" class="extype">scala.Predef</a>.</dd>
<dt>Definition Classes</dt>
<dd><a href="../predef%24%24ensuring.html" name="scala.Predef.Ensuring" id="scala.Predef.Ensuring" class="extype">Ensuring</a></dd>
</dl></div>
<h3 id="ensuring">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]</span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt class="implicit">Implicit</dt>
<dd>This member is added by an implicit conversion from <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>] to<a href="../predef%24%24ensuring.html" name="scala.Predef.Ensuring" id="scala.Predef.Ensuring" class="extype">Ensuring</a>[<a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]] performed by method Ensuring in <a href="../predef%24.html" name="scala.Predef" id="scala.Predef" class="extype">scala.Predef</a>.</dd>
<dt>Definition Classes</dt>
<dd><a href="../predef%24%24ensuring.html" name="scala.Predef.Ensuring" id="scala.Predef.Ensuring" class="extype">Ensuring</a></dd>
</dl></div>
<h3 id="eq">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="../anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether the argument (<code>that</code>) is a reference to the receiver object (<code>this</code>).</p>
<p> The <code>eq</code> method implements an <a href="http://en.wikipedia.org/wiki/Equivalence_relation" target="_blank">equivalence relation</a> on non-null instances of <code>AnyRef</code>, and has three additional properties:</p>
<ul>
It is consistent: for any non-null instances <code>x</code> and <code>y</code> of type <code>AnyRef</code>, multiple invocations of <code>x.eq(y)</code> consistently returns <code>true</code> or consistently returns <code>false</code>.For any non-null instance <code>x</code> of type <code>AnyRef</code>, <code>x.eq(null)</code> and <code>null.eq(x)</code> returns <code>false</code>.
<code>null.eq(null)</code> returns <code>true</code>.</ul>
<p> When overriding the <code>equals</code> or <code>hashCode</code> methods, it is important to ensure that their behavior is consistent with reference equality. Therefore, if two objects are references to each other (<code>o1 eq o2</code>), they should be equal to each other (<code>o1 == o2</code>) and they should hash to the same value (<code>o1.hashCode == o2.hashCode</code>). </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the argument is a reference to the receiver object; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
</dl>
</div>
<h3 id="equals">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a href="../anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>The equality method for reference types. Default implementation delegates to <code>eq</code>.</p>
<p> See also <code>equals</code> in <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">scala.Any</a>. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>
</div>
<h3 id="failed">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">failed</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="../index.html#Throwable=Throwable" name="scala.Throwable" id="scala.Throwable" class="extmbr">Throwable</a>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>The returned <code>Future</code> will be successfully completed with the <code>Throwable</code> of the original <code>Future</code> if the original <code>Future</code> fails.</p>
<p> If the original <code>Future</code> is successful, the returned <code>Future</code> is failed with a <code>NoSuchElementException</code>.</p>
<p> This future may contain a throwable object and this means that the future failed. Futures obtained through combinators have the same exception as the future they were obtained from. The following throwable objects are not contained in the future:</p>
<ul>

<code>Error</code> - fatal errors are not contained within futures
<code>InterruptedException</code> - not contained within futuresall <code>scala.util.control.ControlThrowable</code> except <code>NonLocalReturnControl</code> - not contained within futures</ul>
<p> Instead, the future is completed with a ExecutionException with one of the exceptions above as the cause. If a future is failed with a <code>scala.runtime.NonLocalReturnControl</code>, it is completed with a value from that throwable instead.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a failed projection of this <code>Future</code>.</p></dd>
</dl>
</div>
<h3 id="fallbackTo">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">fallbackTo</span><span class="tparams">[<span name="U">U &gt;: <span name="scala.concurrent.Future.T" class="extype">T</span></span>]</span><span class="params">(<span name="that">that: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.fallbackTo.U" class="extype">U</span>]</span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.fallbackTo.U" class="extype">U</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Creates a new future which holds the result of this future if it was completed successfully, or, if not, the result of the <code>that</code> future if <code>that</code> is completed successfully. If both futures are failed, the resulting future holds the throwable object of the first future.</p>
<p> Using this method will not cause concurrent programs to become nondeterministic.</p>
<p> Example:</p>
<pre data-language="scala">val f = Future { throw new RuntimeException("failed") }
val g = Future { 5 }
val h = f fallbackTo g
h foreach println // Eventually prints 5</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>the type of the other <code>Future</code> and the resulting <code>Future</code></p></dd>
<dt class="param">that</dt>
<dd class="cmt"><p>the <code>Future</code> whose result we want to use if this <code>Future</code> fails.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> with the successful result of this or that <code>Future</code> or the failure of this <code>Future</code> if both fail</p></dd>
</dl>
</div>
<h3 id="filter">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">filter</span><span class="params">(<span name="p">p: (<span name="scala.concurrent.Future.T" class="extype">T</span>) =&gt; <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Creates a new future by filtering the value of the current future with a predicate.</p>
<p> If the current future contains a value which satisfies the predicate, the new future will also hold that value. Otherwise, the resulting future will fail with a <code>NoSuchElementException</code>.</p>
<p> If the current future fails, then the resulting future also fails.</p>
<p> Example:</p>
<pre data-language="scala">val f = Future { 5 }
val g = f filter { _ % 2 == 1 }
val h = f filter { _ % 2 == 0 }
g foreach println // Eventually prints 5
Await.result(h, Duration.Zero) // throw a NoSuchElementException</pre>
</div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>the predicate to apply to the successful result of this <code>Future</code></p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> which will hold the successful result of this <code>Future</code> if it matches the predicate or a <code>NoSuchElementException</code></p></dd>
</dl>
</div>
<h3 id="finalize">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <a href="../unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Called by the garbage collector on the receiver object when there are no more references to the object.</p>
<p> The details of when and if the <code>finalize</code> method is invoked, as well as the interaction between <code>finalize</code> and non-local returns and exceptions, are all platform dependent. </p>
</div>
<dl class="attributes block">
<dt>Attributes</dt>
<dd>protected[<a href="../../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd>
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div>
<h3 id="flatMap">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">flatMap</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="f">f: (<span name="scala.concurrent.Future.T" class="extype">T</span>) =&gt; <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.flatMap.S" class="extype">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.flatMap.S" class="extype">S</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Creates a new future by applying a function to the successful result of this future, and returns the result of the function as the new future. If this future is completed with an exception then the new future will also contain this exception.</p>
<p> Example:</p>
<pre data-language="scala">val f = Future { 5 }
val g = Future { 3 }
val h = for {
  x: Int &lt;- f // returns Future(5)
  y: Int &lt;- g // returns Future(3)
} yield x + y</pre>
<p> is translated to:</p>
<pre data-language="scala">f flatMap { (x: Int) =&gt; g map { (y: Int) =&gt; x + y } }</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of the returned <code>Future</code></p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>the function which will be applied to the successful result of this <code>Future</code></p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> which will be completed with the result of the application of the function</p></dd>
</dl>
</div>
<h3 id="flatten">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">flatten</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="../%24less%24colon%24less.html" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>, <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.flatten.S" class="extype">S</span>]]</span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.flatten.S" class="extype">S</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Creates a new future with one level of nesting flattened, this method is equivalent to <code>flatMap(identity)</code>. </p></div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of the returned <code>Future</code></p></dd>
</dl>
</div>
<h3 id="foreach">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">foreach</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span name="scala.concurrent.Future.T" class="extype">T</span>) =&gt; <span name="scala.concurrent.Future.foreach.U" class="extype">U</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="../unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Asynchronously processes the value in the future once the value becomes available.</p>
<p> WARNING: Will not be called if this future is never completed or if it is completed with a failure.</p>
<p> Since this method executes asynchronously and does not produce a return value, any non-fatal exceptions thrown will be reported to the <code>ExecutionContext</code>.</p>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>only used to accept any return type of the given callback function</p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>the function which will be executed if this <code>Future</code> completes with a result, the return value of <code>f</code> will be discarded.</p></dd>
</dl>
</div>
<h3 id="formatted">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="implicit">formatted</span><span class="params">(<span name="fmtstr">fmtstr: <a href="../predef%24.html#String=String" name="scala.Predef.String" id="scala.Predef.String" class="extmbr">String</a></span>)</span><span class="result">: <a href="../predef%24.html#String=String" name="scala.Predef.String" id="scala.Predef.String" class="extmbr">String</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Returns string formatted according to given <code>format</code> string. Format strings are as for <code>String.format</code> (@see java.lang.String.format). </p></div>
<dl class="attributes block">
<dt class="implicit">Implicit</dt>
<dd>This member is added by an implicit conversion from <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>] to<a href="../predef%24%24stringformat.html" name="scala.Predef.StringFormat" id="scala.Predef.StringFormat" class="extype">StringFormat</a>[<a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]] performed by method StringFormat in <a href="../predef%24.html" name="scala.Predef" id="scala.Predef" class="extype">scala.Predef</a>.</dd>
<dt>Definition Classes</dt>
<dd><a href="../predef%24%24stringformat.html" name="scala.Predef.StringFormat" id="scala.Predef.StringFormat" class="extype">StringFormat</a></dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../inline.html" name="scala.inline" id="scala.inline" class="extype">inline</a></span><span class="args">()</span> </dd>
</dl>
</div>
<h3 id="getClass">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="java.lang.Class" class="extype">Class</span>[_ &lt;: <a href="../anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Returns the runtime class representation of the object. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a class object corresponding to the runtime type of the receiver.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
</dl>
</div>
<h3 id="hashCode">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <a href="../int.html" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>The hashCode method for reference types. See hashCode in <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">scala.Any</a>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the hash code value for this object.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
</dl>
</div>
<h3 id="isInstanceOf">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Test whether the dynamic type of the receiver object is <code>T0</code>.</p>
<p> Note that the result of the test is modulo Scala's erasure semantics. Therefore the expression <code>1.isInstanceOf[String]</code> will return <code>false</code>, while the expression <code>List(1).isInstanceOf[List[String]]</code> will return <code>true</code>. In the latter example, because the type argument is erased as part of compilation it is not possible to check whether the contents of the list are of the specified type. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the receiver object is an instance of erasure of type <code>T0</code>; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd><a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a></dd>
</dl>
</div>
<h3 id="map">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">map</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="f">f: (<span name="scala.concurrent.Future.T" class="extype">T</span>) =&gt; <span name="scala.concurrent.Future.map.S" class="extype">S</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.map.S" class="extype">S</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Creates a new future by applying a function to the successful result of this future. If this future is completed with an exception then the new future will also contain this exception.</p>
<p> Example:</p>
<pre data-language="scala">val f = Future { "The future" }
val g = f map { x: String =&gt; x + " is now!" }</pre>
<p> Note that a for comprehension involving a <code>Future</code> may expand to include a call to <code>map</code> and or <code>flatMap</code> and <code>withFilter</code>. See <a href="#flatMap%5BS%5D(f:T=&gt;scala.concurrent.Future%5BS%5D)(implicitexecutor:scala.concurrent.ExecutionContext):scala.concurrent.Future%5BS%5D" name="scala.concurrent.Future#flatMap" id="scala.concurrent.Future#flatMap" class="extmbr">scala.concurrent.Future#flatMap</a> for an example of such a comprehension.</p>
</div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of the returned <code>Future</code></p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>the function which will be applied to the successful result of this <code>Future</code></p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> which will be completed with the result of the application of the function</p></dd>
</dl>
</div>
<h3 id="mapTo">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">mapTo</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="tag">tag: <a href="../reflect/classtag.html" name="scala.reflect.ClassTag" id="scala.reflect.ClassTag" class="extype">ClassTag</a>[<span name="scala.concurrent.Future.mapTo.S" class="extype">S</span>]</span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.mapTo.S" class="extype">S</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Creates a new <code>Future[S]</code> which is completed with this <code>Future</code>'s result if that conforms to <code>S</code>'s erased type or a <code>ClassCastException</code> otherwise. </p></div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of the returned <code>Future</code></p></dd>
<dt class="param">tag</dt>
<dd class="cmt"><p>the <code>ClassTag</code> which will be used to cast the result of this <code>Future</code></p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> holding the casted result of this <code>Future</code> or a <code>ClassCastException</code> otherwise</p></dd>
</dl>
</div>
<h3 id="ne">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="../anyref.html" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Equivalent to <code>!(this eq that)</code>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the argument is not a reference to the receiver object; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
</dl>
</div>
<h3 id="notify">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <a href="../unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Wakes up a single thread that is waiting on the receiver object's monitor. </p></div>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div>
<h3 id="notifyAll">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="../unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Wakes up all threads that are waiting on the receiver object's monitor. </p></div>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div>
<h3 id="recover">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">recover</span><span class="tparams">[<span name="U">U &gt;: <span name="scala.concurrent.Future.T" class="extype">T</span></span>]</span><span class="params">(<span name="pf">pf: <a href="../partialfunction.html" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<a href="../index.html#Throwable=Throwable" name="scala.Throwable" id="scala.Throwable" class="extmbr">Throwable</a>, <span name="scala.concurrent.Future.recover.U" class="extype">U</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.recover.U" class="extype">U</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Creates a new future that will handle any matching throwable that this future might contain. If there is no match, or if this future contains a valid result then the new future will contain the same.</p>
<p> Example:</p>
<pre data-language="scala">Future (6 / 0) recover { case e: ArithmeticException =&gt; 0 } // result: 0
Future (6 / 0) recover { case e: NotFoundException   =&gt; 0 } // result: exception
Future (6 / 2) recover { case e: ArithmeticException =&gt; 0 } // result: 3</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>the type of the returned <code>Future</code></p></dd>
<dt class="param">pf</dt>
<dd class="cmt"><p>the <code>PartialFunction</code> to apply if this <code>Future</code> fails</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> with the successful value of this <code>Future</code> or the result of the <code>PartialFunction</code></p></dd>
</dl>
</div>
<h3 id="recoverWith">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">recoverWith</span><span class="tparams">[<span name="U">U &gt;: <span name="scala.concurrent.Future.T" class="extype">T</span></span>]</span><span class="params">(<span name="pf">pf: <a href="../partialfunction.html" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<a href="../index.html#Throwable=Throwable" name="scala.Throwable" id="scala.Throwable" class="extmbr">Throwable</a>, <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.recoverWith.U" class="extype">U</span>]]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.recoverWith.U" class="extype">U</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Creates a new future that will handle any matching throwable that this future might contain by assigning it a value of another future.</p>
<p> If there is no match, or if this future contains a valid result then the new future will contain the same result.</p>
<p> Example:</p>
<pre data-language="scala">val f = Future { Int.MaxValue }
Future (6 / 0) recoverWith { case e: ArithmeticException =&gt; f } // result: Int.MaxValue</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>the type of the returned <code>Future</code></p></dd>
<dt class="param">pf</dt>
<dd class="cmt"><p>the <code>PartialFunction</code> to apply if this <code>Future</code> fails</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> with the successful value of this <code>Future</code> or the outcome of the <code>Future</code> returned by the <code>PartialFunction</code></p></dd>
</dl>
</div>
<h3 id="synchronized">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
</dl></div>
<h3 id="toString">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Creates a String representation of this object. The default representation is platform dependent. On the java platform it is the concatenation of the class name, "@", and the object's hashcode in hexadecimal. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a String representation of the object.</p></dd>
</dl>
<dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef → <a href="../any.html" name="scala.Any" id="scala.Any" class="extype">Any</a>
</dd>
</dl>
</div>
<h3 id="transform">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">transform</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="s">s: (<span name="scala.concurrent.Future.T" class="extype">T</span>) =&gt; <span name="scala.concurrent.Future.transform.S" class="extype">S</span></span>, <span name="f">f: (<a href="../index.html#Throwable=Throwable" name="scala.Throwable" id="scala.Throwable" class="extmbr">Throwable</a>) =&gt; <a href="../index.html#Throwable=Throwable" name="scala.Throwable" id="scala.Throwable" class="extmbr">Throwable</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.transform.S" class="extype">S</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt"><p>Creates a new future by applying the 's' function to the successful result of this future, or the 'f' function to the failed result. If there is any non-fatal exception thrown when 's' or 'f' is applied, that exception will be propagated to the resulting future. </p></div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of the returned <code>Future</code></p></dd>
<dt class="param">s</dt>
<dd class="cmt"><p>function that transforms a successful result of the receiver into a successful result of the returned future</p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>function that transforms a failure of the receiver into a failure of the returned future</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> that will be completed with the transformed value</p></dd>
</dl>
</div>
<h3 id="wait">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <a href="../unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd>
</dl></div>
<h3 id="wait">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="../long.html" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="arg1">arg1: <a href="../int.html" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="../unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd>
</dl></div>
<h3 id="wait">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="../long.html" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="../unit.html" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span>
</h3>
   <div class="fullcomment"><dl class="attributes block">
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd>
<span class="name">@<a href="../throws.html" name="scala.throws" id="scala.throws" class="extype">throws</a></span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@<a href="../native.html" name="scala.native" id="scala.native" class="extype">native</a></span><span class="args">()</span> </dd>
</dl></div>
<h3 id="withFilter">
<span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def </span></span><span class="symbol"><span class="name">withFilter</span><span class="params">(<span name="p">p: (<span name="scala.concurrent.Future.T" class="extype">T</span>) =&gt; <a href="../boolean.html" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.T" class="extype">T</span>]</span></span>
</h3>
   <h3 id="zip">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">zip</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="that">that: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.zip.U" class="extype">U</span>]</span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[(<span name="scala.concurrent.Future.T" class="extype">T</span>, <span name="scala.concurrent.Future.zip.U" class="extype">U</span>)]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Zips the values of <code>this</code> and <code>that</code> future, and creates a new future holding the tuple of their results.</p>
<p> If <code>this</code> future fails, the resulting future is failed with the throwable stored in <code>this</code>. Otherwise, if <code>that</code> future fails, the resulting future is failed with the throwable stored in <code>that</code>. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>the type of the other <code>Future</code></p></dd>
<dt class="param">that</dt>
<dd class="cmt"><p>the other <code>Future</code></p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> with the results of both futures or the failure of the first of them that failed</p></dd>
</dl>
</div>
<h3 id="zipWith">
<span class="modifier_kind"> <span class="kind">def </span></span><span class="symbol"><span class="name">zipWith</span><span class="tparams">[<span name="U">U</span>, <span name="R">R</span>]</span><span class="params">(<span name="that">that: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.zipWith.U" class="extype">U</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="scala.concurrent.Future.T" class="extype">T</span>, <span name="scala.concurrent.Future.zipWith.U" class="extype">U</span>) =&gt; <span name="scala.concurrent.Future.zipWith.R" class="extype">R</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executor">executor: <a href="executioncontext.html" name="scala.concurrent.ExecutionContext" id="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</a></span>)</span><span class="result">: <a href="future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="scala.concurrent.Future.zipWith.R" class="extype">R</span>]</span></span>
</h3>
   <div class="fullcomment">
<div class="comment cmt">
<p>Zips the values of <code>this</code> and <code>that</code> future using a function <code>f</code>, and creates a new future holding the result.</p>
<p> If <code>this</code> future fails, the resulting future is failed with the throwable stored in <code>this</code>. Otherwise, if <code>that</code> future fails, the resulting future is failed with the throwable stored in <code>that</code>. If the application of <code>f</code> throws a throwable, the resulting future is failed with that throwable if it is non-fatal. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>the type of the other <code>Future</code></p></dd>
<dt class="tparam">R</dt>
<dd class="cmt"><p>the type of the resulting <code>Future</code></p></dd>
<dt class="param">that</dt>
<dd class="cmt"><p>the other <code>Future</code></p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>the function to apply to the results of <code>this</code> and <code>that</code></p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a <code>Future</code> with the result of the application of <code>f</code> to the results of <code>this</code> and <code>that</code></p></dd>
</dl>
</div>
</div>
</div></div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002-2019 EPFL, with contributions from Lightbend.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.scala-lang.org/api/2.13.0/scala/concurrent/Future.html" class="_attribution-link">https://www.scala-lang.org/api/2.13.0/scala/concurrent/Future.html</a>
  </p>
</div>
