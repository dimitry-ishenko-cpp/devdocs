<h1> Class NestIterator  </h1> <div class="description"> <p>A type of collection that is aware of nested items and exposes methods to check or retrieve them</p> </div> <div class="info"> <b>Namespace:</b> <a href="namespace-cake.collection.iterator.html">Cake\Collection\Iterator</a><br> </div> <div class="section"> <h2>Property Summary</h2> <ul class="member-summary properties"> <li class="clearfix"> <div class="name"> <a href="#%24_nestKey">$_nestKey</a> <span class="attributes"> <span class="label">protected</span> </span> </div> <div class="property-type"><code>callable|string</code></div> <div class="description"> <p>The name of the property that contains the nested items for each element</p> </div> </li> </ul> </div> <div class="section"> <h2>Method Summary</h2> <ul class="member-summary"> <li class="clearfix"> <h5 class="function-name"> <a href="#__construct()">__construct()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Constructor</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#__debugInfo()">__debugInfo()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns an array that can be used to describe the internal state of this object.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#__serialize()">__serialize()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns an array for serializing this of this object.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#__unserialize()">__unserialize()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Rebuilds the Collection instance.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_createMatcherFilter()">_createMatcherFilter()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Returns a callable that receives a value and will return whether it matches certain condition.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_extract()">_extract()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Returns a column from $data that can be extracted by iterating over the column names contained in $path. It will return arrays for elements in represented with <code>{*}</code></p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_propertyExtractor()">_propertyExtractor()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Returns a callable that can be used to extract a property or column from an array or object based on a dot separated path.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#_simpleExtract()">_simpleExtract()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Returns a column from $data that can be extracted by iterating over the column names contained in $path</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#append()">append()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection as the result of concatenating the list of elements in this collection with the passed list of elements</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#appendItem()">appendItem()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Append a single item creating a new collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#avg()">avg()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the average of all the values extracted with $path or of this collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#buffered()">buffered()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection where the operations performed by this collection. No matter how many times the new collection is iterated, those operations will only be performed once.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#cartesianProduct()">cartesianProduct()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Create a new collection that is the cartesian product of the current collection</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#chunk()">chunk()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Breaks the collection into smaller arrays of the given size.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#chunkWithKeys()">chunkWithKeys()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Breaks the collection into smaller arrays of the given size.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#combine()">combine()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection where the values extracted based on a value path and then indexed by a key path. Optionally this method can produce parent groups based on a group property path.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#compile()">compile()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Iterates once all elements in this collection and executes all stacked operations of them, finally it returns a new collection with the result. This is useful for converting non-rewindable internal iterators into a collection that can be rewound and used multiple times.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#contains()">contains()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns true if $value is present in this collection. Comparisons are made both by value and type.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#count()">count()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the amount of elements in the collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#countBy()">countBy()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sorts a list into groups and returns a count for the number of elements in each group. Similar to groupBy, but instead of returning a list of values, returns a count for the number of values in that group.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#countKeys()">countKeys()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the number of unique keys in this iterator. This is the same as the number of elements the collection will contain after calling <code>toArray()</code></p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#each()">each()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Applies a callback to the elements in this collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#every()">every()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns true if all values in this collection pass the truth test provided in the callback.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#extract()">extract()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection containing the column or property value found in each of the elements.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#filter()">filter()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Looks through each value in the collection, and returns another collection with all the values that pass a truth test. Only the values for which the callback returns true will be present in the resulting collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#first()">first()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the first result in this collection</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#firstMatch()">firstMatch()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the first result matching all the key-value pairs listed in conditions.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getChildren()">getChildren()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a traversable containing the children for the current item</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#groupBy()">groupBy()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Splits a collection into sets, grouped by the result of running each value through the callback. If $callback is a string instead of a callable, groups by the property named by $callback on each of the values.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#hasChildren()">hasChildren()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns true if there is an array or a traversable object stored under the configured nestKey for the current item</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#indexBy()">indexBy()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Given a list and a callback function that returns a key for each element in the list (or a property name), returns an object with an index of each item. Just like groupBy, but for when you know your keys are unique.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#insert()">insert()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection containing each of the elements found in <code>$values</code> as a property inside the corresponding elements in this collection. The property where the values will be inserted is described by the <code>$path</code> parameter.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#isEmpty()">isEmpty()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns whether there are elements in this collection</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#jsonSerialize()">jsonSerialize()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the data that can be converted to JSON. This returns the same data as <code>toArray()</code> which contains only unique keys.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#last()">last()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the last result in this collection</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#lazy()">lazy()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection where any operations chained after it are guaranteed to be run lazily. That is, elements will be yieleded one at a time.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#listNested()">listNested()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection with each of the elements of this collection after flattening the tree structure. The tree structure is defined by nesting elements under a key with a known name. It is possible to specify such name by using the '$nestingKey' parameter.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#map()">map()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns another collection after modifying each of the values in this one using the provided callable.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#match()">match()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Looks through each value in the list, returning a Collection of all the values that contain all of the key-value pairs listed in $conditions.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#max()">max()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the top element in this collection after being sorted by a property. Check the sortBy method for information on the callback and $sort parameters</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#median()">median()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the median of all the values extracted with $path or of this collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#min()">min()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the bottom element in this collection after being sorted by a property. Check the sortBy method for information on the callback and $sort parameters</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#nest()">nest()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection where the values are nested in a tree-like structure based on an id property path and a parent id property path.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#newCollection()">newCollection()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Returns a new collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#optimizeUnwrap()">optimizeUnwrap()</a> <span class="label">protected</span> </h5> <div class="description detailed"> <p>Unwraps this iterator and returns the simplest traversable that can be used for getting the data out</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#prepend()">prepend()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Prepend a set of items to a collection creating a new collection</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#prependItem()">prependItem()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Prepend a single item creating a new collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#reduce()">reduce()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Folds the values in this collection to a single value, as the result of applying the callback function to all elements. $zero is the initial state of the reduction, and each successive step of it should be returned by the callback function. If $zero is omitted the first value of the collection will be used in its place and reduction will start from the second item.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#reject()">reject()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Looks through each value in the collection, and returns another collection with all the values that do not pass a truth test. This is the opposite of <code>filter</code>.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#sample()">sample()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection with maximum $size random elements from this collection</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#serialize()">serialize()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a string representation of this object that can be used to reconstruct it</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#shuffle()">shuffle()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection with the elements placed in a random order, this function does not preserve the original keys in the collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#skip()">skip()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection that will skip the specified amount of elements at the beginning of the iteration.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#some()">some()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns true if any of the values in this collection pass the truth test provided in the callback.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#sortBy()">sortBy()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a sorted iterator out of the elements in this collection, ranked in ascending order by the results of running each value through a callback. $callback can also be a string representing the column or property name.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#stopWhen()">stopWhen()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Creates a new collection that when iterated will stop yielding results if the provided condition evaluates to true.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#sumOf()">sumOf()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the total sum of all the values extracted with $matcher or of this collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#take()">take()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a new collection with maximum $size elements in the internal order this collection was created. If a second parameter is passed, it will determine from what position to start taking elements.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#takeLast()">takeLast()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the last N elements of a collection</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#through()">through()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Passes this collection through a callable as its first argument. This is useful for decorating the full collection with another object.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#toArray()">toArray()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns an array representation of the results</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#toList()">toList()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns an numerically-indexed array representation of the results. This is equivalent to calling <code>toArray(false)</code></p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#transpose()">transpose()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Transpose rows and columns into columns and rows</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#unfold()">unfold()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Creates a new collection where the items are the concatenation of the lists of items generated by the transformer function applied to each item in the original collection.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#unserialize()">unserialize()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Unserializes the passed string and rebuilds the Collection instance</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#unwrap()">unwrap()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the closest nested iterator that can be safely traversed without losing any possible transformations. This is used mainly to remove empty IteratorIterator wrappers that can only slowdown the iteration process.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#zip()">zip()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Combines the elements of this collection with each of the elements of the passed iterables, using their positional index as a reference.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#zipWith()">zipWith()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Combines the elements of this collection with each of the elements of the passed iterables, using their positional index as a reference.</p> </div> </li> </ul> <div class="section"> <h2>Method Detail</h2> <div class="method-detail">  <h3 class="method-name" id="__construct()"> __construct()   <span class="label">public</span> </h3> <pre data-language="php">__construct(iterable $items, callable|string $nestKey)</pre> <div class="description detailed"> <p>Constructor</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>iterable</code> <var>$items</var> </dt> <dd><p>Collection items.</p></dd> <dt> <code>callable|string</code> <var>$nestKey</var> </dt> <dd><p>the property that contains the nested items If a callable is passed, it should return the childrens for the passed item</p></dd> </dl> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="__debugInfo()"> __debugInfo()   <span class="label">public</span> </h3> <pre data-language="php">__debugInfo(): array&lt;string, mixed&gt;</pre> <div class="description detailed"> <p>Returns an array that can be used to describe the internal state of this object.</p> <h4>Returns</h4> <div class="list"> <code>array&lt;string, mixed&gt;</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="__serialize()"> __serialize()   <span class="label">public</span> </h3> <pre data-language="php">__serialize(): array</pre> <div class="description detailed"> <p>Returns an array for serializing this of this object.</p> <h4>Returns</h4> <div class="list"> <code>array</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="__unserialize()"> __unserialize()   <span class="label">public</span> </h3> <pre data-language="php">__unserialize(array $data): void</pre> <div class="description detailed"> <p>Rebuilds the Collection instance.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array</code> <var>$data</var> </dt> <dd><p>Data array.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>void</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_createMatcherFilter()"> _createMatcherFilter()   <span class="label">protected</span> </h3> <pre data-language="php">_createMatcherFilter(array $conditions): Closure</pre> <div class="description detailed"> <p>Returns a callable that receives a value and will return whether it matches certain condition.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array</code> <var>$conditions</var> </dt> <dd><p>A key-value list of conditions to match where the key is the property path to get from the current item and the value is the value to be compared the item with.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>Closure</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_extract()"> _extract()   <span class="label">protected</span> </h3> <pre data-language="php">_extract(ArrayAccess|array $data, array&lt;string&gt; $parts): mixed</pre> <div class="description detailed"> <p>Returns a column from $data that can be extracted by iterating over the column names contained in $path. It will return arrays for elements in represented with <code>{*}</code></p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>ArrayAccess|array</code> <var>$data</var> </dt> <dd><p>Data.</p></dd> <dt> <code>array&lt;string&gt;</code> <var>$parts</var> </dt> <dd><p>Path to extract from.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>mixed</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_propertyExtractor()"> _propertyExtractor()   <span class="label">protected</span> </h3> <pre data-language="php">_propertyExtractor(callable|string $path): callable</pre> <div class="description detailed"> <p>Returns a callable that can be used to extract a property or column from an array or object based on a dot separated path.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string</code> <var>$path</var> </dt> <dd><p>A dot separated path of column to follow so that the final one can be returned or a callable that will take care of doing that.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>callable</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="_simpleExtract()"> _simpleExtract()   <span class="label">protected</span> </h3> <pre data-language="php">_simpleExtract(ArrayAccess|array $data, array&lt;string&gt; $parts): mixed</pre> <div class="description detailed"> <p>Returns a column from $data that can be extracted by iterating over the column names contained in $path</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>ArrayAccess|array</code> <var>$data</var> </dt> <dd><p>Data.</p></dd> <dt> <code>array&lt;string&gt;</code> <var>$parts</var> </dt> <dd><p>Path to extract from.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>mixed</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="append()"> append()   <span class="label">public</span> </h3> <pre data-language="php">append(iterable $items): self</pre> <div class="description detailed"> <p>Returns a new collection as the result of concatenating the list of elements in this collection with the passed list of elements</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>iterable</code> <var>$items</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="appendItem()"> appendItem()   <span class="label">public</span> </h3> <pre data-language="php">appendItem(mixed $item, mixed $key = null): self</pre> <div class="description detailed"> <p>Append a single item creating a new collection.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>mixed</code> <var>$item</var> </dt>  <dt> <code>mixed</code> <var>$key</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="avg()"> avg()   <span class="label">public</span> </h3> <pre data-language="php">avg(callable|string|null $path = null): float|int|null</pre> <div class="description detailed"> <p>Returns the average of all the values extracted with $path or of this collection.</p> <h3>Example:</h3> <pre data-language="php">$items = [
 ['invoice' =&gt; ['total' =&gt; 100]],
 ['invoice' =&gt; ['total' =&gt; 200]]
];

$total = (new Collection($items))-&gt;avg('invoice.total');

// Total: 150

$total = (new Collection([1, 2, 3]))-&gt;avg();
// Total: 2</pre> <p>The average of an empty set or 0 rows is <code>null</code>. Collections with <code>null</code> values are not considered empty.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string|null</code> <var>$path</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>float|int|null</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="buffered()"> buffered()   <span class="label">public</span> </h3> <pre data-language="php">buffered(): self</pre> <div class="description detailed"> <p>Returns a new collection where the operations performed by this collection. No matter how many times the new collection is iterated, those operations will only be performed once.</p> <p>This can also be used to make any non-rewindable iterator rewindable.</p> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="cartesianProduct()"> cartesianProduct()   <span class="label">public</span> </h3> <pre data-language="php">cartesianProduct(callable|null $operation = null, callable|null $filter = null): Cake\Collection\CollectionInterface</pre> <div class="description detailed"> <p>Create a new collection that is the cartesian product of the current collection</p> <p>In order to create a carteisan product a collection must contain a single dimension of data.</p> <h3>Example</h3> <pre data-language="php">$collection = new Collection([['A', 'B', 'C'], [1, 2, 3]]);
$result = $collection-&gt;cartesianProduct()-&gt;toArray();
$expected = [
    ['A', 1],
    ['A', 2],
    ['A', 3],
    ['B', 1],
    ['B', 2],
    ['B', 3],
    ['C', 1],
    ['C', 2],
    ['C', 3],
];</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|null</code> <var>$operation</var> <span class="label">optional</span> </dt> <dd><p>A callable that allows you to customize the product result.</p></dd> <dt> <code>callable|null</code> <var>$filter</var> <span class="label">optional</span> </dt> <dd><p>A filtering callback that must return true for a result to be part of the final results.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>Cake\Collection\CollectionInterface</code><br> </div> <h4>Throws</h4> <div class="list"> <code>LogicException</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="chunk()"> chunk()   <span class="label">public</span> </h3> <pre data-language="php">chunk(int $chunkSize): self</pre> <div class="description detailed"> <p>Breaks the collection into smaller arrays of the given size.</p> <h3>Example:</h3> <pre data-language="php">$items [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
$chunked = (new Collection($items))-&gt;chunk(3)-&gt;toList();
// Returns [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11]]</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>int</code> <var>$chunkSize</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="chunkWithKeys()"> chunkWithKeys()   <span class="label">public</span> </h3> <pre data-language="php">chunkWithKeys(int $chunkSize, bool $keepKeys = true): self</pre> <div class="description detailed"> <p>Breaks the collection into smaller arrays of the given size.</p> <h3>Example:</h3> <pre data-language="php">$items ['a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 3, 'd' =&gt; 4, 'e' =&gt; 5, 'f' =&gt; 6];
$chunked = (new Collection($items))-&gt;chunkWithKeys(3)-&gt;toList();
// Returns [['a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 3], ['d' =&gt; 4, 'e' =&gt; 5, 'f' =&gt; 6]]</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>int</code> <var>$chunkSize</var> </dt>  <dt> <code>bool</code> <var>$keepKeys</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="combine()"> combine()   <span class="label">public</span> </h3> <pre data-language="php">combine(callable|string $keyPath, callable|string $valuePath, callable|string|null $groupPath = null): self</pre> <div class="description detailed"> <p>Returns a new collection where the values extracted based on a value path and then indexed by a key path. Optionally this method can produce parent groups based on a group property path.</p> <h3>Examples:</h3> <pre data-language="php">$items = [
 ['id' =&gt; 1, 'name' =&gt; 'foo', 'parent' =&gt; 'a'],
 ['id' =&gt; 2, 'name' =&gt; 'bar', 'parent' =&gt; 'b'],
 ['id' =&gt; 3, 'name' =&gt; 'baz', 'parent' =&gt; 'a'],
];

$combined = (new Collection($items))-&gt;combine('id', 'name');

// Result will look like this when converted to array
[
 1 =&gt; 'foo',
 2 =&gt; 'bar',
 3 =&gt; 'baz',
];

$combined = (new Collection($items))-&gt;combine('id', 'name', 'parent');

// Result will look like this when converted to array
[
 'a' =&gt; [1 =&gt; 'foo', 3 =&gt; 'baz'],
 'b' =&gt; [2 =&gt; 'bar']
];</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string</code> <var>$keyPath</var> </dt>  <dt> <code>callable|string</code> <var>$valuePath</var> </dt>  <dt> <code>callable|string|null</code> <var>$groupPath</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="compile()"> compile()   <span class="label">public</span> </h3> <pre data-language="php">compile(bool $keepKeys = true): self</pre> <div class="description detailed"> <p>Iterates once all elements in this collection and executes all stacked operations of them, finally it returns a new collection with the result. This is useful for converting non-rewindable internal iterators into a collection that can be rewound and used multiple times.</p> <p>A common use case is to re-use the same variable for calculating different data. In those cases it may be helpful and more performant to first compile a collection and then apply more operations to it.</p> <h3>Example:</h3> <pre data-language="php">$collection-&gt;map($mapper)-&gt;sortBy('age')-&gt;extract('name');
$compiled = $collection-&gt;compile();
$isJohnHere = $compiled-&gt;some($johnMatcher);
$allButJohn = $compiled-&gt;filter($johnMatcher);</pre> <p>In the above example, had the collection not been compiled before, the iterations for <code>map</code>, <code>sortBy</code> and <code>extract</code> would've been executed twice: once for getting <code>$isJohnHere</code> and once for <code>$allButJohn</code></p> <p>You can think of this method as a way to create save points for complex calculations in a collection.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>bool</code> <var>$keepKeys</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="contains()"> contains()   <span class="label">public</span> </h3> <pre data-language="php">contains(mixed $value): bool</pre> <div class="description detailed"> <p>Returns true if $value is present in this collection. Comparisons are made both by value and type.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>mixed</code> <var>$value</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="count()"> count()   <span class="label">public</span> </h3> <pre data-language="php">count(): int</pre> <div class="description detailed"> <p>Returns the amount of elements in the collection.</p> <h2>WARNINGS:</h2> <h3>Will change the current position of the iterator:</h3> <p>Calling this method at the same time that you are iterating this collections, for example in a foreach, will result in undefined behavior. Avoid doing this.</p> <h3>Consumes all elements for NoRewindIterator collections:</h3> <p>On certain type of collections, calling this method may render unusable afterwards. That is, you may not be able to get elements out of it, or to iterate on it anymore.</p> <p>Specifically any collection wrapping a Generator (a function with a yield statement) or a unbuffered database cursor will not accept any other function calls after calling <code>count()</code> on it.</p> <p>Create a new collection with <code>buffered()</code> method to overcome this problem.</p> <h3>Can report more elements than unique keys:</h3> <p>Any collection constructed by appending collections together, or by having internal iterators returning duplicate keys, will report a larger amount of elements using this functions than the final amount of elements when converting the collections to a keyed array. This is because duplicate keys will be collapsed into a single one in the final array, whereas this count method is only concerned by the amount of elements after converting it to a plain list.</p> <p>If you need the count of elements after taking the keys in consideration (the count of unique keys), you can call <code>countKeys()</code></p> <h4>Returns</h4> <div class="list"> <code>int</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="countBy()"> countBy()   <span class="label">public</span> </h3> <pre data-language="php">countBy(callable|string $path): self</pre> <div class="description detailed"> <p>Sorts a list into groups and returns a count for the number of elements in each group. Similar to groupBy, but instead of returning a list of values, returns a count for the number of values in that group.</p> <p>When $callback is a string it should be a property name to extract or a dot separated path of properties that should be followed to get the last one in the path.</p> <h3>Example:</h3> <pre data-language="php">$items = [
 ['id' =&gt; 1, 'name' =&gt; 'foo', 'parent_id' =&gt; 10],
 ['id' =&gt; 2, 'name' =&gt; 'bar', 'parent_id' =&gt; 11],
 ['id' =&gt; 3, 'name' =&gt; 'baz', 'parent_id' =&gt; 10],
];

$group = (new Collection($items))-&gt;countBy('parent_id');

// Or
$group = (new Collection($items))-&gt;countBy(function ($e) {
 return $e['parent_id'];
});

// Result will look like this when converted to array
[
 10 =&gt; 2,
 11 =&gt; 1
];</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string</code> <var>$path</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="countKeys()"> countKeys()   <span class="label">public</span> </h3> <pre data-language="php">countKeys(): int</pre> <div class="description detailed"> <p>Returns the number of unique keys in this iterator. This is the same as the number of elements the collection will contain after calling <code>toArray()</code></p> <p>This method comes with a number of caveats. Please refer to <code>CollectionInterface::count()</code> for details.</p> <h4>Returns</h4> <div class="list"> <code>int</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="each()"> each()   <span class="label">public</span> </h3> <pre data-language="php">each(callable $callback): $this</pre> <div class="description detailed"> <p>Applies a callback to the elements in this collection.</p> <h3>Example:</h3> <pre data-language="php">$collection = (new Collection($items))-&gt;each(function ($value, $key) {
 echo "Element $key: $value";
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable</code> <var>$callback</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="every()"> every()   <span class="label">public</span> </h3> <pre data-language="php">every(callable $callback): bool</pre> <div class="description detailed"> <p>Returns true if all values in this collection pass the truth test provided in the callback.</p> <p>The callback is passed the value and key of the element being tested and should return true if the test passed.</p> <h3>Example:</h3> <pre data-language="php">$overTwentyOne = (new Collection([24, 45, 60, 15]))-&gt;every(function ($value, $key) {
 return $value &gt; 21;
});</pre> <p>Empty collections always return true.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable</code> <var>$callback</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="extract()"> extract()   <span class="label">public</span> </h3> <pre data-language="php">extract(callable|string $path): self</pre> <div class="description detailed"> <p>Returns a new collection containing the column or property value found in each of the elements.</p> <p>The matcher can be a string with a property name to extract or a dot separated path of properties that should be followed to get the last one in the path.</p> <p>If a column or property could not be found for a particular element in the collection, that position is filled with null.</p> <h3>Example:</h3> <p>Extract the user name for all comments in the array:</p> <pre data-language="php">$items = [
 ['comment' =&gt; ['body' =&gt; 'cool', 'user' =&gt; ['name' =&gt; 'Mark']],
 ['comment' =&gt; ['body' =&gt; 'very cool', 'user' =&gt; ['name' =&gt; 'Renan']]
];
$extracted = (new Collection($items))-&gt;extract('comment.user.name');

// Result will look like this when converted to array
['Mark', 'Renan']</pre> <p>It is also possible to extract a flattened collection out of nested properties</p> <pre data-language="php">$items = [
     ['comment' =&gt; ['votes' =&gt; [['value' =&gt; 1], ['value' =&gt; 2], ['value' =&gt; 3]]],
     ['comment' =&gt; ['votes' =&gt; [['value' =&gt; 4]]
];
$extracted = (new Collection($items))-&gt;extract('comment.votes.{*}.value');

// Result will contain
[1, 2, 3, 4]</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string</code> <var>$path</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="filter()"> filter()   <span class="label">public</span> </h3> <pre data-language="php">filter(callable|null $callback = null): self</pre> <div class="description detailed"> <p>Looks through each value in the collection, and returns another collection with all the values that pass a truth test. Only the values for which the callback returns true will be present in the resulting collection.</p> <p>Each time the callback is executed it will receive the value of the element in the current iteration, the key of the element and this collection as arguments, in that order.</p> <h3>Example:</h3> <p>Filtering odd numbers in an array, at the end only the value 2 will be present in the resulting collection:</p> <pre data-language="php">$collection = (new Collection([1, 2, 3]))-&gt;filter(function ($value, $key) {
 return $value % 2 === 0;
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|null</code> <var>$callback</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="first()"> first()   <span class="label">public</span> </h3> <pre data-language="php">first(): mixed</pre> <div class="description detailed"> <p>Returns the first result in this collection</p> <h4>Returns</h4> <div class="list"> <code>mixed</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="firstMatch()"> firstMatch()   <span class="label">public</span> </h3> <pre data-language="php">firstMatch(array $conditions): mixed</pre> <div class="description detailed"> <p>Returns the first result matching all the key-value pairs listed in conditions.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array</code> <var>$conditions</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>mixed</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getChildren()"> getChildren()   <span class="label">public</span> </h3> <pre data-language="php">getChildren(): RecursiveIterator</pre> <div class="description detailed"> <p>Returns a traversable containing the children for the current item</p> <h4>Returns</h4> <div class="list"> <code>RecursiveIterator</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="groupBy()"> groupBy()   <span class="label">public</span> </h3> <pre data-language="php">groupBy(callable|string $path): self</pre> <div class="description detailed"> <p>Splits a collection into sets, grouped by the result of running each value through the callback. If $callback is a string instead of a callable, groups by the property named by $callback on each of the values.</p> <p>When $callback is a string it should be a property name to extract or a dot separated path of properties that should be followed to get the last one in the path.</p> <h3>Example:</h3> <pre data-language="php">$items = [
 ['id' =&gt; 1, 'name' =&gt; 'foo', 'parent_id' =&gt; 10],
 ['id' =&gt; 2, 'name' =&gt; 'bar', 'parent_id' =&gt; 11],
 ['id' =&gt; 3, 'name' =&gt; 'baz', 'parent_id' =&gt; 10],
];

$group = (new Collection($items))-&gt;groupBy('parent_id');

// Or
$group = (new Collection($items))-&gt;groupBy(function ($e) {
 return $e['parent_id'];
});

// Result will look like this when converted to array
[
 10 =&gt; [
     ['id' =&gt; 1, 'name' =&gt; 'foo', 'parent_id' =&gt; 10],
     ['id' =&gt; 3, 'name' =&gt; 'baz', 'parent_id' =&gt; 10],
 ],
 11 =&gt; [
     ['id' =&gt; 2, 'name' =&gt; 'bar', 'parent_id' =&gt; 11],
 ]
];</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string</code> <var>$path</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="hasChildren()"> hasChildren()   <span class="label">public</span> </h3> <pre data-language="php">hasChildren(): bool</pre> <div class="description detailed"> <p>Returns true if there is an array or a traversable object stored under the configured nestKey for the current item</p> <h4>Returns</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="indexBy()"> indexBy()   <span class="label">public</span> </h3> <pre data-language="php">indexBy(callable|string $path): self</pre> <div class="description detailed"> <p>Given a list and a callback function that returns a key for each element in the list (or a property name), returns an object with an index of each item. Just like groupBy, but for when you know your keys are unique.</p> <p>When $callback is a string it should be a property name to extract or a dot separated path of properties that should be followed to get the last one in the path.</p> <h3>Example:</h3> <pre data-language="php">$items = [
 ['id' =&gt; 1, 'name' =&gt; 'foo'],
 ['id' =&gt; 2, 'name' =&gt; 'bar'],
 ['id' =&gt; 3, 'name' =&gt; 'baz'],
];

$indexed = (new Collection($items))-&gt;indexBy('id');

// Or
$indexed = (new Collection($items))-&gt;indexBy(function ($e) {
 return $e['id'];
});

// Result will look like this when converted to array
[
 1 =&gt; ['id' =&gt; 1, 'name' =&gt; 'foo'],
 3 =&gt; ['id' =&gt; 3, 'name' =&gt; 'baz'],
 2 =&gt; ['id' =&gt; 2, 'name' =&gt; 'bar'],
];</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string</code> <var>$path</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="insert()"> insert()   <span class="label">public</span> </h3> <pre data-language="php">insert(string $path, mixed $values): self</pre> <div class="description detailed"> <p>Returns a new collection containing each of the elements found in <code>$values</code> as a property inside the corresponding elements in this collection. The property where the values will be inserted is described by the <code>$path</code> parameter.</p> <p>The $path can be a string with a property name or a dot separated path of properties that should be followed to get the last one in the path.</p> <p>If a column or property could not be found for a particular element in the collection as part of the path, the element will be kept unchanged.</p> <h3>Example:</h3> <p>Insert ages into a collection containing users:</p> <pre data-language="php">$items = [
 ['comment' =&gt; ['body' =&gt; 'cool', 'user' =&gt; ['name' =&gt; 'Mark']],
 ['comment' =&gt; ['body' =&gt; 'awesome', 'user' =&gt; ['name' =&gt; 'Renan']]
];
$ages = [25, 28];
$inserted = (new Collection($items))-&gt;insert('comment.user.age', $ages);

// Result will look like this when converted to array
[
 ['comment' =&gt; ['body' =&gt; 'cool', 'user' =&gt; ['name' =&gt; 'Mark', 'age' =&gt; 25]],
 ['comment' =&gt; ['body' =&gt; 'awesome', 'user' =&gt; ['name' =&gt; 'Renan', 'age' =&gt; 28]]
];</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$path</var> </dt>  <dt> <code>mixed</code> <var>$values</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="isEmpty()"> isEmpty()   <span class="label">public</span> </h3> <pre data-language="php">isEmpty(): bool</pre> <div class="description detailed"> <p>Returns whether there are elements in this collection</p> <h3>Example:</h3> <pre data-language="php">$items [1, 2, 3];
(new Collection($items))-&gt;isEmpty(); // false</pre> <pre data-language="php">(new Collection([]))-&gt;isEmpty(); // true</pre> <h4>Returns</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="jsonSerialize()"> jsonSerialize()   <span class="label">public</span> </h3> <pre data-language="php">jsonSerialize(): array</pre> <div class="description detailed"> <p>Returns the data that can be converted to JSON. This returns the same data as <code>toArray()</code> which contains only unique keys.</p> <p>Part of JsonSerializable interface.</p> <h4>Returns</h4> <div class="list"> <code>array</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="last()"> last()   <span class="label">public</span> </h3> <pre data-language="php">last(): mixed</pre> <div class="description detailed"> <p>Returns the last result in this collection</p> <h4>Returns</h4> <div class="list"> <code>mixed</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="lazy()"> lazy()   <span class="label">public</span> </h3> <pre data-language="php">lazy(): self</pre> <div class="description detailed"> <p>Returns a new collection where any operations chained after it are guaranteed to be run lazily. That is, elements will be yieleded one at a time.</p> <p>A lazy collection can only be iterated once. A second attempt results in an error.</p> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="listNested()"> listNested()   <span class="label">public</span> </h3> <pre data-language="php">listNested(string|int $order = 'desc', callable|string $nestingKey = 'children'): self</pre> <div class="description detailed"> <p>Returns a new collection with each of the elements of this collection after flattening the tree structure. The tree structure is defined by nesting elements under a key with a known name. It is possible to specify such name by using the '$nestingKey' parameter.</p> <p>By default all elements in the tree following a Depth First Search will be returned, that is, elements from the top parent to the leaves for each branch.</p> <p>It is possible to return all elements from bottom to top using a Breadth First Search approach by passing the '$dir' parameter with 'asc'. That is, it will return all elements for the same tree depth first and from bottom to top.</p> <p>Finally, you can specify to only get a collection with the leaf nodes in the tree structure. You do so by passing 'leaves' in the first argument.</p> <p>The possible values for the first argument are aliases for the following constants and it is valid to pass those instead of the alias:</p> <ul> <li>desc: RecursiveIteratorIterator::SELF_FIRST</li> <li>asc: RecursiveIteratorIterator::CHILD_FIRST</li> <li>leaves: RecursiveIteratorIterator::LEAVES_ONLY</li> </ul> <h3>Example:</h3> <pre data-language="php">$collection = new Collection([
 ['id' =&gt; 1, 'children' =&gt; [['id' =&gt; 2, 'children' =&gt; [['id' =&gt; 3]]]]],
 ['id' =&gt; 4, 'children' =&gt; [['id' =&gt; 5]]]
]);
$flattenedIds = $collection-&gt;listNested()-&gt;extract('id'); // Yields [1, 2, 3, 4, 5]</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string|int</code> <var>$order</var> <span class="label">optional</span> </dt>  <dt> <code>callable|string</code> <var>$nestingKey</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="map()"> map()   <span class="label">public</span> </h3> <pre data-language="php">map(callable $callback): self</pre> <div class="description detailed"> <p>Returns another collection after modifying each of the values in this one using the provided callable.</p> <p>Each time the callback is executed it will receive the value of the element in the current iteration, the key of the element and this collection as arguments, in that order.</p> <h3>Example:</h3> <p>Getting a collection of booleans where true indicates if a person is female:</p> <pre data-language="php">$collection = (new Collection($people))-&gt;map(function ($person, $key) {
 return $person-&gt;gender === 'female';
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable</code> <var>$callback</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="match()"> match()   <span class="label">public</span> </h3> <pre data-language="php">match(array $conditions): self</pre> <div class="description detailed"> <p>Looks through each value in the list, returning a Collection of all the values that contain all of the key-value pairs listed in $conditions.</p> <h3>Example:</h3> <pre data-language="php">$items = [
 ['comment' =&gt; ['body' =&gt; 'cool', 'user' =&gt; ['name' =&gt; 'Mark']],
 ['comment' =&gt; ['body' =&gt; 'very cool', 'user' =&gt; ['name' =&gt; 'Renan']]
];

$extracted = (new Collection($items))-&gt;match(['user.name' =&gt; 'Renan']);

// Result will look like this when converted to array
[
 ['comment' =&gt; ['body' =&gt; 'very cool', 'user' =&gt; ['name' =&gt; 'Renan']]
]</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array</code> <var>$conditions</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="max()"> max()   <span class="label">public</span> </h3> <pre data-language="php">max(callable|string $path, int $sort = \SORT_NUMERIC): mixed</pre> <div class="description detailed"> <p>Returns the top element in this collection after being sorted by a property. Check the sortBy method for information on the callback and $sort parameters</p> <h3>Examples:</h3> <pre data-language="php">// For a collection of employees
$max = $collection-&gt;max('age');
$max = $collection-&gt;max('user.salary');
$max = $collection-&gt;max(function ($e) {
 return $e-&gt;get('user')-&gt;get('salary');
});

// Display employee name
echo $max-&gt;name;</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string</code> <var>$path</var> </dt>  <dt> <code>int</code> <var>$sort</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>mixed</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="median()"> median()   <span class="label">public</span> </h3> <pre data-language="php">median(callable|string|null $path = null): float|int|null</pre> <div class="description detailed"> <p>Returns the median of all the values extracted with $path or of this collection.</p> <h3>Example:</h3> <pre data-language="php">$items = [
 ['invoice' =&gt; ['total' =&gt; 400]],
 ['invoice' =&gt; ['total' =&gt; 500]]
 ['invoice' =&gt; ['total' =&gt; 100]]
 ['invoice' =&gt; ['total' =&gt; 333]]
 ['invoice' =&gt; ['total' =&gt; 200]]
];

$total = (new Collection($items))-&gt;median('invoice.total');

// Total: 333

$total = (new Collection([1, 2, 3, 4]))-&gt;median();
// Total: 2.5</pre> <p>The median of an empty set or 0 rows is <code>null</code>. Collections with <code>null</code> values are not considered empty.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string|null</code> <var>$path</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>float|int|null</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="min()"> min()   <span class="label">public</span> </h3> <pre data-language="php">min(callable|string $path, int $sort = \SORT_NUMERIC): mixed</pre> <div class="description detailed"> <p>Returns the bottom element in this collection after being sorted by a property. Check the sortBy method for information on the callback and $sort parameters</p> <h3>Examples:</h3> <pre data-language="php">// For a collection of employees
$min = $collection-&gt;min('age');
$min = $collection-&gt;min('user.salary');
$min = $collection-&gt;min(function ($e) {
 return $e-&gt;get('user')-&gt;get('salary');
});

// Display employee name
echo $min-&gt;name;</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string</code> <var>$path</var> </dt>  <dt> <code>int</code> <var>$sort</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>mixed</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="nest()"> nest()   <span class="label">public</span> </h3> <pre data-language="php">nest(callable|string $idPath, callable|string $parentPath, string $nestingKey = 'children'): self</pre> <div class="description detailed"> <p>Returns a new collection where the values are nested in a tree-like structure based on an id property path and a parent id property path.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string</code> <var>$idPath</var> </dt>  <dt> <code>callable|string</code> <var>$parentPath</var> </dt>  <dt> <code>string</code> <var>$nestingKey</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="newCollection()"> newCollection()   <span class="label">protected</span> </h3> <pre data-language="php">newCollection(mixed ...$args): Cake\Collection\CollectionInterface</pre> <div class="description detailed"> <p>Returns a new collection.</p> <p>Allows classes which use this trait to determine their own type of returned collection interface</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>mixed</code> ...<var>$args</var> </dt> <dd><p>Constructor arguments.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>Cake\Collection\CollectionInterface</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="optimizeUnwrap()"> optimizeUnwrap()   <span class="label">protected</span> </h3> <pre data-language="php">optimizeUnwrap(): iterable</pre> <div class="description detailed"> <p>Unwraps this iterator and returns the simplest traversable that can be used for getting the data out</p> <h4>Returns</h4> <div class="list"> <code>iterable</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="prepend()"> prepend()   <span class="label">public</span> </h3> <pre data-language="php">prepend(mixed $items): self</pre> <div class="description detailed"> <p>Prepend a set of items to a collection creating a new collection</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>mixed</code> <var>$items</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="prependItem()"> prependItem()   <span class="label">public</span> </h3> <pre data-language="php">prependItem(mixed $item, mixed $key = null): self</pre> <div class="description detailed"> <p>Prepend a single item creating a new collection.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>mixed</code> <var>$item</var> </dt>  <dt> <code>mixed</code> <var>$key</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="reduce()"> reduce()   <span class="label">public</span> </h3> <pre data-language="php">reduce(callable $callback, mixed $initial = null): mixed</pre> <div class="description detailed"> <p>Folds the values in this collection to a single value, as the result of applying the callback function to all elements. $zero is the initial state of the reduction, and each successive step of it should be returned by the callback function. If $zero is omitted the first value of the collection will be used in its place and reduction will start from the second item.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable</code> <var>$callback</var> </dt>  <dt> <code>mixed</code> <var>$initial</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>mixed</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="reject()"> reject()   <span class="label">public</span> </h3> <pre data-language="php">reject(callable $callback): self</pre> <div class="description detailed"> <p>Looks through each value in the collection, and returns another collection with all the values that do not pass a truth test. This is the opposite of <code>filter</code>.</p> <p>Each time the callback is executed it will receive the value of the element in the current iteration, the key of the element and this collection as arguments, in that order.</p> <h3>Example:</h3> <p>Filtering even numbers in an array, at the end only values 1 and 3 will be present in the resulting collection:</p> <pre data-language="php">$collection = (new Collection([1, 2, 3]))-&gt;reject(function ($value, $key) {
 return $value % 2 === 0;
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable</code> <var>$callback</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="sample()"> sample()   <span class="label">public</span> </h3> <pre data-language="php">sample(int $length = 10): self</pre> <div class="description detailed"> <p>Returns a new collection with maximum $size random elements from this collection</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>int</code> <var>$length</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="serialize()"> serialize()   <span class="label">public</span> </h3> <pre data-language="php">serialize(): string</pre> <div class="description detailed"> <p>Returns a string representation of this object that can be used to reconstruct it</p> <h4>Returns</h4> <div class="list"> <code>string</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="shuffle()"> shuffle()   <span class="label">public</span> </h3> <pre data-language="php">shuffle(): self</pre> <div class="description detailed"> <p>Returns a new collection with the elements placed in a random order, this function does not preserve the original keys in the collection.</p> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="skip()"> skip()   <span class="label">public</span> </h3> <pre data-language="php">skip(int $length): self</pre> <div class="description detailed"> <p>Returns a new collection that will skip the specified amount of elements at the beginning of the iteration.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>int</code> <var>$length</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="some()"> some()   <span class="label">public</span> </h3> <pre data-language="php">some(callable $callback): bool</pre> <div class="description detailed"> <p>Returns true if any of the values in this collection pass the truth test provided in the callback.</p> <p>The callback is passed the value and key of the element being tested and should return true if the test passed.</p> <h3>Example:</h3> <pre data-language="php">$hasYoungPeople = (new Collection([24, 45, 15]))-&gt;some(function ($value, $key) {
 return $value &lt; 21;
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable</code> <var>$callback</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>bool</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="sortBy()"> sortBy()   <span class="label">public</span> </h3> <pre data-language="php">sortBy(callable|string $path, int $order = \SORT_DESC, int $sort = \SORT_NUMERIC): self</pre> <div class="description detailed"> <p>Returns a sorted iterator out of the elements in this collection, ranked in ascending order by the results of running each value through a callback. $callback can also be a string representing the column or property name.</p> <p>The callback will receive as its first argument each of the elements in $items, the value returned by the callback will be used as the value for sorting such element. Please note that the callback function could be called more than once per element.</p> <h3>Example:</h3> <pre data-language="php">$items = $collection-&gt;sortBy(function ($user) {
 return $user-&gt;age;
});

// alternatively
$items = $collection-&gt;sortBy('age');

// or use a property path
$items = $collection-&gt;sortBy('department.name');

// output all user name order by their age in descending order
foreach ($items as $user) {
 echo $user-&gt;name;
}</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string</code> <var>$path</var> </dt>  <dt> <code>int</code> <var>$order</var> <span class="label">optional</span> </dt>  <dt> <code>int</code> <var>$sort</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="stopWhen()"> stopWhen()   <span class="label">public</span> </h3> <pre data-language="php">stopWhen(callable|array $condition): self</pre> <div class="description detailed"> <p>Creates a new collection that when iterated will stop yielding results if the provided condition evaluates to true.</p> <p>This is handy for dealing with infinite iterators or any generator that could start returning invalid elements at a certain point. For example, when reading lines from a file stream you may want to stop the iteration after a certain value is reached.</p> <h3>Example:</h3> <p>Get an array of lines in a CSV file until the timestamp column is less than a date</p> <pre data-language="php">$lines = (new Collection($fileLines))-&gt;stopWhen(function ($value, $key) {
 return (new DateTime($value))-&gt;format('Y') &lt; 2012;
})
-&gt;toArray();</pre> <p>Get elements until the first unapproved message is found:</p> <pre data-language="php">$comments = (new Collection($comments))-&gt;stopWhen(['is_approved' =&gt; false]);</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|array</code> <var>$condition</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="sumOf()"> sumOf()   <span class="label">public</span> </h3> <pre data-language="php">sumOf(callable|string|null $path = null): float|int</pre> <div class="description detailed"> <p>Returns the total sum of all the values extracted with $matcher or of this collection.</p> <h3>Example:</h3> <pre data-language="php">$items = [
 ['invoice' =&gt; ['total' =&gt; 100]],
 ['invoice' =&gt; ['total' =&gt; 200]]
];

$total = (new Collection($items))-&gt;sumOf('invoice.total');

// Total: 300

$total = (new Collection([1, 2, 3]))-&gt;sumOf();
// Total: 6</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|string|null</code> <var>$path</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>float|int</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="take()"> take()   <span class="label">public</span> </h3> <pre data-language="php">take(int $length = 1, int $offset = 0): self</pre> <div class="description detailed"> <p>Returns a new collection with maximum $size elements in the internal order this collection was created. If a second parameter is passed, it will determine from what position to start taking elements.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>int</code> <var>$length</var> <span class="label">optional</span> </dt>  <dt> <code>int</code> <var>$offset</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="takeLast()"> takeLast()   <span class="label">public</span> </h3> <pre data-language="php">takeLast(int $length): self</pre> <div class="description detailed"> <p>Returns the last N elements of a collection</p> <h3>Example:</h3> <pre data-language="php">$items = [1, 2, 3, 4, 5];

$last = (new Collection($items))-&gt;takeLast(3);

// Result will look like this when converted to array
[3, 4, 5];</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>int</code> <var>$length</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="through()"> through()   <span class="label">public</span> </h3> <pre data-language="php">through(callable $callback): self</pre> <div class="description detailed"> <p>Passes this collection through a callable as its first argument. This is useful for decorating the full collection with another object.</p> <h3>Example:</h3> <pre data-language="php">$items = [1, 2, 3];
$decorated = (new Collection($items))-&gt;through(function ($collection) {
     return new MyCustomCollection($collection);
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable</code> <var>$callback</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="toArray()"> toArray()   <span class="label">public</span> </h3> <pre data-language="php">toArray(bool $keepKeys = true): array</pre> <div class="description detailed"> <p>Returns an array representation of the results</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>bool</code> <var>$keepKeys</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>array</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="toList()"> toList()   <span class="label">public</span> </h3> <pre data-language="php">toList(): array</pre> <div class="description detailed"> <p>Returns an numerically-indexed array representation of the results. This is equivalent to calling <code>toArray(false)</code></p> <h4>Returns</h4> <div class="list"> <code>array</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="transpose()"> transpose()   <span class="label">public</span> </h3> <pre data-language="php">transpose(): Cake\Collection\CollectionInterface</pre> <div class="description detailed"> <p>Transpose rows and columns into columns and rows</p> <h3>Example:</h3> <pre data-language="php">$items = [
      ['Products', '2012', '2013', '2014'],
      ['Product A', '200', '100', '50'],
      ['Product B', '300', '200', '100'],
      ['Product C', '400', '300', '200'],
]

$transpose = (new Collection($items))-&gt;transpose()-&gt;toList();

// Returns
// [
//     ['Products', 'Product A', 'Product B', 'Product C'],
//     ['2012', '200', '300', '400'],
//     ['2013', '100', '200', '300'],
//     ['2014', '50', '100', '200'],
// ]</pre> <h4>Returns</h4> <div class="list"> <code>Cake\Collection\CollectionInterface</code><br> </div> <h4>Throws</h4> <div class="list"> <code>LogicException</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="unfold()"> unfold()   <span class="label">public</span> </h3> <pre data-language="php">unfold(callable|null $callback = null): self</pre> <div class="description detailed"> <p>Creates a new collection where the items are the concatenation of the lists of items generated by the transformer function applied to each item in the original collection.</p> <p>The transformer function will receive the value and the key for each of the items in the collection, in that order, and it must return an array or a Traversable object that can be concatenated to the final result.</p> <p>If no transformer function is passed, an "identity" function will be used. This is useful when each of the elements in the source collection are lists of items to be appended one after another.</p> <h3>Example:</h3> <pre data-language="php">$items [[1, 2, 3], [4, 5]];
$unfold = (new Collection($items))-&gt;unfold(); // Returns [1, 2, 3, 4, 5]</pre> <p>Using a transformer</p> <pre data-language="php">$items [1, 2, 3];
$allItems = (new Collection($items))-&gt;unfold(function ($page) {
 return $service-&gt;fetchPage($page)-&gt;toArray();
});</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>callable|null</code> <var>$callback</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="unserialize()"> unserialize()   <span class="label">public</span> </h3> <pre data-language="php">unserialize(string $collection): void</pre> <div class="description detailed"> <p>Unserializes the passed string and rebuilds the Collection instance</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$collection</var> </dt> <dd><p>The serialized collection</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>void</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="unwrap()"> unwrap()   <span class="label">public</span> </h3> <pre data-language="php">unwrap(): Traversable</pre> <div class="description detailed"> <p>Returns the closest nested iterator that can be safely traversed without losing any possible transformations. This is used mainly to remove empty IteratorIterator wrappers that can only slowdown the iteration process.</p> <h4>Returns</h4> <div class="list"> <code>Traversable</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="zip()"> zip()   <span class="label">public</span> </h3> <pre data-language="php">zip(iterable $items): self</pre> <div class="description detailed"> <p>Combines the elements of this collection with each of the elements of the passed iterables, using their positional index as a reference.</p> <h3>Example:</h3> <pre data-language="php">$collection = new Collection([1, 2]);
$collection-&gt;zip([3, 4], [5, 6])-&gt;toList(); // returns [[1, 3, 5], [2, 4, 6]]</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>iterable</code> <var>$items</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="zipWith()"> zipWith()   <span class="label">public</span> </h3> <pre data-language="php">zipWith(iterable $items, callable $callback): self</pre> <div class="description detailed"> <p>Combines the elements of this collection with each of the elements of the passed iterables, using their positional index as a reference.</p> <p>The resulting element will be the return value of the $callable function.</p> <h3>Example:</h3> <pre data-language="php">$collection = new Collection([1, 2]);
$zipped = $collection-&gt;zipWith([3, 4], [5, 6], function (...$args) {
  return array_sum($args);
});
$zipped-&gt;toList(); // returns [9, 12]; [(1 + 3 + 5), (2 + 4 + 6)]</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>iterable</code> <var>$items</var> </dt>  <dt> <code>callable</code> <var>$callback</var> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>self</code><br> </div> </div> </div> </div> <div class="section"> <h2>Property Detail</h2> <div class="property-detail">  <h3 class="property-name" id="$_nestKey"> <var>$_nestKey</var>   <span class="label">protected</span> </h3> <div class="description detailed"> <p>The name of the property that contains the nested items for each element</p> <h4>Type</h4> <div class="list"> <code>callable|string</code><br> </div> </div> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;present The Cake Software Foundation, Inc.<br>Licensed under the MIT License.<br>CakePHP is a registered trademark of Cake Software Foundation, Inc.<br>We are not endorsed by or affiliated with CakePHP.<br>
    <a href="https://api.cakephp.org/4.4/class-Cake.Collection.Iterator.NestIterator.html" class="_attribution-link">https://api.cakephp.org/4.4/class-Cake.Collection.Iterator.NestIterator.html</a>
  </p>
</div>
