<h1> Interface QueryInterface  </h1> <div class="description"> <p>The basis for every query object</p> </div> <div class="info"> <b>Namespace:</b> <a href="namespace-cake.datasource.html">Cake\Datasource</a><br> </div> <div class="section"> <h2>Method Summary</h2> <ul class="member-summary"> <li class="clearfix"> <h5 class="function-name"> <a href="#aliasField()">aliasField()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns a key =&gt; value array representing a single aliased field that can be passed directly to the select() method. The key will contain the alias and the value the actual field name.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#aliasFields()">aliasFields()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Runs <code>aliasField()</code> for each field in the provided list and returns the result under a single array.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#all()">all()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Fetch the results for this query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#andWhere()">andWhere()</a> <span class="label">public</span> <span class="label annotation">@method</span> </h5> <div class="description detailed"> <p>Connects any previously defined set of conditions to the provided list using the AND operator. {@see \Cake\Database\Query::andWhere()}</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#applyOptions()">applyOptions()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Populates or adds parts to current query clauses using an array. This is handy for passing all query clauses at once. The option array accepts:</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#count()">count()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the total amount of results for the query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#find()">find()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Apply custom finds to against an existing query object.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#first()">first()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the first result out of executing this query, if the query has not been executed before, it will set the limit clause to 1 for performance reasons.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#firstOrFail()">firstOrFail()</a> <span class="label">public</span> <span class="label annotation">@method</span> </h5> <div class="description detailed"> <p>Get the first result from the executing query or raise an exception. {@see \Cake\Database\Query::firstOrFail()}</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#getRepository()">getRepository()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns the default repository object that will be used by this query, that is, the repository that will appear in the from clause.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#limit()">limit()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sets the number of records that should be retrieved from database, accepts an integer or an expression object that evaluates to an integer. In some databases, this operation might not be supported or will require the query to be transformed in order to limit the result set size.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#offset()">offset()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Sets the number of records that should be skipped from the original result set This is commonly used for paginating large results. Accepts an integer or an expression object that evaluates to an integer.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#order()">order()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a single or multiple fields to be used in the ORDER clause for this query. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#page()">page()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Set the page of results you want.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#repository()">repository()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Set the default Table object that will be used by this query and form the <code>FROM</code> clause.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#select()">select()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds fields to be selected from datasource.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#toArray()">toArray()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Returns an array representation of the results after executing the query.</p> </div> </li> <li class="clearfix"> <h5 class="function-name"> <a href="#where()">where()</a> <span class="label">public</span> </h5> <div class="description detailed"> <p>Adds a condition or set of conditions to be used in the WHERE clause for this query. Conditions can be expressed as an array of fields as keys with comparison operators in it, the values for the array will be used for comparing the field to such literal. Finally, conditions can be expressed as a single string or an array of strings.</p> </div> </li> </ul> <div class="section"> <h2>Method Detail</h2> <div class="method-detail">  <h3 class="method-name" id="aliasField()"> aliasField()   <span class="label">public</span> </h3> <pre data-language="php">aliasField(string $field, string|null $alias = null): array&lt;string, string&gt;</pre> <div class="description detailed"> <p>Returns a key =&gt; value array representing a single aliased field that can be passed directly to the select() method. The key will contain the alias and the value the actual field name.</p> <p>If the field is already aliased, then it will not be changed. If no $alias is passed, the default table for this query will be used.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$field</var> </dt> <dd><p>The field to alias</p></dd> <dt> <code>string|null</code> <var>$alias</var> <span class="label">optional</span> </dt> <dd><p>the alias used to prefix the field</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>array&lt;string, string&gt;</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="aliasFields()"> aliasFields()   <span class="label">public</span> </h3> <pre data-language="php">aliasFields(array $fields, string|null $defaultAlias = null): array&lt;string, string&gt;</pre> <div class="description detailed"> <p>Runs <code>aliasField()</code> for each field in the provided list and returns the result under a single array.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array</code> <var>$fields</var> </dt> <dd><p>The fields to alias</p></dd> <dt> <code>string|null</code> <var>$defaultAlias</var> <span class="label">optional</span> </dt> <dd><p>The default alias</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>array&lt;string, string&gt;</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="all()"> all()   <span class="label">public</span> </h3> <pre data-language="php">all(): Cake\Datasource\ResultSetInterface</pre> <div class="description detailed"> <p>Fetch the results for this query.</p> <p>Will return either the results set through setResult(), or execute this query and return the ResultSetDecorator object ready for streaming of results.</p> <p>ResultSetDecorator is a traversable object that implements the methods found on Cake\Collection\Collection.</p> <h4>Returns</h4> <div class="list"> <code>Cake\Datasource\ResultSetInterface</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="andWhere()"> andWhere()   <span class="label">public</span> <span class="label annotation">@method</span> </h3> <pre data-language="php">andWhere(mixed $conditions, array $types = []): $this</pre> <div class="description detailed"> <p>Connects any previously defined set of conditions to the provided list using the AND operator. {@see \Cake\Database\Query::andWhere()}</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt>  <var>$conditions</var> </dt>  <dt> <code>array</code> <var>$types</var> <span class="label">optional</span> </dt>  </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="applyOptions()"> applyOptions()   <span class="label">public</span> </h3> <pre data-language="php">applyOptions(array&lt;string, mixed&gt; $options): $this</pre> <div class="description detailed"> <p>Populates or adds parts to current query clauses using an array. This is handy for passing all query clauses at once. The option array accepts:</p> <ul> <li>fields: Maps to the select method</li> <li>conditions: Maps to the where method</li> <li>limit: Maps to the limit method</li> <li>order: Maps to the order method</li> <li>offset: Maps to the offset method</li> <li>group: Maps to the group method</li> <li>having: Maps to the having method</li> <li>contain: Maps to the contain options for eager loading</li> <li>join: Maps to the join method</li> <li>page: Maps to the page method</li> </ul> <h3>Example:</h3> <pre data-language="php">$query-&gt;applyOptions([
  'fields' =&gt; ['id', 'name'],
  'conditions' =&gt; [
    'created &gt;=' =&gt; '2013-01-01'
  ],
  'limit' =&gt; 10
]);</pre> <p>Is equivalent to:</p> <pre data-language="php">$query
 -&gt;select(['id', 'name'])
 -&gt;where(['created &gt;=' =&gt; '2013-01-01'])
 -&gt;limit(10)</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>array&lt;string, mixed&gt;</code> <var>$options</var> </dt> <dd><p>list of query clauses to apply new parts to.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="count()"> count()   <span class="label">public</span> </h3> <pre data-language="php">count(): int</pre> <div class="description detailed"> <p>Returns the total amount of results for the query.</p> <h4>Returns</h4> <div class="list"> <code>int</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="find()"> find()   <span class="label">public</span> </h3> <pre data-language="php">find(string $finder, array&lt;string, mixed&gt; $options = []): static</pre> <div class="description detailed"> <p>Apply custom finds to against an existing query object.</p> <p>Allows custom find methods to be combined and applied to each other.</p> <pre data-language="php">$repository-&gt;find('all')-&gt;find('recent');</pre> <p>The above is an example of stacking multiple finder methods onto a single query.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>string</code> <var>$finder</var> </dt> <dd><p>The finder method to use.</p></dd> <dt> <code>array&lt;string, mixed&gt;</code> <var>$options</var> <span class="label">optional</span> </dt> <dd><p>The options for the finder.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>static</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="first()"> first()   <span class="label">public</span> </h3> <pre data-language="php">first(): Cake\Datasource\EntityInterface|array|null</pre> <div class="description detailed"> <p>Returns the first result out of executing this query, if the query has not been executed before, it will set the limit clause to 1 for performance reasons.</p> <h3>Example:</h3> <pre data-language="php">$singleUser = $query-&gt;select(['id', 'username'])-&gt;first();</pre> <h4>Returns</h4> <div class="list"> <code>Cake\Datasource\EntityInterface|array|null</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="firstOrFail()"> firstOrFail()   <span class="label">public</span> <span class="label annotation">@method</span> </h3> <pre data-language="php">firstOrFail(): Cake\Datasource\EntityInterface|array</pre> <div class="description detailed"> <p>Get the first result from the executing query or raise an exception. {@see \Cake\Database\Query::firstOrFail()}</p> <h4>Returns</h4> <div class="list"> <code>Cake\Datasource\EntityInterface|array</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="getRepository()"> getRepository()   <span class="label">public</span> </h3> <pre data-language="php">getRepository(): Cake\Datasource\RepositoryInterface|null</pre> <div class="description detailed"> <p>Returns the default repository object that will be used by this query, that is, the repository that will appear in the from clause.</p> <h4>Returns</h4> <div class="list"> <code>Cake\Datasource\RepositoryInterface|null</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="limit()"> limit()   <span class="label">public</span> </h3> <pre data-language="php">limit(Cake\Database\ExpressionInterface|int|null $limit): $this</pre> <div class="description detailed"> <p>Sets the number of records that should be retrieved from database, accepts an integer or an expression object that evaluates to an integer. In some databases, this operation might not be supported or will require the query to be transformed in order to limit the result set size.</p> <h3>Examples</h3> <pre data-language="php">$query-&gt;limit(10) // generates LIMIT 10
$query-&gt;limit($query-&gt;newExpr()-&gt;add(['1 + 1'])); // LIMIT (1 + 1)</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|int|null</code> <var>$limit</var> </dt> <dd><p>number of records to be returned</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="offset()"> offset()   <span class="label">public</span> </h3> <pre data-language="php">offset(Cake\Database\ExpressionInterface|int|null $offset): $this</pre> <div class="description detailed"> <p>Sets the number of records that should be skipped from the original result set This is commonly used for paginating large results. Accepts an integer or an expression object that evaluates to an integer.</p> <p>In some databases, this operation might not be supported or will require the query to be transformed in order to limit the result set size.</p> <h3>Examples</h3> <pre data-language="php">$query-&gt;offset(10) // generates OFFSET 10
 $query-&gt;offset($query-&gt;newExpr()-&gt;add(['1 + 1'])); // OFFSET (1 + 1)</pre> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterface|int|null</code> <var>$offset</var> </dt> <dd><p>number of records to be skipped</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="order()"> order()   <span class="label">public</span> </h3> <pre data-language="php">order(Cake\Database\ExpressionInterfaceClosure|array|string $fields, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a single or multiple fields to be used in the ORDER clause for this query. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p> <p>If an array is passed, keys will be used as the field itself and the value will represent the order in which such field should be ordered. When called multiple times with the same fields as key, the last order definition will prevail over the others.</p> <p>By default this function will append any passed argument to the list of fields to be selected, unless the second argument is set to true.</p> <h3>Examples:</h3> <pre data-language="php">$query-&gt;order(['title' =&gt; 'DESC', 'author_id' =&gt; 'ASC']);</pre> <p>Produces:</p> <p><code>ORDER BY title DESC, author_id ASC</code></p> <pre data-language="php">$query
    -&gt;order(['title' =&gt; $query-&gt;newExpr('DESC NULLS FIRST')])
    -&gt;order('author_id');</pre> <p>Will generate:</p> <p><code>ORDER BY title DESC NULLS FIRST, author_id</code></p> <pre data-language="php">$expression = $query-&gt;newExpr()-&gt;add(['id % 2 = 0']);
$query-&gt;order($expression)-&gt;order(['title' =&gt; 'ASC']);</pre> <p>Will become:</p> <p><code>ORDER BY (id %2 = 0), title ASC</code></p> <p>If you need to set complex expressions as order conditions, you should use <code>orderAsc()</code> or <code>orderDesc()</code>.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterfaceClosure|array|string</code> <var>$fields</var> </dt> <dd><p>fields to be added to the list</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset order with field list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="page()"> page()   <span class="label">public</span> </h3> <pre data-language="php">page(int $num, int|null $limit = null): $this</pre> <div class="description detailed"> <p>Set the page of results you want.</p> <p>This method provides an easier to use interface to set the limit + offset in the record set you want as results. If empty the limit will default to the existing limit clause, and if that too is empty, then <code>25</code> will be used.</p> <p>Pages must start at 1.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>int</code> <var>$num</var> </dt> <dd><p>The page number you want.</p></dd> <dt> <code>int|null</code> <var>$limit</var> <span class="label">optional</span> </dt> <dd><p>The number of rows you want in the page. If null the current limit clause will be used.</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> <h4>Throws</h4> <div class="list"> <code>InvalidArgumentException</code><br> If page number &lt; 1. </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="repository()"> repository()   <span class="label">public</span> </h3> <pre data-language="php">repository(Cake\Datasource\RepositoryInterface $repository): $this</pre> <div class="description detailed"> <p>Set the default Table object that will be used by this query and form the <code>FROM</code> clause.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Datasource\RepositoryInterface</code> <var>$repository</var> </dt> <dd><p>The default repository object to use</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="select()"> select()   <span class="label">public</span> </h3> <pre data-language="php">select(Cake\Database\ExpressionInterfaceCake\ORM\AssociationCake\ORM\Table|callable|array|string $fields, bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds fields to be selected from datasource.</p> <p>Calling this function multiple times will append more fields to the list of fields to be selected.</p> <p>If <code>true</code> is passed in the second argument, any previous selections will be overwritten with the list passed in the first argument.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Cake\Database\ExpressionInterfaceCake\ORM\AssociationCake\ORM\Table|callable|array|string</code> <var>$fields</var> </dt> <dd><p>Fields.</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset fields with passed list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="toArray()"> toArray()   <span class="label">public</span> </h3> <pre data-language="php">toArray(): array</pre> <div class="description detailed"> <p>Returns an array representation of the results after executing the query.</p> <h4>Returns</h4> <div class="list"> <code>array</code><br> </div> </div> </div> <div class="method-detail">  <h3 class="method-name" id="where()"> where()   <span class="label">public</span> </h3> <pre data-language="php">where(Closure|array|string|null $conditions = null, array&lt;string, string&gt; $types = [], bool $overwrite = false): $this</pre> <div class="description detailed"> <p>Adds a condition or set of conditions to be used in the WHERE clause for this query. Conditions can be expressed as an array of fields as keys with comparison operators in it, the values for the array will be used for comparing the field to such literal. Finally, conditions can be expressed as a single string or an array of strings.</p> <p>When using arrays, each entry will be joined to the rest of the conditions using an AND operator. Consecutive calls to this function will also join the new conditions specified using the AND operator. Additionally, values can be expressed using expression objects which can include other query objects.</p> <p>Any conditions created with this methods can be used with any SELECT, UPDATE and DELETE type of queries.</p> <h3>Conditions using operators:</h3> <pre data-language="php">$query-&gt;where([
     'posted &gt;=' =&gt; new DateTime('3 days ago'),
     'title LIKE' =&gt; 'Hello W%',
     'author_id' =&gt; 1,
 ], ['posted' =&gt; 'datetime']);</pre> <p>The previous example produces:</p> <p><code>WHERE posted &gt;= 2012-01-27 AND title LIKE 'Hello W%' AND author_id = 1</code></p> <p>Second parameter is used to specify what type is expected for each passed key. Valid types can be used from the mapped with Database\Type class.</p> <h3>Nesting conditions with conjunctions:</h3> <pre data-language="php">$query-&gt;where([
     'author_id !=' =&gt; 1,
     'OR' =&gt; ['published' =&gt; true, 'posted &lt;' =&gt; new DateTime('now')],
     'NOT' =&gt; ['title' =&gt; 'Hello']
 ], ['published' =&gt; boolean, 'posted' =&gt; 'datetime']</pre> <p>The previous example produces:</p> <p><code>WHERE author_id = 1 AND (published = 1 OR posted &lt; '2012-02-01') AND NOT (title = 'Hello')</code></p> <p>You can nest conditions using conjunctions as much as you like. Sometimes, you may want to define 2 different options for the same key, in that case, you can wrap each condition inside a new array:</p> <p><code>$query-&gt;where(['OR' =&gt; [['published' =&gt; false], ['published' =&gt; true]])</code></p> <p>Keep in mind that every time you call where() with the third param set to false (default), it will join the passed conditions to the previous stored list using the AND operator. Also, using the same array key twice in consecutive calls to this method will not override the previous value.</p> <h3>Using expressions objects:</h3> <pre data-language="php">$exp = $query-&gt;newExpr()-&gt;add(['id !=' =&gt; 100, 'author_id' != 1])-&gt;tieWith('OR');
 $query-&gt;where(['published' =&gt; true], ['published' =&gt; 'boolean'])-&gt;where($exp);</pre> <p>The previous example produces:</p> <p><code>WHERE (id != 100 OR author_id != 1) AND published = 1</code></p> <p>Other Query objects that be used as conditions for any field.</p> <h3>Adding conditions in multiple steps:</h3> <p>You can use callable functions to construct complex expressions, functions receive as first argument a new QueryExpression object and this query instance as second argument. Functions must return an expression object, that will be added the list of conditions for the query using the AND operator.</p> <pre data-language="php">$query
 -&gt;where(['title !=' =&gt; 'Hello World'])
 -&gt;where(function ($exp, $query) {
     $or = $exp-&gt;or(['id' =&gt; 1]);
     $and = $exp-&gt;and(['id &gt;' =&gt; 2, 'id &lt;' =&gt; 10]);
 return $or-&gt;add($and);
 });</pre> <ul> <li>The previous example produces:</li> </ul> <p><code>WHERE title != 'Hello World' AND (id = 1 OR (id &gt; 2 AND id &lt; 10))</code></p> <h3>Conditions as strings:</h3> <pre data-language="php">$query-&gt;where(['articles.author_id = authors.id', 'modified IS NULL']);</pre> <p>The previous example produces:</p> <p><code>WHERE articles.author_id = authors.id AND modified IS NULL</code></p> <p>Please note that when using the array notation or the expression objects, all values will be correctly quoted and transformed to the correspondent database data type automatically for you, thus securing your application from SQL injections. If you use string conditions make sure that your values are correctly quoted. The safest thing you can do is to never use string conditions.</p> <h4>Parameters</h4> <div class="parameter-list list"> <dl> <dt> <code>Closure|array|string|null</code> <var>$conditions</var> <span class="label">optional</span> </dt> <dd><p>The conditions to filter on.</p></dd> <dt> <code>array&lt;string, string&gt;</code> <var>$types</var> <span class="label">optional</span> </dt> <dd><p>Associative array of type names used to bind values to query</p></dd> <dt> <code>bool</code> <var>$overwrite</var> <span class="label">optional</span> </dt> <dd><p>whether to reset conditions with passed list or not</p></dd> </dl> </div> <h4>Returns</h4> <div class="list"> <code>$this</code><br> </div> </div> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;present The Cake Software Foundation, Inc.<br>Licensed under the MIT License.<br>CakePHP is a registered trademark of Cake Software Foundation, Inc.<br>We are not endorsed by or affiliated with CakePHP.<br>
    <a href="https://api.cakephp.org/4.4/interface-Cake.Datasource.QueryInterface.html" class="_attribution-link">https://api.cakephp.org/4.4/interface-Cake.Datasource.QueryInterface.html</a>
  </p>
</div>
