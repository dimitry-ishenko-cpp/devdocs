<h1>
<a href="https://github.com/angular/angular.js/edit/v1.8.x/src/ngAnimate/module.js?message=docs(ngAnimate)%3A%20describe%20your%20change...#L3" class="improve-docs btn btn-primary">Improve this Doc</a> ngAnimate </h1> <h2 id="module-installation">Installation</h2> <p>First, get the file:</p> <ul> <li> <a href="https://developers.google.com/speed/libraries/devguide#angularjs">Google CDN</a> e.g. <pre>"//ajax.googleapis.com/ajax/libs/angularjs/X.Y.Z/angular-animate.js"</pre> </li> <li> <a href="https://www.npmjs.com/">NPM</a> e.g. <pre>npm install --save angular-animate@X.Y.Z</pre> or <pre>yarn add angular-animate@X.Y.Z</pre> </li> <li> <a href="http://bower.io">Bower</a> e.g. <pre>bower install angular-animate#X.Y.Z</pre> </li> <li> <a href="https://code.angularjs.org/">code.angularjs.org</a> (discouraged for production use) e.g. <pre>"//code.angularjs.org/X.Y.Z/angular-animate.js"</pre> </li> </ul> <p>where X.Y.Z is the AngularJS version you are running.</p> <p>Then, include <code>angular-animate.js</code> in your HTML:</p> <pre data-language="html">&lt;script src="path/to/angular.js"&gt;&lt;/script&gt;
&lt;script src="path/to/angular-animate.js"&gt;&lt;/script&gt;</pre> <p>Finally, load the module in your application by adding it as a dependent module:</p> <pre>angular.module('app', ['ngAnimate']);</pre> <p>With that you're ready to get started!</p> <p>The <code>ngAnimate</code> module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via callback hooks. Animations are not enabled by default, however, by including <code>ngAnimate</code> the animation hooks are enabled for an AngularJS app.</p> <h2 id="usage">Usage</h2> <p>Simply put, there are two ways to make use of animations when ngAnimate is used: by using <strong>CSS</strong> and <strong>JavaScript</strong>. The former works purely based using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via <code>module.animation()</code>. For both CSS and JS animations the sole requirement is to have a matching <code>CSS class</code> that exists both in the registered animation and within the HTML element that the animation will be triggered on.</p> <h2 id="directive-support">Directive Support</h2> <p>The following directives are "animation aware":</p> <table> <thead> <tr> <th>Directive</th> <th>Supported Animations</th> </tr> </thead> <tbody> <tr> <td><a href="ng/directive/form.html#animations.html">form / ngForm</a></td> <td>add and remove (<a href="ng/directive/form.html#css-classes.html">various classes</a>)</td> </tr> <tr> <td><a href="nganimate/directive/nganimateswap.html#animations.html">ngAnimateSwap</a></td> <td>enter and leave</td> </tr> <tr> <td><a href="ng/directive/ngclass.html#animations.html">ngClass / {{class}â€‹}</a></td> <td>add and remove</td> </tr> <tr> <td><a href="ng/directive/ngclasseven.html#animations.html">ngClassEven</a></td> <td>add and remove</td> </tr> <tr> <td><a href="ng/directive/ngclassodd.html#animations.html">ngClassOdd</a></td> <td>add and remove</td> </tr> <tr> <td><a href="ng/directive/nghide.html#animations.html">ngHide</a></td> <td>add and remove (the <code>ng-hide</code> class)</td> </tr> <tr> <td><a href="ng/directive/ngif.html#animations.html">ngIf</a></td> <td>enter and leave</td> </tr> <tr> <td><a href="ng/directive/nginclude.html#animations.html">ngInclude</a></td> <td>enter and leave</td> </tr> <tr> <td><a href="ngmessages.html#animations.html">ngMessage / ngMessageExp</a></td> <td>enter and leave</td> </tr> <tr> <td><a href="ngmessages.html#animations.html">ngMessages</a></td> <td>add and remove (the <code>ng-active</code>/<code>ng-inactive</code> classes)</td> </tr> <tr> <td><a href="ng/directive/ngmodel.html#animations.html">ngModel</a></td> <td>add and remove (<a href="ng/directive/ngmodel.html#css-classes.html">various classes</a>)</td> </tr> <tr> <td><a href="ng/directive/ngrepeat.html#animations.html">ngRepeat</a></td> <td>enter, leave, and move</td> </tr> <tr> <td><a href="ng/directive/ngshow.html#animations.html">ngShow</a></td> <td>add and remove (the <code>ng-hide</code> class)</td> </tr> <tr> <td><a href="ng/directive/ngswitch.html#animations.html">ngSwitch</a></td> <td>enter and leave</td> </tr> <tr> <td><a href="ngroute/directive/ngview.html#animations.html">ngView</a></td> <td>enter and leave</td> </tr> </tbody> </table> <p>(More information can be found by visiting the documentation associated with each directive.)</p> <p>For a full breakdown of the steps involved during each animation event, refer to the <a href="ng/service/%24animate.html"><code>$animate</code> API docs</a>.</p> <h2 id="css-based-animations">CSS-based Animations</h2> <p>CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML and CSS code we can create an animation that will be picked up by AngularJS when an underlying directive performs an operation.</p> <p>The example below shows how an <code>enter</code> animation can be made possible on an element using <code>ng-if</code>:</p> <pre data-language="html">&lt;div ng-if="bool" class="fade"&gt;
   Fade me in out
&lt;/div&gt;
&lt;button ng-click="bool=true"&gt;Fade In!&lt;/button&gt;
&lt;button ng-click="bool=false"&gt;Fade Out!&lt;/button&gt;
</pre> <p>Notice the CSS class <strong>fade</strong>? We can now create the CSS transition code that references this class:</p> <pre data-language="css">/* The starting CSS styles for the enter animation */
.fade.ng-enter {
  transition:0.5s linear all;
  opacity:0;
}

/* The finishing CSS styles for the enter animation */
.fade.ng-enter.ng-enter-active {
  opacity:1;
}
</pre> <p>The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two generated CSS classes will be applied to the element; in the example above we have <code>.ng-enter</code> and <code>.ng-enter-active</code>. For CSS transitions, the transition code <strong>must</strong> be defined within the starting CSS class (in this case <code>.ng-enter</code>). The destination class is what the transition will animate towards.</p> <p>If for example we wanted to create animations for <code>leave</code> and <code>move</code> (ngRepeat triggers move) then we can do so using the same CSS naming conventions:</p> <pre data-language="css">/* now the element will fade out before it is removed from the DOM */
.fade.ng-leave {
  transition:0.5s linear all;
  opacity:1;
}
.fade.ng-leave.ng-leave-active {
  opacity:0;
}
</pre> <p>We can also make use of <strong>CSS Keyframes</strong> by referencing the keyframe animation within the starting CSS class:</p> <pre data-language="css">/* there is no need to define anything inside of the destination
CSS class since the keyframe will take charge of the animation */
.fade.ng-leave {
  animation: my_fade_animation 0.5s linear;
  -webkit-animation: my_fade_animation 0.5s linear;
}

@keyframes my_fade_animation {
  from { opacity:1; }
  to { opacity:0; }
}

@-webkit-keyframes my_fade_animation {
  from { opacity:1; }
  to { opacity:0; }
}
</pre> <p>Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.</p> <h3 id="css-class-based-animations">CSS Class-based Animations</h3> <p>Class-based animations (animations that are triggered via <code>ngClass</code>, <code>ngShow</code>, <code>ngHide</code> and some other directives) have a slightly different naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added and removed.</p> <p>For example if we wanted to do a CSS animation for <code>ngHide</code> then we place an animation on the <code>.ng-hide</code> CSS class:</p> <pre data-language="html">&lt;div ng-show="bool" class="fade"&gt;
  Show and hide me
&lt;/div&gt;
&lt;button ng-click="bool=!bool"&gt;Toggle&lt;/button&gt;

&lt;style&gt;
.fade.ng-hide {
  transition:0.5s linear all;
  opacity:0;
}
&lt;/style&gt;
</pre> <p>All that is going on here with ngShow/ngHide behind the scenes is the <code>.ng-hide</code> class is added/removed (when the hidden state is valid). Since ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.</p> <p>In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation with CSS styles.</p> <pre data-language="html">&lt;div ng-class="{on:onOff}" class="highlight"&gt;
  Highlight this box
&lt;/div&gt;
&lt;button ng-click="onOff=!onOff"&gt;Toggle&lt;/button&gt;

&lt;style&gt;
.highlight {
  transition:0.5s linear all;
}
.highlight.on-add {
  background:white;
}
.highlight.on {
  background:yellow;
}
.highlight.on-remove {
  background:black;
}
&lt;/style&gt;
</pre> <p>We can also make use of CSS keyframes by placing them within the CSS classes.</p> <h3 id="css-staggering-animations">CSS Staggering Animations</h3> <p>A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a curtain-like effect. The ngAnimate module (versions &gt;=1.2) supports staggering animations and the stagger effect can be performed by creating a <strong>ng-EVENT-stagger</strong> CSS class and attaching that class to the base CSS class used for the animation. The style property expected within the stagger class can either be a <strong>transition-delay</strong> or an <strong>animation-delay</strong> property (or both if your animation contains both transitions and keyframe animations).</p> <pre data-language="css">.my-animation.ng-enter {
  /* standard transition code */
  transition: 1s linear all;
  opacity:0;
}
.my-animation.ng-enter-stagger {
  /* this will have a 100ms delay between each successive leave animation */
  transition-delay: 0.1s;

  /* As of 1.4.4, this must always be set: it signals ngAnimate
    to not accidentally inherit a delay property from another CSS class */
  transition-duration: 0s;

  /* if you are using animations instead of transitions you should configure as follows:
    animation-delay: 0.1s;
    animation-duration: 0s; */
}
.my-animation.ng-enter.ng-enter-active {
  /* standard transition styles */
  opacity:1;
}
</pre> <p>Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation will also be reset if one or more animation frames have passed since the multiple calls to <code>$animate</code> were fired.</p> <p>The following code will issue the <strong>ng-leave-stagger</strong> event on the element provided:</p> <pre data-language="javascript">var kids = parent.children();

$animate.leave(kids[0]); //stagger index=0
$animate.leave(kids[1]); //stagger index=1
$animate.leave(kids[2]); //stagger index=2
$animate.leave(kids[3]); //stagger index=3
$animate.leave(kids[4]); //stagger index=4

window.requestAnimationFrame(function() {
  //stagger has reset itself
  $animate.leave(kids[5]); //stagger index=0
  $animate.leave(kids[6]); //stagger index=1

  $scope.$digest();
});
</pre> <p>Stagger animations are currently only supported within CSS-defined animations.</p> <h3 id="the-ng-animate-css-class">The ng-animate CSS class</h3> <p>When ngAnimate is animating an element it will apply the <code>ng-animate</code> CSS class to the element for the duration of the animation. This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).</p> <p>Therefore, animations can be applied to an element using this temporary class directly via CSS.</p> <pre data-language="css">.zipper.ng-animate {
  transition:0.5s linear all;
}
.zipper.ng-enter {
  opacity:0;
}
.zipper.ng-enter.ng-enter-active {
  opacity:1;
}
.zipper.ng-leave {
  opacity:1;
}
.zipper.ng-leave.ng-leave-active {
  opacity:0;
}
</pre> <p>(Note that the <code>ng-animate</code> CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove the CSS class once an animation has completed.)</p> <h3 id="the-ng-event-prepare-class">The ng-[event]-prepare class</h3> <p>This is a special class that can be used to prevent unwanted flickering / flash of content before the actual animation starts. The class is added as soon as an animation is initialized, but removed before the actual animation starts (after waiting for a $digest). It is also only added for <em>structural</em> animations (<code>enter</code>, <code>move</code>, and <code>leave</code>).</p> <p>In practice, flickering can appear when nesting elements with structural animations such as <code>ngIf</code> into elements that have class-based animations such as <code>ngClass</code>.</p> <pre data-language="html">&lt;div ng-class="{red: myProp}"&gt;
  &lt;div ng-class="{blue: myProp}"&gt;
    &lt;div class="message" ng-if="myProp"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre> <p>It is possible that during the <code>enter</code> animation, the <code>.message</code> div will be briefly visible before it starts animating. In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:</p> <pre data-language="css">.message.ng-enter-prepare {
  opacity: 0;
}
</pre> <h3 id="animating-between-value-changes">Animating between value changes</h3> <p>Sometimes you need to animate between different expression states, whose values don't necessary need to be known or referenced in CSS styles. Unless possible with another <a href="nganimate.html#directive-support.html">"animation aware" directive</a>, that specific use case can always be covered with <a href="nganimate/directive/nganimateswap.html"><code>ngAnimateSwap</code></a> as can be seen in <a href="nganimate/directive/nganimateswap.html#examples.html">this example</a>.</p> <p>Note that <a href="nganimate/directive/nganimateswap.html"><code>ngAnimateSwap</code></a> is a <em>structural directive</em>, which means it creates a new instance of the element (including any other/child directives it may have) and links it to a new scope every time <em>swap</em> happens. In some cases this might not be desirable (e.g. for performance reasons, or when you wish to retain internal state on the original element instance).</p> <h2 id="javascript-based-animations">JavaScript-based Animations</h2> <p>ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the <code>module.animation()</code> module function we can register the animation.</p> <p>Let's see an example of a enter/leave animation using <code>ngRepeat</code>:</p> <pre data-language="html">&lt;div ng-repeat="item in items" class="slide"&gt;
  {{ item }}
&lt;/div&gt;
</pre> <p>See the <strong>slide</strong> CSS class? Let's use that class to define an animation that we'll structure in our module code by using <code>module.animation</code>:</p> <pre data-language="javascript">myModule.animation('.slide', [function() {
  return {
    // make note that other events (like addClass/removeClass)
    // have different function input parameters
    enter: function(element, doneFn) {
      jQuery(element).fadeIn(1000, doneFn);

      // remember to call doneFn so that AngularJS
      // knows that the animation has concluded
    },

    move: function(element, doneFn) {
      jQuery(element).fadeIn(1000, doneFn);
    },

    leave: function(element, doneFn) {
      jQuery(element).fadeOut(1000, doneFn);
    }
  }
}]);
</pre> <p>The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as greensock.js and velocity.js.</p> <p>If our animation code class-based (meaning that something like <code>ngClass</code>, <code>ngHide</code> and <code>ngShow</code> triggers it) then we can still define our animations inside of the same registered animation, however, the function input arguments are a bit different:</p> <pre data-language="html">&lt;div ng-class="color" class="colorful"&gt;
  this box is moody
&lt;/div&gt;
&lt;button ng-click="color='red'"&gt;Change to red&lt;/button&gt;
&lt;button ng-click="color='blue'"&gt;Change to blue&lt;/button&gt;
&lt;button ng-click="color='green'"&gt;Change to green&lt;/button&gt;
</pre> <pre data-language="javascript">myModule.animation('.colorful', [function() {
  return {
    addClass: function(element, className, doneFn) {
      // do some cool animation and call the doneFn
    },
    removeClass: function(element, className, doneFn) {
      // do some cool animation and call the doneFn
    },
    setClass: function(element, addedClass, removedClass, doneFn) {
      // do some cool animation and call the doneFn
    }
  }
}]);
</pre> <h2 id="css-js-animations-together">CSS + JS Animations Together</h2> <p>AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of AngularJS, defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in <strong>JS animations taking charge of the animation</strong>:</p> <pre data-language="html">&lt;div ng-if="bool" class="slide"&gt;
  Slide in and out
&lt;/div&gt;
</pre> <pre data-language="javascript">myModule.animation('.slide', [function() {
  return {
    enter: function(element, doneFn) {
      jQuery(element).slideIn(1000, doneFn);
    }
  }
}]);
</pre> <pre data-language="css">.slide.ng-enter {
  transition:0.5s linear all;
  transform:translateY(-100px);
}
.slide.ng-enter.ng-enter-active {
  transform:translateY(0);
}
</pre> <p>Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the lack of CSS animations by using the <code>$animateCss</code> service to trigger our own tweaked-out, CSS-based animations directly from our own JS-based animation code:</p> <pre data-language="javascript">myModule.animation('.slide', ['$animateCss', function($animateCss) {
  return {
    enter: function(element) {
       // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.
      return $animateCss(element, {
        event: 'enter',
        structural: true
      });
    }
  }
}]);
</pre> <p>The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.</p> <p>The <code>$animateCss</code> service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that data into <code>$animateCss</code> directly:</p> <pre data-language="javascript">myModule.animation('.slide', ['$animateCss', function($animateCss) {
  return {
    enter: function(element) {
      return $animateCss(element, {
        event: 'enter',
        structural: true,
        addClass: 'maroon-setting',
        from: { height:0 },
        to: { height: 200 }
      });
    }
  }
}]);
</pre> <p>Now we can fill in the rest via our transition CSS code:</p> <pre data-language="css">/* the transition tells ngAnimate to make the animation happen */
.slide.ng-enter { transition:0.5s linear all; }

/* this extra CSS class will be absorbed into the transition
since the $animateCss code is adding the class */
.maroon-setting { background:red; }
</pre> <p>And <code>$animateCss</code> will figure out the rest. Just make sure to have the <code>done()</code> callback fire the <code>doneFn</code> function to signal when the animation is over.</p> <p>To learn more about what's possible be sure to visit the <a href="nganimate/service/%24animatecss.html">$animateCss service</a>.</p> <h2 id="animation-anchoring-via-ng-animate-ref-">Animation Anchoring (via ng-animate-ref)</h2> <p>ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between structural areas of an application (like views) by pairing up elements using an attribute called <code>ng-animate-ref</code>.</p> <p>Let's say for example we have two views that are managed by <code>ng-view</code> and we want to show that there is a relationship between two components situated in within these views. By using the <code>ng-animate-ref</code> attribute we can identify that the two components are paired together and we can then attach an animation, which is triggered when the view changes.</p> <p>Say for example we have the following template code:</p> <pre data-language="html">&lt;!-- index.html --&gt;
&lt;div ng-view class="view-animation"&gt;
&lt;/div&gt;

&lt;!-- home.html --&gt;
&lt;a href="#/banner-page"&gt;
  &lt;img src="./banner.jpg" class="banner" ng-animate-ref="banner"&gt;
&lt;/a&gt;

&lt;!-- banner-page.html --&gt;
&lt;img src="./banner.jpg" class="banner" ng-animate-ref="banner"&gt;
</pre> <p>Now, when the view changes (once the link is clicked), ngAnimate will examine the HTML contents to see if there is a match reference between any components in the view that is leaving and the view that is entering. It will scan both the view which is being removed (leave) and inserted (enter) to see if there are any paired DOM elements that contain a matching ref value.</p> <p>The two images match since they share the same ref value. ngAnimate will now create a transport element (which is a clone of the first image element) and it will then attempt to animate to the position of the second image element in the next view. For the animation to work a special CSS class called <code>ng-anchor</code> will be added to the transported element.</p> <p>We can now attach a transition onto the <code>.banner.ng-anchor</code> CSS class and then ngAnimate will handle the entire transition for us as well as the addition and removal of any changes of CSS classes between the elements:</p> <pre data-language="css">.banner.ng-anchor {
  /* this animation will last for 1 second since there are
         two phases to the animation (an `in` and an `out` phase) */
  transition:0.5s linear all;
}
</pre> <p>We also <strong>must</strong> include animations for the views that are being entered and removed (otherwise anchoring wouldn't be possible since the new view would be inserted right away).</p> <pre data-language="css">.view-animation.ng-enter, .view-animation.ng-leave {
  transition:0.5s linear all;
  position:fixed;
  left:0;
  top:0;
  width:100%;
}
.view-animation.ng-enter {
  transform:translateX(100%);
}
.view-animation.ng-leave,
.view-animation.ng-enter.ng-enter-active {
  transform:translateX(0%);
}
.view-animation.ng-leave.ng-leave-active {
  transform:translateX(-100%);
}
</pre> <p>Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur: an <code>out</code> and an <code>in</code> stage. The <code>out</code> stage happens first and that is when the element is animated away from its origin. Once that animation is over then the <code>in</code> stage occurs which animates the element to its destination. The reason why there are two animations is to give enough time for the enter animation on the new element to be ready.</p> <p>The example above sets up a transition for both the in and out phases, but we can also target the out or in phases directly via <code>ng-anchor-out</code> and <code>ng-anchor-in</code>.</p> <pre data-language="css">.banner.ng-anchor-out {
  transition: 0.5s linear all;

  /* the scale will be applied during the out animation,
         but will be animated away when the in animation runs */
  transform: scale(1.2);
}

.banner.ng-anchor-in {
  transition: 1s linear all;
}
</pre> <h3 id="anchoring-demo">Anchoring Demo</h3>  <h3 id="how-is-the-element-transported-">How is the element transported?</h3> <p>When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting element is located on screen via absolute positioning. The cloned element will be placed inside of the root element of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The element will then animate into the <code>out</code> and <code>in</code> animations and will eventually reach the coordinates and match the dimensions of the destination element. During the entire animation a CSS class of <code>.ng-animate-shim</code> will be applied to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class is: <code>visibility:hidden</code>). Once the anchor reaches its destination then it will be removed and the destination element will become visible since the shim class will be removed.</p> <h3 id="how-is-the-morphing-handled-">How is the morphing handled?</h3> <p>CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out what CSS classes differ between the starting element and the destination element. These different CSS classes will be added/removed on the anchor element and a transition will be applied (the transition that is provided in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since the cloned element is placed inside of root element which is likely close to the body element).</p> <p>Note that if the root element is on the <code>&lt;html&gt;</code> element then the cloned node will be placed inside of body.</p> <h2 id="using-animate-in-your-directive-code">Using $animate in your directive code</h2> <p>So far we've explored how to feed in animations into an AngularJS application, but how do we trigger animations within our own directives in our application? By injecting the <code>$animate</code> service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's imagine we have a greeting box that shows and hides itself when the data changes</p> <pre data-language="html">&lt;greeting-box active="onOrOff"&gt;Hi there&lt;/greeting-box&gt;
</pre> <pre data-language="javascript">ngModule.directive('greetingBox', ['$animate', function($animate) {
  return function(scope, element, attrs) {
    attrs.$observe('active', function(value) {
      value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');
    });
  });
}]);
</pre> <p>Now the <code>on</code> CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element in our HTML code then we can trigger a CSS or JS animation to happen.</p> <pre data-language="css">/* normally we would create a CSS class to reference on the element */
greeting-box.on { transition:0.5s linear all; background:green; color:white; }
</pre> <p>The <code>$animate</code> service contains a variety of other methods like <code>enter</code>, <code>leave</code>, <code>animate</code> and <code>setClass</code>. To learn more about what's possible be sure to visit the <a href="ng/service/%24animate.html">$animate service API page</a>.</p> <h2 id="callbacks-and-promises">Callbacks and Promises</h2> <p>When <code>$animate</code> is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has ended by chaining onto the returned promise that animation method returns.</p> <pre data-language="javascript">// somewhere within the depths of the directive
$animate.enter(element, parent).then(function() {
  //the animation has completed
});
</pre> <p>(Note that earlier versions of AngularJS prior to v1.4 required the promise code to be wrapped using <code>$scope.$apply(...)</code>. This is not the case anymore.)</p> <p>In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering an event listener using the <code>$animate</code> service. Let's say for example that an animation was triggered on our view routing controller to hook into that:</p> <pre data-language="javascript">ngModule.controller('HomePageController', ['$animate', function($animate) {
  $animate.on('enter', ngViewElement, function(element) {
    // the animation for this route has completed
  }]);
}])
</pre> <p>(Note that you will need to trigger a digest within the callback to get AngularJS to notice any scope-related changes.)</p> <div class="component-breakdown"> <h2 id="module-components">Module Components</h2> <div> <h3 class="component-heading" id="directive">Directive</h3> <table class="definition-table"> <tr> <th>Name</th> <th>Description</th> </tr> <tr> <td><a href="nganimate/directive/nganimatechildren.html">ngAnimateChildren</a></td> <td>
<p>ngAnimateChildren allows you to specify that children of this element should animate even if any of the children's parents are currently animating. By default, when an element has an active <code>enter</code>, <code>leave</code>, or <code>move</code> (structural) animation, child elements that also have an active structural animation are not animated.</p> </td> </tr> <tr> <td><a href="nganimate/directive/nganimateswap.html">ngAnimateSwap</a></td> <td>
<p>ngAnimateSwap is a animation-oriented directive that allows for the container to be removed and entered in whenever the associated expression changes. A common usecase for this directive is a rotating banner or slider component which contains one image being present at a time. When the active image changes then the old image will perform a <code>leave</code> animation and the new element will be inserted via an <code>enter</code> animation.</p> </td> </tr> </table> </div> <div> <h3 class="component-heading" id="service">Service</h3> <table class="definition-table"> <tr> <th>Name</th> <th>Description</th> </tr> <tr> <td><a href="nganimate/service/%24animatecss.html">$animateCss</a></td> <td>
<p>The <code>$animateCss</code> service is a useful utility to trigger customized CSS-based transitions/keyframes from a JavaScript-based animation or directly from a directive. The purpose of <code>$animateCss</code> is NOT to side-step how <code>$animate</code> and ngAnimate work, but the goal is to allow pre-existing animations or directives to create more complex animations that can be purely driven using CSS code.</p> </td> </tr> <tr> <td><a href="nganimate/service/%24animate.html">$animate</a></td> <td>
<p>The ngAnimate <code>$animate</code> service documentation is the same for the core <code>$animate</code> service.</p> </td> </tr> </table> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2020 Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://code.angularjs.org/1.8.2/docs/api/ngAnimate" class="_attribution-link">https://code.angularjs.org/1.8.2/docs/api/ngAnimate</a>
  </p>
</div>
