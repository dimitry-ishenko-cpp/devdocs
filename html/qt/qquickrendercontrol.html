<h1 class="title">QQuickRenderControl Class</h1>  <p>The QQuickRenderControl class provides a mechanism for rendering the Qt Quick scenegraph onto an offscreen render target in a fully application-controlled manner. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QQuickRenderControl&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Quick REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Quick)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += quick</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.4</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qobject.html">QObject</a>
</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qquickrendercontrol-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#QQuickRenderControl">QQuickRenderControl</a></b>(QObject *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#dtor.QQuickRenderControl">~QQuickRenderControl</a></b>() override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#beginFrame">beginFrame</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#endFrame">endFrame</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#initialize">initialize</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#invalidate">invalidate</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#polishItems">polishItems</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#prepareThread">prepareThread</a></b>(QThread *<i>targetThread</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#render">render</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QWindow *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#renderWindow">renderWindow</a></b>(QPoint *<i>offset</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#samples">samples</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#setSamples">setSamples</a></b>(int <i>sampleCount</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#sync">sync</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickWindow *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#window">window</a></b>() const</td>
</tr> </table> <h2 id="signals">Signals
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#renderRequested">renderRequested</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#sceneChanged">sceneChanged</a></b>()</td>
</tr> </table> <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QWindow *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickrendercontrol.html#renderWindowFor">renderWindowFor</a></b>(QQuickWindow *<i>win</i>, QPoint *<i>offset</i> = nullptr)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p><a href="qquickwindow.html">QQuickWindow</a> and <a href="qquickview.html">QQuickView</a> and their associated internal render loops render the Qt Quick scene onto a native window. In some cases, for example when integrating with 3rd party OpenGL, Vulkan, Metal, or Direct 3D renderers, it can be useful to get the scene into a texture that can then be used in arbitrary ways by the external rendering engine. Such a mechanism is also essential when integrating with a VR framework. QQuickRenderControl makes this possible in a hardware accelerated manner, unlike the performance-wise limited alternative of using <a href="qquickwindow.html#grabWindow">QQuickWindow::grabWindow</a>()</p> <p>When using a QQuickRenderControl, the <a href="qquickwindow.html">QQuickWindow</a> must not be <a href="qwindow.html#show">shown</a> (it will not be visible on-screen) and there will not be an underlying native window for it. Instead, the <a href="qquickwindow.html">QQuickWindow</a> instance is associated with the render control object, using the overload of the <a href="qquickwindow.html">QQuickWindow</a> constructor, and a texture or image object specified via <a href="qquickwindow.html#setRenderTarget">QQuickWindow::setRenderTarget</a>(). The <a href="qquickwindow.html">QQuickWindow</a> object is still essential, because it represents the Qt Quick scene and provides the bulk of the scene management and event delivery mechanisms. It does not however act as a real on-screen window from the windowing system's perspective.</p> <p>Management of the graphics devices, contexts, image and texture objects is up to the application. The device or context that will be used by Qt Quick must be created before calling <a href="qquickrendercontrol.html#initialize">initialize</a>(). The creation of the the texture object can be deferred, see below. Qt 5.4 introduces the ability for <a href="qopenglcontext.html">QOpenGLContext</a> to adopt existing native contexts. Together with QQuickRenderControl this makes it possible to create a <a href="qopenglcontext.html">QOpenGLContext</a> that shares with an external rendering engine's existing context. This new <a href="qopenglcontext.html">QOpenGLContext</a> can then be used to render the Qt Quick scene into a texture that is accessible by the other engine's context too. For Vulkan, Metal, and Direct 3D there are no Qt-provided wrappers for device objects, so existing ones can be passed as-is via <a href="qquickwindow.html#setGraphicsDevice">QQuickWindow::setGraphicsDevice</a>().</p> <p>Loading and instantiation of the QML components happen by using a <a href="qqmlengine.html">QQmlEngine</a>. Once the root object is created, it will need to be parented to the <a href="qquickwindow.html">QQuickWindow</a>'s contentItem().</p> <p>Applications will usually have to connect to 4 important signals:</p> <ul> <li>
<a href="qquickwindow.html#sceneGraphInitialized">QQuickWindow::sceneGraphInitialized</a>() Emitted at some point after calling <a href="qquickrendercontrol.html#initialize">QQuickRenderControl::initialize</a>(). Upon this signal, the application is expected to create its framebuffer object and associate it with the <a href="qquickwindow.html">QQuickWindow</a>.</li> <li>
<a href="qquickwindow.html#sceneGraphInvalidated">QQuickWindow::sceneGraphInvalidated</a>() When the scenegraph resources are released, the framebuffer object can be destroyed too.</li> <li>
<a href="qquickrendercontrol.html#renderRequested">QQuickRenderControl::renderRequested</a>() Indicates that the scene has to be rendered by calling <a href="qquickrendercontrol.html#render">render</a>(). After making the context current, applications are expected to call <a href="qquickrendercontrol.html#render">render</a>().</li> <li>
<a href="qquickrendercontrol.html#sceneChanged">QQuickRenderControl::sceneChanged</a>() Indicates that the scene has changed meaning that, before rendering, polishing and synchronizing is also necessary.</li> </ul> <p>To send events, for example mouse or keyboard events, to the scene, use <a href="qcoreapplication.html#sendEvent">QCoreApplication::sendEvent</a>() with the <a href="qquickwindow.html">QQuickWindow</a> instance as the receiver.</p> <p>For key events it may be also necessary to set the focus manually on the desired item. In practice this involves calling <a href="qquickitem.html#forceActiveFocus">forceActiveFocus</a>() on the desired item, for example the scene's root item, once it is associated with the scene (the <a href="qquickwindow.html">QQuickWindow</a>).</p> <div class="admonition note"> <p><b>Note: </b>In general QQuickRenderControl is supported in combination with all Qt Quick backends. However, some functionality, in particular grab(), may not be available in all cases.</p> </div>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QQuickRenderControl">QQuickRenderControl::<span class="name">QQuickRenderControl</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)
</h3> <p>Constructs a QQuickRenderControl object, with parent object <i>parent</i>.</p>   <h3 class="fn" id="renderRequested">
<code>[signal] </code><span class="type">void</span> QQuickRenderControl::<span class="name">renderRequested</span>()
</h3> <p>This signal is emitted when the scene graph needs to be rendered. It is not necessary to call <a href="qquickrendercontrol.html#sync">sync</a>().</p> <div class="admonition note"> <p><b>Note: </b>Avoid triggering rendering directly when this signal is emitted. Instead, prefer deferring it by using a timer for example. This will lead to better performance.</p> </div>   <h3 class="fn" id="sceneChanged">
<code>[signal] </code><span class="type">void</span> QQuickRenderControl::<span class="name">sceneChanged</span>()
</h3> <p>This signal is emitted when the scene graph is updated, meaning that <a href="qquickrendercontrol.html#polishItems">polishItems</a>() and <a href="qquickrendercontrol.html#sync">sync</a>() needs to be called. If <a href="qquickrendercontrol.html#sync">sync</a>() returns true, then <a href="qquickrendercontrol.html#render">render</a>() needs to be called.</p> <div class="admonition note"> <p><b>Note: </b>Avoid triggering polishing, synchronization and rendering directly when this signal is emitted. Instead, prefer deferring it by using a timer for example. This will lead to better performance.</p> </div>   <h3 class="fn" id="dtor.QQuickRenderControl">
<code>[override virtual] </code>QQuickRenderControl::<span class="name">~QQuickRenderControl</span>()
</h3> <p>Destroys the instance. Releases all scenegraph resources.</p> <p><b>See also </b><a href="qquickrendercontrol.html#invalidate">invalidate</a>().</p>   <h3 class="fn" id="beginFrame">
<code>[since 6.0] </code><span class="type">void</span> QQuickRenderControl::<span class="name">beginFrame</span>()
</h3> <p>Specifies the start of a graphics frame. Calls to <a href="qquickrendercontrol.html#sync">sync</a>() or <a href="qquickrendercontrol.html#render">render</a>() must be enclosed by calls to beginFrame() and <a href="qquickrendercontrol.html#endFrame">endFrame</a>().</p> <p>Unlike the earlier OpenGL-only world of Qt 5, rendering with other graphics APIs requires more well-defined points of starting and ending a frame. When manually driving the rendering loop via <a href="qquickrendercontrol.html">QQuickRenderControl</a>, it now falls to the user of <a href="qquickrendercontrol.html">QQuickRenderControl</a> to specify these points.</p> <p>A typical update step, including initialization of rendering into an existing texture, could like like the following. The example snippet assumes Direct3D 11 but the same concepts apply other graphics APIs as well.</p> <pre data-language="cpp">if (!m_quickInitialized) {
    m_quickWindow-&gt;setGraphicsDevice(QQuickGraphicsDevice::fromDeviceAndContext(m_engine-&gt;device(), m_engine-&gt;context()));

    if (!m_renderControl-&gt;initialize())
        qWarning("Failed to initialize redirected Qt Quick rendering");

    m_quickWindow-&gt;setRenderTarget(QQuickRenderTarget::fromNativeTexture({ quint64(m_res.texture), 0 },
                                                                         QSize(QML_WIDTH, QML_HEIGHT),
                                                                         SAMPLE_COUNT));

    m_quickInitialized = true;
}

m_renderControl-&gt;polishItems();

m_renderControl-&gt;beginFrame();
m_renderControl-&gt;sync();
m_renderControl-&gt;render();
m_renderControl-&gt;endFrame(); // Qt Quick's rendering commands are submitted to the device context here</pre> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickrendercontrol.html#endFrame">endFrame</a>(), <a href="qquickrendercontrol.html#initialize">initialize</a>(), <a href="qquickrendercontrol.html#sync">sync</a>(), <a href="qquickrendercontrol.html#render">render</a>(), <a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a>, and <a href="qquickrendertarget.html">QQuickRenderTarget</a>.</p>   <h3 class="fn" id="endFrame">
<code>[since 6.0] </code><span class="type">void</span> QQuickRenderControl::<span class="name">endFrame</span>()
</h3> <p>Specifies the end of a graphics frame. Calls to <a href="qquickrendercontrol.html#sync">sync</a>() or <a href="qquickrendercontrol.html#render">render</a>() must be enclosed by calls to <a href="qquickrendercontrol.html#beginFrame">beginFrame</a>() and endFrame().</p> <p>When this function is called, any graphics commands enqueued by the scenegraph are submitted to the context or command queue, whichever is applicable.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickrendercontrol.html#beginFrame">beginFrame</a>(), <a href="qquickrendercontrol.html#initialize">initialize</a>(), <a href="qquickrendercontrol.html#sync">sync</a>(), <a href="qquickrendercontrol.html#render">render</a>(), <a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a>, and <a href="qquickrendertarget.html">QQuickRenderTarget</a>.</p>   <h3 class="fn" id="initialize">
<code>[since 6.0] </code><span class="type">bool</span> QQuickRenderControl::<span class="name">initialize</span>()
</h3> <p>Initializes the scene graph resources. When using a graphics API, such as Vulkan, Metal, OpenGL, or Direct3D, for Qt Quick rendering, <a href="qquickrendercontrol.html">QQuickRenderControl</a> will set up an appropriate rendering engine when this function is called. This rendering infrastructure exists as long as the <a href="qquickrendercontrol.html">QQuickRenderControl</a> exists.</p> <p>To control what graphics API Qt Quick uses, call <a href="qquickwindow.html#setGraphicsApi">QQuickWindow::setGraphicsApi</a>() with one of the <a href="qsgrendererinterface.html">QSGRendererInterface</a>:GraphicsApi constants. That must be done before calling this function.</p> <p>To prevent the scenegraph from creating its own device and context objects, specify an appropriate <a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a>, wrapping existing graphics objects, by calling <a href="qquickwindow.html#setGraphicsDevice">QQuickWindow::setGraphicsDevice</a>().</p> <p>To configure which device extensions to enable (for example, for Vulkan), call <a href="qquickwindow.html#setGraphicsConfiguration">QQuickWindow::setGraphicsConfiguration</a>() before this function.</p> <div class="admonition note"> <p><b>Note: </b>When using Vulkan, <a href="qquickrendercontrol.html">QQuickRenderControl</a> does not create a <a href="qvulkaninstance.html">QVulkanInstance</a> automatically. Rather, it is the application's responsibility to create a suitable <a href="qvulkaninstance.html">QVulkanInstance</a> and <a href="qwindow.html#setVulkanInstance">associate it</a> with the <a href="qquickwindow.html">QQuickWindow</a>. Before initializing the <a href="qvulkaninstance.html">QVulkanInstance</a>, it is strongly encouraged to query the list of Qt Quick's desired instance extensions by calling the static function <a href="qquickgraphicsconfiguration.html#preferredInstanceExtensions">QQuickGraphicsConfiguration::preferredInstanceExtensions</a>() and to pass the returned list to <a href="qvulkaninstance.html#setExtensions">QVulkanInstance::setExtensions</a>().</p> </div> <p>Returns <code>true</code> on success, <code>false</code> otherwise.</p> <div class="admonition note"> <p><b>Note: </b>This function does not need to be, and must not be, called when using the <code>software</code> adaptation of Qt Quick.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickrendertarget.html">QQuickRenderTarget</a>, <a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a>, and <a href="qquickgraphicsconfiguration.html#preferredInstanceExtensions">QQuickGraphicsConfiguration::preferredInstanceExtensions</a>().</p>   <h3 class="fn" id="invalidate">
<span class="type">void</span> QQuickRenderControl::<span class="name">invalidate</span>()
</h3> <p>Stop rendering and release resources.</p> <p>This is the equivalent of the cleanup operations that happen with a real <a href="qquickwindow.html">QQuickWindow</a> when the window becomes hidden.</p> <p>This function is called from the destructor. Therefore there will typically be no need to call it directly.</p> <p>Once invalidate() has been called, it is possible to reuse the <a href="qquickrendercontrol.html">QQuickRenderControl</a> instance by calling <a href="qquickrendercontrol.html#initialize">initialize</a>() again.</p> <div class="admonition note"> <p><b>Note: </b>This function does not take QQuickWindow::persistentSceneGraph() or QQuickWindow::persistentGraphics() into account. This means that context-specific resources are always released.</p> </div>   <h3 class="fn" id="polishItems">
<span class="type">void</span> QQuickRenderControl::<span class="name">polishItems</span>()
</h3> <p>This function should be called as late as possible before <a href="qquickrendercontrol.html#sync">sync</a>(). In a threaded scenario, rendering can happen in parallel with this function.</p>   <h3 class="fn" id="prepareThread">
<span class="type">void</span> QQuickRenderControl::<span class="name">prepareThread</span>(<span class="type"><a href="qthread.html">QThread</a></span> *<i>targetThread</i>)
</h3> <p>Prepares rendering the Qt Quick scene outside the GUI thread.</p> <p><i>targetThread</i> specifies the thread on which synchronization and rendering will happen. There is no need to call this function in a single threaded scenario.</p>   <h3 class="fn" id="render">
<span class="type">void</span> QQuickRenderControl::<span class="name">render</span>()
</h3> <p>Renders the scenegraph using the current context.</p>   <h3 class="fn" id="renderWindow">
<code>[virtual] </code><span class="type"><a href="qwindow.html">QWindow</a></span> *QQuickRenderControl::<span class="name">renderWindow</span>(<span class="type"><a href="qpoint.html">QPoint</a></span> *<i>offset</i>)
</h3> <p>Reimplemented in subclasses to return the real window this render control is rendering into.</p> <p>If <i>offset</i> in non-null, it is set to the offset of the control inside the window.</p> <div class="admonition note"> <p><b>Note: </b>While not mandatory, reimplementing this function becomes essential for supporting multiple screens with different device pixel ratios and properly positioning popup windows opened from QML. Therefore providing it in subclasses is highly recommended.</p> </div>   <h3 class="fn" id="renderWindowFor">
<code>[static] </code><span class="type"><a href="qwindow.html">QWindow</a></span> *QQuickRenderControl::<span class="name">renderWindowFor</span>(<span class="type"><a href="qquickwindow.html">QQuickWindow</a></span> *<i>win</i>, <span class="type"><a href="qpoint.html">QPoint</a></span> *<i>offset</i> = nullptr)
</h3> <p>Returns the real window that <i>win</i> is being rendered to, if any.</p> <p>If <i>offset</i> in non-null, it is set to the offset of the rendering inside its window.</p>   <h3 class="fn" id="samples">
<code>[since 6.0] </code><span class="type">int</span> QQuickRenderControl::<span class="name">samples</span>() const
</h3> <p>Returns the current sample count. 1 or 0 means no multisampling.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickrendercontrol.html#setSamples">setSamples</a>().</p>   <h3 class="fn" id="setSamples">
<code>[since 6.0] </code><span class="type">void</span> QQuickRenderControl::<span class="name">setSamples</span>(<span class="type">int</span> <i>sampleCount</i>)
</h3> <p>Sets the number of samples to use for multisampling. When <i>sampleCount</i> is 0 or 1, multisampling is disabled.</p> <div class="admonition note"> <p><b>Note: </b>This function is always used in combination with a multisample render target, which means <i>sampleCount</i> must match the sample count passed to QQuickRenderTarget::fromNativeTexture(), which in turn must match the sample count of the native texture.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickrendercontrol.html#samples">samples</a>(), <a href="qquickrendercontrol.html#initialize">initialize</a>(), and <a href="qquickrendertarget.html">QQuickRenderTarget</a>.</p>   <h3 class="fn" id="sync">
<span class="type">bool</span> QQuickRenderControl::<span class="name">sync</span>()
</h3> <p>This function is used to synchronize the QML scene with the rendering scene graph.</p> <p>If a dedicated render thread is used, the GUI thread should be blocked for the duration of this call.</p> <p>Returns <i>true</i> if the synchronization changed the scene graph.</p>   <h3 class="fn" id="window">
<code>[since 6.0] </code><span class="type"><a href="qquickwindow.html">QQuickWindow</a></span> *QQuickRenderControl::<span class="name">window</span>() const
</h3> <p>Returns the <a href="qquickwindow.html">QQuickWindow</a> this <a href="qquickrendercontrol.html">QQuickRenderControl</a> is associated with.</p> <div class="admonition note"> <p><b>Note: </b>A <a href="qquickrendercontrol.html">QQuickRenderControl</a> gets associated with a <a href="qquickwindow.html">QQuickWindow</a> when constructing the <a href="qquickwindow.html">QQuickWindow</a>. The return value from this function is null before that point.</p> </div> <p>This function was introduced in Qt 6.0.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qquickrendercontrol.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qquickrendercontrol.html</a>
  </p>
</div>
