<h1 class="title">QModbusServer Class</h1>  <p>The QModbusServer class is the interface to receive and process Modbus requests. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QModbusServer&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += serialbus</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.8</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qmodbusdevice.html">QModbusDevice</a>
</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherited By:</td>
<td class="memItemRight bottomAlign"> <p><a href="qmodbusrtuserialserver.html">QModbusRtuSerialServer</a> and <a href="qmodbustcpserver.html">QModbusTcpServer</a></p> </td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qmodbusserver-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#Option-enum">Option</a></b> { DiagnosticRegister, ExceptionStatusOffset, DeviceBusy, AsciiInputDelimiter, ListenOnlyMode, â€¦, UserOption }</td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#QModbusServer">QModbusServer</a></b>(QObject *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#data">data</a></b>(QModbusDataUnit *<i>newData</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#data-1">data</a></b>(QModbusDataUnit::RegisterType <i>table</i>, quint16 <i>address</i>, quint16 *<i>data</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#processesBroadcast">processesBroadcast</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#serverAddress">serverAddress</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#setData">setData</a></b>(const QModbusDataUnit &amp;<i>newData</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#setData-1">setData</a></b>(QModbusDataUnit::RegisterType <i>table</i>, quint16 <i>address</i>, quint16 <i>data</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#setMap">setMap</a></b>(const QModbusDataUnitMap &amp;<i>map</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#setServerAddress">setServerAddress</a></b>(int <i>serverAddress</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#setValue">setValue</a></b>(int <i>option</i>, const QVariant &amp;<i>newValue</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QVariant </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#value">value</a></b>(int <i>option</i>) const</td>
</tr> </table> <h2 id="signals">Signals
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#dataWritten">dataWritten</a></b>(QModbusDataUnit::RegisterType <i>table</i>, int <i>address</i>, int <i>size</i>)</td>
</tr> </table> <h2 id="protected-functions">Protected Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QModbusResponse </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#processPrivateRequest">processPrivateRequest</a></b>(const QModbusPdu &amp;<i>request</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QModbusResponse </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#processRequest">processRequest</a></b>(const QModbusPdu &amp;<i>request</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#readData">readData</a></b>(QModbusDataUnit *<i>newData</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmodbusserver.html#writeData">writeData</a></b>(const QModbusDataUnit &amp;<i>newData</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>Modbus networks can have multiple Modbus servers. Modbus Servers are read/written by a Modbus client represented by <a href="qmodbusclient.html">QModbusClient</a>. QModbusServer communicates with a Modbus backend, providing users with a convenient API.</p>    <h2>Member Type Documentation</h2>  <h3 class="fn" id="Option-enum">enum QModbusServer::<span class="name">Option</span>
</h3> <p>Each Modbus server has a set of values associated with it, each with its own option.</p> <p>The general purpose options (and the associated types) are:</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QModbusServer::DiagnosticRegister</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The diagnostic register of the server. <code>quint16</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QModbusServer::ExceptionStatusOffset</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The exception status byte offset of the server. <code>quint16</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QModbusServer::DeviceBusy</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">Flag to signal the server is engaged in processing a long-duration program command. <code>quint16</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QModbusServer::AsciiInputDelimiter</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">The Modbus ASCII end of message delimiter. <code>char</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QModbusServer::ListenOnlyMode</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">Flag to set listen only mode of the server. This function is typically supported only by Modbus serial devices. <code>bool</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QModbusServer::ServerIdentifier</code></td>
<td class="topAlign tblval"><code>5</code></td>
<td class="topAlign">The identifier of the server, <b>not</b> the server address. <code>quint8</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QModbusServer::RunIndicatorStatus</code></td>
<td class="topAlign tblval"><code>6</code></td>
<td class="topAlign">The run indicator of the server. <code>quint8</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QModbusServer::AdditionalData</code></td>
<td class="topAlign tblval"><code>7</code></td>
<td class="topAlign">The additional data of the server. <code>QByteArray</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QModbusServer::DeviceIdentification</code></td>
<td class="topAlign tblval"><code>8</code></td>
<td class="topAlign">The physical and functional description of the server. <code>QModbusDeviceIdentification</code>
</td>
</tr> </table> <p>User options:</p> <table class="valuelist">
<tr class="even" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QModbusServer::UserOption</code></td>
<td class="topAlign tblval"><code>0x100</code></td>
<td class="topAlign">The first option that can be used for user-specific purposes.</td>
</tr> </table> <p>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QModbusServer">QModbusServer::<span class="name">QModbusServer</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)
</h3> <p>Constructs a Modbus server with the specified <i>parent</i>.</p>   <h3 class="fn" id="dataWritten">
<code>[signal] </code><span class="type">void</span> QModbusServer::<span class="name">dataWritten</span>(<span class="type"><a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a></span> <i>table</i>, <span class="type">int</span> <i>address</i>, <span class="type">int</span> <i>size</i>)
</h3> <p>This signal is emitted when a Modbus client has written one or more fields of data to the Modbus server. The signal contains information about the fields that were written:</p> <ul> <li>Register type (<i>table</i>) that was written,</li> <li>
<i>address</i> of the first field that was written,</li> <li>and <i>size</i> of consecutive fields that were written starting from <i>address</i>.</li> </ul> <p>The signal is not emitted when the to-be-written fields have not changed due to no change in value.</p>   <h3 class="fn" id="data">
<span class="type">bool</span> QModbusServer::<span class="name">data</span>(<span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> *<i>newData</i>) const
</h3> <p>Returns the values in the register range given by <i>newData</i>.</p> <p><i>newData</i> must provide a valid register type, start address and valueCount. The returned <i>newData</i> will contain the register values associated with the given range.</p> <p>If <i>newData</i> contains a valid register type but a negative start address the entire register map is returned and <i>newData</i> appropriately sized.</p> <p><b>See also </b><a href="qmodbusserver.html#setData">setData</a>().</p>   <h3 class="fn" id="data-1">
<span class="type">bool</span> QModbusServer::<span class="name">data</span>(<span class="type"><a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a></span> <i>table</i>, <span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <i>address</i>, <span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> *<i>data</i>) const
</h3> <p>Reads data stored in the Modbus server. A Modbus server has four tables (<i>table</i>) and each have a unique <i>address</i> field, which is used to read <i>data</i> from the desired field. See <a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a> for more information about the different tables. Returns <code>false</code> if address is outside of the map range or the register type is not even defined.</p> <p><b>See also </b><a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a> and <a href="qmodbusserver.html#setData">setData</a>().</p>   <h3 class="fn" id="processPrivateRequest">
<code>[virtual protected] </code><span class="type"><a href="qmodbusresponse.html">QModbusResponse</a></span> QModbusServer::<span class="name">processPrivateRequest</span>(const <span class="type"><a href="qmodbuspdu.html">QModbusPdu</a></span> &amp;<i>request</i>)
</h3> <p>This function should be implemented by custom Modbus servers. It is called by <a href="qmodbusserver.html#processRequest">processRequest</a>() if the given <i>request</i> is not a standard Modbus request.</p> <p>Overwriting this function allows handling of additional function codes and subfunction-codes not specified in the Modbus Application Protocol Specification 1.1b. Reimplementations should call this function again to ensure an exception response is returned for all unknown function codes the custom Modbus implementation does not handle.</p> <p>This default implementation returns a <code>QModbusExceptionResponse</code> with the <i>request</i> function code and error code set to illegal function.</p> <p><b>See also </b><a href="qmodbusserver.html#processRequest">processRequest</a>().</p>   <h3 class="fn" id="processRequest">
<code>[virtual protected] </code><span class="type"><a href="qmodbusresponse.html">QModbusResponse</a></span> QModbusServer::<span class="name">processRequest</span>(const <span class="type"><a href="qmodbuspdu.html">QModbusPdu</a></span> &amp;<i>request</i>)
</h3> <p>Processes a Modbus client <i>request</i> and returns a Modbus response. This function returns a <a href="qmodbusresponse.html">QModbusResponse</a> or <a href="qmodbusexceptionresponse.html">QModbusExceptionResponse</a> depending on the nature of the request.</p> <p>The default implementation of this function handles all standard Modbus function codes as defined by the Modbus Application Protocol Specification 1.1b. All other Modbus function codes not included in the specification are forwarded to <a href="qmodbusserver.html#processPrivateRequest">processPrivateRequest</a>().</p> <p>The default handling of the standard Modbus function code requests can be overwritten by reimplementing this function. The override must handle the request type in question and return the appropriate <a href="qmodbusresponse.html">QModbusResponse</a>. A common reason might be to filter out function code requests for data values to limit read/write access and function codes not desired in particular implementations such as serial line diagnostics on ethernet or Modbus Plus transport layers. Every other request type should be forwarded to this default implementation.</p> <div class="admonition note"> <p><b>Note: </b>This function should not be overridden to provide a custom implementation for non-standard Modbus request types.</p> </div> <p><b>See also </b><a href="qmodbusserver.html#processPrivateRequest">processPrivateRequest</a>().</p>   <h3 class="fn" id="processesBroadcast">
<code>[virtual] </code><span class="type">bool</span> QModbusServer::<span class="name">processesBroadcast</span>() const
</h3> <p>Subclasses should implement this function if the transport layer shall handle broadcasts. The implementation then should return <code>true</code> if the currently processed request is a broadcast request; otherwise <code>false</code>. The default implementation returns always <code>false</code>.</p> <div class="admonition note"> <p><b>Note: </b>The return value of this function only makes sense from within <a href="qmodbusserver.html#processRequest">processRequest</a>() or <a href="qmodbusserver.html#processPrivateRequest">processPrivateRequest</a>(), otherwise it can only tell that the last request processed was a broadcast request.</p> </div>   <h3 class="fn" id="readData">
<code>[virtual protected] </code><span class="type">bool</span> QModbusServer::<span class="name">readData</span>(<span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> *<i>newData</i>) const
</h3> <p>Reads the values in the register range given by <i>newData</i> and writes the data back to <i>newData</i>. Returns <code>true</code> on success or <code>false</code> if <i>newData</i> is <code>0</code>, the <i>newData</i> range is outside of the map range or the registerType() does not exist.</p> <div class="admonition note"> <p><b>Note: </b>Sub-classes that implement reading from a different backing store then default one, also need to implement <a href="qmodbusserver.html#setMap">setMap</a>() and <a href="qmodbusserver.html#writeData">writeData</a>().</p> </div> <p><b>See also </b><a href="qmodbusserver.html#setMap">setMap</a>() and <a href="qmodbusserver.html#writeData">writeData</a>().</p>   <h3 class="fn" id="serverAddress">
<span class="type">int</span> QModbusServer::<span class="name">serverAddress</span>() const
</h3> <p>Returns the address of this Modbus server instance.</p> <p><b>See also </b><a href="qmodbusserver.html#setServerAddress">setServerAddress</a>().</p>   <h3 class="fn" id="setData">
<span class="type">bool</span> QModbusServer::<span class="name">setData</span>(const <span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> &amp;<i>newData</i>)
</h3> <p>Writes <i>newData</i> to the Modbus server map. Returns <code>false</code> if the <i>newData</i> range is outside of the map range.</p> <p>If the call was successful the <a href="qmodbusserver.html#dataWritten">dataWritten</a>() signal is emitted. Note that the signal is not emitted when the addressed register has not changed. This may happen when <i>newData</i> contains exactly the same values as the register already. Nevertheless this function returns <code>true</code> in such cases.</p> <p><b>See also </b><a href="qmodbusserver.html#data">data</a>().</p>   <h3 class="fn" id="setData-1">
<span class="type">bool</span> QModbusServer::<span class="name">setData</span>(<span class="type"><a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a></span> <i>table</i>, <span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <i>address</i>, <span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <i>data</i>)
</h3> <p>Writes data to the Modbus server. A Modbus server has four tables (<i>table</i>) and each have a unique <i>address</i> field, which is used to write <i>data</i> to the desired field. Returns <code>false</code> if address outside of the map range.</p> <p>If the call was successful the <a href="qmodbusserver.html#dataWritten">dataWritten</a>() signal is emitted. Note that the signal is not emitted when <i>data</i> has not changed. Nevertheless this function returns <code>true</code> in such cases.</p> <p><b>See also </b><a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::RegisterType</a>, <a href="qmodbusserver.html#data">data</a>(), and <a href="qmodbusserver.html#dataWritten">dataWritten</a>().</p>   <h3 class="fn" id="setMap">
<code>[virtual] </code><span class="type">bool</span> QModbusServer::<span class="name">setMap</span>(const <span class="type"><a href="qmodbusdataunit.html#QModbusDataUnitMap-typedef">QModbusDataUnitMap</a></span> &amp;<i>map</i>)
</h3> <p>Sets the registered map structure for requests from other ModBus clients to <i>map</i>. The register values are initialized with zero. Returns <code>true</code> on success; otherwise <code>false</code>.</p> <p>If this function is not called before connecting, a default register with zero entries is setup.</p> <div class="admonition note"> <p><b>Note: </b>Calling this function discards any register value that was previously set.</p> </div>   <h3 class="fn" id="setServerAddress">
<span class="type">void</span> QModbusServer::<span class="name">setServerAddress</span>(<span class="type">int</span> <i>serverAddress</i>)
</h3> <p>Sets the address for this Modbus server instance to <i>serverAddress</i>.</p> <p><b>See also </b><a href="qmodbusserver.html#serverAddress">serverAddress</a>().</p>   <h3 class="fn" id="setValue">
<code>[virtual] </code><span class="type">bool</span> QModbusServer::<span class="name">setValue</span>(<span class="type">int</span> <i>option</i>, const <span class="type"><a href="qvariant.html">QVariant</a></span> &amp;<i>newValue</i>)
</h3> <p>Sets the <i>newValue</i> for <i>option</i> and returns <code>true</code> on success; <code>false</code> otherwise.</p> <div class="admonition note"> <p><b>Note: </b>If the option's associated type is <code>quint8</code> or <code>quint16</code> and the type of <i>newValue</i> is larger, the data will be truncated or conversation will fail.</p> </div> <table class="generic"> <thead><tr class="qt-style">
<th>Key</th>
<th>Description</th>
</tr></thead> <tr class="odd" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::DiagnosticRegister</a></td>
<td>Sets the diagnostic register of the server in a device specific encoding to <i>newValue</i>. The default value preset is <code>0x0000</code>. The bit values of the register need device specific documentation.</td>
</tr> <tr class="even" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::ExceptionStatusOffset</a></td>
<td>Sets the exception status byte offset of the server to <i>newValue</i> which is the absolute offset address in the coils (0x register). Modbus register table starting with <code>0x0000h</code>. The default value preset is <code>0x0000</code>, using the exception status coils similar to Modicon 984 CPUs (coils 1-8).<p>The function returns <code>true</code> if the coils register contains the 8 bits required for storing and retrieving the status coils, otherwise <code>false</code>.</p> </td>
</tr> <tr class="odd" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::DeviceBusy</a></td>
<td>Sets a flag that signals that the server is engaged in processing a long-duration program command. Valid values are <code>0x0000</code> (not busy) and <code>0xffff</code> (busy). The default value preset is <code>0x0000</code>.</td>
</tr> <tr class="even" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::AsciiInputDelimiter</a></td>
<td>The <i>newValue</i> becomes the end of message delimiter for future Modbus ASCII messages. The default value preset is <code>\n</code>.</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::ListenOnlyMode</a></td>
<td>Ss the server's listen only state to <i>newValue</i>. If listen only mode is set to <code>true</code>, messages are monitored but no response will be sent. The default value preset is <code>false</code>.</td>
</tr> <tr class="even" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::ServerIdentifier</a></td>
<td>Sets the server's manufacturer identifier to <i>newValue</i>. Possible values are in the range of <code>0x00</code> to 0xff. The default value preset is <code>0x0a</code>.</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::RunIndicatorStatus</a></td>
<td>Sets the servers' run indicator status to <i>newValue</i>. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum">QModbusPdu::ReportServerId</a> function code. Valid values are <code>0x00</code> (OFF) and <code>0xff</code> (ON). The default value preset is <code>0xff</code> (ON).</td>
</tr> <tr class="even" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::AdditionalData</a></td>
<td>Sets the server's additional data to <i>newValue</i>. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum">QModbusPdu::ReportServerId</a> function code. The maximum data size cannot exceed 249 bytes to match response message size restrictions. The default value preset is <code>Qt Modbus Server</code>.</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::DeviceIdentification</a></td>
<td>Sets the server's physical and functional description. By default there is no additional device identification data set.</td>
</tr> <tr class="even" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::UserOption</a></td>
<td>Sets the value of a user option to <i>newValue</i>.<div class="admonition note"> <p><b>Note: </b>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</p> </div> </td>
</tr> </table> <p><b>See also </b><a href="qmodbusserver.html#value">value</a>().</p>   <h3 class="fn" id="value">
<code>[virtual] </code><span class="type"><a href="qvariant.html">QVariant</a></span> QModbusServer::<span class="name">value</span>(<span class="type">int</span> <i>option</i>) const
</h3> <p>Returns the value for <i>option</i> or an invalid <code>QVariant</code> if the option is not set.</p> <table class="generic"> <thead><tr class="qt-style">
<th>Option</th>
<th>Description</th>
</tr></thead> <tr class="odd" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::DiagnosticRegister</a></td>
<td>Returns the diagnostic register value of the server. The diagnostic register contains device specific contents where each bit has a specific meaning.</td>
</tr> <tr class="even" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::ExceptionStatusOffset</a></td>
<td>Returns the offset address of the exception status byte location in the coils register.</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::DeviceBusy</a></td>
<td>Returns a flag that signals if the server is engaged in processing a long-duration program command.</td>
</tr> <tr class="even" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::AsciiInputDelimiter</a></td>
<td>Returns a end of message delimiter of Modbus ASCII messages.</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::ListenOnlyMode</a></td>
<td>Returns the server's listen only state. Messages are monitored but no response will be sent.</td>
</tr> <tr class="even" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::ServerIdentifier</a></td>
<td>Returns the server manufacturer's identifier code. This can be an arbitrary value in the range of <code>0x00</code> to 0xff.</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::RunIndicatorStatus</a></td>
<td>Returns the server's run indicator status. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum">QModbusPdu::ReportServerId</a> function code.</td>
</tr> <tr class="even" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::AdditionalData</a></td>
<td>Returns the server's additional data. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum">QModbusPdu::ReportServerId</a> function code.</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::DeviceIdentification</a></td>
<td>Returns the server's physical and functional description.</td>
</tr> <tr class="even" valign="top">
<td><a href="qmodbusserver.html#Option-enum">QModbusServer::UserOption</a></td>
<td>Returns the value of a user option.<div class="admonition note"> <p><b>Note: </b>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</p> </div> </td>
</tr> </table> <p><b>See also </b><a href="qmodbusserver.html#setValue">setValue</a>().</p>   <h3 class="fn" id="writeData">
<code>[virtual protected] </code><span class="type">bool</span> QModbusServer::<span class="name">writeData</span>(const <span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> &amp;<i>newData</i>)
</h3> <p>Writes <i>newData</i> to the Modbus server map. Returns <code>true</code> on success, or <code>false</code> if the <i>newData</i> range is outside of the map range or the registerType() does not exist.</p> <div class="admonition note"> <p><b>Note: </b>Sub-classes that implement writing to a different backing store then default one, also need to implement <a href="qmodbusserver.html#setMap">setMap</a>() and <a href="qmodbusserver.html#readData">readData</a>(). The <a href="qmodbusserver.html#dataWritten">dataWritten</a>() signal needs to be emitted from within the functions implementation as well.</p> </div> <p><b>See also </b><a href="qmodbusserver.html#setMap">setMap</a>(), <a href="qmodbusserver.html#readData">readData</a>(), and <a href="qmodbusserver.html#dataWritten">dataWritten</a>().</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qmodbusserver.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qmodbusserver.html</a>
  </p>
</div>
