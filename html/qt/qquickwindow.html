<h1 class="title">QQuickWindow Class</h1>  <p>The QQuickWindow class provides the window for displaying a graphical QML scene. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QQuickWindow&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Quick REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Quick)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += quick</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.0</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Instantiated By:</td>
<td class="memItemRight bottomAlign"> <a href="qml-qtquick-window.html">Window</a>
</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qwindow.html">QWindow</a>
</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherited By:</td>
<td class="memItemRight bottomAlign"> <p><a href="qquickview.html">QQuickView</a></p> </td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qquickwindow-members.html">List of all members, including inherited members</a></li> <li><a href="https://doc.qt.io/qt-6.2/qquickwindow-obsolete.html">Deprecated members</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> struct </td>
<td class="memItemRight bottomAlign"><b><a href="qquickwindow-graphicsstateinfo.html">GraphicsStateInfo</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#CreateTextureOption-enum">CreateTextureOption</a></b> { TextureHasAlphaChannel, TextureHasMipmaps, TextureOwnsGLTexture, TextureCanUseAtlas, TextureIsOpaque }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qquickwindow.html#CreateTextureOption-enum">CreateTextureOptions</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#RenderStage-enum">RenderStage</a></b> { BeforeSynchronizingStage, AfterSynchronizingStage, BeforeRenderingStage, AfterRenderingStage, AfterSwapStage, NoStage }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#SceneGraphError-enum">SceneGraphError</a></b> { ContextNotAvailable }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#TextRenderType-enum">TextRenderType</a></b> { QtTextRendering, NativeTextRendering }</td>
</tr> </table> <h2 id="properties">Properties
</h2> <ul> <li class="fn">
<b><a href="qquickwindow.html#activeFocusItem-prop">activeFocusItem</a></b> : QQuickItem* const</li> <li class="fn">
<b><a href="qquickwindow.html#color-prop">color</a></b> : QColor</li> <li class="fn">
<b><a href="qquickwindow.html#contentItem-prop">contentItem</a></b> : QQuickItem* const</li> <li class="fn">
<b><a href="qquickwindow.html#transientParent-prop">transientParent</a></b> : QWindow* const</li> </ul> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#QQuickWindow">QQuickWindow</a></b>(QWindow *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#dtor.QQuickWindow">~QQuickWindow</a></b>() override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickItem *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#activeFocusItem-prop">activeFocusItem</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#beginExternalCommands">beginExternalCommands</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QColor </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#color-prop">color</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickItem *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#contentItem-prop">contentItem</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGImageNode *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#createImageNode">createImageNode</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGNinePatchNode *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#createNinePatchNode">createNinePatchNode</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGRectangleNode *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#createRectangleNode">createRectangleNode</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGTexture *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#createTextureFromImage">createTextureFromImage</a></b>(const QImage &amp;<i>image</i>, QQuickWindow::CreateTextureOptions <i>options</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGTexture *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#createTextureFromImage-1">createTextureFromImage</a></b>(const QImage &amp;<i>image</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qreal </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#effectiveDevicePixelRatio">effectiveDevicePixelRatio</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#endExternalCommands">endExternalCommands</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#grabWindow">grabWindow</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickGraphicsConfiguration </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#graphicsConfiguration">graphicsConfiguration</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickGraphicsDevice </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#graphicsDevice">graphicsDevice</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QQuickWindow::GraphicsStateInfo &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#graphicsStateInfo">graphicsStateInfo</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQmlIncubationController *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#incubationController">incubationController</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#isPersistentGraphics">isPersistentGraphics</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#isPersistentSceneGraph">isPersistentSceneGraph</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#isSceneGraphInitialized">isSceneGraphInitialized</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickRenderTarget </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#renderTarget">renderTarget</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGRendererInterface *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#rendererInterface">rendererInterface</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#scheduleRenderJob">scheduleRenderJob</a></b>(QRunnable *<i>job</i>, QQuickWindow::RenderStage <i>stage</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#color-prop">setColor</a></b>(const QColor &amp;<i>color</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#setGraphicsConfiguration">setGraphicsConfiguration</a></b>(const QQuickGraphicsConfiguration &amp;<i>config</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#setGraphicsDevice">setGraphicsDevice</a></b>(const QQuickGraphicsDevice &amp;<i>device</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#setPersistentGraphics">setPersistentGraphics</a></b>(bool <i>persistent</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#setPersistentSceneGraph">setPersistentSceneGraph</a></b>(bool <i>persistent</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#setRenderTarget">setRenderTarget</a></b>(const QQuickRenderTarget &amp;<i>target</i>)</td>
</tr> </table> <h2 id="reimplemented-public-functions">Reimplemented Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QAccessibleInterface *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#accessibleRoot">accessibleRoot</a></b>() const override</td>
</tr> </table> <h2 id="public-slots">Public Slots
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#releaseResources">releaseResources</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#update">update</a></b>()</td>
</tr> </table> <h2 id="signals">Signals
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#activeFocusItem-prop">activeFocusItemChanged</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#afterAnimating">afterAnimating</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#afterFrameEnd">afterFrameEnd</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#afterRenderPassRecording">afterRenderPassRecording</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#afterRendering">afterRendering</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#afterSynchronizing">afterSynchronizing</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#beforeFrameBegin">beforeFrameBegin</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#beforeRenderPassRecording">beforeRenderPassRecording</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#beforeRendering">beforeRendering</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#beforeSynchronizing">beforeSynchronizing</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#closing">closing</a></b>(QQuickCloseEvent *<i>close</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#color-prop">colorChanged</a></b>(const QColor &amp;)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#frameSwapped">frameSwapped</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#sceneGraphAboutToStop">sceneGraphAboutToStop</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#sceneGraphError">sceneGraphError</a></b>(QQuickWindow::SceneGraphError <i>error</i>, const QString &amp;<i>message</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#sceneGraphInitialized">sceneGraphInitialized</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#sceneGraphInvalidated">sceneGraphInvalidated</a></b>()</td>
</tr> </table> <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGRendererInterface::GraphicsApi </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#graphicsApi">graphicsApi</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#hasDefaultAlphaBuffer">hasDefaultAlphaBuffer</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#sceneGraphBackend">sceneGraphBackend</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#setDefaultAlphaBuffer">setDefaultAlphaBuffer</a></b>(bool <i>useAlpha</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#setGraphicsApi">setGraphicsApi</a></b>(QSGRendererInterface::GraphicsApi <i>api</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#setSceneGraphBackend">setSceneGraphBackend</a></b>(const QString &amp;<i>backend</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#setTextRenderType">setTextRenderType</a></b>(QQuickWindow::TextRenderType <i>renderType</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickWindow::TextRenderType </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#textRenderType">textRenderType</a></b>()</td>
</tr> </table> <h2 id="reimplemented-protected-functions">Reimplemented Protected Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#closeEvent">closeEvent</a></b>(QCloseEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#event">event</a></b>(QEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#exposeEvent">exposeEvent</a></b>(QExposeEvent *) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#focusInEvent">focusInEvent</a></b>(QFocusEvent *<i>ev</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#focusOutEvent">focusOutEvent</a></b>(QFocusEvent *<i>ev</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#hideEvent">hideEvent</a></b>(QHideEvent *) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#keyPressEvent">keyPressEvent</a></b>(QKeyEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#keyReleaseEvent">keyReleaseEvent</a></b>(QKeyEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a></b>(QMouseEvent *<i>event</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#mouseMoveEvent">mouseMoveEvent</a></b>(QMouseEvent *<i>event</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#mousePressEvent">mousePressEvent</a></b>(QMouseEvent *<i>event</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#mouseReleaseEvent">mouseReleaseEvent</a></b>(QMouseEvent *<i>event</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#resizeEvent">resizeEvent</a></b>(QResizeEvent *<i>ev</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#showEvent">showEvent</a></b>(QShowEvent *) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#tabletEvent">tabletEvent</a></b>(QTabletEvent *<i>event</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwindow.html#wheelEvent">wheelEvent</a></b>(QWheelEvent *<i>event</i>) override</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>QQuickWindow provides the graphical scene management needed to interact with and display a scene of QQuickItems.</p> <p>A QQuickWindow always has a single invisible root item. To add items to this window, reparent the items to the root item or to an existing item in the scene.</p> <p>For easily displaying a scene from a QML file, see <a href="qquickview.html">QQuickView</a>.</p> <h3 id="rendering">Rendering
</h3> <p>QQuickWindow uses a scene graph to represent what needs to be rendered. This scene graph is disconnected from the QML scene and potentially lives in another thread, depending on the platform implementation. Since the rendering scene graph lives independently from the QML scene, it can also be completely released without affecting the state of the QML scene.</p> <p>The <a href="qquickwindow.html#sceneGraphInitialized">sceneGraphInitialized</a>() signal is emitted on the rendering thread before the QML scene is rendered to the screen for the first time. If the rendering scene graph has been released, the signal will be emitted again before the next frame is rendered. A visible, on-screen QQuickWindow is driven internally by a <code>render loop</code>, of which there are multiple implementations provided in the scene graph. For details on the scene graph rendering process, see <a href="qtquick-visualcanvas-scenegraph.html">Qt Quick Scene Graph</a>.</p> <p>By default, a QQuickWindow renders using an accelerated 3D graphics API, such as OpenGL or Vulkan. See <a href="qtquick-visualcanvas-adaptations.html">Scene Graph Adaptations</a> for a detailed overview of scene graph backends and the supported graphics APIs.</p> <div class="admonition warning"> <p><b>Warning: </b>It is crucial that graphics operations and interaction with the scene graph happens exclusively on the rendering thread, primarily during the updatePaintNode() phase.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>As many of the signals related to rendering are emitted from the rendering thread, connections should be made using <a href="qt.html#ConnectionType-enum">Qt::DirectConnection</a>.</p> </div> <h4 id="integration-with-accelerated-3d-graphics-apis">Integration with Accelerated 3D Graphics APIs
</h4> <p>It is possible to integrate OpenGL, Vulkan, Metal, or Direct3D 11 calls directly into the QQuickWindow, as long as the QQuickWindow and the underlying scene graph is rendering using the same API. To access native graphics objects, such as device or context object handles, use <a href="qsgrendererinterface.html">QSGRendererInterface</a>. An instance of <a href="qsgrendererinterface.html">QSGRendererInterface</a> is queriable from QQuickWindow by calling <a href="qquickwindow.html#rendererInterface">rendererInterface</a>(). The enablers for this integration are the <a href="qquickwindow.html#beforeRendering">beforeRendering</a>(), <a href="qquickwindow.html#beforeRenderPassRecording">beforeRenderPassRecording</a>(), <a href="qquickwindow.html#afterRenderPassRecording">afterRenderPassRecording</a>(), and related signals. These allow rendering underlays or overlays. Alternatively, <a href="qnativeinterface-qsgopengltexture.html">QNativeInterface::QSGOpenGLTexture</a>, <a href="qnativeinterface-qsgvulkantexture.html">QNativeInterface::QSGVulkanTexture</a>, and other similar classes allow wrapping an existing native texture or image object in a <a href="qsgtexture.html">QSGTexture</a> that can then be used with the scene graph.</p> <h4 id="rendering-without-acceleration">Rendering without Acceleration
</h4> <p>A limited, pure software based rendering path is available as well. With the <code>software</code> backend, a number of Qt Quick features are not available, QML items relying on these will not be rendered at all. At the same time, this allows QQuickWindow to be functional even on systems where there is no 3D graphics API available at all. See <a href="qtquick-visualcanvas-adaptations-software.html">Qt Quick Software Adaptation</a> for more details.</p> <h4 id="redirected-rendering">Redirected Rendering
</h4> <p>A QQuickWindow is not necessarily backed by a native window on screen. The rendering can be redirected to target a custom render target, such as a given native texture. This is achieved in combination with the <a href="qquickrendercontrol.html">QQuickRenderControl</a> class, and functions such as <a href="qquickwindow.html#setRenderTarget">setRenderTarget</a>(), <a href="qquickwindow.html#setGraphicsDevice">setGraphicsDevice</a>(), and <a href="qquickwindow.html#setGraphicsConfiguration">setGraphicsConfiguration</a>().</p> <p>In this case, the QQuickWindow represents the scene, and provides the intrastructure for rendering a frame. It will not be backed by a render loop and a native window. Instead, in this case the application drives rendering, effectively substituting for the render loops. This allows generating image sequences, rendering into textures for use in external 3D engines, or rendering Qt Quick content within a VR environment.</p> <h4 id="resource-management">Resource Management
</h4> <p>QML will try to cache images and scene graph nodes to improve performance, but in some low-memory scenarios it might be required to aggressively release these resources. The <a href="qquickwindow.html#releaseResources">releaseResources</a>() function can be used to force the clean up of certain resources, especially resource that are cached and can be recreated later when needed again.</p> <p>Additionally, calling <a href="qquickwindow.html#releaseResources">releaseResources</a>() may result in releasing the entire scene graph and the associated graphics resources. The <a href="qquickwindow.html#sceneGraphInvalidated">sceneGraphInvalidated</a>() signal will be emitted when this happens. This behavior is controlled by the <a href="qquickwindow.html#setPersistentGraphics">setPersistentGraphics</a>() and <a href="qquickwindow.html#setPersistentSceneGraph">setPersistentSceneGraph</a>() functions.</p> <div class="admonition note"> <p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering">Scene Graph and Rendering</a> for more information.</p> </div> <h4 id="exposure-and-visibility">Exposure and Visibility
</h4> <p>When a QQuickWindow instance is deliberately hidden with <a href="qwindow.html#hide">hide</a>() or setVisible(false), it will stop rendering and its scene graph and graphics context might be released as well. This depends on the settings configured by <a href="qquickwindow.html#setPersistentGraphics">setPersistentGraphics</a>() and <a href="qquickwindow.html#setPersistentSceneGraph">setPersistentSceneGraph</a>(). The behavior in this respect is identical to explicitly calling the <a href="qquickwindow.html#releaseResources">releaseResources</a>() function. A window can become not exposed, in other words non-renderable, by other means as well. This depends on the platform and windowing system. For example, on Windows minimizing a window makes it stop rendering. On macOS fully obscuring a window by other windows on top triggers the same. On Linux/X11, the behavior is dependent on the window manager.</p> <h4 id="opengl-context-and-surface-formats">OpenGL Context and Surface Formats
</h4> <p>While it is possible to specify a <a href="qsurfaceformat.html">QSurfaceFormat</a> for every QQuickWindow by calling the member function <a href="qwindow.html#setFormat">setFormat</a>(), windows may also be created from QML by using the Window and <a href="qml-qtquick-controls2-applicationwindow.html">ApplicationWindow</a> elements. In this case there is no C++ code involved in the creation of the window instance, yet applications may still wish to set certain surface format values, for example to request a given OpenGL version or profile. Such applications can call the static function <a href="qsurfaceformat.html#setDefaultFormat">QSurfaceFormat::setDefaultFormat</a>() at startup. The specified format will be used for all Quick windows created afterwards.</p> <h4 id="vulkan-instance">Vulkan Instance
</h4> <p>When using Vulkan, a QQuickWindow is automatically associated with a <a href="qvulkaninstance.html">QVulkanInstance</a> that is created and managed internally by the scene graph. This way most applications do not need to worry about having a <code>VkInstance</code> available since it all happens automatically. In advanced cases an application may wish to create its own <a href="qvulkaninstance.html">QVulkanInstance</a>, in order to configure it in a specific way. That is possible as well. Calling <a href="qwindow.html#setVulkanInstance">setVulkanInstance</a>() on the QQuickWindow right after construction, before making it visible, leads to using the application-supplied <a href="qvulkaninstance.html">QVulkanInstance</a> (and the underlying <code>VkInstance</code>). When redirecting via <a href="qquickrendercontrol.html">QQuickRenderControl</a>, there is no <a href="qvulkaninstance.html">QVulkanInstance</a> provided automatically, but rather the application is expected to provide its own and associate it with the QQuickWindow.</p> <h4 id="graphics-contexts-and-devices">Graphics Contexts and Devices
</h4> <p>When the scene graph is initialized, which typically happens when the window becomes exposed or, in case of redirected rendering, initialization is performed <a href="qquickrendercontrol.html#initialize">via QQuickRenderControl</a>, the context or device objects necessary for rendering are created automatically. This includes OpenGL contexts, Direct3D devices and device contexts, Vulkan and Metal devices. These are also queriable by application code afterwards via <a href="qsgrendererinterface.html#getResource">QSGRendererInterface</a>. When using the <code>basic</code> render loop, which performs all rendering on the GUI thread, the same context or device is used with all visible QQuickWindows. The <code>threaded</code> render loop uses a dedicated context or device object for each rendering thread, and so for each QQuickWindow. With some graphics APIs, there is a degree of customizability provided via <a href="qquickwindow.html#setGraphicsConfiguration">setGraphicsConfiguration</a>(). This makes it possible, for example, to specify the list of Vulkan extensions to enable on the <code>VkDevice</code>. Alternatively, it is also possible to provide a set of existing context or device objects for use by the QQuickWindow, instead of letting it construct its own. This is achieved through <a href="qquickwindow.html#setGraphicsDevice">setGraphicsDevice</a>().</p>  <p><b>See also </b><a href="qquickview.html">QQuickView</a>, <a href="qquickrendercontrol.html">QQuickRenderControl</a>, <a href="qquickrendertarget.html">QQuickRenderTarget</a>, <a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a>, <a href="qquickgraphicsconfiguration.html">QQuickGraphicsConfiguration</a>, and <a href="qsgrendererinterface.html">QSGRendererInterface</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="flags" id="CreateTextureOption-enum">enum QQuickWindow::<span class="name">CreateTextureOption</span>flags QQuickWindow::<span class="name">CreateTextureOptions</span>
</h3> <p>The CreateTextureOption enums are used to customize a texture is wrapped.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::TextureHasAlphaChannel</code></td>
<td class="topAlign tblval"><code>0x0001</code></td>
<td class="topAlign">The texture has an alpha channel and should be drawn using blending.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::TextureHasMipmaps</code></td>
<td class="topAlign tblval"><code>0x0002</code></td>
<td class="topAlign">The texture has mipmaps and can be drawn with mipmapping enabled.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::TextureOwnsGLTexture</code></td>
<td class="topAlign tblval"><code>0x0004</code></td>
<td class="topAlign">As of Qt 6.0, this flag is not used in practice and is ignored. Native graphics resource ownership is not transferable to the wrapping <a href="qsgtexture.html">QSGTexture</a>, because Qt Quick may not have the necessary details on how such an object and the associated memory should be freed.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::TextureCanUseAtlas</code></td>
<td class="topAlign tblval"><code>0x0008</code></td>
<td class="topAlign">The image can be uploaded into a texture atlas.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::TextureIsOpaque</code></td>
<td class="topAlign tblval"><code>0x0010</code></td>
<td class="topAlign">The texture will return false for <a href="qsgtexture.html#hasAlphaChannel">QSGTexture::hasAlphaChannel</a>() and will not be blended. This flag was added in Qt 5.6.</td>
</tr> </table> <p>The CreateTextureOptions type is a typedef for <a href="qflags.html">QFlags</a>&lt;CreateTextureOption&gt;. It stores an OR combination of CreateTextureOption values.</p>   <h3 class="fn" id="RenderStage-enum">
<code>[since 5.4] </code>enum QQuickWindow::<span class="name">RenderStage</span>
</h3> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::BeforeSynchronizingStage</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">Before synchronization.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::AfterSynchronizingStage</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">After synchronization.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::BeforeRenderingStage</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">Before rendering.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::AfterRenderingStage</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">After rendering.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::AfterSwapStage</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">After the frame is swapped.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::NoStage</code></td>
<td class="topAlign tblval"><code>5</code></td>
<td class="topAlign">As soon as possible. This value was added in Qt 5.6.</td>
</tr> </table> <p>This enum was introduced or modified in Qt 5.4.</p> <p><b>See also </b><a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering">Scene Graph and Rendering</a>.</p>   <h3 class="fn" id="SceneGraphError-enum">
<code>[since 5.3] </code>enum QQuickWindow::<span class="name">SceneGraphError</span>
</h3> <p>This enum describes the error in a <a href="qquickwindow.html#sceneGraphError">sceneGraphError</a>() signal.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::ContextNotAvailable</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">graphics context creation failed. This typically means that no suitable OpenGL implementation was found, for example because no graphics drivers are installed and so no OpenGL 2 support is present. On mobile and embedded boards that use OpenGL ES such an error is likely to indicate issues in the windowing system integration and possibly an incorrect configuration of Qt.</td>
</tr> </table> <p>This enum was introduced or modified in Qt 5.3.</p>   <h3 class="fn" id="TextRenderType-enum">
<code>[since 5.10] </code>enum QQuickWindow::<span class="name">TextRenderType</span>
</h3> <p>This enum describes the default render type of text-like elements in Qt Quick (<a href="qml-qtquick-text.html">Text</a>, <a href="qml-qtquick-textinput.html">TextInput</a>, etc.).</p> <p>Select NativeTextRendering if you prefer text to look native on the target platform and do not require advanced features such as transformation of the text. Using such features in combination with the NativeTextRendering render type will lend poor and sometimes pixelated results.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::QtTextRendering</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">Use Qt's own rasterization algorithm.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWindow::NativeTextRendering</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">Use the operating system's native rasterizer for text.</td>
</tr> </table> <p>This enum was introduced or modified in Qt 5.10.</p>   <div class="prop"> <h2>Property Documentation</h2>  <h3 class="fn" id="activeFocusItem-prop">
<code>[read-only] </code><span class="name">activeFocusItem</span> : <span class="type"><a href="qquickitem.html">QQuickItem</a></span>* const
</h3> <p>This property holds the item which currently has active focus or <code>null</code> if there is no item with active focus.</p> <p><b>Access functions:</b></p> <table class="alignedsummary"> <tr>
<td class="memItemLeft topAlign rightAlign"> QQuickItem *</td>
<td class="memItemRight bottomAlign">
<span class="name"><b>activeFocusItem</b></span>() const</td>
</tr> </table> <p><b>Notifier signal:</b></p> <table class="alignedsummary"> <tr>
<td class="memItemLeft topAlign rightAlign"> void </td>
<td class="memItemRight bottomAlign">
<span class="name"><b>activeFocusItemChanged</b></span>()</td>
</tr> </table>   <h3 class="fn" id="color-prop">
<span class="name">color</span> : <span class="type"><a href="qcolor.html">QColor</a></span>
</h3> <p>This property holds the color used to clear the color buffer at the beginning of each frame.</p> <p>By default, the clear color is white.</p> <p><b>Access functions:</b></p> <table class="alignedsummary"> <tr>
<td class="memItemLeft topAlign rightAlign"> QColor </td>
<td class="memItemRight bottomAlign">
<span class="name"><b>color</b></span>() const</td>
</tr> <tr>
<td class="memItemLeft topAlign rightAlign"> void </td>
<td class="memItemRight bottomAlign">
<span class="name"><b>setColor</b></span>(const QColor &amp;<i>color</i>)</td>
</tr> </table> <p><b>Notifier signal:</b></p> <table class="alignedsummary"> <tr>
<td class="memItemLeft topAlign rightAlign"> void </td>
<td class="memItemRight bottomAlign">
<span class="name"><b>colorChanged</b></span>(const QColor &amp;)</td>
</tr> </table> <p><b>See also </b><a href="qquickwindow.html#setDefaultAlphaBuffer">setDefaultAlphaBuffer</a>().</p>   <h3 class="fn" id="contentItem-prop">
<code>[read-only] </code><span class="name">contentItem</span> : <span class="type"><a href="qquickitem.html">QQuickItem</a></span>* const
</h3> <p>This property holds the invisible root item of the scene.</p> <p>A <a href="qquickwindow.html">QQuickWindow</a> always has a single invisible root item containing all of its content. To add items to this window, reparent the items to the contentItem or to an existing item in the scene.</p> <p><b>Access functions:</b></p> <table class="alignedsummary"> <tr>
<td class="memItemLeft topAlign rightAlign"> QQuickItem *</td>
<td class="memItemRight bottomAlign">
<span class="name"><b>contentItem</b></span>() const</td>
</tr> </table>   <h3 class="fn" id="transientParent-prop">
<code>[since 5.13] </code><span class="name">transientParent</span> : <span class="type"><a href="qwindow.html#QWindow">QWindow</a></span>* const
</h3> <p>This property holds the window for which this window is a transient pop-up.</p> <p>This is a hint to the window manager that this window is a dialog or pop-up on behalf of the transient parent, which may be any kind of <a href="qwindow.html">QWindow</a>.</p> <p>In order to cause the window to be centered above its transient parent by default, depending on the window manager, it may also be necessary to set the <a href="qwindow.html#flags-prop">flags</a> property with a suitable <a href="qt.html#WindowType-enum">Qt::WindowType</a> (such as <code>Qt::Dialog</code>).</p> <p>This property was introduced in Qt 5.13.</p> <p><b>See also </b><a href="qwindow.html#parent">parent</a>().</p>  </div>  <h2>Member Function Documentation</h2>  <h3 class="fn" id="QQuickWindow">QQuickWindow::<span class="name">QQuickWindow</span>(<span class="type"><a href="qwindow.html#QWindow">QWindow</a></span> *<i>parent</i> = nullptr)
</h3> <p>Constructs a window for displaying a QML scene with parent window <i>parent</i>.</p>   <h3 class="fn" id="afterAnimating">
<code>[signal, since 5.3] </code><span class="type">void</span> QQuickWindow::<span class="name">afterAnimating</span>()
</h3> <p>This signal is emitted on the GUI thread before requesting the render thread to perform the synchronization of the scene graph.</p> <p>Unlike the other similar signals, this one is emitted on the GUI thread instead of the render thread. It can be used to synchronize external animation systems with the QML content. At the same time this means that this signal is not suitable for triggering graphics operations.</p> <p>This function was introduced in Qt 5.3.</p>   <h3 class="fn" id="afterFrameEnd">
<code>[signal, since 6.0] </code><span class="type">void</span> QQuickWindow::<span class="name">afterFrameEnd</span>()
</h3> <p>This signal is emitted when the scene graph has submitted a frame. This is emitted after all other related signals, such as <a href="qquickwindow.html#afterRendering">afterRendering</a>(). It is the last signal that is emitted by the scene graph rendering thread when rendering a frame.</p> <div class="admonition note"> <p><b>Note: </b>Unlike <a href="qquickwindow.html#frameSwapped">frameSwapped</a>(), this signal is guaranteed to be emitted also when the Qt Quick output is redirected via <a href="qquickrendercontrol.html">QQuickRenderControl</a>.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a>).</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickwindow.html#beforeFrameBegin">beforeFrameBegin</a>() and <a href="qquickwindow.html#rendererInterface">rendererInterface</a>().</p>   <h3 class="fn" id="afterRenderPassRecording">
<code>[signal, since 5.14] </code><span class="type">void</span> QQuickWindow::<span class="name">afterRenderPassRecording</span>()
</h3> <p>This signal is emitted after the scenegraph has recorded the commands for its main render pass, but the pass is not yet finalized on the command buffer.</p> <p>This signal is emitted earlier than <a href="qquickwindow.html#afterRendering">afterRendering</a>(), and it guarantees that not just the frame but also the recording of the scenegraph's main render pass is still active. This allows inserting commands without having to generate an entire, separate render pass (which would typically clear the attached images). The native graphics objects can be queried via <a href="qsgrendererinterface.html">QSGRendererInterface</a>.</p> <div class="admonition note"> <p><b>Note: </b>Resource updates (uploads, copies) typically cannot be enqueued from within a render pass. Therefore, more complex user rendering will need to connect to both <a href="qquickwindow.html#beforeRendering">beforeRendering</a>() and this signal.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a>).</p> </div> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qquickwindow.html#rendererInterface">rendererInterface</a>().</p>   <h3 class="fn" id="afterRendering">
<code>[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">afterRendering</span>()
</h3> <p>The signal is emitted after scene graph has added its commands to the command buffer, which is not yet submitted to the graphics queue. If desired, the slot function connected to this signal can query native resources, like the command buffer, before via <a href="qsgrendererinterface.html">QSGRendererInterface</a>. Note however that the render pass (or passes) are already recorded at this point and it is not possible to add more commands within the scenegraph's pass. Instead, use <a href="qquickwindow.html#afterRenderPassRecording">afterRenderPassRecording</a>() for that. This signal has therefore limited use in Qt 6, unlike in Qt 5. Rather, it is the combination of <a href="qquickwindow.html#beforeRendering">beforeRendering</a>() and <a href="qquickwindow.html#beforeRenderPassRecording">beforeRenderPassRecording</a>(), or <a href="qquickwindow.html#beforeRendering">beforeRendering</a>() and <a href="qquickwindow.html#afterRenderPassRecording">afterRenderPassRecording</a>(), that is typically used to achieve under- or overlaying of the custom rendering.</p> <p>When using OpenGL, the <a href="qopenglcontext.html">QOpenGLContext</a> used for rendering by the scene graph will be bound at this point.</p> <div class="admonition warning"> <p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a>).</p> </div> <div class="admonition warning"> <p><b>Warning: </b>When using OpenGL, be aware that setting OpenGL 3.x or 4.x specific states and leaving these enabled or set to non-default values when returning from the connected slot can interfere with the scene graph's rendering.</p> </div> <p><b>See also </b><a href="qquickwindow.html#rendererInterface">rendererInterface</a>(), <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-openglunderqml-example.html">Scene Graph - OpenGL Under QML</a>, <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-metalunderqml-example.html">Scene Graph - Metal Under QML</a>, <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-vulkanunderqml-example.html">Scene Graph - Vulkan Under QML</a>, and <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-d3d11underqml-example.html">Scene Graph - Direct3D 11 Under QML</a>.</p>   <h3 class="fn" id="afterSynchronizing">
<code>[signal, since 5.3] </code><span class="type">void</span> QQuickWindow::<span class="name">afterSynchronizing</span>()
</h3> <p>This signal is emitted after the scene graph is synchronized with the QML state.</p> <p>This signal can be used to do preparation required after calls to <a href="qquickitem.html#updatePaintNode">QQuickItem::updatePaintNode</a>(), while the GUI thread is still locked.</p> <p>When using OpenGL, the <a href="qopenglcontext.html">QOpenGLContext</a> used for rendering by the scene graph will be bound at this point.</p> <div class="admonition warning"> <p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a>).</p> </div> <div class="admonition warning"> <p><b>Warning: </b>When using OpenGL, be aware that setting OpenGL 3.x or 4.x specific states and leaving these enabled or set to non-default values when returning from the connected slot can interfere with the scene graph's rendering.</p> </div> <p>This function was introduced in Qt 5.3.</p>   <h3 class="fn" id="beforeFrameBegin">
<code>[signal, since 6.0] </code><span class="type">void</span> QQuickWindow::<span class="name">beforeFrameBegin</span>()
</h3> <p>This signal is emitted before the scene graph starts preparing the frame. This precedes signals like <a href="qquickwindow.html#beforeSynchronizing">beforeSynchronizing</a>() or <a href="qquickwindow.html#beforeRendering">beforeRendering</a>(). It is the earliest signal that is emitted by the scene graph rendering thread when starting to prepare a new frame.</p> <p>This signal is relevant for lower level graphics frameworks that need to execute certain operations, such as resource cleanup, at a stage where Qt Quick has not initiated the recording of a new frame via the underlying rendering hardware interface APIs.</p> <div class="admonition warning"> <p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a>).</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickwindow.html#afterFrameEnd">afterFrameEnd</a>() and <a href="qquickwindow.html#rendererInterface">rendererInterface</a>().</p>   <h3 class="fn" id="beforeRenderPassRecording">
<code>[signal, since 5.14] </code><span class="type">void</span> QQuickWindow::<span class="name">beforeRenderPassRecording</span>()
</h3> <p>This signal is emitted before the scenegraph starts recording commands for the main render pass. (Layers have their own passes and are fully recorded by the time this signal is emitted.) The render pass is already active on the command buffer when the signal is emitted.</p> <p>This signal is emitted later than <a href="qquickwindow.html#beforeRendering">beforeRendering</a>() and it guarantees that not just the frame, but also the recording of the scenegraph's main render pass is active. This allows inserting commands without having to generate an entire, separate render pass (which would typically clear the attached images). The native graphics objects can be queried via <a href="qsgrendererinterface.html">QSGRendererInterface</a>.</p> <div class="admonition note"> <p><b>Note: </b>Resource updates (uploads, copies) typically cannot be enqueued from within a render pass. Therefore, more complex user rendering will need to connect to both <a href="qquickwindow.html#beforeRendering">beforeRendering</a>() and this signal.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a>).</p> </div> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qquickwindow.html#rendererInterface">rendererInterface</a>().</p>   <h3 class="fn" id="beforeRendering">
<code>[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">beforeRendering</span>()
</h3> <p>This signal is emitted after the preparations for the frame have been done, meaning there is a command buffer in recording mode, where applicable. If desired, the slot function connected to this signal can query native resources like the command before via <a href="qsgrendererinterface.html">QSGRendererInterface</a>. Note however that the recording of the main render pass is not yet started at this point and it is not possible to add commands within that pass. Starting a pass means clearing the color, depth, and stencil buffers so it is not possible to achieve an underlay type of rendering by just connecting to this signal. Rather, connect to <a href="qquickwindow.html#beforeRenderPassRecording">beforeRenderPassRecording</a>(). However, connecting to this signal is still important if the recording of copy type of commands is desired since those cannot be enqueued within a render pass.</p> <p>When using OpenGL, the <a href="qopenglcontext.html">QOpenGLContext</a> used for rendering by the scene graph will be bound at this point.</p> <div class="admonition warning"> <p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a>).</p> </div> <div class="admonition warning"> <p><b>Warning: </b>When using OpenGL, be aware that setting OpenGL 3.x or 4.x specific states and leaving these enabled or set to non-default values when returning from the connected slot can interfere with the scene graph's rendering.</p> </div> <p><b>See also </b><a href="qquickwindow.html#rendererInterface">rendererInterface</a>(), <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-openglunderqml-example.html">Scene Graph - OpenGL Under QML</a>, <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-metalunderqml-example.html">Scene Graph - Metal Under QML</a>, <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-vulkanunderqml-example.html">Scene Graph - Vulkan Under QML</a>, and <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-d3d11underqml-example.html">Scene Graph - Direct3D 11 Under QML</a>.</p>   <h3 class="fn" id="beforeSynchronizing">
<code>[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">beforeSynchronizing</span>()
</h3> <p>This signal is emitted before the scene graph is synchronized with the QML state.</p> <p>Even though the signal is emitted from the scene graph rendering thread, the GUI thread is guaranteed to be blocked, like it is in <a href="qquickitem.html#updatePaintNode">QQuickItem::updatePaintNode</a>(). Therefore, it is safe to access GUI thread thread data in a slot or lambda that is connected with <a href="qt.html#ConnectionType-enum">Qt::DirectConnection</a>.</p> <p>This signal can be used to do any preparation required before calls to <a href="qquickitem.html#updatePaintNode">QQuickItem::updatePaintNode</a>().</p> <p>When using OpenGL, the <a href="qopenglcontext.html">QOpenGLContext</a> used for rendering by the scene graph will be bound at this point.</p> <div class="admonition warning"> <p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a>).</p> </div> <div class="admonition warning"> <p><b>Warning: </b>When using OpenGL, be aware that setting OpenGL 3.x or 4.x specific states and leaving these enabled or set to non-default values when returning from the connected slot can interfere with the scene graph's rendering.</p> </div>   <h3 class="fn" id="closing">
<code>[signal, since 5.1] </code><span class="type">void</span> QQuickWindow::<span class="name">closing</span>(<span class="type">QQuickCloseEvent</span> *<i>close</i>)
</h3> <p>This signal is emitted when the window receives the event <i>close</i> from the windowing system.</p> <p>On macOs, Qt will create a menu item <code>Quit</code> if there is no menu item whose text is "quit" or "exit". This menu item calls the <code>QCoreApplication::quit</code> signal, not the <code>QQuickWindow::closing()</code> signal.</p> <p>This function was introduced in Qt 5.1.</p> <p><b>See also </b><a href="qmenubar.html#qmenubar-as-a-global-menu-bar">QMenuBar as a Global Menu Bar</a>.</p>   <h3 class="fn" id="frameSwapped">
<code>[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">frameSwapped</span>()
</h3> <p>This signal is emitted when a frame has been queued for presenting. With vertical synchronization enabled the signal is emitted at most once per vsync interval in a continuously animating scene.</p> <p>This signal will be emitted from the scene graph rendering thread.</p>   <h3 class="fn" id="releaseResources">
<code>[slot] </code><span class="type">void</span> QQuickWindow::<span class="name">releaseResources</span>()
</h3> <p>This function tries to release redundant resources currently held by the QML scene.</p> <p>Calling this function requests the scene graph to release cached graphics resources, such as graphics pipeline objects or shader programs.</p> <div class="admonition note"> <p><b>Note: </b>The releasing of cached graphics resources is not dependent on the hint from <a href="qquickwindow.html#setPersistentGraphics">setPersistentGraphics</a>().</p> </div> <p>Additionally, depending on the render loop in use, this function may also result in the scene graph and all rendering resources to be released. If this happens, the <a href="qquickwindow.html#sceneGraphInvalidated">sceneGraphInvalidated</a>() signal will be emitted, allowing users to clean up their own graphics resources. The <a href="qquickwindow.html#setPersistentGraphics">setPersistentGraphics</a>() and <a href="qquickwindow.html#setPersistentSceneGraph">setPersistentSceneGraph</a>() functions can be used to prevent this from happening, if handling the cleanup is not feasible in the application, at the cost of higher memory usage.</p> <p><b>See also </b><a href="qquickwindow.html#sceneGraphInvalidated">sceneGraphInvalidated</a>(), <a href="qquickwindow.html#setPersistentGraphics">setPersistentGraphics</a>(), and <a href="qquickwindow.html#setPersistentSceneGraph">setPersistentSceneGraph</a>().</p>   <h3 class="fn" id="sceneGraphAboutToStop">
<code>[signal, since 5.3] </code><span class="type">void</span> QQuickWindow::<span class="name">sceneGraphAboutToStop</span>()
</h3> <p>This signal is emitted on the render thread when the scene graph is about to stop rendering. This happens usually because the window has been hidden.</p> <p>Applications may use this signal to release resources, but should be prepared to reinstantiated them again fast. The scene graph and the graphics context are not released at this time.</p> <div class="admonition warning"> <p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a>).</p> </div> <div class="admonition warning"> <p><b>Warning: </b>Make very sure that a signal handler for sceneGraphAboutToStop() leaves the graphics context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</p> </div> <p>This function was introduced in Qt 5.3.</p> <p><b>See also </b><a href="qquickwindow.html#sceneGraphInvalidated">sceneGraphInvalidated</a>().</p>   <h3 class="fn" id="sceneGraphError">
<code>[signal, since 5.3] </code><span class="type">void</span> QQuickWindow::<span class="name">sceneGraphError</span>(<span class="type"><a href="qquickwindow.html#SceneGraphError-enum">QQuickWindow::SceneGraphError</a></span> <i>error</i>, const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>message</i>)
</h3> <p>This signal is emitted when an <i>error</i> occurred during scene graph initialization.</p> <p>Applications should connect to this signal if they wish to handle errors, like graphics context creation failures, in a custom way. When no slot is connected to the signal, the behavior will be different: Quick will print the <i>message</i>, or show a message box, and terminate the application.</p> <p>This signal will be emitted from the GUI thread.</p> <p>This function was introduced in Qt 5.3.</p>   <h3 class="fn" id="sceneGraphInitialized">
<code>[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">sceneGraphInitialized</span>()
</h3> <p>This signal is emitted when the scene graph has been initialized.</p> <p>This signal will be emitted from the scene graph rendering thread.</p>   <h3 class="fn" id="sceneGraphInvalidated">
<code>[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">sceneGraphInvalidated</span>()
</h3> <p>This signal is emitted when the scene graph has been invalidated.</p> <p>This signal implies that the graphics rendering context used has been invalidated and all user resources tied to that context should be released.</p> <p>When rendering with OpenGL, the <a href="qopenglcontext.html">QOpenGLContext</a> of this window will be bound when this function is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through EGL_CONTEXT_LOST.</p> <p>This signal will be emitted from the scene graph rendering thread.</p>   <h3 class="fn" id="update">
<code>[slot] </code><span class="type">void</span> QQuickWindow::<span class="name">update</span>()
</h3> <p>Schedules the window to render another frame.</p> <p>Calling QQuickWindow::update() differs from <a href="qquickitem.html#update">QQuickItem::update</a>() in that it always triggers a repaint, regardless of changes in the underlying scene graph or not.</p>   <h3 class="fn" id="dtor.QQuickWindow">
<code>[override virtual] </code>QQuickWindow::<span class="name">~QQuickWindow</span>()
</h3> <p>Destroys the window.</p>   <h3 class="fn" id="accessibleRoot">
<code>[override virtual] </code><span class="type"><a href="qaccessibleinterface.html">QAccessibleInterface</a></span> *QQuickWindow::<span class="name">accessibleRoot</span>() const
</h3> <p>Returns an accessibility interface for this window, or 0 if such an interface cannot be created.</p>   <h3 class="fn" id="beginExternalCommands">
<code>[since 5.14] </code><span class="type">void</span> QQuickWindow::<span class="name">beginExternalCommands</span>()
</h3> <p>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function before recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</p> <p>In practice this function is often called from a slot connected to the <a href="qquickwindow.html#beforeRenderPassRecording">beforeRenderPassRecording</a>() or <a href="qquickwindow.html#afterRenderPassRecording">afterRenderPassRecording</a>() signals.</p> <p>The function does not need to be called when recording commands to the application's own command buffer (such as, a VkCommandBuffer or MTLCommandBuffer + MTLRenderCommandEncoder created and managed by the application, not retrieved from the scene graph). With graphics APIs where no native command buffer concept is exposed (OpenGL, Direct 3D 11), beginExternalCommands() and <a href="qquickwindow.html#endExternalCommands">endExternalCommands</a>() together provide a replacement for the Qt 5 resetOpenGLState() function.</p> <p>Calling this function and <a href="qquickwindow.html#endExternalCommands">endExternalCommands</a>() is not necessary within the <a href="qsgrendernode.html#render">render</a>() implementation of a <a href="qsgrendernode.html">QSGRenderNode</a> because the scene graph performs the necessary steps implicitly for render nodes.</p> <p>Native graphics objects (such as, graphics device, command buffer or encoder) are accessible via <a href="qsgrendererinterface.html#getResource">QSGRendererInterface::getResource</a>().</p> <div class="admonition warning"> <p><b>Warning: </b>Watch out for the fact that <a href="qsgrendererinterface.html#Resource-enum">QSGRendererInterface::CommandListResource</a> may return a different object between beginExternalCommands() - <a href="qquickwindow.html#endExternalCommands">endExternalCommands</a>(). This can happen when the underlying implementation provides a dedicated secondary command buffer for recording external graphics commands within a render pass. Therefore, always query CommandListResource after calling this function. Do not attempt to reuse an object from an earlier query.</p> </div> <div class="admonition note"> <p><b>Note: </b>When the scenegraph is using OpenGL, pay attention to the fact that the OpenGL state in the context can have arbitrary settings, and this function does not perform any resetting of the state back to defaults.</p> </div> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qquickwindow.html#endExternalCommands">endExternalCommands</a>() and <a href="qquickopenglutils.html#resetOpenGLState">QQuickOpenGLUtils::resetOpenGLState</a>().</p>   <h3 class="fn" id="closeEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">closeEvent</span>(<span class="type"><a href="qcloseevent.html">QCloseEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwindow.html#closeEvent">QWindow::closeEvent</a>(QCloseEvent *ev).</p>   <h3 class="fn" id="createImageNode">
<code>[since 5.8] </code><span class="type"><a href="qsgimagenode.html">QSGImageNode</a></span> *QQuickWindow::<span class="name">createImageNode</span>() const
</h3> <p>Creates a simple image node. When the scenegraph is not initialized, the return value is null.</p> <p>This is cross-backend alternative to constructing a <a href="qsgsimpletexturenode.html">QSGSimpleTextureNode</a> directly.</p> <p>This function was introduced in Qt 5.8.</p> <p><b>See also </b><a href="qsgimagenode.html">QSGImageNode</a>.</p>   <h3 class="fn" id="createNinePatchNode">
<code>[since 5.8] </code><span class="type">QSGNinePatchNode</span> *QQuickWindow::<span class="name">createNinePatchNode</span>() const
</h3> <p>Creates a nine patch node. When the scenegraph is not initialized, the return value is null.</p> <p>This function was introduced in Qt 5.8.</p>   <h3 class="fn" id="createRectangleNode">
<code>[since 5.8] </code><span class="type"><a href="qsgrectanglenode.html">QSGRectangleNode</a></span> *QQuickWindow::<span class="name">createRectangleNode</span>() const
</h3> <p>Creates a simple rectangle node. When the scenegraph is not initialized, the return value is null.</p> <p>This is cross-backend alternative to constructing a <a href="qsgsimplerectnode.html">QSGSimpleRectNode</a> directly.</p> <p>This function was introduced in Qt 5.8.</p> <p><b>See also </b><a href="qsgrectanglenode.html">QSGRectangleNode</a>.</p>   <h3 class="fn" id="createTextureFromImage">
<span class="type"><a href="qsgtexture.html">QSGTexture</a></span> *QQuickWindow::<span class="name">createTextureFromImage</span>(const <span class="type"><a href="qimage.html">QImage</a></span> &amp;<i>image</i>, <span class="type"><a href="qquickwindow.html#CreateTextureOption-enum">QQuickWindow::CreateTextureOptions</a></span> <i>options</i>) const
</h3> <p>Creates a new <a href="qsgtexture.html">QSGTexture</a> from the supplied <i>image</i>. If the image has an alpha channel, the corresponding texture will have an alpha channel.</p> <p>The caller of the function is responsible for deleting the returned texture. The underlying native texture object is then destroyed together with the <a href="qsgtexture.html">QSGTexture</a>.</p> <p>When <i>options</i> contains <a href="qquickwindow.html#CreateTextureOption-enum">TextureCanUseAtlas</a>, the engine may put the image into a texture atlas. Textures in an atlas need to rely on <a href="qsgtexture.html#normalizedTextureSubRect">QSGTexture::normalizedTextureSubRect</a>() for their geometry and will not support <a href="qsgtexture.html#WrapMode-enum">QSGTexture::Repeat</a>. Other values from <a href="qquickwindow.html#CreateTextureOption-enum">CreateTextureOption</a> are ignored.</p> <p>When <i>options</i> contains <a href="qquickwindow.html#CreateTextureOption-enum">TextureIsOpaque</a>, the engine will create an RGB texture which returns false for <a href="qsgtexture.html#hasAlphaChannel">QSGTexture::hasAlphaChannel</a>(). Opaque textures will in most cases be faster to render. When this flag is not set, the texture will have an alpha channel based on the image's format.</p> <p>When <i>options</i> contains <a href="qquickwindow.html#CreateTextureOption-enum">TextureHasMipmaps</a>, the engine will create a texture which can use mipmap filtering. Mipmapped textures can not be in an atlas.</p> <p>When the scene graph uses OpenGL, the returned texture will be using <code>GL_TEXTURE_2D</code> as texture target and <code>GL_RGBA</code> as internal format. With other graphics APIs, the texture format is typically <code>RGBA8</code>. Reimplement <a href="qsgtexture.html">QSGTexture</a> to create textures with different parameters.</p> <div class="admonition warning"> <p><b>Warning: </b>This function will return 0 if the scene graph has not yet been initialized.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>The returned texture is not memory managed by the scene graph and must be explicitly deleted by the caller on the rendering thread. This is achieved by deleting the texture from a <a href="qsgnode.html">QSGNode</a> destructor or by using <a href="qobject.html#deleteLater">deleteLater</a>() in the case where the texture already has affinity to the rendering thread.</p> </div> <p>This function can be called from any thread.</p> <p><b>See also </b><a href="qquickwindow.html#sceneGraphInitialized">sceneGraphInitialized</a>() and <a href="qsgtexture.html">QSGTexture</a>.</p>   <h3 class="fn" id="createTextureFromImage-1">
<span class="type"><a href="qsgtexture.html">QSGTexture</a></span> *QQuickWindow::<span class="name">createTextureFromImage</span>(const <span class="type"><a href="qimage.html">QImage</a></span> &amp;<i>image</i>) const
</h3> <p>This is an overloaded function.</p>   <h3 class="fn" id="effectiveDevicePixelRatio">
<span class="type"><a href="qtglobal.html#qreal-typedef">qreal</a></span> QQuickWindow::<span class="name">effectiveDevicePixelRatio</span>() const
</h3> <p>Returns the device pixel ratio for this window.</p> <p>This is different from <a href="qwindow.html#devicePixelRatio">QWindow::devicePixelRatio</a>() in that it supports redirected rendering via <a href="qquickrendercontrol.html">QQuickRenderControl</a>. When using a <a href="qquickrendercontrol.html">QQuickRenderControl</a>, the <a href="qquickwindow.html">QQuickWindow</a> is often not created, meaning it is never shown and there is no underlying native window created in the windowing system. As a result, querying properties like the device pixel ratio cannot give correct results. Use this function instead.</p> <p><b>See also </b><a href="qwindow.html#devicePixelRatio">QWindow::devicePixelRatio</a>().</p>   <h3 class="fn" id="endExternalCommands">
<code>[since 5.14] </code><span class="type">void</span> QQuickWindow::<span class="name">endExternalCommands</span>()
</h3> <p>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function after recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</p> <p>In practice this function is often called from a slot connected to the <a href="qquickwindow.html#beforeRenderPassRecording">beforeRenderPassRecording</a>() or <a href="qquickwindow.html#afterRenderPassRecording">afterRenderPassRecording</a>() signals.</p> <p>The function does not need to be called when recording commands to the application's own command buffer (such as, a VkCommandBuffer or MTLCommandBuffer + MTLRenderCommandEncoder created and managed by the application, not retrieved from the scene graph). With graphics APIs where no native command buffer concept is exposed (OpenGL, Direct 3D 11), <a href="qquickwindow.html#beginExternalCommands">beginExternalCommands</a>() and endExternalCommands() together provide a replacement for the Qt 5 resetOpenGLState() function.</p> <p>Calling this function and <a href="qquickwindow.html#beginExternalCommands">beginExternalCommands</a>() is not necessary within the <a href="qsgrendernode.html#render">render</a>() implementation of a <a href="qsgrendernode.html">QSGRenderNode</a> because the scene graph performs the necessary steps implicitly for render nodes.</p> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qquickwindow.html#beginExternalCommands">beginExternalCommands</a>() and <a href="qquickopenglutils.html#resetOpenGLState">QQuickOpenGLUtils::resetOpenGLState</a>().</p>   <h3 class="fn" id="event">
<code>[override virtual protected] </code><span class="type">bool</span> QQuickWindow::<span class="name">event</span>(<span class="type"><a href="qevent.html">QEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwindow.html#event">QWindow::event</a>(QEvent *ev).</p>   <h3 class="fn" id="exposeEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">exposeEvent</span>(<span class="type"><a href="qexposeevent.html">QExposeEvent</a></span> *)
</h3> <p>Reimplements: <a href="qwindow.html#exposeEvent">QWindow::exposeEvent</a>(QExposeEvent *ev).</p>   <h3 class="fn" id="focusInEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">focusInEvent</span>(<span class="type"><a href="qfocusevent.html">QFocusEvent</a></span> *<i>ev</i>)
</h3> <p>Reimplements: <a href="qwindow.html#focusInEvent">QWindow::focusInEvent</a>(QFocusEvent *ev).</p>   <h3 class="fn" id="focusOutEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">focusOutEvent</span>(<span class="type"><a href="qfocusevent.html">QFocusEvent</a></span> *<i>ev</i>)
</h3> <p>Reimplements: <a href="qwindow.html#focusOutEvent">QWindow::focusOutEvent</a>(QFocusEvent *ev).</p>   <h3 class="fn" id="grabWindow">
<span class="type"><a href="qimage.html">QImage</a></span> QQuickWindow::<span class="name">grabWindow</span>()
</h3> <p>Grabs the contents of the window and returns it as an image.</p> <p>It is possible to call the grabWindow() function when the window is not visible. This requires that the window is <a href="qwindow.html#create">created</a> and has a valid size and that no other <a href="qquickwindow.html">QQuickWindow</a> instances are rendering in the same process.</p> <div class="admonition note"> <p><b>Note: </b>When using this window in combination with <a href="qquickrendercontrol.html">QQuickRenderControl</a>, the result of this function is an empty image, unless the <code>software</code> backend is in use. This is because when redirecting the output to an application-managed graphics resource (such as, a texture) by using <a href="qquickrendercontrol.html">QQuickRenderControl</a> and <a href="qquickwindow.html#setRenderTarget">setRenderTarget</a>(), the application is better suited for managing and executing an eventual read back operation, since it is in full control of the resource to begin with.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>Calling this function will cause performance problems.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>This function can only be called from the GUI thread.</p> </div>   <h3 class="fn" id="graphicsApi">
<code>[static, since 6.0] </code><span class="type"><a href="qsgrendererinterface.html#GraphicsApi-enum">QSGRendererInterface::GraphicsApi</a></span> QQuickWindow::<span class="name">graphicsApi</span>()
</h3> <p>Returns the graphics API that would be used by the scene graph if it was initialized at this point in time.</p> <p>The standard way to query the API used by the scene graph is to use <a href="qsgrendererinterface.html#graphicsApi">QSGRendererInterface::graphicsApi</a>() once the scene graph has initialized, for example when or after the <a href="qquickwindow.html#sceneGraphInitialized">sceneGraphInitialized</a>() signal is emitted. In that case one gets the true, real result, because then it is known that everything was initialized correctly using that graphics API.</p> <p>This is not always convenient. If the application needs to set up external frameworks, or needs to work with <a href="qquickwindow.html#setGraphicsDevice">setGraphicsDevice</a>() in a manner that depends on the scene graph's built in API selection logic, it is not always feasiable to defer such operations until after the <a href="qquickwindow.html">QQuickWindow</a> has been made visible or <a href="qquickrendercontrol.html#initialize">QQuickRenderControl::initialize</a>() has been called.</p> <p>Therefore, this static function is provided as a counterpart to <a href="qquickwindow.html#setGraphicsApi">setGraphicsApi</a>(): it can be called at any time, and the result reflects what API the scene graph would choose if it was initialized at the point of the call.</p> <div class="admonition note"> <p><b>Note: </b>This static function is intended to be called on the main (GUI) thread only. For querying the API when rendering, use <a href="qsgrendererinterface.html">QSGRendererInterface</a> since that object lives on the render thread.</p> </div> <div class="admonition note"> <p><b>Note: </b>This function does not take scene graph backends into account.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickwindow.html#setGraphicsApi">setGraphicsApi</a>().</p>   <h3 class="fn" id="graphicsConfiguration">
<code>[since 6.0] </code><span class="type"><a href="qquickgraphicsconfiguration.html">QQuickGraphicsConfiguration</a></span> QQuickWindow::<span class="name">graphicsConfiguration</span>() const
</h3> <p>Returns the <a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a> passed to <a href="qquickwindow.html#setGraphicsDevice">setGraphicsDevice</a>(), or a default constructed one otherwise</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickwindow.html#setGraphicsConfiguration">setGraphicsConfiguration</a>().</p>   <h3 class="fn" id="graphicsDevice">
<code>[since 6.0] </code><span class="type"><a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a></span> QQuickWindow::<span class="name">graphicsDevice</span>() const
</h3> <p>Returns the <a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a> passed to <a href="qquickwindow.html#setGraphicsDevice">setGraphicsDevice</a>(), or a default constructed one otherwise</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickwindow.html#setGraphicsDevice">setGraphicsDevice</a>().</p>   <h3 class="fn" id="graphicsStateInfo">const <span class="type"><a href="qquickwindow-graphicsstateinfo.html">QQuickWindow::GraphicsStateInfo</a></span> &amp;QQuickWindow::<span class="name">graphicsStateInfo</span>()
</h3> <p>Returns a reference to a <a href="qquickwindow-graphicsstateinfo.html">GraphicsStateInfo</a> struct describing some of the RHI's internal state, in particular, the double or tripple buffering status of the backend (such as, the Vulkan or Metal integrations). This is relevant when the underlying graphics APIs is Vulkan or Metal, and the external rendering code wishes to perform double or tripple buffering of its own often-changing resources, such as, uniform buffers, in order to avoid stalling the pipeline.</p>   <h3 class="fn" id="hasDefaultAlphaBuffer">
<code>[static, since 5.1] </code><span class="type">bool</span> QQuickWindow::<span class="name">hasDefaultAlphaBuffer</span>()
</h3> <p>Returns whether to use alpha transparency on newly created windows.</p> <p>This function was introduced in Qt 5.1.</p> <p><b>See also </b><a href="qquickwindow.html#setDefaultAlphaBuffer">setDefaultAlphaBuffer</a>().</p>   <h3 class="fn" id="hideEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">hideEvent</span>(<span class="type"><a href="qhideevent.html">QHideEvent</a></span> *)
</h3> <p>Reimplements: <a href="qwindow.html#hideEvent">QWindow::hideEvent</a>(QHideEvent *ev).</p>   <h3 class="fn" id="incubationController">
<span class="type"><a href="qqmlincubationcontroller.html">QQmlIncubationController</a></span> *QQuickWindow::<span class="name">incubationController</span>() const
</h3> <p>Returns an incubation controller that splices incubation between frames for this window. <a href="qquickview.html">QQuickView</a> automatically installs this controller for you, otherwise you will need to install it yourself using <a href="qqmlengine.html#setIncubationController">QQmlEngine::setIncubationController</a>().</p> <p>The controller is owned by the window and will be destroyed when the window is deleted.</p>   <h3 class="fn" id="isPersistentGraphics">
<span class="type">bool</span> QQuickWindow::<span class="name">isPersistentGraphics</span>() const
</h3> <p>Returns whether essential graphics resources can be released during the lifetime of the <a href="qquickwindow.html">QQuickWindow</a>.</p> <div class="admonition note"> <p><b>Note: </b>This is a hint, and is not guaranteed that it is taken into account.</p> </div> <p><b>See also </b><a href="qquickwindow.html#setPersistentGraphics">setPersistentGraphics</a>().</p>   <h3 class="fn" id="isPersistentSceneGraph">
<span class="type">bool</span> QQuickWindow::<span class="name">isPersistentSceneGraph</span>() const
</h3> <p>Returns whether the scene graph nodes and resources can be released during the lifetime of this <a href="qquickwindow.html">QQuickWindow</a>.</p> <div class="admonition note"> <p><b>Note: </b>This is a hint. When and how this happens is implementation specific.</p> </div>   <h3 class="fn" id="isSceneGraphInitialized">
<span class="type">bool</span> QQuickWindow::<span class="name">isSceneGraphInitialized</span>() const
</h3> <p>Returns true if the scene graph has been initialized; otherwise returns false.</p>   <h3 class="fn" id="keyPressEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">keyPressEvent</span>(<span class="type"><a href="qkeyevent.html">QKeyEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwindow.html#keyPressEvent">QWindow::keyPressEvent</a>(QKeyEvent *ev).</p>   <h3 class="fn" id="keyReleaseEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">keyReleaseEvent</span>(<span class="type"><a href="qkeyevent.html">QKeyEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwindow.html#keyReleaseEvent">QWindow::keyReleaseEvent</a>(QKeyEvent *ev).</p>   <h3 class="fn" id="mouseDoubleClickEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">mouseDoubleClickEvent</span>(<span class="type"><a href="qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)
</h3> <p>Reimplements: <a href="qwindow.html#mouseDoubleClickEvent">QWindow::mouseDoubleClickEvent</a>(QMouseEvent *ev).</p>   <h3 class="fn" id="mouseMoveEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">mouseMoveEvent</span>(<span class="type"><a href="qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)
</h3> <p>Reimplements: <a href="qwindow.html#mouseMoveEvent">QWindow::mouseMoveEvent</a>(QMouseEvent *ev).</p>   <h3 class="fn" id="mousePressEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">mousePressEvent</span>(<span class="type"><a href="qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)
</h3> <p>Reimplements: <a href="qwindow.html#mousePressEvent">QWindow::mousePressEvent</a>(QMouseEvent *ev).</p>   <h3 class="fn" id="mouseReleaseEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">mouseReleaseEvent</span>(<span class="type"><a href="qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)
</h3> <p>Reimplements: <a href="qwindow.html#mouseReleaseEvent">QWindow::mouseReleaseEvent</a>(QMouseEvent *ev).</p>   <h3 class="fn" id="renderTarget">
<code>[since 6.0] </code><span class="type"><a href="qquickrendertarget.html">QQuickRenderTarget</a></span> QQuickWindow::<span class="name">renderTarget</span>() const
</h3> <p>Returns the <a href="qquickrendertarget.html">QQuickRenderTarget</a> passed to <a href="qquickwindow.html#setRenderTarget">setRenderTarget</a>(), or a default constructed one otherwise</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickwindow.html#setRenderTarget">setRenderTarget</a>().</p>   <h3 class="fn" id="rendererInterface">
<code>[since 5.8] </code><span class="type"><a href="qsgrendererinterface.html">QSGRendererInterface</a></span> *QQuickWindow::<span class="name">rendererInterface</span>() const
</h3> <p>Returns the current renderer interface. The value is always valid and is never null.</p> <div class="admonition note"> <p><b>Note: </b>This function can be called at any time after constructing the <a href="qquickwindow.html">QQuickWindow</a>, even while <a href="qquickwindow.html#isSceneGraphInitialized">isSceneGraphInitialized</a>() is still false. However, some renderer interface functions, in particular <a href="qsgrendererinterface.html#getResource">QSGRendererInterface::getResource</a>() will not be functional until the scenegraph is up and running. Backend queries, like <a href="qsgrendererinterface.html#graphicsApi">QSGRendererInterface::graphicsApi</a>() or <a href="qsgrendererinterface.html#shaderType">QSGRendererInterface::shaderType</a>(), will always be functional on the other hand.</p> </div> <div class="admonition note"> <p><b>Note: </b>The ownership of the returned pointer stays with Qt. The returned instance may or may not be shared between different <a href="qquickwindow.html">QQuickWindow</a> instances, depending on the scenegraph backend in use. Therefore applications are expected to query the interface object for each <a href="qquickwindow.html">QQuickWindow</a> instead of reusing the already queried pointer.</p> </div> <p>This function was introduced in Qt 5.8.</p> <p><b>See also </b><a href="qsgrendernode.html">QSGRenderNode</a> and <a href="qsgrendererinterface.html">QSGRendererInterface</a>.</p>   <h3 class="fn" id="resizeEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">resizeEvent</span>(<span class="type"><a href="qresizeevent.html">QResizeEvent</a></span> *<i>ev</i>)
</h3> <p>Reimplements: <a href="qwindow.html#resizeEvent">QWindow::resizeEvent</a>(QResizeEvent *ev).</p>   <h3 class="fn" id="sceneGraphBackend">
<code>[static, since 5.9] </code><span class="type"><a href="qstring.html">QString</a></span> QQuickWindow::<span class="name">sceneGraphBackend</span>()
</h3> <p>Returns the requested Qt Quick scenegraph backend.</p> <div class="admonition note"> <p><b>Note: </b>The return value of this function may still be outdated by subsequent calls to <a href="qquickwindow.html#setSceneGraphBackend">setSceneGraphBackend</a>() until the first <a href="qquickwindow.html">QQuickWindow</a> in the application has been constructed.</p> </div> <div class="admonition note"> <p><b>Note: </b>The value only reflects the request in the <code>QT_QUICK_BACKEND</code> environment variable after a <a href="qquickwindow.html">QQuickWindow</a> has been constructed.</p> </div> <p>This function was introduced in Qt 5.9.</p> <p><b>See also </b><a href="qquickwindow.html#setSceneGraphBackend">setSceneGraphBackend</a>().</p>   <h3 class="fn" id="scheduleRenderJob">
<code>[since 5.4] </code><span class="type">void</span> QQuickWindow::<span class="name">scheduleRenderJob</span>(<span class="type"><a href="qrunnable.html">QRunnable</a></span> *<i>job</i>, <span class="type"><a href="qquickwindow.html#RenderStage-enum">QQuickWindow::RenderStage</a></span> <i>stage</i>)
</h3> <p>Schedules <i>job</i> to run when the rendering of this window reaches the given <i>stage</i>.</p> <p>This is a convenience to the equivalent signals in <a href="qquickwindow.html">QQuickWindow</a> for "one shot" tasks.</p> <p>The window takes ownership over <i>job</i> and will delete it when the job is completed.</p> <p>If rendering is shut down before <i>job</i> has a chance to run, the job will be run and then deleted as part of the scene graph cleanup. If the window is never shown and no rendering happens before the <a href="qquickwindow.html">QQuickWindow</a> is destroyed, all pending jobs will be destroyed without their run() method being called.</p> <p>If the rendering is happening on a different thread, then the job will happen on the rendering thread.</p> <p>If <i>stage</i> is <a href="qquickwindow.html#RenderStage-enum">NoStage</a>, <i>job</i> will be run at the earliest opportunity whenever the render thread is not busy rendering a frame. If the window is not exposed, and is not renderable, at the time the job is either posted or handled, the job is deleted without executing the run() method. If a non-threaded renderer is in use, the run() method of the job is executed synchronously. When rendering with OpenGL, the OpenGL context is changed to the renderer's context before executing any job, including <a href="qquickwindow.html#RenderStage-enum">NoStage</a> jobs.</p> <div class="admonition note"> <p><b>Note: </b>This function does not trigger rendering; the jobs targeting any other stage than <a href="qquickwindow.html#RenderStage-enum">NoStage</a> will be stored run until rendering is triggered elsewhere. To force the job to run earlier, call <a href="qquickwindow.html#update">QQuickWindow::update</a>();</p> </div> <p>This function was introduced in Qt 5.4.</p> <p><b>See also </b><a href="qquickwindow.html#beforeRendering">beforeRendering</a>(), <a href="qquickwindow.html#afterRendering">afterRendering</a>(), <a href="qquickwindow.html#beforeSynchronizing">beforeSynchronizing</a>(), <a href="qquickwindow.html#afterSynchronizing">afterSynchronizing</a>(), <a href="qquickwindow.html#frameSwapped">frameSwapped</a>(), and <a href="qquickwindow.html#sceneGraphInvalidated">sceneGraphInvalidated</a>().</p>   <h3 class="fn" id="setDefaultAlphaBuffer">
<code>[static, since 5.1] </code><span class="type">void</span> QQuickWindow::<span class="name">setDefaultAlphaBuffer</span>(<span class="type">bool</span> <i>useAlpha</i>)
</h3> <p><i>useAlpha</i> specifies whether to use alpha transparency on newly created windows.</p> <p>In any application which expects to create translucent windows, it's necessary to set this to true before creating the first <a href="qquickwindow.html">QQuickWindow</a>. The default value is false.</p> <p>This function was introduced in Qt 5.1.</p> <p><b>See also </b><a href="qquickwindow.html#hasDefaultAlphaBuffer">hasDefaultAlphaBuffer</a>().</p>   <h3 class="fn" id="setGraphicsApi">
<code>[static, since 5.8] </code><span class="type">void</span> QQuickWindow::<span class="name">setGraphicsApi</span>(<span class="type"><a href="qsgrendererinterface.html#GraphicsApi-enum">QSGRendererInterface::GraphicsApi</a></span> <i>api</i>)
</h3> <p>Requests the specified graphics <i>api</i>.</p> <p>When the built-in, default graphics adaptation is used, <i>api</i> specifies which graphics API (OpenGL, Vulkan, Metal, or Direct3D) the scene graph should use to render. In addition, the <code>software</code> backend is built-in as well, and can be requested by setting <i>api</i> to <a href="qsgrendererinterface.html#GraphicsApi-enum">QSGRendererInterface::Software</a>.</p> <p>Unlike <a href="qquickwindow.html#setSceneGraphBackend">setSceneGraphBackend</a>(), which can only be used to request a given backend (shipped either built-in or installed as dynamically loaded plugins), this function works with the higher level concept of graphics APIs. It covers the backends that ship with Qt Quick, and thus have corresponding values in the <a href="qsgrendererinterface.html#GraphicsApi-enum">QSGRendererInterface::GraphicsApi</a> enum.</p> <p>When this function is not called at all, and the equivalent environment variable <code>QSG_RHI_BACKEND</code> is not set either, the scene graph will choose the graphics API to use based on the platform.</p> <p>This function becomes important in applications that are only prepared for rendering with a given API. For example, if there is native OpenGL or Vulkan rendering done by the application, it will want to ensure Qt Quick is rendering using OpenGL or Vulkan too. Such applications are expected to call this function early in their main() function.</p> <div class="admonition note"> <p><b>Note: </b>The call to the function must happen before constructing the first <a href="qquickwindow.html">QQuickWindow</a> in the application. The graphics API cannot be changed afterwards.</p> </div> <div class="admonition note"> <p><b>Note: </b>When used in combination with <a href="qquickrendercontrol.html">QQuickRenderControl</a>, this rule is relaxed: it is possible to change the graphics API, but only when all existing <a href="qquickrendercontrol.html">QQuickRenderControl</a> and <a href="qquickwindow.html">QQuickWindow</a> instances have been destroyed.</p> </div> <p>To query what graphics API the scene graph is using to render, <a href="qsgrendererinterface.html#graphicsApi">QSGRendererInterface::graphicsApi</a>() after the scene graph <a href="qquickwindow.html#isSceneGraphInitialized">has initialized</a>, which typically happens either when the window becomes visible for the first time, or when <a href="qquickrendercontrol.html#initialize">QQuickRenderControl::initialize</a>() is called.</p> <p>To switch back to the default behavior, where the scene graph chooses a graphics API based on the platform and other conditions, set <i>api</i> to <a href="qsgrendererinterface.html#GraphicsApi-enum">QSGRendererInterface::Unknown</a>.</p> <p>This function was introduced in Qt 5.8.</p> <p><b>See also </b><a href="qquickwindow.html#graphicsApi">graphicsApi</a>().</p>   <h3 class="fn" id="setGraphicsConfiguration">
<code>[since 6.0] </code><span class="type">void</span> QQuickWindow::<span class="name">setGraphicsConfiguration</span>(const <span class="type"><a href="qquickgraphicsconfiguration.html">QQuickGraphicsConfiguration</a></span> &amp;<i>config</i>)
</h3> <p>Sets the graphics configuration for this window. <i>config</i> contains various settings that may be taken into account by the scene graph when initializing the underlying graphics devices and contexts.</p> <p>Such additional configuration, specifying for example what device extensions to enable for Vulkan, becomes relevant and essential when integrating native graphics rendering code that relies on certain extensions. The same is true when integrating with an external 3D or VR engines, such as OpenXR.</p> <div class="admonition note"> <p><b>Note: </b>The configuration is ignored when adopting existing graphics devices via <a href="qquickwindow.html#setGraphicsDevice">setGraphicsDevice</a>() since the scene graph is then not in control of the actual construction of those objects.</p> </div> <p><a href="qquickgraphicsconfiguration.html">QQuickGraphicsConfiguration</a> instances are implicitly shared, copyable, and can be passed by value.</p> <div class="admonition warning"> <p><b>Warning: </b>Setting a <a href="qquickgraphicsconfiguration.html">QQuickGraphicsConfiguration</a> on a <a href="qquickwindow.html">QQuickWindow</a> must happen early enough, before the scene graph is initialized for the first time for that window. With on-screen windows this means the call must be done before invoking <a href="qwindow.html#show">show</a>() on the <a href="qquickwindow.html">QQuickWindow</a> or <a href="qquickview.html">QQuickView</a>. With <a href="qquickrendercontrol.html">QQuickRenderControl</a> the configuration must be finalized before calling <a href="qquickrendercontrol.html#initialize">initialize</a>().</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickwindow.html#graphicsConfiguration">graphicsConfiguration</a>().</p>   <h3 class="fn" id="setGraphicsDevice">
<code>[since 6.0] </code><span class="type">void</span> QQuickWindow::<span class="name">setGraphicsDevice</span>(const <span class="type"><a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a></span> &amp;<i>device</i>)
</h3> <p>Sets the graphics device objects for this window. The scenegraph will use existing device, physical device, and other objects specified by <i>device</i> instead of creating new ones.</p> <p>This function is very often used in combination with <a href="qquickrendercontrol.html">QQuickRenderControl</a> and <a href="qquickwindow.html#setRenderTarget">setRenderTarget</a>(), in order to redirect Qt Quick rendering into a texture.</p> <p>A default constructed <a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a> does not change the default behavior in any way. Once a <i>device</i> created via one of the <a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a> factory functions, such as, <a href="qquickgraphicsdevice.html#fromDeviceObjects">QQuickGraphicsDevice::fromDeviceObjects</a>(), is passed in, and the scenegraph uses a matching graphics API (with the example of fromDeviceObjects(), that would be Vulkan), the scenegraph will use the existing device objects (such as, the <code>VkPhysicalDevice</code>, <code>VkDevice</code>, and graphics queue family index, in case of Vulkan) encapsulated by the <a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a>. This allows using the same device, and so sharing resources, such as buffers and textures, between Qt Quick and native rendering engines.</p> <div class="admonition warning"> <p><b>Warning: </b>This function can only be called before initializing the scenegraph and will have no effect if called afterwards. In practice this typically means calling it right before <a href="qquickrendercontrol.html#initialize">QQuickRenderControl::initialize</a>().</p> </div> <p>As an example, this time with Direct3D, the typical usage is expected to be the following:</p> <pre data-language="cpp">// native graphics resources set up by a custom D3D rendering engine
ID3D11Device *device;
ID3D11DeviceContext *context;
ID3D11Texture2D *texture;
...
// now to redirect Qt Quick content into 'texture' we could do the following:
QQuickRenderControl *renderControl = new QQuickRenderControl;
QQuickWindow *window = new QQuickWindow(renderControl); // this window will never be shown on-screen
...
window-&gt;setGraphicsDevice(QQuickGraphicsDevice::fromDeviceAndContext(device, context));
renderControl-&gt;initialize();
window-&gt;setRenderTarget(QQuickRenderTarget::fromD3D11Texture(texture, textureSize);
...</pre> <p>The key aspect of using this function is to ensure that resources or handles to resources, such as <code>texture</code> in the above example, are visible to and usable by both the external rendering engine and the scenegraph renderer. This requires using the same graphics device (or with OpenGL, OpenGL context).</p> <p><a href="qquickgraphicsdevice.html">QQuickGraphicsDevice</a> instances are implicitly shared, copyable, and can be passed by value. They do not own the associated native objects (such as, the ID3D11Device in the example).</p> <div class="admonition note"> <p><b>Note: </b>Using <a href="qquickrendercontrol.html">QQuickRenderControl</a> does not always imply having to call this function. When adopting an existing device or context is not needed, this function should not be called, and the scene graph will then initialize its own devices and contexts normally, just as it would with an on-screen <a href="qquickwindow.html">QQuickWindow</a>.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickwindow.html#graphicsDevice">graphicsDevice</a>(), <a href="qquickrendercontrol.html">QQuickRenderControl</a>, <a href="qquickwindow.html#setRenderTarget">setRenderTarget</a>(), and <a href="qquickwindow.html#setGraphicsApi">setGraphicsApi</a>().</p>   <h3 class="fn" id="setPersistentGraphics">
<span class="type">void</span> QQuickWindow::<span class="name">setPersistentGraphics</span>(<span class="type">bool</span> <i>persistent</i>)
</h3> <p>Sets whether the graphics resources (graphics device or context, swapchain, buffers, textures) should be preserved, and cannot be released until the last window is deleted, to <i>persistent</i>. The default value is true.</p> <p>When calling <a href="qquickwindow.html#releaseResources">releaseResources</a>(), or when the window gets hidden (more specifically, not renderable), some render loops have the possibility to release all, not just the cached, graphics resources. This can free up memory temporarily, but it also means the rendering engine will have to do a full, potentially costly reinitialization of the resources when the window needs to render again.</p> <div class="admonition note"> <p><b>Note: </b>The rules for when a window is not renderable are platform and window manager specific.</p> </div> <div class="admonition note"> <p><b>Note: </b>All graphics resources are released when the last <a href="qquickwindow.html">QQuickWindow</a> is deleted, regardless of this setting.</p> </div> <div class="admonition note"> <p><b>Note: </b>This is a hint, and is not guaranteed that it is taken into account.</p> </div> <div class="admonition note"> <p><b>Note: </b>This hint does not apply to cached resources, that are relatively cheap to drop and then recreate later. Therefore, calling <a href="qquickwindow.html#releaseResources">releaseResources</a>() will typically lead to releasing those regardless of the value of this hint.</p> </div> <p><b>See also </b><a href="qquickwindow.html#isPersistentGraphics">isPersistentGraphics</a>(), <a href="qquickwindow.html#setPersistentSceneGraph">setPersistentSceneGraph</a>(), <a href="qquickwindow.html#sceneGraphInitialized">sceneGraphInitialized</a>(), <a href="qquickwindow.html#sceneGraphInvalidated">sceneGraphInvalidated</a>(), and <a href="qquickwindow.html#releaseResources">releaseResources</a>().</p>   <h3 class="fn" id="setPersistentSceneGraph">
<span class="type">void</span> QQuickWindow::<span class="name">setPersistentSceneGraph</span>(<span class="type">bool</span> <i>persistent</i>)
</h3> <p>Sets whether the scene graph nodes and resources are <i>persistent</i>. Persistent means the nodes and resources cannot be released. The default value is <code>true</code>.</p> <p>When calling <a href="qquickwindow.html#releaseResources">releaseResources</a>(), when the window gets hidden (more specifically, not renderable), some render loops have the possibility to release the scene graph nodes and related graphics resources. This frees up memory temporarily, but will also mean the scene graph has to be rebuilt when the window renders next time.</p> <div class="admonition note"> <p><b>Note: </b>The rules for when a window is not renderable are platform and window manager specific.</p> </div> <div class="admonition note"> <p><b>Note: </b>The scene graph nodes and resources are always released when the last <a href="qquickwindow.html">QQuickWindow</a> is deleted, regardless of this setting.</p> </div> <div class="admonition note"> <p><b>Note: </b>This is a hint, and is not guaranteed that it is taken into account.</p> </div> <p><b>See also </b><a href="qquickwindow.html#isPersistentSceneGraph">isPersistentSceneGraph</a>(), <a href="qquickwindow.html#setPersistentGraphics">setPersistentGraphics</a>(), <a href="qquickwindow.html#sceneGraphInvalidated">sceneGraphInvalidated</a>(), <a href="qquickwindow.html#sceneGraphInitialized">sceneGraphInitialized</a>(), and <a href="qquickwindow.html#releaseResources">releaseResources</a>().</p>   <h3 class="fn" id="setRenderTarget">
<code>[since 6.0] </code><span class="type">void</span> QQuickWindow::<span class="name">setRenderTarget</span>(const <span class="type"><a href="qquickrendertarget.html">QQuickRenderTarget</a></span> &amp;<i>target</i>)
</h3> <p>Sets the render target for this window to be <i>target</i>.</p> <p>A <a href="qquickrendertarget.html">QQuickRenderTarget</a> serves as an opaque handle for a renderable native object, most commonly a 2D texture, and associated metadata, such as the size in pixels.</p> <p>A default constructed <a href="qquickrendertarget.html">QQuickRenderTarget</a> means no redirection. A valid <i>target</i>, created via one of the static <a href="qquickrendertarget.html">QQuickRenderTarget</a> factory functions, on the other hand, enables redirection of the rendering of the Qt Quick scene: it will no longer target the color buffers for the surface associated with the window, but rather the textures or other graphics objects specified in <i>target</i>.</p> <p>For example, assuming the scenegraph is using Vulkan to render, one can redirect its output into a <code>VkImage</code>. For graphics APIs like Vulkan, the image layout must be provided as well. <a href="qquickrendertarget.html">QQuickRenderTarget</a> instances are implicitly shared and are copyable and can be passed by value. They do not own the associated native objects (such as, the VkImage in the example), however.</p> <pre data-language="cpp">QQuickRenderTarget rt = QQuickRenderTarget::fromVulkanImage(vulkanImage, VK_IMAGE_LAYOUT_PREINITIALIZED, pixelSize);
quickWindow-&gt;setRenderTarget(rt);</pre> <p>This function is very often used in combination with <a href="qquickrendercontrol.html">QQuickRenderControl</a> and an invisible <a href="qquickwindow.html">QQuickWindow</a>, in order to render Qt Quick content into a texture, without creating an on-screen native window for this <a href="qquickwindow.html">QQuickWindow</a>.</p> <p>When the desired target, or associated data, such as the size, changes, call this function with a new <a href="qquickrendertarget.html">QQuickRenderTarget</a>. Constructing <a href="qquickrendertarget.html">QQuickRenderTarget</a> instances and calling this function is cheap, but be aware that setting a new <i>target</i> with a different native object or other data may lead to potentially expensive initialization steps when the scenegraph is about to render the next frame. Therefore change the target only when necessary.</p> <div class="admonition note"> <p><b>Note: </b>This function should not be used when using the <code>software</code> backend. Instead, use <a href="qquickwindow.html#grabWindow">grabWindow</a>() to render the content into a <a href="qimage.html">QImage</a>.</p> </div> <div class="admonition note"> <p><b>Note: </b>The window does not take ownership of any native objects referenced in <i>target</i>.</p> </div> <div class="admonition note"> <p><b>Note: </b>It is the caller's responsibility to ensure the native objects referred to in <i>target</i> are valid for the scenegraph renderer too. For instance, with Vulkan, Metal, and Direct3D this implies that the texture or image is created on the same graphics device that is used by the scenegraph internally. Therefore, when texture objects created on an already existing device or context are involved, this function is often used in combination with <a href="qquickwindow.html#setGraphicsDevice">setGraphicsDevice</a>().</p> </div> <div class="admonition note"> <p><b>Note: </b>With graphics APIs where relevant, the application must pay attention to image layout transitions performed by the scenegraph. For example, once a VkImage is associated with the scenegraph by calling this function, its layout will transition to <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> when rendering a frame.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>This function can only be called from the thread doing the rendering.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qquickwindow.html#renderTarget">renderTarget</a>(), <a href="qquickrendercontrol.html">QQuickRenderControl</a>, <a href="qquickwindow.html#setGraphicsDevice">setGraphicsDevice</a>(), and <a href="qquickwindow.html#setGraphicsApi">setGraphicsApi</a>().</p>   <h3 class="fn" id="setSceneGraphBackend">
<code>[static, since 5.8] </code><span class="type">void</span> QQuickWindow::<span class="name">setSceneGraphBackend</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>backend</i>)
</h3> <p>Requests a Qt Quick scenegraph <i>backend</i>. Backends can either be built-in or be installed in form of dynamically loaded plugins.</p> <p>This is an overloaded function.</p> <div class="admonition note"> <p><b>Note: </b>The call to the function must happen before constructing the first <a href="qquickwindow.html">QQuickWindow</a> in the application. It cannot be changed afterwards.</p> </div> <p>See <a href="qtquick-visualcanvas-adaptations.html#switch-between-adaptations-in-your-application">Switch Between Adaptations in Your Application</a> for more information about the list of backends. If <i>backend</i> is invalid or an error occurs, the request is ignored.</p> <div class="admonition note"> <p><b>Note: </b>Calling this function is equivalent to setting the <code>QT_QUICK_BACKEND</code> or <code>QMLSCENE_DEVICE</code> environment variables. However, this API is safer to use in applications that spawn other processes as there is no need to worry about environment inheritance.</p> </div> <p>This function was introduced in Qt 5.8.</p> <p><b>See also </b><a href="qquickwindow.html#sceneGraphBackend">sceneGraphBackend</a>().</p>   <h3 class="fn" id="setTextRenderType">
<code>[static, since 5.10] </code><span class="type">void</span> QQuickWindow::<span class="name">setTextRenderType</span>(<span class="type"><a href="qquickwindow.html#TextRenderType-enum">QQuickWindow::TextRenderType</a></span> <i>renderType</i>)
</h3> <p>Sets the default render type of text-like elements in Qt Quick to <i>renderType</i>.</p> <div class="admonition note"> <p><b>Note: </b>setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified.</p> </div> <p>This function was introduced in Qt 5.10.</p> <p><b>See also </b><a href="qquickwindow.html#textRenderType">textRenderType</a>().</p>   <h3 class="fn" id="showEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">showEvent</span>(<span class="type"><a href="qshowevent.html">QShowEvent</a></span> *)
</h3> <p>Reimplements: <a href="qwindow.html#showEvent">QWindow::showEvent</a>(QShowEvent *ev).</p>   <h3 class="fn" id="tabletEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">tabletEvent</span>(<span class="type"><a href="qtabletevent.html">QTabletEvent</a></span> *<i>event</i>)
</h3> <p>Reimplements: <a href="qwindow.html#tabletEvent">QWindow::tabletEvent</a>(QTabletEvent *ev).</p>   <h3 class="fn" id="textRenderType">
<code>[static, since 5.10] </code><span class="type"><a href="qquickwindow.html#TextRenderType-enum">QQuickWindow::TextRenderType</a></span> QQuickWindow::<span class="name">textRenderType</span>()
</h3> <p>Returns the render type of text-like elements in Qt Quick. The default is <a href="qquickwindow.html#TextRenderType-enum">QQuickWindow::QtTextRendering</a>.</p> <p>This function was introduced in Qt 5.10.</p> <p><b>See also </b><a href="qquickwindow.html#setTextRenderType">setTextRenderType</a>().</p>   <h3 class="fn" id="wheelEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">wheelEvent</span>(<span class="type"><a href="qwheelevent.html">QWheelEvent</a></span> *<i>event</i>)
</h3> <p>Reimplements: <a href="qwindow.html#wheelEvent">QWindow::wheelEvent</a>(QWheelEvent *ev).</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qquickwindow.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qquickwindow.html</a>
  </p>
</div>
