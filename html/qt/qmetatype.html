<h1 class="title">QMetaType Class</h1>  <p>The QMetaType class manages named types in the meta-object system. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QMetaType&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qmetatype-members.html">List of all members, including inherited members</a></li> <li><a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html">Deprecated members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="threads-reentrancy.html">thread-safe</a>.</p> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#Type-enum">Type</a></b> { Void, Bool, Int, UInt, Double, …, UnknownType }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#TypeFlag-enum">TypeFlag</a></b> { NeedsConstruction, NeedsDestruction, RelocatableType, IsEnumeration, IsUnsignedEnumeration, …, IsConst }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qmetatype.html#TypeFlag-enum">TypeFlags</a></b></td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#QMetaType">QMetaType</a></b>(int <i>typeId</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#alignOf">alignOf</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPartialOrdering </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#compare">compare</a></b>(const void *<i>lhs</i>, const void *<i>rhs</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void *</td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#construct-1">construct</a></b>(void *<i>where</i>, const void *<i>copy</i> = nullptr) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void *</td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#create-1">create</a></b>(const void *<i>copy</i> = nullptr) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#debugStream">debugStream</a></b>(QDebug &amp;<i>dbg</i>, const void *<i>rhs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#destroy-1">destroy</a></b>(void *<i>data</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#destruct-1">destruct</a></b>(void *<i>data</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#equals">equals</a></b>(const void *<i>lhs</i>, const void *<i>rhs</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QMetaType::TypeFlags </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#flags">flags</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#hasRegisteredDataStreamOperators">hasRegisteredDataStreamOperators</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#hasRegisteredDebugStreamOperator">hasRegisteredDebugStreamOperator</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#id">id</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#isEqualityComparable">isEqualityComparable</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#isOrdered">isOrdered</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#isRegistered-1">isRegistered</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#isValid">isValid</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#load">load</a></b>(QDataStream &amp;<i>stream</i>, void *<i>data</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QMetaObject *</td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#metaObject">metaObject</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#name">name</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#save">save</a></b>(QDataStream &amp;<i>stream</i>, const void *<i>data</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#sizeOf-1">sizeOf</a></b>() const</td>
</tr> </table> <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#canConvert">canConvert</a></b>(QMetaType <i>fromType</i>, QMetaType <i>toType</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#canView">canView</a></b>(QMetaType <i>fromType</i>, QMetaType <i>toType</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#convert">convert</a></b>(QMetaType <i>fromType</i>, const void *<i>from</i>, QMetaType <i>toType</i>, void *<i>to</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QMetaType </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#fromName">fromName</a></b>(QByteArrayView <i>typeName</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QMetaType </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#fromType">fromType</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#hasRegisteredConverterFunction">hasRegisteredConverterFunction</a></b>(QMetaType <i>fromType</i>, QMetaType <i>toType</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#hasRegisteredConverterFunction-1">hasRegisteredConverterFunction</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#hasRegisteredMutableViewFunction">hasRegisteredMutableViewFunction</a></b>(QMetaType <i>fromType</i>, QMetaType <i>toType</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#hasRegisteredMutableViewFunction-1">hasRegisteredMutableViewFunction</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#isRegistered">isRegistered</a></b>(int <i>type</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#registerConverter">registerConverter</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#view">view</a></b>(QMetaType <i>fromType</i>, void *<i>from</i>, QMetaType <i>toType</i>, void *<i>to</i>)</td>
</tr> </table> <h2 id="related-non-members">Related Non-Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#qMetaTypeId">qMetaTypeId</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#qRegisterMetaType">qRegisterMetaType</a></b>(const char *<i>typeName</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#qRegisterMetaType-1">qRegisterMetaType</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#operator-not-eq">operator!=</a></b>(QMetaType <i>a</i>, QMetaType <i>b</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#operator-eq-eq">operator==</a></b>(QMetaType <i>a</i>, QMetaType <i>b</i>)</td>
</tr> </table> <h2 id="macros">Macros
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</a></b>(<i>Container</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a></b>(<i>Type</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</a></b>(<i>PointerType</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a></b>(<i>Container</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetatype.html#Q_DECLARE_SMART_POINTER_METATYPE">Q_DECLARE_SMART_POINTER_METATYPE</a></b>(<i>SmartPointer</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>The class is used as a helper to marshall types in <a href="qmetatype.html#Type-enum">QVariant</a> and in queued signals and slots connections. It associates a type name to a type so that it can be created and destructed dynamically at run-time. Declare new types with <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>() to make them available to <a href="qmetatype.html#Type-enum">QVariant</a> and other template-based functions. Call <a href="qmetatype.html#qRegisterMetaType-1">qRegisterMetaType</a>() to make types available to non-template based functions, such as the queued signal and slot connections.</p> <p>Any class or struct that has a public default constructor, a public copy constructor, and a public destructor can be registered.</p> <p>The following code allocates and destructs an instance of <code>MyClass</code>:</p> <pre data-language="cpp">int id = QMetaType::type("MyClass");
if (id != QMetaType::UnknownType) {
    void *myClassPtr = QMetaType::create(id);
    ...
    QMetaType::destroy(id, myClassPtr);
    myClassPtr = 0;
}</pre> <p>If we want the stream operators <code>operator&lt;&lt;()</code> and <code>operator&gt;&gt;()</code> to work on <a href="qmetatype.html#Type-enum">QVariant</a> objects that store custom types, the custom type must provide <code>operator&lt;&lt;()</code> and <code>operator&gt;&gt;()</code> operators.</p>  <p><b>See also </b><a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>(), <a href="qvariant.html#setValue">QVariant::setValue</a>(), <a href="qvariant.html#value">QVariant::value</a>(), and <a href="qvariant.html#fromValue">QVariant::fromValue</a>().</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="Type-enum">enum QMetaType::<span class="name">Type</span>
</h3> <p>These are the built-in types supported by <a href="qmetatype.html">QMetaType</a>:</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Void</code></td>
<td class="topAlign tblval"><code>43</code></td>
<td class="topAlign"><code>void</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Bool</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign"><code>bool</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Int</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign"><code>int</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::UInt</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign"><code>unsigned int</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Double</code></td>
<td class="topAlign tblval"><code>6</code></td>
<td class="topAlign"><code>double</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QChar</code></td>
<td class="topAlign tblval"><code>7</code></td>
<td class="topAlign">QChar</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QString</code></td>
<td class="topAlign tblval"><code>10</code></td>
<td class="topAlign">QString</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QByteArray</code></td>
<td class="topAlign tblval"><code>12</code></td>
<td class="topAlign">QByteArray</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Nullptr</code></td>
<td class="topAlign tblval"><code>51</code></td>
<td class="topAlign"><code>std::nullptr_t</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::VoidStar</code></td>
<td class="topAlign tblval"><code>31</code></td>
<td class="topAlign"><code>void *</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Long</code></td>
<td class="topAlign tblval"><code>32</code></td>
<td class="topAlign"><code>long</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::LongLong</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">LongLong</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Short</code></td>
<td class="topAlign tblval"><code>33</code></td>
<td class="topAlign"><code>short</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Char</code></td>
<td class="topAlign tblval"><code>34</code></td>
<td class="topAlign"><code>char</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Char16</code></td>
<td class="topAlign tblval"><code>56</code></td>
<td class="topAlign"><code>char16_t</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Char32</code></td>
<td class="topAlign tblval"><code>57</code></td>
<td class="topAlign"><code>char32_t</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::ULong</code></td>
<td class="topAlign tblval"><code>35</code></td>
<td class="topAlign"><code>unsigned long</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::ULongLong</code></td>
<td class="topAlign tblval"><code>5</code></td>
<td class="topAlign">ULongLong</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::UShort</code></td>
<td class="topAlign tblval"><code>36</code></td>
<td class="topAlign"><code>unsigned short</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::SChar</code></td>
<td class="topAlign tblval"><code>40</code></td>
<td class="topAlign"><code>signed char</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::UChar</code></td>
<td class="topAlign tblval"><code>37</code></td>
<td class="topAlign"><code>unsigned char</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::Float</code></td>
<td class="topAlign tblval"><code>38</code></td>
<td class="topAlign"><code>float</code></td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QObjectStar</code></td>
<td class="topAlign tblval"><code>39</code></td>
<td class="topAlign">
<a href="qobject.html">QObject</a> *</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QVariant</code></td>
<td class="topAlign tblval"><code>41</code></td>
<td class="topAlign">QVariant</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QCursor</code></td>
<td class="topAlign tblval"><code>0x100a</code></td>
<td class="topAlign">QCursor</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QDate</code></td>
<td class="topAlign tblval"><code>14</code></td>
<td class="topAlign">QDate</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QSize</code></td>
<td class="topAlign tblval"><code>21</code></td>
<td class="topAlign">QSize</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QTime</code></td>
<td class="topAlign tblval"><code>15</code></td>
<td class="topAlign">QTime</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QVariantList</code></td>
<td class="topAlign tblval"><code>9</code></td>
<td class="topAlign">QVariantList</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QPolygon</code></td>
<td class="topAlign tblval"><code>0x1007</code></td>
<td class="topAlign">QPolygon</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QPolygonF</code></td>
<td class="topAlign tblval"><code>0x1016</code></td>
<td class="topAlign">QPolygonF</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QColor</code></td>
<td class="topAlign tblval"><code>0x1003</code></td>
<td class="topAlign">QColor</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QColorSpace</code></td>
<td class="topAlign tblval"><code>0x1017</code></td>
<td class="topAlign">QColorSpace (introduced in Qt 5.15)</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QSizeF</code></td>
<td class="topAlign tblval"><code>22</code></td>
<td class="topAlign">QSizeF</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QRectF</code></td>
<td class="topAlign tblval"><code>20</code></td>
<td class="topAlign">QRectF</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QLine</code></td>
<td class="topAlign tblval"><code>23</code></td>
<td class="topAlign">QLine</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QTextLength</code></td>
<td class="topAlign tblval"><code>0x100d</code></td>
<td class="topAlign">QTextLength</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QStringList</code></td>
<td class="topAlign tblval"><code>11</code></td>
<td class="topAlign">QStringList</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QVariantMap</code></td>
<td class="topAlign tblval"><code>8</code></td>
<td class="topAlign">QVariantMap</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QVariantHash</code></td>
<td class="topAlign tblval"><code>28</code></td>
<td class="topAlign">QVariantHash</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QIcon</code></td>
<td class="topAlign tblval"><code>0x1005</code></td>
<td class="topAlign">QIcon</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QPen</code></td>
<td class="topAlign tblval"><code>0x100c</code></td>
<td class="topAlign">QPen</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QLineF</code></td>
<td class="topAlign tblval"><code>24</code></td>
<td class="topAlign">QLineF</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QTextFormat</code></td>
<td class="topAlign tblval"><code>0x100e</code></td>
<td class="topAlign">QTextFormat</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QRect</code></td>
<td class="topAlign tblval"><code>19</code></td>
<td class="topAlign">QRect</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QPoint</code></td>
<td class="topAlign tblval"><code>25</code></td>
<td class="topAlign">QPoint</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QUrl</code></td>
<td class="topAlign tblval"><code>17</code></td>
<td class="topAlign">QUrl</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QRegularExpression</code></td>
<td class="topAlign tblval"><code>44</code></td>
<td class="topAlign">QRegularExpression</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QDateTime</code></td>
<td class="topAlign tblval"><code>16</code></td>
<td class="topAlign">QDateTime</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QPointF</code></td>
<td class="topAlign tblval"><code>26</code></td>
<td class="topAlign">QPointF</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QPalette</code></td>
<td class="topAlign tblval"><code>0x1004</code></td>
<td class="topAlign">QPalette</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QFont</code></td>
<td class="topAlign tblval"><code>0x1000</code></td>
<td class="topAlign">QFont</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QBrush</code></td>
<td class="topAlign tblval"><code>0x1002</code></td>
<td class="topAlign">QBrush</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QRegion</code></td>
<td class="topAlign tblval"><code>0x1008</code></td>
<td class="topAlign">QRegion</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QBitArray</code></td>
<td class="topAlign tblval"><code>13</code></td>
<td class="topAlign">QBitArray</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QImage</code></td>
<td class="topAlign tblval"><code>0x1006</code></td>
<td class="topAlign">QImage</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QKeySequence</code></td>
<td class="topAlign tblval"><code>0x100b</code></td>
<td class="topAlign">QKeySequence</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QSizePolicy</code></td>
<td class="topAlign tblval"><code>0x2000</code></td>
<td class="topAlign">QSizePolicy</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QPixmap</code></td>
<td class="topAlign tblval"><code>0x1001</code></td>
<td class="topAlign">QPixmap</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QLocale</code></td>
<td class="topAlign tblval"><code>18</code></td>
<td class="topAlign">QLocale</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QBitmap</code></td>
<td class="topAlign tblval"><code>0x1009</code></td>
<td class="topAlign">QBitmap</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QTransform</code></td>
<td class="topAlign tblval"><code>0x1010</code></td>
<td class="topAlign">QTransform</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QMatrix4x4</code></td>
<td class="topAlign tblval"><code>0x1011</code></td>
<td class="topAlign">QMatrix4x4</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QVector2D</code></td>
<td class="topAlign tblval"><code>0x1012</code></td>
<td class="topAlign">QVector2D</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QVector3D</code></td>
<td class="topAlign tblval"><code>0x1013</code></td>
<td class="topAlign">QVector3D</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QVector4D</code></td>
<td class="topAlign tblval"><code>0x1014</code></td>
<td class="topAlign">QVector4D</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QQuaternion</code></td>
<td class="topAlign tblval"><code>0x1015</code></td>
<td class="topAlign">QQuaternion</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QEasingCurve</code></td>
<td class="topAlign tblval"><code>29</code></td>
<td class="topAlign">QEasingCurve</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QJsonValue</code></td>
<td class="topAlign tblval"><code>45</code></td>
<td class="topAlign">QJsonValue</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QJsonObject</code></td>
<td class="topAlign tblval"><code>46</code></td>
<td class="topAlign">QJsonObject</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QJsonArray</code></td>
<td class="topAlign tblval"><code>47</code></td>
<td class="topAlign">QJsonArray</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QJsonDocument</code></td>
<td class="topAlign tblval"><code>48</code></td>
<td class="topAlign">QJsonDocument</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QCborValue</code></td>
<td class="topAlign tblval"><code>53</code></td>
<td class="topAlign">QCborValue</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QCborArray</code></td>
<td class="topAlign tblval"><code>54</code></td>
<td class="topAlign">QCborArray</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QCborMap</code></td>
<td class="topAlign tblval"><code>55</code></td>
<td class="topAlign">QCborMap</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QCborSimpleType</code></td>
<td class="topAlign tblval"><code>52</code></td>
<td class="topAlign">QCborSimpleType</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QModelIndex</code></td>
<td class="topAlign tblval"><code>42</code></td>
<td class="topAlign">QModelIndex</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QPersistentModelIndex</code></td>
<td class="topAlign tblval"><code>50</code></td>
<td class="topAlign">QPersistentModelIndex (introduced in Qt 5.5)</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QUuid</code></td>
<td class="topAlign tblval"><code>30</code></td>
<td class="topAlign">QUuid</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::QByteArrayList</code></td>
<td class="topAlign tblval"><code>49</code></td>
<td class="topAlign">QByteArrayList</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::User</code></td>
<td class="topAlign tblval"><code>65536</code></td>
<td class="topAlign">Base value for user types</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::UnknownType</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">This is an invalid type id. It is returned from <a href="qmetatype.html">QMetaType</a> for types that are not registered</td>
</tr> </table> <p>Additional types can be registered using <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>().</p> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#type">type</a>() and <a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#typeName">typeName</a>().</p>   <h3 class="flags" id="TypeFlag-enum">enum QMetaType::<span class="name">TypeFlag</span>flags QMetaType::<span class="name">TypeFlags</span>
</h3> <p>The enum describes attributes of a type supported by <a href="qmetatype.html">QMetaType</a>.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QMetaType::NeedsConstruction</code></td>
<td class="topAlign tblval"><code>0x1</code></td>
<td class="topAlign">This type has non-trivial constructors. If the flag is not set instances can be safely initialized with memset to 0.</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::NeedsDestruction</code></td>
<td class="topAlign tblval"><code>0x2</code></td>
<td class="topAlign">This type has a non-trivial destructor. If the flag is not set calls to the destructor are not necessary before discarding objects.</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::RelocatableType</code></td>
<td class="topAlign tblval"><code>0x4</code></td>
<td class="topAlign">An instance of a type having this attribute can be safely moved to a different memory location using memcpy.</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::IsEnumeration</code></td>
<td class="topAlign tblval"><code>0x10</code></td>
<td class="topAlign">This type is an enumeration.</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::IsUnsignedEnumeration</code></td>
<td class="topAlign tblval"><code>0x100</code></td>
<td class="topAlign">If the type is an Enumeration, its underlying type is unsigned.</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::PointerToQObject</code></td>
<td class="topAlign tblval"><code>0x8</code></td>
<td class="topAlign">This type is a pointer to a derived of <a href="qobject.html">QObject</a>.</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::IsPointer</code></td>
<td class="topAlign tblval"><code>0x800</code></td>
<td class="topAlign">This type is a pointer to another type.</td>
</tr> <tr>
<td class="topAlign"><code>QMetaType::IsConst</code></td>
<td class="topAlign tblval"><code>0x2000</code></td>
<td class="topAlign">Indicates that values of this types are immutable; for instance because they are pointers to const objects.</td>
</tr> </table> <p>The TypeFlags type is a typedef for <a href="qflags.html">QFlags</a>&lt;TypeFlag&gt;. It stores an OR combination of TypeFlag values.</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QMetaType">
<code>[since 5.0] </code>QMetaType::<span class="name">QMetaType</span>(<span class="type">int</span> <i>typeId</i>)
</h3> <p>Constructs a QMetaType object that contains all information about type <i>typeId</i>.</p> <p>This function was introduced in Qt 5.0.</p>   <h3 class="fn" id="alignOf">
<code>[since 6.0] </code><span class="type">qsizetype</span> QMetaType::<span class="name">alignOf</span>() const
</h3> <p>Returns the alignment of the type in bytes (i.e. alignof(T), where T is the actual type for which this <a href="qmetatype.html">QMetaType</a> instance was constructed for).</p> <p>This function is typically used together with construct() to perform low-level management of the memory used by a type.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#construct">QMetaType::construct</a>() and <a href="qmetatype.html#sizeOf-1">QMetaType::sizeOf</a>().</p>   <h3 class="fn" id="canConvert">
<code>[static] </code><span class="type">bool</span> QMetaType::<span class="name">canConvert</span>(<span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>fromType</i>, <span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>toType</i>)
</h3> <p>Returns <code>true</code> if <a href="qmetatype.html#convert">QMetaType::convert</a> can convert from <i>fromType</i> to <i>toType</i>.</p> <p>The following conversions are supported by Qt:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Type</th>
<th>Automatically Cast To</th>
</tr></thead> <tr class="odd" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::Bool</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum">QMetaType::ULongLong</a>
</td>
</tr> <tr class="even" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QByteArray</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum">QMetaType::ULongLong</a>, <a href="qmetatype.html#Type-enum">QMetaType::QUuid</a>
</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QChar</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum">QMetaType::ULongLong</a>
</td>
</tr> <tr class="even" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QColor</a></td>
<td><a href="qmetatype.html#Type-enum">QMetaType::QString</a></td>
</tr> <tr class="odd" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QDate</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::QDateTime</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>
</td>
</tr> <tr class="even" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QDateTime</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::QDate</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum">QMetaType::QTime</a>
</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::Double</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum">QMetaType::ULongLong</a>
</td>
</tr> <tr class="even" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QFont</a></td>
<td><a href="qmetatype.html#Type-enum">QMetaType::QString</a></td>
</tr> <tr class="odd" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::Int</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum">QMetaType::ULongLong</a>
</td>
</tr> <tr class="even" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QKeySequence</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>
</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QVariantList</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::QStringList</a> (if the list's items can be converted to QStrings)</td>
</tr> <tr class="even" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::LongLong</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum">QMetaType::ULongLong</a>
</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QPoint</a></td>
<td><a href="qmetatype.html#Type-enum">QMetaType::QPointF</a></td>
</tr> <tr class="even" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QRect</a></td>
<td><a href="qmetatype.html#Type-enum">QMetaType::QRectF</a></td>
</tr> <tr class="odd" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QString</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum">QMetaType::QColor</a>, <a href="qmetatype.html#Type-enum">QMetaType::QDate</a>, <a href="qmetatype.html#Type-enum">QMetaType::QDateTime</a>, <a href="qmetatype.html#Type-enum">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum">QMetaType::QFont</a>, <a href="qmetatype.html#Type-enum">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum">QMetaType::QKeySequence</a>, <a href="qmetatype.html#Type-enum">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum">QMetaType::QStringList</a>, <a href="qmetatype.html#Type-enum">QMetaType::QTime</a>, <a href="qmetatype.html#Type-enum">QMetaType::UInt</a>, <a href="qmetatype.html#Type-enum">QMetaType::ULongLong</a>, <a href="qmetatype.html#Type-enum">QMetaType::QUuid</a>
</td>
</tr> <tr class="even" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QStringList</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::QVariantList</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a> (if the list contains exactly one item)</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QTime</a></td>
<td><a href="qmetatype.html#Type-enum">QMetaType::QString</a></td>
</tr> <tr class="even" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::UInt</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum">QMetaType::ULongLong</a>
</td>
</tr> <tr class="odd" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::ULongLong</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::Bool</a>, <a href="qmetatype.html#Type-enum">QMetaType::QChar</a>, <a href="qmetatype.html#Type-enum">QMetaType::Double</a>, <a href="qmetatype.html#Type-enum">QMetaType::Int</a>, <a href="qmetatype.html#Type-enum">QMetaType::LongLong</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>, <a href="qmetatype.html#Type-enum">QMetaType::UInt</a>
</td>
</tr> <tr class="even" valign="top">
<td><a href="qmetatype.html#Type-enum">QMetaType::QUuid</a></td>
<td>
<a href="qmetatype.html#Type-enum">QMetaType::QByteArray</a>, <a href="qmetatype.html#Type-enum">QMetaType::QString</a>
</td>
</tr> </table> <p>Casting between primitive type (int, float, bool etc.) is supported.</p> <p>Converting between pointers of types derived from <a href="qobject.html">QObject</a> will also return true for this function if a <a href="qobject.html#qobject_cast-1">qobject_cast</a> from the type described by <i>fromType</i> to the type described by <i>toType</i> would succeed.</p> <p>A cast from a sequential container will also return true for this function if the <i>toType</i> is <a href="qmetatype.html#Type-enum">QVariantList</a>.</p> <p>Similarly, a cast from an associative container will also return true for this function the <i>toType</i> is <a href="qmetatype.html#Type-enum">QVariantHash</a> or <a href="qmetatype.html#Type-enum">QVariantMap</a>.</p> <p><b>See also </b><a href="qmetatype.html#convert">convert</a>(), <a href="qsequentialiterable.html">QSequentialIterable</a>, <a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a>(), <a href="qassociativeiterable.html">QAssociativeIterable</a>, and <a href="qmetatype.html#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</a>().</p>   <h3 class="fn" id="canView">
<code>[static] </code><span class="type">bool</span> QMetaType::<span class="name">canView</span>(<span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>fromType</i>, <span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>toType</i>)
</h3> <p>Returns <code>true</code> if <a href="qmetatype.html#view">QMetaType::view</a> can create a mutable view of type <i>toType</i> on type <i>fromType</i>.</p> <p>Converting between pointers of types derived from <a href="qobject.html">QObject</a> will return true for this function if a <a href="qobject.html#qobject_cast-1">qobject_cast</a> from the type described by <i>fromType</i> to the type described by <i>toType</i> would succeed.</p> <p>You can create a mutable view of type <a href="qsequentialiterable.html">QSequentialIterable</a> on any container registered with <a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a>().</p> <p>Similarly you can create a mutable view of type <a href="qassociativeiterable.html">QAssociativeIterable</a> on any container registered with <a href="qmetatype.html#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</a>().</p> <p><b>See also </b><a href="qmetatype.html#convert">convert</a>(), <a href="qsequentialiterable.html">QSequentialIterable</a>, <a href="qmetatype.html#Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</a>(), <a href="qassociativeiterable.html">QAssociativeIterable</a>, and <a href="qmetatype.html#Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</a>().</p>   <h3 class="fn" id="compare">
<code>[since 6.0] </code><span class="type"><a href="qpartialordering.html">QPartialOrdering</a></span> QMetaType::<span class="name">compare</span>(const <span class="type">void</span> *<i>lhs</i>, const <span class="type">void</span> *<i>rhs</i>) const
</h3> <p>Compares the objects at <i>lhs</i> and <i>rhs</i> for ordering.</p> <p>Returns <a href="qpartialordering.html#Unordered-var">QPartialOrdering::Unordered</a> if comparison is not supported or the values are unordered. Otherwise, returns <a href="qpartialordering.html#Less-var">QPartialOrdering::Less</a>, <a href="qpartialordering.html#Equivalent-var">QPartialOrdering::Equivalent</a> or <a href="qpartialordering.html#Greater-var">QPartialOrdering::Greater</a> if <i>lhs</i> is less than, equivalent to or greater than <i>rhs</i>, respectively.</p> <p>Both objects must be of the type described by this metatype. If either <i>lhs</i> or <i>rhs</i> is <code>nullptr</code>, the values are unordered. Comparison is only supported if the type's less than operator was visible to the metatype declaration.</p> <p>If the type's equality operator was also visible, values will only compare equal if the equality operator says they are. In the absence of an equality operator, when neither value is less than the other, values are considered equal; if equality is also available and two such values are not equal, they are considered unordered, just as NaN (not a number) values of a floating point type lie outside its ordering.</p> <div class="admonition note"> <p><b>Note: </b>If no less than operator was visible to the metatype declaration, values are unordered even if an equality operator visible to the declaration considers them equal: <code>compare() == 0</code> only agrees with <a href="qmetatype.html#equals">equals</a>() if the less than operator was visible.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qmetatype.html#equals">equals</a>() and <a href="qmetatype.html#isOrdered">isOrdered</a>().</p>   <h3 class="fn" id="construct-1">
<code>[since 5.0] </code><span class="type">void</span> *QMetaType::<span class="name">construct</span>(<span class="type">void</span> *<i>where</i>, const <span class="type">void</span> *<i>copy</i> = nullptr) const
</h3> <p>Constructs a value of the type that this <a href="qmetatype.html">QMetaType</a> instance was constructed for in the existing memory addressed by <i>where</i>, that is a copy of <i>copy</i>, and returns <i>where</i>. If <i>copy</i> is zero, the value is default constructed.</p> <p>This is a low-level function for explicitly managing the memory used to store the type. Consider calling create() if you don't need this level of control (that is, use "new" rather than "placement new").</p> <p>You must ensure that <i>where</i> points to a location where the new value can be stored and that <i>where</i> is suitably aligned. The type's size can be queried by calling <a href="qmetatype.html#sizeOf-1">sizeOf</a>().</p> <p>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</p> <p>This function was introduced in Qt 5.0.</p>   <h3 class="fn" id="convert">
<code>[static, since 5.2] </code><span class="type">bool</span> QMetaType::<span class="name">convert</span>(<span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>fromType</i>, const <span class="type">void</span> *<i>from</i>, <span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>toType</i>, <span class="type">void</span> *<i>to</i>)
</h3> <p>Converts the object at <i>from</i> from <i>fromType</i> to the preallocated space at <i>to</i> typed <i>toType</i>. Returns <code>true</code>, if the conversion succeeded, otherwise false.</p> <p>Both <i>from</i> and <i>to</i> have to be valid pointers.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="create-1">
<code>[since 5.0] </code><span class="type">void</span> *QMetaType::<span class="name">create</span>(const <span class="type">void</span> *<i>copy</i> = nullptr) const
</h3> <p>Returns a copy of <i>copy</i>, assuming it is of the type that this <a href="qmetatype.html">QMetaType</a> instance was created for. If <i>copy</i> is <code>nullptr</code>, creates a default constructed instance.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#destroy">QMetaType::destroy</a>().</p>   <h3 class="fn" id="debugStream">
<code>[since 5.2] </code><span class="type">bool</span> QMetaType::<span class="name">debugStream</span>(<span class="type"><a href="qdebug.html">QDebug</a></span> &amp;<i>dbg</i>, const <span class="type">void</span> *<i>rhs</i>)
</h3> <p>Streams the object at <i>rhs</i> to the debug stream <i>dbg</i>. Returns <code>true</code> on success, otherwise false.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="destroy-1">
<code>[since 5.0] </code><span class="type">void</span> QMetaType::<span class="name">destroy</span>(<span class="type">void</span> *<i>data</i>) const
</h3> <p>Destroys the <i>data</i>, assuming it is of the type that this <a href="qmetatype.html">QMetaType</a> instance was created for.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#create">QMetaType::create</a>().</p>   <h3 class="fn" id="destruct-1">
<code>[since 5.0] </code><span class="type">void</span> QMetaType::<span class="name">destruct</span>(<span class="type">void</span> *<i>data</i>) const
</h3> <p>Destructs the value, located at <i>data</i>, assuming that it is of the type for which this <a href="qmetatype.html">QMetaType</a> instance was constructed for.</p> <p>Unlike destroy(), this function only invokes the type's destructor, it doesn't invoke the delete operator.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#construct">QMetaType::construct</a>().</p>   <h3 class="fn" id="equals">
<code>[since 6.0] </code><span class="type">bool</span> QMetaType::<span class="name">equals</span>(const <span class="type">void</span> *<i>lhs</i>, const <span class="type">void</span> *<i>rhs</i>) const
</h3> <p>Compares the objects at <i>lhs</i> and <i>rhs</i> for equality.</p> <p>Both objects must be of the type described by this metatype. Can only compare the two objects if a less than or equality operator for the type was visible to the metatype declaration. Otherwise, the metatype never considers values equal. When an equality operator was visible to the metatype declaration, it is authoritative; otherwise, if less than is visible, when neither value is less than the other, the two are considered equal. If values are unordered (see <a href="qmetatype.html#compare">compare</a>() for details) they are not equal.</p> <p>Returns true if the two objects compare equal, otherwise false.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qmetatype.html#isEqualityComparable">isEqualityComparable</a>() and <a href="qmetatype.html#compare">compare</a>().</p>   <h3 class="fn" id="flags">
<code>[since 5.0] </code><span class="type"><a href="qmetatype.html#TypeFlag-enum">QMetaType::TypeFlags</a></span> QMetaType::<span class="name">flags</span>() const
</h3> <p>Returns flags of the type for which this <a href="qmetatype.html">QMetaType</a> instance was constructed.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qmetatype.html#TypeFlag-enum">QMetaType::TypeFlags</a> and QMetaType::flags().</p>   <h3 class="fn" id="fromName">
<code>[static] </code><span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> QMetaType::<span class="name">fromName</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>typeName</i>)
</h3> <p>Returns a <a href="qmetatype.html">QMetaType</a> matching <i>typeName</i>. The returned object is not valid if the typeName is not known to <a href="qmetatype.html">QMetaType</a></p>   <h3 class="fn" id="fromType">
<code>[static, since 5.15] </code>template &lt;typename T&gt; <span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> QMetaType::<span class="name">fromType</span>()
</h3> <p>Returns the <a href="qmetatype.html">QMetaType</a> corresponding to the type in the template parameter.</p> <p>This function was introduced in Qt 5.15.</p>   <h3 class="fn" id="hasRegisteredConverterFunction">
<code>[static, since 5.2] </code><span class="type">bool</span> QMetaType::<span class="name">hasRegisteredConverterFunction</span>(<span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>fromType</i>, <span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>toType</i>)
</h3> <p>Returns <code>true</code>, if the meta type system has a registered conversion from meta type id <i>fromType</i> to <i>toType</i></p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="hasRegisteredConverterFunction-1">
<code>[static, since 5.2] </code>template &lt;typename From, typename To&gt; <span class="type">bool</span> QMetaType::<span class="name">hasRegisteredConverterFunction</span>()
</h3> <p>Returns <code>true</code>, if the meta type system has a registered conversion from type From to type To. </p>
<p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="hasRegisteredDataStreamOperators">
<code>[since 6.1] </code><span class="type">bool</span> QMetaType::<span class="name">hasRegisteredDataStreamOperators</span>() const
</h3> <p>Returns <code>true</code>, if the meta type system has registered data stream operators for this meta type.</p> <p>This function was introduced in Qt 6.1.</p>   <h3 class="fn" id="hasRegisteredDebugStreamOperator">
<code>[since 6.0] </code><span class="type">bool</span> QMetaType::<span class="name">hasRegisteredDebugStreamOperator</span>() const
</h3> <p>Returns <code>true</code>, if the meta type system has a registered debug stream operator for this meta type.</p> <p>This function was introduced in Qt 6.0.</p>   <h3 class="fn" id="hasRegisteredMutableViewFunction">
<code>[static, since 5.2] </code><span class="type">bool</span> QMetaType::<span class="name">hasRegisteredMutableViewFunction</span>(<span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>fromType</i>, <span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>toType</i>)
</h3> <p>Returns <code>true</code>, if the meta type system has a registered mutable view on meta type id <i>fromType</i> of meta type id <i>toType</i>.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="hasRegisteredMutableViewFunction-1">
<code>[static, since 6.0] </code>template &lt;typename From, typename To&gt; <span class="type">bool</span> QMetaType::<span class="name">hasRegisteredMutableViewFunction</span>()
</h3> <p>Returns <code>true</code>, if the meta type system has a registered mutable view on type From of type To. </p>
<p>This is an overloaded function.</p> <p>This function was introduced in Qt 6.0.</p>   <h3 class="fn" id="id">
<code>[since 5.13] </code><span class="type">int</span> QMetaType::<span class="name">id</span>() const
</h3> <p>Returns id type hold by this QMetatype instance.</p> <p>This function was introduced in Qt 5.13.</p>   <h3 class="fn" id="isEqualityComparable">
<span class="type">bool</span> QMetaType::<span class="name">isEqualityComparable</span>() const
</h3> <p>Returns <code>true</code> if a less than or equality operator for the type described by this metatype was visible to the metatype declaration, otherwise <code>false</code>.</p> <p><b>See also </b><a href="qmetatype.html#equals">equals</a>() and <a href="qmetatype.html#isOrdered">isOrdered</a>().</p>   <h3 class="fn" id="isOrdered">
<span class="type">bool</span> QMetaType::<span class="name">isOrdered</span>() const
</h3> <p>Returns <code>true</code> if a less than operator for the type described by this metatype was visible to the metatype declaration, otherwise <code>false</code>.</p> <p><b>See also </b><a href="qmetatype.html#compare">compare</a>() and <a href="qmetatype.html#isEqualityComparable">isEqualityComparable</a>().</p>   <h3 class="fn" id="isRegistered">
<code>[static] </code><span class="type">bool</span> QMetaType::<span class="name">isRegistered</span>(<span class="type">int</span> <i>type</i>)
</h3> <p>Returns <code>true</code> if the datatype with ID <i>type</i> is registered; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#type">type</a>(), <a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#typeName">typeName</a>(), and <a href="qmetatype.html#Type-enum">Type</a>.</p>   <h3 class="fn" id="isRegistered-1">
<code>[since 5.0] </code><span class="type">bool</span> QMetaType::<span class="name">isRegistered</span>() const
</h3> <p>Returns <code>true</code> if this <a href="qmetatype.html">QMetaType</a> object contains valid information about a type, false otherwise.</p> <p>This function was introduced in Qt 5.0.</p>   <h3 class="fn" id="isValid">
<code>[since 5.0] </code><span class="type">bool</span> QMetaType::<span class="name">isValid</span>() const
</h3> <p>Returns <code>true</code> if this <a href="qmetatype.html">QMetaType</a> object contains valid information about a type, false otherwise.</p> <p>This function was introduced in Qt 5.0.</p>   <h3 class="fn" id="load">
<span class="type">bool</span> QMetaType::<span class="name">load</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>stream</i>, <span class="type">void</span> *<i>data</i>) const
</h3> <p>Reads the object of this type from the given <i>stream</i> into <i>data</i>. Returns <code>true</code> if the object is loaded successfully; otherwise returns <code>false</code>.</p> <p>The type must have been registered with <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>() beforehand.</p> <p>Normally, you should not need to call this function directly. Instead, use <a href="qmetatype.html#Type-enum">QVariant</a>'s <code>operator&gt;&gt;()</code>, which relies on load() to stream custom types.</p> <p><b>See also </b><a href="qmetatype.html#save">save</a>().</p>   <h3 class="fn" id="metaObject">
<code>[since 5.5] </code>const <span class="type"><a href="qmetaobject.html">QMetaObject</a></span> *QMetaType::<span class="name">metaObject</span>() const
</h3> <p>return a <a href="qmetaobject.html">QMetaObject</a> relative to this type.</p> <p>If the type is a pointer type to a subclass of <a href="qobject.html">QObject</a>, <a href="qmetatype.html#flags">flags</a>() contains <a href="qmetatype.html#TypeFlag-enum">QMetaType::PointerToQObject</a> and this function returns the corresponding <a href="qmetaobject.html">QMetaObject</a>. This can be used to in combinaison with QMetaObject::construct to create <a href="qobject.html">QObject</a> of this type.</p> <p>If the type is a <a href="qobject.html#Q_GADGET">Q_GADGET</a>, <a href="qmetatype.html#flags">flags</a>() contains <a href="qmetatype.html#TypeFlag-enum">QMetaType::IsGadget</a>, and this function returns its <a href="qmetaobject.html">QMetaObject</a>. This can be used to retrieve <a href="qmetamethod.html">QMetaMethod</a> and <a href="qmetaproperty.html">QMetaProperty</a> and use them on a pointer of this type. (given by <a href="qvariant.html#data">QVariant::data</a> for example)</p> <p>If the type is an enumeration, <a href="qmetatype.html#flags">flags</a>() contains <a href="qmetatype.html#TypeFlag-enum">QMetaType::IsEnumeration</a>, and this function returns the <a href="qmetaobject.html">QMetaObject</a> of the enclosing object if the enum was registered as a <a href="qobject.html#Q_ENUM">Q_ENUM</a> or <code>nullptr</code> otherwise</p> <p>This function was introduced in Qt 5.5.</p> <p><b>See also </b><a href="qmetatype.html#flags">QMetaType::flags</a>().</p>   <h3 class="fn" id="name">
<code>[since 5.15] </code>const <span class="type">char</span> *QMetaType::<span class="name">name</span>() const
</h3> <p>Returns the type name associated with this <a href="qmetatype.html">QMetaType</a>, or a null pointer if no matching type was found. The returned pointer must not be deleted.</p> <p>This function was introduced in Qt 5.15.</p> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#typeName">typeName</a>().</p>   <h3 class="fn" id="registerConverter">
<code>[static, since 5.2] </code>template &lt;typename From, typename To&gt; <span class="type">bool</span> QMetaType::<span class="name">registerConverter</span>()
</h3> <p>Registers the possibility of an implicit conversion from type From to type To in the meta type system. Returns <code>true</code> if the registration succeeded, otherwise false.</p>  <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="save">
<span class="type">bool</span> QMetaType::<span class="name">save</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>stream</i>, const <span class="type">void</span> *<i>data</i>) const
</h3> <p>Writes the object pointed to by <i>data</i> to the given <i>stream</i>. Returns <code>true</code> if the object is saved successfully; otherwise returns <code>false</code>.</p> <p>The type must have been registered with <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>() beforehand.</p> <p>Normally, you should not need to call this function directly. Instead, use <a href="qmetatype.html#Type-enum">QVariant</a>'s <code>operator&lt;&lt;()</code>, which relies on save() to stream custom types.</p> <p><b>See also </b><a href="qmetatype.html#load">load</a>().</p>   <h3 class="fn" id="sizeOf-1">
<code>[since 5.0] </code><span class="type">qsizetype</span> QMetaType::<span class="name">sizeOf</span>() const
</h3> <p>Returns the size of the type in bytes (i.e. sizeof(T), where T is the actual type for which this <a href="qmetatype.html">QMetaType</a> instance was constructed for).</p> <p>This function is typically used together with construct() to perform low-level management of the memory used by a type.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#construct">QMetaType::construct</a>(), QMetaType::sizeOf(), and <a href="qmetatype.html#alignOf">QMetaType::alignOf</a>().</p>   <h3 class="fn" id="view">
<code>[static, since 6.0] </code><span class="type">bool</span> QMetaType::<span class="name">view</span>(<span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>fromType</i>, <span class="type">void</span> *<i>from</i>, <span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>toType</i>, <span class="type">void</span> *<i>to</i>)
</h3> <p>Creates a mutable view on the object at <i>from</i> of <i>fromType</i> in the preallocated space at <i>to</i> typed <i>toType</i>. Returns <code>true</code> if the conversion succeeded, otherwise false.</p> <p>This function was introduced in Qt 6.0.</p>   <div class="relnonmem"> <h2>Related Non-Members</h2>  <h3 class="fn" id="qMetaTypeId">template &lt;typename T&gt; <span class="type">int</span> <span class="name">qMetaTypeId</span>()
</h3> <p>Returns the meta type id of type <code>T</code> at compile time. If the type was not declared with <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>(), compilation will fail.</p> <p>Typical usage:</p> <pre data-language="cpp">int id = qMetaTypeId&lt;QString&gt;();    // id is now QMetaType::QString
id = qMetaTypeId&lt;MyStruct&gt;();       // compile error if MyStruct not declared</pre> <p>QMetaType::type() returns the same ID as qMetaTypeId(), but does a lookup at runtime based on the name of the type. QMetaType::type() is a bit slower, but compilation succeeds if a type is not registered.</p> <p><b>See also </b><a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>() and <a href="https://doc.qt.io/qt-6.2/qmetatype-obsolete.html#type">QMetaType::type</a>().</p>   <h3 class="fn" id="qRegisterMetaType">template &lt;typename T&gt; <span class="type">int</span> <span class="name">qRegisterMetaType</span>(const <span class="type">char</span> *<i>typeName</i>)
</h3> <p>Registers the type name <i>typeName</i> for the type <code>T</code>. Returns the internal ID used by <a href="qmetatype.html">QMetaType</a>. Any class or struct that has a public default constructor, a public copy constructor and a public destructor can be registered.</p> <p>This function requires that <code>T</code> is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <a href="qmetatype.html#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</a>() to be able to register pointers to forward declared types.</p> <p>After a type has been registered, you can create and destroy objects of that type dynamically at run-time.</p> <p>This example registers the class <code>MyClass</code>:</p> <pre data-language="cpp">qRegisterMetaType&lt;MyClass&gt;("MyClass");</pre> <p>This function is useful to register typedefs so they can be used by <a href="qmetaproperty.html">QMetaProperty</a>, or in QueuedConnections</p> <pre data-language="cpp">typedef QString CustomString;
qRegisterMetaType&lt;CustomString&gt;("CustomString");</pre> <div class="admonition warning"> <p><b>Warning: </b>This function is useful only for registering an alias (typedef) for every other use case <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a> and <a href="qmetatype.html#qMetaTypeId">qMetaTypeId</a>() should be used instead.</p> </div> <p><b>See also </b><a href="qmetatype.html#isRegistered-1">isRegistered</a>() and <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>().</p>   <h3 class="fn" id="qRegisterMetaType-1">template &lt;typename T&gt; <span class="type">int</span> <span class="name">qRegisterMetaType</span>()
</h3> <p>Call this function to register the type <code>T</code>. <code>T</code> must be declared with <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>(). Returns the meta type Id.</p> <p>Example:</p> <pre data-language="cpp">int id = qRegisterMetaType&lt;MyStruct&gt;();</pre> <p>This function requires that <code>T</code> is a fully defined type at the point where the function is called. For pointer types, it also requires that the pointed to type is fully defined. Use <a href="qmetatype.html#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</a>() to be able to register pointers to forward declared types.</p> <p>After a type has been registered, you can create and destroy objects of that type dynamically at run-time.</p> <p>To use the type <code>T</code> in <a href="qmetatype.html#Type-enum">QVariant</a>, using <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>() is sufficient. To use the type <code>T</code> in queued signal and slot connections, <code>qRegisterMetaType&lt;T&gt;()</code> must be called before the first connection is established.</p> <p>Also, to use type <code>T</code> with the <a href="qobject.html#property">QObject::property</a>() API, <code>qRegisterMetaType&lt;T&gt;()</code> must be called before it is used, typically in the constructor of the class that uses <code>T</code>, or in the <code>main()</code> function.</p> <p><b>See also </b><a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>().</p>   <h3 class="fn" id="operator-not-eq">
<code>[since 5.15] </code><span class="type">bool</span> <span class="name">operator!=</span>(<span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>a</i>, <span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>b</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns <code>true</code> if the <a href="qmetatype.html">QMetaType</a> <i>a</i> represents a different type than the <a href="qmetatype.html">QMetaType</a> <i>b</i>, otherwise returns <code>false</code>.</p> <p>This function was introduced in Qt 5.15.</p>   <h3 class="fn" id="operator-eq-eq">
<code>[since 5.15] </code><span class="type">bool</span> <span class="name">operator==</span>(<span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>a</i>, <span class="type"><a href="qmetatype.html#QMetaType">QMetaType</a></span> <i>b</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns <code>true</code> if the <a href="qmetatype.html">QMetaType</a> <i>a</i> represents the same type as the <a href="qmetatype.html">QMetaType</a> <i>b</i>, otherwise returns <code>false</code>.</p> <p>This function was introduced in Qt 5.15.</p>  </div> <div class="macros"> <h2>Macro Documentation</h2>  <h3 class="fn" id="Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE">
<span class="name">Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE</span>(<i>Container</i>)
</h3> <p>This macro makes the container <i>Container</i> known to <a href="qmetatype.html">QMetaType</a> as an associative container. This makes it possible to put an instance of Container&lt;T, U&gt; into a <a href="qmetatype.html#Type-enum">QVariant</a>, if T and U are themselves known to <a href="qmetatype.html">QMetaType</a>.</p> <p>Note that all of the Qt associative containers already have built-in support, and it is not necessary to use this macro with them. The std::map container also has built-in support.</p> <p>This example shows a typical use of Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE():</p> <pre data-language="cpp">#include &lt;unordered_list&gt;

Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(std::unordered_map)

void someFunc()
{
    std::unordered_map&lt;int, bool&gt; container;
    QVariant var = QVariant::fromValue(container);
    // ...
}</pre>   <h3 class="fn" id="Q_DECLARE_METATYPE">
<span class="name">Q_DECLARE_METATYPE</span>(<i>Type</i>)
</h3> <p>This macro makes the type <i>Type</i> known to <a href="qmetatype.html">QMetaType</a> as long as it provides a public default constructor, a public copy constructor and a public destructor. It is needed to use the type <i>Type</i> as a custom type in <a href="qmetatype.html#Type-enum">QVariant</a>.</p> <p>This macro requires that <i>Type</i> is a fully defined type at the point where it is used. For pointer types, it also requires that the pointed to type is fully defined. Use in conjunction with <a href="qmetatype.html#Q_DECLARE_OPAQUE_POINTER">Q_DECLARE_OPAQUE_POINTER</a>() to register pointers to forward declared types.</p> <p>Ideally, this macro should be placed below the declaration of the class or struct. If that is not possible, it can be put in a private header file which has to be included every time that type is used in a <a href="qmetatype.html#Type-enum">QVariant</a>.</p> <p>Adding a Q_DECLARE_METATYPE() makes the type known to all template based functions, including <a href="qmetatype.html#Type-enum">QVariant</a>. Note that if you intend to use the type in <i>queued</i> signal and slot connections or in <a href="qobject.html">QObject</a>'s property system, you also have to call <a href="qmetatype.html#qRegisterMetaType-1">qRegisterMetaType</a>() since the names are resolved at runtime.</p> <p>This example shows a typical use case of Q_DECLARE_METATYPE():</p> <pre data-language="cpp">struct MyStruct
{
    int i;
    ...
};

Q_DECLARE_METATYPE(MyStruct)</pre> <p>If <code>MyStruct</code> is in a namespace, the Q_DECLARE_METATYPE() macro has to be outside the namespace:</p> <pre data-language="cpp">namespace MyNamespace
{
    ...
}

Q_DECLARE_METATYPE(MyNamespace::MyStruct)</pre> <p>Since <code>MyStruct</code> is now known to <a href="qmetatype.html">QMetaType</a>, it can be used in <a href="qmetatype.html#Type-enum">QVariant</a>:</p> <pre data-language="cpp">MyStruct s;
QVariant var;
var.setValue(s); // copy s into the variant

...

// retrieve the value
MyStruct s2 = var.value&lt;MyStruct&gt;();</pre> <p>Some types are registered automatically and do not need this macro:</p> <ul> <li>Pointers to classes derived from <a href="qobject.html">QObject</a>
</li> <li>
<a href="qlist.html">QList</a>&lt;T&gt;, <a href="qqueue.html">QQueue</a>&lt;T&gt;, <a href="qstack.html">QStack</a>&lt;T&gt; or <a href="qset.html">QSet</a>&lt;T&gt; where T is a registered meta type</li> <li>
<a href="qhash.html#qhash">QHash</a>&lt;T1, T2&gt;, <a href="qmap.html">QMap</a>&lt;T1, T2&gt; or QPair&lt;T1, T2&gt; where T1 and T2 are registered meta types</li> <li>
<a href="qpointer.html">QPointer</a>&lt;T&gt;, <a href="qsharedpointer.html">QSharedPointer</a>&lt;T&gt;, <a href="qweakpointer.html">QWeakPointer</a>&lt;T&gt;, where T is a class that derives from <a href="qobject.html">QObject</a>
</li> <li>Enumerations registered with <a href="qobject.html#Q_ENUM">Q_ENUM</a> or <a href="qobject.html#Q_FLAG">Q_FLAG</a>
</li> <li>Classes that have a <a href="qobject.html#Q_GADGET">Q_GADGET</a> macro</li> </ul> <div class="admonition note"> <p><b>Note: </b>This method also registers the stream and debug operators for the type if they are visible at registration time. As this is done automatically in some places, it is strongly recommended to declare the stream operators for a type directly after the type itself. Because of the argument dependent lookup rules of C++, it is also strongly recommended to declare the operators in the same namespace as the type itself.</p> </div> <p>The stream operators should have the following signatures:</p> <pre data-language="cpp">QDataStream &amp;operator&lt;&lt;(QDataStream &amp;out, const MyClass &amp;myObj);
QDataStream &amp;operator&gt;&gt;(QDataStream &amp;in, MyClass &amp;myObj);</pre> <p><b>See also </b><a href="qmetatype.html#qRegisterMetaType-1">qRegisterMetaType</a>().</p>   <h3 class="fn" id="Q_DECLARE_OPAQUE_POINTER">
<code>[since 5.0] </code><span class="name">Q_DECLARE_OPAQUE_POINTER</span>(<i>PointerType</i>)
</h3> <p>This macro enables pointers to forward-declared types (<i>PointerType</i>) to be registered with <a href="qmetatype.html">QMetaType</a> using either <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>() or <a href="qmetatype.html#qRegisterMetaType-1">qRegisterMetaType</a>().</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>() and <a href="qmetatype.html#qRegisterMetaType-1">qRegisterMetaType</a>().</p>   <h3 class="fn" id="Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE">
<span class="name">Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE</span>(<i>Container</i>)
</h3> <p>This macro makes the container <i>Container</i> known to <a href="qmetatype.html">QMetaType</a> as a sequential container. This makes it possible to put an instance of Container&lt;T&gt; into a <a href="qmetatype.html#Type-enum">QVariant</a>, if T itself is known to <a href="qmetatype.html">QMetaType</a>.</p> <p>Note that all of the Qt sequential containers already have built-in support, and it is not necessary to use this macro with them. The std::vector and std::list containers also have built-in support.</p> <p>This example shows a typical use of Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE():</p> <pre data-language="cpp">#include &lt;deque&gt;

Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(std::deque)

void someFunc()
{
    std::deque&lt;QFile*&gt; container;
    QVariant var = QVariant::fromValue(container);
    // ...
}</pre>   <h3 class="fn" id="Q_DECLARE_SMART_POINTER_METATYPE">
<span class="name">Q_DECLARE_SMART_POINTER_METATYPE</span>(<i>SmartPointer</i>)
</h3> <p>This macro makes the smart pointer <i>SmartPointer</i> known to <a href="qmetatype.html">QMetaType</a> as a smart pointer. This makes it possible to put an instance of SmartPointer&lt;T&gt; into a <a href="qmetatype.html#Type-enum">QVariant</a>, if T is a type which inherits <a href="qobject.html">QObject</a>.</p> <p>Note that the <a href="qweakpointer.html">QWeakPointer</a>, <a href="qsharedpointer.html">QSharedPointer</a> and <a href="qpointer.html">QPointer</a> already have built-in support, and it is not necessary to use this macro with them.</p> <p>This example shows a typical use of Q_DECLARE_SMART_POINTER_METATYPE():</p> <pre data-language="cpp">#include &lt;memory&gt;

Q_DECLARE_SMART_POINTER_METATYPE(std::shared_ptr)

void someFunc()
{
    auto smart_ptr = std::make_shared&lt;QFile&gt;();
    QVariant var = QVariant::fromValue(smart_ptr);
    // ...
    if (var.canConvert&lt;QObject*&gt;()) {
        QObject *sp = var.value&lt;QObject*&gt;();
        qDebug() &lt;&lt; sp-&gt;metaObject()-&gt;className(); // Prints 'QFile'.
    }
}</pre>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qmetatype.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qmetatype.html</a>
  </p>
</div>
