<h1 class="title">QSGMaterialShader Class</h1>  <p>The QSGMaterialShader class represents a graphics API independent shader program. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QSGMaterialShader&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Quick REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Quick)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += quick</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.14</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qsgmaterialshader-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> struct </td>
<td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader-graphicspipelinestate.html">GraphicsPipelineState</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> class </td>
<td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader-renderstate.html">RenderState</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgmaterialshader.html#Flag-enum">Flag</a></b> { UpdatesGraphicsPipelineState }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qsgmaterialshader.html#Flag-enum">Flags</a></b></td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgmaterialshader.html#QSGMaterialShader">QSGMaterialShader</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSGMaterialShader::Flags </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgmaterialshader.html#flags">flags</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgmaterialshader.html#setFlag">setFlag</a></b>(QSGMaterialShader::Flags <i>flags</i>, bool <i>on</i> = true)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgmaterialshader.html#setFlags">setFlags</a></b>(QSGMaterialShader::Flags <i>flags</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgmaterialshader.html#updateGraphicsPipelineState">updateGraphicsPipelineState</a></b>(QSGMaterialShader::RenderState &amp;<i>state</i>, QSGMaterialShader::GraphicsPipelineState *<i>ps</i>, QSGMaterial *<i>newMaterial</i>, QSGMaterial *<i>oldMaterial</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgmaterialshader.html#updateSampledImage">updateSampledImage</a></b>(QSGMaterialShader::RenderState &amp;<i>state</i>, int <i>binding</i>, QSGTexture **<i>texture</i>, QSGMaterial *<i>newMaterial</i>, QSGMaterial *<i>oldMaterial</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgmaterialshader.html#updateUniformData">updateUniformData</a></b>(QSGMaterialShader::RenderState &amp;<i>state</i>, QSGMaterial *<i>newMaterial</i>, QSGMaterial *<i>oldMaterial</i>)</td>
</tr> </table> <h2 id="protected-functions">Protected Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgmaterialshader.html#setShader">setShader</a></b>(QSGMaterialShader::Stage <i>stage</i>, const QShader &amp;<i>shader</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qsgmaterialshader.html#setShaderFileName">setShaderFileName</a></b>(QSGMaterialShader::Stage <i>stage</i>, const QString &amp;<i>filename</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>QSGMaterialShader represents a combination of vertex and fragment shaders, data that define the graphics pipeline state changes, and logic that updates graphics resources, such as uniform buffers and textures.</p> <div class="admonition note"> <p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering">Scene Graph and Rendering</a> for more information.</p> </div> <p>The <a href="qsgmaterial.html">QSGMaterial</a> and QSGMaterialShader form a tight relationship. For one scene graph (including nested graphs), there is one unique QSGMaterialShader instance that encapsulates the shaders and other data the scene graph uses to render an object with that material. Each <a href="qsggeometrynode.html">QSGGeometryNode</a> can have a unique <a href="qsgmaterial.html">QSGMaterial</a> that defines how the graphics pipeline must be configured while drawing the node. An instance of QSGMaterialShader is never created explicitly by the user, it will be created on demand by the scene graph through <a href="qsgmaterial.html#createShader">QSGMaterial::createShader</a>(). The scene graph creates an instance of QSGMaterialShader by calling the <a href="qsgmaterial.html#createShader">QSGMaterial::createShader</a>() method, ensuring that there is only one instance of each shader implementation.</p> <p>In Qt 5, QSGMaterialShader was tied to OpenGL. It was built directly on QOpenGLShaderProgram and had functions like <code>updateState()</code> that could issue arbitrary OpenGL commands. This is no longer the case in Qt 6. QSGMaterialShader is not strictly data-oriented, meaning it provides data (shaders and the desired pipeline state changes) together with logic that updates data in a uniform buffer. Graphics API access is not provided. This means that a QSGMaterialShader cannot make OpenGL, Vulkan, Metal, or Direct 3D calls on its own. Together with the unified shader management, this allows a QSGMaterialShader to be written once, and be functional with any of the supported graphics APIs at run time.</p> <p>The shaders set by calling the protected <a href="qsgmaterialshader.html#setShaderFileName">setShaderFileName</a>() function control what material does with the vertex data from the geometry, and how the fragments are shaded. A QSGMaterialShader will typically set a vertex and a fragment shader during construction. Changing the shaders afterwards may not lead to the desired effect and must be avoided.</p> <p>In Qt 6, the default approach is to ship <code>.qsb</code> files with the application, typically embedded via the resource system, and referenced when calling <a href="qsgmaterialshader.html#setShaderFileName">setShaderFileName</a>(). The <code>.qsb</code> files are generated offline, or at latest at application build time, from Vulkan-style GLSL source code using the <code>qsb</code> tool from the Qt Shader Tools module.</p> <p>There are three virtuals that can be overridden. These provide the data, or the logic to generate the data, for uniform buffers, textures, and pipeline state changes.</p> <p><a href="qsgmaterialshader.html#updateUniformData">updateUniformData</a>() is the function that is most commonly reimplemented in subclasses. This function is expected to update the contents of a <a href="qbytearray.html">QByteArray</a> that will then be exposed to the shaders as a uniform buffer. Any QSGMaterialShader that has a uniform block in its vertex or fragment shader must reimplement <a href="qsgmaterialshader.html#updateUniformData">updateUniformData</a>().</p> <p><a href="qsgmaterialshader.html#updateSampledImage">updateSampledImage</a>() is relevant when the shader code samples textures. The function will be invoked for each sampler (or combined image sampler, in APIs where relevant), giving it the option to specify which <a href="qsgtexture.html">QSGTexture</a> should be exposed to the shader.</p> <p>The shader pipeline state changes are less often used. One use case is materials that wish to use a specific blend mode. The relevant function is <a href="qsgmaterialshader.html#updateGraphicsPipelineState">updateGraphicsPipelineState</a>(). This function is not called unless the QSGMaterialShader has opted in by setting the flag <a href="qsgmaterialshader.html#Flag-enum">UpdatesGraphicsPipelineState</a>. The task of the function is to update the <a href="qsgmaterialshader-graphicspipelinestate.html">GraphicsPipelineState</a> struct instance that is passed to it with the desired changes. Currently only blending and culling-related features are available, other states cannot be controlled by materials.</p> <p>A minimal example, that also includes texture support, could be the following. Here we assume that Material is the <a href="qsgmaterial.html">QSGMaterial</a> that creates an instance of Shader in its <a href="qsgmaterial.html#createShader">createShader</a>(), and that it holds a <a href="qsgtexture.html">QSGTexture</a> we want to sample in the fragment shader. The vertex shader relies only on the modelview-projection matrix.</p> <pre data-language="cpp">class Shader : public QSGMaterialShader
{
public:
    Shader()
    {
        setShaderFileName(VertexStage, QLatin1String(":/materialshader.vert.qsb"));
        setShaderFileName(FragmentStage, QLatin1String(":/materialshader.frag.qsb"));
    }

    bool updateUniformData(RenderState &amp;state, QSGMaterial *, QSGMaterial *)
    {
        bool changed = false;
        QByteArray *buf = state.uniformData();
        if (state.isMatrixDirty()) {
            const QMatrix4x4 m = state.combinedMatrix();
            memcpy(buf-&gt;data(), m.constData(), 64);
            changed = true;
        }
        return changed;
    }

    void updateSampledImage(RenderState &amp;, int binding, QSGTexture **texture, QSGMaterial *newMaterial, QSGMaterial *)
    {
        Material *mat = static_cast&lt;Material *&gt;(newMaterial);
        if (binding == 1)
            *texture = mat-&gt;texture();
    }
};</pre> <p>The Vulkan-style GLSL source code for the shaders could look like the following. These are expected to be preprocessed offline using the <code>qsb</code> tool, which generates the <code>.qsb</code> files referenced in the Shader() constructor.</p> <pre data-language="cpp">#version 440
layout(location = 0) in vec4 aVertex;
layout(location = 1) in vec2 aTexCoord;
layout(location = 0) out vec2 vTexCoord;
layout(std140, binding = 0) uniform buf {
    mat4 qt_Matrix;
} ubuf;
out gl_PerVertex { vec4 gl_Position; };
void main() {
    gl_Position = ubuf.qt_Matrix * aVertex;
    vTexCoord = aTexCoord;
}</pre> <pre data-language="cpp">#version 440
layout(location = 0) in vec2 vTexCoord;
layout(location = 0) out vec4 fragColor;
layout(binding = 1) uniform sampler2D srcTex;
void main() {
    vec4 c = texture(srcTex, vTexCoord);
    fragColor = vec4(c.rgb * 0.5, 1.0);
}</pre> <div class="admonition note"> <p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering">Scene Graph and Rendering</a> for more information.</p> </div>  <p><b>See also </b><a href="qsgmaterial.html">QSGMaterial</a>, <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-custommaterial-example.html">Scene Graph - Custom Material</a>, <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-twotextureproviders-example.html">Scene Graph - Two Texture Providers</a>, and <a href="https://doc.qt.io/qt-6.2/qtquick-scenegraph-graph-example.html">Scene Graph - Graph</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="flags" id="Flag-enum">enum QSGMaterialShader::<span class="name">Flag</span>flags QSGMaterialShader::<span class="name">Flags</span>
</h3> <p>Flag values to indicate special material properties.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QSGMaterialShader::UpdatesGraphicsPipelineState</code></td>
<td class="topAlign tblval"><code>0x0001</code></td>
<td class="topAlign">Setting this flag enables calling <a href="qsgmaterialshader.html#updateGraphicsPipelineState">updateGraphicsPipelineState</a>().</td>
</tr> </table> <p>The Flags type is a typedef for <a href="qflags.html">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QSGMaterialShader">QSGMaterialShader::<span class="name">QSGMaterialShader</span>()
</h3> <p>Constructs a new QSGMaterialShader.</p>   <h3 class="fn" id="flags">
<span class="type"><a href="qsgmaterialshader.html#Flag-enum">QSGMaterialShader::Flags</a></span> QSGMaterialShader::<span class="name">flags</span>() const
</h3> <p>Returns the currently set flags for this material shader.</p> <p><b>See also </b><a href="qsgmaterialshader.html#setFlags">setFlags</a>().</p>   <h3 class="fn" id="setFlag">
<span class="type">void</span> QSGMaterialShader::<span class="name">setFlag</span>(<span class="type"><a href="qsgmaterialshader.html#Flag-enum">QSGMaterialShader::Flags</a></span> <i>flags</i>, <span class="type">bool</span> <i>on</i> = true)
</h3> <p>Sets the <i>flags</i> on this material shader if <i>on</i> is true; otherwise clears the specified flags.</p>   <h3 class="fn" id="setFlags">
<span class="type">void</span> QSGMaterialShader::<span class="name">setFlags</span>(<span class="type"><a href="qsgmaterialshader.html#Flag-enum">QSGMaterialShader::Flags</a></span> <i>flags</i>)
</h3> <p>Sets the <i>flags</i> for this material shader.</p> <p><b>See also </b><a href="qsgmaterialshader.html#flags">flags</a>().</p>   <h3 class="fn" id="setShader">
<code>[protected] </code><span class="type">void</span> QSGMaterialShader::<span class="name">setShader</span>(<span class="type">QSGMaterialShader::Stage</span> <i>stage</i>, const <span class="type">QShader</span> &amp;<i>shader</i>)
</h3> <p>Sets the <i>shader</i> for the specified <i>stage</i>.</p>   <h3 class="fn" id="setShaderFileName">
<code>[protected] </code><span class="type">void</span> QSGMaterialShader::<span class="name">setShaderFileName</span>(<span class="type">QSGMaterialShader::Stage</span> <i>stage</i>, const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>filename</i>)
</h3> <p>Sets the <i>filename</i> for the shader for the specified <i>stage</i>.</p> <p>The file is expected to contain a serialized QShader.</p>   <h3 class="fn" id="updateGraphicsPipelineState">
<code>[virtual] </code><span class="type">bool</span> QSGMaterialShader::<span class="name">updateGraphicsPipelineState</span>(<span class="type"><a href="qsgmaterialshader-renderstate.html">QSGMaterialShader::RenderState</a></span> &amp;<i>state</i>, <span class="type"><a href="qsgmaterialshader-graphicspipelinestate.html">QSGMaterialShader::GraphicsPipelineState</a></span> *<i>ps</i>, <span class="type"><a href="qsgmaterial.html">QSGMaterial</a></span> *<i>newMaterial</i>, <span class="type"><a href="qsgmaterial.html">QSGMaterial</a></span> *<i>oldMaterial</i>)
</h3> <p>This function is called by the scene graph to enable the material to provide a custom set of graphics state. The set of states that are customizable by material is limited to blending and related settings.</p> <div class="admonition note"> <p><b>Note: </b>This function is only called when the <a href="qsgmaterialshader.html#Flag-enum">UpdatesGraphicsPipelineState</a> flag was enabled via <a href="qsgmaterialshader.html#setFlags">setFlags</a>(). By default it is not set, and so this function is never called.</p> </div> <p>The return value must be <code>true</code> whenever a change was made to any of the members in <i>ps</i>.</p> <div class="admonition note"> <p><b>Note: </b>The contents of <i>ps</i> is not persistent between invocations of this function.</p> </div> <p>The current rendering <i>state</i> is passed from the scene graph.</p> <p>The subclass specific state can be extracted from <i>newMaterial</i>. When <i>oldMaterial</i> is null, this shader was just activated.</p>   <h3 class="fn" id="updateSampledImage">
<code>[virtual] </code><span class="type">void</span> QSGMaterialShader::<span class="name">updateSampledImage</span>(<span class="type"><a href="qsgmaterialshader-renderstate.html">QSGMaterialShader::RenderState</a></span> &amp;<i>state</i>, <span class="type">int</span> <i>binding</i>, <span class="type"><a href="qsgtexture.html">QSGTexture</a></span> **<i>texture</i>, <span class="type"><a href="qsgmaterial.html">QSGMaterial</a></span> *<i>newMaterial</i>, <span class="type"><a href="qsgmaterial.html">QSGMaterial</a></span> *<i>oldMaterial</i>)
</h3> <p>This function is called by the scene graph to prepare using a sampled image in the shader, typically in form of a combined image sampler.</p> <p><i>binding</i> is the binding number of the sampler. The function is called for each combined image sampler variable in the shader code associated with the <a href="qsgmaterialshader.html">QSGMaterialShader</a>.</p> <p>When *<i>texture</i> is null, it must be set to a <a href="qsgtexture.html">QSGTexture</a> pointer before returning. When non-null, it is up to the material to decide if a new <code>QSGTexture *</code> is stored to it, or if it updates some parameters on the already known <a href="qsgtexture.html">QSGTexture</a>. The ownership of the <a href="qsgtexture.html">QSGTexture</a> is not transferred.</p> <p>The current rendering <i>state</i> is passed from the scene graph. Where relevant, it is up to the material to trigger enqueuing texture data uploads.</p> <p>The subclass specific state can be extracted from <i>newMaterial</i>.</p> <p><i>oldMaterial</i> can be used to minimize changes. When <i>oldMaterial</i> is null, this shader was just activated.</p>   <h3 class="fn" id="updateUniformData">
<code>[virtual] </code><span class="type">bool</span> QSGMaterialShader::<span class="name">updateUniformData</span>(<span class="type"><a href="qsgmaterialshader-renderstate.html">QSGMaterialShader::RenderState</a></span> &amp;<i>state</i>, <span class="type"><a href="qsgmaterial.html">QSGMaterial</a></span> *<i>newMaterial</i>, <span class="type"><a href="qsgmaterial.html">QSGMaterial</a></span> *<i>oldMaterial</i>)
</h3> <p>This function is called by the scene graph to get the contents of the shader program's uniform buffer updated. The implementation is not expected to perform any real graphics operations, it is merely responsible for copying data to the <a href="qbytearray.html">QByteArray</a> returned from <a href="qsgmaterialshader-renderstate.html#uniformData">RenderState::uniformData</a>(). The scene graph takes care of making that buffer visible in the shaders.</p> <p>The current rendering <i>state</i> is passed from the scene graph. If the state indicates that any relevant state is dirty, the implementation must update the appropriate region in the buffer data that is accessible via <a href="qsgmaterialshader-renderstate.html#uniformData">RenderState::uniformData</a>(). When a state, such as, matrix or opacity, is not dirty, there is no need to touch the corresponding region since the data is persistent.</p> <p>The return value must be <code>true</code> whenever any change was made to the uniform data.</p> <p>The subclass specific state, such as the color of a flat color material, should be extracted from <i>newMaterial</i> to update the relevant regions in the buffer accordingly.</p> <p><i>oldMaterial</i> can be used to minimize buffer changes (which are typically memcpy calls) when updating material states. When <i>oldMaterial</i> is null, this shader was just activated.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qsgmaterialshader.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qsgmaterialshader.html</a>
  </p>
</div>
