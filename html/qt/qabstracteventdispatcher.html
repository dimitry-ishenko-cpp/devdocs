<h1 class="title">QAbstractEventDispatcher Class</h1>  <p>The QAbstractEventDispatcher class provides an interface to manage Qt's event queue. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QAbstractEventDispatcher&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qobject.html">QObject</a>
</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qabstracteventdispatcher-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> struct </td>
<td class="memItemRight bottomAlign"><b><a href="qabstracteventdispatcher-timerinfo.html">TimerInfo</a></b></td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#QAbstractEventDispatcher">QAbstractEventDispatcher</a></b>(QObject *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#dtor.QAbstractEventDispatcher">~QAbstractEventDispatcher</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#filterNativeEvent">filterNativeEvent</a></b>(const QByteArray &amp;<i>eventType</i>, void *<i>message</i>, qintptr *<i>result</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#installNativeEventFilter">installNativeEventFilter</a></b>(QAbstractNativeEventFilter *<i>filterObj</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#interrupt">interrupt</a></b>() = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#processEvents">processEvents</a></b>(QEventLoop::ProcessEventsFlags <i>flags</i>) = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#registerSocketNotifier">registerSocketNotifier</a></b>(QSocketNotifier *<i>notifier</i>) = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#registerTimer">registerTimer</a></b>(qint64 <i>interval</i>, Qt::TimerType <i>timerType</i>, QObject *<i>object</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#registerTimer-1">registerTimer</a></b>(int <i>timerId</i>, qint64 <i>interval</i>, Qt::TimerType <i>timerType</i>, QObject *<i>object</i>) = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QList&lt;QAbstractEventDispatcher::TimerInfo&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#registeredTimers">registeredTimers</a></b>(QObject *<i>object</i>) const = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual int </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#remainingTime">remainingTime</a></b>(int <i>timerId</i>) = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#removeNativeEventFilter">removeNativeEventFilter</a></b>(QAbstractNativeEventFilter *<i>filter</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#unregisterSocketNotifier">unregisterSocketNotifier</a></b>(QSocketNotifier *<i>notifier</i>) = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#unregisterTimer">unregisterTimer</a></b>(int <i>timerId</i>) = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#unregisterTimers">unregisterTimers</a></b>(QObject *<i>object</i>) = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#wakeUp">wakeUp</a></b>() = 0</td>
</tr> </table> <h2 id="signals">Signals
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#aboutToBlock">aboutToBlock</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#awake">awake</a></b>()</td>
</tr> </table> <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QAbstractEventDispatcher *</td>
<td class="memItemRight bottomAlign">
<b><a href="qabstracteventdispatcher.html#instance">instance</a></b>(QThread *<i>thread</i> = nullptr)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>An event dispatcher receives events from the window system and other sources. It then sends them to the <a href="qcoreapplication.html">QCoreApplication</a> or <a href="qapplication.html">QApplication</a> instance for processing and delivery. QAbstractEventDispatcher provides fine-grained control over event delivery.</p> <p>For simple control of event processing use <a href="qcoreapplication.html#processEvents">QCoreApplication::processEvents</a>().</p> <p>For finer control of the application's event loop, call <a href="qabstracteventdispatcher.html#instance">instance</a>() and call functions on the QAbstractEventDispatcher object that is returned. If you want to use your own instance of QAbstractEventDispatcher or of a QAbstractEventDispatcher subclass, you must install it with <a href="qcoreapplication.html#setEventDispatcher">QCoreApplication::setEventDispatcher</a>() or <a href="qthread.html#setEventDispatcher">QThread::setEventDispatcher</a>() <i>before</i> a default event dispatcher has been installed.</p> <p>The main event loop is started by calling <a href="qcoreapplication.html#exec">QCoreApplication::exec</a>(), and stopped by calling <a href="qcoreapplication.html#exit">QCoreApplication::exit</a>(). Local event loops can be created using <a href="qeventloop.html">QEventLoop</a>.</p> <p>Programs that perform long operations can call <a href="qabstracteventdispatcher.html#processEvents">processEvents</a>() with a bitwise OR combination of various <a href="qeventloop.html#ProcessEventsFlag-enum">QEventLoop::ProcessEventsFlag</a> values to control which events should be delivered.</p> <p>QAbstractEventDispatcher also allows the integration of an external event loop with the Qt event loop.</p>  <p><b>See also </b><a href="qeventloop.html">QEventLoop</a>, <a href="qcoreapplication.html">QCoreApplication</a>, and <a href="qthread.html">QThread</a>.</p>   <h2>Member Function Documentation</h2>  <h3 class="fn" id="QAbstractEventDispatcher">QAbstractEventDispatcher::<span class="name">QAbstractEventDispatcher</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)
</h3> <p>Constructs a new event dispatcher with the given <i>parent</i>.</p>   <h3 class="fn" id="aboutToBlock">
<code>[signal] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">aboutToBlock</span>()
</h3> <p>This signal is emitted before the event loop calls a function that could block.</p> <p><b>See also </b><a href="qabstracteventdispatcher.html#awake">awake</a>().</p>   <h3 class="fn" id="awake">
<code>[signal] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">awake</span>()
</h3> <p>This signal is emitted after the event loop returns from a function that could block.</p> <p><b>See also </b><a href="qabstracteventdispatcher.html#wakeUp">wakeUp</a>() and <a href="qabstracteventdispatcher.html#aboutToBlock">aboutToBlock</a>().</p>   <h3 class="fn" id="dtor.QAbstractEventDispatcher">
<code>[virtual] </code>QAbstractEventDispatcher::<span class="name">~QAbstractEventDispatcher</span>()
</h3> <p>Destroys the event dispatcher.</p>   <h3 class="fn" id="filterNativeEvent">
<code>[since 5.0] </code><span class="type">bool</span> QAbstractEventDispatcher::<span class="name">filterNativeEvent</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>eventType</i>, <span class="type">void</span> *<i>message</i>, <span class="type"><a href="qtglobal.html#qintptr-typedef">qintptr</a></span> *<i>result</i>)
</h3> <p>Sends <i>message</i> through the event filters that were set by <a href="qabstracteventdispatcher.html#installNativeEventFilter">installNativeEventFilter</a>(). This function returns <code>true</code> as soon as an event filter returns <code>true</code>, and false otherwise to indicate that the processing of the event should continue.</p> <p>Subclasses of <a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a> <i>must</i> call this function for <i>all</i> messages received from the system to ensure compatibility with any extensions that may be used in the application. The type of event <i>eventType</i> is specific to the platform plugin chosen at run-time, and can be used to cast message to the right type. The <i>result</i> pointer is only used on Windows, and corresponds to the LRESULT pointer.</p> <p>Note that the type of <i>message</i> is platform dependent. See <a href="qabstractnativeeventfilter.html">QAbstractNativeEventFilter</a> for details.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qabstracteventdispatcher.html#installNativeEventFilter">installNativeEventFilter</a>() and <a href="qabstractnativeeventfilter.html#nativeEventFilter">QAbstractNativeEventFilter::nativeEventFilter</a>().</p>   <h3 class="fn" id="installNativeEventFilter">
<code>[since 5.0] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">installNativeEventFilter</span>(<span class="type"><a href="qabstractnativeeventfilter.html">QAbstractNativeEventFilter</a></span> *<i>filterObj</i>)
</h3> <p>Installs an event filter <i>filterObj</i> for all native events received by the application.</p> <p>The event filter <i>filterObj</i> receives events via its <a href="qabstractnativeeventfilter.html#nativeEventFilter">nativeEventFilter</a>() function, which is called for all events received by all threads.</p> <p>The <a href="qabstractnativeeventfilter.html#nativeEventFilter">nativeEventFilter</a>() function should return true if the event should be filtered, (in this case, stopped). It should return false to allow normal Qt processing to continue: the native event can then be translated into a <a href="qevent.html">QEvent</a> and handled by the standard Qt <a href="qevent.html">event</a> filtering, e.g. <a href="qobject.html#installEventFilter">QObject::installEventFilter</a>().</p> <p>If multiple event filters are installed, the filter that was installed last is activated first.</p> <div class="admonition note"> <p><b>Note: </b>The filter function set here receives native messages, that is, MSG or XEvent structs.</p> </div> <p>For maximum portability, you should always try to use <a href="qevent.html">QEvent</a> objects and <a href="qobject.html#installEventFilter">QObject::installEventFilter</a>() whenever possible.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qobject.html#installEventFilter">QObject::installEventFilter</a>().</p>   <h3 class="fn" id="instance">
<code>[static] </code><span class="type"><a href="qabstracteventdispatcher.html#QAbstractEventDispatcher">QAbstractEventDispatcher</a></span> *QAbstractEventDispatcher::<span class="name">instance</span>(<span class="type"><a href="qthread.html">QThread</a></span> *<i>thread</i> = nullptr)
</h3> <p>Returns a pointer to the event dispatcher object for the specified <i>thread</i>. If <i>thread</i> is <code>nullptr</code>, the current thread is used. If no event dispatcher exists for the specified thread, this function returns <code>nullptr</code>.</p> <p><b>Note:</b> If Qt is built without thread support, the <i>thread</i> argument is ignored.</p>   <h3 class="fn" id="interrupt">
<code>[pure virtual] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">interrupt</span>()
</h3> <p>Interrupts event dispatching. The event dispatcher will return from <a href="qabstracteventdispatcher.html#processEvents">processEvents</a>() as soon as possible.</p>   <h3 class="fn" id="processEvents">
<code>[pure virtual] </code><span class="type">bool</span> QAbstractEventDispatcher::<span class="name">processEvents</span>(<span class="type"><a href="qeventloop.html#ProcessEventsFlag-enum">QEventLoop::ProcessEventsFlags</a></span> <i>flags</i>)
</h3> <p>Processes pending events that match <i>flags</i> until there are no more events to process. Returns <code>true</code> if an event was processed; otherwise returns <code>false</code>.</p> <p>This function is especially useful if you have a long running operation, and want to show its progress without allowing user input by using the <a href="qeventloop.html#ProcessEventsFlag-enum">QEventLoop::ExcludeUserInputEvents</a> flag.</p> <p>If the <a href="qeventloop.html#ProcessEventsFlag-enum">QEventLoop::WaitForMoreEvents</a> flag is set in <i>flags</i>, the behavior of this function is as follows:</p> <ul> <li>If events are available, this function returns after processing them.</li> <li>If no events are available, this function will wait until more are available and return after processing newly available events.</li> </ul> <p>If the <a href="qeventloop.html#ProcessEventsFlag-enum">QEventLoop::WaitForMoreEvents</a> flag is not set in <i>flags</i>, and no events are available, this function will return immediately.</p> <p><b>Note:</b> This function does not process events continuously; it returns after all available events are processed.</p>   <h3 class="fn" id="registerSocketNotifier">
<code>[pure virtual] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">registerSocketNotifier</span>(<span class="type"><a href="qsocketnotifier.html">QSocketNotifier</a></span> *<i>notifier</i>)
</h3> <p>Registers <i>notifier</i> with the event loop. Subclasses must implement this method to tie a socket notifier into another event loop.</p>   <h3 class="fn" id="registerTimer">
<span class="type">int</span> QAbstractEventDispatcher::<span class="name">registerTimer</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>interval</i>, <span class="type"><a href="qt.html#TimerType-enum">Qt::TimerType</a></span> <i>timerType</i>, <span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>object</i>)
</h3> <p>Registers a timer with the specified <i>interval</i> and <i>timerType</i> for the given <i>object</i> and returns the timer id.</p>   <h3 class="fn" id="registerTimer-1">
<code>[pure virtual] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">registerTimer</span>(<span class="type">int</span> <i>timerId</i>, <span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>interval</i>, <span class="type"><a href="qt.html#TimerType-enum">Qt::TimerType</a></span> <i>timerType</i>, <span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>object</i>)
</h3> <p>Register a timer with the specified <i>timerId</i>, <i>interval</i>, and <i>timerType</i> for the given <i>object</i>.</p>   <h3 class="fn" id="registeredTimers">
<code>[pure virtual] </code><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qabstracteventdispatcher-timerinfo.html">QAbstractEventDispatcher::TimerInfo</a></span>&gt; QAbstractEventDispatcher::<span class="name">registeredTimers</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>object</i>) const
</h3> <p>Returns a list of registered timers for <i>object</i>. The <a href="qabstracteventdispatcher-timerinfo.html">TimerInfo</a> struct has <code>timerId</code>, <code>interval</code>, and <code>timerType</code> members.</p> <p><b>See also </b><a href="qt.html#TimerType-enum">Qt::TimerType</a>.</p>   <h3 class="fn" id="remainingTime">
<code>[pure virtual] </code><span class="type">int</span> QAbstractEventDispatcher::<span class="name">remainingTime</span>(<span class="type">int</span> <i>timerId</i>)
</h3> <p>Returns the remaining time in milliseconds with the given <i>timerId</i>. If the timer is inactive, the returned value will be -1. If the timer is overdue, the returned value will be 0.</p> <p><b>See also </b><a href="qt.html#TimerType-enum">Qt::TimerType</a>.</p>   <h3 class="fn" id="removeNativeEventFilter">
<code>[since 5.0] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">removeNativeEventFilter</span>(<span class="type"><a href="qabstractnativeeventfilter.html">QAbstractNativeEventFilter</a></span> *<i>filter</i>)
</h3> <p>Removes the event filter <i>filter</i> from this object. The request is ignored if such an event filter has not been installed.</p> <p>All event filters for this object are automatically removed when this object is destroyed.</p> <p>It is always safe to remove an event filter, even during event filter filter activation (that is, even from within the <a href="qabstractnativeeventfilter.html#nativeEventFilter">nativeEventFilter</a>() function).</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qabstracteventdispatcher.html#installNativeEventFilter">installNativeEventFilter</a>() and <a href="qabstractnativeeventfilter.html">QAbstractNativeEventFilter</a>.</p>   <h3 class="fn" id="unregisterSocketNotifier">
<code>[pure virtual] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">unregisterSocketNotifier</span>(<span class="type"><a href="qsocketnotifier.html">QSocketNotifier</a></span> *<i>notifier</i>)
</h3> <p>Unregisters <i>notifier</i> from the event dispatcher. Subclasses must reimplement this method to tie a socket notifier into another event loop. Reimplementations must call the base implementation.</p>   <h3 class="fn" id="unregisterTimer">
<code>[pure virtual] </code><span class="type">bool</span> QAbstractEventDispatcher::<span class="name">unregisterTimer</span>(<span class="type">int</span> <i>timerId</i>)
</h3> <p>Unregisters the timer with the given <i>timerId</i>. Returns <code>true</code> if successful; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qabstracteventdispatcher.html#registerTimer">registerTimer</a>() and <a href="qabstracteventdispatcher.html#unregisterTimers">unregisterTimers</a>().</p>   <h3 class="fn" id="unregisterTimers">
<code>[pure virtual] </code><span class="type">bool</span> QAbstractEventDispatcher::<span class="name">unregisterTimers</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>object</i>)
</h3> <p>Unregisters all the timers associated with the given <i>object</i>. Returns <code>true</code> if all timers were successful removed; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qabstracteventdispatcher.html#unregisterTimer">unregisterTimer</a>() and <a href="qabstracteventdispatcher.html#registeredTimers">registeredTimers</a>().</p>   <h3 class="fn" id="wakeUp">
<code>[pure virtual] </code><span class="type">void</span> QAbstractEventDispatcher::<span class="name">wakeUp</span>()
</h3> <p>Wakes up the event loop.</p> <p><b>Note:</b> This function is <a href="threads-reentrancy.html">thread-safe</a>.</p> <p><b>See also </b><a href="qabstracteventdispatcher.html#awake">awake</a>().</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qabstracteventdispatcher.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qabstracteventdispatcher.html</a>
  </p>
</div>
