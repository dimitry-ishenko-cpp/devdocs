<h1 class="title">QStringTokenizer Class</h1> <span class="small-subtitle">template &lt;typename Haystack, typename Needle&gt; class QStringTokenizer</span>  <p>The QStringTokenizer class splits strings into tokens along given separators. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QStringTokenizer&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 6.0</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> QtPrivate::Tok::HaystackPinning (private), QtPrivate::Tok::NeedlePinning (private), and </td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qstringtokenizer-members.html">List of all members, including inherited members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="17-qdoc-commands-thread.html#reentrant">reentrant</a>.</p> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#const_iterator-typedef">const_iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#const_pointer-typedef">const_pointer</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#const_reference-typedef">const_reference</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#difference_type-typedef">difference_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#iterator-typedef">iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#pointer-typedef">pointer</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#reference-typedef">reference</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#sentinel-typedef">sentinel</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#size_type-typedef">size_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#value_type-typedef">value_type</a></b></td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qstringtokenizer.html#QStringTokenizer-1">QStringTokenizer</a></b>(Haystack <i>haystack</i>, Needle <i>needle</i>, Qt::SplitBehavior <i>sb</i> = Qt::KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></b>(Haystack <i>haystack</i>, Needle <i>needle</i>, Qt::CaseSensitivity <i>cs</i>, Qt::SplitBehavior <i>sb</i> = Qt::KeepEmptyParts)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QStringTokenizer::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qstringtokenizer.html#begin">begin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QStringTokenizer::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qstringtokenizer.html#cbegin">cbegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QStringTokenizer::sentinel </td>
<td class="memItemRight bottomAlign">
<b><a href="qstringtokenizer.html#cend">cend</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QStringTokenizer::sentinel </td>
<td class="memItemRight bottomAlign">
<b><a href="qstringtokenizer.html#end">end</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> LContainer </td>
<td class="memItemRight bottomAlign">
<b><a href="qstringtokenizer.html#toContainer">toContainer</a></b>(LContainer &amp;&amp;<i>c</i> = {}) const &amp;</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> RContainer </td>
<td class="memItemRight bottomAlign">
<b><a href="qstringtokenizer.html#toContainer-1">toContainer</a></b>(RContainer &amp;&amp;<i>c</i> = {}) const &amp;&amp;</td>
</tr> </table> <h2 id="related-non-members">Related Non-Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> decltype(QtPrivate::Tok::TokenizerResult&lt;Haystack, Needle&gt;({std::forward&lt;Haystack&gt;(h), std::forward&lt;Needle&gt;(n), flags...})) </td>
<td class="memItemRight bottomAlign">
<b><a href="qstringtokenizer.html#qTokenize">qTokenize</a></b>(Haystack &amp;&amp;<i>haystack</i>, Needle &amp;&amp;<i>needle</i>, Flags... <i>flags</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>Splits a string into substrings wherever a given separator occurs, returning a (lazily constructed) list of those strings. If the separator does not match anywhere in the string, produces a single-element list containing this string. If the separator is empty, QStringTokenizer produces an empty string, followed by each of the string's characters, followed by another empty string. The two enumerations <a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a> and <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> further control the output.</p> <p>QStringTokenizer drives <a href="qstringview.html#tokenize">QStringView::tokenize</a>(), but, at least with a recent compiler, you can use it directly, too:</p> <pre data-language="cpp">for (auto it : QStringTokenizer{string, separator})
    use(*it);</pre> <div class="admonition note"> <p><b>Note: </b>You should never, ever, name the template arguments of a QStringTokenizer explicitly. If you can use C++17 Class Template Argument Deduction (CTAD), you may write <code>QStringTokenizer{string, separator}</code> (without template arguments). If you can't use C++17 CTAD, you must use the <a href="qstringview.html#split">QStringView::split</a>() or QLatin1String::split() member functions and store the return value only in <code>auto</code> variables:</p> </div> <pre data-language="cpp">auto result = string.split(sep);</pre> <p>This is because the template arguments of QStringTokenizer have a very subtle dependency on the specific string and separator types from with which they are constructed, and they don't usually correspond to the actual types passed.</p> <h3 id="lazy-sequences">Lazy Sequences
</h3> <p>QStringTokenizer acts as a so-called lazy sequence, that is, each next element is only computed once you ask for it. Lazy sequences have the advantage that they only require O(1) memory. They have the disadvantage that, at least for QStringTokenizer, they only allow forward, not random-access, iteration.</p> <p>The intended use-case is that you just plug it into a ranged for loop:</p> <pre data-language="cpp">for (auto it : QStringTokenizer{string, separator})
    use(*it);</pre> <p>or a C++20 ranged algorithm:</p> <pre data-language="cpp">std::ranges::for_each(QStringTokenizer{string, separator},
                      [] (auto token) { use(token); });</pre> <h3 id="end-sentinel">End Sentinel
</h3> <p>The QStringTokenizer iterators cannot be used with classical STL algorithms, because those require iterator/iterator pairs, while QStringTokenizer uses sentinels. That is, it uses a different type, QStringTokenizer::sentinel, to mark the end of the range. This improves performance, because the sentinel is an empty type. Sentinels are supported from C++17 (for ranged for) and C++20 (for algorithms using the new ranges library).</p> <h3 id="temporaries">Temporaries
</h3> <p>QStringTokenizer is very carefully designed to avoid dangling references. If you construct a tokenizer from a temporary string (an rvalue), that argument is stored internally, so the referenced data isn't deleted before it is tokenized:</p> <pre data-language="cpp">auto tok = QStringTokenizer{widget.text(), u','};
// return value of `widget.text()` is destroyed, but content was moved into `tok`
for (auto e : tok)
   use(e);</pre> <p>If you pass named objects (lvalues), then QStringTokenizer does not store a copy. You are responsible to keep the named object's data around for longer than the tokenizer operates on it:</p> <pre data-language="cpp">auto text = widget.text();
auto tok = QStringTokenizer{text, u','};
text.clear();      // destroy content of `text`
for (auto e : tok) // ERROR: `tok` references deleted data!
    use(e);</pre>  <p><b>See also </b><a href="qstringview.html#split">QStringView::split</a>(), <a href="qstring.html#split">QString::split</a>(), and <a href="qregularexpression.html">QRegularExpression</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="const_iterator-typedef">
<code>[alias] </code>QStringTokenizer::<span class="name">const_iterator</span>
</h3> <p>This typedef provides an STL-style const iterator for <a href="qstringtokenizer.html">QStringTokenizer</a>.</p> <p><b>See also </b><a href="qstringtokenizer.html#iterator-typedef">iterator</a>.</p>   <h3 class="fn" id="const_pointer-typedef">
<code>[alias] </code>QStringTokenizer::<span class="name">const_pointer</span>
</h3> <p>Alias for <code>value_type *</code>.</p>   <h3 class="fn" id="const_reference-typedef">
<code>[alias] </code>QStringTokenizer::<span class="name">const_reference</span>
</h3> <p>Alias for <code>value_type &amp;</code>.</p>   <h3 class="fn" id="difference_type-typedef">
<code>[alias] </code>QStringTokenizer::<span class="name">difference_type</span>
</h3> <p>Alias for qsizetype.</p>   <h3 class="fn" id="iterator-typedef">
<code>[alias] </code>QStringTokenizer::<span class="name">iterator</span>
</h3> <p>This typedef provides an STL-style const iterator for <a href="qstringtokenizer.html">QStringTokenizer</a>.</p> <p><a href="qstringtokenizer.html">QStringTokenizer</a> does not support mutable iterators, so this is the same as const_iterator.</p> <p><b>See also </b><a href="qstringtokenizer.html#const_iterator-typedef">const_iterator</a>.</p>   <h3 class="fn" id="pointer-typedef">
<code>[alias] </code>QStringTokenizer::<span class="name">pointer</span>
</h3> <p>Alias for <code>value_type *</code>.</p> <p><a href="qstringtokenizer.html">QStringTokenizer</a> does not support mutable iterators, so this is the same as const_pointer.</p>   <h3 class="fn" id="reference-typedef">
<code>[alias] </code>QStringTokenizer::<span class="name">reference</span>
</h3> <p>Alias for <code>value_type &amp;</code>.</p> <p><a href="qstringtokenizer.html">QStringTokenizer</a> does not support mutable references, so this is the same as const_reference.</p>   <h3 class="fn" id="sentinel-typedef">
<code>[alias] </code>QStringTokenizer::<span class="name">sentinel</span>
</h3> <p>This typedef provides an STL-style sentinel for QStringTokenizer::iterator and QStringTokenizer::const_iterator.</p> <p><b>See also </b><a href="qstringtokenizer.html#const_iterator-typedef">const_iterator</a>.</p>   <h3 class="fn" id="size_type-typedef">
<code>[alias] </code>QStringTokenizer::<span class="name">size_type</span>
</h3> <p>Alias for qsizetype.</p>   <h3 class="fn" id="value_type-typedef">
<code>[alias] </code>QStringTokenizer::<span class="name">value_type</span>
</h3> <p>Alias for <code>const QStringView</code> or <code>const QLatin1String</code>, depending on the tokenizer's <code>Haystack</code> template argument.</p>    <h2>Member Function Documentation</h2>  <div class="fngroup"> <h3 class="fn fngroupitem" id="begin">
<span class="type">QStringTokenizer::iterator</span> QStringTokenizer::<span class="name">begin</span>() const
</h3>
<h3 class="fn fngroupitem" id="cbegin">
<span class="type">QStringTokenizer::iterator</span> QStringTokenizer::<span class="name">cbegin</span>() const
</h3>
</div> <p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first token in the list.</p> <p><b>See also </b><a href="qstringtokenizer.html#end">end</a>() and <a href="qstringtokenizer.html#cend">cend</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="QStringTokenizer">QStringTokenizer::<span class="name">QStringTokenizer</span>(<span class="type">Haystack</span> <i>haystack</i>, <span class="type">Needle</span> <i>needle</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a></span> <i>cs</i>, <span class="type"><a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a></span> <i>sb</i> = Qt::KeepEmptyParts)
</h3>
<h3 class="fn fngroupitem" id="QStringTokenizer-1">QStringTokenizer::<span class="name">QStringTokenizer</span>(<span class="type">Haystack</span> <i>haystack</i>, <span class="type">Needle</span> <i>needle</i>, <span class="type"><a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a></span> <i>sb</i> = Qt::KeepEmptyParts, <span class="type"><a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)
</h3>
</div> <p>Constructs a string tokenizer that splits the string <i>haystack</i> into substrings wherever <i>needle</i> occurs, and allows iteration over those strings as they are found. If <i>needle</i> does not match anywhere in <i>haystack</i>, a single element containing <i>haystack</i> is produced.</p> <p><i>cs</i> specifies whether <i>needle</i> should be matched case sensitively or case insensitively.</p> <p>If <i>sb</i> is <a href="qt.html#SplitBehaviorFlags-enum">Qt::SkipEmptyParts</a>, empty entries don't appear in the result. By default, empty entries are included.</p> <p><b>See also </b><a href="qstringview.html#split">QStringView::split</a>(), <a href="qstring.html#split">QString::split</a>(), <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a>, and <a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a>.</p>   <h3 class="fn" id="cend">
<span class="type">QStringTokenizer::sentinel</span> QStringTokenizer::<span class="name">cend</span>() const
</h3> <p>Same as <a href="qstringtokenizer.html#end">end</a>().</p> <p><b>See also </b><a href="qstringtokenizer.html#cbegin">cbegin</a>() and <a href="qstringtokenizer.html#end">end</a>().</p>   <h3 class="fn" id="end">
<span class="type">QStringTokenizer::sentinel</span> QStringTokenizer::<span class="name">end</span>() const
</h3> <p>Returns a const <a href="containers.html#stl-style-iterators">STL-style sentinel</a> pointing to the imaginary token after the last token in the list.</p> <p><b>See also </b><a href="qstringtokenizer.html#begin">begin</a>() and <a href="qstringtokenizer.html#cend">cend</a>().</p>   <h3 class="fn" id="toContainer">template &lt;typename LContainer&gt; <span class="type">LContainer</span> QStringTokenizer::<span class="name">toContainer</span>(<span class="type">LContainer</span> &amp;&amp;<i>c</i> = {}) const &amp;
</h3> <p>Converts the lazy sequence into a (typically) random-access container of type <code>LContainer</code>.</p> <p>This function is only available if <code>Container</code> has a <code>value_type</code> matching this tokenizer's value_type.</p> <p>If you pass in a named container (an lvalue) for <i>c</i>, then that container is filled, and a reference to it is returned. If you pass in a temporary container (an rvalue, incl. the default argument), then that container is filled, and returned by value.</p> <pre data-language="cpp">// assuming tok's value_type is QStringView, then...
auto tok = QStringTokenizer{~~~};
// ... rac1 is a QList:
auto rac1 = tok.toContainer();
// ... rac2 is std::pmr::vector&lt;QStringView&gt;:
auto rac2 = tok.toContainer&lt;std::pmr::vector&lt;QStringView&gt;&gt;();
auto rac3 = QVarLengthArray&lt;QStringView, 12&gt;{};
// appends the token sequence produced by tok to rac3
//  and returns a reference to rac3 (which we ignore here):
tok.toContainer(rac3);</pre> <p>This gives you maximum flexibility in how you want the sequence to be stored.</p>   <h3 class="fn" id="toContainer-1">template &lt;typename RContainer&gt; <span class="type">RContainer</span> QStringTokenizer::<span class="name">toContainer</span>(<span class="type">RContainer</span> &amp;&amp;<i>c</i> = {}) const &amp;&amp;
</h3> <p>This is an overloaded function.</p> <p>Converts the lazy sequence into a (typically) random-access container of type <code>RContainer</code>.</p> <p>In addition to the constraints on the lvalue-this overload, this rvalue-this overload is only available when this <a href="qstringtokenizer.html">QStringTokenizer</a> does not store the haystack internally, as this could create a container full of dangling references:</p> <pre data-language="cpp">auto tokens = QStringTokenizer{widget.text(), u','}.toContainer();
// ERROR: cannot call toContainer() on rvalue
// 'tokens' references the data of the copy of widget.text()
// stored inside the QStringTokenizer, which has since been deleted</pre> <p>To fix, store the <a href="qstringtokenizer.html">QStringTokenizer</a> in a temporary:</p> <pre data-language="cpp">auto tokenizer = QStringTokenizer{widget.text90, u','};
auto tokens = tokenizer.toContainer();
// OK: the copy of widget.text() stored in 'tokenizer' keeps the data
// referenced by 'tokens' alive.</pre> <p>You can force this function into existence by passing a view instead:</p> <pre data-language="cpp">func(QStringTokenizer{QStringView{widget.text()}, u','}.toContainer());
// OK: compiler keeps widget.text() around until after func() has executed</pre> <p>If you pass in a named container (an lvalue)for <i>c</i>, then that container is filled, and a reference to it is returned. If you pass in a temporary container (an rvalue, incl. the default argument), then that container is filled, and returned by value.</p>   <div class="relnonmem"> <h2>Related Non-Members</h2>  <h3 class="fn" id="qTokenize">
<code>[since 6.0] </code>template &lt;typename Haystack, typename Needle, typename Flags&gt; <span class="type">decltype</span>(<span class="type">QtPrivate::Tok::TokenizerResult</span>&lt;<span class="type">Haystack</span>, <span class="type">Needle</span>&gt;({<span class="type">std::forward</span>&lt;<span class="type">Haystack</span>&gt;(<span class="type">h</span>), <span class="type">std::forward</span>&lt;<span class="type">Needle</span>&gt;(<span class="type">n</span>), <span class="type">flags</span>...})) <span class="name">qTokenize</span>(<span class="type">Haystack</span> &amp;&amp;<i>haystack</i>, <span class="type">Needle</span> &amp;&amp;<i>needle</i>, <span class="type">Flags</span>... <i>flags</i>)
</h3> <p>Factory function for a <a href="qstringtokenizer.html">QStringTokenizer</a> that splits the string <i>haystack</i> into substrings wherever <i>needle</i> occurs, and allows iteration over those strings as they are found. If <i>needle</i> does not match anywhere in <i>haystack</i>, a single element containing <i>haystack</i> is produced.</p> <p>Pass values from <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> and <a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a> enumerators as <i>flags</i> to modify the behavior of the tokenizer.</p> <p>You can use this function if your compiler doesn't, yet, support C++17 Class Template Argument Deduction (CTAD). We recommend direct use of <a href="qstringtokenizer.html">QStringTokenizer</a> with CTAD instead.</p> <p>This function was introduced in Qt 6.0.</p>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qstringtokenizer.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qstringtokenizer.html</a>
  </p>
</div>
