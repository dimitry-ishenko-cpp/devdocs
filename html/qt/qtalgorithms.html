<h1 class="title">&lt;QtAlgorithms&gt; - Generic Algorithms</h1>  <p>The &lt;QtAlgorithms&gt; header includes the generic, template-based algorithms. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QtAlgorithms&gt;</span> </td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qtalgorithms-obsolete.html">Deprecated members</a></li> </ul> <h2 id="functions">Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qCountLeadingZeroBits">qCountLeadingZeroBits</a></b>(quint8 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qCountLeadingZeroBits-1">qCountLeadingZeroBits</a></b>(quint16 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qCountLeadingZeroBits-2">qCountLeadingZeroBits</a></b>(quint32 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qCountLeadingZeroBits-3">qCountLeadingZeroBits</a></b>(quint64 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qCountTrailingZeroBits">qCountTrailingZeroBits</a></b>(quint8 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qCountTrailingZeroBits-1">qCountTrailingZeroBits</a></b>(quint16 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qCountTrailingZeroBits-2">qCountTrailingZeroBits</a></b>(quint32 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qCountTrailingZeroBits-3">qCountTrailingZeroBits</a></b>(quint64 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qDeleteAll">qDeleteAll</a></b>(ForwardIterator <i>begin</i>, ForwardIterator <i>end</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qDeleteAll-1">qDeleteAll</a></b>(const Container &amp;<i>c</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qPopulationCount">qPopulationCount</a></b>(quint8 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qPopulationCount-1">qPopulationCount</a></b>(quint16 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qPopulationCount-2">qPopulationCount</a></b>(quint32 <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uint </td>
<td class="memItemRight bottomAlign">
<b><a href="qtalgorithms.html#qPopulationCount-3">qPopulationCount</a></b>(quint64 <i>v</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>Qt provides a number of global template functions in <code>&lt;QtAlgorithms&gt;</code> that work on containers and perform small tasks to make life easier, such as <a href="qtalgorithms.html#qDeleteAll">qDeleteAll</a>(), which invokes <code>operator delete</code> on all items in a given container or in a given range. You can use these algorithms with any <a href="containers.html">container class</a> that provides STL-style iterators, including Qt's <a href="qlist.html">QList</a>, <a href="qmap.html">QMap</a>, and <a href="qhash.html#qhash">QHash</a> classes.</p> <p>Most algorithms take <a href="containers.html#stl-style-iterators">STL-style iterators</a> as parameters. The algorithms are generic in the sense that they aren't bound to a specific iterator class; you can use them with any iterators that meet a certain set of requirements.</p> <p>Different algorithms can have different requirements for the iterators they accept. The iterator types required are specified for each algorithm. If an iterator of the wrong type is passed (for example, if QList::ConstIterator is passed as an <a href="qtalgorithms.html#output-iterators">output iterator</a>), you will always get a compiler error, although not necessarily a very informative one.</p> <p>Some algorithms have special requirements on the value type stored in the containers. For example, <a href="qtalgorithms.html#qDeleteAll">qDeleteAll</a>() requires that the value type is a non-const pointer type (for example, <a href="qwidget.html">QWidget</a> *). The value type requirements are specified for each algorithm, and the compiler will produce an error if a requirement isn't met.</p> <p>The generic algorithms can be used on other container classes than those provided by Qt and STL. The syntax of STL-style iterators is modeled after C++ pointers, so it's possible to use plain arrays as containers and plain pointers as iterators.</p> <h4 id="types-of-iterators">Types of Iterators
</h4> <p>The algorithms have certain requirements on the iterator types they accept, and these are specified individually for each function. The compiler will produce an error if a requirement isn't met.</p> <h5 id="input-iterators">Input Iterators
</h5> <p>An <i>input iterator</i> is an iterator that can be used for reading data sequentially from a container. It must provide the following operators: <code>==</code> and <code>!=</code> for comparing two iterators, unary <code>*</code> for retrieving the value stored in the item, and prefix <code>++</code> for advancing to the next item.</p> <p>The Qt containers' iterator types (const and non-const) are all input iterators.</p> <h5 id="output-iterators">Output Iterators
</h5> <p>An output iterator is an iterator that can be used for writing data sequentially to a container or to some output stream. It must provide the following operators: unary <code>*</code> for writing a value (i.e., <code>*it = val</code>) and prefix <code>++</code> for advancing to the next item.</p> <p>The Qt containers' non-const iterator types are all output iterators.</p> <h5 id="forward-iterators">Forward Iterators
</h5> <p>A <i>forward iterator</i> is an iterator that meets the requirements of both input iterators and output iterators.</p> <p>The Qt containers' non-const iterator types are all forward iterators.</p> <h5 id="bidirectional-iterators">Bidirectional Iterators
</h5> <p>A <i>bidirectional iterator</i> is an iterator that meets the requirements of forward iterators but that in addition supports prefix <code>--</code> for iterating backward.</p> <p>The Qt containers' non-const iterator types are all bidirectional iterators.</p> <h5 id="random-access-iterators">Random Access Iterators
</h5> <p>The last category, <i>random access iterators</i>, is the most powerful type of iterator. It supports all the requirements of a bidirectional iterator, and supports the following operations:</p> <table class="generic"> <tr class="odd" valign="top">
<td><code>i += n</code></td>
<td>advances iterator <code>i</code> by <code>n</code> positions</td>
</tr> <tr class="even" valign="top">
<td><code>i -= n</code></td>
<td>moves iterator <code>i</code> back by <code>n</code> positions</td>
</tr> <tr class="odd" valign="top">
<td>
<code>i + n</code> or <code>n + i</code>
</td>
<td>returns the iterator for the item <code>n</code> positions ahead of iterator <code>i</code>
</td>
</tr> <tr class="even" valign="top">
<td><code>i - n</code></td>
<td>returns the iterator for the item <code>n</code> positions behind of iterator <code>i</code>
</td>
</tr> <tr class="odd" valign="top">
<td><code>i - j</code></td>
<td>returns the number of items between iterators <code>i</code> and <code>j</code>
</td>
</tr> <tr class="even" valign="top">
<td><code>i[n]</code></td>
<td>same as <code>*(i + n)</code>
</td>
</tr> <tr class="odd" valign="top">
<td><code>i &lt; j</code></td>
<td>returns <code>true</code> if iterator <code>j</code> comes after iterator <code>i</code>
</td>
</tr> </table> <p><a href="qlist.html">QList</a>'s non-const iterator type is random access iterator.</p>  <p><b>See also </b><a href="containers.html">container classes</a> and <a href="qtglobal.html">&lt;QtGlobal&gt;</a>.</p>   <h2>Function Documentation</h2>  <h3 class="fn" id="qCountLeadingZeroBits">
<code>[since 5.6] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qCountLeadingZeroBits</span>(<span class="type"><a href="qtglobal.html#quint8-typedef">quint8</a></span> <i>v</i>)
</h3> <p>Returns the number of consecutive zero bits in <i>v</i>, when searching from the MSB. For example, qCountLeadingZeroBits(quint8(1)) returns 7 and qCountLeadingZeroBits(quint8(8)) returns 4.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="qCountLeadingZeroBits-1">
<code>[since 5.6] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qCountLeadingZeroBits</span>(<span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <i>v</i>)
</h3> <p>Returns the number of consecutive zero bits in <i>v</i>, when searching from the MSB. For example, qCountLeadingZeroBits(quint16(1)) returns 15 and qCountLeadingZeroBits(quint16(8)) returns 12.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="qCountLeadingZeroBits-2">
<code>[since 5.6] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qCountLeadingZeroBits</span>(<span class="type"><a href="qtglobal.html#quint32-typedef">quint32</a></span> <i>v</i>)
</h3> <p>Returns the number of consecutive zero bits in <i>v</i>, when searching from the MSB. For example, qCountLeadingZeroBits(quint32(1)) returns 31 and qCountLeadingZeroBits(quint32(8)) returns 28.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="qCountLeadingZeroBits-3">
<code>[since 5.6] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qCountLeadingZeroBits</span>(<span class="type"><a href="qtglobal.html#quint64-typedef">quint64</a></span> <i>v</i>)
</h3> <p>Returns the number of consecutive zero bits in <i>v</i>, when searching from the MSB. For example, qCountLeadingZeroBits(quint64(1)) returns 63 and qCountLeadingZeroBits(quint64(8)) returns 60.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="qCountTrailingZeroBits">
<code>[since 5.6] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qCountTrailingZeroBits</span>(<span class="type"><a href="qtglobal.html#quint8-typedef">quint8</a></span> <i>v</i>)
</h3> <p>Returns the number of consecutive zero bits in <i>v</i>, when searching from the LSB. For example, qCountTrailingZeroBits(1) returns 0 and qCountTrailingZeroBits(8) returns 3.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="qCountTrailingZeroBits-1">
<code>[since 5.6] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qCountTrailingZeroBits</span>(<span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <i>v</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="qCountTrailingZeroBits-2">
<code>[since 5.6] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qCountTrailingZeroBits</span>(<span class="type"><a href="qtglobal.html#quint32-typedef">quint32</a></span> <i>v</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="qCountTrailingZeroBits-3">
<code>[since 5.6] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qCountTrailingZeroBits</span>(<span class="type"><a href="qtglobal.html#quint64-typedef">quint64</a></span> <i>v</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="qDeleteAll">template &lt;typename ForwardIterator&gt; <span class="type">void</span> <span class="name">qDeleteAll</span>(<span class="type">ForwardIterator</span> <i>begin</i>, <span class="type">ForwardIterator</span> <i>end</i>)
</h3> <p>Deletes all the items in the range [<i>begin</i>, <i>end</i>) using the C++ <code>delete</code> operator. The item type must be a pointer type (for example, <code>QWidget *</code>).</p> <p>Example:</p> <pre data-language="cpp">QList&lt;Employee *&gt; list;
list.append(new Employee("Blackpool", "Stephen"));
list.append(new Employee("Twist", "Oliver"));

qDeleteAll(list.begin(), list.end());
list.clear();</pre> <p>Notice that qDeleteAll() doesn't remove the items from the container; it merely calls <code>delete</code> on them. In the example above, we call clear() on the container to remove the items.</p> <p>This function can also be used to delete items stored in associative containers, such as <a href="qmap.html">QMap</a> and <a href="qhash.html#qhash">QHash</a>. Only the objects stored in each container will be deleted by this function; objects used as keys will not be deleted.</p> <p><b>See also </b><a href="qtalgorithms.html#forward-iterators">forward iterators</a>.</p>   <h3 class="fn" id="qDeleteAll-1">template &lt;typename Container&gt; <span class="type">void</span> <span class="name">qDeleteAll</span>(const <span class="type">Container</span> &amp;<i>c</i>)
</h3> <p>This is an overloaded function.</p> <p>This is the same as qDeleteAll(<i>c</i>.begin(), <i>c</i>.end()).</p>   <h3 class="fn" id="qPopulationCount">
<code>[since 5.2] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qPopulationCount</span>(<span class="type"><a href="qtglobal.html#quint8-typedef">quint8</a></span> <i>v</i>)
</h3> <p>Returns the number of bits set in <i>v</i>. This number is also called the Hamming Weight of <i>v</i>.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="qPopulationCount-1">
<code>[since 5.2] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qPopulationCount</span>(<span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <i>v</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="qPopulationCount-2">
<code>[since 5.2] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qPopulationCount</span>(<span class="type"><a href="qtglobal.html#quint32-typedef">quint32</a></span> <i>v</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="qPopulationCount-3">
<code>[since 5.2] </code><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <span class="name">qPopulationCount</span>(<span class="type"><a href="qtglobal.html#quint64-typedef">quint64</a></span> <i>v</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.2.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qtalgorithms.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qtalgorithms.html</a>
  </p>
</div>
