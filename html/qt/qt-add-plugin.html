<h1 class="title">qt_add_plugin</h1>   <p>Creates a Qt plugin target.</p> <p>The command is defined in the <code>Core</code> component of the <code>Qt6</code> package. Load the package with:</p> <pre data-language="cpp">find_package(Qt6 COMPONENTS Core REQUIRED)</pre> <h2 id="synopsis">Synopsis
</h2> <pre data-language="cpp">qt_add_plugin(target
              [SHARED | STATIC]
              [CLASS_NAME class_name]
              [OUTPUT_TARGETS variable_name]
)</pre> <p>If <a href="https://doc.qt.io/qt-6.2/cmake-qt5-and-qt6-compatibility.html#versionless-commands">versionless commands</a> are disabled, use <code>qt6_add_plugin()</code> instead. It supports the same set of arguments as this command.</p> <h2 id="description">Description
</h2> <p>Qt plugin targets have additional requirements over and above an ordinary CMake library target. The <code>qt_add_plugin()</code> command adds the necessary handling to ensure these requirements are met. It should be called rather than the built-in CMake <code>add_library()</code> command when defining a Qt plugin target.</p> <p>By default, the plugin will be created as a <code>STATIC</code> library if Qt was built statically, or as a <code>MODULE</code> library otherwise. You can override this default by explicitly providing the <code>STATIC</code> or <code>SHARED</code> option.</p> <div class="admonition note"> <p><b>Note: </b>Non-static plugins are meant to be loaded dynamically at runtime, not linked to at build time. CMake differentiates between these two scenarios by providing the <code>MODULE</code> library type for dynamically loaded libraries, and the <code>SHARED</code> library type for libraries that may be linked to directly. This distinction is important for some toolchains (notably Visual Studio), due to the way symbol exports are handled. It may not be possible to link to <code>MODULE</code> libraries, and generating a <code>SHARED</code> library with no exported symbols can result in build-time errors. If the <code>SHARED</code> option is passed to <code>qt_add_plugin()</code>, it will therefore create a <code>MODULE</code> library rather than a <code>SHARED</code> library.</p> </div> <p>Every Qt plugin has a class name. By default, this will be the same as the <code>target</code>, but it can be overridden with the <code>CLASS_NAME</code> option. The class name corresponds to the name of the C++ class that declares the metadata for the plugin. For static plugins, it is also the name passed to <a href="qtplugin.html#Q_IMPORT_PLUGIN">Q_IMPORT_PLUGIN</a>, which imports the plugin into an application and ensures it is available at run time.</p> <p>If the plugin is built statically, <code>qt_add_plugin()</code> may define additional internal targets. These facilitate automatic importing of the plugin for any executable or shared library that links to the plugin. If the project installs the plugin and intends to make it available for other projects to link to, the project should also install these internal targets. The names of these targets can be obtained by providing the <code>OUTPUT_TARGETS</code> option, followed by the name of a variable in which to return the target list.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qt-add-plugin.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qt-add-plugin.html</a>
  </p>
</div>
