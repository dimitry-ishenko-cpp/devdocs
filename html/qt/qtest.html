<h1 class="title">QTest Namespace</h1>  <p>The QTest namespace contains all the functions and declarations that are related to Qt Test. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QTest&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Test REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Test)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += testlib</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qtest-obsolete.html">Deprecated members</a></li> </ul> <h2 id="classes">Classes
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> class </td>
<td class="memItemRight bottomAlign"><b><a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a></b></td>
</tr> </table> <h2 id="types">Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#KeyAction-enum">KeyAction</a></b> { Press, Release, Click, Shortcut }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#MouseAction-enum">MouseAction</a></b> { MousePress, MouseRelease, MouseClick, MouseDClick, MouseMove }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QBenchmarkMetric-enum">QBenchmarkMetric</a></b> { FramesPerSecond, BitsPerSecond, BytesPerSecond, WalltimeMilliseconds, WalltimeNanoseconds, â€¦, EmulationFaults }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#TestFailMode-enum">TestFailMode</a></b> { Abort, Continue }</td>
</tr> </table> <h2 id="functions">Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#addColumn">addColumn</a></b>(const char *<i>name</i>, T *<i>dummy</i> = 0)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QTestData &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#addRow">addRow</a></b>(const char *<i>format</i>, ...)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#benchmarkMetricName">benchmarkMetricName</a></b>(QTest::QBenchmarkMetric <i>metric</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#benchmarkMetricUnit">benchmarkMetricUnit</a></b>(QTest::QBenchmarkMetric <i>metric</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPointingDevice *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#createTouchDevice">createTouchDevice</a></b>(QInputDevice::DeviceType <i>devType</i> = QInputDevice::DeviceType::TouchScreen, QInputDevice::Capabilities <i>caps</i> = QInputDevice::Capability::Position)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#currentAppName">currentAppName</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#currentDataTag">currentDataTag</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#currentTestFailed">currentTestFailed</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#currentTestFunction">currentTestFunction</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#ignoreMessage">ignoreMessage</a></b>(QtMsgType <i>type</i>, const char *<i>message</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#ignoreMessage-1">ignoreMessage</a></b>(QtMsgType <i>type</i>, const QRegularExpression &amp;<i>messagePattern</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyClick">keyClick</a></b>(QWidget *<i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyClick-1">keyClick</a></b>(QWindow *<i>window</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyClick-2">keyClick</a></b>(QWindow *<i>window</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyClick-3">keyClick</a></b>(QWidget *<i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyClicks">keyClicks</a></b>(QWidget *<i>widget</i>, const QString &amp;<i>sequence</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyEvent">keyEvent</a></b>(QTest::KeyAction <i>action</i>, QWidget *<i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyEvent-1">keyEvent</a></b>(QTest::KeyAction <i>action</i>, QWindow *<i>window</i>, char <i>ascii</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyEvent-2">keyEvent</a></b>(QTest::KeyAction <i>action</i>, QWindow *<i>window</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyEvent-3">keyEvent</a></b>(QTest::KeyAction <i>action</i>, QWidget *<i>widget</i>, char <i>ascii</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyPress">keyPress</a></b>(QWidget *<i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyPress-1">keyPress</a></b>(QWindow *<i>window</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyPress-2">keyPress</a></b>(QWindow *<i>window</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyPress-3">keyPress</a></b>(QWidget *<i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyRelease">keyRelease</a></b>(QWidget *<i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyRelease-1">keyRelease</a></b>(QWindow *<i>window</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyRelease-2">keyRelease</a></b>(QWindow *<i>window</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keyRelease-3">keyRelease</a></b>(QWidget *<i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keySequence">keySequence</a></b>(QWindow *<i>window</i>, const QKeySequence &amp;<i>keySequence</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#keySequence-1">keySequence</a></b>(QWidget *<i>widget</i>, const QKeySequence &amp;<i>keySequence</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#mouseClick">mouseClick</a></b>(QWidget *<i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#mouseClick-1">mouseClick</a></b>(QWindow *<i>window</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>stateKey</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#mouseDClick">mouseDClick</a></b>(QWidget *<i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#mouseDClick-1">mouseDClick</a></b>(QWindow *<i>window</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>stateKey</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#mouseMove">mouseMove</a></b>(QWidget *<i>widget</i>, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#mouseMove-1">mouseMove</a></b>(QWindow *<i>window</i>, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#mousePress">mousePress</a></b>(QWidget *<i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#mousePress-1">mousePress</a></b>(QWindow *<i>window</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>stateKey</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#mouseRelease">mouseRelease</a></b>(QWidget *<i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#mouseRelease-1">mouseRelease</a></b>(QWindow *<i>window</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>stateKey</i> = Qt::KeyboardModifiers(), QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QTestData &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#newRow">newRow</a></b>(const char *<i>dataTag</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#qExec">qExec</a></b>(QObject *<i>testObject</i>, int <i>argc</i> = 0, char **<i>argv</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#qExec-1">qExec</a></b>(QObject *<i>testObject</i>, const QStringList &amp;<i>arguments</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;QTemporaryDir&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#qExtractTestData">qExtractTestData</a></b>(const QString &amp;<i>dirName</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#qSleep">qSleep</a></b>(int <i>ms</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#qWait">qWait</a></b>(int <i>ms</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#qWaitFor">qWaitFor</a></b>(Functor <i>predicate</i>, int <i>timeout</i> = 5000)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#qWaitForWindowActive">qWaitForWindowActive</a></b>(QWindow *<i>window</i>, int <i>timeout</i> = 5000)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#qWaitForWindowActive-1">qWaitForWindowActive</a></b>(QWidget *<i>widget</i>, int <i>timeout</i> = 5000)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#qWaitForWindowExposed">qWaitForWindowExposed</a></b>(QWindow *<i>window</i>, int <i>timeout</i> = 5000)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#qWaitForWindowExposed-1">qWaitForWindowExposed</a></b>(QWidget *<i>widget</i>, int <i>timeout</i> = 5000)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#setBenchmarkResult">setBenchmarkResult</a></b>(qreal <i>result</i>, QTest::QBenchmarkMetric <i>metric</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toHexRepresentation">toHexRepresentation</a></b>(const char *<i>ba</i>, int <i>length</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString">toString</a></b>(const QStringView &amp;<i>string</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString">toString</a></b>(const T &amp;<i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-1">toString</a></b>(const QPair&lt;T1, T2&gt; &amp;<i>pair</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-36">toString</a></b>(const QVector2D &amp;<i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-37">toString</a></b>(const QVector3D &amp;<i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-38">toString</a></b>(const QVector4D &amp;<i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-39">toString</a></b>(QSizePolicy::Policy <i>p</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-40">toString</a></b>(QSizePolicy::ControlTypes <i>cts</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-41">toString</a></b>(QSizePolicy::ControlType <i>ct</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-42">toString</a></b>(QSizePolicy <i>sp</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-2">toString</a></b>(const std::pair&lt;T1, T2&gt; &amp;<i>pair</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-3">toString</a></b>(const std::tuple&lt;Types...&gt; &amp;<i>tuple</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-5">toString</a></b>(const QString &amp;<i>string</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-6">toString</a></b>(const QLatin1String &amp;<i>string</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-7">toString</a></b>(const QByteArray &amp;<i>ba</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-9">toString</a></b>(const QTime &amp;<i>time</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-10">toString</a></b>(const QDate &amp;<i>date</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-11">toString</a></b>(const QDateTime &amp;<i>dateTime</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-12">toString</a></b>(const QCborError &amp;<i>c</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-13">toString</a></b>(const QChar &amp;<i>character</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-15">toString</a></b>(const QPoint &amp;<i>point</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-16">toString</a></b>(const QSize &amp;<i>size</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-17">toString</a></b>(const QRect &amp;<i>rectangle</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-18">toString</a></b>(const QPointF &amp;<i>point</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-19">toString</a></b>(const QSizeF &amp;<i>size</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-20">toString</a></b>(const QRectF &amp;<i>rectangle</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-21">toString</a></b>(const QUrl &amp;<i>url</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-22">toString</a></b>(const QUuid &amp;<i>uuid</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-23">toString</a></b>(const QVariant &amp;<i>variant</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char *</td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#toString-29">toString</a></b>(std::nullptr_t)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QTest::QTouchEventWidgetSequence </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#touchEvent">touchEvent</a></b>(QWidget *<i>widget</i>, QPointingDevice *<i>device</i>, bool <i>autoCommit</i> = true)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QTest::QTouchEventSequence </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#touchEvent-1">touchEvent</a></b>(QWindow *<i>window</i>, QPointingDevice *<i>device</i>, bool <i>autoCommit</i> = true)</td>
</tr> </table> <h2 id="macros">Macros
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qtest.html#QBENCHMARK">QBENCHMARK</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qtest.html#QBENCHMARK_ONCE">QBENCHMARK_ONCE</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QCOMPARE">QCOMPARE</a></b>(<i>actual</i>, <i>expected</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a></b>(<i>dataIndex</i>, <i>comment</i>, <i>mode</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QFAIL">QFAIL</a></b>(<i>message</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QFETCH">QFETCH</a></b>(<i>type</i>, <i>name</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QFETCH_GLOBAL">QFETCH_GLOBAL</a></b>(<i>type</i>, <i>name</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QFINDTESTDATA">QFINDTESTDATA</a></b>(<i>filename</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QSKIP">QSKIP</a></b>(<i>description</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QTEST">QTEST</a></b>(<i>actual</i>, <i>testElement</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QTEST_APPLESS_MAIN">QTEST_APPLESS_MAIN</a></b>(<i>TestClass</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QTEST_GUILESS_MAIN">QTEST_GUILESS_MAIN</a></b>(<i>TestClass</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a></b>(<i>TestClass</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QTRY_COMPARE">QTRY_COMPARE</a></b>(<i>actual</i>, <i>expected</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QTRY_COMPARE_WITH_TIMEOUT">QTRY_COMPARE_WITH_TIMEOUT</a></b>(<i>actual</i>, <i>expected</i>, <i>timeout</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QTRY_VERIFY2">QTRY_VERIFY2</a></b>(<i>condition</i>, <i>message</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QTRY_VERIFY">QTRY_VERIFY</a></b>(<i>condition</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QTRY_VERIFY2_WITH_TIMEOUT">QTRY_VERIFY2_WITH_TIMEOUT</a></b>(<i>condition</i>, <i>message</i>, <i>timeout</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QTRY_VERIFY_WITH_TIMEOUT">QTRY_VERIFY_WITH_TIMEOUT</a></b>(<i>condition</i>, <i>timeout</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QVERIFY2">QVERIFY2</a></b>(<i>condition</i>, <i>message</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QVERIFY">QVERIFY</a></b>(<i>condition</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qtest.html#QVERIFY_EXCEPTION_THROWN">QVERIFY_EXCEPTION_THROWN</a></b>(<i>expression</i>, <i>exceptiontype</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>See the <a href="https://doc.qt.io/qt-6.2/qtest-overview.html">Qt Test Overview</a> for information about how to write unit tests.</p>   <div class="classes"> <h2>Classes</h2> <h3> class <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a>
</h3> <p>The QTouchEventSequence class is used to simulate a sequence of touch events. <a href="qtest-qtoucheventsequence.html#details">More...</a></p>  </div>  <h2>Type Documentation</h2>  <h3 class="fn" id="KeyAction-enum">enum QTest::<span class="name">KeyAction</span>
</h3> <p>This enum describes possible actions for key handling.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QTest::Press</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The key is pressed.</td>
</tr> <tr>
<td class="topAlign"><code>QTest::Release</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The key is released.</td>
</tr> <tr>
<td class="topAlign"><code>QTest::Click</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">The key is clicked (pressed and released).</td>
</tr> <tr>
<td class="topAlign"><code>QTest::Shortcut</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">A shortcut is activated. This value has been added in Qt 5.6.</td>
</tr> </table>   <h3 class="fn" id="MouseAction-enum">enum QTest::<span class="name">MouseAction</span>
</h3> <p>This enum describes possible actions for mouse handling.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QTest::MousePress</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">A mouse button is pressed.</td>
</tr> <tr>
<td class="topAlign"><code>QTest::MouseRelease</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">A mouse button is released.</td>
</tr> <tr>
<td class="topAlign"><code>QTest::MouseClick</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">A mouse button is clicked (pressed and released).</td>
</tr> <tr>
<td class="topAlign"><code>QTest::MouseDClick</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">A mouse button is double clicked (pressed and released twice).</td>
</tr> <tr>
<td class="topAlign"><code>QTest::MouseMove</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">The mouse pointer has moved.</td>
</tr> </table>   <h3 class="fn" id="QBenchmarkMetric-enum">enum QTest::<span class="name">QBenchmarkMetric</span>
</h3> <p>This enum lists all the things that can be benchmarked.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QTest::FramesPerSecond</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">Frames per second</td>
</tr> <tr>
<td class="topAlign"><code>QTest::BitsPerSecond</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">Bits per second</td>
</tr> <tr>
<td class="topAlign"><code>QTest::BytesPerSecond</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">Bytes per second</td>
</tr> <tr>
<td class="topAlign"><code>QTest::WalltimeMilliseconds</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">Clock time in milliseconds</td>
</tr> <tr>
<td class="topAlign"><code>QTest::WalltimeNanoseconds</code></td>
<td class="topAlign tblval"><code>7</code></td>
<td class="topAlign">Clock time in nanoseconds</td>
</tr> <tr>
<td class="topAlign"><code>QTest::BytesAllocated</code></td>
<td class="topAlign tblval"><code>8</code></td>
<td class="topAlign">Memory usage in bytes</td>
</tr> <tr>
<td class="topAlign"><code>QTest::Events</code></td>
<td class="topAlign tblval"><code>6</code></td>
<td class="topAlign">Event count</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CPUTicks</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">CPU time</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CPUMigrations</code></td>
<td class="topAlign tblval"><code>9</code></td>
<td class="topAlign">Process migrations between CPUs</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CPUCycles</code></td>
<td class="topAlign tblval"><code>10</code></td>
<td class="topAlign">CPU cycles</td>
</tr> <tr>
<td class="topAlign"><code>QTest::RefCPUCycles</code></td>
<td class="topAlign tblval"><code>30</code></td>
<td class="topAlign">Reference CPU cycles</td>
</tr> <tr>
<td class="topAlign"><code>QTest::BusCycles</code></td>
<td class="topAlign tblval"><code>11</code></td>
<td class="topAlign">Bus cycles</td>
</tr> <tr>
<td class="topAlign"><code>QTest::StalledCycles</code></td>
<td class="topAlign tblval"><code>12</code></td>
<td class="topAlign">Cycles stalled</td>
</tr> <tr>
<td class="topAlign"><code>QTest::InstructionReads</code></td>
<td class="topAlign tblval"><code>5</code></td>
<td class="topAlign">Instruction reads</td>
</tr> <tr>
<td class="topAlign"><code>QTest::Instructions</code></td>
<td class="topAlign tblval"><code>13</code></td>
<td class="topAlign">Instructions executed</td>
</tr> <tr>
<td class="topAlign"><code>QTest::BranchInstructions</code></td>
<td class="topAlign tblval"><code>14</code></td>
<td class="topAlign">Branch-type instructions</td>
</tr> <tr>
<td class="topAlign"><code>QTest::BranchMisses</code></td>
<td class="topAlign tblval"><code>15</code></td>
<td class="topAlign">Branch instructions that were mispredicted</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CacheReferences</code></td>
<td class="topAlign tblval"><code>16</code></td>
<td class="topAlign">Cache accesses of any type</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CacheMisses</code></td>
<td class="topAlign tblval"><code>20</code></td>
<td class="topAlign">Cache misses of any type</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CacheReads</code></td>
<td class="topAlign tblval"><code>17</code></td>
<td class="topAlign">Cache reads / loads</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CacheReadMisses</code></td>
<td class="topAlign tblval"><code>21</code></td>
<td class="topAlign">Cache read / load misses</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CacheWrites</code></td>
<td class="topAlign tblval"><code>18</code></td>
<td class="topAlign">Cache writes / stores</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CacheWriteMisses</code></td>
<td class="topAlign tblval"><code>22</code></td>
<td class="topAlign">Cache write / store misses</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CachePrefetches</code></td>
<td class="topAlign tblval"><code>19</code></td>
<td class="topAlign">Cache prefetches</td>
</tr> <tr>
<td class="topAlign"><code>QTest::CachePrefetchMisses</code></td>
<td class="topAlign tblval"><code>23</code></td>
<td class="topAlign">Cache prefetch misses</td>
</tr> <tr>
<td class="topAlign"><code>QTest::ContextSwitches</code></td>
<td class="topAlign tblval"><code>24</code></td>
<td class="topAlign">Context switches</td>
</tr> <tr>
<td class="topAlign"><code>QTest::PageFaults</code></td>
<td class="topAlign tblval"><code>25</code></td>
<td class="topAlign">Page faults of any type</td>
</tr> <tr>
<td class="topAlign"><code>QTest::MinorPageFaults</code></td>
<td class="topAlign tblval"><code>26</code></td>
<td class="topAlign">Minor page faults</td>
</tr> <tr>
<td class="topAlign"><code>QTest::MajorPageFaults</code></td>
<td class="topAlign tblval"><code>27</code></td>
<td class="topAlign">Major page faults</td>
</tr> <tr>
<td class="topAlign"><code>QTest::AlignmentFaults</code></td>
<td class="topAlign tblval"><code>28</code></td>
<td class="topAlign">Faults caused due to misalignment</td>
</tr> <tr>
<td class="topAlign"><code>QTest::EmulationFaults</code></td>
<td class="topAlign tblval"><code>29</code></td>
<td class="topAlign">Faults that needed software emulation</td>
</tr> </table> <p>Note that <code>WalltimeNanoseconds</code> and <code>BytesAllocated</code> are only provided for use via <a href="qtest.html#setBenchmarkResult">setBenchmarkResult</a>(), and results in those metrics are not able to be provided automatically by the <a href="qtest.html">QTest</a> framework.</p> <p><b>See also </b><a href="qtest.html#benchmarkMetricName">QTest::benchmarkMetricName</a>() and <a href="qtest.html#benchmarkMetricUnit">QTest::benchmarkMetricUnit</a>().</p>   <h3 class="fn" id="TestFailMode-enum">enum QTest::<span class="name">TestFailMode</span>
</h3> <p>This enum describes the modes for handling an expected failure of the <a href="qtest.html#QVERIFY">QVERIFY</a>() or <a href="qtest.html#QCOMPARE">QCOMPARE</a>() macros.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QTest::Abort</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">Aborts the execution of the test. Use this mode when it doesn't make sense to execute the test any further after the expected failure.</td>
</tr> <tr>
<td class="topAlign"><code>QTest::Continue</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">Continues execution of the test after the expected failure.</td>
</tr> </table> <p><b>See also </b><a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>    <h2>Function Documentation</h2>  <h3 class="fn" id="addColumn">template &lt;typename T&gt; <span class="type">void</span> QTest::<span class="name">addColumn</span>(const <span class="type">char</span> *<i>name</i>, <span class="type">T</span> *<i>dummy</i> = 0)
</h3> <p>Adds a column with type <code>T</code> to the current test data. <i>name</i> is the name of the column. <i>dummy</i> is a workaround for buggy compilers and can be ignored.</p> <p>To populate the column with values, <a href="qtest.html#newRow">newRow</a>() can be used. Use <a href="qtest.html#QFETCH">QFETCH</a>() to fetch the data in the actual test.</p> <p>Example:</p> <pre data-language="cpp">    QTest::addColumn&lt;int&gt;("intval");
    QTest::addColumn&lt;QString&gt;("str");
    QTest::addColumn&lt;double&gt;("dbl");
    QTest::newRow("row1") &lt;&lt; 1 &lt;&lt; "hello" &lt;&lt; 1.5;</pre> <p>To add custom types to the testdata, the type must be registered with <a href="qmetatype.html">QMetaType</a> via <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>().</p> <p><b>Note:</b> This macro can only be used in a test's data function that is invoked by the test framework.</p> <p>See <a href="https://doc.qt.io/qt-6.2/qttestlib-tutorial2-example.html">Data Driven Testing</a> for a more extensive example.</p> <p><b>See also </b><a href="qtest.html#newRow">QTest::newRow</a>(), <a href="qtest.html#QFETCH">QFETCH</a>(), and <a href="qmetatype.html">QMetaType</a>.</p>   <h3 class="fn" id="addRow">
<code>[since 5.9] </code><span class="type">QTestData</span> &amp;QTest::<span class="name">addRow</span>(const <span class="type">char</span> *<i>format</i>, ...)
</h3> <p>Appends a new row to the current test data. The function's arguments are passed to <a href="qbytearray.html#qsnprintf">qsnprintf</a>() for formatting according to <i>format</i>. See the <a href="qbytearray.html#qvsnprintf">qvsnprintf</a>() documentation for caveats and limitations.</p> <p>The formatted string will appear as the name of this test data in the test output.</p> <p>Returns a QTestData reference that can be used to stream in data.</p> <p>Example:</p> <pre data-language="cpp">    QTest::addColumn&lt;int&gt;("input");
    QTest::addColumn&lt;QString&gt;("output");
    QTest::addRow("%d", 0) &lt;&lt; 0 &lt;&lt; QString("0");
    QTest::addRow("%d", 1) &lt;&lt; 1 &lt;&lt; QString("1");</pre> <p><b>Note:</b> This function can only be used in a test's data function that is invoked by the test framework.</p> <p>See <a href="https://doc.qt.io/qt-6.2/qttestlib-tutorial2-example.html">Data Driven Testing</a> for a more extensive example.</p> <p>This function was introduced in Qt 5.9.</p> <p><b>See also </b><a href="qtest.html#addColumn">addColumn</a>() and <a href="qtest.html#QFETCH">QFETCH</a>().</p>   <h3 class="fn" id="benchmarkMetricName">const <span class="type">char</span> *QTest::<span class="name">benchmarkMetricName</span>(<span class="type"><a href="qtest.html#QBenchmarkMetric-enum">QTest::QBenchmarkMetric</a></span> <i>metric</i>)
</h3> <p>Returns the enum value <i>metric</i> as a character string.</p>   <h3 class="fn" id="benchmarkMetricUnit">const <span class="type">char</span> *QTest::<span class="name">benchmarkMetricUnit</span>(<span class="type"><a href="qtest.html#QBenchmarkMetric-enum">QTest::QBenchmarkMetric</a></span> <i>metric</i>)
</h3> <p>Retuns the units of measure for the specified <i>metric</i>.</p>   <h3 class="fn" id="createTouchDevice">
<code>[since 5.8] </code><span class="type"><a href="qpointingdevice.html">QPointingDevice</a></span> *QTest::<span class="name">createTouchDevice</span>(<span class="type"><a href="qinputdevice.html#DeviceType-enum">QInputDevice::DeviceType</a></span> <i>devType</i> = QInputDevice::DeviceType::TouchScreen, <span class="type"><a href="qinputdevice.html#Capability-enum">QInputDevice::Capabilities</a></span> <i>caps</i> = QInputDevice::Capability::Position)
</h3> <p>Creates a dummy touch device of type <i>devType</i> with capabilities <i>caps</i> for simulation of touch events.</p> <p>The touch device will be registered with the QPA window system interface, and deleted automatically when the <a href="qcoreapplication.html">QCoreApplication</a> is deleted. So you should typically use createTouchDevice() to initialize a <a href="qpointingdevice.html">QPointingDevice</a> member variable in your test case class, and use the same instance for all tests.</p> <p>This function was introduced in Qt 5.8.</p> <p><b>See also </b><a href="qtest-qtoucheventsequence.html">QTest::QTouchEventSequence</a> and <a href="qtest.html#touchEvent">touchEvent</a>().</p>   <h3 class="fn" id="currentAppName">const <span class="type">char</span> *QTest::<span class="name">currentAppName</span>()
</h3> <p>Returns the name of the binary that is currently executed.</p>   <h3 class="fn" id="currentDataTag">const <span class="type">char</span> *QTest::<span class="name">currentDataTag</span>()
</h3> <p>Returns the name of the current test data. If the test doesn't have any assigned testdata, the function returns 0.</p>   <h3 class="fn" id="currentTestFailed">
<span class="type">bool</span> QTest::<span class="name">currentTestFailed</span>()
</h3> <p>Returns <code>true</code> if the current test function failed, otherwise false.</p>   <h3 class="fn" id="currentTestFunction">const <span class="type">char</span> *QTest::<span class="name">currentTestFunction</span>()
</h3> <p>Returns the name of the test function that is currently executed.</p> <p>Example:</p> <pre data-language="cpp">void MyTestClass::cleanup()
{
    if (qstrcmp(QTest::currentTestFunction(), "myDatabaseTest") == 0) {
        // clean up all database connections
        closeAllDatabases();
    }
}</pre>   <h3 class="fn" id="ignoreMessage">
<span class="type">void</span> QTest::<span class="name">ignoreMessage</span>(<span class="type"><a href="qtglobal.html#QtMsgType-enum">QtMsgType</a></span> <i>type</i>, const <span class="type">char</span> *<i>message</i>)
</h3> <p>Ignores messages created by <a href="qtglobal.html#qDebug">qDebug</a>(), <a href="qtglobal.html#qInfo">qInfo</a>() or <a href="qtglobal.html#qWarning">qWarning</a>(). If the <i>message</i> with the corresponding <i>type</i> is outputted, it will be removed from the test log. If the test finished and the <i>message</i> was not outputted, a test failure is appended to the test log.</p> <p><b>Note:</b> Invoking this function will only ignore one message. If the message you want to ignore is outputted twice, you have to call ignoreMessage() twice, too.</p> <p>Example:</p> <pre data-language="cpp">QDir dir;
QTest::ignoreMessage(QtWarningMsg, "QDir::mkdir: Empty or null file name(s)");
dir.mkdir("");</pre> <p>The example above tests that <a href="qdir.html#mkdir">QDir::mkdir</a>() outputs the right warning when invoked with an invalid file name.</p>   <h3 class="fn" id="ignoreMessage-1">
<code>[since 5.3] </code><span class="type">void</span> QTest::<span class="name">ignoreMessage</span>(<span class="type"><a href="qtglobal.html#QtMsgType-enum">QtMsgType</a></span> <i>type</i>, const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>messagePattern</i>)
</h3> <p>This is an overloaded function.</p> <p>Ignores messages created by <a href="qtglobal.html#qDebug">qDebug</a>(), <a href="qtglobal.html#qInfo">qInfo</a>() or <a href="qtglobal.html#qWarning">qWarning</a>(). If the message matching <i>messagePattern</i> with the corresponding <i>type</i> is outputted, it will be removed from the test log. If the test finished and the message was not outputted, a test failure is appended to the test log.</p> <p><b>Note:</b> Invoking this function will only ignore one message. If the message you want to ignore is outputted twice, you have to call ignoreMessage() twice, too.</p> <p>This function was introduced in Qt 5.3.</p>   <h3 class="fn" id="keyClick">
<span class="type">void</span> QTest::<span class="name">keyClick</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="qt.html#Key-enum">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>Simulates clicking of <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before clicking the key.</p> <p>Examples:</p> <pre data-language="cpp">QTest::keyClick(myWidget, Qt::Key_Escape);

QTest::keyClick(myWidget, Qt::Key_Escape, Qt::ShiftModifier, 200);</pre> <p>The first example above simulates clicking the <code>escape</code> key on <code>myWidget</code> without any keyboard modifiers and without delay. The second example simulates clicking <code>shift-escape</code> on <code>myWidget</code> following a 200 ms delay of the test.</p> <p><b>See also </b><a href="qtest.html#keyClicks">QTest::keyClicks</a>().</p>   <h3 class="fn" id="keyClick-1">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">keyClick</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qt.html#Key-enum">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates clicking of <i>key</i> with an optional <i>modifier</i> on a <i>window</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before clicking the key.</p> <p>Examples:</p> <pre data-language="cpp">QTest::keyClick(&amp;myWindow, Qt::Key_Escape);
QTest::keyClick(&amp;myWindow, Qt::Key_Escape, Qt::ShiftModifier, 200);</pre> <p>The first example above simulates clicking the <code>escape</code> key on <code>myWindow</code> without any keyboard modifiers and without delay. The second example simulates clicking <code>shift-escape</code> on <code>myWindow</code> following a 200 ms delay of the test.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#keyClicks">QTest::keyClicks</a>().</p>   <h3 class="fn" id="keyClick-2">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">keyClick</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates clicking of <i>key</i> with an optional <i>modifier</i> on a <i>window</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before clicking the key.</p> <p>Example:</p> <pre data-language="cpp">QWidget myWindow;
QTest::keyClick(&amp;myWindow, Qt::Key_Tab);</pre> <p>The example above simulates clicking <code>a</code> on <code>myWindow</code> without any keyboard modifiers and without delay of the test.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#keyClicks">QTest::keyClicks</a>().</p>   <h3 class="fn" id="keyClick-3">
<span class="type">void</span> QTest::<span class="name">keyClick</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates clicking of <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before clicking the key.</p> <p>Example:</p> <pre data-language="cpp">QTest::keyClick(myWidget, 'a');</pre> <p>The example above simulates clicking <code>a</code> on <code>myWidget</code> without any keyboard modifiers and without delay of the test.</p> <p><b>See also </b><a href="qtest.html#keyClicks">QTest::keyClicks</a>().</p>   <h3 class="fn" id="keyClicks">
<span class="type">void</span> QTest::<span class="name">keyClicks</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>sequence</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>Simulates clicking a <i>sequence</i> of keys on a <i>widget</i>. Optionally, a keyboard <i>modifier</i> can be specified as well as a <i>delay</i> (in milliseconds) of the test before each key click.</p> <p>Example:</p> <pre data-language="cpp">QTest::keyClicks(myWidget, "hello world");</pre> <p>The example above simulates clicking the sequence of keys representing "hello world" on <code>myWidget</code> without any keyboard modifiers and without delay of the test.</p> <p><b>See also </b><a href="qtest.html#keyClick">QTest::keyClick</a>().</p>   <h3 class="fn" id="keyEvent">
<span class="type">void</span> QTest::<span class="name">keyEvent</span>(<span class="type"><a href="qtest.html#KeyAction-enum">QTest::KeyAction</a></span> <i>action</i>, <span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="qt.html#Key-enum">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>Sends a Qt key event to <i>widget</i> with the given <i>key</i> and an associated <i>action</i>. Optionally, a keyboard <i>modifier</i> can be specified, as well as a <i>delay</i> (in milliseconds) of the test before sending the event.</p>   <h3 class="fn" id="keyEvent-1">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">keyEvent</span>(<span class="type"><a href="qtest.html#KeyAction-enum">QTest::KeyAction</a></span> <i>action</i>, <span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type">char</span> <i>ascii</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Sends a Qt key event to <i>window</i> with the given key <i>ascii</i> and an associated <i>action</i>. Optionally, a keyboard <i>modifier</i> can be specified, as well as a <i>delay</i> (in milliseconds) of the test before sending the event.</p> <p>This function was introduced in Qt 5.0.</p>   <h3 class="fn" id="keyEvent-2">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">keyEvent</span>(<span class="type"><a href="qtest.html#KeyAction-enum">QTest::KeyAction</a></span> <i>action</i>, <span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qt.html#Key-enum">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Sends a Qt key event to <i>window</i> with the given <i>key</i> and an associated <i>action</i>. Optionally, a keyboard <i>modifier</i> can be specified, as well as a <i>delay</i> (in milliseconds) of the test before sending the event.</p> <p>This function was introduced in Qt 5.0.</p>   <h3 class="fn" id="keyEvent-3">
<span class="type">void</span> QTest::<span class="name">keyEvent</span>(<span class="type"><a href="qtest.html#KeyAction-enum">QTest::KeyAction</a></span> <i>action</i>, <span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type">char</span> <i>ascii</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Sends a Qt key event to <i>widget</i> with the given key <i>ascii</i> and an associated <i>action</i>. Optionally, a keyboard <i>modifier</i> can be specified, as well as a <i>delay</i> (in milliseconds) of the test before sending the event.</p>   <h3 class="fn" id="keyPress">
<span class="type">void</span> QTest::<span class="name">keyPress</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="qt.html#Key-enum">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>Simulates pressing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before pressing the key.</p> <div class="admonition note"> <p><b>Note: </b>At some point you should release the key using <a href="qtest.html#keyRelease">keyRelease</a>().</p> </div> <p><b>See also </b><a href="qtest.html#keyRelease">QTest::keyRelease</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>   <h3 class="fn" id="keyPress-1">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">keyPress</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates pressing a <i>key</i> with an optional <i>modifier</i> on a <i>window</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before pressing the key.</p> <div class="admonition note"> <p><b>Note: </b>At some point you should release the key using <a href="qtest.html#keyRelease">keyRelease</a>().</p> </div> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#keyRelease">QTest::keyRelease</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>   <h3 class="fn" id="keyPress-2">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">keyPress</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qt.html#Key-enum">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates pressing a <i>key</i> with an optional <i>modifier</i> on a <i>window</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before pressing the key.</p> <div class="admonition note"> <p><b>Note: </b>At some point you should release the key using <a href="qtest.html#keyRelease">keyRelease</a>().</p> </div> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#keyRelease">QTest::keyRelease</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>   <h3 class="fn" id="keyPress-3">
<span class="type">void</span> QTest::<span class="name">keyPress</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates pressing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before pressing the key.</p> <div class="admonition note"> <p><b>Note: </b>At some point you should release the key using <a href="qtest.html#keyRelease">keyRelease</a>().</p> </div> <p><b>See also </b><a href="qtest.html#keyRelease">QTest::keyRelease</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>   <h3 class="fn" id="keyRelease">
<span class="type">void</span> QTest::<span class="name">keyRelease</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="qt.html#Key-enum">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>Simulates releasing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before releasing the key.</p> <p><b>See also </b><a href="qtest.html#keyPress">QTest::keyPress</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>   <h3 class="fn" id="keyRelease-1">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">keyRelease</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates releasing a <i>key</i> with an optional <i>modifier</i> on a <i>window</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before releasing the key.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#keyClick">QTest::keyClick</a>().</p>   <h3 class="fn" id="keyRelease-2">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">keyRelease</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qt.html#Key-enum">Qt::Key</a></span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates releasing a <i>key</i> with an optional <i>modifier</i> on a <i>window</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before releasing the key.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#keyPress">QTest::keyPress</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>   <h3 class="fn" id="keyRelease-3">
<span class="type">void</span> QTest::<span class="name">keyRelease</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type">char</span> <i>key</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::NoModifier, <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates releasing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds before releasing the key.</p> <p><b>See also </b><a href="qtest.html#keyClick">QTest::keyClick</a>().</p>   <h3 class="fn" id="keySequence">
<code>[since 5.10] </code><span class="type">void</span> QTest::<span class="name">keySequence</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, const <span class="type"><a href="qkeysequence.html">QKeySequence</a></span> &amp;<i>keySequence</i>)
</h3> <p>This is an overloaded function.</p> <p>Simulates typing of <i>keySequence</i> into a <i>window</i>.</p> <p>This function was introduced in Qt 5.10.</p> <p><b>See also </b><a href="qtest.html#keyClick">QTest::keyClick</a>() and <a href="qtest.html#keyClicks">QTest::keyClicks</a>().</p>   <h3 class="fn" id="keySequence-1">
<code>[since 5.10] </code><span class="type">void</span> QTest::<span class="name">keySequence</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, const <span class="type"><a href="qkeysequence.html">QKeySequence</a></span> &amp;<i>keySequence</i>)
</h3> <p>This is an overloaded function.</p> <p>Simulates typing of <i>keySequence</i> into a <i>widget</i>.</p> <p>This function was introduced in Qt 5.10.</p> <p><b>See also </b><a href="qtest.html#keyClick">QTest::keyClick</a>() and <a href="qtest.html#keyClicks">QTest::keyClicks</a>().</p>   <h3 class="fn" id="mouseClick">
<span class="type">void</span> QTest::<span class="name">mouseClick</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="qt.html#MouseButton-enum">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::KeyboardModifiers(), <span class="type"><a href="qpoint.html">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>Simulates clicking a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position of the click is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before pressing and before releasing the button.</p> <p><b>See also </b><a href="qtest.html#mousePress">QTest::mousePress</a>() and <a href="qtest.html#mouseRelease">QTest::mouseRelease</a>().</p>   <h3 class="fn" id="mouseClick-1">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">mouseClick</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qt.html#MouseButton-enum">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>stateKey</i> = Qt::KeyboardModifiers(), <span class="type"><a href="qpoint.html">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates clicking a mouse <i>button</i> with an optional <i>stateKey</i> modifier on a <i>window</i>. The position of the click is defined by <i>pos</i>; the default position is the center of the window. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before pressing and before releasing the button.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#mousePress">QTest::mousePress</a>() and <a href="qtest.html#mouseRelease">QTest::mouseRelease</a>().</p>   <h3 class="fn" id="mouseDClick">
<span class="type">void</span> QTest::<span class="name">mouseDClick</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="qt.html#MouseButton-enum">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::KeyboardModifiers(), <span class="type"><a href="qpoint.html">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>Simulates double clicking a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position of the click is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before each press and release.</p> <p><b>See also </b><a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>   <h3 class="fn" id="mouseDClick-1">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">mouseDClick</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qt.html#MouseButton-enum">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>stateKey</i> = Qt::KeyboardModifiers(), <span class="type"><a href="qpoint.html">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates double clicking a mouse <i>button</i> with an optional <i>stateKey</i> modifier on a <i>window</i>. The position of the click is defined by <i>pos</i>; the default position is the center of the window. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before each press and release.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>   <h3 class="fn" id="mouseMove">
<span class="type">void</span> QTest::<span class="name">mouseMove</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="qpoint.html">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>Moves the mouse pointer to a <i>widget</i>. If <i>pos</i> is not specified, the mouse pointer moves to the center of the widget. If a <i>delay</i> (in milliseconds) is given, the test will wait before moving the mouse pointer.</p>   <h3 class="fn" id="mouseMove-1">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">mouseMove</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qpoint.html">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Moves the mouse pointer to a <i>window</i>. If <i>pos</i> is not specified, the mouse pointer moves to the center of the window. If a <i>delay</i> (in milliseconds) is given, the test will wait before moving the mouse pointer.</p> <p>This function was introduced in Qt 5.0.</p>   <h3 class="fn" id="mousePress">
<span class="type">void</span> QTest::<span class="name">mousePress</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="qt.html#MouseButton-enum">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::KeyboardModifiers(), <span class="type"><a href="qpoint.html">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>Simulates pressing a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before the press.</p> <p><b>See also </b><a href="qtest.html#mouseRelease">QTest::mouseRelease</a>() and <a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>   <h3 class="fn" id="mousePress-1">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">mousePress</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qt.html#MouseButton-enum">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>stateKey</i> = Qt::KeyboardModifiers(), <span class="type"><a href="qpoint.html">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates pressing a mouse <i>button</i> with an optional <i>stateKey</i> modifier on a <i>window</i>. The position is defined by <i>pos</i>; the default position is the center of the window. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before the press.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#mouseRelease">QTest::mouseRelease</a>() and <a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>   <h3 class="fn" id="mouseRelease">
<span class="type">void</span> QTest::<span class="name">mouseRelease</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="qt.html#MouseButton-enum">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>modifier</i> = Qt::KeyboardModifiers(), <span class="type"><a href="qpoint.html">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>Simulates releasing a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position of the release is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before releasing the button.</p> <p><b>See also </b><a href="qtest.html#mousePress">QTest::mousePress</a>() and <a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>   <h3 class="fn" id="mouseRelease-1">
<code>[since 5.0] </code><span class="type">void</span> QTest::<span class="name">mouseRelease</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qt.html#MouseButton-enum">Qt::MouseButton</a></span> <i>button</i>, <span class="type"><a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a></span> <i>stateKey</i> = Qt::KeyboardModifiers(), <span class="type"><a href="qpoint.html">QPoint</a></span> <i>pos</i> = QPoint(), <span class="type">int</span> <i>delay</i> = -1)
</h3> <p>This is an overloaded function.</p> <p>Simulates releasing a mouse <i>button</i> with an optional <i>stateKey</i> modifier on a <i>window</i>. The position of the release is defined by <i>pos</i>; the default position is the center of the window. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before releasing the button.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#mousePress">QTest::mousePress</a>() and <a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>   <h3 class="fn" id="newRow">
<span class="type">QTestData</span> &amp;QTest::<span class="name">newRow</span>(const <span class="type">char</span> *<i>dataTag</i>)
</h3> <p>Appends a new row to the current test data. <i>dataTag</i> is the name of the testdata that will appear in the test output. Returns a QTestData reference that can be used to stream in data.</p> <p>Example:</p> <pre data-language="cpp">void MyTestClass::addSingleStringRows()
{
    QTest::addColumn&lt;QString&gt;("aString");
    QTest::newRow("just hello") &lt;&lt; QString("hello");
    QTest::newRow("a null string") &lt;&lt; QString();
}</pre> <p><b>Note:</b> This macro can only be used in a test's data function that is invoked by the test framework.</p> <p>See <a href="https://doc.qt.io/qt-6.2/qttestlib-tutorial2-example.html">Data Driven Testing</a> for a more extensive example.</p> <p><b>See also </b><a href="qtest.html#addColumn">addColumn</a>() and <a href="qtest.html#QFETCH">QFETCH</a>().</p>   <h3 class="fn" id="qExec">
<span class="type">int</span> QTest::<span class="name">qExec</span>(<span class="type"><a href="qobject.html">QObject</a></span> *<i>testObject</i>, <span class="type">int</span> <i>argc</i> = 0, <span class="type">char</span> **<i>argv</i> = nullptr)
</h3> <p>Executes tests declared in <i>testObject</i>. In addition, the private slots <code>initTestCase()</code>, <code>cleanupTestCase()</code>, <code>init()</code> and <code>cleanup()</code> are executed if they exist. See <a href="https://doc.qt.io/qt-6.2/qtest-overview.html#creating-a-test">Creating a Test</a> for more details.</p> <p>Optionally, the command line arguments <i>argc</i> and <i>argv</i> can be provided. For a list of recognized arguments, read <a href="https://doc.qt.io/qt-6.2/qtest-overview.html#qt-test-command-line-arguments">Qt Test Command Line Arguments</a>.</p> <p>The following example will run all tests in <code>MyTestObject</code>:</p> <pre data-language="cpp">MyTestObject test1;
QTest::qExec(&amp;test1);</pre> <p>This function returns 0 if no tests failed, or a value other than 0 if one or more tests failed or in case of unhandled exceptions. (Skipped tests do not influence the return value.)</p> <p>For stand-alone test applications, the convenience macro <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>() can be used to declare a main() function that parses the command line arguments and executes the tests, avoiding the need to call this function explicitly.</p> <p>The return value from this function is also the exit code of the test application when the <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>() macro is used.</p> <p>For stand-alone test applications, this function should not be called more than once, as command-line options for logging test output to files and executing individual test functions will not behave correctly.</p> <p>Note: This function is not reentrant, only one test can run at a time. A test that was executed with qExec() can't run another test via qExec() and threads are not allowed to call qExec() simultaneously.</p> <p>If you have programatically created the arguments, as opposed to getting them from the arguments in <code>main()</code>, it is likely of interest to use QTest::qExec(<a href="qobject.html">QObject</a> *, const <a href="qstringlist.html">QStringList</a> &amp;) since it is Unicode safe.</p> <p><b>See also </b><a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>().</p>   <h3 class="fn" id="qExec-1">
<span class="type">int</span> QTest::<span class="name">qExec</span>(<span class="type"><a href="qobject.html">QObject</a></span> *<i>testObject</i>, const <span class="type"><a href="qstringlist.html">QStringList</a></span> &amp;<i>arguments</i>)
</h3> <p>This is an overloaded function.</p> <p>Behaves identically to qExec(<a href="qobject.html">QObject</a> *, int, char**) but takes a <a href="qstringlist.html">QStringList</a> of <i>arguments</i> instead of a <code>char**</code> list.</p>   <h3 class="fn" id="qExtractTestData">
<span class="type"><a href="qsharedpointer.html">QSharedPointer</a></span>&lt;<span class="type"><a href="qtemporarydir.html">QTemporaryDir</a></span>&gt; QTest::<span class="name">qExtractTestData</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>dirName</i>)
</h3> <p>Extracts a directory from resources to disk. The content is extracted recursively to a temporary folder. The extracted content is removed automatically once the last reference to the return value goes out of scope.</p> <p><i>dirName</i> is the name of the directory to extract from resources.</p> <p>Returns the temporary directory where the data was extracted or null in case of errors.</p>   <h3 class="fn" id="qSleep">
<span class="type">void</span> QTest::<span class="name">qSleep</span>(<span class="type">int</span> <i>ms</i>)
</h3> <p>Sleeps for <i>ms</i> milliseconds, blocking execution of the test. qSleep() will not do any event processing and leave your test unresponsive. Network communication might time out while sleeping. Use <a href="qtest.html#qWait">QTest::qWait</a>() to do non-blocking sleeping.</p> <p><i>ms</i> must be greater than 0.</p> <p><b>Note:</b> The qSleep() function calls either <code>nanosleep()</code> on unix or <code>Sleep()</code> on windows, so the accuracy of time spent in qSleep() depends on the operating system.</p> <p>Example:</p> <pre data-language="cpp">QTest::qSleep(250);</pre> <p><b>See also </b><a href="qtest.html#qWait">QTest::qWait</a>().</p>   <h3 class="fn" id="qWait">
<span class="type">void</span> QTest::<span class="name">qWait</span>(<span class="type">int</span> <i>ms</i>)
</h3> <p>Waits for <i>ms</i> milliseconds. While waiting, events will be processed and your test will stay responsive to user interface events or network communication.</p> <p>Example:</p> <pre data-language="cpp">    int i = 0;
    while (myNetworkServerNotResponding() &amp;&amp; i++ &lt; 50)
        QTest::qWait(250);</pre> <p>The code above will wait until the network server is responding for a maximum of about 12.5 seconds.</p> <p><b>See also </b><a href="qtest.html#qSleep">QTest::qSleep</a>() and <a href="qsignalspy.html#wait">QSignalSpy::wait</a>().</p>   <h3 class="fn" id="qWaitFor">
<code>[since 5.10] </code>template &lt;typename Functor&gt; <span class="type">bool</span> QTest::<span class="name">qWaitFor</span>(<span class="type">Functor</span> <i>predicate</i>, <span class="type">int</span> <i>timeout</i> = 5000)
</h3> <p>Waits for <i>timeout</i> milliseconds or until the <i>predicate</i> returns true.</p> <p>Returns <code>true</code> if the <i>predicate</i> returned true at any point, otherwise returns <code>false</code>.</p> <p>Example:</p> <pre data-language="cpp">    MyObject obj;
    obj.startup();
    QTest::qWaitFor([&amp;]() {
        return obj.isReady();
    }, 3000);</pre> <p>The code above will wait for the object to become ready, for a maximum of three seconds.</p> <p>This function was introduced in Qt 5.10.</p>   <h3 class="fn" id="qWaitForWindowActive">
<code>[since 5.0] </code><span class="type">bool</span> QTest::<span class="name">qWaitForWindowActive</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type">int</span> <i>timeout</i> = 5000)
</h3> <p>Waits for <i>timeout</i> milliseconds or until the <i>window</i> is active.</p> <p>Returns <code>true</code> if <code>window</code> is active within <i>timeout</i> milliseconds, otherwise returns <code>false</code>.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#qWaitForWindowExposed">qWaitForWindowExposed</a>() and <a href="qwindow.html#isActive">QWindow::isActive</a>().</p>   <h3 class="fn" id="qWaitForWindowActive-1">
<code>[since 5.0] </code><span class="type">bool</span> QTest::<span class="name">qWaitForWindowActive</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type">int</span> <i>timeout</i> = 5000)
</h3> <p>Waits for <i>timeout</i> milliseconds or until the <i>widget</i>'s window is active.</p> <p>Returns <code>true</code> if <code>widget</code>'s window is active within <i>timeout</i> milliseconds, otherwise returns <code>false</code>.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#qWaitForWindowExposed">qWaitForWindowExposed</a>() and <a href="qwidget.html#isActiveWindow-prop">QWidget::isActiveWindow</a>().</p>   <h3 class="fn" id="qWaitForWindowExposed">
<code>[since 5.0] </code><span class="type">bool</span> QTest::<span class="name">qWaitForWindowExposed</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type">int</span> <i>timeout</i> = 5000)
</h3> <p>Waits for <i>timeout</i> milliseconds or until the <i>window</i> is exposed. Returns <code>true</code> if <code>window</code> is exposed within <i>timeout</i> milliseconds, otherwise returns <code>false</code>.</p> <p>This is mainly useful for asynchronous systems like X11, where a window will be mapped to screen some time after being asked to show itself on the screen.</p> <p>Note that a window that is mapped to screen may still not be considered exposed if the window client area is completely covered by other windows, or if the window is otherwise not visible. This function will then time out when waiting for such a window.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#qWaitForWindowActive">qWaitForWindowActive</a>() and <a href="qwindow.html#isExposed">QWindow::isExposed</a>().</p>   <h3 class="fn" id="qWaitForWindowExposed-1">
<code>[since 5.0] </code><span class="type">bool</span> QTest::<span class="name">qWaitForWindowExposed</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type">int</span> <i>timeout</i> = 5000)
</h3> <p>Waits for <i>timeout</i> milliseconds or until the <i>widget</i>'s window is exposed. Returns <code>true</code> if <code>widget</code>'s window is exposed within <i>timeout</i> milliseconds, otherwise returns <code>false</code>.</p> <p>This is mainly useful for asynchronous systems like X11, where a window will be mapped to screen some time after being asked to show itself on the screen.</p> <p>Note that a window that is mapped to screen may still not be considered exposed if the window client area is completely covered by other windows, or if the window is otherwise not visible. This function will then time out when waiting for such a window.</p> <p>A specific configuration where this happens is when using QGLWidget as a viewport widget on macOS: The viewport widget gets the expose event, not the parent widget.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#qWaitForWindowActive">qWaitForWindowActive</a>().</p>   <h3 class="fn" id="setBenchmarkResult">
<span class="type">void</span> QTest::<span class="name">setBenchmarkResult</span>(<span class="type"><a href="qtglobal.html#qreal-typedef">qreal</a></span> <i>result</i>, <span class="type"><a href="qtest.html#QBenchmarkMetric-enum">QTest::QBenchmarkMetric</a></span> <i>metric</i>)
</h3> <p>Sets the benchmark result for this test function to <i>result</i>.</p> <p>Use this function if you want to report benchmark results without using the QBENCHMARK macro. Use <i>metric</i> to specify how Qt Test should interpret the results.</p> <p>The context for the result will be the test function name and any data tag from the _data function. This function can only be called once in each test function, subsequent calls will replace the earlier reported results.</p> <p>Note that the -iterations command line argument has no effect on test functions without the QBENCHMARK macro.</p>   <h3 class="fn" id="toHexRepresentation">
<span class="type">char</span> *QTest::<span class="name">toHexRepresentation</span>(const <span class="type">char</span> *<i>ba</i>, <span class="type">int</span> <i>length</i>)
</h3> <p>Returns a pointer to a string that is the string <i>ba</i> represented as a space-separated sequence of hex characters. If the input is considered too long, it is truncated. A trucation is indicated in the returned string as an ellipsis at the end. The caller has ownership of the returned pointer and must ensure it is later passed to operator delete[].</p> <p><i>length</i> is the length of the string <i>ba</i>.</p>   <h3 class="fn" id="toString">
<code>[since 5.11] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qstringview.html">QStringView</a></span> &amp;<i>string</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>string</i>.</p> <p>This function was introduced in Qt 5.11.</p>   <h3 class="fn" id="toString">template &lt;typename T&gt; <span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type">T</span> &amp;<i>value</i>)
</h3> <p>Returns a textual representation of <i>value</i>. This function is used by <a href="qtest.html#QCOMPARE">QCOMPARE</a>() to output verbose information in case of a test failure.</p> <p>You can add specializations or overloads of this function to your test to enable verbose output.</p> <div class="admonition note"> <p><b>Note: </b>Starting with Qt 5.5, you should prefer to provide a toString() function in the type's namespace instead of specializing this template. If your code needs to continue to work with the QTestLib from Qt 5.4 or earlier, you need to continue to use specialization.</p> </div> <div class="admonition note"> <p><b>Note: </b>The caller of toString() must delete the returned data using <code>delete[]</code>. Your implementation should return a string created with <code>new[]</code> or <a href="qbytearray.html#qstrdup">qstrdup</a>(). The easiest way to do so is to create a <a href="qbytearray.html">QByteArray</a> or <a href="qstring.html">QString</a> and call QTest::toString() on it (see second example below).</p> </div> <p>Example for specializing (Qt â‰¤ 5.4):</p> <pre data-language="cpp">namespace QTest {
    template&lt;&gt;
    char *toString(const MyPoint &amp;point)
    {
        const QByteArray ba("MyPoint("
                            + QByteArray::number(point.x()) + ", "
                            + QByteArray::number(point.y()) + ')');
        return qstrdup(ba.data());
    }
}</pre> <p>The example above defines a toString() specialization for a class called <code>MyPoint</code>. Whenever a comparison of two instances of <code>MyPoint</code> fails, <a href="qtest.html#QCOMPARE">QCOMPARE</a>() will call this function to output the contents of <code>MyPoint</code> to the test log.</p> <p>Same example, but with overloading (Qt â‰¥ 5.5):</p> <pre data-language="cpp">namespace {
    char *toString(const MyPoint &amp;point)
    {
        return QTest::toString("MyPoint(" +
                               QByteArray::number(point.x()) + ", " +
                               QByteArray::number(point.y()) + ')');
    }
}</pre> <p><b>See also </b><a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>   <h3 class="fn" id="toString-1">
<code>[since 5.11] </code>template &lt;typename T1, typename T2&gt; <span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type">QPair</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt; &amp;<i>pair</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the <i>pair</i>.</p> <p>This function was introduced in Qt 5.11.</p>   <h3 class="fn" id="toString-36">
<code>[since 5.11] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qvector2d.html">QVector2D</a></span> &amp;<i>v</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the 2D vector <i>v</i>.</p> <p>This function was introduced in Qt 5.11.</p>   <h3 class="fn" id="toString-37">
<code>[since 5.11] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qvector3d.html">QVector3D</a></span> &amp;<i>v</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the 3D vector <i>v</i>.</p> <p>This function was introduced in Qt 5.11.</p>   <h3 class="fn" id="toString-38">
<code>[since 5.11] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qvector4d.html">QVector4D</a></span> &amp;<i>v</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the 4D vector <i>v</i>.</p> <p>This function was introduced in Qt 5.11.</p>   <h3 class="fn" id="toString-39">
<code>[since 5.5] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(<span class="type"><a href="qsizepolicy.html#Policy-enum">QSizePolicy::Policy</a></span> <i>p</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of policy <i>p</i>.</p> <p>This function was introduced in Qt 5.5.</p>   <h3 class="fn" id="toString-40">
<code>[since 5.5] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(<span class="type"><a href="qsizepolicy.html#ControlType-enum">QSizePolicy::ControlTypes</a></span> <i>cts</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of control types <i>cts</i>.</p> <p>This function was introduced in Qt 5.5.</p>   <h3 class="fn" id="toString-41">
<code>[since 5.5] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(<span class="type"><a href="qsizepolicy.html#ControlType-enum">QSizePolicy::ControlType</a></span> <i>ct</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of control type <i>ct</i>.</p> <p>This function was introduced in Qt 5.5.</p>   <h3 class="fn" id="toString-42">
<code>[since 5.5] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(<span class="type"><a href="qsizepolicy.html">QSizePolicy</a></span> <i>sp</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of size policy <i>sp</i>.</p> <p>This function was introduced in Qt 5.5.</p>   <h3 class="fn" id="toString-2">
<code>[since 5.11] </code>template &lt;typename T1, typename T2&gt; <span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type">std::pair</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt; &amp;<i>pair</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the <i>pair</i>.</p> <p>This function was introduced in Qt 5.11.</p>   <h3 class="fn" id="toString-3">
<code>[since 5.12] </code>template &lt;typename Types&gt; <span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type">std::tuple</span>&lt;<span class="type">Types</span>...&gt; &amp;<i>tuple</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>tuple</i>.</p> <p>This function was introduced in Qt 5.12.</p>   <h3 class="fn" id="toString-5">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>string</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>string</i>.</p>   <h3 class="fn" id="toString-6">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qlatin1string.html">QLatin1String</a></span> &amp;<i>string</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>string</i>.</p>   <h3 class="fn" id="toString-7">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>ba</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the byte array <i>ba</i>.</p> <p><b>See also </b><a href="qtest.html#toHexRepresentation">QTest::toHexRepresentation</a>().</p>   <h3 class="fn" id="toString-9">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qtime.html">QTime</a></span> &amp;<i>time</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>time</i>.</p>   <h3 class="fn" id="toString-10">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qdate.html">QDate</a></span> &amp;<i>date</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>date</i>.</p>   <h3 class="fn" id="toString-11">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qdatetime.html">QDateTime</a></span> &amp;<i>dateTime</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the date and time specified by <i>dateTime</i>.</p>   <h3 class="fn" id="toString-12">
<code>[since 5.12] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qcborerror.html">QCborError</a></span> &amp;<i>c</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given CBOR error <i>c</i>.</p> <p>This function was introduced in Qt 5.12.</p>   <h3 class="fn" id="toString-13">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qchar.html">QChar</a></span> &amp;<i>character</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>character</i>.</p>   <h3 class="fn" id="toString-15">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qpoint.html">QPoint</a></span> &amp;<i>point</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>point</i>.</p>   <h3 class="fn" id="toString-16">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qsize.html">QSize</a></span> &amp;<i>size</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>size</i>.</p>   <h3 class="fn" id="toString-17">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qrect.html">QRect</a></span> &amp;<i>rectangle</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>rectangle</i>.</p>   <h3 class="fn" id="toString-18">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qpointf.html">QPointF</a></span> &amp;<i>point</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>point</i>.</p>   <h3 class="fn" id="toString-19">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qsizef.html">QSizeF</a></span> &amp;<i>size</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>size</i>.</p>   <h3 class="fn" id="toString-20">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qrectf.html">QRectF</a></span> &amp;<i>rectangle</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>rectangle</i>.</p>   <h3 class="fn" id="toString-21">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qurl.html">QUrl</a></span> &amp;<i>url</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>url</i>.</p>   <h3 class="fn" id="toString-22">
<code>[since 5.11] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="quuid.html">QUuid</a></span> &amp;<i>uuid</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>uuid</i>.</p> <p>This function was introduced in Qt 5.11.</p>   <h3 class="fn" id="toString-23">
<span class="type">char</span> *QTest::<span class="name">toString</span>(const <span class="type"><a href="qvariant.html">QVariant</a></span> &amp;<i>variant</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a textual representation of the given <i>variant</i>.</p>   <h3 class="fn" id="toString-29">
<code>[since 5.8] </code><span class="type">char</span> *QTest::<span class="name">toString</span>(<span class="type">std::nullptr_t</span>)
</h3> <p>This is an overloaded function.</p> <p>Returns a string containing <code>nullptr</code>.</p> <p>This function was introduced in Qt 5.8.</p>   <h3 class="fn" id="touchEvent">
<span class="type">QTest::QTouchEventWidgetSequence</span> QTest::<span class="name">touchEvent</span>(<span class="type"><a href="qwidget.html">QWidget</a></span> *<i>widget</i>, <span class="type"><a href="qpointingdevice.html">QPointingDevice</a></span> *<i>device</i>, <span class="type">bool</span> <i>autoCommit</i> = true)
</h3> <p>Creates and returns a <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a> for the <i>device</i> to simulate events for <i>widget</i>.</p> <p>When adding touch events to the sequence, <i>widget</i> will also be used to translate the position provided to screen coordinates, unless another widget is provided in the respective calls to press(), move() etc.</p> <p>The touch events are committed to the event system when the destructor of the <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a> is called (ie when the object returned runs out of scope), unless <i>autoCommit</i> is set to false. When <i>autoCommit</i> is false, commit() has to be called manually.</p> <p><a href="qtest.html#createTouchDevice">createTouchDevice</a>() can be called to create a test touch device for use with this function.</p>   <h3 class="fn" id="touchEvent-1">
<code>[since 5.0] </code><span class="type"><a href="qtest-qtoucheventsequence.html">QTest::QTouchEventSequence</a></span> QTest::<span class="name">touchEvent</span>(<span class="type"><a href="qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qpointingdevice.html">QPointingDevice</a></span> *<i>device</i>, <span class="type">bool</span> <i>autoCommit</i> = true)
</h3> <p>Creates and returns a <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a> for the <i>device</i> to simulate events for <i>window</i>.</p> <p>When adding touch events to the sequence, <i>window</i> will also be used to translate the position provided to screen coordinates, unless another window is provided in the respective calls to press(), move() etc.</p> <p>The touch events are committed to the event system when the destructor of the <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a> is called (ie when the object returned runs out of scope), unless <i>autoCommit</i> is set to false. When <i>autoCommit</i> is false, commit() has to be called manually.</p> <p><a href="qtest.html#createTouchDevice">createTouchDevice</a>() can be called to create a test touch device for use with this function.</p> <p>This function was introduced in Qt 5.0.</p>   <div class="macros"> <h2>Macro Documentation</h2>  <h3 class="fn" id="QBENCHMARK">
<span class="name">QBENCHMARK</span>
</h3> <p>This macro is used to measure the performance of code within a test. The code to be benchmarked is contained within a code block following this macro.</p> <p>For example:</p> <pre data-language="cpp">void TestBenchmark::simple()
{
    QString str1 = QLatin1String("This is a test string");
    QString str2 = QLatin1String("This is a test string");
    QCOMPARE(str1.localeAwareCompare(str2), 0);
    QBENCHMARK {
        str1.localeAwareCompare(str2);
    }
}</pre> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qtest-overview.html#creating-a-benchmark">Creating a Benchmark</a> and <a href="https://doc.qt.io/qt-6.2/qttestlib-tutorial5-example.html">Writing a Benchmark</a>.</p>   <h3 class="fn" id="QBENCHMARK_ONCE">
<span class="name">QBENCHMARK_ONCE</span>
</h3> <p>The QBENCHMARK_ONCE macro is for measuring performance of a code block by running it once.</p> <p>This macro is used to measure the performance of code within a test. The code to be benchmarked is contained within a code block following this macro.</p> <p>Unlike QBENCHMARK, the contents of the contained code block is only run once. The elapsed time will be reported as "0" if it's to short to be measured by the selected backend. (Use)</p> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qtest-overview.html#creating-a-benchmark">Creating a Benchmark</a> and <a href="https://doc.qt.io/qt-6.2/qttestlib-tutorial5-example.html">Writing a Benchmark</a>.</p>   <h3 class="fn" id="QCOMPARE">
<span class="name">QCOMPARE</span>(<i>actual</i>, <i>expected</i>)
</h3> <p>The QCOMPARE() macro compares an <i>actual</i> value to an <i>expected</i> value using the equality operator. If <i>actual</i> and <i>expected</i> match, execution continues. If not, a failure is recorded in the test log and the test function returns without attempting any later checks.</p> <p>Always respect QCOMPARE() parameter semantics. The first parameter passed to it should always be the actual value produced by the code-under-test, while the second parameter should always be the expected value. When the values don't match, QCOMPARE() prints them with the labels <i>Actual</i> and <i>Expected</i>. If the parameter order is swapped, debugging a failing test can be confusing and tests expecting zero may fail due to rounding errors.</p> <p>QCOMPARE() tries to output the contents of the values if the comparison fails, so it is visible from the test log why the comparison failed.</p> <p>Example:</p> <pre data-language="cpp">QCOMPARE(QString("hello").toUpper(), QString("HELLO"));</pre> <p>When comparing floating-point types (<code>float</code>, <code>double</code>, and <code>qfloat16</code>), <a href="qtglobal.html#qFuzzyCompare-1">qFuzzyCompare</a>() is used for finite values. If <a href="qtglobal.html#qFuzzyIsNull">qFuzzyIsNull</a>() is true for both values, they are also considered equal. Infinities match if they have the same sign, and any NaN as actual value matches with any NaN as expected value (even though NaN != NaN, even when they're identical).</p> <p>When comparing <a href="qlist.html">QList</a>, arrays and initializer lists of the value type can be passed as expected value:</p> <pre data-language="cpp">    const int expected[] = {8, 10, 12, 16, 20, 24};
    QCOMPARE(QFontDatabase::standardSizes(), expected);</pre> <p>Note that using initializer lists requires a defining a helper macro to prevent the preprocessor from interpreting the commas as macro argument delimiters:</p> <pre data-language="cpp"> #define ARG(...) __VA_ARGS__
     QCOMPARE(QFontDatabase::standardSizes(), ARG({8, 10, 12, 16, 20, 24}));
 #undef ARG</pre> <div class="admonition note"> <p><b>Note: </b>QCOMPARE() can only be used in a test function that is invoked by the test framework.</p> </div> <p>For your own classes, you can use <a href="qtest.html#toString">QTest::toString</a>() to format values for outputting into the test log.</p> <p>Example:</p> <pre data-language="cpp">char *toString(const MyType &amp;t)
{
    char *repr = new char[t.reprSize()];
    t.writeRepr(repr);
    return repr;
}</pre> <p>The return from <code>toString()</code> must be a <code>new char []</code>. That is, it shall be released with <code>delete[]</code> (rather than <code>free()</code> or plain <code>delete</code>) once the calling code is done with it.</p> <p><b>See also </b><a href="qtest.html#QVERIFY">QVERIFY</a>(), <a href="qtest.html#QTRY_COMPARE">QTRY_COMPARE</a>(), <a href="qtest.html#toString">QTest::toString</a>(), and <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>   <h3 class="fn" id="QEXPECT_FAIL">
<span class="name">QEXPECT_FAIL</span>(<i>dataIndex</i>, <i>comment</i>, <i>mode</i>)
</h3> <p>The QEXPECT_FAIL() macro marks the next <a href="qtest.html#QCOMPARE">QCOMPARE</a>() or <a href="qtest.html#QVERIFY">QVERIFY</a>() as an expected failure. Instead of adding a failure to the test log, an expected failure will be reported.</p> <p>If a <a href="qtest.html#QVERIFY">QVERIFY</a>() or <a href="qtest.html#QCOMPARE">QCOMPARE</a>() is marked as an expected failure, but passes instead, an unexpected pass (XPASS) is written to the test log.</p> <p>The parameter <i>dataIndex</i> describes for which entry in the test data the failure is expected. Pass an empty string (<code>""</code>) if the failure is expected for all entries or if no test data exists.</p> <p><i>comment</i> will be appended to the test log for the expected failure.</p> <p><i>mode</i> is a <a href="qtest.html#TestFailMode-enum">QTest::TestFailMode</a> and sets whether the test should continue to execute or not.</p> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p> </div> <p>Example 1:</p> <pre data-language="cpp">QEXPECT_FAIL("", "Will fix in the next release", Continue);
QCOMPARE(i, 42);
QCOMPARE(j, 43);</pre> <p>In the example above, an expected fail will be written into the test output if the variable <code>i</code> is not 42. If the variable <code>i</code> is 42, an unexpected pass is written instead. The QEXPECT_FAIL() has no influence on the second <a href="qtest.html#QCOMPARE">QCOMPARE</a>() statement in the example.</p> <p>Example 2:</p> <pre data-language="cpp">QEXPECT_FAIL("data27", "Oh my, this is soooo broken", Abort);
QCOMPARE(i, 42);</pre> <p>The above testfunction will not continue executing for the test data entry <code>data27</code>.</p> <p><b>See also </b><a href="qtest.html#TestFailMode-enum">QTest::TestFailMode</a>, <a href="qtest.html#QVERIFY">QVERIFY</a>(), and <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>   <h3 class="fn" id="QFAIL">
<span class="name">QFAIL</span>(<i>message</i>)
</h3> <p>This macro can be used to force a test failure. The test stops executing and the failure <i>message</i> is appended to the test log.</p> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p> </div> <p>Example:</p> <pre data-language="cpp">if (sizeof(int) != 4)
    QFAIL("This test has not been ported to this platform yet.");</pre>   <h3 class="fn" id="QFETCH">
<span class="name">QFETCH</span>(<i>type</i>, <i>name</i>)
</h3> <p>The fetch macro creates a local variable named <i>name</i> with the type <i>type</i> on the stack. The <i>name</i> and <i>type</i> must match a column from the test's data table. This is asserted and the test will abort if the assertion fails.</p> <p>Assuming a test has the following data:</p> <pre data-language="cpp">void TestQString::toInt_data()
{
    QTest::addColumn&lt;QString&gt;("aString");
    QTest::addColumn&lt;int&gt;("expected");

    QTest::newRow("positive value") &lt;&lt; "42" &lt;&lt; 42;
    QTest::newRow("negative value") &lt;&lt; "-42" &lt;&lt; -42;
    QTest::newRow("zero") &lt;&lt; "0" &lt;&lt; 0;
}</pre> <p>The test data has two elements, a <a href="qstring.html">QString</a> called <code>aString</code> and an integer called <code>expected</code>. To fetch these values in the actual test:</p> <pre data-language="cpp">void TestQString::toInt()
{
     QFETCH(QString, aString);
     QFETCH(int, expected);

     QCOMPARE(aString.toInt(), expected);
}</pre> <p><code>aString</code> and <code>expected</code> are variables on the stack that are initialized with the current test data.</p> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework. The test function must have a _data function.</p> </div>   <h3 class="fn" id="QFETCH_GLOBAL">
<span class="name">QFETCH_GLOBAL</span>(<i>type</i>, <i>name</i>)
</h3> <p>This macro fetches a variable named <i>name</i> with the type <i>type</i> from a row in the global data table. The <i>name</i> and <i>type</i> must match a column in the global data table. This is asserted and the test will abort if the assertion fails.</p> <p>Assuming a test has the following data:</p> <pre data-language="cpp">void TestQLocale::initTestCase_data()
{
    QTest::addColumn&lt;QLocale&gt;("locale");
    QTest::newRow("C") &lt;&lt; QLocale::c();
    QTest::newRow("UKish") &lt;&lt; QLocale("en_GB");
    QTest::newRow("USAish") &lt;&lt; QLocale(QLocale::English, QLocale::UnitedStates);
}

void TestQLocale::roundTripInt_data()
{
    QTest::addColumn&lt;int&gt;("number");
    QTest::newRow("zero") &lt;&lt; 0;
    QTest::newRow("one") &lt;&lt; 1;
    QTest::newRow("two") &lt;&lt; 2;
    QTest::newRow("ten") &lt;&lt; 10;
}</pre> <p>The test's own data is a single number per row. In this case, <code>initTestCase_data()</code> also supplies a locale per row. Therefore, this test will be run with every combination of locale from the latter and number from the former. Thus, with four rows in the global table and three in the local, the test function is run for 12 distinct test-cases (4 * 3 = 12).</p> <pre data-language="cpp">void TestQLocale::roundTripInt()
{
    QFETCH_GLOBAL(QLocale, locale);
    QFETCH(int, number);
    bool ok;
    QCOMPARE(locale.toInt(locale.toString(number), &amp;ok), number);
    QVERIFY(ok);
}</pre> <p>The locale is read from the global data table using QFETCH_GLOBAL(), and the number is read from the local data table using <a href="qtest.html#QFETCH">QFETCH</a>().</p> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in test methods of a class with an <code>initTestCase_data()</code> method.</p> </div>   <h3 class="fn" id="QFINDTESTDATA">
<code>[since 5.0] </code><span class="name">QFINDTESTDATA</span>(<i>filename</i>)
</h3> <p>Returns a <a href="qstring.html">QString</a> for the testdata file referred to by <i>filename</i>, or an empty <a href="qstring.html">QString</a> if the testdata file could not be found.</p> <p>This macro allows the test to load data from an external file without hardcoding an absolute filename into the test, or using relative paths which may be error prone.</p> <p>The returned path will be the first path from the following list which resolves to an existing file or directory:</p> <ul> <li>
<i>filename</i> relative to <a href="qcoreapplication.html#applicationDirPath">QCoreApplication::applicationDirPath</a>() (only if a <a href="qcoreapplication.html">QCoreApplication</a> or <a href="qapplication.html">QApplication</a> object has been created).</li> <li>
<i>filename</i> relative to the test's standard install directory (<a href="qlibraryinfo.html#LibraryPath-enum">QLibraryInfo::TestsPath</a> with the lowercased testcase name appended).</li> <li>
<i>filename</i> relative to the directory containing the source file from which QFINDTESTDATA is invoked.</li> </ul> <p>If the named file/directory does not exist at any of these locations, a warning is printed to the test log.</p> <p>For example, in this code:</p> <pre data-language="cpp">bool tst_MyXmlParser::parse()
{
    MyXmlParser parser;
    QString input = QFINDTESTDATA("testxml/simple1.xml");
    QVERIFY(parser.parse(input));
}</pre> <p>The testdata file will be resolved as the first existing file from:</p> <ul> <li><code>/home/user/build/myxmlparser/tests/tst_myxmlparser/testxml/simple1.xml</code></li> <li><code>/usr/local/Qt-5.0.0/tests/tst_myxmlparser/testxml/simple1.xml</code></li> <li><code>/home/user/sources/myxmlparser/tests/tst_myxmlparser/testxml/simple1.xml</code></li> </ul> <p>This allows the test to find its testdata regardless of whether the test has been installed, and regardless of whether the test's build tree is equal to the test's source tree.</p> <div class="admonition note"> <p><b>Note: </b>reliable detection of testdata from the source directory requires either that qmake is used, or the <code>QT_TESTCASE_BUILDDIR</code> macro is defined to point to the working directory from which the compiler is invoked, or only absolute paths to the source files are passed to the compiler. Otherwise, the absolute path of the source directory cannot be determined.</p> </div> <div class="admonition note"> <p><b>Note: </b>The <code>QT_TESTCASE_BUILDDIR</code> macro is also implicitly defined if CMake is used and the <a href="https://doc.qt.io/qt-6.2/qttest-module.html">QtTest</a> module is linked to the target. You can change the default <code>QT_TESTCASE_BUILDDIR</code> by setting the QT_TESTCASE_BUILDDIR property on the target.</p> </div> <div class="admonition note"> <p><b>Note: </b>For tests that use the <a href="qtest.html#QTEST_APPLESS_MAIN">QTEST_APPLESS_MAIN</a>() macro to generate a <code>main()</code> function, <code>QFINDTESTDATA</code> will not attempt to find test data relative to <a href="qcoreapplication.html#applicationDirPath">QCoreApplication::applicationDirPath</a>(). In practice, this means that tests using <code>QTEST_APPLESS_MAIN()</code> will fail to find their test data if run from a shadow build tree.</p> </div> <p>This function was introduced in Qt 5.0.</p>   <h3 class="fn" id="QSKIP">
<span class="name">QSKIP</span>(<i>description</i>)
</h3> <p>If called from a test function, the QSKIP() macro stops execution of the test without adding a failure to the test log. You can use it to skip tests that wouldn't make sense in the current configuration. For example, a test of font rendering may call QSKIP() if the needed fonts are not installed on the test system.</p> <p>The text <i>description</i> is appended to the test log and should contain an explanation of why the test couldn't be executed.</p> <p>If the test is data-driven, each call to QSKIP() in the test function will skip only the current row of test data, so an unconditional call to QSKIP() will produce one skip message in the test log for each row of test data.</p> <p>If called from an <code>_data</code> function, the QSKIP() macro will stop execution of the <code>_data</code> function and will prevent execution of the associated test function. This entirely omits a data-driven test. To omit individual rows, make them conditional by using a simple <code>if (condition) newRow(...) &lt;&lt; ...</code> in the <code>_data</code> function, instead of using QSKIP() in the test function.</p> <p>If called from <code>initTestCase_data()</code>, the QSKIP() macro will skip all test and <code>_data</code> functions. If called from <code>initTestCase()</code> when there is no <code>initTestCase_data()</code>, or when it only sets up one row, QSKIP() will likewise skip the whole test. However, if <code>initTestCase_data()</code> contains more than one row, then <code>initTestCase()</code> is called (followed by each test and finally the wrap-up) once per row of it. Therefore, a call to QSKIP() in <code>initTestCase()</code> will merely skip all test functions for the current row of global data, set up by <code>initTestCase_data()</code>.</p> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function or <code>_data</code> function that is invoked by the test framework.</p> </div> <p>Example:</p> <pre data-language="cpp">if (!QSqlDatabase::drivers().contains("SQLITE"))
    QSKIP("This test requires the SQLITE database driver");</pre> <h5 id="skipping-known-bugs">Skipping Known Bugs
</h5> <p>If a test exposes a known bug that will not be fixed immediately, use the <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>() macro to document the failure and reference the bug tracking identifier for the known issue. When the test is run, expected failures will be marked as XFAIL in the test output and will not be counted as failures when setting the test program's return code. If an expected failure does not occur, the XPASS (unexpected pass) will be reported in the test output and will be counted as a test failure.</p> <p>For known bugs, <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>() is better than QSKIP() because a developer cannot fix the bug without an XPASS result reminding them that the test needs to be updated too. If QSKIP() is used, there is no reminder to revise or re-enable the test, without which subsequent regressions will not be reported.</p> <p><b>See also </b><a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>() and <a href="qttest-best-practices-qdoc.html#select-appropriate-mechanisms-to-exclude-tests">Select Appropriate Mechanisms to Exclude Tests</a>.</p>   <h3 class="fn" id="QTEST">
<span class="name">QTEST</span>(<i>actual</i>, <i>testElement</i>)
</h3> <p>QTEST() is a convenience macro for <a href="qtest.html#QCOMPARE">QCOMPARE</a>() that compares the value <i>actual</i> with the element <i>testElement</i> from the test's data. If there is no such element, the test asserts.</p> <p>Apart from that, QTEST() behaves exactly as <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p> <p>Instead of writing:</p> <pre data-language="cpp">QFETCH(QString, myString);
QCOMPARE(QString("hello").toUpper(), myString);</pre> <p>you can write:</p> <pre data-language="cpp">QTEST(QString("hello").toUpper(), "myString");</pre> <p><b>See also </b><a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>   <h3 class="fn" id="QTEST_APPLESS_MAIN">
<span class="name">QTEST_APPLESS_MAIN</span>(<i>TestClass</i>)
</h3> <p>Implements a main() function that executes all tests in <i>TestClass</i>.</p> <p>Behaves like <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>(), but doesn't instantiate a <a href="qapplication.html">QApplication</a> object. Use this macro for really simple stand-alone non-GUI tests.</p> <p><b>See also </b><a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>().</p>   <h3 class="fn" id="QTEST_GUILESS_MAIN">
<code>[since 5.0] </code><span class="name">QTEST_GUILESS_MAIN</span>(<i>TestClass</i>)
</h3> <p>Implements a main() function that instantiates a <a href="qcoreapplication.html">QCoreApplication</a> object and the <i>TestClass</i>, and executes all tests in the order they were defined. Use this macro to build stand-alone executables.</p> <p>Behaves like <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>(), but instantiates a <a href="qcoreapplication.html">QCoreApplication</a> instead of the <a href="qapplication.html">QApplication</a> object. Use this macro if your test case doesn't need functionality offered by <a href="qapplication.html">QApplication</a>, but the event loop is still necessary.</p> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>().</p>   <h3 class="fn" id="QTEST_MAIN">
<span class="name">QTEST_MAIN</span>(<i>TestClass</i>)
</h3> <p>Implements a main() function that instantiates an application object and the <i>TestClass</i>, and executes all tests in the order they were defined. Use this macro to build stand-alone executables.</p> <p>If <code>QT_WIDGETS_LIB</code> is defined, the application object will be a <a href="qapplication.html">QApplication</a>, if <code>QT_GUI_LIB</code> is defined, the application object will be a <a href="qguiapplication.html">QGuiApplication</a>, otherwise it will be a <a href="qcoreapplication.html">QCoreApplication</a>. If qmake is used and the configuration includes <code>QT += widgets</code>, then <code>QT_WIDGETS_LIB</code> will be defined automatically. Similarly, if qmake is used and the configuration includes <code>QT += gui</code>, then <code>QT_GUI_LIB</code> will be defined automatically.</p> <div class="admonition note"> <p><b>Note: </b>On platforms that have keypad navigation enabled by default, this macro will forcefully disable it if <code>QT_WIDGETS_LIB</code> is defined. This is done to simplify the usage of key events when writing autotests. If you wish to write a test case that uses keypad navigation, you should enable it either in the <code>initTestCase()</code> or <code>init()</code> functions of your test case by calling <a href="qapplication.html#setNavigationMode">QApplication::setNavigationMode</a>().</p> </div> <p>Example:</p> <pre data-language="cpp">QTEST_MAIN(TestQString)</pre> <p><b>See also </b><a href="qtest.html#QTEST_APPLESS_MAIN">QTEST_APPLESS_MAIN</a>(), <a href="qtest.html#QTEST_GUILESS_MAIN">QTEST_GUILESS_MAIN</a>(), <a href="qtest.html#qExec">QTest::qExec</a>(), and <a href="qapplication.html#setNavigationMode">QApplication::setNavigationMode</a>().</p>   <h3 class="fn" id="QTRY_COMPARE">
<code>[since 5.0] </code><span class="name">QTRY_COMPARE</span>(<i>actual</i>, <i>expected</i>)
</h3> <p>Performs a comparison of the <i>actual</i> and <i>expected</i> values by invoking <a href="qtest.html#QTRY_COMPARE_WITH_TIMEOUT">QTRY_COMPARE_WITH_TIMEOUT</a>() with a timeout of five seconds.</p> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p> </div> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#QTRY_COMPARE_WITH_TIMEOUT">QTRY_COMPARE_WITH_TIMEOUT</a>(), <a href="qtest.html#QCOMPARE">QCOMPARE</a>(), <a href="qtest.html#QVERIFY">QVERIFY</a>(), <a href="qtest.html#QTRY_VERIFY">QTRY_VERIFY</a>(), and <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>   <h3 class="fn" id="QTRY_COMPARE_WITH_TIMEOUT">
<code>[since 5.0] </code><span class="name">QTRY_COMPARE_WITH_TIMEOUT</span>(<i>actual</i>, <i>expected</i>, <i>timeout</i>)
</h3> <p>The QTRY_COMPARE_WITH_TIMEOUT() macro is similar to <a href="qtest.html#QCOMPARE">QCOMPARE</a>(), but performs the comparison of the <i>actual</i> and <i>expected</i> values repeatedly, until either the two values are equal or the <i>timeout</i> (in milliseconds) is reached. Between each comparison, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</p> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p> </div> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#QTRY_COMPARE">QTRY_COMPARE</a>(), <a href="qtest.html#QCOMPARE">QCOMPARE</a>(), <a href="qtest.html#QVERIFY">QVERIFY</a>(), <a href="qtest.html#QTRY_VERIFY">QTRY_VERIFY</a>(), and <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>   <h3 class="fn" id="QTRY_VERIFY2">
<code>[since 5.6] </code><span class="name">QTRY_VERIFY2</span>(<i>condition</i>, <i>message</i>)
</h3> <p>Checks the <i>condition</i> by invoking <a href="qtest.html#QTRY_VERIFY2_WITH_TIMEOUT">QTRY_VERIFY2_WITH_TIMEOUT</a>() with a timeout of five seconds. If <i>condition</i> is then still false, <i>message</i> is output. The <i>message</i> is a plain C string.</p> <p>Example:</p> <pre data-language="cpp">QTRY_VERIFY2_WITH_TIMEOUT(list.size() &gt; 2, QByteArray::number(list.size()).constData());</pre> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p> </div> <p>This function was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qtest.html#QTRY_VERIFY2_WITH_TIMEOUT">QTRY_VERIFY2_WITH_TIMEOUT</a>(), QTRY_VERIFY2(), <a href="qtest.html#QVERIFY">QVERIFY</a>(), <a href="qtest.html#QCOMPARE">QCOMPARE</a>(), <a href="qtest.html#QTRY_COMPARE">QTRY_COMPARE</a>(), and <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>   <h3 class="fn" id="QTRY_VERIFY">
<code>[since 5.0] </code><span class="name">QTRY_VERIFY</span>(<i>condition</i>)
</h3> <p>Checks the <i>condition</i> by invoking <a href="qtest.html#QTRY_VERIFY_WITH_TIMEOUT">QTRY_VERIFY_WITH_TIMEOUT</a>() with a timeout of five seconds.</p> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p> </div> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#QTRY_VERIFY_WITH_TIMEOUT">QTRY_VERIFY_WITH_TIMEOUT</a>(), <a href="qtest.html#QTRY_VERIFY2">QTRY_VERIFY2</a>(), <a href="qtest.html#QVERIFY">QVERIFY</a>(), <a href="qtest.html#QCOMPARE">QCOMPARE</a>(), <a href="qtest.html#QTRY_COMPARE">QTRY_COMPARE</a>(), and <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>   <h3 class="fn" id="QTRY_VERIFY2_WITH_TIMEOUT">
<code>[since 5.6] </code><span class="name">QTRY_VERIFY2_WITH_TIMEOUT</span>(<i>condition</i>, <i>message</i>, <i>timeout</i>)
</h3> <p>The QTRY_VERIFY2_WITH_TIMEOUT macro is similar to <a href="qtest.html#QTRY_VERIFY_WITH_TIMEOUT">QTRY_VERIFY_WITH_TIMEOUT</a>() except that it outputs a verbose <i>message</i> when <i>condition</i> is still false after the specified <i>timeout</i> (in milliseconds). The <i>message</i> is a plain C string.</p> <p>Example:</p> <pre data-language="cpp">QTRY_VERIFY2_WITH_TIMEOUT(list.size() &gt; 2, QByteArray::number(list.size()).constData(), 10000);</pre> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p> </div> <p>This function was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qtest.html#QTRY_VERIFY">QTRY_VERIFY</a>(), <a href="qtest.html#QTRY_VERIFY_WITH_TIMEOUT">QTRY_VERIFY_WITH_TIMEOUT</a>(), <a href="qtest.html#QVERIFY">QVERIFY</a>(), <a href="qtest.html#QCOMPARE">QCOMPARE</a>(), <a href="qtest.html#QTRY_COMPARE">QTRY_COMPARE</a>(), and <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>   <h3 class="fn" id="QTRY_VERIFY_WITH_TIMEOUT">
<code>[since 5.0] </code><span class="name">QTRY_VERIFY_WITH_TIMEOUT</span>(<i>condition</i>, <i>timeout</i>)
</h3> <p>The QTRY_VERIFY_WITH_TIMEOUT() macro is similar to <a href="qtest.html#QVERIFY">QVERIFY</a>(), but checks the <i>condition</i> repeatedly, until either the condition becomes true or the <i>timeout</i> (in milliseconds) is reached. Between each evaluation, events will be processed. If the timeout is reached, a failure is recorded in the test log and the test won't be executed further.</p> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p> </div> <p>This function was introduced in Qt 5.0.</p> <p><b>See also </b><a href="qtest.html#QTRY_VERIFY">QTRY_VERIFY</a>(), <a href="qtest.html#QTRY_VERIFY2_WITH_TIMEOUT">QTRY_VERIFY2_WITH_TIMEOUT</a>(), <a href="qtest.html#QVERIFY">QVERIFY</a>(), <a href="qtest.html#QCOMPARE">QCOMPARE</a>(), <a href="qtest.html#QTRY_COMPARE">QTRY_COMPARE</a>(), and <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>   <h3 class="fn" id="QVERIFY2">
<span class="name">QVERIFY2</span>(<i>condition</i>, <i>message</i>)
</h3> <p>The QVERIFY2() macro behaves exactly like <a href="qtest.html#QVERIFY">QVERIFY</a>(), except that it reports a <i>message</i> when <i>condition</i> is false. The <i>message</i> is a plain C string.</p> <p>The message can also be obtained from a function call that produces a plain C string, such as <a href="qtglobal.html#qPrintable">qPrintable</a>() applied to a <a href="qstring.html">QString</a>, which may be built in any of its usual ways, including applying <code>.args()</code> to format some data.</p> <p>Example:</p> <pre data-language="cpp">QVERIFY2(QFileInfo("file.txt").exists(), "file.txt does not exist.");</pre> <p>For example, if you have a file object and you are testing its <code>open()</code> function, you might write a test with a statement like:</p> <pre data-language="cpp">bool opened = file.open(QIODevice::WriteOnly);
QVERIFY(opened);</pre> <p>If this test fails, it will give no clue as to why the file failed to open:</p> <p><code>FAIL! : tst_QFile::open_write() 'opened' returned FALSE. ()</code></p> <p>If there is a more informative error message you could construct from the values being tested, you can use <code>QVERIFY2()</code> to pass that message along with your test condition, to provide a more informative message on failure:</p> <pre data-language="cpp">QVERIFY2(file.open(QIODevice::WriteOnly),
         qPrintable(QString("open %1: %2")
                    .arg(file.fileName()).arg(file.errorString())));</pre> <p>If this branch is being tested in the Qt CI system, the above detailed failure message will be inserted into the summary posted to the code-review system:</p> <p><code>FAIL! : tst_QFile::open_write() 'opened' returned FALSE. (open /tmp/qt.a3B42Cd: No space left on device)</code></p> <p><b>See also </b><a href="qtest.html#QVERIFY">QVERIFY</a>(), <a href="qtest.html#QCOMPARE">QCOMPARE</a>(), and <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>   <h3 class="fn" id="QVERIFY">
<span class="name">QVERIFY</span>(<i>condition</i>)
</h3> <p>The QVERIFY() macro checks whether the <i>condition</i> is true or not. If it is true, execution continues. If not, a failure is recorded in the test log and the test won't be executed further.</p> <p>You can use <a href="qtest.html#QVERIFY2">QVERIFY2</a>() when it is practical and valuable to put additional information into the test failure report.</p> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p> </div> <p>For example, the following code shows this macro being used to verify that a <a href="qsignalspy.html">QSignalSpy</a> object is valid:</p> <pre data-language="cpp">QVERIFY(spy.isValid());</pre> <p>For more information about the failure, use <code>QCOMPARE(x, y)</code> instead of <code>QVERIFY(x == y)</code>, because it reports both the expected and actual value when the comparison fails.</p> <p><b>See also </b><a href="qtest.html#QCOMPARE">QCOMPARE</a>(), <a href="qtest.html#QTRY_VERIFY">QTRY_VERIFY</a>(), <a href="qsignalspy.html">QSignalSpy</a>, and <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>   <h3 class="fn" id="QVERIFY_EXCEPTION_THROWN">
<code>[since 5.3] </code><span class="name">QVERIFY_EXCEPTION_THROWN</span>(<i>expression</i>, <i>exceptiontype</i>)
</h3> <p>The QVERIFY_EXCEPTION_THROWN macro executes <i>expression</i> and tries to catch an exception thrown from <i>expression</i>.</p> <p>There are several possible outcomes:</p> <ul> <li>If <i>expression</i> throws an exception that is either the same as <i>exceptiontype</i> or derived from <i>exceptiontype</i>, then execution will continue.</li> <li>Otherwise, if <i>expression</i> throws no exception, or the exception thrown derives from <code>std::exception</code>, then a failure will be recorded in the test log and the macro returns early (from enclosing function).</li> <li>If the thrown exception derives neither from <code>std::exception</code> nor from <i>exceptiontype</i>, a failure will be recorded in the test log, and the exception is re-thrown. This avoids problems with e.g. pthread cancellation exceptions.</li> </ul> <div class="admonition note"> <p><b>Note: </b>This macro can only be used in a test function that is invoked by the test framework.</p> </div> <p>This function was introduced in Qt 5.3.</p>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qtest.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qtest.html</a>
  </p>
</div>
