<h1 class="title">Shape QML Type</h1>  <p>Renders a path. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Import Statement:</td>
<td class="memItemRight bottomAlign"> import QtQuick.Shapes</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.10</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <p><a href="qml-qtquick-item.html">Item</a></p> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherited By:</td>
<td class="memItemRight bottomAlign"> <p><a href="qml-qtquick-particles-ellipseshape.html">EllipseShape</a>, <a href="qml-qtquick-particles-lineshape.html">LineShape</a>, and <a href="qml-qtquick-particles-maskshape.html">MaskShape</a></p> </td>
</tr>
</table>
<ul> <li><a href="https://doc.qt.io/qt-6.2/qml-qtquick-shapes-shape-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="properties">Properties
</h2> <ul> <li class="fn">
<b><a href="qml-qtquick-shapes-shape.html#asynchronous-prop">asynchronous</a></b> : bool</li> <li class="fn">
<b><a href="qml-qtquick-shapes-shape.html#containsMode-prop">containsMode</a></b> : enumeration</li> <li class="fn">
<b><a href="qml-qtquick-shapes-shape.html#data-prop">data</a></b> : list&lt;Object&gt;</li> <li class="fn">
<b><a href="qml-qtquick-shapes-shape.html#rendererType-prop">rendererType</a></b> : enumeration</li> <li class="fn">
<b><a href="qml-qtquick-shapes-shape.html#status-prop">status</a></b> : enumeration</li> <li class="fn">
<b><a href="qml-qtquick-shapes-shape.html#vendorExtensionsEnabled-prop">vendorExtensionsEnabled</a></b> : bool</li> </ul>  <h2 id="details">Detailed Description
</h2> <p>Renders a path either by generating geometry via <a href="qpainterpath.html">QPainterPath</a> and manual triangulation or by using a GPU vendor extension.</p> <p>This approach is different from rendering shapes via <a href="qquickpainteditem.html">QQuickPaintedItem</a> or the 2D Canvas because the path never gets rasterized in software. Therefore Shape is suitable for creating shapes spreading over larger areas of the screen, avoiding the performance penalty for texture uploads or framebuffer blits. In addition, the declarative API allows manipulating, binding to, and even animating the path element properties like starting and ending position, the control points, and so on.</p> <p>The types for specifying path elements are shared between <a href="qml-qtquick-pathview.html">PathView</a> and Shape. However, not all Shape implementations support all path element types, while some may not make sense for <a href="qml-qtquick-pathview.html">PathView</a>. Shape's currently supported subset is: <a href="qml-qtquick-pathmove.html">PathMove</a>, <a href="qml-qtquick-pathline.html">PathLine</a>, <a href="qml-qtquick-pathquad.html">PathQuad</a>, <a href="qml-qtquick-pathcubic.html">PathCubic</a>, <a href="qml-qtquick-patharc.html">PathArc</a>, and <a href="qml-qtquick-pathsvg.html">PathSvg</a>.</p> <p>See <a href="qml-qtquick-path.html">Path</a> for a detailed overview of the supported path elements.</p> <pre data-language="qml">Shape {
    width: 200
    height: 150
    anchors.centerIn: parent
    ShapePath {
        strokeWidth: 4
        strokeColor: "red"
        fillGradient: LinearGradient {
            x1: 20; y1: 20
            x2: 180; y2: 130
            GradientStop { position: 0; color: "blue" }
            GradientStop { position: 0.2; color: "green" }
            GradientStop { position: 0.4; color: "red" }
            GradientStop { position: 0.6; color: "yellow" }
            GradientStop { position: 1; color: "cyan" }
        }
        strokeStyle: ShapePath.DashLine
        dashPattern: [ 1, 4 ]
        startX: 20; startY: 20
        PathLine { x: 180; y: 130 }
        PathLine { x: 20; y: 130 }
        PathLine { x: 20; y: 20 }
    }
}</pre> <p class="centerAlign"><img alt="" src="data:image/png;base64,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"></p>
<p>Like <a href="qml-qtquick-item.html">Item</a>, Shape also allows any visual or non-visual objects to be declared as children. <a href="qml-qtquick-shapes-shapepath.html">ShapePath</a> objects are handled specially. This is useful since it allows adding visual items, like <a href="qml-qtquick-rectangle.html">Rectangle</a> or <a href="qml-qtquick-image.html">Image</a>, and non-visual objects, like <a href="qml-qtqml-timer.html">Timer</a> directly as children of Shape.</p> <p>The following list summarizes the available Shape rendering approaches:</p> <ul> <li>When running with the OpenGL backend of Qt Quick, only the generic, triangulation-based approach is available. When OpenGL is not used directly by the scene graph, for example because it is using the graphics abstraction layer (QRhi), only the generic shape renderer is available.</li> <li>The <code>software</code> backend is fully supported. The path is rendered via <a href="qpainter.html#strokePath">QPainter::strokePath</a>() and <a href="qpainter.html#fillPath">QPainter::fillPath</a>() in this case.</li> <li>The OpenVG backend is not currently supported.</li> </ul> <p>When using Shape, it is important to be aware of potential performance implications:</p> <ul> <li>When the application is running with the generic, triangulation-based Shape implementation, the geometry generation happens entirely on the CPU. This is potentially expensive. Changing the set of path elements, changing the properties of these elements, or changing certain properties of the Shape itself all lead to retriangulation of the affected paths on every change. Therefore, applying animation to such properties can affect performance on less powerful systems.</li> <li>However, the data-driven, declarative nature of the Shape API often means better cacheability for the underlying CPU and GPU resources. A property change in one <a href="qml-qtquick-shapes-shapepath.html">ShapePath</a> will only lead to reprocessing the affected <a href="qml-qtquick-shapes-shapepath.html">ShapePath</a>, leaving other parts of the Shape unchanged. Therefore, a frequently changing property can still result in a lower overall system load than with imperative painting approaches (for example, <a href="qpainter.html">QPainter</a>).</li> <li>At the same time, attention must be paid to the number of Shape elements in the scene. The way such a Shape item is represented in the scene graph is different from an ordinary geometry-based item, and incurs a certain cost when it comes to OpenGL state changes.</li> <li>As a general rule, scenes should avoid using separate Shape items when it is not absolutely necessary. Prefer using one Shape item with multiple <a href="qml-qtquick-shapes-shapepath.html">ShapePath</a> elements over multiple Shape items.</li> </ul> <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qtquick-shapes-example.html">Qt Quick Examples - Shapes</a>, <a href="qml-qtquick-path.html">Path</a>, <a href="qml-qtquick-pathmove.html">PathMove</a>, <a href="qml-qtquick-pathline.html">PathLine</a>, <a href="qml-qtquick-pathquad.html">PathQuad</a>, <a href="qml-qtquick-pathcubic.html">PathCubic</a>, <a href="qml-qtquick-patharc.html">PathArc</a>, and <a href="qml-qtquick-pathsvg.html">PathSvg</a>.</p>  <h2>Property Documentation</h2>  <h3 class="qmlproto" id="asynchronous-prop"><p> <span class="name">asynchronous</span> : <span class="type"><a href="qml-bool.html">bool</a></span></p></h3> <p>When <a href="qml-qtquick-shapes-shape.html#rendererType-prop">rendererType</a> is <code>Shape.GeometryRenderer</code>, the input path is triangulated on the CPU during the polishing phase of the Shape. This is potentially expensive. To offload this work to separate worker threads, set this property to <code>true</code>.</p> <p>When enabled, making a Shape visible will not wait for the content to become available. Instead, the GUI/main thread is not blocked and the results of the path rendering are shown only when all the asynchronous work has been finished.</p> <p>The default value is <code>false</code>.</p>    <h3 class="qmlproto" id="containsMode-prop"><p> <span class="qmlextra">[since QtQuick.Shapes 1.11] </span><span class="name">containsMode</span> : <span class="type"><a href="qml-enumeration.html">enumeration</a></span></p></h3> <p>This property determines the definition of <a href="qquickitem.html#contains">contains</a>() for the Shape. It is useful in case you add <a href="qtquickhandlers-index.html">Qt Quick Input Handlers</a> and you want to react only when the mouse or touchpoint is fully inside the Shape.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>Shape.BoundingRectContains</code></td>
<td class="topAlign">The default implementation of <a href="qquickitem.html#contains">QQuickItem::contains</a>() checks only whether the given point is inside the rectangular bounding box. This is the most efficient implementation, which is why it's the default.</td>
</tr> <tr>
<td class="topAlign"><code>Shape.FillContains</code></td>
<td class="topAlign">Check whether the interior (the part that would be filled if you are rendering it with fill) of any <a href="qml-qtquick-shapes-shapepath.html">ShapePath</a> that makes up this Shape contains the given point. The more complex and numerous ShapePaths you add, the less efficient this is to check, which can potentially slow down event delivery in your application. So it should be used with care.</td>
</tr> </table> <p>One way to speed up the <code>FillContains</code> check is to generate an approximate outline with as few points as possible, place that in a transparent Shape on top, and add your Pointer Handlers to that, so that the containment check is cheaper during event delivery.</p> <p>This property was introduced in QtQuick.Shapes 1.11.</p>    <h3 class="qmlproto" id="data-prop"><p> <span class="qmlextra">[default] </span><span class="name">data</span> : <span class="type"><a href="qml-list.html">list</a></span>&lt;<span class="type">Object</span>&gt;</p></h3> <p>This property holds the <a href="qml-qtquick-shapes-shapepath.html">ShapePath</a> objects that define the contents of the Shape. It can also contain any other type of objects, since Shape, like Item, allows adding any visual or non-visual objects as children.</p>    <h3 class="qmlproto" id="rendererType-prop"><p> <span class="name">rendererType</span> : <span class="type"><a href="qml-enumeration.html">enumeration</a></span></p></h3> <p>This property determines which path rendering backend is active.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>Shape.UnknownRenderer</code></td>
<td class="topAlign">The renderer is unknown.</td>
</tr> <tr>
<td class="topAlign"><code>Shape.GeometryRenderer</code></td>
<td class="topAlign">The generic, driver independent solution for OpenGL. Uses the same CPU-based triangulation approach as <a href="qpainter.html">QPainter</a>'s OpenGL 2 paint engine. This is the default when the OpenGL Qt Quick scenegraph backend is in use.</td>
</tr> <tr>
<td class="topAlign"><code>Shape.SoftwareRenderer</code></td>
<td class="topAlign">Pure <a href="qpainter.html">QPainter</a> drawing using the raster paint engine. This is the default, and only, option when the Qt Quick scenegraph is running with the <code>software</code> backend.</td>
</tr> </table>    <h3 class="qmlproto" id="status-prop"><p> <span class="name">status</span> : <span class="type"><a href="qml-enumeration.html">enumeration</a></span></p></h3> <p>This property determines the status of the Shape and is relevant when Shape.asynchronous is set to <code>true</code>.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>Shape.Null</code></td>
<td class="topAlign">Not yet initialized.</td>
</tr> <tr>
<td class="topAlign"><code>Shape.Ready</code></td>
<td class="topAlign">The Shape has finished processing.</td>
</tr> <tr>
<td class="topAlign"><code>Shape.Processing</code></td>
<td class="topAlign">The path is being processed.</td>
</tr> </table>    <h3 class="qmlproto" id="vendorExtensionsEnabled-prop"><p> <span class="name">vendorExtensionsEnabled</span> : <span class="type"><a href="qml-bool.html">bool</a></span></p></h3> <p>This property controls the usage of non-standard OpenGL extensions.</p> <p>The default value is <code>false</code>.</p> <p>As of Qt 6.0 there are no vendor-specific rendering paths implemented.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qml-qtquick-shapes-shape.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qml-qtquick-shapes-shape.html</a>
  </p>
</div>
