<h1 class="title">QPixelFormat Class</h1>  <p>QPixelFormat is a class for describing different pixel layouts in graphics buffers. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QPixelFormat&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Gui REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Gui)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += gui</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.4</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qpixelformat-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#AlphaPosition-enum">AlphaPosition</a></b> { AtBeginning, AtEnd }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#AlphaPremultiplied-enum">AlphaPremultiplied</a></b> { NotPremultiplied, Premultiplied }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#AlphaUsage-enum">AlphaUsage</a></b> { IgnoresAlpha, UsesAlpha }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#ByteOrder-enum">ByteOrder</a></b> { LittleEndian, BigEndian, CurrentSystemEndian }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#ColorModel-enum">ColorModel</a></b> { RGB, BGR, Indexed, Grayscale, CMYK, …, Alpha }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#TypeInterpretation-enum">TypeInterpretation</a></b> { UnsignedInteger, UnsignedShort, UnsignedByte, FloatingPoint }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#YUVLayout-enum">YUVLayout</a></b> { YUV444, YUV422, YUV411, YUV420P, YUV420SP, …, Y16 }</td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#QPixelFormat-1">QPixelFormat</a></b>(QPixelFormat::ColorModel <i>colorModel</i>, uchar <i>firstSize</i>, uchar <i>secondSize</i>, uchar <i>thirdSize</i>, uchar <i>fourthSize</i>, uchar <i>fifthSize</i>, uchar <i>alphaSize</i>, QPixelFormat::AlphaUsage <i>alphaUsage</i>, QPixelFormat::AlphaPosition <i>alphaPosition</i>, QPixelFormat::AlphaPremultiplied <i>premultiplied</i>, QPixelFormat::TypeInterpretation <i>typeInterpretation</i>, QPixelFormat::ByteOrder <i>byteOrder</i> = CurrentSystemEndian, uchar <i>subEnum</i> = 0)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#QPixelFormat">QPixelFormat</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat::AlphaPosition </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#alphaPosition">alphaPosition</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#alphaSize">alphaSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat::AlphaUsage </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#alphaUsage">alphaUsage</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#bitsPerPixel">bitsPerPixel</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#blackSize">blackSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#blueSize">blueSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#brightnessSize">brightnessSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat::ByteOrder </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#byteOrder">byteOrder</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#channelCount">channelCount</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat::ColorModel </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#colorModel">colorModel</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#cyanSize">cyanSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#greenSize">greenSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#hueSize">hueSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#lightnessSize">lightnessSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#magentaSize">magentaSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat::AlphaPremultiplied </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#premultiplied">premultiplied</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#redSize">redSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#saturationSize">saturationSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat::TypeInterpretation </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#typeInterpretation">typeInterpretation</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#yellowSize">yellowSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat::YUVLayout </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#yuvLayout">yuvLayout</a></b>() const</td>
</tr> </table> <h2 id="related-non-members">Related Non-Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#qPixelFormatAlpha">qPixelFormatAlpha</a></b>(uchar <i>channelSize</i>, QPixelFormat::TypeInterpretation <i>typeInterpretation</i> = QPixelFormat::UnsignedInteger)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#qPixelFormatCmyk">qPixelFormatCmyk</a></b>(uchar <i>channelSize</i>, uchar <i>alphaSize</i> = 0, QPixelFormat::AlphaUsage <i>alphaUsage</i> = QPixelFormat::IgnoresAlpha, QPixelFormat::AlphaPosition <i>alphaPosition</i> = QPixelFormat::AtBeginning, QPixelFormat::TypeInterpretation <i>typeInterpretation</i> = QPixelFormat::UnsignedInteger)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#qPixelFormatGrayscale">qPixelFormatGrayscale</a></b>(uchar <i>channelSize</i>, QPixelFormat::TypeInterpretation <i>typeInterpretation</i> = QPixelFormat::UnsignedInteger)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#qPixelFormatHsl">qPixelFormatHsl</a></b>(uchar <i>channelSize</i>, uchar <i>alphaSize</i> = 0, QPixelFormat::AlphaUsage <i>alphaUsage</i> = QPixelFormat::IgnoresAlpha, QPixelFormat::AlphaPosition <i>alphaPosition</i> = QPixelFormat::AtBeginning, QPixelFormat::TypeInterpretation <i>typeInterpretation</i> = QPixelFormat::FloatingPoint)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#qPixelFormatHsv">qPixelFormatHsv</a></b>(uchar <i>channelSize</i>, uchar <i>alphaSize</i> = 0, QPixelFormat::AlphaUsage <i>alphaUsage</i> = QPixelFormat::IgnoresAlpha, QPixelFormat::AlphaPosition <i>alphaPosition</i> = QPixelFormat::AtBeginning, QPixelFormat::TypeInterpretation <i>typeInterpretation</i> = QPixelFormat::FloatingPoint)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#qPixelFormatRgba">qPixelFormatRgba</a></b>(uchar <i>redSize</i>, uchar <i>greenSize</i>, uchar <i>blueSize</i>, uchar <i>alphaSize</i>, QPixelFormat::AlphaUsage <i>alphaUsage</i>, QPixelFormat::AlphaPosition <i>alphaPosition</i>, QPixelFormat::AlphaPremultiplied <i>premultiplied</i> = QPixelFormat::NotPremultiplied, QPixelFormat::TypeInterpretation <i>typeInterpretation</i> = QPixelFormat::UnsignedInteger)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qpixelformat.html#qPixelFormatYuv">qPixelFormatYuv</a></b>(QPixelFormat::YUVLayout <i>yuvLayout</i>, uchar <i>alphaSize</i> = 0, QPixelFormat::AlphaUsage <i>alphaUsage</i> = QPixelFormat::IgnoresAlpha, QPixelFormat::AlphaPosition <i>alphaPosition</i> = QPixelFormat::AtBeginning, QPixelFormat::AlphaPremultiplied <i>premultiplied</i> = QPixelFormat::NotPremultiplied, QPixelFormat::TypeInterpretation <i>typeInterpretation</i> = QPixelFormat::UnsignedByte, QPixelFormat::ByteOrder <i>byteOrder</i> = QPixelFormat::LittleEndian)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>In Qt there is a often a need to represent the layout of the pixels in a graphics buffer. Internally QPixelFormat stores everything in a 64 bit datastructure. This gives performance but also some limitations.</p> <p>QPixelFormat can describe 5 color channels and 1 alpha channel, each can use 6 bits to describe the size of the color channel.</p> <p>The position of the alpha channel is described with a separate enum. This is to make it possible to describe <a href="qimage.html">QImage</a> formats like ARGB32, and also describe typical OpenGL formats like RBGA8888.</p> <p>How pixels are suppose to be read is determined by the <a href="qpixelformat.html#TypeInterpretation-enum">TypeInterpretation</a> enum. It describes if color values are suppose to be read byte per byte, or if a pixel is suppose to be read as a complete int and then masked.</p> <p>There is no support for describing YUV's macro pixels. Instead a list of YUV formats has been made. When a QPixelFormat is describing a YUV format, the <a href="qpixelformat.html#bitsPerPixel">bitsPerPixel</a> value has been deduced by the YUV Layout enum. Also, the color channels should all be set to zero except the fifth color channel that should store the <a href="qpixelformat.html#bitsPerPixel">bitsPerPixel</a> value.</p>  <p><b>See also </b><a href="qpixelformat.html#TypeInterpretation-enum">TypeInterpretation</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="AlphaPosition-enum">enum QPixelFormat::<span class="name">AlphaPosition</span>
</h3> <p>This enum type is used to describe the alpha channels position relative to the color channels.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::AtBeginning</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The alpha channel will be put in front of the color channels . E.g. ARGB.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::AtEnd</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The alpha channel will be put in the back of the color channels. E.g. RGBA.</td>
</tr> </table>   <h3 class="fn" id="AlphaPremultiplied-enum">enum QPixelFormat::<span class="name">AlphaPremultiplied</span>
</h3> <p>This enum type describes the boolean state if the alpha channel is multiplied into the color channels or not.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::NotPremultiplied</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The alpha channel is not multiplied into the color channels.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::Premultiplied</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The alpha channel is multiplied into the color channels.</td>
</tr> </table>   <h3 class="fn" id="AlphaUsage-enum">enum QPixelFormat::<span class="name">AlphaUsage</span>
</h3> <p>This enum describes if the alpha channel is used or not. Sometimes the pixelformat will have a size for the alpha channel, but the pixel format does actually not use the alpha channel. For example RGB32 is such a format. The RGB channels are 8 bits each, and there is no alpha channel. But the complete size for each pixel is 32. Therefore the alpha channel size is 8, but the alpha channel is ignored. Its important to note that in such situations the position of the alpha channel is significant.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::IgnoresAlpha</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The alpha channel is not used.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::UsesAlpha</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The alpha channel is used.</td>
</tr> </table>   <h3 class="fn" id="ByteOrder-enum">enum QPixelFormat::<span class="name">ByteOrder</span>
</h3> <p>This enum describes the ByteOrder of the pixel format. This enum is mostly ignored but have some use cases for YUV formats. BGR formats have their own color model, and should not be described by using the opposite endianness on an RGB format.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::LittleEndian</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The byte order is little endian.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::BigEndian</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The byte order is big endian.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::CurrentSystemEndian</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">This enum will not be stored, but is converted in the constructor to the endian enum that matches the enum of the current system.</td>
</tr> </table>   <h3 class="fn" id="ColorModel-enum">enum QPixelFormat::<span class="name">ColorModel</span>
</h3> <p>This enum type is used to describe the color model of the pixelformat. Alpha was added in 5.5.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::RGB</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The color model is RGB.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::BGR</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">This is logically the opposite endian version of RGB. However, for ease of use it has its own model.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::Indexed</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">The color model uses a color palette.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::Grayscale</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">The color model is Grayscale.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::CMYK</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">The color model is CMYK.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::HSL</code></td>
<td class="topAlign tblval"><code>5</code></td>
<td class="topAlign">The color model is HSL.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::HSV</code></td>
<td class="topAlign tblval"><code>6</code></td>
<td class="topAlign">The color model is HSV.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::YUV</code></td>
<td class="topAlign tblval"><code>7</code></td>
<td class="topAlign">The color model is YUV.</td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::Alpha</code></td>
<td class="topAlign tblval"><code>8</code></td>
<td class="topAlign">There is no color model, only alpha is used.</td>
</tr> </table>   <h3 class="fn" id="TypeInterpretation-enum">enum QPixelFormat::<span class="name">TypeInterpretation</span>
</h3> <p>This enum describes how each pixel is interpreted. If a pixel is read as a full 32 bit unsigned integer and then each channel is masked out, or if each byte is read as unsigned char values. Typically <a href="qimage.html">QImage</a> formats interpret one pixel as an unsigned integer and then the color channels are masked out. OpenGL on the other hand typically interpreted pixels "one byte after the other", Ie. unsigned byte.</p> <p><a href="qimage.html">QImage</a> also have the format Format_RGBA8888 (and its derivatives), where the pixels are interpreted as unsigned bytes. OpenGL has extensions that makes it possible to upload pixel buffers in an unsigned integer format.</p> <p class="centerAlign"><img alt="An unsigned integer ARGB32 pixel." src="data:image/png;base64,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"></p>
<p>The image above shows a ARGB pixel in memory read as an unsigned integer. However, if this pixel was read byte for byte on a little endian system the first byte would be the byte containing the B-channel. The next byte would be the G-channel, then the R-channel and finally the A-channel. This shows that on little endian systems, how each pixel is interpreted is significant for integer formats. This is not the case on big endian systems.</p> <table class="valuelist">
<tr>
<th class="tblConst">Constant</th>
<th class="tblVal">Value</th>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::UnsignedInteger</code></td>
<td class="topAlign tblval"><code>0</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::UnsignedShort</code></td>
<td class="topAlign tblval"><code>1</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::UnsignedByte</code></td>
<td class="topAlign tblval"><code>2</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::FloatingPoint</code></td>
<td class="topAlign tblval"><code>3</code></td>
</tr> </table>   <h3 class="fn" id="YUVLayout-enum">enum QPixelFormat::<span class="name">YUVLayout</span>
</h3> <p>YUV is not represented by describing the size of the color channels. This is because YUV often use macro pixels, making the concept of separate color channels invalid. Instead the different YUV layouts are described with this enum.</p> <table class="valuelist">
<tr>
<th class="tblConst">Constant</th>
<th class="tblVal">Value</th>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::YUV444</code></td>
<td class="topAlign tblval"><code>0</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::YUV422</code></td>
<td class="topAlign tblval"><code>1</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::YUV411</code></td>
<td class="topAlign tblval"><code>2</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::YUV420P</code></td>
<td class="topAlign tblval"><code>3</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::YUV420SP</code></td>
<td class="topAlign tblval"><code>4</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::YV12</code></td>
<td class="topAlign tblval"><code>5</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::UYVY</code></td>
<td class="topAlign tblval"><code>6</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::YUYV</code></td>
<td class="topAlign tblval"><code>7</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::NV12</code></td>
<td class="topAlign tblval"><code>8</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::NV21</code></td>
<td class="topAlign tblval"><code>9</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::IMC1</code></td>
<td class="topAlign tblval"><code>10</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::IMC2</code></td>
<td class="topAlign tblval"><code>11</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::IMC3</code></td>
<td class="topAlign tblval"><code>12</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::IMC4</code></td>
<td class="topAlign tblval"><code>13</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::Y8</code></td>
<td class="topAlign tblval"><code>14</code></td>
</tr> <tr>
<td class="topAlign"><code>QPixelFormat::Y16</code></td>
<td class="topAlign tblval"><code>15</code></td>
</tr> </table>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QPixelFormat-1">QPixelFormat::<span class="name">QPixelFormat</span>(<span class="type"><a href="qpixelformat.html#ColorModel-enum">QPixelFormat::ColorModel</a></span> <i>colorModel</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>firstSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>secondSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>thirdSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>fourthSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>fifthSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>alphaSize</i>, <span class="type"><a href="qpixelformat.html#AlphaUsage-enum">QPixelFormat::AlphaUsage</a></span> <i>alphaUsage</i>, <span class="type"><a href="qpixelformat.html#AlphaPosition-enum">QPixelFormat::AlphaPosition</a></span> <i>alphaPosition</i>, <span class="type"><a href="qpixelformat.html#AlphaPremultiplied-enum">QPixelFormat::AlphaPremultiplied</a></span> <i>premultiplied</i>, <span class="type"><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a></span> <i>typeInterpretation</i>, <span class="type"><a href="qpixelformat.html#ByteOrder-enum">QPixelFormat::ByteOrder</a></span> <i>byteOrder</i> = CurrentSystemEndian, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>subEnum</i> = 0)
</h3> <p>Creates a QPixelFormat which assigns its data to the attributes. <i>colorModel</i> will be put into a buffer which is 4 bits long.</p> <p><i>firstSize</i> <i>secondSize</i> <i>thirdSize</i> <i>fourthSize</i> <i>fifthSize</i> <i>alphaSize</i> are all meant to represent the size of a channel. The channels will be used for different uses dependent on the <i>colorModel</i>. For RGB the firstSize will represent the Red channel. On CMYK it will represent the value of the Cyan channel.</p> <p><i>alphaUsage</i> represents if the alpha channel is used or not.</p> <p><i>alphaPosition</i> is the position of the alpha channel.</p> <p><i>premultiplied</i> represents if the alpha channel is already multiplied with the color channels.</p> <p><i>typeInterpretation</i> is how the pixel is interpreted.</p> <p><i>byteOrder</i> represents the endianness of the pixelformat. This defaults to <a href="qpixelformat.html#ByteOrder-enum">CurrentSystemEndian</a>.</p> <p><i>subEnum</i> is used for colorModels that have to store some extra information with supplying an extra enum. This is used by YUV to store the YUV type The default value is 0.</p>   <h3 class="fn" id="QPixelFormat">QPixelFormat::<span class="name">QPixelFormat</span>()
</h3> <p>Creates a null pixelformat. This format maps to <a href="qimage.html#Format-enum">QImage::Format_Invalid</a>.</p>   <h3 class="fn" id="alphaPosition">
<span class="type"><a href="qpixelformat.html#AlphaPosition-enum">QPixelFormat::AlphaPosition</a></span> QPixelFormat::<span class="name">alphaPosition</span>() const
</h3> <p>Accessor function for alphaPosition.</p>   <h3 class="fn" id="alphaSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">alphaSize</span>() const
</h3> <p>Accessor function for the alpha channel size.</p>   <h3 class="fn" id="alphaUsage">
<span class="type"><a href="qpixelformat.html#AlphaUsage-enum">QPixelFormat::AlphaUsage</a></span> QPixelFormat::<span class="name">alphaUsage</span>() const
</h3> <p>Accessor function for alphaUsage.</p>   <h3 class="fn" id="bitsPerPixel">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">bitsPerPixel</span>() const
</h3> <p>Accessor function for the bits used per pixel. This function returns the sum of the color channels + the size of the alpha channel.</p>   <h3 class="fn" id="blackSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">blackSize</span>() const
</h3> <p>Accessor function for the black/key color channel.</p>   <h3 class="fn" id="blueSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">blueSize</span>() const
</h3> <p>Accessor function for the size of the blue color channel.</p>   <h3 class="fn" id="brightnessSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">brightnessSize</span>() const
</h3> <p>Accessor function for the brightness channel size.</p>   <h3 class="fn" id="byteOrder">
<span class="type"><a href="qpixelformat.html#ByteOrder-enum">QPixelFormat::ByteOrder</a></span> QPixelFormat::<span class="name">byteOrder</span>() const
</h3> <p>The byte order is almost always set the byte order of the current system. However, it can be useful to describe some YUV formats. This function should never return <a href="qpixelformat.html#ByteOrder-enum">QPixelFormat::CurrentSystemEndian</a> as this value is translated to a endian value in the constructor.</p>   <h3 class="fn" id="channelCount">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">channelCount</span>() const
</h3> <p>Accessor function for getting the channelCount. Channel Count is deduced by color channels with a size &gt; 0 and if the size of the alpha channel is &gt; 0.</p>   <h3 class="fn" id="colorModel">
<span class="type"><a href="qpixelformat.html#ColorModel-enum">QPixelFormat::ColorModel</a></span> QPixelFormat::<span class="name">colorModel</span>() const
</h3> <p>Accessor function for getting the colorModel.</p>   <h3 class="fn" id="cyanSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">cyanSize</span>() const
</h3> <p>Accessor function for the cyan color channel.</p>   <h3 class="fn" id="greenSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">greenSize</span>() const
</h3> <p>Accessor function for the size of the green color channel.</p>   <h3 class="fn" id="hueSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">hueSize</span>() const
</h3> <p>Accessor function for the hue channel size.</p>   <h3 class="fn" id="lightnessSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">lightnessSize</span>() const
</h3> <p>Accessor function for the lightness channel size.</p>   <h3 class="fn" id="magentaSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">magentaSize</span>() const
</h3> <p>Accessor function for the megenta color channel.</p>   <h3 class="fn" id="premultiplied">
<span class="type"><a href="qpixelformat.html#AlphaPremultiplied-enum">QPixelFormat::AlphaPremultiplied</a></span> QPixelFormat::<span class="name">premultiplied</span>() const
</h3> <p>Accessor function for the <a href="qpixelformat.html#AlphaPremultiplied-enum">AlphaPremultiplied</a> enum. This indicates if the alpha channel is multiplied in to the color channels.</p>   <h3 class="fn" id="redSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">redSize</span>() const
</h3> <p>Accessor function for the size of the red color channel.</p>   <h3 class="fn" id="saturationSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">saturationSize</span>() const
</h3> <p>Accessor function for the saturation channel size.</p>   <h3 class="fn" id="typeInterpretation">
<span class="type"><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a></span> QPixelFormat::<span class="name">typeInterpretation</span>() const
</h3> <p>Accessor function for the type representation of a color channel or a pixel.</p> <p><b>See also </b><a href="qpixelformat.html#TypeInterpretation-enum">TypeInterpretation</a>.</p>   <h3 class="fn" id="yellowSize">
<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> QPixelFormat::<span class="name">yellowSize</span>() const
</h3> <p>Accessor function for the yellow color channel.</p>   <h3 class="fn" id="yuvLayout">
<span class="type"><a href="qpixelformat.html#YUVLayout-enum">QPixelFormat::YUVLayout</a></span> QPixelFormat::<span class="name">yuvLayout</span>() const
</h3> <p>Accessor function for the <a href="qpixelformat.html#YUVLayout-enum">YUVLayout</a>. It is difficult to describe the color channels of a YUV pixel format since YUV color model uses macro pixels. Instead the layout of the pixels are stored as an enum.</p>   <div class="relnonmem"> <h2>Related Non-Members</h2>  <h3 class="fn" id="qPixelFormatAlpha">
<code>[since 5.5] </code><span class="type"><a href="qpixelformat.html#QPixelFormat">QPixelFormat</a></span> <span class="name">qPixelFormatAlpha</span>(<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>channelSize</i>, <span class="type"><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a></span> <i>typeInterpretation</i> = QPixelFormat::UnsignedInteger)
</h3> <p>Constructor function for creating an Alpha format. A mask format can be described by passing 1 to <i>channelSize</i>. Its also possible to define very accurate alpha formats using doubles to describe each pixel by passing 8 as <i>channelSize</i> and <a href="qpixelformat.html#TypeInterpretation-enum">FloatingPoint</a> as <i>typeInterpretation</i>.</p> <p>This function was introduced in Qt 5.5.</p> <p><b>See also </b><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a>.</p>   <h3 class="fn" id="qPixelFormatCmyk">
<span class="type"><a href="qpixelformat.html#QPixelFormat">QPixelFormat</a></span> <span class="name">qPixelFormatCmyk</span>(<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>channelSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>alphaSize</i> = 0, <span class="type"><a href="qpixelformat.html#AlphaUsage-enum">QPixelFormat::AlphaUsage</a></span> <i>alphaUsage</i> = QPixelFormat::IgnoresAlpha, <span class="type"><a href="qpixelformat.html#AlphaPosition-enum">QPixelFormat::AlphaPosition</a></span> <i>alphaPosition</i> = QPixelFormat::AtBeginning, <span class="type"><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a></span> <i>typeInterpretation</i> = QPixelFormat::UnsignedInteger)
</h3> <p>Constructor function for creating CMYK formats. The channel count will be 4 or 5 depending on if <i>alphaSize</i> is bigger than zero or not. The CMYK color channels will all be set to the value of <i>channelSize</i>.</p> <p><i>alphaUsage</i> <i>alphaPosition</i> and <i>typeInterpretation</i> are all accessible with the accessors with the same name.</p> <p><b>See also </b><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a>.</p>   <h3 class="fn" id="qPixelFormatGrayscale">
<span class="type"><a href="qpixelformat.html#QPixelFormat">QPixelFormat</a></span> <span class="name">qPixelFormatGrayscale</span>(<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>channelSize</i>, <span class="type"><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a></span> <i>typeInterpretation</i> = QPixelFormat::UnsignedInteger)
</h3> <p>Constructor function for creating a Grayscale format. Monochrome formats can be described by passing 1 to <i>channelSize</i>. Its also possible to define very accurate grayscale formats using doubles to describe each pixel by passing 8 as <i>channelSize</i> and <a href="qpixelformat.html#TypeInterpretation-enum">FloatingPoint</a> as <i>typeInterpretation</i>.</p> <p><b>See also </b><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a>.</p>   <h3 class="fn" id="qPixelFormatHsl">
<span class="type"><a href="qpixelformat.html#QPixelFormat">QPixelFormat</a></span> <span class="name">qPixelFormatHsl</span>(<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>channelSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>alphaSize</i> = 0, <span class="type"><a href="qpixelformat.html#AlphaUsage-enum">QPixelFormat::AlphaUsage</a></span> <i>alphaUsage</i> = QPixelFormat::IgnoresAlpha, <span class="type"><a href="qpixelformat.html#AlphaPosition-enum">QPixelFormat::AlphaPosition</a></span> <i>alphaPosition</i> = QPixelFormat::AtBeginning, <span class="type"><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a></span> <i>typeInterpretation</i> = QPixelFormat::FloatingPoint)
</h3> <p>Constructor function for creating HSL formats. The channel count will be 3 or 4 depending on if <i>alphaSize</i> is bigger than 0.</p> <p><i>channelSize</i> will set the <a href="qpixelformat.html#hueSize">hueSize</a> <a href="qpixelformat.html#saturationSize">saturationSize</a> and <a href="qpixelformat.html#lightnessSize">lightnessSize</a> to the same value.</p> <p><i>alphaUsage</i> <i>alphaPosition</i> and <i>typeInterpretation</i> are all accessible with the accessors with the same name.</p>   <h3 class="fn" id="qPixelFormatHsv">
<span class="type"><a href="qpixelformat.html#QPixelFormat">QPixelFormat</a></span> <span class="name">qPixelFormatHsv</span>(<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>channelSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>alphaSize</i> = 0, <span class="type"><a href="qpixelformat.html#AlphaUsage-enum">QPixelFormat::AlphaUsage</a></span> <i>alphaUsage</i> = QPixelFormat::IgnoresAlpha, <span class="type"><a href="qpixelformat.html#AlphaPosition-enum">QPixelFormat::AlphaPosition</a></span> <i>alphaPosition</i> = QPixelFormat::AtBeginning, <span class="type"><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a></span> <i>typeInterpretation</i> = QPixelFormat::FloatingPoint)
</h3> <p>Constructor function for creating HSV formats. The channel count will be 3 or 4 depending on if <i>alphaSize</i> is bigger than 0.</p> <p><i>channelSize</i> will set the <a href="qpixelformat.html#hueSize">hueSize</a> <a href="qpixelformat.html#saturationSize">saturationSize</a> and <a href="qpixelformat.html#brightnessSize">brightnessSize</a> to the same value.</p> <p><i>alphaUsage</i> <i>alphaPosition</i> and <i>typeInterpretation</i> are all accessible with the accessors with the same name.</p>   <h3 class="fn" id="qPixelFormatRgba">
<span class="type"><a href="qpixelformat.html#QPixelFormat">QPixelFormat</a></span> <span class="name">qPixelFormatRgba</span>(<span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>redSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>greenSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>blueSize</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>alphaSize</i>, <span class="type"><a href="qpixelformat.html#AlphaUsage-enum">QPixelFormat::AlphaUsage</a></span> <i>alphaUsage</i>, <span class="type"><a href="qpixelformat.html#AlphaPosition-enum">QPixelFormat::AlphaPosition</a></span> <i>alphaPosition</i>, <span class="type"><a href="qpixelformat.html#AlphaPremultiplied-enum">QPixelFormat::AlphaPremultiplied</a></span> <i>premultiplied</i> = QPixelFormat::NotPremultiplied, <span class="type"><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a></span> <i>typeInterpretation</i> = QPixelFormat::UnsignedInteger)
</h3> <p>Constructor function making an RGB pixelformat. <i>redSize</i> <i>greenSize</i> <i>blueSize</i> represent the size of each color channel. <i>alphaSize</i> describes the alpha channel size and its position is described with <i>alphaPosition</i>. <i>alphaUsage</i> is used to determine if the alpha channel is used or not. Setting the alpha channel size to 8 and <a href="qpixelformat.html#alphaUsage">alphaUsage</a> to <a href="qpixelformat.html#AlphaUsage-enum">IgnoresAlpha</a> is how it is possible to create a 32 bit format where the rgb channels only use 24 bits combined. <i>premultiplied</i> <i>typeInterpretation</i> are accessible with accessors with the same name.</p> <p><b>See also </b><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a>.</p>   <h3 class="fn" id="qPixelFormatYuv">
<span class="type"><a href="qpixelformat.html#QPixelFormat">QPixelFormat</a></span> <span class="name">qPixelFormatYuv</span>(<span class="type"><a href="qpixelformat.html#YUVLayout-enum">QPixelFormat::YUVLayout</a></span> <i>yuvLayout</i>, <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <i>alphaSize</i> = 0, <span class="type"><a href="qpixelformat.html#AlphaUsage-enum">QPixelFormat::AlphaUsage</a></span> <i>alphaUsage</i> = QPixelFormat::IgnoresAlpha, <span class="type"><a href="qpixelformat.html#AlphaPosition-enum">QPixelFormat::AlphaPosition</a></span> <i>alphaPosition</i> = QPixelFormat::AtBeginning, <span class="type"><a href="qpixelformat.html#AlphaPremultiplied-enum">QPixelFormat::AlphaPremultiplied</a></span> <i>premultiplied</i> = QPixelFormat::NotPremultiplied, <span class="type"><a href="qpixelformat.html#TypeInterpretation-enum">QPixelFormat::TypeInterpretation</a></span> <i>typeInterpretation</i> = QPixelFormat::UnsignedByte, <span class="type"><a href="qpixelformat.html#ByteOrder-enum">QPixelFormat::ByteOrder</a></span> <i>byteOrder</i> = QPixelFormat::LittleEndian)
</h3> <p>Constructor function for creating a <a href="qpixelformat.html">QPixelFormat</a> describing a YUV format with <i>yuvLayout</i>. <i>alphaSize</i> describes the size of a potential alpha channel and is position is described with <i>alphaPosition</i>. The "first" "second" .. "fifth" channels are all set to 0. <i>alphaUsage</i> <i>premultiplied</i> <i>typeInterpretation</i> and <i>byteOrder</i> will work as with other formats.</p>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qpixelformat.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qpixelformat.html</a>
  </p>
</div>
