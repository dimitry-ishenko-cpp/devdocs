<h1 class="title">QSharedDataPointer Class</h1> <span class="small-subtitle">template &lt;typename T&gt; class QSharedDataPointer</span>  <p>The QSharedDataPointer class represents a pointer to an implicitly shared object. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QSharedDataPointer&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qshareddatapointer-members.html">List of all members, including inherited members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="17-qdoc-commands-thread.html#reentrant">reentrant</a>.</p> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qshareddatapointer.html#Type-typedef">Type</a></b></td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#QSharedDataPointer-4">QSharedDataPointer</a></b>(QSharedDataPointer&lt;T&gt; &amp;&amp;<i>o</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#QSharedDataPointer-3">QSharedDataPointer</a></b>(const QSharedDataPointer&lt;T&gt; &amp;<i>o</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#QSharedDataPointer-2">QSharedDataPointer</a></b>(T *<i>data</i>, QAdoptSharedDataTag)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#QSharedDataPointer-1">QSharedDataPointer</a></b>(T *<i>data</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSharedDataPointer&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-eq-2">operator=</a></b>(QSharedDataPointer&lt;T&gt; &amp;&amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSharedDataPointer&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-eq">operator=</a></b>(const QSharedDataPointer&lt;T&gt; &amp;<i>o</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#dtor.QSharedDataPointer">~QSharedDataPointer</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#constData">constData</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#data">data</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#data-1">data</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#detach">detach</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#get">get</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#get-1">get</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#reset">reset</a></b>(T *<i>ptr</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#swap">swap</a></b>(QSharedDataPointer&lt;T&gt; &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#take">take</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-T--2a">operator T *</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-const-T--2a">operator const T *</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-not">operator!</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-2a">operator*</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const T &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-2a-1">operator*</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator--gt">operator-&gt;</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator--gt-1">operator-&gt;</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSharedDataPointer&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-eq-1">operator=</a></b>(T *<i>o</i>)</td>
</tr> </table> <h2 id="protected-functions">Protected Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> T *</td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#clone">clone</a></b>()</td>
</tr> </table> <h2 id="related-non-members">Related Non-Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-not-eq">operator!=</a></b>(const QSharedDataPointer&lt;T&gt; &amp;<i>lhs</i>, const QSharedDataPointer&lt;T&gt; &amp;<i>rhs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-not-eq-2">operator!=</a></b>(const T *<i>ptr</i>, const QSharedDataPointer&lt;T&gt; &amp;<i>rhs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-eq-eq">operator==</a></b>(const QSharedDataPointer&lt;T&gt; &amp;<i>lhs</i>, const QSharedDataPointer&lt;T&gt; &amp;<i>rhs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qshareddatapointer.html#operator-eq-eq-2">operator==</a></b>(const T *<i>ptr</i>, const QSharedDataPointer&lt;T&gt; &amp;<i>rhs</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>QSharedDataPointer&lt;T&gt; makes writing your own <a href="implicit-sharing.html">implicitly shared</a> classes easy. QSharedDataPointer implements <a href="threads-reentrancy.html">thread-safe</a> reference counting, ensuring that adding QSharedDataPointers to your <a href="17-qdoc-commands-thread.html#reentrant">reentrant</a> classes won't make them non-reentrant.</p> <p><a href="implicit-sharing.html">Implicit sharing</a> is used by many Qt classes to combine the speed and memory efficiency of pointers with the ease of use of classes. See the <a href="implicit-sharing.html">Shared Classes</a> page for more information.</p> <p>Suppose you want to make an <code>Employee</code> class implicitly shared. The procedure is:</p> <ul> <li>Define the class <code>Employee</code> to have a single data member of type <code>QSharedDataPointer&lt;EmployeeData&gt;</code>.</li> <li>Define the <code>EmployeeData</code> class derived from <a href="qshareddata.html">QSharedData</a> to contain all the data members you would normally have put in the <code>Employee</code> class.</li> </ul> <p>To show this in practice, we review the source code for the implicitly shared <code>Employee</code> class. In the header file we define the two classes <code>Employee</code> and <code>EmployeeData</code>.</p> <pre data-language="cpp">#include &lt;QSharedData&gt;
#include &lt;QString&gt;

class EmployeeData : public QSharedData
{
  public:
    EmployeeData() : id(-1) { }
    EmployeeData(const EmployeeData &amp;other)
        : QSharedData(other), id(other.id), name(other.name) { }
    ~EmployeeData() { }

    int id;
    QString name;
};

class Employee
{
  public:
    Employee() { d = new EmployeeData; }
    Employee(int id, const QString &amp;name) {
        d = new EmployeeData;
        setId(id);
        setName(name);
    }
    Employee(const Employee &amp;other)
          : d (other.d)
    {
    }
    void setId(int id) { d-&gt;id = id; }
    void setName(const QString &amp;name) { d-&gt;name = name; }

    int id() const { return d-&gt;id; }
    QString name() const { return d-&gt;name; }

  private:
    QSharedDataPointer&lt;EmployeeData&gt; d;
};</pre> <p>In class <code>Employee</code>, note the single data member, a <i>d pointer</i> of type <code>QSharedDataPointer&lt;EmployeeData&gt;</code>. All accesses of employee data must go through the <i>d pointer's</i> <code>operator-&gt;()</code>. For write accesses, <code>operator-&gt;()</code> will automatically call <a href="qshareddatapointer.html#detach">detach</a>(), which creates a copy of the shared data object if the shared data object's reference count is greater than 1. This ensures that writes to one <code>Employee</code> object don't affect any other <code>Employee</code> objects that share the same <code>EmployeeData</code> object.</p> <p>Class <code>EmployeeData</code> inherits <a href="qshareddata.html">QSharedData</a>, which provides the <i>behind the scenes</i> reference counter. <code>EmployeeData</code> has a default constructor, a copy constructor, and a destructor. Normally, trivial implementations of these are all that is needed in the <i>data</i> class for an implicitly shared class.</p> <p>Implementing the two constructors for class <code>Employee</code> is also straightforward. Both create a new instance of <code>EmployeeData</code> and assign it to the <i>d pointer</i> .</p> <pre data-language="cpp">    Employee() { d = new EmployeeData; }

    Employee(int id, const QString &amp;name) {
        d = new EmployeeData;
        setId(id);
        setName(name);
    }</pre> <p>Note that class <code>Employee</code> also has a trivial copy constructor defined, which is not strictly required in this case.</p> <pre data-language="cpp">    Employee(const Employee &amp;other)
          : d (other.d)
    {
    }</pre> <p>The copy constructor is not strictly required here, because class <code>EmployeeData</code> is included in the same file as class <code>Employee</code> (<code>employee.h</code>). However, including the private subclass of <a href="qshareddata.html">QSharedData</a> in the same file as the public class containing the QSharedDataPointer is not typical. Normally, the idea is to hide the private subclass of <a href="qshareddata.html">QSharedData</a> from the user by putting it in a separate file which would not be included in the public file. In this case, we would normally put class <code>EmployeeData</code> in a separate file, which would <i>not</i> be included in <code>employee.h</code>. Instead, we would just predeclare the private subclass <code>EmployeeData</code> in <code>employee.h</code> this way:</p> <pre data-language="cpp">    class EmployeeData;</pre> <p>If we had done it that way here, the copy constructor shown would be required. Since the copy constructor is trivial, you might as well just always include it.</p> <p>Behind the scenes, QSharedDataPointer automatically increments the reference count whenever an <code>Employee</code> object is copied, assigned, or passed as a parameter. It decrements the reference count whenever an <code>Employee</code> object is deleted or goes out of scope. The shared <code>EmployeeData</code> object is deleted automatically if and when the reference count reaches 0.</p> <p>In a non-const member function of <code>Employee</code>, whenever the <i>d pointer</i> is dereferenced, QSharedDataPointer automatically calls <a href="qshareddatapointer.html#detach">detach</a>() to ensure that the function operates on its own copy of the data.</p> <pre data-language="cpp">    void setId(int id) { d-&gt;id = id; }

    void setName(const QString &amp;name) { d-&gt;name = name; }</pre> <p>Note that if <a href="qshareddatapointer.html#detach">detach</a>() is called more than once in a member function due to multiple dereferences of the <i>d pointer</i>, <a href="qshareddatapointer.html#detach">detach</a>() will only create a copy of the shared data the first time it is called, if at all, because on the second and subsequent calls of <a href="qshareddatapointer.html#detach">detach</a>(), the reference count will be 1 again.</p> <p>But note that in the second <code>Employee</code> constructor, which takes an employee ID and a name, both setId() and setName() are called, but they don't cause <i>copy on write</i>, because the reference count for the newly constructed <code>EmployeeData</code> object has just been set to 1.</p> <p>In <code>Employee</code>'s <i>const</i> member functions, dereferencing the <i>d pointer</i> does <i>not</i> cause <a href="qshareddatapointer.html#detach">detach</a>() to be called.</p> <pre data-language="cpp">    int id() const { return d-&gt;id; }

    QString name() const { return d-&gt;name; }</pre> <p>Notice that there is no need to implement a copy constructor or an assignment operator for the <code>Employee</code> class, because the copy constructor and assignment operator provided by the C++ compiler will do the <i>member by member</i> shallow copy required. The only member to copy is the <i>d pointer</i>, which is a QSharedDataPointer, whose <code>operator=()</code> just increments the reference count of the shared <code>EmployeeData</code> object.</p> <h3 id="implicit-vs-explicit-sharing">Implicit vs Explicit Sharing
</h3> <p>Implicit sharing might not be right for the <code>Employee</code> class. Consider a simple example that creates two instances of the implicitly shared <code>Employee</code> class.</p> <pre data-language="cpp">#include "employee.h"

int main()
{
    Employee e1(1001, "Albrecht Durer");
    Employee e2 = e1;
    e1.setName("Hans Holbein");
}</pre> <p>After the second employee e2 is created and e1 is assigned to it, both <code>e1</code> and <code>e2</code> refer to Albrecht Durer, employee 1001. Both <code>Employee</code> objects point to the same instance of <code>EmployeeData</code>, which has reference count 2. Then <code>e1.setName("Hans Holbein")</code> is called to change the employee name, but because the reference count is greater than 1, a <i>copy on write</i> is performed before the name is changed. Now <code>e1</code> and <code>e2</code> point to different <code>EmployeeData</code> objects. They have different names, but both have ID 1001, which is probably not what you want. You can, of course, just continue with <code>e1.setId(1002)</code>, if you really mean to create a second, unique employee, but if you only want to change the employee's name everywhere, consider using <a href="qexplicitlyshareddatapointer.html">explicit sharing</a> in the <code>Employee</code> class instead of implicit sharing.</p> <p>If you declare the <i>d pointer</i> in the <code>Employee</code> class to be <code>QExplicitlySharedDataPointer&lt;EmployeeData&gt;</code>, then explicit sharing is used and <i>copy on write</i> operations are not performed automatically (i.e. <a href="qshareddatapointer.html#detach">detach</a>() is not called in non-const functions). In that case, after <code>e1.setName("Hans Holbein")</code>, the employee's name has been changed, but both e1 and e2 still refer to the same instance of <code>EmployeeData</code>, so there is only one employee with ID 1001.</p> <p>In the member function documentation, <i>d pointer</i> always refers to the internal pointer to the shared data object.</p> <h3 id="optimize-performance-for-usage-in-qt-containers">Optimize Performance for Usage in Qt Containers
</h3> <p>You should consider marking your implicitly shared class as a movable type using the <a href="qtglobal.html#Q_DECLARE_TYPEINFO">Q_DECLARE_TYPEINFO</a>() macro if it resembles the <code>Employee</code> class above and uses a QSharedDataPointer or <a href="qexplicitlyshareddatapointer.html">QExplicitlySharedDataPointer</a> as the only member. This can improve performance and memory efficiency when using Qt's <a href="containers.html">container classes</a>.</p>  <p><b>See also </b><a href="qshareddata.html">QSharedData</a>, <a href="qexplicitlyshareddatapointer.html">QExplicitlySharedDataPointer</a>, <a href="qscopedpointer.html">QScopedPointer</a>, and <a href="qsharedpointer.html">QSharedPointer</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="Type-typedef">QSharedDataPointer::<span class="name">Type</span>
</h3> <p>This is the type of the shared data object. The <i>d pointer</i> points to an object of this type.</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QSharedDataPointer-4">
<code>[since 5.2] </code>QSharedDataPointer::<span class="name">QSharedDataPointer</span>(<span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>o</i>)
</h3> <p>Move-constructs a QSharedDataPointer instance, making it point at the same object that <i>o</i> was pointing to.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="QSharedDataPointer-3">QSharedDataPointer::<span class="name">QSharedDataPointer</span>(const <span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>o</i>)
</h3> <p>Sets the <i>d pointer</i> of <i>this</i> to the <i>d pointer</i> in <i>o</i> and increments the reference count of the shared data object.</p>   <h3 class="fn" id="QSharedDataPointer-2">
<code>[since 6.0] </code>QSharedDataPointer::<span class="name">QSharedDataPointer</span>(<span class="type">T</span> *<i>data</i>, <span class="type"><a href="qadoptshareddatatag.html">QAdoptSharedDataTag</a></span>)
</h3> <p>Constructs a QSharedDataPointer with <i>d pointer</i> set to <i>data</i>. <i>data</i>'s reference counter is <b>not</b> incremented; this can be used to adopt pointers obtained from <a href="qshareddatapointer.html#take">take</a>().</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qshareddatapointer.html#take">take</a>().</p>   <h3 class="fn" id="QSharedDataPointer-1">QSharedDataPointer::<span class="name">QSharedDataPointer</span>(<span class="type">T</span> *<i>data</i>)
</h3> <p>Constructs a QSharedDataPointer with <i>d pointer</i> set to <i>data</i> and increments <i>data</i>'s reference count.</p>   <h3 class="fn" id="QSharedDataPointer">QSharedDataPointer::<span class="name">QSharedDataPointer</span>()
</h3> <p>Constructs a QSharedDataPointer initialized with <code>nullptr</code> as <i>d pointer</i>.</p>   <h3 class="fn" id="operator-eq-2">
<code>[since 5.2] </code><span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;QSharedDataPointer::<span class="name">operator=</span>(<span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)
</h3> <p>Move-assigns <i>other</i> to this <a href="qshareddatapointer.html">QSharedDataPointer</a> instance.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="operator-eq">
<span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;QSharedDataPointer::<span class="name">operator=</span>(const <span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>o</i>)
</h3> <p>Sets the <i>d pointer</i> of <i>this</i> to the <i>d pointer</i> of <i>o</i> and increments the reference count of the shared data object. The reference count of the old shared data object of <i>this</i> is decremented. If the reference count of the old shared data object becomes 0, the old shared data object is deleted.</p>   <h3 class="fn" id="dtor.QSharedDataPointer">QSharedDataPointer::<span class="name">~QSharedDataPointer</span>()
</h3> <p>Decrements the reference count of the shared data object. If the reference count becomes 0, the shared data object is deleted. <i>This</i> is then destroyed.</p>   <h3 class="fn" id="clone">
<code>[protected] </code><span class="type">T</span> *QSharedDataPointer::<span class="name">clone</span>()
</h3> <p>Creates and returns a deep copy of the current data. This function is called by <a href="qshareddatapointer.html#detach">detach</a>() when the reference count is greater than 1 in order to create the new copy. This function uses the <i>operator new</i> and calls the copy constructor of the type T.</p> <p>This function is provided so that you may support "virtual copy constructors" for your own types. In order to so, you should declare a template-specialization of this function for your own type, like the example below:</p> <pre data-language="cpp">    template&lt;&gt;
    EmployeeData *QSharedDataPointer&lt;EmployeeData&gt;::clone()
    {
        return d-&gt;clone();
    }</pre> <p>In the example above, the template specialization for the clone() function calls the <i>EmployeeData::clone()</i> virtual function. A class derived from EmployeeData could override that function and return the proper polymorphic type.</p>   <h3 class="fn" id="constData">const <span class="type">T</span> *QSharedDataPointer::<span class="name">constData</span>() const
</h3> <p>Returns a const pointer to the shared data object. This function does <i>not</i> call <a href="qshareddatapointer.html#detach">detach</a>().</p> <p><b>See also </b><a href="qshareddatapointer.html#data">data</a>().</p>   <h3 class="fn" id="data">
<span class="type">T</span> *QSharedDataPointer::<span class="name">data</span>()
</h3> <p>Returns a pointer to the shared data object. This function calls <a href="qshareddatapointer.html#detach">detach</a>().</p> <p><b>See also </b><a href="qshareddatapointer.html#constData">constData</a>().</p>   <h3 class="fn" id="data-1">const <span class="type">T</span> *QSharedDataPointer::<span class="name">data</span>() const
</h3> <p>Returns a pointer to the shared data object. This function does <i>not</i> call <a href="qshareddatapointer.html#detach">detach</a>().</p>   <h3 class="fn" id="detach">
<span class="type">void</span> QSharedDataPointer::<span class="name">detach</span>()
</h3> <p>If the shared data object's reference count is greater than 1, this function creates a deep copy of the shared data object and sets the <i>d pointer</i> of <i>this</i> to the copy.</p> <p>This function is called automatically by non-const member functions of <a href="qshareddatapointer.html">QSharedDataPointer</a> if <i>copy on write</i> is required. You don't need to call it yourself.</p>   <h3 class="fn" id="get">
<code>[since 6.0] </code><span class="type">T</span> *QSharedDataPointer::<span class="name">get</span>()
</h3> <p>Same as <a href="qshareddatapointer.html#data">data</a>(). This function is provided for STL compatibility.</p> <p>This function was introduced in Qt 6.0.</p>   <h3 class="fn" id="get-1">
<code>[since 6.0] </code>const <span class="type">T</span> *QSharedDataPointer::<span class="name">get</span>() const
</h3> <p>Same as <a href="qshareddatapointer.html#data">data</a>(). This function is provided for STL compatibility.</p> <p>This function was introduced in Qt 6.0.</p>   <h3 class="fn" id="reset">
<code>[since 6.0] </code><span class="type">void</span> QSharedDataPointer::<span class="name">reset</span>(<span class="type">T</span> *<i>ptr</i> = nullptr)
</h3> <p>Sets the <i>d pointer</i> of <i>this</i> to <i>ptr</i> and increments <i>ptr</i>'s reference count if <i>ptr</i> is not <code>nullptr</code>. The reference count of the old shared data object is decremented, and the object deleted if the reference count reaches 0.</p> <p>This function was introduced in Qt 6.0.</p>   <h3 class="fn" id="swap">
<span class="type">void</span> QSharedDataPointer::<span class="name">swap</span>(<span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)
</h3> <p>Swap this instance's shared data pointer with the shared data pointer in <i>other</i>.</p>   <h3 class="fn" id="take">
<code>[since 6.0] </code><span class="type">T</span> *QSharedDataPointer::<span class="name">take</span>()
</h3> <p>Returns a pointer to the shared object, and resets <i>this</i> to be <code>nullptr</code>. (That is, this function sets the <i>d pointer</i> of <i>this</i> to <code>nullptr</code>.)</p> <div class="admonition note"> <p><b>Note: </b>The reference count of the returned object will <b>not</b> be decremented. This function can be used together with the constructor that takes a <a href="qadoptshareddatatag.html">QAdoptSharedDataTag</a> tag object to transfer the shared data object without intervening atomic operations.</p> </div> <p>This function was introduced in Qt 6.0.</p>   <h3 class="fn" id="operator-T--2a">
<span class="type">T</span> *QSharedDataPointer::<span class="name">operator T *</span>()
</h3> <p>Returns a pointer to the shared data object. This function calls <a href="qshareddatapointer.html#detach">detach</a>().</p> <p><b>See also </b><a href="qshareddatapointer.html#data">data</a>() and <a href="qshareddatapointer.html#constData">constData</a>().</p>   <h3 class="fn" id="operator-const-T--2a">const <span class="type">T</span> *QSharedDataPointer::<span class="name">operator const T *</span>() const
</h3> <p>Returns a pointer to the shared data object. This function does <i>not</i> call <a href="qshareddatapointer.html#detach">detach</a>().</p>   <h3 class="fn" id="operator-not">
<span class="type">bool</span> QSharedDataPointer::<span class="name">operator!</span>() const
</h3> <p>Returns <code>true</code> if the <i>d pointer</i> of <i>this</i> is <code>nullptr</code>.</p>   <h3 class="fn" id="operator-2a">
<span class="type">T</span> &amp;QSharedDataPointer::<span class="name">operator*</span>()
</h3> <p>Provides access to the shared data object's members. This function calls <a href="qshareddatapointer.html#detach">detach</a>().</p>   <h3 class="fn" id="operator-2a-1">const <span class="type">T</span> &amp;QSharedDataPointer::<span class="name">operator*</span>() const
</h3> <p>Provides const access to the shared data object's members. This function does <i>not</i> call <a href="qshareddatapointer.html#detach">detach</a>().</p>   <h3 class="fn" id="operator--gt">
<span class="type">T</span> *QSharedDataPointer::<span class="name">operator-&gt;</span>()
</h3> <p>Provides access to the shared data object's members. This function calls <a href="qshareddatapointer.html#detach">detach</a>().</p>   <h3 class="fn" id="operator--gt-1">const <span class="type">T</span> *QSharedDataPointer::<span class="name">operator-&gt;</span>() const
</h3> <p>Provides const access to the shared data object's members. This function does <i>not</i> call <a href="qshareddatapointer.html#detach">detach</a>().</p>   <h3 class="fn" id="operator-eq-1">
<span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;QSharedDataPointer::<span class="name">operator=</span>(<span class="type">T</span> *<i>o</i>)
</h3> <p>Sets the <i>d pointer</i> og <i>this</i> to <i>o</i> and increments <i>o</i>'s reference count. The reference count of the old shared data object of <i>this</i> is decremented. If the reference count of the old shared data object becomes 0, the old shared data object is deleted.</p>   <div class="relnonmem"> <h2>Related Non-Members</h2>  <h3 class="fn" id="operator-not-eq">
<span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)
</h3> <p>Returns <code>true</code> if <i>lhs</i> and <i>rhs</i> do <i>not</i> have the same <i>d pointer</i>. This function does <i>not</i> call <a href="qshareddatapointer.html#detach">detach</a>().</p>   <h3 class="fn" id="operator-not-eq-2">
<span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type">T</span> *<i>ptr</i>, const <span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)
</h3> <p>Returns <code>true</code> if the <i>d pointer</i> of <i>rhs</i> is <i>not</i> <i>ptr</i>. <i>d pointer</i>. This function does <i>not</i> call <a href="qshareddatapointer.html#detach">detach</a>().</p>   <h3 class="fn" id="operator-eq-eq">
<span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)
</h3> <p>Returns <code>true</code> if <i>lhs</i> and <i>rhs</i> have the same <i>d pointer</i>. This function does <i>not</i> call <a href="qshareddatapointer.html#detach">detach</a>().</p>   <h3 class="fn" id="operator-eq-eq-2">
<span class="type">bool</span> <span class="name">operator==</span>(const <span class="type">T</span> *<i>ptr</i>, const <span class="type"><a href="qshareddatapointer.html#QSharedDataPointer">QSharedDataPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)
</h3> <p>Returns <code>true</code> if the <i>d pointer</i> of <i>rhs</i> is <i>ptr</i>. This function does <i>not</i> call <a href="qshareddatapointer.html#detach">detach</a>().</p>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qshareddatapointer.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qshareddatapointer.html</a>
  </p>
</div>
