<h1 class="title">QCanBusDevice Class</h1>  <p>The QCanBusDevice class is the interface class for CAN bus. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QCanBusDevice&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += serialbus</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.8</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qobject.html">QObject</a>
</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qcanbusdevice-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> struct </td>
<td class="memItemRight bottomAlign"><b><a href="qcanbusdevice-filter.html">Filter</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#CanBusDeviceState-enum">CanBusDeviceState</a></b> { UnconnectedState, ConnectingState, ConnectedState, ClosingState }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#CanBusError-enum">CanBusError</a></b> { NoError, ReadError, WriteError, ConnectionError, ConfigurationError, …, TimeoutError }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum class </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#CanBusStatus-enum">CanBusStatus</a></b> { Unknown, Good, Warning, Error, BusOff }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#ConfigurationKey-enum">ConfigurationKey</a></b> { RawFilterKey, ErrorFilterKey, LoopbackKey, ReceiveOwnKey, BitRateKey, …, UserKey }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#Direction-enum">Direction</a></b> { Input, Output, AllDirections }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#Direction-enum">Directions</a></b></td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#QCanBusDevice-1">QCanBusDevice</a></b>(QObject *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QCanBusDevice::CanBusStatus </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#busStatus">busStatus</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#clear">clear</a></b>(QCanBusDevice::Directions <i>direction</i> = Direction::AllDirections)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;QCanBusDevice::ConfigurationKey&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#configurationKeys">configurationKeys</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVariant </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#configurationParameter">configurationParameter</a></b>(QCanBusDevice::ConfigurationKey <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#connectDevice">connectDevice</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QCanBusDeviceInfo </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#deviceInfo">deviceInfo</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#disconnectDevice">disconnectDevice</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCanBusDevice::CanBusError </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#error">error</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#errorString">errorString</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qint64 </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#framesAvailable">framesAvailable</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qint64 </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#framesToWrite">framesToWrite</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#hasBusStatus">hasBusStatus</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#interpretErrorFrame">interpretErrorFrame</a></b>(const QCanBusFrame &amp;<i>frame</i>) = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;QCanBusFrame&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#readAllFrames">readAllFrames</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCanBusFrame </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#readFrame">readFrame</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#resetController">resetController</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#setConfigurationParameter">setConfigurationParameter</a></b>(QCanBusDevice::ConfigurationKey <i>key</i>, const QVariant &amp;<i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCanBusDevice::CanBusDeviceState </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#state">state</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#waitForFramesReceived">waitForFramesReceived</a></b>(int <i>msecs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#waitForFramesWritten">waitForFramesWritten</a></b>(int <i>msecs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#writeFrame">writeFrame</a></b>(const QCanBusFrame &amp;<i>frame</i>) = 0</td>
</tr> </table> <h2 id="signals">Signals
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#errorOccurred">errorOccurred</a></b>(QCanBusDevice::CanBusError)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#framesReceived">framesReceived</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#framesWritten">framesWritten</a></b>(qint64 <i>framesCount</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#stateChanged">stateChanged</a></b>(QCanBusDevice::CanBusDeviceState <i>state</i>)</td>
</tr> </table> <h2 id="protected-functions">Protected Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#clearError">clearError</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#close">close</a></b>() = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCanBusFrame </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#dequeueOutgoingFrame">dequeueOutgoingFrame</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#enqueueOutgoingFrame">enqueueOutgoingFrame</a></b>(const QCanBusFrame &amp;<i>newFrame</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#enqueueReceivedFrames">enqueueReceivedFrames</a></b>(const QList&lt;QCanBusFrame&gt; &amp;<i>newFrames</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#hasOutgoingFrames">hasOutgoingFrames</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#open">open</a></b>() = 0</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#setError">setError</a></b>(const QString &amp;<i>errorText</i>, QCanBusDevice::CanBusError <i>errorId</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcanbusdevice.html#setState">setState</a></b>(QCanBusDevice::CanBusDeviceState <i>newState</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>QCanBusDevice communicates with a CAN plugin providing users with a convenient API. The CAN plugin must be specified during the object creation.</p>    <h2>Member Type Documentation</h2>  <h3 class="fn" id="CanBusDeviceState-enum">enum QCanBusDevice::<span class="name">CanBusDeviceState</span>
</h3> <p>This enum describes all possible device states.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::UnconnectedState</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The device is disconnected.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::ConnectingState</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The device is being connected.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::ConnectedState</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">The device is connected to the CAN bus.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::ClosingState</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">The device is being closed.</td>
</tr> </table>   <h3 class="fn" id="CanBusError-enum">enum QCanBusDevice::<span class="name">CanBusError</span>
</h3> <p>This enum describes all the possible error conditions.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::NoError</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">No errors have occurred.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::ReadError</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">An error occurred during a read operation.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::WriteError</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">An error occurred during a write operation.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::ConnectionError</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">An error occurred when attempting to open the plugin.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::ConfigurationError</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">An error occurred when attempting to set a configuration parameter.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::UnknownError</code></td>
<td class="topAlign tblval"><code>5</code></td>
<td class="topAlign">An unknown error occurred.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::OperationError</code></td>
<td class="topAlign tblval"><code>6</code></td>
<td class="topAlign">An operation was attempted while the device was in a state that did not permit it. This enum was introduced in Qt 5.14.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::TimeoutError</code></td>
<td class="topAlign tblval"><code>7</code></td>
<td class="topAlign">An timeout occurred while waiting for frames written or received. This enum was introduced in Qt 5.14.</td>
</tr> </table>   <h3 class="fn" id="CanBusStatus-enum">
<code>[since 5.14] </code>enum class QCanBusDevice::<span class="name">CanBusStatus</span>
</h3> <p>This enum describes possible CAN bus status values.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::CanBusStatus::Unknown</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The CAN bus status is unknown (e.g. not supported by the CAN plugin).</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::CanBusStatus::Good</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The CAN controller is fully operational</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::CanBusStatus::Warning</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">The CAN controller is in warning status</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::CanBusStatus::Error</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">The CAN controller is in error status (no longer sending CAN frames)</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::CanBusStatus::BusOff</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">The CAN controller is in bus off status (disconnected from the CAN bus)</td>
</tr> </table> <p>This enum was introduced or modified in Qt 5.14.</p>   <h3 class="fn" id="ConfigurationKey-enum">enum QCanBusDevice::<span class="name">ConfigurationKey</span>
</h3> <p>This enum describes the possible configuration options for the CAN bus connection.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::RawFilterKey</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">This configuration determines the type of CAN bus frames that the current device accepts. The expected value is <code>QList&lt;QCanBusDevice::Filter&gt;</code>. Passing an empty list clears all previously set filters including default filters. For more details see <a href="qcanbusdevice-filter.html">QCanBusDevice::Filter</a>.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::ErrorFilterKey</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">This key defines the type of error that should be forwarded via the current connection. The associated value should be of type <a href="qcanbusframe.html#FrameError-enum">QCanBusFrame::FrameErrors</a>.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::LoopbackKey</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">This key defines whether the CAN bus device should operate in loopback mode. Loopback means, whenever a CAN frame is transmitted on the CAN bus, a local echo of this frame is sent to all applications connected to this CAN device. The expected value for this key is <code>bool</code>.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::ReceiveOwnKey</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">This key defines whether this CAN device receives its own send frames. This can be used to check if the transmission was successful. The expected value for this key is <code>bool</code>.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::BitRateKey</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">This key defines the CAN bitrate in bits per second. With CAN FD, the payload can be transmitted at a higher data bitrate, if <a href="qcanbusframe.html#hasBitrateSwitch">QCanBusFrame::hasBitrateSwitch</a>() is set. In this case, <code>QCanBusDevice::BitRateKey</code> is only used for the CAN ID arbitration phase. See also <code>QCanBusDevice::DataBitRateKey</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::CanFdKey</code></td>
<td class="topAlign tblval"><code>5</code></td>
<td class="topAlign">This key defines whether sending and receiving of CAN FD frames should be enabled. The expected value for this key is <code>bool</code>.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::DataBitRateKey</code></td>
<td class="topAlign tblval"><code>6</code></td>
<td class="topAlign">This key defines the CAN FD payload bitrate in bits per second. CAN FD allows to transmit the payload of frames with <a href="qcanbusframe.html#hasBitrateSwitch">QCanBusFrame::hasBitrateSwitch</a>() flag at a higher data bitrate, after the arbitration phase at the nominal bitrate is finished. This enum value was introduced in Qt 5.9. See also <code>QCanBusDevice::BitRateKey</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::ProtocolKey</code></td>
<td class="topAlign tblval"><code>7</code></td>
<td class="topAlign">This key allows to specify another protocol. For now, this parameter can only be set and used in the SocketCAN plugin. This enum value was introduced in Qt 5.14.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::UserKey</code></td>
<td class="topAlign tblval"><code>30</code></td>
<td class="topAlign">This key defines the range where custom keys start. Its most common purpose is to permit platform-specific configuration options.</td>
</tr> </table> <p><b>See also </b><a href="qcanbusdevice.html#configurationParameter">configurationParameter</a>().</p>   <h3 class="flags" id="Direction-enum">
<code>[since 5.12] </code>enum QCanBusDevice::<span class="name">Direction</span>flags QCanBusDevice::<span class="name">Directions</span>
</h3> <p>This enum describes possible data transmission directions.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::Input</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">Input direction.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::Output</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">Output direction.</td>
</tr> <tr>
<td class="topAlign"><code>QCanBusDevice::AllDirections</code></td>
<td class="topAlign tblval"><code>Input | Output</code></td>
<td class="topAlign">Both directions, input and output.</td>
</tr> </table> <p>This enum was introduced or modified in Qt 5.12.</p> <p>The Directions type is a typedef for <a href="qflags.html">QFlags</a>&lt;Direction&gt;. It stores an OR combination of Direction values.</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QCanBusDevice-1">QCanBusDevice::<span class="name">QCanBusDevice</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)
</h3> <p>Constructs a serial bus device with the specified <i>parent</i>.</p>   <h3 class="fn" id="errorOccurred">
<code>[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">errorOccurred</span>(<span class="type"><a href="qcanbusdevice.html#CanBusError-enum">QCanBusDevice::CanBusError</a></span>)
</h3> <p>This signal is emitted when an error occurs.</p>   <h3 class="fn" id="framesReceived">
<code>[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">framesReceived</span>()
</h3> <p>This signal is emitted when one or more frames have been received. The frames should be read using <a href="qcanbusdevice.html#readFrame">readFrame</a>() and <a href="qcanbusdevice.html#framesAvailable">framesAvailable</a>().</p>   <h3 class="fn" id="framesWritten">
<code>[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">framesWritten</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>framesCount</i>)
</h3> <p>This signal is emitted every time a payload of frames has been written to the CAN bus. The <i>framesCount</i> argument is set to the number of frames that were written in this payload.</p>   <h3 class="fn" id="stateChanged">
<code>[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">stateChanged</span>(<span class="type"><a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::CanBusDeviceState</a></span> <i>state</i>)
</h3> <p>This signal is emitted every time the state of the device changes. The new state is represented by <i>state</i>.</p> <p><b>See also </b><a href="qcanbusdevice.html#setState">setState</a>() and <a href="qcanbusdevice.html#state">state</a>().</p>   <h3 class="fn" id="busStatus">
<code>[virtual, since 5.14] </code><span class="type"><a href="qcanbusdevice.html#CanBusStatus-enum">QCanBusDevice::CanBusStatus</a></span> QCanBusDevice::<span class="name">busStatus</span>()
</h3> <p>Returns the current CAN bus status. If the status cannot be requested, QCanBusDevice::UnknownStatus is returned.</p> <div class="admonition note"> <p><b>Note: </b>This function may not be implemented in all CAN plugins. Please refer to the plugins help pages for more information. The function <a href="qcanbusdevice.html#hasBusStatus">hasBusStatus</a>() can be used at runtime to check if the used CAN plugin has support for requesting the CAN bus status.</p> </div> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qcanbusdevice.html#hasBusStatus">hasBusStatus</a>() and <a href="qcanbusdevice.html#resetController">resetController</a>().</p>   <h3 class="fn" id="clear">
<code>[since 5.12] </code><span class="type">void</span> QCanBusDevice::<span class="name">clear</span>(<span class="type"><a href="qcanbusdevice.html#Direction-enum">QCanBusDevice::Directions</a></span> <i>direction</i> = Direction::AllDirections)
</h3> <p>Clears the devices input or output buffers, depending on <i>direction</i>.</p> <p>This function only operates on <a href="qcanbusdevice.html">QCanBusDevice</a> buffers. Frames that are already written to the CAN driver or CAN hardware layer, or that are not yet read from these layers, are not cleared by this function.</p> <div class="admonition note"> <p><b>Note: </b>Clearing the output buffers is only possible for buffered devices.</p> </div> <p>This function was introduced in Qt 5.12.</p> <p><b>See also </b><a href="qcanbusdevice.html#framesAvailable">framesAvailable</a>(), <a href="qcanbusdevice.html#readFrame">readFrame</a>(), <a href="qcanbusdevice.html#framesToWrite">framesToWrite</a>(), and <a href="qcanbusdevice.html#writeFrame">writeFrame</a>().</p>   <h3 class="fn" id="clearError">
<code>[protected, since 5.14] </code><span class="type">void</span> QCanBusDevice::<span class="name">clearError</span>()
</h3> <p>Clears the error id and the human readable description of the last device error.</p> <p>CAN bus implementations must use this function to update the device's error state.</p> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qcanbusdevice.html#error">error</a>(), <a href="qcanbusdevice.html#errorOccurred">errorOccurred</a>(), and <a href="qcanbusdevice.html#setError">setError</a>().</p>   <h3 class="fn" id="close">
<code>[pure virtual protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">close</span>()
</h3> <p>This function is responsible for closing the CAN bus connection. The implementation must ensure that the instance's <a href="qcanbusdevice.html#state">state</a>() is set to <a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::UnconnectedState</a>.</p> <p>This function's most important task is to close the socket to the CAN device and to call <a href="qcanbusdevice.html#setState">QCanBusDevice::setState</a>().</p> <p><b>See also </b><a href="qcanbusdevice.html#disconnectDevice">disconnectDevice</a>().</p>   <h3 class="fn" id="configurationKeys">
<span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qcanbusdevice.html#ConfigurationKey-enum">QCanBusDevice::ConfigurationKey</a></span>&gt; QCanBusDevice::<span class="name">configurationKeys</span>() const
</h3> <p>Returns the list of keys used by the CAN bus connection.</p> <p>The the meaning of the keys is equivalent to <a href="qcanbusdevice.html#ConfigurationKey-enum">ConfigurationKey</a>. If a key is not explicitly mentioned the platform's default setting for the relevant key is used.</p>   <h3 class="fn" id="configurationParameter">
<span class="type"><a href="qvariant.html">QVariant</a></span> QCanBusDevice::<span class="name">configurationParameter</span>(<span class="type"><a href="qcanbusdevice.html#ConfigurationKey-enum">QCanBusDevice::ConfigurationKey</a></span> <i>key</i>) const
</h3> <p>Returns the current value assigned to the <a href="qcanbusdevice.html#ConfigurationKey-enum">ConfigurationKey</a> <i>key</i>; otherwise an invalid <a href="qvariant.html">QVariant</a>.</p> <p><b>See also </b><a href="qcanbusdevice.html#setConfigurationParameter">setConfigurationParameter</a>() and <a href="qcanbusdevice.html#configurationKeys">configurationKeys</a>().</p>   <h3 class="fn" id="connectDevice">
<span class="type">bool</span> QCanBusDevice::<span class="name">connectDevice</span>()
</h3> <p>Connects the device to the CAN bus. Returns <code>true</code> on success; otherwise <code>false</code>.</p> <p>This function calls <a href="qcanbusdevice.html#open">open</a>() as part of its implementation.</p> <p><b>See also </b><a href="qcanbusdevice.html#disconnectDevice">disconnectDevice</a>().</p>   <h3 class="fn" id="dequeueOutgoingFrame">
<code>[protected] </code><span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span> QCanBusDevice::<span class="name">dequeueOutgoingFrame</span>()
</h3> <p>Returns the next <a href="qcanbusframe.html">QCanBusFrame</a> from the internal list of outgoing frames; otherwise returns an invalid <a href="qcanbusframe.html">QCanBusFrame</a>. The returned frame is removed from the internal list.</p>   <h3 class="fn" id="deviceInfo">
<code>[virtual, since 6.2] </code><span class="type"><a href="qcanbusdeviceinfo.html">QCanBusDeviceInfo</a></span> QCanBusDevice::<span class="name">deviceInfo</span>() const
</h3> <p>Returns a <a href="qcanbusdeviceinfo.html">QCanBusDeviceInfo</a> for the current <a href="qcanbusdevice.html">QCanBusDevice</a>. If the function is not implemented by a sub-class of <a href="qcanbusdevice.html">QCanBusDevice</a>, a default constructed object is returned.</p> <p>This function was introduced in Qt 6.2.</p>   <h3 class="fn" id="disconnectDevice">
<span class="type">void</span> QCanBusDevice::<span class="name">disconnectDevice</span>()
</h3> <p>Disconnects the device from the CAN bus.</p> <p>This function calls <a href="qcanbusdevice.html#close">close</a>() as part of its implementation.</p> <div class="admonition note"> <p><b>Note: </b>This function should only be called, if <a href="qcanbusdevice.html#connectDevice">connectDevice</a>() returned <code>true</code>.</p> </div> <p><b>See also </b><a href="qcanbusdevice.html#connectDevice">connectDevice</a>().</p>   <h3 class="fn" id="enqueueOutgoingFrame">
<code>[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">enqueueOutgoingFrame</span>(const <span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span> &amp;<i>newFrame</i>)
</h3> <p>Appends <i>newFrame</i> to the internal list of outgoing frames which can be accessed by <a href="qcanbusdevice.html#writeFrame">writeFrame</a>().</p> <p>Subclasses must call this function when they write a new frame.</p>   <h3 class="fn" id="enqueueReceivedFrames">
<code>[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">enqueueReceivedFrames</span>(const <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span>&gt; &amp;<i>newFrames</i>)
</h3> <p>Appends <i>newFrames</i> to the internal list of frames which can be accessed using <a href="qcanbusdevice.html#readFrame">readFrame</a>() and emits the <a href="qcanbusdevice.html#framesReceived">framesReceived</a>() signal.</p> <p>Subclasses must call this function when they receive frames.</p>   <h3 class="fn" id="error">
<span class="type"><a href="qcanbusdevice.html#CanBusError-enum">QCanBusDevice::CanBusError</a></span> QCanBusDevice::<span class="name">error</span>() const
</h3> <p>Returns the last error that has occurred. The error value is always set to last error that occurred and it is never reset.</p> <p><b>See also </b><a href="qcanbusdevice.html#setError">setError</a>() and <a href="qcanbusdevice.html#errorString">errorString</a>().</p>   <h3 class="fn" id="errorString">
<span class="type"><a href="qstring.html">QString</a></span> QCanBusDevice::<span class="name">errorString</span>() const
</h3> <p>Returns a human-readable description of the last device error that occurred.</p> <p><b>See also </b><a href="qcanbusdevice.html#error">error</a>().</p>   <h3 class="fn" id="framesAvailable">
<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QCanBusDevice::<span class="name">framesAvailable</span>() const
</h3> <p>Returns the number of available frames. If no frames are available, this function returns 0.</p> <p><b>See also </b><a href="qcanbusdevice.html#clear">clear</a>(), <a href="qcanbusdevice.html#readFrame">readFrame</a>(), and <a href="qcanbusdevice.html#readAllFrames">readAllFrames</a>().</p>   <h3 class="fn" id="framesToWrite">
<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QCanBusDevice::<span class="name">framesToWrite</span>() const
</h3> <p>For buffered devices, this function returns the number of frames waiting to be written. For unbuffered devices, this function always returns zero.</p> <div class="admonition note"> <p><b>Note: </b>There may be additional buffering in the CAN driver and CAN hardware layer. Therefore, if this function returns zero, that does not mean all CAN frames are already written to the CAN bus.</p> </div> <p><b>See also </b><a href="qcanbusdevice.html#clear">clear</a>() and <a href="qcanbusdevice.html#writeFrame">writeFrame</a>().</p>   <h3 class="fn" id="hasBusStatus">
<code>[virtual, since 5.14] </code><span class="type">bool</span> QCanBusDevice::<span class="name">hasBusStatus</span>() const
</h3> <p>Return true, if the CAN plugin supports requesting the CAN bus status.</p> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qcanbusdevice.html#busStatus">busStatus</a>().</p>   <h3 class="fn" id="hasOutgoingFrames">
<code>[protected] </code><span class="type">bool</span> QCanBusDevice::<span class="name">hasOutgoingFrames</span>() const
</h3> <p>Returns <code>true</code> if the internal list of outgoing frames is not empty; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="interpretErrorFrame">
<code>[pure virtual] </code><span class="type"><a href="qstring.html">QString</a></span> QCanBusDevice::<span class="name">interpretErrorFrame</span>(const <span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span> &amp;<i>frame</i>)
</h3> <p>Interprets <i>frame</i> as error frame and returns a human readable description of the error.</p> <p>If <i>frame</i> is not an error frame, the returned string is empty.</p>   <h3 class="fn" id="open">
<code>[pure virtual protected] </code><span class="type">bool</span> QCanBusDevice::<span class="name">open</span>()
</h3> <p>This function is called by <a href="qcanbusdevice.html#connectDevice">connectDevice</a>(). Subclasses must provide an implementation which returns <code>true</code> if the CAN bus connection could be established; otherwise <code>false</code>. The <a href="qcanbusdevice.html">QCanBusDevice</a> implementation ensures upon entry of this function that the device's <a href="qcanbusdevice.html#state">state</a>() is set to <a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::ConnectingState</a> already.</p> <p>The implementation must ensure that upon success the instance's <a href="qcanbusdevice.html#state">state</a>() is set to <a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::ConnectedState</a>; otherwise <a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::UnconnectedState</a>. <a href="qcanbusdevice.html#setState">setState</a>() must be used to set the new device state.</p> <p>The custom implementation is responsible for opening the socket, instanciation of a potentially required <a href="qsocketnotifier.html">QSocketNotifier</a> and the application of custom and default <a href="qcanbusdevice.html#configurationParameter">QCanBusDevice::configurationParameter</a>().</p> <p><b>See also </b><a href="qcanbusdevice.html#connectDevice">connectDevice</a>().</p>   <h3 class="fn" id="readAllFrames">
<code>[since 5.12] </code><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span>&gt; QCanBusDevice::<span class="name">readAllFrames</span>()
</h3> <p>Returns all <a href="qcanbusframe.html">QCanBusFrame</a>s from the queue; otherwise returns an empty <a href="qlist.html">QList</a>. The returned frames are removed from the queue.</p> <p>The queue operates according to the FIFO principle.</p> <p>This function was introduced in Qt 5.12.</p> <p><b>See also </b><a href="qcanbusdevice.html#clear">clear</a>(), <a href="qcanbusdevice.html#framesAvailable">framesAvailable</a>(), and <a href="qcanbusdevice.html#readFrame">readFrame</a>().</p>   <h3 class="fn" id="readFrame">
<span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span> QCanBusDevice::<span class="name">readFrame</span>()
</h3> <p>Returns the next <a href="qcanbusframe.html">QCanBusFrame</a> from the queue; otherwise returns an empty <a href="qcanbusframe.html">QCanBusFrame</a>. The returned frame is removed from the queue.</p> <p>The queue operates according to the FIFO principle.</p> <p><b>See also </b><a href="qcanbusdevice.html#clear">clear</a>(), <a href="qcanbusdevice.html#framesAvailable">framesAvailable</a>(), and <a href="qcanbusdevice.html#readAllFrames">readAllFrames</a>().</p>   <h3 class="fn" id="resetController">
<code>[virtual, since 5.14] </code><span class="type">void</span> QCanBusDevice::<span class="name">resetController</span>()
</h3> <p>Performs a CAN controller reset to release the CAN controller from bus off state, if possible.</p> <div class="admonition note"> <p><b>Note: </b>CAN controller resets disturb the running communication and may take up to one second to complete. Only call this function to recover from bus errors.</p> </div> <div class="admonition note"> <p><b>Note: </b>This function may not be implemented in all CAN plugins. Please refer to the plugins help pages for more information.</p> </div> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qcanbusdevice.html#busStatus">busStatus</a>().</p>   <h3 class="fn" id="setConfigurationParameter">
<code>[virtual] </code><span class="type">void</span> QCanBusDevice::<span class="name">setConfigurationParameter</span>(<span class="type"><a href="qcanbusdevice.html#ConfigurationKey-enum">QCanBusDevice::ConfigurationKey</a></span> <i>key</i>, const <span class="type"><a href="qvariant.html">QVariant</a></span> &amp;<i>value</i>)
</h3> <p>Sets the configuration parameter <i>key</i> for the CAN bus connection to <i>value</i>. The potential keys are represented by <a href="qcanbusdevice.html#ConfigurationKey-enum">ConfigurationKey</a>.</p> <p>A parameter can be unset by setting an invalid <a href="qvariant.html">QVariant</a>. Unsetting a parameter implies that the configuration is reset to its default setting.</p> <div class="admonition note"> <p><b>Note: </b>In most cases, configuration changes only take effect after a reconnect.</p> </div> <p><b>See also </b><a href="qcanbusdevice.html#configurationParameter">configurationParameter</a>().</p>   <h3 class="fn" id="setError">
<code>[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">setError</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>errorText</i>, <span class="type"><a href="qcanbusdevice.html#CanBusError-enum">QCanBusDevice::CanBusError</a></span> <i>errorId</i>)
</h3> <p>Sets the human readable description of the last device error to <i>errorText</i>. <i>errorId</i> categorizes the type of error.</p> <p>CAN bus implementations must use this function to update the device's error state.</p> <p><b>See also </b><a href="qcanbusdevice.html#error">error</a>(), <a href="qcanbusdevice.html#errorOccurred">errorOccurred</a>(), and <a href="qcanbusdevice.html#clearError">clearError</a>().</p>   <h3 class="fn" id="setState">
<code>[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">setState</span>(<span class="type"><a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::CanBusDeviceState</a></span> <i>newState</i>)
</h3> <p>Sets the state of the device to <i>newState</i>. CAN bus implementations must use this function to update the device state.</p> <p><b>See also </b><a href="qcanbusdevice.html#state">state</a>().</p>   <h3 class="fn" id="state">
<span class="type"><a href="qcanbusdevice.html#CanBusDeviceState-enum">QCanBusDevice::CanBusDeviceState</a></span> QCanBusDevice::<span class="name">state</span>() const
</h3> <p>Returns the current state of the device.</p> <p><b>See also </b><a href="qcanbusdevice.html#setState">setState</a>() and <a href="qcanbusdevice.html#stateChanged">stateChanged</a>().</p>   <h3 class="fn" id="waitForFramesReceived">
<code>[virtual] </code><span class="type">bool</span> QCanBusDevice::<span class="name">waitForFramesReceived</span>(<span class="type">int</span> <i>msecs</i>)
</h3> <p>Blocks until new frames are available for reading and the <a href="qcanbusdevice.html#framesReceived">framesReceived</a>() signal has been emitted, or until <i>msecs</i> milliseconds have passed. If <i>msecs</i> is <code>-1</code>, this function will not time out.</p> <p>Returns <code>true</code> if new frames are available for reading and the <a href="qcanbusdevice.html#framesReceived">framesReceived</a>() signal is emitted; otherwise returns <code>false</code> (if the operation timed out or if an error occurred).</p> <div class="admonition note"> <p><b>Note: </b>This function will start a local event loop. This may lead to scenarios whereby other application slots may be called while the execution of this function scope is blocking. To avoid problems, the signals for this class should not be connected to slots. Similarly this function must never be called in response to the <a href="qcanbusdevice.html#framesReceived">framesReceived</a>() or <a href="qcanbusdevice.html#errorOccurred">errorOccurred</a>() signals.</p> </div> <p><b>See also </b><a href="qcanbusdevice.html#waitForFramesWritten">waitForFramesWritten</a>().</p>   <h3 class="fn" id="waitForFramesWritten">
<code>[virtual] </code><span class="type">bool</span> QCanBusDevice::<span class="name">waitForFramesWritten</span>(<span class="type">int</span> <i>msecs</i>)
</h3> <p>For buffered devices, this function waits until all buffered frames have been written to the device and the <a href="qcanbusdevice.html#framesWritten">framesWritten</a>() signal has been emitted, or until <i>msecs</i> milliseconds have passed. If <i>msecs</i> is -1, this function will not time out. For unbuffered devices, it returns immediately with <code>false</code> as <a href="qcanbusdevice.html#writeFrame">writeFrame</a>() does not require a write buffer.</p> <p>Returns <code>true</code> if the <a href="qcanbusdevice.html#framesWritten">framesWritten</a>() signal is emitted; otherwise returns <code>false</code> (i.e. if the operation timed out, or if an error occurred).</p> <div class="admonition note"> <p><b>Note: </b>This function will start a local event loop. This may lead to scenarios whereby other application slots may be called while the execution of this function scope is blocking. To avoid problems, the signals for this class should not be connected to slots. Similarly this function must never be called in response to the <a href="qcanbusdevice.html#framesWritten">framesWritten</a>() or <a href="qcanbusdevice.html#errorOccurred">errorOccurred</a>() signals.</p> </div> <p><b>See also </b><a href="qcanbusdevice.html#waitForFramesReceived">waitForFramesReceived</a>().</p>   <h3 class="fn" id="writeFrame">
<code>[pure virtual] </code><span class="type">bool</span> QCanBusDevice::<span class="name">writeFrame</span>(const <span class="type"><a href="qcanbusframe.html">QCanBusFrame</a></span> &amp;<i>frame</i>)
</h3> <p>Writes <i>frame</i> to the CAN bus and returns <code>true</code> on success; otherwise <code>false</code>.</p> <p>On some platforms, the frame may be put into a queue and the return value may only indicate a successful insertion into the queue. The actual frame will be send later on. Therefore the <a href="qcanbusdevice.html#framesWritten">framesWritten</a>() signal is the final confirmation that the frame has been handed off to the transport layer. If an error occurs the <a href="qcanbusdevice.html#errorOccurred">errorOccurred</a>() is emitted.</p> <p>As per CAN bus specification, frames of type <a href="qcanbusframe.html#FrameType-enum">remote transfer request (RTR)</a> do not have a payload, but a length from 0 to 8 (including). This length indicates the expected response payload length from the remote party. Therefore when sending a RTR frame using this function it may still be required to set an arbitrary payload on <i>frame</i>. The length of the arbitrary payload is what is set as size expectation for the RTR frame.</p> <p><b>See also </b><a href="qcanbusframe.html#setPayload">QCanBusFrame::setPayload</a>().</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qcanbusdevice.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qcanbusdevice.html</a>
  </p>
</div>
