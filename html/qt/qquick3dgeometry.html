<h1 class="title">QQuick3DGeometry Class</h1>  <p>Base class for defining custom geometry. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QQuick3DGeometry&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.15</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Instantiated By:</td>
<td class="memItemRight bottomAlign"> <a href="qml-qtquick3d-geometry.html">Geometry</a>
</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qquick3dobject.html">QQuick3DObject</a>
</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qquick3dgeometry-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#addAttribute">addAttribute</a></b>(Attribute::Semantic <i>semantic</i>, int <i>offset</i>, Attribute::ComponentType <i>componentType</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#addAttribute-1">addAttribute</a></b>(const QQuick3DGeometry::Attribute &amp;<i>attribute</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuick3DGeometry::Attribute </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#attribute">attribute</a></b>(int <i>index</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#attributeCount">attributeCount</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVector3D </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#boundsMax">boundsMax</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVector3D </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#boundsMin">boundsMin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#clear">clear</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArray </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#indexData">indexData</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuick3DGeometry::PrimitiveType </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#primitiveType">primitiveType</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#setBounds">setBounds</a></b>(const QVector3D &amp;<i>min</i>, const QVector3D &amp;<i>max</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#setIndexData">setIndexData</a></b>(const QByteArray &amp;<i>data</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#setIndexData-1">setIndexData</a></b>(int <i>offset</i>, const QByteArray &amp;<i>data</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#setPrimitiveType">setPrimitiveType</a></b>(QQuick3DGeometry::PrimitiveType <i>type</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#setStride">setStride</a></b>(int <i>stride</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#setVertexData">setVertexData</a></b>(const QByteArray &amp;<i>data</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#setVertexData-1">setVertexData</a></b>(int <i>offset</i>, const QByteArray &amp;<i>data</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#stride">stride</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArray </td>
<td class="memItemRight bottomAlign">
<b><a href="qquick3dgeometry.html#vertexData">vertexData</a></b>() const</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>The QQuick3DGeometry can be used to specify custom geometry for a Model in the Qt Quick 3D scene.</p> <p>While not strictly required, the typical usage is to inherit from this class. The subclass is then exposed to QML by registering it to the type system. The <a href="qml-qtquick3d-model.html#geometry-prop">geometry</a> property of a Model can then be set to reference an instance of the registered type.</p> <p>The high-level structure of such a class is typically similar to the following:</p> <pre data-language="cpp">class CustomGeometry : public QQuick3DGeometry
{
public:
    CustomGeometry() { rebuildGeometry(); }

    void setSomething() {
       // Change relevant internal data.
       // ...

       // Then rebuild the vertex and index data and pass it to QQuick3DGeometry.
       rebuildGeometry();

       // Finally, trigger an update. This is relevant in case nothing else
       // is changing in the scene; this way we make sure a new frame will
       // be rendered.
       update();
    }

private:
    void rebuildGeometry()
    {
        QByteArray vertices;
        QByteArray indices;
        ...
        setPrimitiveType(Lines);
        setVertexBuffer(vertices);
        setIndexBuffer(indices);
        setStride(3 * sizeof(float)); // e.g. when having 3 components per vertex
        setBounds(...); // minimum and maximum extents, for picking
        addAttribute(PositionSemantic, 0, F32Type);
        ...
    }
};</pre> <p>This class can then be registered as a QML type and used with <a href="qml-qtquick3d-model.html">Model</a>.</p> <p>In Qt 5 type registration happened with <a href="qqmlengine.html#qmlRegisterType-1">qmlRegisterType</a>:</p> <pre data-language="cpp">qmlRegisterType&lt;CustomGeometry&gt;("Example", 1, 0, "CustomGeometry");</pre> <p>In Qt 6 the default approach is to use automatic registration with the help of the build system. Instead of calling <a href="qqmlengine.html#qmlRegisterType-1">qmlRegisterType</a>, the <code>.pro</code> file can now contain:</p> <pre data-language="cpp">CONFIG += qmltypes
QML_IMPORT_NAME = Example
QML_IMPORT_MAJOR_VERSION = 1</pre> <p>With CMake, automatic registration is the default behavior, so no special settings are needed beyond basic QML module setup:</p> <pre data-language="cpp">qt_add_qml_module(application
    URI Example
    VERSION 1.0
)</pre> <p>The class implementation should add <a href="qqmlengine.html#QML_NAMED_ELEMENT">QML_NAMED_ELEMENT</a>:</p> <pre data-language="cpp">class CustomGeometry : public QQuick3DGeometry
{
    Q_OBJECT
    QML_NAMED_ELEMENT(CustomGeometry)
    ...
};</pre> <p>The QML code can then use the custom type:</p> <pre data-language="cpp">import Example 1.0

Model {
    id: customModel
    geometry: CustomGeometry {
    }
}</pre> <p>At minimum, a custom geometry should have the following specified:</p> <ul> <li>vertex data,</li> <li>vertex stride,</li> <li>primitive type,</li> <li>an attribute with PositionSemantic.</li> </ul> <p>These are sufficient to render the mesh. For indexed drawing, the index buffer data and an attribute with IndexSemantic needs to be specified as well. In order to support picking (input), the class must specify the bounding volume using <a href="qquick3dgeometry.html#setBounds">setBounds</a>(). For proper lighting, an attribute with NormalSemantic is needed. When the material uses texturing, at least one set of UV coordinates must be provided and described in an TexCoord0Semantic or TexCoord1Semantic attribute. Some materials may require tangents and binormals as well.</p> <p>As a concrete, minimal example, the following class would provide geometry for a single triangle:</p> <pre data-language="cpp">class ExampleGeometry : public QQuick3DGeometry
{
    Q_OBJECT
    QML_NAMED_ELEMENT(ExampleGeometry)

public:
    ExampleGeometry();

private:
    void updateData();
};

ExampleGeometry::ExampleGeometry()
{
    updateData();
}

void ExampleGeometry::updateData()
{
    QByteArray v;
    v.resize(3 * 3 * sizeof(float));
    float *p = reinterpret_cast&lt;float *&gt;(v.data());

    // a triangle, front face = counter-clockwise
    *p++ = -1.0f; *p++ = -1.0f; *p++ = 0.0f;
    *p++ = 1.0f; *p++ = -1.0f; *p++ = 0.0f;
    *p++ = 0.0f; *p++ = 1.0f; *p++ = 0.0f;

    setVertexData(v);
    setStride(3 * sizeof(float));

    setPrimitiveType(QQuick3DGeometry::PrimitiveType::Triangles);

    addAttribute(QQuick3DGeometry::Attribute::PositionSemantic,
                 0,
                 QQuick3DGeometry::Attribute::F32Type);
}</pre> <p>Depending on the lighting in the scene, the result of referencing this geometry from a Model:</p> <p class="centerAlign"><img alt="" src="data:image/jpeg;base64,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"></p>
<div class="admonition note"> <p><b>Note: </b>Vertex data is expected to follow OpenGL conventions. This means the data must be provided with the assumption that the Y axis is pointing up in the normalized device coordinate system, and that front faces have a counter clockwise winding.</p> </div>  <p><b>See also </b><a href="qml-qtquick3d-model.html">Model</a> and <a href="quick3d-asset-conditioning-3d-assets.html#geometry">Geometry</a>.</p>   <h2>Member Function Documentation</h2>  <h3 class="fn" id="addAttribute">
<span class="type">void</span> QQuick3DGeometry::<span class="name">addAttribute</span>(<span class="type">Attribute::Semantic</span> <i>semantic</i>, <span class="type">int</span> <i>offset</i>, <span class="type">Attribute::ComponentType</span> <i>componentType</i>)
</h3> <p>Adds vertex attribute description. Each attribute has a <i>semantic</i>, which specifies the usage of the attribute and the number of components it has, an <i>offset</i> from the beginning to the vertex to the attribute location inside a vertex and a <i>componentType</i> specifying the datatype and size of the attribute.</p> <p>The semantic can be one of the following:</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>PositionSemantic</code></td>
<td class="topAlign">The attribute is a position. 3 components: <i>x</i>, <i>y</i>, and <i>z</i>
</td>
</tr> <tr>
<td class="topAlign"><code>NormalSemantic</code></td>
<td class="topAlign">The attribute is a normal vector. 3 components: <i>x</i>, <i>y</i>, and <i>z</i>
</td>
</tr> <tr>
<td class="topAlign"><code>TexCoord0Semantic</code></td>
<td class="topAlign">The attribute is a texture coordinate. 2 components: <i>u</i> and <i>v</i>
</td>
</tr> <tr>
<td class="topAlign"><code>TexCoord1Semantic</code></td>
<td class="topAlign">The attribute is a texture coordinate. 2 components: <i>u</i> and <i>v</i>
</td>
</tr> <tr>
<td class="topAlign"><code>TangentSemantic</code></td>
<td class="topAlign">The attribute is a tangent vector. 3 components: <i>x</i>, <i>y</i>, and <i>z</i>
</td>
</tr> <tr>
<td class="topAlign"><code>BinormalSemantic</code></td>
<td class="topAlign">The attribute is a binormal vector. 3 components: <i>x</i>, <i>y</i>, and <i>z</i>
</td>
</tr> <tr>
<td class="topAlign"><code>JointSemantic</code></td>
<td class="topAlign">The attribute is a joint index vector for <a href="quick3d-vertex-skinning.html">skinning</a>. 4 components: joint index 1-4</td>
</tr> <tr>
<td class="topAlign"><code>WeightSemantic</code></td>
<td class="topAlign">The attribute is a weight vector for <a href="quick3d-vertex-skinning.html">skinning</a>. 4 components: joint weight 1-4</td>
</tr> <tr>
<td class="topAlign"><code>ColorSemantic</code></td>
<td class="topAlign">The attribute is a vertex color vector. 4 components: <i>r</i>, <i>g</i>, <i>b</i>, and <i>a</i>
</td>
</tr> <tr>
<td class="topAlign"><code>TargetPositionSemantic</code></td>
<td class="topAlign">The attribute is a position for the first <a href="quick3d-morphing.html">morph target</a>. 3 components: <i>x</i>, <i>y</i>, and <i>z</i>
</td>
</tr> <tr>
<td class="topAlign"><code>TargetNormalSemantic</code></td>
<td class="topAlign">The attribute is a normal vector for the first <a href="quick3d-morphing.html">morph target</a>. 3 components: <i>x</i>, <i>y</i>, and <i>z</i>
</td>
</tr> <tr>
<td class="topAlign"><code>TargetTangentSemantic</code></td>
<td class="topAlign">The attribute is a tangent vector for the first <a href="quick3d-morphing.html">morph target</a>. 3 components: <i>x</i>, <i>y</i>, and <i>z</i>
</td>
</tr> <tr>
<td class="topAlign"><code>TargetBinormalSemantic</code></td>
<td class="topAlign">The attribute is a binormal vector for the first <a href="quick3d-morphing.html">morph target</a>. 3 components: <i>x</i>, <i>y</i>, and <i>z</i>
</td>
</tr> </table> <p>In addition, <i>semantic</i> can be <code>IndexSemantic</code>. In this case the attribute does not represent an entry in the vertex buffer, but rather describes the index data in the index buffer. Since there is always just one index per vertex, <i>offset</i> makes no sense for the index buffer, and should be left at zero.</p> <p>The component type can be one of the following:</p> <table class="valuelist">
<tr class="even" valign="top">
<th class="tblConst">Constant</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>U16Type</code></td>
<td class="topAlign">The attribute is an unsigned 16-bit integer.</td>
</tr> <tr>
<td class="topAlign"><code>U32Type</code></td>
<td class="topAlign">The attribute is an unsigned 32-bit integer.</td>
</tr> <tr>
<td class="topAlign"><code>I32Type</code></td>
<td class="topAlign">The attribute is a signed 32-bit integer.</td>
</tr> <tr>
<td class="topAlign"><code>F32Type</code></td>
<td class="topAlign">The attribute is a single-precision float.</td>
</tr> </table> <div class="admonition note"> <p><b>Note: </b>The joint index data is typically <code>I32Type</code>. <code>F32Type</code> is also supported in order to enable functioning with APIs, such as OpenGL ES 2.0, that do not support integer vertex input attributes.</p> </div>   <h3 class="fn" id="addAttribute-1">
<span class="type">void</span> QQuick3DGeometry::<span class="name">addAttribute</span>(const <span class="type">QQuick3DGeometry::Attribute</span> &amp;<i>attribute</i>)
</h3> <p>This is an overloaded function.</p> <p>Adds vertex attribute description. Each attribute has a semantic, which specifies the usage of the attribute and the number of components it has, an offset from the beginning to the vertex to the attribute location inside a vertex and a componentType specifying the datatype and size of the attribute.</p>   <h3 class="fn" id="attribute">
<span class="type">QQuick3DGeometry::Attribute</span> QQuick3DGeometry::<span class="name">attribute</span>(<span class="type">int</span> <i>index</i>) const
</h3> <p>Returns attribute definition number <i>index</i></p> <p>The attribute definitions are numbered from 0 to <code>attributeCount() - 1</code></p>   <h3 class="fn" id="attributeCount">
<span class="type">int</span> QQuick3DGeometry::<span class="name">attributeCount</span>() const
</h3> <p>Returns the number of attributes defined for this geometry.</p> <p><b>See also </b><a href="qquick3dgeometry.html#attribute">attribute</a>.</p>   <h3 class="fn" id="boundsMax">
<span class="type"><a href="qvector3d.html">QVector3D</a></span> QQuick3DGeometry::<span class="name">boundsMax</span>() const
</h3> <p>Returns the maximum coordinate of the bounding volume.</p> <p><b>See also </b><a href="qquick3dgeometry.html#setBounds">setBounds</a>.</p>   <h3 class="fn" id="boundsMin">
<span class="type"><a href="qvector3d.html">QVector3D</a></span> QQuick3DGeometry::<span class="name">boundsMin</span>() const
</h3> <p>Returns the minimum coordinate of the bounding volume.</p> <p><b>See also </b><a href="qquick3dgeometry.html#setBounds">setBounds</a>.</p>   <h3 class="fn" id="clear">
<span class="type">void</span> QQuick3DGeometry::<span class="name">clear</span>()
</h3> <p>Resets the geometry to its initial state, clearing previously set vertex and index data as well as attributes.</p>   <h3 class="fn" id="indexData">
<span class="type"><a href="qbytearray.html">QByteArray</a></span> QQuick3DGeometry::<span class="name">indexData</span>() const
</h3> <p>Returns the index buffer data.</p> <p><b>See also </b><a href="qquick3dgeometry.html#setIndexData">setIndexData</a>().</p>   <h3 class="fn" id="primitiveType">
<span class="type">QQuick3DGeometry::PrimitiveType</span> QQuick3DGeometry::<span class="name">primitiveType</span>() const
</h3> <p>Returns the primitive type used when rendering. The default is <code>Triangles</code>.</p> <p><b>See also </b><a href="qquick3dgeometry.html#setPrimitiveType">setPrimitiveType</a>.</p>   <h3 class="fn" id="setBounds">
<span class="type">void</span> QQuick3DGeometry::<span class="name">setBounds</span>(const <span class="type"><a href="qvector3d.html">QVector3D</a></span> &amp;<i>min</i>, const <span class="type"><a href="qvector3d.html">QVector3D</a></span> &amp;<i>max</i>)
</h3> <p>Sets the bounding volume of the geometry to the cube defined by the points <i>min</i> and <i>max</i>. This is used for <a href="qml-qtquick3d-view3d.html#pick-method">picking</a>.</p>   <h3 class="fn" id="setIndexData">
<span class="type">void</span> QQuick3DGeometry::<span class="name">setIndexData</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>data</i>)
</h3> <p>Sets the index buffer to <i>data</i>. To use indexed drawing, add an attribute with <code>IndexSemantic</code></p> <p><b>See also </b><a href="qquick3dgeometry.html#indexData">indexData</a>() and <a href="qquick3dgeometry.html#addAttribute">addAttribute</a>.</p>   <h3 class="fn" id="setIndexData-1">
<span class="type">void</span> QQuick3DGeometry::<span class="name">setIndexData</span>(<span class="type">int</span> <i>offset</i>, const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>data</i>)
</h3> <p>This is an overloaded function.</p> <p>Updates a subset of the index buffer. <i>offset</i> specifies the offset in bytes, <i>data</i> specifies the size and the data.</p> <p>This function will not resize the buffer. If <code>offset + data.size()</code> is greater than the current size of the buffer, the overshooting data will be ignored.</p> <div class="admonition note"> <p><b>Note: </b>The partial update functions for vertex and index data do not offer any guarantee on how such changes are implemented internally. Depending on the underlying implementation, even partial changes may lead to updating the entire graphics resource.</p> </div>   <h3 class="fn" id="setPrimitiveType">
<span class="type">void</span> QQuick3DGeometry::<span class="name">setPrimitiveType</span>(<span class="type">QQuick3DGeometry::PrimitiveType</span> <i>type</i>)
</h3> <p>Sets the primitive type used for rendering to <i>type</i>.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>Points</code></td>
<td class="topAlign">The primitives are points.</td>
</tr> <tr>
<td class="topAlign"><code>LineStrip</code></td>
<td class="topAlign">The primitives are lines in a strip.</td>
</tr> <tr>
<td class="topAlign"><code>Lines</code></td>
<td class="topAlign">The primitives are lines in a list.</td>
</tr> <tr>
<td class="topAlign"><code>TriangleStrip</code></td>
<td class="topAlign">The primitives are triangles in a strip.</td>
</tr> <tr>
<td class="topAlign"><code>TriangleFan</code></td>
<td class="topAlign">The primitives are triangles in a fan. Be aware that triangle fans may not be supported at run time, depending on the underlying graphics API.</td>
</tr> <tr>
<td class="topAlign"><code>Triangles</code></td>
<td class="topAlign">The primitives are triangles in a list.</td>
</tr> </table> <p>The initial value is <code>Triangles</code>.</p> <div class="admonition note"> <p><b>Note: </b>Be aware that triangle fans (TriangleFan) may not be supported at run time, depending on the underlying graphics API. For example, with Direct 3D this topology will not be functional at all.</p> </div> <div class="admonition note"> <p><b>Note: </b>The point size for Points and the line width for Lines and LineStrip are controlled by the <a href="qml-qtquick3d-principledmaterial.html#pointSize-prop">material</a>. Be aware however that sizes other than 1 may not be supported at run time, depending on the underlying graphics API.</p> </div> <p><b>See also </b><a href="qquick3dgeometry.html#primitiveType">primitiveType</a>().</p>   <h3 class="fn" id="setStride">
<span class="type">void</span> QQuick3DGeometry::<span class="name">setStride</span>(<span class="type">int</span> <i>stride</i>)
</h3> <p>Sets the stride of the vertex buffer to <i>stride</i>, measured in bytes. This is the distance between two consecutive vertices in the buffer.</p> <p>For example, a tightly packed, interleaved vertex buffer for a geometry using <code>PositionSemantic</code>, <code>IndexSemantic</code>, and <code>ColorSemantic</code> will have a stride of <code>28</code> (Seven floats in total: Three for position, four for color, and none for indexes, which do not go in the vertex buffer.)</p> <div class="admonition note"> <p><b>Note: </b><a href="qquick3dgeometry.html">QQuick3DGeometry</a> expects, and works only with, vertex data with an interleaved attribute layout.</p> </div> <p><b>See also </b><a href="qquick3dgeometry.html#stride">stride</a>() and <a href="qquick3dgeometry.html#addAttribute">addAttribute</a>.</p>   <h3 class="fn" id="setVertexData">
<span class="type">void</span> QQuick3DGeometry::<span class="name">setVertexData</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>data</i>)
</h3> <p>Sets the vertex buffer <i>data</i>. The buffer should hold all the vertex data packed in the array, as described by the attribute definitions. Note that this does not include attributes with <code>IndexSemantic</code>, which belong in the index buffer.</p> <p><b>See also </b><a href="qquick3dgeometry.html#vertexData">vertexData</a>(), <a href="qquick3dgeometry.html#addAttribute">addAttribute</a>, <a href="qquick3dgeometry.html#setStride">setStride</a>, and <a href="qquick3dgeometry.html#setIndexData">setIndexData</a>.</p>   <h3 class="fn" id="setVertexData-1">
<span class="type">void</span> QQuick3DGeometry::<span class="name">setVertexData</span>(<span class="type">int</span> <i>offset</i>, const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>data</i>)
</h3> <p>This is an overloaded function.</p> <p>Updates a subset of the vertex buffer. <i>offset</i> specifies the offset in bytes, <i>data</i> specifies the size and the data.</p> <p>This function will not resize the buffer. If <code>offset + data.size()</code> is greater than the current size of the buffer, the overshooting data will be ignored.</p> <div class="admonition note"> <p><b>Note: </b>The partial update functions for vertex and index data do not offer any guarantee on how such changes are implemented internally. Depending on the underlying implementation, even partial changes may lead to updating the entire graphics resource.</p> </div>   <h3 class="fn" id="stride">
<span class="type">int</span> QQuick3DGeometry::<span class="name">stride</span>() const
</h3> <p>Returns the byte stride of the vertex buffer.</p> <p><b>See also </b><a href="qquick3dgeometry.html#setStride">setStride</a>.</p>   <h3 class="fn" id="vertexData">
<span class="type"><a href="qbytearray.html">QByteArray</a></span> QQuick3DGeometry::<span class="name">vertexData</span>() const
</h3> <p>Returns the vertex buffer data set by <a href="qquick3dgeometry.html#setVertexData">setVertexData</a>.</p> <p><b>See also </b><a href="qquick3dgeometry.html#setVertexData">setVertexData</a>().</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qquick3dgeometry.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qquick3dgeometry.html</a>
  </p>
</div>
