<h1 class="title">Qt for WebAssembly</h1>   <p>WebAssembly (or Wasm) is a binary bytecode format intended to be executed in a virtual machine inside a web browser. This allows an application to be deployed to a device with a compliant web browser without going through any installation steps. The application will run inside a secure sandbox in the web browser. This format is nearly as fast as native machine code, and is now supported by all major web browsers. This makes it appropriate for applications that do not need full access to the device capabilities, but benefits from a swift and uncomplicated installation process.</p> <p>Qt for WebAssembly is a <a href="qpa.html">platform plugin</a> that lets you build Qt applications, which can be integrated into your web pages. It doesn't require any client-side installations and reduces the server-side resource usage.</p> <div class="admonition note"> <p><b>Note: </b>Qt for WebAssembly is currently in Tech Preview.</p> </div> <h2 id="getting-started-with-qt-for-webassembly">Getting Started with Qt for WebAssembly
</h2> <h3 id="install-emscripten">Install Emscripten
</h3> <p><a href="https://emscripten.org/docs/introducing_emscripten/index.html">emscripten</a> is a toolchain for compiling to WebAssembly. It lets you run Qt on the web at near-native speed without plugins.</p> <p>Refer to the <a href="https://emscripten.org/docs/getting_started/index.html">emscripten documentation</a> for more information about installing the Emscripten SDK.</p> <p>After installation, you should have the Emscripten compiler in your path. Check this with the following command:</p> <pre data-language="cpp">em++ --version</pre> <p>Each Qt minor version targets a specific minimum Emcsripten version, which will not change for the lifetime of that Qt minor version. Qt's binary packages are built using this version of the Emscripten SDK. We recommend installing the minimum Emcsripten version corresponding to the Qt version you are using, especially if you are using the binary pckages.</p> <p>Newer versions of Emscripten above the minimum version may work (and often do), but may introduce behavior changes which require changes to Qt.</p> <p>The minimum versions are:</p> <ul> <li>Qt 6.2.0: 2.0.14</li> </ul> <p>Use <code>emsdk</code> to install specific <code>emscripten</code> versions. For example, to install it for Qt 6.2 enter:</p> <ul> <li>./emsdk install 2.0.14</li> <li>./emsdk activate 2.0.14</li> </ul> <p>After installation, on Windows, you should have emscripten in your path. On macOS or Linux you need to add it to your path, like this:</p> <pre data-language="cpp">source /path/to/emsdk/emsdk_env.sh</pre> <p>Check this with the following command:</p> <pre data-language="cpp">em++ --version</pre> <h4 id="download-the-binaries">Download the binaries
</h4> <p>The binary builds can be downloaded in the Downloads section using your Qt account.</p> <h4 id="build-qt-from-the-sources">Build Qt from the sources
</h4> <p>Alternatively, you could download the Qt sources in the Downloads section, and build Qt from it.</p> <p>Configure Qt as a cross-compile build for the <code>wasm-emscripten</code> platform. This will implicitly set the <code>-static</code>, <code>-no-feature-thread</code>, and <code>-no-make examples</code> configure options. Thread support and building of the examples can be enabled by removing the corresponding disabling option. Shared library builds are not supported at this time.</p> <p>For Qt 6, you will need a host build of the same version of Qt and add that path to QT_HOST_PATH by using the <code>-qt-host-path</code> configure argument.</p> <p>Although it should be detected, you may optionally set the CMAKE_TOOLCHAIN_PATH to the Emscripten.cmake toolchain file that comes with Emscripten sdk, by using the -DCMAKE_TOOLCHAIN_FILE= configure argument.</p> <pre data-language="cpp">./configure -qt-host-path /path/to/Qt/6.2.0/platform -xplatform wasm-emscripten -prefix $PWD/qtbase</pre> <p>On Windows, make sure you have <code>MinGW</code> in your <code>PATH</code> and configure with the following:</p> <pre data-language="cpp">configure -qt-host-path C:\Path\to\Qt6 -no-warnings-are-errors -xplatform wasm-emscripten -platform win32-g++ -prefix %CD%\qtbase</pre> <p>Build required modules:</p> <pre data-language="cpp">cmake --build . -t qtbase -t qtdeclarative [-t another_module]</pre> <h4 id="build-and-run-your-application">Build and run your application
</h4> <pre data-language="cpp">$ /path/to/qt-wasm/qtbase/bin/qt-cmake
$ make</pre> <p>This generates the following files:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Generated file</th>
<th>Brief Description</th>
</tr></thead> <tr class="odd" valign="top">
<td>app.html</td>
<td>HTML container</td>
</tr> <tr class="even" valign="top">
<td>qtloader.js</td>
<td>JS API for loading Qt apps</td>
</tr> <tr class="odd" valign="top">
<td>app.js</td>
<td>JS API for loading Qt apps</td>
</tr> <tr class="even" valign="top">
<td>app.wasm</td>
<td>emscripten app binary</td>
</tr> </table> <p>When deploying the app, the compression is typically handled on the server side. We recommend to compress the wasm binaries because this typically reduces the size of the binary by 50 %.</p> <h4 id="additional-configuration">Additional configuration
</h4> <p>Qt for Webassembly has several additional configuration arguments available.</p> <table class="generic"> <thead><tr class="qt-style">
<th>Configure Argument</th>
<th>Brief Description</th>
</tr></thead> <tr class="odd" valign="top">
<td>-sse2</td>
<td>This enables autovectorization and Wasm SIMD support by adding the compiler argument -msimd128. In addition, emulated and native optcode SSE instructions are utilized (at which point Qt's SSE code paths will also be used). SSE1, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, and 128-bit AVX instructions only. Simd support may need to be enabled in browsers advanced configurations, such as 'about:config' or 'chrome:flags'. There may be performance issues when used with certain SIMD instructions that are emulated and that have no native optcode supported by the browser. For more information see https://emscripten.org/docs/porting/simd.html</td>
</tr> <tr class="even" valign="top">
<td>-feature-thread</td>
<td>Multi-threaded wasm</td>
</tr> <tr class="odd" valign="top">
<td>-device-option QT_WASM_SOURCE_MAP=1</td>
<td>Debugging option for creating source maps</td>
</tr> <tr class="even" valign="top">
<td>-feature-opengles3</td>
<td>Use opengles3 in addition to the default opengles2</td>
</tr> </table> <h2 id="test-run-your-application">Test-run your application
</h2> <p>You can test-run your application in the following way:</p> <pre data-language="cpp">/path/to/emscripten/emrun --browser=firefox appname.html</pre> <h2 id="supported-target-browsers-and-devices">Supported target browsers and devices
</h2> <h3 id="desktop">Desktop
</h3> <ul> <li>Chrome</li> <li>Firefox</li> <li>Safari</li> <li>Edge(Chrome)</li> </ul> <p>If the browser supports WebAssembly, then Qt should run.</p> <div class="admonition note"> <p><b>Note: </b>Qt has a fixed WebGL requirement, also for apps that do not use WebGL directly. Browsers often blacklist WebGL for older/unsupported GPUs.</p> </div> <h3 id="mobile">Mobile
</h3> <ul> <li>Android Chrome Browser</li> <li>iPhone / iPad Mobile Safari</li> </ul> <div class="admonition note"> <p><b>Note: </b>There is currently no support for text input using the virtual keyboard. Safari currently does not support wasm modules of the size Qt produces.</p> </div> <p>Qt does not make direct use of operating system features and it makes no difference if, for example, FireFox runs on Windows or macOS. Qt does use some operating system adaptations, for example for ctrl/cmd key handling on macOS.</p> <h2 id="supported-qt-modules">Supported Qt Modules
</h2> <p>Qt for WebAssembly supports a subset of the Qt modules and features. The list below lists the currently tested modules.</p> <ul> <li>QtBase (see section for limitations below)</li> <li><a href="https://doc.qt.io/qt-6.2/qtshadertools-module.html">QtShaderTools</a></li> <li>QtDeclarative (see section for limitations below)</li> <li><a href="https://doc.qt.io/qt-6.2/qtquickcontrols2-module.html">QtQuickControls2</a></li> <li><a href="https://doc.qt.io/qt-6.2/qtwebsockets-qmlmodule.html">QtWebSockets</a></li> <li>QQtSvg</li> <li><a href="https://doc.qt.io/qt-6.2/qtmqtt-module.html">QtMqtt</a></li> </ul> <h3 id="other-modules-are-untested-and-may-or-may-not-work">Other modules are untested and may or may not work.
</h3> <p>Note that changes and updates to browsers may also change Wasm platform behavior, thus this documentation and listed limitations below may not be up-to-date.</p> <ul> <li>Web browsers get regular updates and they are configurable and extensible, sometimes with surprising side effects for WebAssembly-based applications:<ul> <li>JavaScript blockers may block JavaScript without enabling NoScript. This means that &lt;noscript&gt; content is not displayed, and that the application appears to be stuck at the loading screen.</li> <li>Some ad-blockers block all .wasm files from specific hosts, such as github.com</li> <li>privacy.resistFingerprinting=true (FireFox) disables high-dpi support - the browser will appear to be running on a standard-dpi display.</li> </ul> </li> </ul> <h3 id="qtbase-limitations-and-not-supported-features">QtBase limitations and not supported features
</h3> <h4 id="qtbase-on-opengl-desktop-vulkan-or-metal">QtBase on OpenGL Desktop, Vulkan or Metal
</h4> <ul> <li>WebGL is required, even for applications which do not use OpenGL themselves. All relevant browsers support WebGL, but note that some browsers blacklist certain older GPUs. The Qt loader will detect this and display an error message.</li> <li>Mixing OpenGL and raster content is not supported</li> <li>Child OpenGL windows are not supported. The window compositor (in the Qt for Wasm platform plugin) supports raster windows only.</li> <li>
<a href="qopenglwidget.html">QOpenGLWidget</a> is not supported: QTBUG-66944</li> <li>Qt will detect OpenGL support as OpenGL ES. In reality the browser will be providing WebGL. WebGL 1.0 is based on OpenGL ES 2, and WebGL 2.0 based on OpenGL ES 3 are very similar, but there are some incompatibilities. See <a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/#6">WebGL and OpenGL Differences</a> There are additional differences between WebGL 1.0 and WebGL 2.0 which are documented in: <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0">WebGL 2.0 Specification</a>
</li> </ul> <h4 id="multithreading-with-qthread-qconcurrent-qfuture-as-part-of-qtbase">Multithreading with QThread, QConcurrent, QFuture as part of QtBase
</h4> <p>Threads on Qt for WebAssembly are not officially supported yet and may not work exactly like posix threads do. Refer to <a href="https://emscripten.org/docs/porting/pthreads.html">Pthreads Support</a>.</p> <p>Qt on WebAssembly can run multithreads, however support is disabled by default in order to be compatible with as many browsers as possible. Thread support can be enabled by building Qt from source and using the "-feature-thread" configure flag.</p> <p>The Qt for WebAssembly binary release packages do not support multithreading.</p> <p>The minimum Emscripten SDK version is 1.38.30. The Emscripten pthreads documentation contains relevant documentation for multithreading.</p> <p>Threads are supported by some (but not all) browsers. Configuration changes may be required. The [1] demo can be used to determine if thread support is available. Note that it is the build mode which determines if browser thread support is required, not whether the application starts a thread or not.</p> <p>In Firefox versions before 79, open about:config and make sure the following option is enabled:</p> <ul> <li>javascript.options.shared_memory = true</li> </ul> <p>Thread support will only be enabled provided that that the web server sets two additional headers:</p> <ul> <li>Cross-Origin-Opener-Policy: same-origin</li> <li>Cross-Origin-Embedder-Policy: require-corp</li> </ul> <p>(These are the COOP and COEP headers, respectively)</p> <p>Mozilla bug 1619649 tracks the Firefox defaults change. In the mean time, its possible to manually bypass or enable the header check:</p> <p>Firefox Nightly or Beta - bypass header check:</p> <ul> <li>dom.postMessage.sharedArrayBuffer.bypassCOOP_COEP.insecure.enabled = true</li> </ul> <p>Firefox Release - enable header check:</p> <ul> <li>browser.tabs.remote.useCrossOriginEmbedderPolicy = true</li> <li>browser.tabs.remote.useCrossOriginOpenerPolicy = true</li> </ul> <p>After enabling the header check, make sure your web server sets the required headers. See <a href="https://bugreports.qt.io/browse/QTBUG-79087">QTBUG-79087</a> for an example python-based development server.</p> <h5 id="https-bugreports-qt-io-browse-qtbug-79087">https://bugreports.qt.io/browse/QTBUG-79087
</h5> <p>Application developers may need to add two settings to its .pro or CMakeFiles.txt file when enabling threads:</p> <ul> <li>Thread Pool Size: Applications should set the expected number of concurrent threads at build time. This can be done by setting QT_WASM_PTHREAD_POOL_SIZE in the .pro or CMakeFIles.txt file (maps to Emscripten PTHREAD_POOL_SIZE). Applications can exceed PTHREAD_POOL_SIZE, provided they return main thread control to the browser before waiting on the new thread, for example by returning from the event handler that started the new thread. This allows the browser to start another web worker. Immediately waiting for the new thread on the main thread (using <a href="qthread.html#wait">QThread::wait</a>() or similar) will deadlock. Qt sets PTHREAD_POOL_SIZE to 4 by default.</li> <li>Heap Memory Size: Applications should set the heap memory size at build time, since growing the heap is not supported with pthreads enabled. This can be be done by setting QT_WASM_INITIAL_MEMORY in the CMakeFiles.txt file (maps to Emscripten INITIAL_MEMORY). Browsers typically limit the initial WASM memory allocation size to 1GB. Qt sets INITIAL_MEMORY to 1GB by default (for -feature-thread enabled builds)</li> </ul> <p>Using cmake, such as:</p> <pre data-language="cpp">set(QT_WASM_PTHREAD_POOL_SIZE, 10)</pre> <h4 id="limited-network-access-due-to-web-sandbox">Limited Network access due to web sandbox
</h4> <p>The web sandbox limits network access to a subset of what is available for native apps.</p> <ul> <li>
<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> http requests to the web page origin server, or to a server which supports CORS.</li> <li>
<a href="qwebsocket.html">QWebSocket</a> connections to any host.</li> <li>TCP and UDP socked tunneling using over WebSockets using a websockify server [3].<ul> <li>Websockify v0.8.0 can be used to tunnel TCP connections with QT5.12 but it is <b>MANDATORY</b> to specify the base64 or binary subprotocols before calling <a href="qwebsocket.html#open">QWebSocket::open</a>().</li> </ul> </li> </ul> <h4 id="files-and-local-file-system-access-limited-due-to-the-web-sandbox">Files and local file system access limited due to the web sandbox
</h4> <p>File system access is sandboxed on the web, and this has implications for how the application works with files. The Web platform provides APIs for accessing the local file system in a way which is under user control, as well as APIs for accessing persistent storage. Emscripten and Qt wraps these features and provides APIs which are easier to use from C++ and Qt-based applications.</p> <p>The web platform provides features for accessing local files and persistent storage:</p> <ul> <li>&lt;input type="file"&gt; for showing a native open-file dialog where the user can pick a file.</li> <li>IndexedDB provides persistent local storage (not accessible outside the browser)</li> </ul> <p>Emscripten provides several file systems with a POSIX like API. These include:</p> <ul> <li>the MEMFS ephemeral file system which stores files in-memory</li> <li>the IDBFS persistent file system which stores files using IndexedDB</li> </ul> <p>Emscripten mounts a temporary MEMFS filesystem to "/" at app startup. This means that <a href="qfile.html">QFile</a> can be used, and will read and write files to memory by default. Qt provides other API as well:</p> <ul> <li>
<a href="qsettings.html">QSettings</a> has an IndexedDB-based backend; Note that <a href="qsettings.html">QSettings</a> is asynchronous on WebAssembly. See usage example at [2]</li> <li>
<a href="https://doc.qt.io/qt-5/qfiledialog.html#getOpenFileContent">QFileDialog::getOpenFileContent() </a> opens a native file dialog where the user can pick a file</li> <li>
<a href="https://doc.qt.io/qt-5/qfiledialog.html#saveFileContent">QFileDialog::saveFileContent()</a> saves a file to the local file system via file download}</li> </ul> <h4 id="clipboard-with-only-text-content">Clipboard with only text content
</h4> <p>Qt supports copying and pasting text to the system clipboard but there are browser specific differences you need to take into account in your code.</p> <ul> <li>Browsers that support the Clipboard API are preferred. Note that a requirement for this API is that the web page is served over a secure connection (e.g. https).<ul> <li>Chrome supports the Clipboard API</li> <li>Firefox supports the Clipboard API behind a flag: dom.events.asyncClipboard.dataTransfer</li> </ul> </li> <li>Browsers that will send clipboard events to Qt's canvas element are also supported<ul> <li>This mode supports the CTRL+x/c/v keyboard shortcuts only</li> <li>Ongoing work. Firefox works well, other browsers have some hiccups.</li> <li>text only at this time</li> </ul> </li> </ul> <h4 id="other-qtbase-known-limitations">Other QtBase known limitations
</h4> <ul> <li>Nested event loops are not supported. Applications should not call, for example, <a href="qdialog.html#exec">QDialog::exec</a>() or create a new <a href="qeventloop.html">QEventLoop</a> object.</li> <li>Drag and Drop is not supported</li> <li>Printing is not supported</li> <li>
<a href="qdnslookup.html">QDnsLookup</a> lookups, <a href="qtcpsocket.html">QTcpSocket</a>, <a href="qssl.html">QSsl</a> do not work and are not supported on Wasm due to the platform sandbox</li> <li>Accessibility: Wasm as a platform limits the access to canvas and this cannot be circumvented by Qt. Qt renders application content to a canvas element, and does not use (other) native DOM elements. This means accessibility (screen readers) are not supported and that text inputs won't trigger virtual keyboards.</li> <li>Fonts: Wasm sandbox does not allow access to system fonts. Font files must be distributed with the application, for example in Qt resources or downloading. Qt for WebAssembly itself embeds one such font.</li> <li>High-DPI and scaling: High-DPI rendering is supported, and so is setting the overall UI visual size using the browser zoom feature. Browser font size (and type) settings have no effect on Qt applications.</li> </ul> <h4 id="qtquickcontrols2-known-issues-and-limitations">QtQuickControls2 known issues and limitations
</h4> <p>Known limitations and issues with Qt Quick Controls 2:</p> <ul> <li>There may be artifacts of uninitialized graphics memory on some Qt Quick Controls 2 components, such as checkboxes. This can sometimes be seen on HighDPi displays.</li> <li>Native styles for Windows and macOS are not supported as Wasm as a platform is not providing that capability</li> </ul> <h4 id="debugging-and-profiling">Debugging and profiling
</h4> <p>Wasm debugging is done on browser javascript console, debugging applications on Wasm directly within Qt Creator is not possible.</p> <ul> <li>Qt debug and logging output is printed on the JavaScript console, which can be accessed via browser "Developer Tools" or similar.</li> <li>Source maps for stepping through code, can be created by reconfiguring Qt with the --device-option QT_WASM_SOURCE_MAP=1, and building a debug build.<ul> <li><a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map">https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map</a></li> <li><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/source-maps#source_maps_in_devtools_sources_panel">https://developers.google.com/web/tools/chrome-devtools/javascript/source-maps#source_maps_in_devtools_sources_panel</a></li> </ul> </li> <li>Mobile browsers can use remote debugging<ul> <li><a href="https://developer.mozilla.org/en-US/docs/Tools/Remote_Debugging">https://developer.mozilla.org/en-US/docs/Tools/Remote_Debugging</a></li> <li><a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging">https://developers.google.com/web/tools/chrome-devtools/remote-debugging</a></li> <li><a href="https://developer.apple.com/safari/tools/">https://developer.apple.com/safari/tools/</a></li> </ul> </li> <li>To stop execution on a certain line and popup the browser debugger programmatically, you can add the function emscripten_debugger(); to the application source code.</li> <li>Profiling can be accomplished by using a debug build and the javascript console profiling features. Qt adds --profiling-funcs to the linker arguments in debug builds, which preserve function names in profiling</li> </ul> <h3 id="footprint-and-file-size">Footprint and file size
</h3> <p>Expected footprint (download size): Wasm modules as produced by the compiler can be large, but compress well:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Example</th>
<th>gzip</th>
<th>brotli</th>
</tr></thead> <tr class="odd" valign="top">
<td>helloglwindow (<a href="https://doc.qt.io/qt-6.2/qtcore-module.html">QtCore</a> + <a href="https://doc.qt.io/qt-6.2/qtgui-module.html">QtGui</a>)</td>
<td>2.8M</td>
<td>2.1M</td>
</tr> <tr class="even" valign="top">
<td>wiggly widget (<a href="https://doc.qt.io/qt-6.2/qtcore-module.html">QtCore</a> + <a href="https://doc.qt.io/qt-6.2/qtgui-module.html">QtGui</a> + QtWidgets)</td>
<td>4.3M</td>
<td>3.2M</td>
</tr> <tr class="odd" valign="top">
<td>SensorTag (<a href="https://doc.qt.io/qt-6.2/qtcore-module.html">QtCore</a> + <a href="https://doc.qt.io/qt-6.2/qtgui-module.html">QtGui</a> + QtWidgets + <a href="https://doc.qt.io/qt-6.2/qtquick-module.html">QtQuick</a> + <a href="https://doc.qt.io/qt-6.2/qtcharts-module.html">QtCharts</a>)</td>
<td>8.6M</td>
<td>6.3M</td>
</tr> </table> <p>Compression is typically handled on the web server side, using standard compression features: the server compresses automatically or picks up pre-compressed versions of the files. There's generally no need to have special handling of wasm files.</p> <h5 id="other-known-issues-limitations-and-general-notes">Other known issues, limitations and general notes
</h5> <ul> <li>Supported on all development host systems: Linux, MacOS, and Windows (MinGW)</li> <li>Link time error such as "wasm-ld: error: initial memory too small", requires adjustment of the initial memory size. Use QT_WASM_TOTAL_MEMORY to set the initial size in kb, which must be a multiple of 64KB (65536). In CMakeFiles.txt: set(QT_WASM_TOTAL_MEMORY, xxxxx);</li> <li>To target WebAssembly platform specifically in qmake, use emscripten as the platform name, such as: emscripten { message("Building for WebAssembly") }</li> <li>Open known bugs and issues on Wasm can be found on Qt issue tracking JIRA on this link: <a href="https://bugreports.qt.io/secure/RapidBoard.jspa?rapidView=258&amp;quickFilter=2352">https://bugreports.qt.io/secure/RapidBoard.jspa?rapidView=258&amp;quickFilter=2352</a>
</li> </ul> <h2 id="some-examples">Some examples
</h2> <ul> <li><a href="https://www.qt.io/web-assembly-example-industrial-panel">Industrial Panel Demo</a></li> <li><a href="https://www.qt.io/web-assembly-example-slate">QMainWindow app</a></li> <li><a href="https://www.qt.io/web-assembly-example-gallery">A gallery of available controls in Qt Quick Controls</a></li> <li><a href="https://www.qt.io/web-assembly-example-pizza-shop">Web app for prdering pizzas</a></li> </ul> <h2 id="external-resources">External resources
</h2> <ul> <li><a href="http://blog.qt.io/blog/2018/04/23/beta-qt-webassembly-technology-preview/">Qt for WebAssembly Technology Preview</a></li> <li><a href="http://blog.qt.io/blog/2018/05/22/qt-for-webassembly/">Qt and WebAssembly</a></li> <li><a href="https://wiki.qt.io/Qt_for_WebAssembly">Qt for WebAssembly wiki</a></li> <li><a href="http://blog.qt.io/blog/2018/11/19/getting-started-qt-webassembly/">Getting Started with Qt for WebAssembly</a></li> <li><a href="http://blog.qt.io/blog/2018/06/12/remote-uis-webgl-webassembly/">Remote UIs with WebGL and WebAssembly</a></li> <li><a href="https://webassembly.org">WebAssembly Resource site</a></li> <li><a href="https://emscripten.org/docs/">Emscripten Documentation</a></li> </ul> <h2 id="licenses">Licenses
</h2> <p>Qt for WebAssembly is available under commercial licenses from <a href="http://www.qt.io/about-us/">The Qt Company</a>. In addition, it is available under the <a href="http://www.gnu.org/licenses/gpl-3.0.html">GNU General Public License, version 3</a>. See <a href="https://doc.qt.io/qt-6.2/licensing.html">Qt Licensing</a> for further details.</p>  <p><b>See also </b><a href="https://webassembly.org">WebAssembly Resource site</a>, <a href="http://blog.qt.io/blog/2018/11/19/getting-started-qt-webassembly/">Getting Started with Qt for WebAssembly</a>, and <a href="http://blog.qt.io/blog/2018/06/12/remote-uis-webgl-webassembly/">Remote UIs with WebGL and WebAssembly</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/wasm.html" class="_attribution-link">https://doc.qt.io/qt-6.2/wasm.html</a>
  </p>
</div>
