<h1 class="title">QCborValue Class</h1>  <p>The QCborValue class encapsulates a value in CBOR. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QCborValue&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.12</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qcborvalue-members.html">List of all members, including inherited members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="17-qdoc-commands-thread.html#reentrant">reentrant</a>.</p> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#DiagnosticNotationOption-enum">DiagnosticNotationOption</a></b> { Compact, LineWrapped, ExtendedFormat }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qcborvalue.html#DiagnosticNotationOption-enum">DiagnosticNotationOptions</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#EncodingOption-enum">EncodingOption</a></b> { NoTransformation, UseFloat, UseFloat16, UseIntegers }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qcborvalue.html#EncodingOption-enum">EncodingOptions</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#Type-enum">Type</a></b> { Integer, ByteArray, String, Array, Map, â€¦, Uuid }</td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-24">QCborValue</a></b>(QCborValue &amp;&amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-23">QCborValue</a></b>(const QCborValue &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-21">QCborValue</a></b>(const QUuid &amp;<i>uuid</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-20">QCborValue</a></b>(const QRegularExpression &amp;<i>rx</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-19">QCborValue</a></b>(const QUrl &amp;<i>url</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-18">QCborValue</a></b>(const QDateTime &amp;<i>dt</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-17">QCborValue</a></b>(QCborKnownTags <i>tag</i>, const QCborValue &amp;<i>tv</i> = QCborValue())</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-16">QCborValue</a></b>(QCborTag <i>tag</i>, const QCborValue &amp;<i>tv</i> = QCborValue())</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-15">QCborValue</a></b>(QCborMap &amp;&amp;<i>m</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-14">QCborValue</a></b>(const QCborMap &amp;<i>m</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-13">QCborValue</a></b>(QCborArray &amp;&amp;<i>a</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-12">QCborValue</a></b>(const QCborArray &amp;<i>a</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-10">QCborValue</a></b>(QLatin1String <i>s</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-9">QCborValue</a></b>(QStringView <i>s</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-8">QCborValue</a></b>(const QString &amp;<i>s</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-7">QCborValue</a></b>(const QByteArray &amp;<i>ba</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-6">QCborValue</a></b>(QCborSimpleType <i>st</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-5">QCborValue</a></b>(double <i>d</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-4">QCborValue</a></b>(qint64 <i>i</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-3">QCborValue</a></b>(bool <i>b</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-2">QCborValue</a></b>(std::nullptr_t)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue-1">QCborValue</a></b>(QCborValue::Type <i>t_</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#QCborValue">QCborValue</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-eq-1">operator=</a></b>(QCborValue &amp;&amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-eq">operator=</a></b>(const QCborValue &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#dtor.QCborValue">~QCborValue</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#compare">compare</a></b>(const QCborValue &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isArray">isArray</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isBool">isBool</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isByteArray">isByteArray</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isContainer">isContainer</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isDateTime">isDateTime</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isDouble">isDouble</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isFalse">isFalse</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isInteger">isInteger</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isInvalid">isInvalid</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isMap">isMap</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isNull">isNull</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isRegularExpression">isRegularExpression</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isSimpleType">isSimpleType</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isSimpleType-1">isSimpleType</a></b>(QCborSimpleType <i>st</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isString">isString</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isTag">isTag</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isTrue">isTrue</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isUndefined">isUndefined</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isUrl">isUrl</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#isUuid">isUuid</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#swap">swap</a></b>(QCborValue &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborTag </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#tag">tag</a></b>(QCborTag <i>defaultValue</i> = QCborTag(-1)) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#taggedValue">taggedValue</a></b>(const QCborValue &amp;<i>defaultValue</i> = QCborValue()) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborArray </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toArray">toArray</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborArray </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toArray-1">toArray</a></b>(const QCborArray &amp;<i>defaultValue</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toBool">toBool</a></b>(bool <i>defaultValue</i> = false) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArray </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toByteArray">toByteArray</a></b>(const QByteArray &amp;<i>defaultValue</i> = {}) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArray </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toCbor">toCbor</a></b>(QCborValue::EncodingOptions <i>opt</i> = NoTransformation) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toCbor-1">toCbor</a></b>(QCborStreamWriter &amp;<i>writer</i>, QCborValue::EncodingOptions <i>opt</i> = NoTransformation) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDateTime </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toDateTime">toDateTime</a></b>(const QDateTime &amp;<i>defaultValue</i> = {}) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toDiagnosticNotation">toDiagnosticNotation</a></b>(QCborValue::DiagnosticNotationOptions <i>opts</i> = Compact) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> double </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toDouble">toDouble</a></b>(double <i>defaultValue</i> = 0) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qint64 </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toInteger">toInteger</a></b>(qint64 <i>defaultValue</i> = 0) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QJsonValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toJsonValue">toJsonValue</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toMap">toMap</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toMap-1">toMap</a></b>(const QCborMap &amp;<i>defaultValue</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRegularExpression </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toRegularExpression">toRegularExpression</a></b>(const QRegularExpression &amp;<i>defaultValue</i> = {}) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborSimpleType </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toSimpleType">toSimpleType</a></b>(QCborSimpleType <i>defaultValue</i> = QCborSimpleType::Undefined) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toString">toString</a></b>(const QString &amp;<i>defaultValue</i> = {}) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QUrl </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toUrl">toUrl</a></b>(const QUrl &amp;<i>defaultValue</i> = {}) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QUuid </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toUuid">toUuid</a></b>(const QUuid &amp;<i>defaultValue</i> = {}) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVariant </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#toVariant">toVariant</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue::Type </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#type">type</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-not-eq">operator!=</a></b>(const QCborValue &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-lt">operator&lt;</a></b>(const QCborValue &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-eq-eq">operator==</a></b>(const QCborValue &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-5b-5d">operator[]</a></b>(const QString &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-5b-5d-1">operator[]</a></b>(QLatin1String <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-5b-5d-2">operator[]</a></b>(qint64 <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValueRef </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-5b-5d-3">operator[]</a></b>(qint64 <i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValueRef </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-5b-5d-4">operator[]</a></b>(QLatin1String <i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValueRef </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#operator-5b-5d-5">operator[]</a></b>(const QString &amp;<i>key</i>)</td>
</tr> </table> <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#fromCbor">fromCbor</a></b>(QCborStreamReader &amp;<i>reader</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#fromCbor-1">fromCbor</a></b>(const QByteArray &amp;<i>ba</i>, QCborParserError *<i>error</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#fromCbor-2">fromCbor</a></b>(const char *<i>data</i>, qsizetype <i>len</i>, QCborParserError *<i>error</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#fromCbor-3">fromCbor</a></b>(const quint8 *<i>data</i>, qsizetype <i>len</i>, QCborParserError *<i>error</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#fromJsonValue">fromJsonValue</a></b>(const QJsonValue &amp;<i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborvalue.html#fromVariant">fromVariant</a></b>(const QVariant &amp;<i>variant</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>This class can be used to hold one of the many types available in CBOR. CBOR is the Concise Binary Object Representation, a very compact form of binary data encoding that is a superset of JSON. It was created by the IETF Constrained RESTful Environments (CoRE) WG, which has used it in many new RFCs. It is meant to be used alongside the <a href="https://datatracker.ietf.org/doc/html/rfc7252">CoAP protocol</a>.</p> <p>CBOR has three groups of built-in types:</p> <ul> <li>Basic types: integers, floating point (double), boolean, null, etc.</li> <li>String-like types: strings and byte arrays</li> <li>Containers: arrays and maps</li> </ul> <p>Additionally, CBOR supports a form of type extensibility by associating a "tag" to one of the above types to convey more information. For example, a UUID is represented by a tag and a byte array containing the 16 bytes of the UUID content. QCborValue supports creating and decoding several of those extended types directly with Qt classes (like <a href="quuid.html">QUuid</a>).</p> <p>For the complete list, see <a href="qcborvalue.html#Type-enum">QCborValue::Type</a>. The type of a QCborValue can be queried using <a href="qcborvalue.html#type">type</a>() or one of the "isXxxx" functions.</p> <h3 id="extended-types-and-tagged-values">Extended types and tagged values
</h3> <p>A tagged value is a normal QCborValue that is paired with a number that is its tag. See <a href="qtcborcommon.html#QCborKnownTags-enum">QCborKnownTags</a> for more information on what tags are in the API as well as the full, official list. Such combinations form extended types.</p> <p>QCborValue has support for certain extended types in the API, like URL (with <a href="qurl.html">QUrl</a>) and UUID (with <a href="quuid.html">QUuid</a>). Other extended types not supported in the API are represented by a QCborValue of <a href="qcborvalue.html#Type-enum">Tag</a> type. The tag can later be retrieved by <a href="qcborvalue.html#tag">tag</a>() and the tagged value using <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p> <p>In order to support future compatibility, QCborValues containing extended Qt types compare equal to the tag type of the same contents. In other words, the following expression is true:</p> <pre data-language="cpp">    QCborValue(uuid) == QCborValue(QCborKnownTags::Uuid, uuid.toRfc4122());</pre> <h3 id="undefined-and-null-values">Undefined and null values
</h3> <p>QCborValue can contain a value of "null", which is not of any specific type. It resembles the C++ <code>std::nullptr_t</code> type, whose only possible value is <code>nullptr</code>. QCborValue has a constructor taking such a type and creates a null QCborValue.</p> <p>Null values are used to indicate that an optional value is not present. In that aspect, it is similar to the C++ Standard Library type <code>std::optional</code> when that is disengaged. Unlike the C++ type, CBOR nulls are simply of type "Null" and it is not possible to determine what concrete type it is replacing.</p> <p>QCborValue can also be of the undefined type, which represents a value of "undefined". In fact, that is what the QCborValue default constructor creates.</p> <p>Undefined values are different from null values. While nulls are used to indicate an optional value that is not provided, Undefined is usually used to indicate that an expected value could not be provided, usually due to an error or a precondition that could not be satisfied.</p> <p>Such values are completely valid and may appear in CBOR streams, unlike JSON content and <a href="qjsonvalue.html">QJsonValue</a>'s undefined bit. But like <a href="qjsonvalue.html">QJsonValue</a>'s Undefined, it is returned by a CBOR container's value() or read-only operator[] for invalid look-ups (index out of range for <a href="qcborarray.html">QCborArray</a>, or key not found for <a href="qcbormap.html">QCborMap</a>). It is not possible to tell such a case apart from the value of Undefined, so if that is required, check the <a href="qcborarray.html">QCborArray</a> size and use the <a href="qcbormap.html">QCborMap</a> iterator API.</p> <h3 id="simple-types">Simple types
</h3> <p>CBOR supports additional simple types that, like Null and Undefined, carry no other value. They are called interchangeably "Simple Types" and "Simple Values". CBOR encodes booleans as two distinct types (one for <code>true</code> and one for <code>false</code>), but QCborValue has a convenience API for them.</p> <p>There are currently no other defined CBOR simple types. QCborValue supports them simply by their number with API like <a href="qcborvalue.html#isSimpleType">isSimpleType</a>() and <a href="qcborvalue.html#toSimpleType">toSimpleType</a>(), available for compatibility with future specifications before the Qt API can be updated. Their use before such a specification is discouraged, as other CBOR implementations may not support them fully.</p> <h3 id="cbor-support">CBOR support
</h3> <p>QCborValue supports all CBOR features required to create canonical and strict streams. It implements almost all of the features specified in <a href="https://datatracker.ietf.org/doc/html/rfc7049">RFC 7049</a>.</p> <p>The following table lists the CBOR features that QCborValue supports.</p> <table class="generic"> <thead><tr class="qt-style">
<th>Feature</th>
<th>Support</th>
</tr></thead> <tr class="odd" valign="top">
<td>Unsigned numbers</td>
<td>Yes (<a href="qtglobal.html#qint64-typedef">qint64</a> range)</td>
</tr> <tr class="even" valign="top">
<td>Negative numbers</td>
<td>Yes (<a href="qtglobal.html#qint64-typedef">qint64</a> range)</td>
</tr> <tr class="odd" valign="top">
<td>Byte strings</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Text strings</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Chunked strings</td>
<td>See below</td>
</tr> <tr class="even" valign="top">
<td>Tags</td>
<td>Yes (arbitrary)</td>
</tr> <tr class="odd" valign="top">
<td>Booleans</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Null</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Undefined</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Arbitrary simple values</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Half-precision float (16-bit)</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Single-precision float (32-bit)</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Double-precision float (64-bit)</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Infinities and NaN floating point</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Determinate-length arrays and maps</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Indeterminate-length arrays and maps</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Map key types other than strings and integers</td>
<td>Yes (arbitrary)</td>
</tr> </table> <p>Integers in QCborValue are limited to the range of the <a href="qtglobal.html#qint64-typedef">qint64</a> type. That is, from -9,223,372,036,854,775,808 (-2<sup>63</sup>) to 9,223,372,036,854,775,807 (2<sup>63</sup> - 1). CBOR itself can represent integer values outside of this range, which QCborValue does not support. When decoding a stream using <a href="qcborvalue.html#fromCbor">fromCbor</a>() containing one of those values, QCborValue will convert automatically to <a href="qcborvalue.html#Type-enum">Double</a>, but that may lose up to 11 bits of precision.</p> <p><a href="qcborvalue.html#fromCbor">fromCbor</a>() is able to decode chunked strings, but will always merge the chunks together into a single QCborValue. For that reason, it always writes non-chunked strings when using <a href="qcborvalue.html#toCbor">toCbor</a>() (which is required by the Canonical format anyway).</p> <p>QCborValue will always convert half- and single-precision floating point values in the CBOR stream to double-precision. The <a href="qcborvalue.html#toCbor">toCbor</a>() function can take a parameter indicating to recreate them.</p> <h3 id="qcborvalueref">QCborValueRef
</h3> <p><a href="qcborvalue.html#qcborvalueref">QCborValueRef</a> is a helper class for <a href="qcborarray.html">QCborArray</a> and <a href="qcbormap.html">QCborMap</a>. It is the type you get when using one of the mutating APIs in those classes. Unlike QCborValue, new values can be assigned to that class. When that is done, the array or map it refers to will be modified with the new value. In all other aspects, its API is identical to QCborValue.</p> <p><a href="qjsonvalue.html">QJsonValue</a>, <a href="qjsondocument.html">QJsonDocument</a></p>  <p><b>See also </b><a href="qcborarray.html">QCborArray</a>, <a href="qcbormap.html">QCborMap</a>, <a href="qcborstreamreader.html">QCborStreamReader</a>, and <a href="qcborstreamwriter.html">QCborStreamWriter</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="flags" id="DiagnosticNotationOption-enum">enum QCborValue::<span class="name">DiagnosticNotationOption</span>flags QCborValue::<span class="name">DiagnosticNotationOptions</span>
</h3> <p>This enum is used in the option argument to <a href="qcborvalue.html#toDiagnosticNotation">toDiagnosticNotation</a>(), to modify the output format.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Compact</code></td>
<td class="topAlign tblval"><code>0x00</code></td>
<td class="topAlign">Does not use any line-breaks, producing a compact representation.</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::LineWrapped</code></td>
<td class="topAlign tblval"><code>0x01</code></td>
<td class="topAlign">Uses line-breaks, one <a href="qcborvalue.html">QCborValue</a> per line.</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::ExtendedFormat</code></td>
<td class="topAlign tblval"><code>0x02</code></td>
<td class="topAlign">Uses some different options to represent values, not found in RFC 7049. Those options are subject to change.</td>
</tr> </table> <p>Currently, <code>ExtendedFormat</code> will change how byte arrays are represented. Without it, they are always hex-encoded and without spaces. With it, <a href="qcborvalue.html#toCbor">QCborValue::toCbor</a>() will either use hex with spaces, base64 or base64url encoding, depending on the context.</p> <p>The DiagnosticNotationOptions type is a typedef for <a href="qflags.html">QFlags</a>&lt;DiagnosticNotationOption&gt;. It stores an OR combination of DiagnosticNotationOption values.</p> <p><b>See also </b><a href="qcborvalue.html#toDiagnosticNotation">toDiagnosticNotation</a>().</p>   <h3 class="flags" id="EncodingOption-enum">enum QCborValue::<span class="name">EncodingOption</span>flags QCborValue::<span class="name">EncodingOptions</span>
</h3> <p>This enum is used in the options argument to <a href="qcborvalue.html#toCbor">toCbor</a>(), modifying the behavior of the encoder.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCborValue::NoTransformation</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">(Default) Performs no transformations.</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::UseFloat</code></td>
<td class="topAlign tblval"><code>0x02</code></td>
<td class="topAlign">Tells the encoder to use IEEE 754 single-precision floating point (that is, <code>float</code>) whenever possible.</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::UseFloat16</code></td>
<td class="topAlign tblval"><code>UseFloat | 0x04</code></td>
<td class="topAlign">Tells the encoder to use IEEE 754 half-precision floating point (that is, <code>qfloat16</code>), whenever possible. Implies <code>UseFloat</code>.</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::UseIntegers</code></td>
<td class="topAlign tblval"><code>0x08</code></td>
<td class="topAlign">Tells the encoder to use integers whenever a value of type <a href="qcborvalue.html#Type-enum">Double</a> contains an integer.</td>
</tr> </table> <p>The use of <code>UseFloat16</code> is required to encode the stream in Canonical Format, but is not otherwise necessary.</p> <p>The EncodingOptions type is a typedef for <a href="qflags.html">QFlags</a>&lt;EncodingOption&gt;. It stores an OR combination of EncodingOption values.</p> <p><b>See also </b><a href="qcborvalue.html#toCbor">toCbor</a>().</p>   <h3 class="fn" id="Type-enum">enum QCborValue::<span class="name">Type</span>
</h3> <p>This enum represents the <a href="qcborvalue.html">QCborValue</a> type. It is returned by the <a href="qcborvalue.html#type">type</a>() function.</p> <p>The CBOR built-in types are:</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Integer</code></td>
<td class="topAlign tblval"><code>0x00</code></td>
<td class="topAlign">
<code>qint64</code>: An integer value</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::ByteArray</code></td>
<td class="topAlign tblval"><code>0x40</code></td>
<td class="topAlign">
<a href="qbytearray.html">QByteArray</a>: a byte array ("byte string")</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::String</code></td>
<td class="topAlign tblval"><code>0x60</code></td>
<td class="topAlign">
<a href="qstring.html">QString</a>: a Unicode string ("text string")</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Array</code></td>
<td class="topAlign tblval"><code>0x80</code></td>
<td class="topAlign">
<a href="qcborarray.html">QCborArray</a>: an array of QCborValues</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Map</code></td>
<td class="topAlign tblval"><code>0xa0</code></td>
<td class="topAlign">
<a href="qcbormap.html">QCborMap</a>: an associative container of QCborValues</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::SimpleType</code></td>
<td class="topAlign tblval"><code>0x100</code></td>
<td class="topAlign">
<a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType</a>: one of several simple types/values</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::False</code></td>
<td class="topAlign tblval"><code>SimpleType + int(QCborSimpleType::False)</code></td>
<td class="topAlign">
<code>bool</code>: the simple type for value <code>false</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::True</code></td>
<td class="topAlign tblval"><code>SimpleType + int(QCborSimpleType::True)</code></td>
<td class="topAlign">
<code>bool</code>: the simple type for value <code>true</code>
</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Null</code></td>
<td class="topAlign tblval"><code>SimpleType + int(QCborSimpleType::Null)</code></td>
<td class="topAlign">
<code>std::nullptr_t</code>: the simple type for the null value</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Undefined</code></td>
<td class="topAlign tblval"><code>SimpleType + int(QCborSimpleType::Undefined)</code></td>
<td class="topAlign">(no type) the simple type for the undefined value</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Double</code></td>
<td class="topAlign tblval"><code>0x202</code></td>
<td class="topAlign">
<code>double</code>: a double-precision floating point</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Invalid</code></td>
<td class="topAlign tblval"><code>-1</code></td>
<td class="topAlign">Not a valid value, this usually indicates a CBOR decoding error</td>
</tr> </table> <p>Additionally, <a href="qcborvalue.html">QCborValue</a> can represent extended types:</p> <table class="valuelist">
<tr class="even" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Tag</code></td>
<td class="topAlign tblval"><code>0xc0</code></td>
<td class="topAlign">An unknown or unrecognized extended type, represented by its tag (a <a href="qtcborcommon.html#QCborTag-enum">QCborTag</a>) and the tagged value (a <a href="qcborvalue.html">QCborValue</a>)</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::DateTime</code></td>
<td class="topAlign tblval"><code>0x10000</code></td>
<td class="topAlign">
<a href="qdatetime.html">QDateTime</a>: a date and time stamp</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Url</code></td>
<td class="topAlign tblval"><code>0x10020</code></td>
<td class="topAlign">
<a href="qurl.html">QUrl</a>: a URL or URI</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::RegularExpression</code></td>
<td class="topAlign tblval"><code>0x10023</code></td>
<td class="topAlign">
<a href="qregularexpression.html">QRegularExpression</a>: the pattern of a regular expression</td>
</tr> <tr>
<td class="topAlign"><code>QCborValue::Uuid</code></td>
<td class="topAlign tblval"><code>0x10025</code></td>
<td class="topAlign">
<a href="quuid.html">QUuid</a>: a UUID</td>
</tr> </table> <p><b>See also </b><a href="qcborvalue.html#type">type</a>().</p>    <h2>Member Function Documentation</h2>  <div class="fngroup"> <h3 class="fn fngroupitem" id="fromCbor-2">
<code>[static] </code><span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> QCborValue::<span class="name">fromCbor</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>, <span class="type"><a href="qcborparsererror.html">QCborParserError</a></span> *<i>error</i> = nullptr)
</h3>
<h3 class="fn fngroupitem" id="fromCbor-3">
<code>[static] </code><span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> QCborValue::<span class="name">fromCbor</span>(const <span class="type"><a href="qtglobal.html#quint8-typedef">quint8</a></span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>, <span class="type"><a href="qcborparsererror.html">QCborParserError</a></span> *<i>error</i> = nullptr)
</h3>
</div> <p>This is an overloaded function.</p> <p>Converts <i>len</i> bytes of <i>data</i> to a <a href="qbytearray.html">QByteArray</a> and then calls the overload of this function that accepts a <a href="qbytearray.html">QByteArray</a>, also passing <i>error</i>, if provided.</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="toMap">
<span class="type"><a href="qcbormap.html">QCborMap</a></span> QCborValue::<span class="name">toMap</span>() const
</h3>
<h3 class="fn fngroupitem" id="toMap-1">
<span class="type"><a href="qcbormap.html">QCborMap</a></span> QCborValue::<span class="name">toMap</span>(const <span class="type"><a href="qcbormap.html">QCborMap</a></span> &amp;<i>defaultValue</i>) const
</h3>
</div> <p>Returns the map value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of the map type. Otherwise, it returns <i>defaultValue</i>.</p> <p>Note that this function performs no conversion from other types to <a href="qcbormap.html">QCborMap</a>.</p> <p><b>See also </b><a href="qcborvalue.html#isMap">isMap</a>(), <a href="qcborvalue.html#isArray">isArray</a>(), <a href="qcborvalue.html#isContainer">isContainer</a>(), and <a href="qcborvalue.html#toArray">toArray</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="toArray">
<span class="type"><a href="qcborarray.html">QCborArray</a></span> QCborValue::<span class="name">toArray</span>() const
</h3>
<h3 class="fn fngroupitem" id="toArray-1">
<span class="type"><a href="qcborarray.html">QCborArray</a></span> QCborValue::<span class="name">toArray</span>(const <span class="type"><a href="qcborarray.html">QCborArray</a></span> &amp;<i>defaultValue</i>) const
</h3>
</div> <p>Returns the array value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of the array type. Otherwise, it returns <i>defaultValue</i>.</p> <p>Note that this function performs no conversion from other types to <a href="qcborarray.html">QCborArray</a>.</p> <p><b>See also </b><a href="qcborvalue.html#isArray">isArray</a>(), <a href="qcborvalue.html#isByteArray">isByteArray</a>(), <a href="qcborvalue.html#isMap">isMap</a>(), <a href="qcborvalue.html#isContainer">isContainer</a>(), and <a href="qcborvalue.html#toMap">toMap</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="QCborValue-17">QCborValue::<span class="name">QCborValue</span>(<span class="type"><a href="qtcborcommon.html#QCborKnownTags-enum">QCborKnownTags</a></span> <i>tag</i>, const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;<i>tv</i> = QCborValue())
</h3>
<h3 class="fn fngroupitem" id="QCborValue-16">QCborValue::<span class="name">QCborValue</span>(<span class="type"><a href="qtcborcommon.html#QCborTag-enum">QCborTag</a></span> <i>tag</i>, const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;<i>tv</i> = QCborValue())
</h3>
</div> <p>Creates a <a href="qcborvalue.html">QCborValue</a> for the extended type represented by the tag value <i>tag</i>, tagging value <i>tv</i>. The tag can later be retrieved using <a href="qcborvalue.html#tag">tag</a>() and the tagged value using <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p> <p><b>See also </b><a href="qcborvalue.html#isTag">isTag</a>(), <a href="qcborvalue.html#tag">tag</a>(), <a href="qcborvalue.html#taggedValue">taggedValue</a>(), and <a href="qtcborcommon.html#QCborKnownTags-enum">QCborKnownTags</a>.</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="QCborValue-15">QCborValue::<span class="name">QCborValue</span>(<span class="type"><a href="qcbormap.html">QCborMap</a></span> &amp;&amp;<i>m</i>)
</h3>
<h3 class="fn fngroupitem" id="QCborValue-14">QCborValue::<span class="name">QCborValue</span>(const <span class="type"><a href="qcbormap.html">QCborMap</a></span> &amp;<i>m</i>)
</h3>
</div> <p>Creates a <a href="qcborvalue.html">QCborValue</a> with the map <i>m</i>. The map can later be retrieved using <a href="qcborvalue.html#toMap">toMap</a>().</p> <p><b>See also </b><a href="qcborvalue.html#toMap">toMap</a>(), <a href="qcborvalue.html#isMap">isMap</a>(), and <a href="qcborvalue.html#isArray">isArray</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="QCborValue-13">QCborValue::<span class="name">QCborValue</span>(<span class="type"><a href="qcborarray.html">QCborArray</a></span> &amp;&amp;<i>a</i>)
</h3>
<h3 class="fn fngroupitem" id="QCborValue-12">QCborValue::<span class="name">QCborValue</span>(const <span class="type"><a href="qcborarray.html">QCborArray</a></span> &amp;<i>a</i>)
</h3>
</div> <p>Creates a <a href="qcborvalue.html">QCborValue</a> with the array <i>a</i>. The array can later be retrieved using <a href="qcborvalue.html#toArray">toArray</a>().</p> <p><b>See also </b><a href="qcborvalue.html#toArray">toArray</a>(), <a href="qcborvalue.html#isArray">isArray</a>(), and <a href="qcborvalue.html#isMap">isMap</a>().</p>   <h3 class="fn" id="QCborValue-24">QCborValue::<span class="name">QCborValue</span>(<span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;&amp;<i>other</i>)
</h3> <p>This is an overloaded function.</p> <p>Moves the contents of the <i>other</i> QCborValue object into this one and frees the resources of this one.</p>   <h3 class="fn" id="QCborValue-23">QCborValue::<span class="name">QCborValue</span>(const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;<i>other</i>)
</h3> <p>Copies the contents of <i>other</i> into this object.</p>   <h3 class="fn" id="QCborValue-21">QCborValue::<span class="name">QCborValue</span>(const <span class="type"><a href="quuid.html">QUuid</a></span> &amp;<i>uuid</i>)
</h3> <p>Creates a QCborValue object of the UUID extended type and containing the value represented by <i>uuid</i>. The value can later be retrieved using <a href="qcborvalue.html#toUuid">toUuid</a>().</p> <p>The CBOR UUID type is an extended type represented by a byte array tagged as an <a href="qtcborcommon.html#QCborKnownTags-enum">Uuid</a>.</p> <p><b>See also </b><a href="qcborvalue.html#toUuid">toUuid</a>(), <a href="qcborvalue.html#isUuid">isUuid</a>(), and <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p>   <h3 class="fn" id="QCborValue-20">QCborValue::<span class="name">QCborValue</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>rx</i>)
</h3> <p>Creates a QCborValue object of the regular expression pattern extended type and containing the value represented by <i>rx</i>. The value can later be retrieved using <a href="qcborvalue.html#toRegularExpression">toRegularExpression</a>().</p> <p>The CBOR regular expression type is an extended type represented by a string tagged as an <a href="qtcborcommon.html#QCborKnownTags-enum">RegularExpression</a>. Note that CBOR regular expressions only store the patterns, so any flags that the <a href="qregularexpression.html">QRegularExpression</a> object may carry will be lost.</p> <p><b>See also </b><a href="qcborvalue.html#toRegularExpression">toRegularExpression</a>(), <a href="qcborvalue.html#isRegularExpression">isRegularExpression</a>(), and <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p>   <h3 class="fn" id="QCborValue-19">QCborValue::<span class="name">QCborValue</span>(const <span class="type"><a href="qurl.html">QUrl</a></span> &amp;<i>url</i>)
</h3> <p>Creates a QCborValue object of the URL extended type and containing the value represented by <i>url</i>. The value can later be retrieved using <a href="qcborvalue.html#toUrl">toUrl</a>().</p> <p>The CBOR URL type is an extended type represented by a string tagged as an <a href="qtcborcommon.html#QCborKnownTags-enum">Url</a>.</p> <p><b>See also </b><a href="qcborvalue.html#toUrl">toUrl</a>(), <a href="qcborvalue.html#isUrl">isUrl</a>(), and <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p>   <h3 class="fn" id="QCborValue-18">QCborValue::<span class="name">QCborValue</span>(const <span class="type"><a href="qdatetime.html">QDateTime</a></span> &amp;<i>dt</i>)
</h3> <p>Creates a QCborValue object of the date/time extended type and containing the value represented by <i>dt</i>. The value can later be retrieved using <a href="qcborvalue.html#toDateTime">toDateTime</a>().</p> <p>The CBOR date/time types are extension types using tags: either a string (in ISO date format) tagged as a <a href="qtcborcommon.html#QCborKnownTags-enum">DateTime</a> or a number (of seconds since the start of 1970, UTC) tagged as a <a href="qtcborcommon.html#QCborKnownTags-enum">UnixTime_t</a>. When parsing CBOR streams, QCborValue will convert <a href="qtcborcommon.html#QCborKnownTags-enum">UnixTime_t</a> to the string-based type.</p> <p><b>See also </b><a href="qcborvalue.html#toDateTime">toDateTime</a>(), <a href="qcborvalue.html#isDateTime">isDateTime</a>(), and <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p>   <h3 class="fn" id="QCborValue-10">QCborValue::<span class="name">QCborValue</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>s</i>)
</h3> <p>This is an overloaded function.</p> <p>Creates a QCborValue with string value <i>s</i>. The value can later be retrieved using <a href="qcborvalue.html#toString">toString</a>().</p> <p><b>See also </b><a href="qcborvalue.html#toString">toString</a>(), <a href="qcborvalue.html#isString">isString</a>(), and <a href="qcborvalue.html#isByteArray">isByteArray</a>().</p>   <h3 class="fn" id="QCborValue-9">QCborValue::<span class="name">QCborValue</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>s</i>)
</h3> <p>Creates a QCborValue with string value <i>s</i>. The value can later be retrieved using <a href="qcborvalue.html#toString">toString</a>().</p> <p><b>See also </b><a href="qcborvalue.html#toString">toString</a>(), <a href="qcborvalue.html#isString">isString</a>(), and <a href="qcborvalue.html#isByteArray">isByteArray</a>().</p>   <h3 class="fn" id="QCborValue-8">QCborValue::<span class="name">QCborValue</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>s</i>)
</h3> <p>Creates a QCborValue with string value <i>s</i>. The value can later be retrieved using <a href="qcborvalue.html#toString">toString</a>().</p> <p><b>See also </b><a href="qcborvalue.html#toString">toString</a>(), <a href="qcborvalue.html#isString">isString</a>(), and <a href="qcborvalue.html#isByteArray">isByteArray</a>().</p>   <h3 class="fn" id="QCborValue-7">QCborValue::<span class="name">QCborValue</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>ba</i>)
</h3> <p>Creates a QCborValue with byte array value <i>ba</i>. The value can later be retrieved using <a href="qcborvalue.html#toByteArray">toByteArray</a>().</p> <p><b>See also </b><a href="qcborvalue.html#toByteArray">toByteArray</a>(), <a href="qcborvalue.html#isByteArray">isByteArray</a>(), and <a href="qcborvalue.html#isString">isString</a>().</p>   <h3 class="fn" id="QCborValue-6">QCborValue::<span class="name">QCborValue</span>(<span class="type"><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType</a></span> <i>st</i>)
</h3> <p>Creates a QCborValue of simple type <i>st</i>. The type can later later be retrieved using <a href="qcborvalue.html#toSimpleType">toSimpleType</a>() as well as <a href="qcborvalue.html#isSimpleType">isSimpleType</a>(st).</p> <p>CBOR simple types are types that do not have any associated value, like C++'s <code>std::nullptr_t</code> type, whose only possible value is <code>nullptr</code>.</p> <p>If <i>st</i> is <code>QCborSimpleType::Null</code>, the resulting QCborValue will be of the <a href="qcborvalue.html#Type-enum">Null</a> type and similarly for <code>QCborSimpleType::Undefined</code>. If <i>st</i> is <code>QCborSimpleType::False</code> or <code>QCborSimpleType::True</code>, the created QCborValue will be a boolean containing a value of false or true, respectively.</p> <p>This function can be used with simple types not defined in the API. For example, to create a QCborValue with simple type 12, one could write:</p> <pre data-language="cpp">    QCborValue value(QCborSimpleType(12));</pre> <p>Simple types should not be used until a specification for them has been published, since other implementations may not support them properly. Simple type values 24 to 31 are reserved and must not be used.</p> <p><a href="qcborvalue.html#isSimpleType">isSimpleType</a>(), <a href="qcborvalue.html#isNull">isNull</a>(), <a href="qcborvalue.html#isUndefined">isUndefined</a>(), <a href="qcborvalue.html#isTrue">isTrue</a>(), <a href="qcborvalue.html#isFalse">isFalse</a>()</p>   <h3 class="fn" id="QCborValue-5">QCborValue::<span class="name">QCborValue</span>(<span class="type">double</span> <i>d</i>)
</h3> <p>Creates a QCborValue with floating point value <i>d</i>. The value can later be retrieved using <a href="qcborvalue.html#toDouble">toDouble</a>().</p> <p>CBOR floating point values are distinct from integer values. Therefore, QCborValue objects with integers will compare differently to QCborValue objects containing floating-point, even if the values contained in the objects are equivalent.</p> <p><b>See also </b><a href="qcborvalue.html#toDouble">toDouble</a>(), <a href="qcborvalue.html#isDouble">isDouble</a>(), and <a href="qcborvalue.html#isInteger">isInteger</a>().</p>   <h3 class="fn" id="QCborValue-4">QCborValue::<span class="name">QCborValue</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>i</i>)
</h3> <p>Creates a QCborValue with integer value <i>i</i>. The value can later be retrieved using <a href="qcborvalue.html#toInteger">toInteger</a>().</p> <p>CBOR integer values are distinct from floating point values. Therefore, QCborValue objects with integers will compare differently to QCborValue objects containing floating-point, even if the values contained in the objects are equivalent.</p> <p><b>See also </b><a href="qcborvalue.html#toInteger">toInteger</a>(), <a href="qcborvalue.html#isInteger">isInteger</a>(), and <a href="qcborvalue.html#isDouble">isDouble</a>().</p>   <h3 class="fn" id="QCborValue-3">QCborValue::<span class="name">QCborValue</span>(<span class="type">bool</span> <i>b</i>)
</h3> <p>Creates a QCborValue with boolean value <i>b</i>. The value can later be retrieved using <a href="qcborvalue.html#toBool">toBool</a>().</p> <p>Internally, CBOR booleans are represented by a pair of types, one for true and one for false. For that reason, boolean QCborValues will return true for <a href="qcborvalue.html#isSimpleType">isSimpleType</a>() and one of <code>isSimpleType(QCborSimpleType::False)</code> or <code>isSimpleType(QCborSimpleType::True)</code>.</p> <p><b>See also </b><a href="qcborvalue.html#toBool">toBool</a>(), <a href="qcborvalue.html#isBool">isBool</a>(), <a href="qcborvalue.html#isTrue">isTrue</a>(), <a href="qcborvalue.html#isFalse">isFalse</a>(), and <a href="qcborvalue.html#isSimpleType">isSimpleType</a>().</p>   <h3 class="fn" id="QCborValue-2">QCborValue::<span class="name">QCborValue</span>(<span class="type">std::nullptr_t</span>)
</h3> <p>Creates a QCborValue of the <a href="qcborvalue.html#Type-enum">Null</a> type.</p> <p>CBOR null values are used to indicate optional values that were not provided. They are distinct from undefined values, in that null values are usually not the result of an earlier error or problem.</p> <p><b>See also </b><a href="qcborvalue.html#isNull">isNull</a>(), <a href="qcborvalue.html#isUndefined">isUndefined</a>(), and <a href="qcborvalue.html#isSimpleType">isSimpleType</a>().</p>   <h3 class="fn" id="QCborValue-1">QCborValue::<span class="name">QCborValue</span>(<span class="type"><a href="qcborvalue.html#Type-enum">QCborValue::Type</a></span> <i>t_</i>)
</h3> <p>Creates a QCborValue of type <i>t_</i>. The value associated with such a type (if any) will be default constructed.</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>().</p>   <h3 class="fn" id="QCborValue">QCborValue::<span class="name">QCborValue</span>()
</h3> <p>Creates a QCborValue of the <a href="qcborvalue.html#Type-enum">Undefined</a> type.</p> <p>CBOR undefined values are used to indicate missing information, usually as a result of a previous operation that did not complete as expected. They are also used by the <a href="qcborarray.html">QCborArray</a> and <a href="qcbormap.html">QCborMap</a> API to indicate the searched item was not found.</p> <p>Undefined values are represented by the <a href="qtcborcommon.html#QCborSimpleType-enum">Undefined simple type</a>. Because of that, QCborValues with undefined values will also return true for <a href="qcborvalue.html#isSimpleType">isSimpleType</a>() and <code>isSimpleType(QCborSimpleType::Undefined)</code>.</p> <p>Undefined values are different from null values.</p> <p>QCborValue objects with undefined values are also different from invalid QCborValue objects. The API will not create invalid QCborValues, but they may exist as a result of a parsing error.</p> <p><b>See also </b><a href="qcborvalue.html#isUndefined">isUndefined</a>(), <a href="qcborvalue.html#isNull">isNull</a>(), and <a href="qcborvalue.html#isSimpleType">isSimpleType</a>().</p>   <h3 class="fn" id="operator-eq-1">
<span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;QCborValue::<span class="name">operator=</span>(<span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;&amp;<i>other</i>)
</h3> <p>This is an overloaded function.</p> <p>Moves the contents of the <i>other</i> <a href="qcborvalue.html">QCborValue</a> object into this one and frees the resources of this one. Returns a reference to this object.</p>   <h3 class="fn" id="operator-eq">
<span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;QCborValue::<span class="name">operator=</span>(const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;<i>other</i>)
</h3> <p>Replaces the contents of this QCborObject with a copy of <i>other</i>.</p>   <h3 class="fn" id="dtor.QCborValue">QCborValue::<span class="name">~QCborValue</span>()
</h3> <p>Disposes of the current <a href="qcborvalue.html">QCborValue</a> object and frees any associated resources.</p>   <h3 class="fn" id="compare">
<span class="type">int</span> QCborValue::<span class="name">compare</span>(const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;<i>other</i>) const
</h3> <p>Compares this value and <i>other</i>, and returns an integer that indicates whether this value should be sorted prior to (if the result is negative) or after <i>other</i> (if the result is positive). If this function returns 0, the two values are equal and hold the same contents.</p> <p>If each <a href="qcborvalue.html">QCborValue</a> contains an array or map, the comparison is recursive to elements contained in them.</p> <h6 id="extended-types">Extended types
</h6> <p><a href="qcborvalue.html">QCborValue</a> compares equal a <a href="qcborvalue.html">QCborValue</a> containing an extended type, like <a href="qcborvalue.html#Type-enum">Url</a> and <a href="qcborvalue.html#Type-enum">Url</a> and its equivalent tagged representation. So, for example, the following expression is true:</p> <pre data-language="cpp">    QCborValue(QUrl("https://example.com")) == QCborValue(QCborKnownTags::Url, "https://example.com");</pre> <p>Do note that Qt types like <a href="qurl.html">QUrl</a> and <a href="qdatetime.html">QDateTime</a> will normalize and otherwise modify their arguments. The expression above is true only because the string on the right side is the normalized value that the <a href="qcborvalue.html">QCborValue</a> on the left would take. If, for example, the "https" part were uppercase in both sides, the comparison would fail. For information on normalizations performed by <a href="qcborvalue.html">QCborValue</a>, please consult the documentation of the constructor taking the Qt type in question.</p> <h6 id="sorting-order">Sorting order
</h6> <p>Sorting order in CBOR is defined in <a href="https://datatracker.ietf.org/doc/html/rfc7049#section-3.9">RFC 7049, section 3.9</a>, which discusses the sorting of keys in a map when following the Canonical encoding. According to the specification, "sorting is performed on the bytes of the representation of the key data items" and lists as consequences that:</p> <ul> <li>"If two keys have different lengths, the shorter one sorts earlier;"</li> <li>"If two keys have the same length, the one with the lower value in (byte-wise) lexical order sorts earlier."</li> </ul> <p>This results in surprising sorting of QCborValues, where the result of this function is different from that which would later be retrieved by comparing the contained elements. For example, the <a href="qcborvalue.html">QCborValue</a> containing string "zzz" sorts before the <a href="qcborvalue.html">QCborValue</a> with string "foobar", even though when comparing as <a href="qstring.html#compare">QStrings</a> or <a href="qbytearray.html">QByteArrays</a> the "zzz" sorts after "foobar" (dictionary order).</p> <p>The specification does not clearly indicate what sorting order should be done for values of different types (it says sorting should not pay "attention to the 3/5 bit splitting for major types"). <a href="qcborvalue.html">QCborValue</a> makes the assumption that types should be sorted too. The numeric values of the <a href="qcborvalue.html#Type-enum">QCborValue::Type</a> enumeration are in that order, with the exception of the extended types, which compare as their tagged equivalents.</p> <div class="admonition note"> <p><b>Note: </b>Sorting order is preliminary and is subject to change. Applications should not depend on the order returned by this function for the time being.</p> </div> <p><b>See also </b><a href="qcborarray.html#compare">QCborArray::compare</a>(), <a href="qcbormap.html#compare">QCborMap::compare</a>(), and <a href="qcborvalue.html#operator-eq-eq">operator==</a>().</p>   <h3 class="fn" id="fromCbor">
<code>[static] </code><span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> QCborValue::<span class="name">fromCbor</span>(<span class="type"><a href="qcborstreamreader.html">QCborStreamReader</a></span> &amp;<i>reader</i>)
</h3> <p>Decodes one item from the CBOR stream found in <i>reader</i> and returns the equivalent representation. This function is recursive: if the item is a map or array, it will decode all items found in that map or array, until the outermost object is finished.</p> <p>This function need not be used on the root element of a <a href="qcborstreamreader.html">QCborStreamReader</a>. For example, the following code illustrates how to skip the CBOR signature tag from the beginning of a file:</p> <pre data-language="cpp">    if (reader.isTag() &amp;&amp; reader.toTag() == QCborKnownTags::Signature)
        reader.next();

    QCborValue contents = QCborValue::fromCbor(reader);</pre> <p>The returned value may be partially complete and indistinguishable from a valid <a href="qcborvalue.html">QCborValue</a> even if the decoding failed. To determine if there was an error, check if <a href="qcborstreamreader.html#lastError">reader.lastError</a>() is indicating an error condition. This function stops decoding immediately after the first error.</p> <p><b>See also </b><a href="qcborvalue.html#toCbor">toCbor</a>(), <a href="qcborvalue.html#toDiagnosticNotation">toDiagnosticNotation</a>(), <a href="qcborvalue.html#toVariant">toVariant</a>(), and <a href="qcborvalue.html#toJsonValue">toJsonValue</a>().</p>   <h3 class="fn" id="fromCbor-1">
<code>[static] </code><span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> QCborValue::<span class="name">fromCbor</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>ba</i>, <span class="type"><a href="qcborparsererror.html">QCborParserError</a></span> *<i>error</i> = nullptr)
</h3> <p>This is an overloaded function.</p> <p>Decodes one item from the CBOR stream found in the byte array <i>ba</i> and returns the equivalent representation. This function is recursive: if the item is a map or array, it will decode all items found in that map or array, until the outermost object is finished.</p> <p>This function stores the error state, if any, in the object pointed to by <i>error</i>, along with the offset of where the error occurred. If no error happened, it stores <a href="qcborerror.html">NoError</a> in the error state and the number of bytes that it consumed (that is, it stores the offset for the first unused byte). Using that information makes it possible to parse further data that may exist in the same byte array.</p> <p>The returned value may be partially complete and indistinguishable from a valid <a href="qcborvalue.html">QCborValue</a> even if the decoding failed. To determine if there was an error, check if there was an error stored in <i>error</i>. This function stops decoding immediately after the first error.</p> <p><b>See also </b><a href="qcborvalue.html#toCbor">toCbor</a>(), <a href="qcborvalue.html#toDiagnosticNotation">toDiagnosticNotation</a>(), <a href="qcborvalue.html#toVariant">toVariant</a>(), and <a href="qcborvalue.html#toJsonValue">toJsonValue</a>().</p>   <h3 class="fn" id="fromJsonValue">
<code>[static] </code><span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> QCborValue::<span class="name">fromJsonValue</span>(const <span class="type"><a href="qjsonvalue.html">QJsonValue</a></span> &amp;<i>v</i>)
</h3> <p>Converts the JSON value contained in <i>v</i> into its corresponding CBOR value and returns it. There is no data loss in converting from JSON to CBOR, as the CBOR type set is richer than JSON's. Additionally, values converted to CBOR using this function can be converted back to JSON using <a href="qcborvalue.html#toJsonValue">toJsonValue</a>() with no data loss.</p> <p>The following table lists the mapping of JSON types to CBOR types:</p> <table class="generic"> <thead><tr class="qt-style">
<th>JSON Type</th>
<th>CBOR Type</th>
</tr></thead> <tr class="odd" valign="top">
<td>Bool</td>
<td>Bool</td>
</tr> <tr class="even" valign="top">
<td>Number</td>
<td>Integer (if the number has no fraction and is in the <a href="qtglobal.html#qint64-typedef">qint64</a> range) or Double</td>
</tr> <tr class="odd" valign="top">
<td>String</td>
<td>String</td>
</tr> <tr class="even" valign="top">
<td>Array</td>
<td>Array</td>
</tr> <tr class="odd" valign="top">
<td>Object</td>
<td>Map</td>
</tr> <tr class="even" valign="top">
<td>Null</td>
<td>Null</td>
</tr> </table> <p><a href="qjsonvalue.html">QJsonValue</a> can also be undefined, indicating a previous operation that failed to complete (for example, searching for a key not present in an object). Undefined values are not JSON types and may not appear in JSON arrays and objects, but this function does return the <a href="qcborvalue.html">QCborValue</a> undefined value if the corresponding <a href="qjsonvalue.html">QJsonValue</a> is undefined.</p> <p><b>See also </b><a href="qcborvalue.html#toJsonValue">toJsonValue</a>(), <a href="qcborvalue.html#fromVariant">fromVariant</a>(), <a href="qcborarray.html#fromJsonArray">QCborArray::fromJsonArray</a>(), and <a href="qcbormap.html#fromJsonObject">QCborMap::fromJsonObject</a>().</p>   <h3 class="fn" id="fromVariant">
<code>[static] </code><span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> QCborValue::<span class="name">fromVariant</span>(const <span class="type"><a href="qvariant.html">QVariant</a></span> &amp;<i>variant</i>)
</h3> <p>Converts the <a href="qvariant.html">QVariant</a> <i>variant</i> into <a href="qcborvalue.html">QCborValue</a> and returns it.</p> <p>QVariants may contain a large list of different meta types, many of which have no corresponding representation in CBOR. That includes all user-defined meta types. When preparing transmission using CBOR, it is suggested to encode carefully each value to prevent loss of representation.</p> <p>The following table lists the conversion this function will apply:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Qt (C++) type</th>
<th>CBOR type</th>
</tr></thead> <tr class="odd" valign="top">
<td>invalid (QVariant())</td>
<td>Undefined</td>
</tr> <tr class="even" valign="top">
<td><code>bool</code></td>
<td>Bool</td>
</tr> <tr class="odd" valign="top">
<td><code>std::nullptr_t</code></td>
<td>Null</td>
</tr> <tr class="even" valign="top">
<td>
<code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <a href="qtglobal.html#qint64-typedef">qint64</a>
</td>
<td>Integer</td>
</tr> <tr class="odd" valign="top">
<td><a href="qtglobal.html#quint64-typedef">quint64</a></td>
<td>Integer, or Double if outside the range of qint64</td>
</tr> <tr class="even" valign="top">
<td>
<code>float</code>, <code>double</code>
</td>
<td>Double</td>
</tr> <tr class="odd" valign="top">
<td><a href="qbytearray.html">QByteArray</a></td>
<td><a href="qcborvalue.html#Type-enum">ByteArray</a></td>
</tr> <tr class="even" valign="top">
<td><a href="qdatetime.html">QDateTime</a></td>
<td><a href="qcborvalue.html#Type-enum">DateTime</a></td>
</tr> <tr class="odd" valign="top">
<td><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType</a></td>
<td>Simple type</td>
</tr> <tr class="even" valign="top">
<td><a href="qjsonarray.html">QJsonArray</a></td>
<td>Array, converted using QCborArray::formJsonArray()</td>
</tr> <tr class="odd" valign="top">
<td><a href="qjsondocument.html">QJsonDocument</a></td>
<td>Array or Map</td>
</tr> <tr class="even" valign="top">
<td><a href="qjsonobject.html">QJsonObject</a></td>
<td>Map, converted using <a href="qcbormap.html#fromJsonObject">QCborMap::fromJsonObject</a>()</td>
</tr> <tr class="odd" valign="top">
<td><a href="qjsonvalue.html">QJsonValue</a></td>
<td>converted using <a href="qcborvalue.html#fromJsonValue">fromJsonValue</a>()</td>
</tr> <tr class="even" valign="top">
<td><a href="qregularexpression.html">QRegularExpression</a></td>
<td><a href="qcborvalue.html#Type-enum">RegularExpression</a></td>
</tr> <tr class="odd" valign="top">
<td><a href="qstring.html">QString</a></td>
<td>String</td>
</tr> <tr class="even" valign="top">
<td><a href="qstringlist.html">QStringList</a></td>
<td>Array</td>
</tr> <tr class="odd" valign="top">
<td><a href="qvariant.html#QVariantHash-typedef">QVariantHash</a></td>
<td>Map</td>
</tr> <tr class="even" valign="top">
<td><a href="qvariant.html#QVariantList-typedef">QVariantList</a></td>
<td>Array</td>
</tr> <tr class="odd" valign="top">
<td><a href="qvariant.html#QVariantMap-typedef">QVariantMap</a></td>
<td>Map</td>
</tr> <tr class="even" valign="top">
<td><a href="qurl.html">QUrl</a></td>
<td>Url</td>
</tr> <tr class="odd" valign="top">
<td><a href="quuid.html">QUuid</a></td>
<td>Uuid</td>
</tr> </table> <p>If <a href="qvariant.html#isNull">QVariant::isNull</a>() returns true, a null <a href="qcborvalue.html">QCborValue</a> is returned or inserted into the list or object, regardless of the type carried by <a href="qvariant.html">QVariant</a>. Note the behavior change in Qt 6.0 affecting <a href="qvariant.html#isNull">QVariant::isNull</a>() also affects this function.</p> <p>For other types not listed above, a conversion to string will be attempted, usually but not always by calling <a href="qvariant.html#toString">QVariant::toString</a>(). If the conversion fails the value is replaced by an Undefined CBOR value. Note that <a href="qvariant.html#toString">QVariant::toString</a>() is also lossy for the majority of types.</p> <p>Please note that the conversions via <a href="qvariant.html#toString">QVariant::toString</a>() are subject to change at any time. Both <a href="qvariant.html">QVariant</a> and <a href="qcborvalue.html">QCborValue</a> may be extended in the future to support more types, which will result in a change in how this function performs conversions.</p> <p><b>See also </b><a href="qcborvalue.html#toVariant">toVariant</a>(), <a href="qcborvalue.html#fromJsonValue">fromJsonValue</a>(), <a href="qcborarray.html#toVariantList">QCborArray::toVariantList</a>(), <a href="qcbormap.html#toVariantMap">QCborMap::toVariantMap</a>(), and <a href="qjsonvalue.html#fromVariant">QJsonValue::fromVariant</a>().</p>   <h3 class="fn" id="isArray">
<span class="type">bool</span> QCborValue::<span class="name">isArray</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the array type. The array value can be retrieved using <a href="qcborvalue.html#toArray">toArray</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>() and <a href="qcborvalue.html#toArray">toArray</a>().</p>   <h3 class="fn" id="isBool">
<span class="type">bool</span> QCborValue::<span class="name">isBool</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is a boolean. The value can be retrieved using <a href="qcborvalue.html#toBool">toBool</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>(), <a href="qcborvalue.html#toBool">toBool</a>(), <a href="qcborvalue.html#isTrue">isTrue</a>(), and <a href="qcborvalue.html#isFalse">isFalse</a>().</p>   <h3 class="fn" id="isByteArray">
<span class="type">bool</span> QCborValue::<span class="name">isByteArray</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the byte array type. The byte array value can be retrieved using <a href="qcborvalue.html#toByteArray">toByteArray</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>() and <a href="qcborvalue.html#toByteArray">toByteArray</a>().</p>   <h3 class="fn" id="isContainer">
<span class="type">bool</span> QCborValue::<span class="name">isContainer</span>() const
</h3> <p>This convenience function returns true if the <a href="qcborvalue.html">QCborValue</a> is either an array or a map.</p> <p><b>See also </b><a href="qcborvalue.html#isArray">isArray</a>() and <a href="qcborvalue.html#isMap">isMap</a>().</p>   <h3 class="fn" id="isDateTime">
<span class="type">bool</span> QCborValue::<span class="name">isDateTime</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the date/time type. The value can be retrieved using <a href="qcborvalue.html#toDateTime">toDateTime</a>(). Date/times are extended types that use the tag <a href="qtcborcommon.html#QCborKnownTags-enum">DateTime</a>.</p> <p>Additionally, when decoding from a CBOR stream, <a href="qcborvalue.html">QCborValue</a> will interpret tags of value <a href="qtcborcommon.html#QCborKnownTags-enum">UnixTime_t</a> and convert them to the equivalent date/time.</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>() and <a href="qcborvalue.html#toDateTime">toDateTime</a>().</p>   <h3 class="fn" id="isDouble">
<span class="type">bool</span> QCborValue::<span class="name">isDouble</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the floating-point type. The value can be retrieved using <a href="qcborvalue.html#toDouble">toDouble</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>() and <a href="qcborvalue.html#toDouble">toDouble</a>().</p>   <h3 class="fn" id="isFalse">
<span class="type">bool</span> QCborValue::<span class="name">isFalse</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is a boolean with false value. This function exists because, internally, CBOR booleans are stored as two separate types, one for true and one for false.</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>(), <a href="qcborvalue.html#isBool">isBool</a>(), <a href="qcborvalue.html#isTrue">isTrue</a>(), and <a href="qcborvalue.html#toBool">toBool</a>().</p>   <h3 class="fn" id="isInteger">
<span class="type">bool</span> QCborValue::<span class="name">isInteger</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the integer type. The integer value can be retrieved using <a href="qcborvalue.html#toInteger">toInteger</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>() and <a href="qcborvalue.html#toInteger">toInteger</a>().</p>   <h3 class="fn" id="isInvalid">
<span class="type">bool</span> QCborValue::<span class="name">isInvalid</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is not of any valid type. Invalid QCborValues are distinct from those with undefined values and they usually represent a decoding error.</p> <p><b>See also </b><a href="qcborvalue.html#isUndefined">isUndefined</a>() and <a href="qcborvalue.html#isNull">isNull</a>().</p>   <h3 class="fn" id="isMap">
<span class="type">bool</span> QCborValue::<span class="name">isMap</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the map type. The map value can be retrieved using <a href="qcborvalue.html#toMap">toMap</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>() and <a href="qcborvalue.html#toMap">toMap</a>().</p>   <h3 class="fn" id="isNull">
<span class="type">bool</span> QCborValue::<span class="name">isNull</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the null type.</p> <p>CBOR null values are used to indicate optional values that were not provided. They are distinct from undefined values, in that null values are usually not the result of an earlier error or problem.</p> <p>Null values are distinct from undefined values and from invalid <a href="qcborvalue.html">QCborValue</a> objects. The API will not create invalid QCborValues, but they may exist as a result of a parsing error.</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>(), <a href="qcborvalue.html#isUndefined">isUndefined</a>(), and <a href="qcborvalue.html#isInvalid">isInvalid</a>().</p>   <h3 class="fn" id="isRegularExpression">
<span class="type">bool</span> QCborValue::<span class="name">isRegularExpression</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> contains a regular expression's pattern. The pattern can be retrieved using <a href="qcborvalue.html#toRegularExpression">toRegularExpression</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>() and <a href="qcborvalue.html#toRegularExpression">toRegularExpression</a>().</p>   <h3 class="fn" id="isSimpleType">
<span class="type">bool</span> QCborValue::<span class="name">isSimpleType</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of one of the CBOR simple types. The type itself can later be retrieved using <a href="qcborvalue.html#type">type</a>(), even for types that don't have an enumeration in the API. They can also be checked with the <a href="qcborvalue.html#isSimpleType-1">isSimpleType</a>(QCborSimpleType) overload.</p> <p><b>See also </b><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType</a>, <a href="qcborvalue.html#isSimpleType-1">isSimpleType</a>(QCborSimpleType), and <a href="qcborvalue.html#toSimpleType">toSimpleType</a>().</p>   <h3 class="fn" id="isSimpleType-1">
<span class="type">bool</span> QCborValue::<span class="name">isSimpleType</span>(<span class="type"><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType</a></span> <i>st</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of a simple type and <a href="qcborvalue.html#toSimpleType">toSimpleType</a>() would return <i>st</i>, false otherwise. This function can be used to check for any CBOR simple type, even those for which there is no enumeration in the API. For example, for the simple type of value 12, you could write:</p> <pre data-language="cpp">    value.isSimpleType(QCborSimpleType(12));</pre> <p><b>See also </b><a href="qcborvalue.html#QCborValue-6">QCborValue::QCborValue</a>(QCborSimpleType), <a href="qcborvalue.html#isSimpleType">isSimpleType</a>(), <a href="qcborvalue.html#isFalse">isFalse</a>(), <a href="qcborvalue.html#isTrue">isTrue</a>(), <a href="qcborvalue.html#isNull">isNull</a>, <a href="qcborvalue.html#isUndefined">isUndefined</a>(), and <a href="qcborvalue.html#toSimpleType">toSimpleType</a>().</p>   <h3 class="fn" id="isString">
<span class="type">bool</span> QCborValue::<span class="name">isString</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the string type. The string value can be retrieved using <a href="qcborvalue.html#toString">toString</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>() and <a href="qcborvalue.html#toString">toString</a>().</p>   <h3 class="fn" id="isTag">
<span class="type">bool</span> QCborValue::<span class="name">isTag</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the tag type. The tag value can be retrieved using <a href="qcborvalue.html#tag">tag</a>() and the tagged value using <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p> <p>This function also returns true for extended types that the API recognizes. For code that handles extended types directly before the Qt API is updated to support them, it is possible to recreate the tag + tagged value pair by using <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>(), <a href="qcborvalue.html#tag">tag</a>(), <a href="qcborvalue.html#taggedValue">taggedValue</a>(), and <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p>   <h3 class="fn" id="isTrue">
<span class="type">bool</span> QCborValue::<span class="name">isTrue</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is a boolean with true value. This function exists because, internally, CBOR booleans are stored as two separate types, one for false and one for true.</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>(), <a href="qcborvalue.html#isBool">isBool</a>(), <a href="qcborvalue.html#isFalse">isFalse</a>(), and <a href="qcborvalue.html#toBool">toBool</a>().</p>   <h3 class="fn" id="isUndefined">
<span class="type">bool</span> QCborValue::<span class="name">isUndefined</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the undefined type.</p> <p>CBOR undefined values are used to indicate missing information, usually as a result of a previous operation that did not complete as expected. They are also used by the <a href="qcborarray.html">QCborArray</a> and <a href="qcbormap.html">QCborMap</a> API to indicate the searched item was not found.</p> <p>Undefined values are distinct from null values.</p> <p><a href="qcborvalue.html">QCborValue</a> objects with undefined values are also different from invalid <a href="qcborvalue.html">QCborValue</a> objects. The API will not create invalid QCborValues, but they may exist as a result of a parsing error.</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>(), <a href="qcborvalue.html#isNull">isNull</a>(), and <a href="qcborvalue.html#isInvalid">isInvalid</a>().</p>   <h3 class="fn" id="isUrl">
<span class="type">bool</span> QCborValue::<span class="name">isUrl</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> is of the URL type. The URL value can be retrieved using <a href="qcborvalue.html#toUrl">toUrl</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>() and <a href="qcborvalue.html#toUrl">toUrl</a>().</p>   <h3 class="fn" id="isUuid">
<span class="type">bool</span> QCborValue::<span class="name">isUuid</span>() const
</h3> <p>Returns true if this <a href="qcborvalue.html">QCborValue</a> contains a UUID. The value can be retrieved using <a href="qcborvalue.html#toUuid">toUuid</a>().</p> <p><b>See also </b><a href="qcborvalue.html#type">type</a>() and <a href="qcborvalue.html#toUuid">toUuid</a>().</p>   <h3 class="fn" id="swap">
<span class="type">void</span> QCborValue::<span class="name">swap</span>(<span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;<i>other</i>)
</h3> <p>Swaps the contents of this <a href="qcborvalue.html">QCborValue</a> object and <i>other</i>.</p>   <h3 class="fn" id="tag">
<span class="type"><a href="qtcborcommon.html#QCborTag-enum">QCborTag</a></span> QCborValue::<span class="name">tag</span>(<span class="type"><a href="qtcborcommon.html#QCborTag-enum">QCborTag</a></span> <i>defaultValue</i> = QCborTag(-1)) const
</h3> <p>Returns the tag of this extended <a href="qcborvalue.html">QCborValue</a> object, if it is of the tag type, <i>defaultValue</i> otherwise.</p> <p>CBOR represents extended types by associating a number (the tag) with a stored representation. This function returns that number. To retrieve the representation, use <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p> <p><b>See also </b><a href="qcborvalue.html#isTag">isTag</a>(), <a href="qcborvalue.html#taggedValue">taggedValue</a>(), <a href="qcborvalue.html#isDateTime">isDateTime</a>(), <a href="qcborvalue.html#isUrl">isUrl</a>(), <a href="qcborvalue.html#isRegularExpression">isRegularExpression</a>(), and <a href="qcborvalue.html#isUuid">isUuid</a>().</p>   <h3 class="fn" id="taggedValue">
<span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> QCborValue::<span class="name">taggedValue</span>(const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;<i>defaultValue</i> = QCborValue()) const
</h3> <p>Returns the tagged value of this extended <a href="qcborvalue.html">QCborValue</a> object, if it is of the tag type, <i>defaultValue</i> otherwise.</p> <p>CBOR represents extended types by associating a number (the tag) with a stored representation. This function returns that representation. To retrieve the tag, use <a href="qcborvalue.html#tag">tag</a>().</p> <p><b>See also </b><a href="qcborvalue.html#isTag">isTag</a>(), <a href="qcborvalue.html#tag">tag</a>(), <a href="qcborvalue.html#isDateTime">isDateTime</a>(), <a href="qcborvalue.html#isUrl">isUrl</a>(), <a href="qcborvalue.html#isRegularExpression">isRegularExpression</a>(), and <a href="qcborvalue.html#isUuid">isUuid</a>().</p>   <h3 class="fn" id="toBool">
<span class="type">bool</span> QCborValue::<span class="name">toBool</span>(<span class="type">bool</span> <i>defaultValue</i> = false) const
</h3> <p>Returns the boolean value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of a boolean type. Otherwise, it returns <i>defaultValue</i>.</p> <p><b>See also </b><a href="qcborvalue.html#isBool">isBool</a>(), <a href="qcborvalue.html#isTrue">isTrue</a>(), and <a href="qcborvalue.html#isFalse">isFalse</a>().</p>   <h3 class="fn" id="toByteArray">
<span class="type"><a href="qbytearray.html">QByteArray</a></span> QCborValue::<span class="name">toByteArray</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>defaultValue</i> = {}) const
</h3> <p>Returns the byte array value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of the byte array type. Otherwise, it returns <i>defaultValue</i>.</p> <p>Note that this function performs no conversion from other types to <a href="qbytearray.html">QByteArray</a>.</p> <p><b>See also </b><a href="qcborvalue.html#isByteArray">isByteArray</a>(), <a href="qcborvalue.html#isString">isString</a>(), and <a href="qcborvalue.html#toString">toString</a>().</p>   <h3 class="fn" id="toCbor">
<span class="type"><a href="qbytearray.html">QByteArray</a></span> QCborValue::<span class="name">toCbor</span>(<span class="type"><a href="qcborvalue.html#EncodingOption-enum">QCborValue::EncodingOptions</a></span> <i>opt</i> = NoTransformation) const
</h3> <p>Encodes this <a href="qcborvalue.html">QCborValue</a> object to its CBOR representation, using the options specified in <i>opt</i>, and return the byte array containing that representation.</p> <p>This function will not fail, except if this <a href="qcborvalue.html">QCborValue</a> or any of the contained items, if this is a map or array, are invalid. Invalid types are not produced normally by the API, but can result from decoding errors.</p> <p>By default, this function performs no transformation on the values in the <a href="qcborvalue.html">QCborValue</a>, writing all floating point directly as double-precision (<code>double</code>) types. If the <a href="qcborvalue.html#EncodingOption-enum">UseFloat</a> option is specified, it will use single precision (<code>float</code>) for any floating point value for which there's no loss of precision in using that representation. That includes infinities and NaN values.</p> <p>Similarly, if <a href="qcborvalue.html#EncodingOption-enum">UseFloat16</a> is specified, this function will try to use half-precision (<code>qfloat16</code>) floating point if the conversion to that results in no loss of precision. This is always true for infinities and NaN.</p> <p>If <a href="qcborvalue.html#EncodingOption-enum">UseIntegers</a> is specified, it will use integers for any floating point value that contains an actual integer.</p> <p><b>See also </b><a href="qcborvalue.html#fromCbor">fromCbor</a>(), <a href="qcborvalue.html#fromVariant">fromVariant</a>(), and <a href="qcborvalue.html#fromJsonValue">fromJsonValue</a>().</p>   <h3 class="fn" id="toCbor-1">
<span class="type">void</span> QCborValue::<span class="name">toCbor</span>(<span class="type"><a href="qcborstreamwriter.html">QCborStreamWriter</a></span> &amp;<i>writer</i>, <span class="type"><a href="qcborvalue.html#EncodingOption-enum">QCborValue::EncodingOptions</a></span> <i>opt</i> = NoTransformation) const
</h3> <p>This is an overloaded function.</p> <p>Encodes this <a href="qcborvalue.html">QCborValue</a> object to its CBOR representation, using the options specified in <i>opt</i>, to the writer specified by <i>writer</i>. The same writer can be used by multiple QCborValues, for example, in order to encode different elements in a larger array.</p> <p>This function will not fail, except if this <a href="qcborvalue.html">QCborValue</a> or any of the contained items, if this is a map or array, are invalid. Invalid types are not produced normally by the API, but can result from decoding errors.</p> <p>By default, this function performs no transformation on the values in the <a href="qcborvalue.html">QCborValue</a>, writing all floating point directly as double-precision (binary64) types. If the <a href="qcborvalue.html#EncodingOption-enum">UseFloat</a> option is specified, it will use single precision (binary32) for any floating point value for which there's no loss of precision in using that representation. That includes infinities and NaN values.</p> <p>Similarly, if <a href="qcborvalue.html#EncodingOption-enum">UseFloat16</a> is specified, this function will try to use half-precision (binary16) floating point if the conversion to that results in no loss of precision. This is always true for infinities and NaN.</p> <p>If <a href="qcborvalue.html#EncodingOption-enum">UseIntegers</a> is specified, it will use integers for any floating point value that contains an actual integer.</p> <p><b>See also </b><a href="qcborvalue.html#fromCbor">fromCbor</a>(), <a href="qcborvalue.html#fromVariant">fromVariant</a>(), and <a href="qcborvalue.html#fromJsonValue">fromJsonValue</a>().</p>   <h3 class="fn" id="toDateTime">
<span class="type"><a href="qdatetime.html">QDateTime</a></span> QCborValue::<span class="name">toDateTime</span>(const <span class="type"><a href="qdatetime.html">QDateTime</a></span> &amp;<i>defaultValue</i> = {}) const
</h3> <p>Returns the date/time value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of the date/time extended type. Otherwise, it returns <i>defaultValue</i>.</p> <p>Note that this function performs no conversion from other types to <a href="qdatetime.html">QDateTime</a>.</p> <p><b>See also </b><a href="qcborvalue.html#isDateTime">isDateTime</a>(), <a href="qcborvalue.html#isTag">isTag</a>(), and <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p>   <h3 class="fn" id="toDiagnosticNotation">
<span class="type"><a href="qstring.html">QString</a></span> QCborValue::<span class="name">toDiagnosticNotation</span>(<span class="type"><a href="qcborvalue.html#DiagnosticNotationOption-enum">QCborValue::DiagnosticNotationOptions</a></span> <i>opts</i> = Compact) const
</h3> <p>Creates the diagnostic notation equivalent of this CBOR object and returns it. The <i>opts</i> parameter controls the dialect of the notation. Diagnostic notation is useful in debugging, to aid the developer in understanding what value is stored in the <a href="qcborvalue.html">QCborValue</a> or in a CBOR stream. For that reason, the Qt API provides no support for parsing the diagnostic back into the in-memory format or CBOR stream, though the representation is unique and it would be possible.</p> <p>CBOR diagnostic notation is specified by <a href="https://datatracker.ietf.org/doc/html/rfc7049#section-6">section 6</a> of RFC 7049. It is a text representation of the CBOR stream and it is very similar to JSON, but it supports the CBOR types not found in JSON. The extended format enabled by the <a href="qcborvalue.html#DiagnosticNotationOption-enum">ExtendedFormat</a> flag is currently in some IETF drafts and its format is subject to change.</p> <p>This function produces the equivalent representation of the stream that <a href="qcborvalue.html#toCbor">toCbor</a>() would produce, without any transformation option provided there. This also implies this function may not produce a representation of the stream that was used to create the object, if it was created using <a href="qcborvalue.html#fromCbor">fromCbor</a>(), as that function may have applied transformations. For a high-fidelity notation of a stream, without transformation, see the <code>cbordump</code> example.</p> <p><b>See also </b><a href="qcborvalue.html#toCbor">toCbor</a>() and <a href="qjsondocument.html#toJson">QJsonDocument::toJson</a>().</p>   <h3 class="fn" id="toDouble">
<span class="type">double</span> QCborValue::<span class="name">toDouble</span>(<span class="type">double</span> <i>defaultValue</i> = 0) const
</h3> <p>Returns the floating point value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of the Double type. If it is of the Integer type, this function returns the integer value converted to double. In any other case, it returns <i>defaultValue</i>.</p> <p><b>See also </b><a href="qcborvalue.html#isDouble">isDouble</a>(), <a href="qcborvalue.html#isInteger">isInteger</a>(), and <a href="qcborvalue.html#toInteger">toInteger</a>().</p>   <h3 class="fn" id="toInteger">
<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QCborValue::<span class="name">toInteger</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>defaultValue</i> = 0) const
</h3> <p>Returns the integer value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of the integer type. If it is of the Double type, this function returns the floating point value converted to integer. In any other case, it returns <i>defaultValue</i>.</p> <p><b>See also </b><a href="qcborvalue.html#isInteger">isInteger</a>(), <a href="qcborvalue.html#isDouble">isDouble</a>(), and <a href="qcborvalue.html#toDouble">toDouble</a>().</p>   <h3 class="fn" id="toJsonValue">
<span class="type"><a href="qjsonvalue.html">QJsonValue</a></span> QCborValue::<span class="name">toJsonValue</span>() const
</h3> <p>Converts this <a href="qcborvalue.html">QCborValue</a> object to an equivalent representation in JSON and returns it as a <a href="qjsonvalue.html">QJsonValue</a>.</p> <p>Please note that CBOR contains a richer and wider type set than JSON, so some information may be lost in this conversion. The following table compares CBOR types to JSON types and indicates whether information may be lost or not.</p> <table class="generic"> <thead><tr class="qt-style">
<th>CBOR Type</th>
<th>JSON Type</th>
<th>Comments</th>
</tr></thead> <tr class="odd" valign="top">
<td>Bool</td>
<td>Bool</td>
<td>No data loss possible</td>
</tr> <tr class="even" valign="top">
<td>Double</td>
<td>Number</td>
<td>Infinities and NaN will be converted to Null; no data loss for other values</td>
</tr> <tr class="odd" valign="top">
<td>Integer</td>
<td>Number</td>
<td>Data loss possible in the conversion if the integer is larger than 2<sup>53</sup> or smaller than -2<sup>53</sup>.</td>
</tr> <tr class="even" valign="top">
<td>Null</td>
<td>Null</td>
<td>No data loss possible</td>
</tr> <tr class="odd" valign="top">
<td>Undefined</td>
<td>Null</td>
<td>Type information lost</td>
</tr> <tr class="even" valign="top">
<td>String</td>
<td>String</td>
<td>No data loss possible</td>
</tr> <tr class="odd" valign="top">
<td>Byte Array</td>
<td>String</td>
<td>Converted to a lossless encoding like Base64url, but the distinction between strings and byte arrays is lost</td>
</tr> <tr class="even" valign="top">
<td>Other simple types</td>
<td>String</td>
<td>Type information lost</td>
</tr> <tr class="odd" valign="top">
<td>Array</td>
<td>Array</td>
<td>Conversion applies to each contained value</td>
</tr> <tr class="even" valign="top">
<td>Map</td>
<td>Object</td>
<td>Keys are converted to string; values converted according to this table</td>
</tr> <tr class="odd" valign="top">
<td>Tags and extended types</td>
<td>Special</td>
<td>The tag number itself is lost and the tagged value is converted to JSON</td>
</tr> </table> <p>For information on the conversion of CBOR map keys to string, see <a href="qcbormap.html#toJsonObject">QCborMap::toJsonObject</a>().</p> <p>If this <a href="qcborvalue.html">QCborValue</a> contains the undefined value, this function will return an undefined <a href="qjsonvalue.html">QJsonValue</a> too. Note that JSON does not support undefined values and undefined QJsonValues are an extension to the specification. They cannot be held in a <a href="qjsonarray.html">QJsonArray</a> or <a href="qjsonobject.html">QJsonObject</a>, but can be returned from functions to indicate a failure. For all other intents and purposes, they are the same as null.</p> <h6 id="special-handling-of-tags-and-extended-types">Special handling of tags and extended types
</h6> <p>Some tags are handled specially and change the transformation of the tagged value from CBOR to JSON. The following table lists those special cases:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Tag</th>
<th>CBOR type</th>
<th>Transformation</th>
</tr></thead> <tr class="odd" valign="top">
<td><a href="qtcborcommon.html#QCborKnownTags-enum">ExpectedBase64url</a></td>
<td>Byte array</td>
<td>Encodes the byte array as Base64url</td>
</tr> <tr class="even" valign="top">
<td><a href="qtcborcommon.html#QCborKnownTags-enum">ExpectedBase64</a></td>
<td>Byte array</td>
<td>Encodes the byte array as Base64</td>
</tr> <tr class="odd" valign="top">
<td><a href="qtcborcommon.html#QCborKnownTags-enum">ExpectedBase16</a></td>
<td>Byte array</td>
<td>Encodes the byte array as hex</td>
</tr> <tr class="even" valign="top">
<td>Url</td>
<td>Url and String</td>
<td>Uses <a href="qurl.html#toEncoded">QUrl::toEncoded</a>() to normalize the encoding to the URL's fully encoded format</td>
</tr> <tr class="odd" valign="top">
<td>Uuid</td>
<td>Uuid and Byte array</td>
<td>Uses <a href="quuid.html#toString">QUuid::toString</a>() to create the string representation</td>
</tr> </table> <p><b>See also </b><a href="qcborvalue.html#fromJsonValue">fromJsonValue</a>(), <a href="qcborvalue.html#toVariant">toVariant</a>(), <a href="qcborarray.html#toJsonArray">QCborArray::toJsonArray</a>(), and <a href="qcbormap.html#toJsonObject">QCborMap::toJsonObject</a>().</p>   <h3 class="fn" id="toRegularExpression">
<span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> QCborValue::<span class="name">toRegularExpression</span>(const <span class="type"><a href="qregularexpression.html">QRegularExpression</a></span> &amp;<i>defaultValue</i> = {}) const
</h3> <p>Returns the regular expression value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of the regular expression pattern extended type. Otherwise, it returns <i>defaultValue</i>.</p> <p>Note that this function performs no conversion from other types to <a href="qregularexpression.html">QRegularExpression</a>.</p> <p><b>See also </b><a href="qcborvalue.html#isRegularExpression">isRegularExpression</a>(), <a href="qcborvalue.html#isTag">isTag</a>(), and <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p>   <h3 class="fn" id="toSimpleType">
<span class="type"><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType</a></span> QCborValue::<span class="name">toSimpleType</span>(<span class="type"><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType</a></span> <i>defaultValue</i> = QCborSimpleType::Undefined) const
</h3> <p>Returns the simple type this <a href="qcborvalue.html">QCborValue</a> is of, if it is a simple type. If it is not a simple type, it returns <i>defaultValue</i>.</p> <p>The following types are simple types and this function will return the listed values:</p> <table class="generic"> <tr class="odd" valign="top">
<td><a href="qcborvalue.html#Type-enum">QCborValue::False</a></td>
<td><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType::False</a></td>
</tr> <tr class="even" valign="top">
<td><a href="qcborvalue.html#Type-enum">QCborValue::True</a></td>
<td><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType::True</a></td>
</tr> <tr class="odd" valign="top">
<td><a href="qcborvalue.html#Type-enum">QCborValue::Null</a></td>
<td><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType::Null</a></td>
</tr> <tr class="even" valign="top">
<td><a href="qcborvalue.html#Type-enum">QCborValue::Undefined</a></td>
<td><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType::Undefined</a></td>
</tr> </table> <p><b>See also </b><a href="qcborvalue.html#type">type</a>(), <a href="qcborvalue.html#isSimpleType">isSimpleType</a>(), <a href="qcborvalue.html#isBool">isBool</a>(), <a href="qcborvalue.html#isTrue">isTrue</a>(), <a href="qcborvalue.html#isFalse">isFalse</a>(), <a href="qcborvalue.html#isTrue">isTrue</a>(), <a href="qcborvalue.html#isNull">isNull</a>(), and <a href="qcborvalue.html#isUndefined">isUndefined</a>().</p>   <h3 class="fn" id="toString">
<span class="type"><a href="qstring.html">QString</a></span> QCborValue::<span class="name">toString</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>defaultValue</i> = {}) const
</h3> <p>Returns the string value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of the string type. Otherwise, it returns <i>defaultValue</i>.</p> <p>Note that this function performs no conversion from other types to <a href="qstring.html">QString</a>.</p> <p><b>See also </b><a href="qcborvalue.html#isString">isString</a>(), <a href="qcborvalue.html#isByteArray">isByteArray</a>(), and <a href="qcborvalue.html#toByteArray">toByteArray</a>().</p>   <h3 class="fn" id="toUrl">
<span class="type"><a href="qurl.html">QUrl</a></span> QCborValue::<span class="name">toUrl</span>(const <span class="type"><a href="qurl.html">QUrl</a></span> &amp;<i>defaultValue</i> = {}) const
</h3> <p>Returns the URL value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of the URL extended type. Otherwise, it returns <i>defaultValue</i>.</p> <p>Note that this function performs no conversion from other types to <a href="qurl.html">QUrl</a>.</p> <p><b>See also </b><a href="qcborvalue.html#isUrl">isUrl</a>(), <a href="qcborvalue.html#isTag">isTag</a>(), and <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p>   <h3 class="fn" id="toUuid">
<span class="type"><a href="quuid.html">QUuid</a></span> QCborValue::<span class="name">toUuid</span>(const <span class="type"><a href="quuid.html">QUuid</a></span> &amp;<i>defaultValue</i> = {}) const
</h3> <p>Returns the UUID value stored in this <a href="qcborvalue.html">QCborValue</a>, if it is of the UUID extended type. Otherwise, it returns <i>defaultValue</i>.</p> <p>Note that this function performs no conversion from other types to <a href="quuid.html">QUuid</a>.</p> <p><b>See also </b><a href="qcborvalue.html#isUuid">isUuid</a>(), <a href="qcborvalue.html#isTag">isTag</a>(), and <a href="qcborvalue.html#taggedValue">taggedValue</a>().</p>   <h3 class="fn" id="toVariant">
<span class="type"><a href="qvariant.html">QVariant</a></span> QCborValue::<span class="name">toVariant</span>() const
</h3> <p>Converts this value to a native Qt type and returns the corresponding <a href="qvariant.html">QVariant</a>.</p> <p>The following table lists the mapping performed between <a href="qcborvalue.html#Type-enum">QCborValue types</a> and <a href="qmetatype.html#Type-enum">Qt meta types</a>.</p> <table class="generic"> <thead><tr class="qt-style">
<th>CBOR Type</th>
<th>Qt or C++ type</th>
<th>Notes</th>
</tr></thead> <tr class="odd" valign="top">
<td>Integer</td>
<td><a href="qtglobal.html#qint64-typedef">qint64</a></td>
<td></td>
</tr> <tr class="even" valign="top">
<td>Double</td>
<td><code>double</code></td>
<td></td>
</tr> <tr class="odd" valign="top">
<td>Bool</td>
<td><code>bool</code></td>
<td></td>
</tr> <tr class="even" valign="top">
<td>Null</td>
<td><code>std::nullptr_t</code></td>
<td></td>
</tr> <tr class="odd" valign="top">
<td>Undefined</td>
<td>no type (QVariant())</td>
<td></td>
</tr> <tr class="even" valign="top">
<td>Byte array</td>
<td><a href="qbytearray.html">QByteArray</a></td>
<td></td>
</tr> <tr class="odd" valign="top">
<td>String</td>
<td><a href="qstring.html">QString</a></td>
<td></td>
</tr> <tr class="even" valign="top">
<td>Array</td>
<td><a href="qvariant.html#QVariantList-typedef">QVariantList</a></td>
<td>Recursively converts all values</td>
</tr> <tr class="odd" valign="top">
<td>Map</td>
<td><a href="qvariant.html#QVariantMap-typedef">QVariantMap</a></td>
<td>Key types are "stringified"</td>
</tr> <tr class="even" valign="top">
<td>Other simple types</td>
<td><a href="qtcborcommon.html#QCborSimpleType-enum">QCborSimpleType</a></td>
<td></td>
</tr> <tr class="odd" valign="top">
<td><a href="qcborvalue.html#Type-enum">DateTime</a></td>
<td><a href="qdatetime.html">QDateTime</a></td>
<td></td>
</tr> <tr class="even" valign="top">
<td>Url</td>
<td><a href="qurl.html">QUrl</a></td>
<td></td>
</tr> <tr class="odd" valign="top">
<td><a href="qcborvalue.html#Type-enum">RegularExpression</a></td>
<td><a href="qregularexpression.html">QRegularExpression</a></td>
<td></td>
</tr> <tr class="even" valign="top">
<td>Uuid</td>
<td><a href="quuid.html">QUuid</a></td>
<td></td>
</tr> <tr class="odd" valign="top">
<td>Other tags</td>
<td>Special</td>
<td>The tag is ignored and the tagged value is converted using this function</td>
</tr> </table> <p>Note that values in both CBOR Maps and Arrays are converted recursively using this function too and placed in QVariantMap and QVariantList instead. You will not find <a href="qcbormap.html">QCborMap</a> and <a href="qcborarray.html">QCborArray</a> stored inside the QVariants.</p> <p>QVariantMaps have string keys, unlike CBOR, so the conversion of a <a href="qcbormap.html">QCborMap</a> to QVariantMap will imply a step of "stringification" of the key values. See <a href="qcbormap.html#toJsonObject">QCborMap::toJsonObject</a>() for details.</p> <p><b>See also </b><a href="qcborvalue.html#fromVariant">fromVariant</a>(), <a href="qcborvalue.html#toJsonValue">toJsonValue</a>(), <a href="qcborarray.html#toVariantList">QCborArray::toVariantList</a>(), and <a href="qcbormap.html#toVariantMap">QCborMap::toVariantMap</a>().</p>   <h3 class="fn" id="type">
<span class="type"><a href="qcborvalue.html#Type-enum">QCborValue::Type</a></span> QCborValue::<span class="name">type</span>() const
</h3> <p>Returns the type of this <a href="qcborvalue.html">QCborValue</a>. The type can also later be retrieved by one of the "isXxx" functions.</p> <p><b>See also </b><a href="qcborvalue.html#isInteger">isInteger</a>(), <a href="qcborvalue.html#isByteArray">isByteArray</a>(), <a href="qcborvalue.html#isString">isString</a>(), <a href="qcborvalue.html#isArray">isArray</a>(), <a href="qcborvalue.html#isMap">isMap</a>(), <a href="qcborvalue.html#isTag">isTag</a>(), <a href="qcborvalue.html#isFalse">isFalse</a>(), <a href="qcborvalue.html#isTrue">isTrue</a>(), <a href="qcborvalue.html#isBool">isBool</a>(), <a href="qcborvalue.html#isNull">isNull</a>(), <a href="qcborvalue.html#isUndefined">isUndefined</a>, <a href="qcborvalue.html#isDouble">isDouble</a>(), <a href="qcborvalue.html#isDateTime">isDateTime</a>(), <a href="qcborvalue.html#isUrl">isUrl</a>(), <a href="qcborvalue.html#isRegularExpression">isRegularExpression</a>(), and <a href="qcborvalue.html#isUuid">isUuid</a>().</p>   <h3 class="fn" id="operator-not-eq">
<span class="type">bool</span> QCborValue::<span class="name">operator!=</span>(const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;<i>other</i>) const
</h3> <p>Compares this value and <i>other</i>, and returns true if contents differ, false otherwise. If each <a href="qcborvalue.html">QCborValue</a> contains an array or map, the comparison is recursive to elements contained in them.</p> <p>For more information on CBOR equality in Qt, see, <a href="qcborvalue.html#compare">QCborValue::compare</a>().</p> <p><b>See also </b><a href="qcborvalue.html#compare">compare</a>(), <a href="qcborvalue.html#operator-eq-eq">QCborValue::operator==</a>(), <a href="qcbormap.html#operator-eq-eq">QCborMap::operator==</a>(), <a href="qcborvalue.html#operator-eq-eq">operator==</a>(), and <a href="qcborvalue.html#operator-lt">operator&lt;</a>().</p>   <h3 class="fn" id="operator-lt">
<span class="type">bool</span> QCborValue::<span class="name">operator&lt;</span>(const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;<i>other</i>) const
</h3> <p>Compares this value and <i>other</i>, and returns true if this value should be sorted before <i>other</i>, false otherwise. If each <a href="qcborvalue.html">QCborValue</a> contains an array or map, the comparison is recursive to elements contained in them.</p> <p>For more information on CBOR sorting order, see <a href="qcborvalue.html#compare">QCborValue::compare</a>().</p> <p><b>See also </b><a href="qcborvalue.html#compare">compare</a>(), <a href="qcborvalue.html#operator-eq-eq">QCborValue::operator==</a>(), <a href="qcbormap.html#operator-eq-eq">QCborMap::operator==</a>(), <a href="qcborvalue.html#operator-eq-eq">operator==</a>(), and <a href="qcborvalue.html#operator-not-eq">operator!=</a>().</p>   <h3 class="fn" id="operator-eq-eq">
<span class="type">bool</span> QCborValue::<span class="name">operator==</span>(const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> &amp;<i>other</i>) const
</h3> <p>Compares this value and <i>other</i>, and returns true if they hold the same contents, false otherwise. If each <a href="qcborvalue.html">QCborValue</a> contains an array or map, the comparison is recursive to elements contained in them.</p> <p>For more information on CBOR equality in Qt, see, <a href="qcborvalue.html#compare">compare</a>().</p> <p><b>See also </b><a href="qcborvalue.html#compare">compare</a>(), QCborValue::operator==(), <a href="qcbormap.html#operator-eq-eq">QCborMap::operator==</a>(), <a href="qcborvalue.html#operator-not-eq">operator!=</a>(), and <a href="qcborvalue.html#operator-lt">operator&lt;</a>().</p>   <h3 class="fn" id="operator-5b-5d">const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> QCborValue::<span class="name">operator[]</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>key</i>) const
</h3> <p>If this <a href="qcborvalue.html">QCborValue</a> is a <a href="qcbormap.html">QCborMap</a>, searches elements for the value whose key matches <i>key</i>. If there's no key matching <i>key</i> in the map or if this <a href="qcborvalue.html">QCborValue</a> object is not a map, returns the undefined value.</p> <p>This function is equivalent to:</p> <pre data-language="cpp">    value.toMap().value(key);</pre> <p><b>See also </b><a href="qcborvalue.html#operator-5b-5d-2">operator[]</a>(qint64), <a href="qcbormap.html#operator-5b-5d">QCborMap::operator[]</a>, <a href="qcbormap.html#value">QCborMap::value</a>(), and <a href="qcbormap.html#find">QCborMap::find</a>().</p>   <h3 class="fn" id="operator-5b-5d-1">const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> QCborValue::<span class="name">operator[]</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>If this <a href="qcborvalue.html">QCborValue</a> is a <a href="qcbormap.html">QCborMap</a>, searches elements for the value whose key matches <i>key</i>. If there's no key matching <i>key</i> in the map or if this <a href="qcborvalue.html">QCborValue</a> object is not a map, returns the undefined value.</p> <p>This function is equivalent to:</p> <pre data-language="cpp">    value.toMap().value(key);</pre> <p><b>See also </b><a href="qcborvalue.html#operator-5b-5d-2">operator[]</a>(qint64), <a href="qcbormap.html#operator-5b-5d">QCborMap::operator[]</a>, <a href="qcbormap.html#value">QCborMap::value</a>(), and <a href="qcbormap.html#find">QCborMap::find</a>().</p>   <h3 class="fn" id="operator-5b-5d-2">const <span class="type"><a href="qcborvalue.html#QCborValue">QCborValue</a></span> QCborValue::<span class="name">operator[]</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>If this <a href="qcborvalue.html">QCborValue</a> is a <a href="qcbormap.html">QCborMap</a>, searches elements for the value whose key matches <i>key</i>. If this is a <a href="qcborarray.html">QCborArray</a>, returns the element whose index is <i>key</i>. If there's no matching value in the array or map, or if this <a href="qcborvalue.html">QCborValue</a> object is not an array or map, returns the undefined value.</p> <p><b>See also </b><a href="qcborvalue.html#operator-5b-5d">operator[]</a>, <a href="qcbormap.html#operator-5b-5d">QCborMap::operator[]</a>, <a href="qcbormap.html#value">QCborMap::value</a>(), <a href="qcbormap.html#find">QCborMap::find</a>(), <a href="qcborarray.html#operator-5b-5d">QCborArray::operator[]</a>, and <a href="qcborarray.html#at">QCborArray::at</a>().</p>   <h3 class="fn" id="operator-5b-5d-3">
<span class="type">QCborValueRef</span> QCborValue::<span class="name">operator[]</span>(<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> <i>key</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a <a href="qcborvalue.html#qcborvalueref">QCborValueRef</a> that can be used to read or modify the entry in this, as a map or array, with the given <i>key</i>. When this <a href="qcborvalue.html">QCborValue</a> is a <a href="qcbormap.html">QCborMap</a> or, for 0 &lt;= key &lt; 0x10000, a <a href="qcborarray.html">QCborArray</a>, this function is equivalent to the matching operator[] on that map or array.</p> <p>Before returning the reference: if this <a href="qcborvalue.html">QCborValue</a> was an array but the key is out of range, the array is first converted to a map (so that <code>map[i]</code> is <code>array[i]</code> for each index, <code>i</code>, with valid <code>array[i]</code>); otherwise, if it was not a map it will be over-written with an empty map.</p> <p><b>See also </b><a href="qcborvalue.html#operator-5b-5d">operator[]</a>, <a href="qcbormap.html#operator-5b-5d">QCborMap::operator[]</a>, <a href="qcbormap.html#value">QCborMap::value</a>(), <a href="qcbormap.html#find">QCborMap::find</a>(), <a href="qcborarray.html#operator-5b-5d">QCborArray::operator[]</a>, and <a href="qcborarray.html#at">QCborArray::at</a>().</p>   <h3 class="fn" id="operator-5b-5d-4">
<span class="type">QCborValueRef</span> QCborValue::<span class="name">operator[]</span>(<span class="type"><a href="qlatin1string.html">QLatin1String</a></span> <i>key</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a <a href="qcborvalue.html#qcborvalueref">QCborValueRef</a> that can be used to read or modify the entry in this, as a map, with the given <i>key</i>. When this <a href="qcborvalue.html">QCborValue</a> is a <a href="qcbormap.html">QCborMap</a>, this function is equivalent to the matching operator[] on that map.</p> <p>Before returning the reference: if this <a href="qcborvalue.html">QCborValue</a> was an array, it is first converted to a map (so that <code>map[i]</code> is <code>array[i]</code> for each index, <code>i</code>, with valid <code>array[i]</code>); otherwise, if it was not a map it will be over-written with an empty map.</p> <p><b>See also </b><a href="qcborvalue.html#operator-5b-5d-2">operator[]</a>(qint64), <a href="qcbormap.html#operator-5b-5d">QCborMap::operator[]</a>, <a href="qcbormap.html#value">QCborMap::value</a>(), and <a href="qcbormap.html#find">QCborMap::find</a>().</p>   <h3 class="fn" id="operator-5b-5d-5">
<span class="type">QCborValueRef</span> QCborValue::<span class="name">operator[]</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>key</i>)
</h3> <p>Returns a <a href="qcborvalue.html#qcborvalueref">QCborValueRef</a> that can be used to read or modify the entry in this, as a map, with the given <i>key</i>. When this <a href="qcborvalue.html">QCborValue</a> is a <a href="qcbormap.html">QCborMap</a>, this function is equivalent to the matching operator[] on that map.</p> <p>Before returning the reference: if this <a href="qcborvalue.html">QCborValue</a> was an array, it is first converted to a map (so that <code>map[i]</code> is <code>array[i]</code> for each index, <code>i</code>, with valid <code>array[i]</code>); otherwise, if it was not a map it will be over-written with an empty map.</p> <p><b>See also </b><a href="qcborvalue.html#operator-5b-5d-2">operator[]</a>(qint64), <a href="qcbormap.html#operator-5b-5d">QCborMap::operator[]</a>, <a href="qcbormap.html#value">QCborMap::value</a>(), and <a href="qcbormap.html#find">QCborMap::find</a>().</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qcborvalue.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qcborvalue.html</a>
  </p>
</div>
