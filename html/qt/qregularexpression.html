<h1 class="title">QRegularExpression Class</h1>  <p>The QRegularExpression class provides pattern matching using regular expressions. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QRegularExpression&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.0</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qregularexpression-members.html">List of all members, including inherited members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="17-qdoc-commands-thread.html#reentrant">reentrant</a>.</p> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#MatchOption-enum">MatchOption</a></b> { NoMatchOption, AnchoredMatchOption, AnchorAtOffsetMatchOption, DontCheckSubjectStringMatchOption }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qregularexpression.html#MatchOption-enum">MatchOptions</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#MatchType-enum">MatchType</a></b> { NormalMatch, PartialPreferCompleteMatch, PartialPreferFirstMatch, NoMatch }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#PatternOption-enum">PatternOption</a></b> { NoPatternOption, CaseInsensitiveOption, DotMatchesEverythingOption, MultilineOption, ExtendedPatternSyntaxOption, â€¦, UseUnicodePropertiesOption }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qregularexpression.html#PatternOption-enum">PatternOptions</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#WildcardConversionOption-enum">WildcardConversionOption</a></b> { DefaultWildcardConversion, UnanchoredWildcardConversion }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qregularexpression.html#WildcardConversionOption-enum">WildcardConversionOptions</a></b></td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#QRegularExpression-3">QRegularExpression</a></b>(QRegularExpression &amp;&amp;<i>re</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#QRegularExpression-2">QRegularExpression</a></b>(const QRegularExpression &amp;<i>re</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#QRegularExpression-1">QRegularExpression</a></b>(const QString &amp;<i>pattern</i>, QRegularExpression::PatternOptions <i>options</i> = NoPatternOption)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRegularExpression &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#operator-eq-1">operator=</a></b>(QRegularExpression &amp;&amp;<i>re</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRegularExpression &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#operator-eq">operator=</a></b>(const QRegularExpression &amp;<i>re</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#dtor.QRegularExpression">~QRegularExpression</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#captureCount">captureCount</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#errorString">errorString</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRegularExpressionMatchIterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#globalMatch">globalMatch</a></b>(const QString &amp;<i>subject</i>, qsizetype <i>offset</i> = 0, QRegularExpression::MatchType <i>matchType</i> = NormalMatch, QRegularExpression::MatchOptions <i>matchOptions</i> = NoMatchOption) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRegularExpressionMatchIterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#globalMatch-1">globalMatch</a></b>(QStringView <i>subjectView</i>, qsizetype <i>offset</i> = 0, QRegularExpression::MatchType <i>matchType</i> = NormalMatch, QRegularExpression::MatchOptions <i>matchOptions</i> = NoMatchOption) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#isValid">isValid</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRegularExpressionMatch </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#match">match</a></b>(const QString &amp;<i>subject</i>, qsizetype <i>offset</i> = 0, QRegularExpression::MatchType <i>matchType</i> = NormalMatch, QRegularExpression::MatchOptions <i>matchOptions</i> = NoMatchOption) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRegularExpressionMatch </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#match-1">match</a></b>(QStringView <i>subjectView</i>, qsizetype <i>offset</i> = 0, QRegularExpression::MatchType <i>matchType</i> = NormalMatch, QRegularExpression::MatchOptions <i>matchOptions</i> = NoMatchOption) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QStringList </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#namedCaptureGroups">namedCaptureGroups</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#optimize">optimize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#pattern">pattern</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#patternErrorOffset">patternErrorOffset</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRegularExpression::PatternOptions </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#patternOptions">patternOptions</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#setPattern">setPattern</a></b>(const QString &amp;<i>pattern</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#setPatternOptions">setPatternOptions</a></b>(QRegularExpression::PatternOptions <i>options</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#swap">swap</a></b>(QRegularExpression &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#operator-not-eq">operator!=</a></b>(const QRegularExpression &amp;<i>re</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#operator-eq-eq">operator==</a></b>(const QRegularExpression &amp;<i>re</i>) const</td>
</tr> </table> <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#anchoredPattern">anchoredPattern</a></b>(QStringView <i>expression</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#anchoredPattern-1">anchoredPattern</a></b>(const QString &amp;<i>expression</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#escape">escape</a></b>(QStringView <i>str</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#escape-1">escape</a></b>(const QString &amp;<i>str</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRegularExpression </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#fromWildcard">fromWildcard</a></b>(QStringView <i>pattern</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseInsensitive, QRegularExpression::WildcardConversionOptions <i>options</i> = DefaultWildcardConversion)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#wildcardToRegularExpression">wildcardToRegularExpression</a></b>(QStringView <i>pattern</i>, QRegularExpression::WildcardConversionOptions <i>options</i> = DefaultWildcardConversion)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#wildcardToRegularExpression-1">wildcardToRegularExpression</a></b>(const QString &amp;<i>pattern</i>, QRegularExpression::WildcardConversionOptions <i>options</i> = DefaultWildcardConversion)</td>
</tr> </table> <h2 id="related-non-members">Related Non-Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> size_t </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#qHash">qHash</a></b>(const QRegularExpression &amp;<i>key</i>, size_t <i>seed</i> = 0)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#operator-lt-lt">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QRegularExpression &amp;<i>re</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDebug </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#operator-lt-lt-1">operator&lt;&lt;</a></b>(QDebug <i>debug</i>, const QRegularExpression &amp;<i>re</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDebug </td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#operator-lt-lt-2">operator&lt;&lt;</a></b>(QDebug <i>debug</i>, QRegularExpression::PatternOptions <i>patternOptions</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qregularexpression.html#operator-gt-gt">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QRegularExpression &amp;<i>re</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>Regular expressions, or <i>regexps</i>, are a very powerful tool to handle strings and texts. This is useful in many contexts, e.g.,</p> <table class="generic"> <tr class="odd" valign="top">
<td>Validation</td>
<td>A regexp can test whether a substring meets some criteria, e.g. is an integer or contains no whitespace.</td>
</tr> <tr class="even" valign="top">
<td>Searching</td>
<td>A regexp provides more powerful pattern matching than simple substring matching, e.g., match one of the words <i>mail</i>, <i>letter</i> or <i>correspondence</i>, but none of the words <i>email</i>, <i>mailman</i>, <i>mailer</i>, <i>letterbox</i>, etc.</td>
</tr> <tr class="odd" valign="top">
<td>Search and Replace</td>
<td>A regexp can replace all occurrences of a substring with a different substring, e.g., replace all occurrences of <i>&amp;</i> with <i>&amp;amp;</i> except where the <i>&amp;</i> is already followed by an <i>amp;</i>.</td>
</tr> <tr class="even" valign="top">
<td>String Splitting</td>
<td>A regexp can be used to identify where a string should be split apart, e.g. splitting tab-delimited strings.</td>
</tr> </table> <p>This document is by no means a complete reference to pattern matching using regular expressions, and the following parts will require the reader to have some basic knowledge about Perl-like regular expressions and their pattern syntax.</p> <p>Good references about regular expressions include:</p> <ul> <li>
<i>Mastering Regular Expressions</i> (Third Edition) by Jeffrey E. F. Friedl, ISBN 0-596-52812-4;</li> <li>the <a href="http://pcre.org/pcre.txt">pcrepattern(3)</a> man page, describing the pattern syntax supported by PCRE (the reference implementation of Perl-compatible regular expressions);</li> <li>the <a href="http://perldoc.perl.org/perlre.html">Perl's regular expression documentation</a> and the <a href="http://perldoc.perl.org/perlretut.html">Perl's regular expression tutorial</a>.</li> </ul> <h3 id="introduction">Introduction
</h3> <p>QRegularExpression implements Perl-compatible regular expressions. It fully supports Unicode. For an overview of the regular expression syntax supported by QRegularExpression, please refer to the aforementioned pcrepattern(3) man page. A regular expression is made up of two things: a <b>pattern string</b> and a set of <b>pattern options</b> that change the meaning of the pattern string.</p> <p>You can set the pattern string by passing a string to the QRegularExpression constructor:</p> <pre data-language="cpp">QRegularExpression re("a pattern");</pre> <p>This sets the pattern string to <code>a pattern</code>. You can also use the <a href="qregularexpression.html#setPattern">setPattern</a>() function to set a pattern on an existing QRegularExpression object:</p> <pre data-language="cpp">QRegularExpression re;
re.setPattern("another pattern");</pre> <p>Note that due to C++ literal strings rules, you must escape all backslashes inside the pattern string with another backslash:</p> <pre data-language="cpp">// matches two digits followed by a space and a word
QRegularExpression re("\\d\\d \\w+");

// matches a backslash
QRegularExpression re2("\\\\");</pre> <p>Alternatively, you can use a <a href="https://en.cppreference.com/w/cpp/language/string_literal">raw string literal</a>, in which case you don't need to escape backslashes in the pattern, all characters between <code>R"(...)"</code> are considered raw characters. As you can see in the following example, this simplifies writing patterns:</p> <pre data-language="cpp">// matches two digits followed by a space and a word
QRegularExpression re(R"(\d\d \w+)");</pre> <p>The <a href="qregularexpression.html#pattern">pattern</a>() function returns the pattern that is currently set for a QRegularExpression object:</p> <pre data-language="cpp">QRegularExpression re("a third pattern");
QString pattern = re.pattern(); // pattern == "a third pattern"</pre> <h3 id="pattern-options">Pattern Options
</h3> <p>The meaning of the pattern string can be modified by setting one or more <i>pattern options</i>. For instance, it is possible to set a pattern to match case insensitively by setting the <a href="qregularexpression.html#PatternOption-enum">QRegularExpression::CaseInsensitiveOption</a>.</p> <p>You can set the options by passing them to the QRegularExpression constructor, as in:</p> <pre data-language="cpp">// matches "Qt rocks", but also "QT rocks", "QT ROCKS", "qT rOcKs", etc.
QRegularExpression re("Qt rocks", QRegularExpression::CaseInsensitiveOption);</pre> <p>Alternatively, you can use the <a href="qregularexpression.html#setPatternOptions">setPatternOptions</a>() function on an existing QRegularExpressionObject:</p> <pre data-language="cpp">QRegularExpression re("^\\d+$");
re.setPatternOptions(QRegularExpression::MultilineOption);
// re matches any line in the subject string that contains only digits (but at least one)</pre> <p>It is possible to get the pattern options currently set on a QRegularExpression object by using the <a href="qregularexpression.html#patternOptions">patternOptions</a>() function:</p> <pre data-language="cpp">QRegularExpression re = QRegularExpression("^two.*words$", QRegularExpression::MultilineOption
                                                           | QRegularExpression::DotMatchesEverythingOption);

QRegularExpression::PatternOptions options = re.patternOptions();
// options == QRegularExpression::MultilineOption | QRegularExpression::DotMatchesEverythingOption</pre> <p>Please refer to the <a href="qregularexpression.html#PatternOption-enum">QRegularExpression::PatternOption</a> enum documentation for more information about each pattern option.</p> <h3 id="match-type-and-match-options">Match Type and Match Options
</h3> <p>The last two arguments of the <a href="qregularexpression.html#match">match</a>() and the <a href="qregularexpression.html#globalMatch">globalMatch</a>() functions set the match type and the match options. The match type is a value of the <a href="qregularexpression.html#MatchType-enum">QRegularExpression::MatchType</a> enum; the "traditional" matching algorithm is chosen by using the <a href="qregularexpression.html#MatchType-enum">NormalMatch</a> match type (the default). It is also possible to enable partial matching of the regular expression against a subject string: see the <a href="qregularexpression.html#partial-matching">partial matching</a> section for more details.</p> <p>The match options are a set of one or more <a href="qregularexpression.html#MatchOption-enum">QRegularExpression::MatchOption</a> values. They change the way a specific match of a regular expression against a subject string is done. Please refer to the <a href="qregularexpression.html#MatchOption-enum">QRegularExpression::MatchOption</a> enum documentation for more details.</p> <h3 id="normal-matching">Normal Matching
</h3> <p>In order to perform a match you can simply invoke the <a href="qregularexpression.html#match">match</a>() function passing a string to match against. We refer to this string as the <i>subject string</i>. The result of the <a href="qregularexpression.html#match">match</a>() function is a <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object that can be used to inspect the results of the match. For instance:</p> <pre data-language="cpp">// match two digits followed by a space and a word
QRegularExpression re("\\d\\d \\w+");
QRegularExpressionMatch match = re.match("abc123 def");
bool hasMatch = match.hasMatch(); // true</pre> <p>If a match is successful, the (implicit) capturing group number 0 can be used to retrieve the substring matched by the entire pattern (see also the section about <a href="qregularexpression.html#extracting-captured-substrings">extracting captured substrings</a>):</p> <pre data-language="cpp">QRegularExpression re("\\d\\d \\w+");
QRegularExpressionMatch match = re.match("abc123 def");
if (match.hasMatch()) {
    QString matched = match.captured(0); // matched == "23 def"
    // ...
}</pre> <p>It's also possible to start a match at an arbitrary offset inside the subject string by passing the offset as an argument of the <a href="qregularexpression.html#match">match</a>() function. In the following example <code>"12 abc"</code> is not matched because the match is started at offset 1:</p> <pre data-language="cpp">QRegularExpression re("\\d\\d \\w+");
QRegularExpressionMatch match = re.match("12 abc 45 def", 1);
if (match.hasMatch()) {
    QString matched = match.captured(0); // matched == "45 def"
    // ...
}</pre> <h4 id="extracting-captured-substrings">Extracting captured substrings
</h4> <p>The <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object contains also information about the substrings captured by the capturing groups in the pattern string. The <a href="qregularexpressionmatch.html#captured">captured</a>() function will return the string captured by the n-th capturing group:</p> <pre data-language="cpp">QRegularExpression re("^(\\d\\d)/(\\d\\d)/(\\d\\d\\d\\d)$");
QRegularExpressionMatch match = re.match("08/12/1985");
if (match.hasMatch()) {
    QString day = match.captured(1); // day == "08"
    QString month = match.captured(2); // month == "12"
    QString year = match.captured(3); // year == "1985"
    // ...
}</pre> <p>Capturing groups in the pattern are numbered starting from 1, and the implicit capturing group 0 is used to capture the substring that matched the entire pattern.</p> <p>It's also possible to retrieve the starting and the ending offsets (inside the subject string) of each captured substring, by using the <a href="qregularexpressionmatch.html#capturedStart">capturedStart</a>() and the <a href="qregularexpressionmatch.html#capturedEnd">capturedEnd</a>() functions:</p> <pre data-language="cpp">QRegularExpression re("abc(\\d+)def");
QRegularExpressionMatch match = re.match("XYZabc123defXYZ");
if (match.hasMatch()) {
    int startOffset = match.capturedStart(1); // startOffset == 6
    int endOffset = match.capturedEnd(1); // endOffset == 9
    // ...
}</pre> <p>All of these functions have an overload taking a <a href="qstring.html">QString</a> as a parameter in order to extract <i>named</i> captured substrings. For instance:</p> <pre data-language="cpp">QRegularExpression re("^(?&lt;date&gt;\\d\\d)/(?&lt;month&gt;\\d\\d)/(?&lt;year&gt;\\d\\d\\d\\d)$");
QRegularExpressionMatch match = re.match("08/12/1985");
if (match.hasMatch()) {
    QString date = match.captured("date"); // date == "08"
    QString month = match.captured("month"); // month == "12"
    QString year = match.captured("year"); // year == 1985
}</pre> <h3 id="global-matching">Global Matching
</h3> <p><i>Global matching</i> is useful to find all the occurrences of a given regular expression inside a subject string. Suppose that we want to extract all the words from a given string, where a word is a substring matching the pattern <code>\w+</code>.</p> <p><a href="qregularexpression.html#globalMatch">QRegularExpression::globalMatch</a> returns a <a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a>, which is a Java-like forward iterator that can be used to iterate over the results. For instance:</p> <pre data-language="cpp">QRegularExpression re("(\\w+)");
QRegularExpressionMatchIterator i = re.globalMatch("the quick fox");</pre> <p>Since it's a Java-like iterator, the <a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a> will point immediately before the first result. Every result is returned as a <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object. The <a href="qregularexpressionmatchiterator.html#hasNext">hasNext</a>() function will return true if there's at least one more result, and <a href="qregularexpressionmatchiterator.html#next">next</a>() will return the next result and advance the iterator. Continuing from the previous example:</p> <pre data-language="cpp">QStringList words;
while (i.hasNext()) {
    QRegularExpressionMatch match = i.next();
    QString word = match.captured(1);
    words &lt;&lt; word;
}
// words contains "the", "quick", "fox"</pre> <p>You can also use <a href="qregularexpressionmatchiterator.html#peekNext">peekNext</a>() to get the next result without advancing the iterator.</p> <p>It is also possible to simply use the result of <a href="qregularexpression.html#globalMatch">QRegularExpression::globalMatch</a> in a range-based for loop, for instance like this:</p> <pre data-language="cpp">// using a raw string literal, R"(raw_characters)", to be able to use "\w"
// without having to escape the backslash as "\\w"
QRegularExpression re(R"(\w+)");
QString subject("the quick fox");
for (const QRegularExpressionMatch &amp;match : re.globalMatch(subject)) {
    // ...
}</pre> <p>It is possible to pass a starting offset and one or more match options to the <a href="qregularexpression.html#globalMatch">globalMatch</a>() function, exactly like normal matching with <a href="qregularexpression.html#match">match</a>().</p> <h3 id="partial-matching">Partial Matching
</h3> <p>A <i>partial match</i> is obtained when the end of the subject string is reached, but more characters are needed to successfully complete the match. Note that a partial match is usually much more inefficient than a normal match because many optimizations of the matching algorithm cannot be employed.</p> <p>A partial match must be explicitly requested by specifying a match type of <a href="qregularexpression.html#MatchType-enum">PartialPreferCompleteMatch</a> or <a href="qregularexpression.html#MatchType-enum">PartialPreferFirstMatch</a> when calling <a href="qregularexpression.html#match">QRegularExpression::match</a> or <a href="qregularexpression.html#globalMatch">QRegularExpression::globalMatch</a>. If a partial match is found, then calling the <a href="qregularexpressionmatch.html#hasMatch">hasMatch</a>() function on the <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object returned by <a href="qregularexpression.html#match">match</a>() will return <code>false</code>, but <a href="qregularexpressionmatch.html#hasPartialMatch">hasPartialMatch</a>() will return <code>true</code>.</p> <p>When a partial match is found, no captured substrings are returned, and the (implicit) capturing group 0 corresponding to the whole match captures the partially matched substring of the subject string.</p> <p>Note that asking for a partial match can still lead to a complete match, if one is found; in this case, <a href="qregularexpressionmatch.html#hasMatch">hasMatch</a>() will return <code>true</code> and <a href="qregularexpressionmatch.html#hasPartialMatch">hasPartialMatch</a>() <code>false</code>. It never happens that a <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> reports both a partial and a complete match.</p> <p>Partial matching is mainly useful in two scenarios: validating user input in real time and incremental/multi-segment matching.</p> <h4 id="validating-user-input">Validating user input
</h4> <p>Suppose that we would like the user to input a date in a specific format, for instance "MMM dd, yyyy". We can check the input validity with a pattern like:</p> <p><code>^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \d\d?, \d\d\d\d$</code></p> <p>(This pattern doesn't catch invalid days, but let's keep it for the example's purposes).</p> <p>We would like to validate the input with this regular expression <i>while</i> the user is typing it, so that we can report an error in the input as soon as it is committed (for instance, the user typed the wrong key). In order to do so we must distinguish three cases:</p> <ul> <li>the input cannot possibly match the regular expression;</li> <li>the input does match the regular expression;</li> <li>the input does not match the regular expression right now, but it will if more characters will be added to it.</li> </ul> <p>Note that these three cases represent exactly the possible states of a <a href="qvalidator.html">QValidator</a> (see the <a href="qvalidator.html#State-enum">QValidator::State</a> enum).</p> <p>In particular, in the last case we want the regular expression engine to report a partial match: we are successfully matching the pattern against the subject string but the matching cannot continue because the end of the subject is encountered. Notice, however, that the matching algorithm should continue and try all possibilities, and in case a complete (non-partial) match is found, then this one should be reported, and the input string accepted as fully valid.</p> <p>This behavior is implemented by the <a href="qregularexpression.html#MatchType-enum">PartialPreferCompleteMatch</a> match type. For instance:</p> <pre data-language="cpp">QString pattern("^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d?, \\d\\d\\d\\d$");
QRegularExpression re(pattern);

QString input("Jan 21,");
QRegularExpressionMatch match = re.match(input, 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true</pre> <p>If matching the same regular expression against the subject string leads to a complete match, it is reported as usual:</p> <pre data-language="cpp">QString input("Dec 8, 1985");
QRegularExpressionMatch match = re.match(input, 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // true
bool hasPartialMatch = match.hasPartialMatch(); // false</pre> <p>Another example with a different pattern, showing the behavior of preferring a complete match over a partial one:</p> <pre data-language="cpp">QRegularExpression re("abc\\w+X|def");
QRegularExpressionMatch match = re.match("abcdef", 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // true
bool hasPartialMatch = match.hasPartialMatch(); // false
QString captured = match.captured(0); // captured == "def"</pre> <p>In this case, the subpattern <code>abc\\w+X</code> partially matches the subject string; however, the subpattern <code>def</code> matches the subject string completely, and therefore a complete match is reported.</p> <p>If multiple partial matches are found when matching (but no complete match), then the <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object will report the first one that is found. For instance:</p> <pre data-language="cpp">QRegularExpression re("abc\\w+X|defY");
QRegularExpressionMatch match = re.match("abcdef", 0, QRegularExpression::PartialPreferCompleteMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true
QString captured = match.captured(0); // captured == "abcdef"</pre> <h4 id="incremental-multi-segment-matching">Incremental/multi-segment matching
</h4> <p>Incremental matching is another use case of partial matching. Suppose that we want to find the occurrences of a regular expression inside a large text (that is, substrings matching the regular expression). In order to do so we would like to "feed" the large text to the regular expression engines in smaller chunks. The obvious problem is what happens if the substring that matches the regular expression spans across two or more chunks.</p> <p>In this case, the regular expression engine should report a partial match, so that we can match again adding new data and (eventually) get a complete match. This implies that the regular expression engine may assume that there are other characters <i>beyond the end</i> of the subject string. This is not to be taken literally -- the engine will never try to access any character after the last one in the subject.</p> <p>QRegularExpression implements this behavior when using the <a href="qregularexpression.html#MatchType-enum">PartialPreferFirstMatch</a> match type. This match type reports a partial match as soon as it is found, and other match alternatives are not tried (even if they could lead to a complete match). For instance:</p> <pre data-language="cpp">QRegularExpression re("abc|ab");
QRegularExpressionMatch match = re.match("ab", 0, QRegularExpression::PartialPreferFirstMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true</pre> <p>This happens because when matching the first branch of the alternation operator a partial match is found, and therefore matching stops, without trying the second branch. Another example:</p> <pre data-language="cpp">QRegularExpression re("abc(def)?");
QRegularExpressionMatch match = re.match("abc", 0, QRegularExpression::PartialPreferFirstMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true</pre> <p>This shows what could seem a counterintuitive behavior of quantifiers: since <code>?</code> is greedy, then the engine tries first to continue the match after having matched <code>"abc"</code>; but then the matching reaches the end of the subject string, and therefore a partial match is reported. This is even more surprising in the following example:</p> <pre data-language="cpp">QRegularExpression re("(abc)*");
QRegularExpressionMatch match = re.match("abc", 0, QRegularExpression::PartialPreferFirstMatch);
bool hasMatch = match.hasMatch(); // false
bool hasPartialMatch = match.hasPartialMatch(); // true</pre> <p>It's easy to understand this behavior if we remember that the engine expects the subject string to be only a substring of the whole text we're looking for a match into (that is, how we said before, that the engine assumes that there are other characters beyond the end of the subject string).</p> <p>Since the <code>*</code> quantifier is greedy, then reporting a complete match could be an error, because after the current subject <code>"abc"</code> there may be other occurrences of <code>"abc"</code>. For instance, the complete text could have been "abcabcX", and therefore the <i>right</i> match to report (in the complete text) would have been <code>"abcabc"</code>; by matching only against the leading <code>"abc"</code> we instead get a partial match.</p> <h3 id="error-handling">Error Handling
</h3> <p>It is possible for a QRegularExpression object to be invalid because of syntax errors in the pattern string. The <a href="qregularexpression.html#isValid">isValid</a>() function will return true if the regular expression is valid, or false otherwise:</p> <pre data-language="cpp">QRegularExpression invalidRe("(unmatched|parenthesis");
bool isValid = invalidRe.isValid(); // false</pre> <p>You can get more information about the specific error by calling the <a href="qregularexpression.html#errorString">errorString</a>() function; moreover, the <a href="qregularexpression.html#patternErrorOffset">patternErrorOffset</a>() function will return the offset inside the pattern string</p> <pre data-language="cpp">QRegularExpression invalidRe("(unmatched|parenthesis");
if (!invalidRe.isValid()) {
    QString errorString = invalidRe.errorString(); // errorString == "missing )"
    int errorOffset = invalidRe.patternErrorOffset(); // errorOffset == 22
    // ...
}</pre> <p>If a match is attempted with an invalid QRegularExpression, then the returned <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object will be invalid as well (that is, its <a href="qregularexpressionmatch.html#isValid">isValid</a>() function will return false). The same applies for attempting a global match.</p> <h3 id="unsupported-perl-compatible-regular-expressions-features">Unsupported Perl-compatible Regular Expressions Features
</h3> <p>QRegularExpression does not support all the features available in Perl-compatible regular expressions. The most notable one is the fact that duplicated names for capturing groups are not supported, and using them can lead to undefined behavior.</p> <p>This may change in a future version of Qt.</p> <h3 id="debugging-code-that-uses-qregularexpression">Debugging Code that Uses QRegularExpression
</h3> <p>QRegularExpression internally uses a just in time compiler (JIT) to optimize the execution of the matching algorithm. The JIT makes extensive usage of self-modifying code, which can lead debugging tools such as Valgrind to crash. You must enable all checks for self-modifying code if you want to debug programs using QRegularExpression (for instance, Valgrind's <code>--smc-check</code> command line option). The downside of enabling such checks is that your program will run considerably slower.</p> <p>To avoid that, the JIT is disabled by default if you compile Qt in debug mode. It is possible to override the default and enable or disable the JIT usage (both in debug or release mode) by setting the <code>QT_ENABLE_REGEXP_JIT</code> environment variable to a non-zero or zero value respectively.</p>  <p><b>See also </b><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> and <a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="flags" id="MatchOption-enum">enum QRegularExpression::<span class="name">MatchOption</span>flags QRegularExpression::<span class="name">MatchOptions</span>
</h3> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::NoMatchOption</code></td>
<td class="topAlign tblval"><code>0x0000</code></td>
<td class="topAlign">No match options are set.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::AnchoredMatchOption</code></td>
<td class="topAlign tblval"><code>AnchorAtOffsetMatchOption</code></td>
<td class="topAlign">Use AnchorAtOffsetMatchOption instead.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::AnchorAtOffsetMatchOption</code></td>
<td class="topAlign tblval"><code>0x0001</code></td>
<td class="topAlign">The match is constrained to start exactly at the offset passed to <a href="qregularexpression.html#match">match</a>() in order to be successful, even if the pattern string does not contain any metacharacter that anchors the match at that point. Note that passing this option does not anchor the end of the match to the end of the subject; if you want to fully anchor a regular expression, use <a href="qregularexpression.html#anchoredPattern">anchoredPattern</a>(). This enum value has been introduced in Qt 6.0.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::DontCheckSubjectStringMatchOption</code></td>
<td class="topAlign tblval"><code>0x0002</code></td>
<td class="topAlign">The subject string is not checked for UTF-16 validity before attempting a match. Use this option with extreme caution, as attempting to match an invalid string may crash the program and/or constitute a security issue. This enum value has been introduced in Qt 5.4.</td>
</tr> </table> <p>The MatchOptions type is a typedef for <a href="qflags.html">QFlags</a>&lt;MatchOption&gt;. It stores an OR combination of MatchOption values.</p>   <h3 class="fn" id="MatchType-enum">enum QRegularExpression::<span class="name">MatchType</span>
</h3> <p>The MatchType enum defines the type of the match that should be attempted against the subject string.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::NormalMatch</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">A normal match is done.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::PartialPreferCompleteMatch</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The pattern string is matched partially against the subject string. If a partial match is found, then it is recorded, and other matching alternatives are tried as usual. If a complete match is then found, then it's preferred to the partial match; in this case only the complete match is reported. If instead no complete match is found (but only the partial one), then the partial one is reported.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::PartialPreferFirstMatch</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">The pattern string is matched partially against the subject string. If a partial match is found, then matching stops and the partial match is reported. In this case, other matching alternatives (potentially leading to a complete match) are not tried. Moreover, this match type assumes that the subject string only a substring of a larger text, and that (in this text) there are other characters beyond the end of the subject string. This can lead to surprising results; see the discussion in the <a href="qregularexpression.html#partial-matching">partial matching</a> section for more details.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::NoMatch</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">No matching is done. This value is returned as the match type by a default constructed <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> or <a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a>. Using this match type is not very useful for the user, as no matching ever happens. This enum value has been introduced in Qt 5.1.</td>
</tr> </table>   <h3 class="flags" id="PatternOption-enum">enum QRegularExpression::<span class="name">PatternOption</span>flags QRegularExpression::<span class="name">PatternOptions</span>
</h3> <p>The PatternOption enum defines modifiers to the way the pattern string should be interpreted, and therefore the way the pattern matches against a subject string.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::NoPatternOption</code></td>
<td class="topAlign tblval"><code>0x0000</code></td>
<td class="topAlign">No pattern options are set.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::CaseInsensitiveOption</code></td>
<td class="topAlign tblval"><code>0x0001</code></td>
<td class="topAlign">The pattern should match against the subject string in a case insensitive way. This option corresponds to the /i modifier in Perl regular expressions.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::DotMatchesEverythingOption</code></td>
<td class="topAlign tblval"><code>0x0002</code></td>
<td class="topAlign">The dot metacharacter (<code>.</code>) in the pattern string is allowed to match any character in the subject string, including newlines (normally, the dot does not match newlines). This option corresponds to the <code>/s</code> modifier in Perl regular expressions.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::MultilineOption</code></td>
<td class="topAlign tblval"><code>0x0004</code></td>
<td class="topAlign">The caret (<code>^</code>) and the dollar (<code>$</code>) metacharacters in the pattern string are allowed to match, respectively, immediately after and immediately before any newline in the subject string, as well as at the very beginning and at the very end of the subject string. This option corresponds to the <code>/m</code> modifier in Perl regular expressions.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::ExtendedPatternSyntaxOption</code></td>
<td class="topAlign tblval"><code>0x0008</code></td>
<td class="topAlign">Any whitespace in the pattern string which is not escaped and outside a character class is ignored. Moreover, an unescaped sharp (<b>#</b>) outside a character class causes all the following characters, until the first newline (included), to be ignored. This can be used to increase the readability of a pattern string as well as put comments inside regular expressions; this is particularly useful if the pattern string is loaded from a file or written by the user, because in C++ code it is always possible to use the rules for string literals to put comments outside the pattern string. This option corresponds to the <code>/x</code> modifier in Perl regular expressions.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::InvertedGreedinessOption</code></td>
<td class="topAlign tblval"><code>0x0010</code></td>
<td class="topAlign">The greediness of the quantifiers is inverted: <code>*</code>, <code>+</code>, <code>?</code>, <code>{m,n}</code>, etc. become lazy, while their lazy versions (<code>*?</code>, <code>+?</code>, <code>??</code>, <code>{m,n}?</code>, etc.) become greedy. There is no equivalent for this option in Perl regular expressions.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::DontCaptureOption</code></td>
<td class="topAlign tblval"><code>0x0020</code></td>
<td class="topAlign">The non-named capturing groups do not capture substrings; named capturing groups still work as intended, as well as the implicit capturing group number 0 corresponding to the entire match. There is no equivalent for this option in Perl regular expressions.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::UseUnicodePropertiesOption</code></td>
<td class="topAlign tblval"><code>0x0040</code></td>
<td class="topAlign">The meaning of the <code>\w</code>, <code>\d</code>, etc., character classes, as well as the meaning of their counterparts (<code>\W</code>, <code>\D</code>, etc.), is changed from matching ASCII characters only to matching any character with the corresponding Unicode property. For instance, <code>\d</code> is changed to match any character with the Unicode Nd (decimal digit) property; <code>\w</code> to match any character with either the Unicode L (letter) or N (digit) property, plus underscore, and so on. This option corresponds to the <code>/u</code> modifier in Perl regular expressions.</td>
</tr> </table> <p>The PatternOptions type is a typedef for <a href="qflags.html">QFlags</a>&lt;PatternOption&gt;. It stores an OR combination of PatternOption values.</p>   <h3 class="flags" id="WildcardConversionOption-enum">
<code>[since 6.0] </code>enum QRegularExpression::<span class="name">WildcardConversionOption</span>flags QRegularExpression::<span class="name">WildcardConversionOptions</span>
</h3> <p>The WildcardConversionOption enum defines modifiers to the way a wildcard glob pattern gets converted to a regular expression pattern.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::DefaultWildcardConversion</code></td>
<td class="topAlign tblval"><code>0x0</code></td>
<td class="topAlign">No conversion options are set.</td>
</tr> <tr>
<td class="topAlign"><code>QRegularExpression::UnanchoredWildcardConversion</code></td>
<td class="topAlign tblval"><code>0x1</code></td>
<td class="topAlign">The conversion will not anchor the pattern. This allows for partial string matches of wildcard expressions.</td>
</tr> </table> <p>This enum was introduced or modified in Qt 6.0.</p> <p>The WildcardConversionOptions type is a typedef for <a href="qflags.html">QFlags</a>&lt;WildcardConversionOption&gt;. It stores an OR combination of WildcardConversionOption values.</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QRegularExpression-3">
<code>[since 6.1] </code>QRegularExpression::<span class="name">QRegularExpression</span>(<span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;&amp;<i>re</i>)
</h3> <p>Constructs a QRegularExpression object by moving from <i>re</i>.</p> <p>Note that a moved-from QRegularExpression can only be destroyed or assigned to. The effect of calling other functions than the destructor or one of the assignment operators is undefined.</p> <p>This function was introduced in Qt 6.1.</p> <p><b>See also </b><a href="qregularexpression.html#operator-eq">operator=</a>().</p>   <h3 class="fn" id="QRegularExpression-2">QRegularExpression::<span class="name">QRegularExpression</span>(const <span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;<i>re</i>)
</h3> <p>Constructs a QRegularExpression object as a copy of <i>re</i>.</p> <p><b>See also </b><a href="qregularexpression.html#operator-eq">operator=</a>().</p>   <h3 class="fn" id="QRegularExpression-1">QRegularExpression::<span class="name">QRegularExpression</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>pattern</i>, <span class="type"><a href="qregularexpression.html#PatternOption-enum">QRegularExpression::PatternOptions</a></span> <i>options</i> = NoPatternOption)
</h3> <p>Constructs a QRegularExpression object using the given <i>pattern</i> as pattern and the <i>options</i> as the pattern options.</p> <p><b>See also </b><a href="qregularexpression.html#setPattern">setPattern</a>() and <a href="qregularexpression.html#setPatternOptions">setPatternOptions</a>().</p>   <h3 class="fn" id="QRegularExpression">QRegularExpression::<span class="name">QRegularExpression</span>()
</h3> <p>Constructs a QRegularExpression object with an empty pattern and no pattern options.</p> <p><b>See also </b><a href="qregularexpression.html#setPattern">setPattern</a>() and <a href="qregularexpression.html#setPatternOptions">setPatternOptions</a>().</p>   <h3 class="fn" id="operator-eq-1">
<span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;QRegularExpression::<span class="name">operator=</span>(<span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;&amp;<i>re</i>)
</h3> <p>Move-assigns the regular expression <i>re</i> to this object, and returns a reference to the result. Both the pattern and the pattern options are copied.</p> <p>Note that a moved-from <a href="qregularexpression.html">QRegularExpression</a> can only be destroyed or assigned to. The effect of calling other functions than the destructor or one of the assignment operators is undefined.</p>   <h3 class="fn" id="operator-eq">
<span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;QRegularExpression::<span class="name">operator=</span>(const <span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;<i>re</i>)
</h3> <p>Assigns the regular expression <i>re</i> to this object, and returns a reference to the copy. Both the pattern and the pattern options are copied.</p>   <h3 class="fn" id="dtor.QRegularExpression">QRegularExpression::<span class="name">~QRegularExpression</span>()
</h3> <p>Destroys the <a href="qregularexpression.html">QRegularExpression</a> object.</p>   <h3 class="fn" id="anchoredPattern">
<code>[static, since 5.15] </code><span class="type"><a href="qstring.html">QString</a></span> QRegularExpression::<span class="name">anchoredPattern</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>expression</i>)
</h3> <p>Returns the <i>expression</i> wrapped between the <code>\A</code> and <code>\z</code> anchors to be used for exact matching.</p> <p>This function was introduced in Qt 5.15.</p>   <h3 class="fn" id="anchoredPattern-1">
<code>[static, since 5.12] </code><span class="type"><a href="qstring.html">QString</a></span> QRegularExpression::<span class="name">anchoredPattern</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>expression</i>)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.12.</p>   <h3 class="fn" id="captureCount">
<span class="type">int</span> QRegularExpression::<span class="name">captureCount</span>() const
</h3> <p>Returns the number of capturing groups inside the pattern string, or -1 if the regular expression is not valid.</p> <div class="admonition note"> <p><b>Note: </b>The implicit capturing group 0 is <i>not</i> included in the returned number.</p> </div> <p><b>See also </b><a href="qregularexpression.html#isValid">isValid</a>().</p>   <h3 class="fn" id="errorString">
<span class="type"><a href="qstring.html">QString</a></span> QRegularExpression::<span class="name">errorString</span>() const
</h3> <p>Returns a textual description of the error found when checking the validity of the regular expression, or "no error" if no error was found.</p> <p><b>See also </b><a href="qregularexpression.html#isValid">isValid</a>() and <a href="qregularexpression.html#patternErrorOffset">patternErrorOffset</a>().</p>   <h3 class="fn" id="escape">
<code>[static, since 5.15] </code><span class="type"><a href="qstring.html">QString</a></span> QRegularExpression::<span class="name">escape</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>str</i>)
</h3> <p>Escapes all characters of <i>str</i> so that they no longer have any special meaning when used as a regular expression pattern string, and returns the escaped string. For instance:</p> <pre data-language="cpp">QString escaped = QRegularExpression::escape("a(x) = f(x) + g(x)");
// escaped == "a\\(x\\)\\ \\=\\ f\\(x\\)\\ \\+\\ g\\(x\\)"</pre> <p>This is very convenient in order to build patterns from arbitrary strings:</p> <pre data-language="cpp">QString pattern = "(" + QRegularExpression::escape(name) +
                  "|" + QRegularExpression::escape(nickname) + ")";
QRegularExpression re(pattern);</pre> <div class="admonition note"> <p><b>Note: </b>This function implements Perl's quotemeta algorithm and escapes with a backslash all characters in <i>str</i>, except for the characters in the <code>[A-Z]</code>, <code>[a-z]</code> and <code>[0-9]</code> ranges, as well as the underscore (<code>_</code>) character. The only difference with Perl is that a literal NUL inside <i>str</i> is escaped with the sequence <code>"\\0"</code> (backslash + <code>'0'</code>), instead of <code>"\\\0"</code> (backslash + <code>NUL</code>).</p> </div> <p>This function was introduced in Qt 5.15.</p>   <h3 class="fn" id="escape-1">
<code>[static] </code><span class="type"><a href="qstring.html">QString</a></span> QRegularExpression::<span class="name">escape</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>)
</h3> <p>This is an overloaded function.</p>   <h3 class="fn" id="fromWildcard">
<code>[static, since 6.0] </code><span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> QRegularExpression::<span class="name">fromWildcard</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>pattern</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseInsensitive, <span class="type"><a href="qregularexpression.html#WildcardConversionOption-enum">QRegularExpression::WildcardConversionOptions</a></span> <i>options</i> = DefaultWildcardConversion)
</h3> <p>Returns a regular expression of the glob pattern <i>pattern</i>. The regular expression will be case sensitive if <i>cs</i> is <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a>, and converted according to <i>options</i>.</p> <p>Equivalent to</p> <pre data-language="cpp">auto reOptions = cs == Qt::CaseSensitive ? QRegularExpression::NoPatternOption :
                                           QRegularExpression::CaseInsensitiveOption;
return QRegularExpression(wildcardToRegularExpression(str, options), reOptions);</pre> <p>This function was introduced in Qt 6.0.</p>   <h3 class="fn" id="globalMatch">
<span class="type"><a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a></span> QRegularExpression::<span class="name">globalMatch</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>subject</i>, <span class="type">qsizetype</span> <i>offset</i> = 0, <span class="type"><a href="qregularexpression.html#MatchType-enum">QRegularExpression::MatchType</a></span> <i>matchType</i> = NormalMatch, <span class="type"><a href="qregularexpression.html#MatchOption-enum">QRegularExpression::MatchOptions</a></span> <i>matchOptions</i> = NoMatchOption) const
</h3> <p>Attempts to perform a global match of the regular expression against the given <i>subject</i> string, starting at the position <i>offset</i> inside the subject, using a match of type <i>matchType</i> and honoring the given <i>matchOptions</i>.</p> <p>The returned <a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a> is positioned before the first match result (if any).</p> <div class="admonition note"> <p><b>Note: </b>The data referenced by <i>subject</i> should remain valid as long as there are <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> objects using it. At the moment Qt makes a (shallow) copy of the data, but this behavior may change in a future version of Qt.</p> </div> <p><b>See also </b><a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a> and <a href="qregularexpression.html#global-matching">global matching</a>.</p>   <h3 class="fn" id="globalMatch-1">
<code>[since 6.0] </code><span class="type"><a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a></span> QRegularExpression::<span class="name">globalMatch</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>subjectView</i>, <span class="type">qsizetype</span> <i>offset</i> = 0, <span class="type"><a href="qregularexpression.html#MatchType-enum">QRegularExpression::MatchType</a></span> <i>matchType</i> = NormalMatch, <span class="type"><a href="qregularexpression.html#MatchOption-enum">QRegularExpression::MatchOptions</a></span> <i>matchOptions</i> = NoMatchOption) const
</h3> <p>This is an overloaded function.</p> <p>Attempts to perform a global match of the regular expression against the given <i>subjectView</i> string view, starting at the position <i>offset</i> inside the subject, using a match of type <i>matchType</i> and honoring the given <i>matchOptions</i>.</p> <p>The returned <a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a> is positioned before the first match result (if any).</p> <div class="admonition note"> <p><b>Note: </b>The data referenced by <i>subjectView</i> must remain valid as long as there are <a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a> or <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> objects using it.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a> and <a href="qregularexpression.html#global-matching">global matching</a>.</p>   <h3 class="fn" id="isValid">
<span class="type">bool</span> QRegularExpression::<span class="name">isValid</span>() const
</h3> <p>Returns <code>true</code> if the regular expression is a valid regular expression (that is, it contains no syntax errors, etc.), or false otherwise. Use <a href="qregularexpression.html#errorString">errorString</a>() to obtain a textual description of the error.</p> <p><b>See also </b><a href="qregularexpression.html#errorString">errorString</a>() and <a href="qregularexpression.html#patternErrorOffset">patternErrorOffset</a>().</p>   <h3 class="fn" id="match">
<span class="type"><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a></span> QRegularExpression::<span class="name">match</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>subject</i>, <span class="type">qsizetype</span> <i>offset</i> = 0, <span class="type"><a href="qregularexpression.html#MatchType-enum">QRegularExpression::MatchType</a></span> <i>matchType</i> = NormalMatch, <span class="type"><a href="qregularexpression.html#MatchOption-enum">QRegularExpression::MatchOptions</a></span> <i>matchOptions</i> = NoMatchOption) const
</h3> <p>Attempts to match the regular expression against the given <i>subject</i> string, starting at the position <i>offset</i> inside the subject, using a match of type <i>matchType</i> and honoring the given <i>matchOptions</i>.</p> <p>The returned <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object contains the results of the match.</p> <div class="admonition note"> <p><b>Note: </b>The data referenced by <i>subject</i> should remain valid as long as there are <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> objects using it. At the moment Qt makes a (shallow) copy of the data, but this behavior may change in a future version of Qt.</p> </div> <p><b>See also </b><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> and <a href="qregularexpression.html#normal-matching">normal matching</a>.</p>   <h3 class="fn" id="match-1">
<code>[since 6.0] </code><span class="type"><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a></span> QRegularExpression::<span class="name">match</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>subjectView</i>, <span class="type">qsizetype</span> <i>offset</i> = 0, <span class="type"><a href="qregularexpression.html#MatchType-enum">QRegularExpression::MatchType</a></span> <i>matchType</i> = NormalMatch, <span class="type"><a href="qregularexpression.html#MatchOption-enum">QRegularExpression::MatchOptions</a></span> <i>matchOptions</i> = NoMatchOption) const
</h3> <p>This is an overloaded function.</p> <p>Attempts to match the regular expression against the given <i>subjectView</i> string view, starting at the position <i>offset</i> inside the subject, using a match of type <i>matchType</i> and honoring the given <i>matchOptions</i>.</p> <p>The returned <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> object contains the results of the match.</p> <div class="admonition note"> <p><b>Note: </b>The data referenced by <i>subjectView</i> must remain valid as long as there are <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> objects using it.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> and <a href="qregularexpression.html#normal-matching">normal matching</a>.</p>   <h3 class="fn" id="namedCaptureGroups">
<code>[since 5.1] </code><span class="type"><a href="qstringlist.html">QStringList</a></span> QRegularExpression::<span class="name">namedCaptureGroups</span>() const
</h3> <p>Returns a list of <a href="qregularexpression.html#captureCount">captureCount</a>() + 1 elements, containing the names of the named capturing groups in the pattern string. The list is sorted such that the element of the list at position <code>i</code> is the name of the <code>i</code>-th capturing group, if it has a name, or an empty string if that capturing group is unnamed.</p> <p>For instance, given the regular expression</p> <pre data-language="cpp">    (?&lt;day&gt;\d\d)-(?&lt;month&gt;\d\d)-(?&lt;year&gt;\d\d\d\d) (\w+) (?&lt;name&gt;\w+)</pre> <p>namedCaptureGroups() will return the following list:</p> <pre data-language="cpp">    ("", "day", "month", "year", "", "name")</pre> <p>which corresponds to the fact that the capturing group #0 (corresponding to the whole match) has no name, the capturing group #1 has name "day", the capturing group #2 has name "month", etc.</p> <p>If the regular expression is not valid, returns an empty list.</p> <p>This function was introduced in Qt 5.1.</p> <p><b>See also </b><a href="qregularexpression.html#isValid">isValid</a>(), <a href="qregularexpressionmatch.html#captured">QRegularExpressionMatch::captured</a>(), and <a href="qstring.html#isEmpty">QString::isEmpty</a>().</p>   <h3 class="fn" id="optimize">
<code>[since 5.4] </code><span class="type">void</span> QRegularExpression::<span class="name">optimize</span>() const
</h3> <p>Compiles the pattern immediately, including JIT compiling it (if the JIT is enabled) for optimization.</p> <p>This function was introduced in Qt 5.4.</p> <p><b>See also </b><a href="qregularexpression.html#isValid">isValid</a>() and <a href="qregularexpression.html#debugging-code-that-uses-qregularexpression">Debugging Code that Uses QRegularExpression</a>.</p>   <h3 class="fn" id="pattern">
<span class="type"><a href="qstring.html">QString</a></span> QRegularExpression::<span class="name">pattern</span>() const
</h3> <p>Returns the pattern string of the regular expression.</p> <p><b>See also </b><a href="qregularexpression.html#setPattern">setPattern</a>() and <a href="qregularexpression.html#patternOptions">patternOptions</a>().</p>   <h3 class="fn" id="patternErrorOffset">
<span class="type">qsizetype</span> QRegularExpression::<span class="name">patternErrorOffset</span>() const
</h3> <p>Returns the offset, inside the pattern string, at which an error was found when checking the validity of the regular expression. If no error was found, then -1 is returned.</p> <p><b>See also </b><a href="qregularexpression.html#pattern">pattern</a>(), <a href="qregularexpression.html#isValid">isValid</a>(), and <a href="qregularexpression.html#errorString">errorString</a>().</p>   <h3 class="fn" id="patternOptions">
<span class="type"><a href="qregularexpression.html#PatternOption-enum">QRegularExpression::PatternOptions</a></span> QRegularExpression::<span class="name">patternOptions</span>() const
</h3> <p>Returns the pattern options for the regular expression.</p> <p><b>See also </b><a href="qregularexpression.html#setPatternOptions">setPatternOptions</a>() and <a href="qregularexpression.html#pattern">pattern</a>().</p>   <h3 class="fn" id="setPattern">
<span class="type">void</span> QRegularExpression::<span class="name">setPattern</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>pattern</i>)
</h3> <p>Sets the pattern string of the regular expression to <i>pattern</i>. The pattern options are left unchanged.</p> <p><b>See also </b><a href="qregularexpression.html#pattern">pattern</a>() and <a href="qregularexpression.html#setPatternOptions">setPatternOptions</a>().</p>   <h3 class="fn" id="setPatternOptions">
<span class="type">void</span> QRegularExpression::<span class="name">setPatternOptions</span>(<span class="type"><a href="qregularexpression.html#PatternOption-enum">QRegularExpression::PatternOptions</a></span> <i>options</i>)
</h3> <p>Sets the given <i>options</i> as the pattern options of the regular expression. The pattern string is left unchanged.</p> <p><b>See also </b><a href="qregularexpression.html#patternOptions">patternOptions</a>() and <a href="qregularexpression.html#setPattern">setPattern</a>().</p>   <h3 class="fn" id="swap">
<span class="type">void</span> QRegularExpression::<span class="name">swap</span>(<span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;<i>other</i>)
</h3> <p>Swaps the regular expression <i>other</i> with this regular expression. This operation is very fast and never fails.</p>   <h3 class="fn" id="wildcardToRegularExpression">
<code>[static, since 5.15] </code><span class="type"><a href="qstring.html">QString</a></span> QRegularExpression::<span class="name">wildcardToRegularExpression</span>(<span class="type"><a href="qstringview.html">QStringView</a></span> <i>pattern</i>, <span class="type"><a href="qregularexpression.html#WildcardConversionOption-enum">QRegularExpression::WildcardConversionOptions</a></span> <i>options</i> = DefaultWildcardConversion)
</h3> <p>Returns a regular expression representation of the given glob <i>pattern</i>. The transformation is targeting file path globbing, which means in particular that path separators receive special treatment. This implies that it is not just a basic translation from "*" to ".*".</p> <pre data-language="cpp">QString wildcard = QRegularExpression::wildcardToRegularExpression("*.jpeg");
// Will match files with names like:
//    foo.jpeg
//    f_o_o.jpeg
//    fÃ¶Ã¶.jpeg</pre> <p>By default, the returned regular expression is fully anchored. In other words, there is no need of calling <a href="qregularexpression.html#anchoredPattern">anchoredPattern</a>() again on the result. To get an a regular expression that is not anchored, pass <a href="qregularexpression.html#WildcardConversionOption-enum">UnanchoredWildcardConversion</a> as the conversion <i>options</i>.</p> <p>This implementation follows closely the definition of wildcard for glob patterns:</p> <table class="generic"> <tr class="odd" valign="top">
<td><b>c</b></td>
<td>Any character represents itself apart from those mentioned below. Thus <b>c</b> matches the character <i>c</i>.</td>
</tr> <tr class="even" valign="top">
<td><b>?</b></td>
<td>Matches any single character. It is the same as <b>.</b> in full regexps.</td>
</tr> <tr class="odd" valign="top">
<td><b>*</b></td>
<td>Matches zero or more of any characters. It is the same as <b>.*</b> in full regexps.</td>
</tr> <tr class="even" valign="top">
<td><b>[abc]</b></td>
<td>Matches one character given in the bracket.</td>
</tr> <tr class="odd" valign="top">
<td><b>[a-c]</b></td>
<td>Matches one character from the range given in the bracket.</td>
</tr> <tr class="even" valign="top">
<td><b>[!abc]</b></td>
<td>Matches one character that is not given in the bracket. It is the same as <b>[^abc]</b> in full regexp.</td>
</tr> <tr class="odd" valign="top">
<td><b>[!a-c]</b></td>
<td>Matches one character that is not from the range given in the bracket. It is the same as <b>[^a-c]</b> in full regexp.</td>
</tr> </table> <div class="admonition note"> <p><b>Note: </b>The backslash (\) character is <i>not</i> an escape char in this context. In order to match one of the special characters, place it in square brackets (for example, <code>[?]</code>).</p> </div> <p>More information about the implementation can be found in:</p> <ul> <li><a href="https://en.wikipedia.org/wiki/Glob_(programming)">The Wikipedia Glob article</a></li> <li><code>man 7 glob</code></li> </ul> <p>This function was introduced in Qt 5.15.</p> <p><b>See also </b><a href="qregularexpression.html#escape">escape</a>().</p>   <h3 class="fn" id="wildcardToRegularExpression-1">
<code>[static, since 5.12] </code><span class="type"><a href="qstring.html">QString</a></span> QRegularExpression::<span class="name">wildcardToRegularExpression</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>pattern</i>, <span class="type"><a href="qregularexpression.html#WildcardConversionOption-enum">QRegularExpression::WildcardConversionOptions</a></span> <i>options</i> = DefaultWildcardConversion)
</h3> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 5.12.</p>   <h3 class="fn" id="operator-not-eq">
<span class="type">bool</span> QRegularExpression::<span class="name">operator!=</span>(const <span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;<i>re</i>) const
</h3> <p>Returns <code>true</code> if the regular expression is different from <i>re</i>, or false otherwise.</p> <p><b>See also </b><a href="qregularexpression.html#operator-eq-eq">operator==</a>().</p>   <h3 class="fn" id="operator-eq-eq">
<span class="type">bool</span> QRegularExpression::<span class="name">operator==</span>(const <span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;<i>re</i>) const
</h3> <p>Returns <code>true</code> if the regular expression is equal to <i>re</i>, or false otherwise. Two <a href="qregularexpression.html">QRegularExpression</a> objects are equal if they have the same pattern string and the same pattern options.</p> <p><b>See also </b><a href="qregularexpression.html#operator-not-eq">operator!=</a>().</p>   <div class="relnonmem"> <h2>Related Non-Members</h2>  <h3 class="fn" id="qHash">
<code>[since 5.6] </code><span class="type">size_t</span> <span class="name">qHash</span>(const <span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;<i>key</i>, <span class="type">size_t</span> <i>seed</i> = 0)
</h3> <p>Returns the hash value for <i>key</i>, using <i>seed</i> to seed the calculation.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="operator-lt-lt">
<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;<i>re</i>)
</h3> <p>Writes the regular expression <i>re</i> to stream <i>out</i>.</p> <p><b>See also </b><a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>   <h3 class="fn" id="operator-lt-lt-1">
<span class="type"><a href="qdebug.html">QDebug</a></span> <span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdebug.html">QDebug</a></span> <i>debug</i>, const <span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;<i>re</i>)
</h3> <p>Writes the regular expression <i>re</i> into the debug object <i>debug</i> for debugging purposes.</p> <p><b>See also </b><a href="testing-and-debugging.html#debugging-techniques">Debugging Techniques</a>.</p>   <h3 class="fn" id="operator-lt-lt-2">
<span class="type"><a href="qdebug.html">QDebug</a></span> <span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdebug.html">QDebug</a></span> <i>debug</i>, <span class="type"><a href="qregularexpression.html#PatternOption-enum">QRegularExpression::PatternOptions</a></span> <i>patternOptions</i>)
</h3> <p>Writes the pattern options <i>patternOptions</i> into the debug object <i>debug</i> for debugging purposes.</p> <p><b>See also </b><a href="testing-and-debugging.html#debugging-techniques">Debugging Techniques</a>.</p>   <h3 class="fn" id="operator-gt-gt">
<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="qregularexpression.html#QRegularExpression">QRegularExpression</a></span> &amp;<i>re</i>)
</h3> <p>Reads a regular expression from stream <i>in</i> into <i>re</i>.</p> <p><b>See also </b><a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qregularexpression.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qregularexpression.html</a>
  </p>
</div>
