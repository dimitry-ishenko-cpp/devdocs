<h1 class="title">The Qt Resource System</h1>   <p>The Qt resource system is a platform-independent mechanism for shipping resource files in an application. Use it if your application always needs a certain set of files (like icons, translation files, images), and you don't want to use system-specific means to package and locate these resources.</p> <p>Most commonly, the resource files are embedded into your application executable, or in libraries and plugins that are loaded by the application executable. Alternatively, the resource files can also be stored in an <a href="resources.html#external-resource-files">exernal resource file</a>.</p> <p>The resource system is based on tight cooperation between Qt's <a href="rcc.html">rcc</a> resource compiler, the build system, and the Qt runtime API.</p> <div class="admonition note"> <p><b>Note: </b>Currently, the Qt resource system does not make use of any system-specific capabilities for handling resources, such as the ones on Windows, macOS, and iOS. This might change in a future Qt release.</p> </div> <h2 id="the-qt-resource-compiler-rcc">The Qt Resource Compiler (rcc)
</h2> <p>The <a href="rcc.html">Resource Compiler (rcc)</a> command line tool reads resource files and generates either a C++ or Python source file, or an <code>.rcc</code> file.</p> <p>The list of files and related metadata is passed to <code>rcc</code> in the form of a <a href="resources.html#qt-resource-collection-file">Qt Resource Collection File</a>.</p> <p>By default, rcc will generate C++ source code that is then compiled as part of an executable or library. The <code>-g python</code> option generates Python source code instead. The <code>-binary</code> option generates a binary archive that is by convention saved in an <code>.rcc</code> file and can be loaded at runtime.</p> <div class="admonition note"> <p><b>Note: </b>While it is possible to run <code>rcc</code> from the command line, this is typically best left to a build system. See also the sections about <a href="resources.html#qmake">qmake</a> and <a href="resources.html#cmake">CMake</a> below.</p> </div> <h2 id="qt-resource-collection-file-qrc">Qt Resource Collection File (.qrc)
</h2> <p>A <code>.qrc</code> file is an XML document that enumerates local files to be included as runtime resources. It serves as input to <code>rcc</code>.</p> <p>Here's an example <code>.qrc</code> file:</p> <pre data-language="cpp">&lt;RCC&gt;
    &lt;qresource prefix="/"&gt;
        &lt;file&gt;images/copy.png&lt;/file&gt;
        &lt;file&gt;images/cut.png&lt;/file&gt;
        &lt;file&gt;images/new.png&lt;/file&gt;
        &lt;file&gt;images/open.png&lt;/file&gt;
        &lt;file&gt;images/paste.png&lt;/file&gt;
        &lt;file&gt;images/save.png&lt;/file&gt;
    &lt;/qresource&gt;
&lt;/RCC&gt;</pre> <p>Each <code>&lt;file&gt;</code> element in the XML identifies a file in the application's source tree. The path is resolved relative to the directory containing the <code>.qrc</code> file.</p> <p>The path is also used by default to identify the file's content at runtime. That is, the file <code>copy.png</code> will be available in the resource system as <code>:/images/copy.png</code> or <code>qrc:/images/copy.png</code>. To override this default run-time name, see <a href="resources.html#prefixes">Prefixes</a> and <a href="resources.html#aliases">Aliases</a>.</p> <p><i>Qt Creator</i>, <i>Qt Design Studio</i>, <i>Qt Designer</i>, and <i>Qt Visual Studio Tools</i> allow you to create, inspect and edit <code>.qrc</code> files through a convenient user interface. Except for <i>Qt Designer</i>, they also provide wizards for projects using the Qt resource system.</p> <h2 id="build-system-integration">Build System Integration
</h2> <p>The processing of resource files with <code>rcc</code> is typically done at the time the application is built. Several build tools have dedicated support for this, including <a href="resources.html#cmake">CMake</a> and <a href="resources.html#qmake">qmake</a>.</p> <h3 id="cmake">CMake
</h3> <p>If <code>CMAKE_AUTORCC</code> is enabled, you can just add <code>.qrc</code> files as sources to your executable or library. The referenced resource files will then be embedded into the binary:</p> <pre data-language="cpp">set(CMAKE_AUTORCC ON)

qt_add_executable(my_app
    application.qrc
    main.cpp
)</pre> <p>See <a href="https://cmake.org/cmake/help/latest/prop_tgt/AUTORCC.html">CMake's AUTORCC documentation</a> for more details about AUTORCC.</p> <p>An alternative to AUTORCC is using Qt6Core's CMake function <a href="qt-add-resources.html">qt_add_resources</a>, which gives more control over the creation of resources. For example, it allows you to specify the content of the resource directly in the project file without writing a <code>.qrc</code> file first:</p> <pre data-language="cpp">qt_add_resources(my_app "app_images"
    PREFIX "/"
    FILES
        images/copy.png
        images/cut.png
        images/new.png
        images/open.png
        images/paste.png
        images/save.png
)</pre> <p>Finally, <a href="https://doc.qt.io/qt-6.2/qt-add-qml-module.html">qt_add_qml_module</a> allows you to embed Qt Quick resources into the resource system of your application. The function is defined in the <code>Qml</code> component of the <code>Qt6</code> CMake package.</p> <h3 id="qmake">qmake
</h3> <p><a href="qmake-manual.html">qmake</a> supports handing resources with the <a href="qmake-variable-reference.html#resources">RESOURCES</a> variable. If you add a <code>.qrc</code> file path to the variable, the listed resource files will be embedded into the generated library or executable:</p> <pre data-language="cpp">RESOURCES = application.qrc</pre> <p>For simple applications, it is also possible to let qmake generate the <code>.qrc</code> file for you, avoiding the need for an additional file to be maintained:</p> <pre data-language="cpp">resources.files = \
    images/copy.png \
    images/cut.png \
    images/new.png \
    images/open.png \
    images/paste.png \
    images/save.png
resources.prefix = /

RESOURCES = resources</pre> <h2 id="runtime-api">Runtime API
</h2> <p>Qt API that deals with iterating and reading files has built-in support for the Qt Resource System. You can pass a resource path instead of a local file path to <a href="qfile.html">QFile</a> and <a href="qdir.html">QDir</a>, but also for instance to the <a href="qicon.html">QIcon</a>, <a href="qimage.html">QImage</a>, and <a href="qpixmap.html">QPixmap</a> constructors:</p> <pre data-language="cpp">    cutAct = new QAction(QIcon(":/images/cut.png"), tr("Cu&amp;t"), this);</pre> <p>The <code>:</code> prefix makes it explicit that "/images/cut.png" should be loaded from the Qt Resource System.</p> <p>You can also reference the Qt resource system through a <a href="qurl.html">QUrl</a>. Use the <code>qrc</code> scheme in this case:</p> <pre data-language="cpp">    QQmlApplicationEngine engine;
    engine.load(QUrl("qrc:/myapp/main.qml"));</pre> <p>See the <a href="https://doc.qt.io/qt-6.2/qtwidgets-mainwindows-application-example.html">Application</a> example for an actual application that uses Qt's resource system to store its icons.</p> <h2 id="advanced-topics">Advanced Topics
</h2> <h3 id="prefixes">Prefixes
</h3> <p>A <code>.qrc</code> file can set a prefix to be added to each local file name, given in a <code>&lt;file&gt;</code> element, to get the name by which the file shall be known within the resource system.</p> <p>Prefixes allow you to structure the resources, avoiding clashes between resource files added through different <code>.qrc</code> files in different libraries or plugins.</p> <div class="admonition note"> <p><b>Note: </b>The <code>/qt</code> and <code>/qt-project.org</code> prefixes are reserved for documented use cases in Qt. The <a href="qt-conf.html">qt.conf</a> file is for instance looked up in <code>:/qt/etc/qt.conf</code> or <code>qrc:/qt/etc/qt.conf</code>.</p> </div> <h3 id="aliases">Aliases
</h3> <p>Sometimes it is convenient to make a resource file available under a different path at runtime. <code>.qrc</code> files allow this by setting an <code>alias</code> attribute:</p> <pre data-language="cpp">&lt;file alias="cut-img.png"&gt;images/cut.png&lt;/file&gt;</pre> <p>The file is from the application then only accessible as <code>:/cut-img.png</code> or <code>qrc:/cut-img.png</code>.</p> <h3 id="language-selectors">Language Selectors
</h3> <p>Some resources need to change based on the user's locale, such as translation files or icons. <a href="resources.html#resource-collection-files">Resource Collection Files</a> support this through a <code>lang</code> attribute to the <code>qresource</code> tag, specifying a suitable locale string. For example:</p> <pre data-language="cpp">&lt;qresource&gt;
    &lt;file&gt;cut.jpg&lt;/file&gt;
&lt;/qresource&gt;
&lt;qresource lang="fr"&gt;
    &lt;file alias="cut.jpg"&gt;cut_fr.jpg&lt;/file&gt;
&lt;/qresource&gt;</pre> <p>If the user's locale is French (i.e., <a href="qlocale.html#system">QLocale::system</a>().language() is French), <code>:/cut.jpg</code> or <code>qrc:/cut.jpg</code> becomes a reference to the <code>cut_fr.jpg</code> image. For other locales, <code>cut.jpg</code> is used.</p> <p>See the <a href="qlocale.html">QLocale</a> documentation for a description of the format to use for locale strings.</p> <p>See <a href="qfileselector.html">QFileSelector</a> for an additional mechanism to select locale-specific resources.</p> <h3 id="embedding-large-files">Embedding Large Files
</h3> <p>By default, <code>rcc</code> embeds the resource files into executables in the form of C++ arrays. This can be problematic especially for large resources.</p> <p>If the compiler takes too long, or even fails because of memory overflow, you can opt into a special mode where the resources are embedded as part of a two-step process. The C++ compiler only reserves enough space in the target executable or library for the resources. The actual embedding of the resource file's content and metadata is then done after the compilation and linking phase, through another rcc call.</p> <p>For qmake, this is enabled by adding <code>resources_big</code> to the <code>CONFIG</code> variable:</p> <pre data-language="cpp">CONFIG += resources_big</pre> <p>For CMake, you need to use the <a href="qt-add-bigresources.html">qt_add_big_resources</a> function:</p> <pre data-language="cpp">qt_add_big_resources(SOURCES application.qrc)
target_sources(my_app PRIVATE ${SOURCES})</pre> <h3 id="external-resource-files">External Resource Files
</h3> <p>An alternative to embedding the resource files into the binary is to store them in a separate <code>.rcc</code> file. <code>rcc</code> allows this with the <code>-binary</code> option. Such a <code>.rcc</code> file must then be loaded at runtime with <a href="qresource.html">QResource</a>.</p> <p>For example, a set of resource data specified in a <code>.qrc</code> file can be compiled in the following way:</p> <pre data-language="cpp">rcc -binary myresource.qrc -o myresource.rcc</pre> <p>In the application, this resource would be registered with code like this:</p> <pre data-language="cpp">QResource::registerResource("/path/to/myresource.rcc");</pre> <p>If you use CMake, you can use the <a href="qt-add-binary-resources.html">qt_add_binary_resources</a> function to schedule the <code>rcc</code> call above:</p> <pre data-language="cpp">qt_add_binary_resources(resources application.qrc DESTINATION application.rcc)
add_dependencies(my_app resources)</pre> <h3 id="resources-in-a-qt-for-python-application">Resources in a Qt for Python application
</h3> <p>The resource collection file is converted to a Python module by using the resource compiler <a href="rcc.html">rcc</a>:</p> <pre data-language="cpp">rcc -g python application.qrc &gt; application_rc.py</pre> <p>The module can then be imported in the application:</p> <pre data-language="cpp">import application_rc.py</pre> <h3 id="compression">Compression
</h3> <p><code>rcc</code> attempts to compress the content to optimize disk space usage in the final binaries. By default, it will perform a heuristic check to determine whether compressing is worth it and will store the content uncompressed if it fails to sufficiently compress. To control the threshold, you can use the <code>-threshold</code> option, which tells <code>rcc</code> the percentage of the original file size that must be gained for it to store the file in compressed form.</p> <pre data-language="cpp">rcc -threshold 25 myresources.qrc</pre> <p>The default value is "70", indicating that the compressed file must be 70% smaller than the original (no more than 30% of the original file size).</p> <p>It is possible to turn off compression if desired. This can be useful if your resources already contain a compressed format, such as <code>.png</code> files, and you do not want to incur the CPU cost at build time to confirm that it can't be compressed. Another reason is if disk usage is not a problem and the application would prefer to keep the content as clean memory pages at runtime. You do this by giving the <code>-no-compress</code> command line argument.</p> <pre data-language="cpp">rcc -no-compress myresources.qrc</pre> <p><code>rcc</code> also gives you some control over the compression level and compression algorithm, for example:</p> <pre data-language="cpp">rcc -compress 2 -compress-algo zlib myresources.qrc</pre> <p>It is also possible to use <code>threshold</code>, <code>compress</code>, and <code>compress-algo</code> as attributes in a .qrc <code>file</code> tag.</p> <pre data-language="cpp">&lt;qresource&gt;
    &lt;file compress="1" compress-algo="zstd"&gt;data.txt&lt;/file&gt;
&lt;/qresource&gt;</pre> <p>The above will select the <code>zstd</code> algorithm with compression level 1.</p> <p><code>rcc</code> supports the following compression algorithms and compression levels:</p> <ul> <li>
<code>best</code>: use the best algorithm among the ones below, at its highest compression level, to achieve the most compression at the expense of using a lot of CPU time during compilation. This value is useful in the XML file to indicate a file should be most compressed, regardless of which algorithms <code>rcc</code> supports.</li> <li>
<code>zstd</code>: use the <a href="http://facebook.github.io/zstd/">Zstandard</a> library to compress contents. Valid compression levels range from 1 to 19, 1 is least compression (least CPU time) and 19 is the most compression (most CPU time). The default level is 14. A special value of 0 tells the <code>zstd</code> library to choose an implementation-defined default.</li> <li>
<code>zlib</code>: use the <a href="https://zlib.net">zlib</a> library to compress contents. Valid compression levels range from 1 to 9, with 1 applying the least compression (least CPU time) and 9 the most compression (most CPU time). The special value 0 means "no compression" and should not be used. The default is implementation-defined, but usually is level 6.</li> <li>
<code>none</code>: no compression. This is the same as the <code>-no-compress</code> option.</li> </ul> <p>Support for both Zstandard and zlib are optional. If a given library was not detected at compile time, attempting to pass <code>-compress-algo</code> for that library will result in an error. The default compression algorithm is <code>zstd</code> if it is enabled, <code>zlib</code> if not.</p> <h3 id="explicit-loading-and-unloading-of-embedded-resources">Explicit Loading and Unloading of Embedded Resources
</h3> <p>Resources embedded in C++ executable or library code are automatically registered to the Qt resource system in a constructor of an internal global variable. Since the global variables are initialized before main() runs, the resources are available when the program starts to run.</p> <p>When embedding resources in <i>static</i> libraries, the C++ linker might remove the static variables that register the resources. If you embed resources in a static library, you therefore need to explicitly register your resources by calling <a href="qdir.html#Q_INIT_RESOURCE">Q_INIT_RESOURCE</a>() with the base name of the <code>.qrc</code> file. For example:</p> <pre data-language="cpp">MyClass::MyClass() : BaseClass()
{
    Q_INIT_RESOURCE(resources);

    QFile file(":/myfile.dat");
    ...
}</pre> <p>You can also explicitly remove registered resources from the application, for instance when unloading a plugin. Use <a href="qdir.html#Q_CLEANUP_RESOURCE">Q_CLEANUP_RESOURCE</a>() for this.</p> <p>Note: As the resource initializers generated by rcc are declared in the global namespace, your calls to <a href="qdir.html#Q_INIT_RESOURCE">Q_INIT_RESOURCE</a>() and <a href="qdir.html#Q_CLEANUP_RESOURCE">Q_CLEANUP_RESOURCE</a>() need to be done outside any namespace.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/resources.html" class="_attribution-link">https://doc.qt.io/qt-6.2/resources.html</a>
  </p>
</div>
