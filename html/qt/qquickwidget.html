<h1 class="title">QQuickWidget Class</h1>  <p>The QQuickWidget class provides a widget for displaying a Qt Quick user interface. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QQuickWidget&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS QuickWidgets REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::QuickWidgets)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += quickwidgets</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.3</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qwidget.html">QWidget</a>
</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qquickwidget-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#ResizeMode-enum">ResizeMode</a></b> { SizeViewToRootObject, SizeRootObjectToView }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#Status-enum">Status</a></b> { Null, Ready, Loading, Error }</td>
</tr> </table> <h2 id="properties">Properties
</h2> <ul> <li class="fn">
<b><a href="qquickwidget.html#resizeMode-prop">resizeMode</a></b> : ResizeMode</li> <li class="fn">
<b><a href="qquickwidget.html#source-prop">source</a></b> : QUrl</li> <li class="fn">
<b><a href="qquickwidget.html#status-prop">status</a></b> : const Status</li> </ul> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#QQuickWidget-2">QQuickWidget</a></b>(const QUrl &amp;<i>source</i>, QWidget *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#QQuickWidget-1">QQuickWidget</a></b>(QQmlEngine *<i>engine</i>, QWidget *<i>parent</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#QQuickWidget">QQuickWidget</a></b>(QWidget *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#dtor.QQuickWidget">~QQuickWidget</a></b>() override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQmlEngine *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#engine">engine</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;QQmlError&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#errors">errors</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSurfaceFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#format">format</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#grabFramebuffer">grabFramebuffer</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSize </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#initialSize">initialSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickWindow *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#quickWindow">quickWindow</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickWidget::ResizeMode </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#resizeMode-prop">resizeMode</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQmlContext *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#rootContext">rootContext</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickItem *</td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#rootObject">rootObject</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#setClearColor">setClearColor</a></b>(const QColor &amp;<i>color</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#setFormat">setFormat</a></b>(const QSurfaceFormat &amp;<i>format</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#resizeMode-prop">setResizeMode</a></b>(QQuickWidget::ResizeMode)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QUrl </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#source">source</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QQuickWidget::Status </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#status-prop">status</a></b>() const</td>
</tr> </table> <h2 id="public-slots">Public Slots
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#setSource">setSource</a></b>(const QUrl &amp;<i>url</i>)</td>
</tr> </table> <h2 id="signals">Signals
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#sceneGraphError">sceneGraphError</a></b>(QQuickWindow::SceneGraphError <i>error</i>, const QString &amp;<i>message</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#statusChanged">statusChanged</a></b>(QQuickWidget::Status <i>status</i>)</td>
</tr> </table> <h2 id="reimplemented-protected-functions">Reimplemented Protected Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#dragEnterEvent">dragEnterEvent</a></b>(QDragEnterEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#dragLeaveEvent">dragLeaveEvent</a></b>(QDragLeaveEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#dragMoveEvent">dragMoveEvent</a></b>(QDragMoveEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#dropEvent">dropEvent</a></b>(QDropEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#event">event</a></b>(QEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#focusInEvent">focusInEvent</a></b>(QFocusEvent *<i>event</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#focusNextPrevChild">focusNextPrevChild</a></b>(bool <i>next</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#focusOutEvent">focusOutEvent</a></b>(QFocusEvent *<i>event</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#hideEvent">hideEvent</a></b>(QHideEvent *) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#keyPressEvent">keyPressEvent</a></b>(QKeyEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#keyReleaseEvent">keyReleaseEvent</a></b>(QKeyEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a></b>(QMouseEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#mouseMoveEvent">mouseMoveEvent</a></b>(QMouseEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#mousePressEvent">mousePressEvent</a></b>(QMouseEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#mouseReleaseEvent">mouseReleaseEvent</a></b>(QMouseEvent *<i>e</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#paintEvent">paintEvent</a></b>(QPaintEvent *<i>event</i>) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#showEvent">showEvent</a></b>(QShowEvent *) override</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual void </td>
<td class="memItemRight bottomAlign">
<b><a href="qquickwidget.html#wheelEvent">wheelEvent</a></b>(QWheelEvent *<i>e</i>) override</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>This is a convenience wrapper for <a href="qquickwindow.html">QQuickWindow</a> which will automatically load and display a QML scene when given the URL of the main source file. Alternatively, you can instantiate your own objects using <a href="qqmlcomponent.html">QQmlComponent</a> and place them in a manually set up QQuickWidget.</p> <p>Typical usage:</p> <pre data-language="cpp">QQuickWidget *view = new QQuickWidget;
view-&gt;setSource(QUrl::fromLocalFile("myqmlfile.qml"));
view-&gt;show();</pre> <p>To receive errors related to loading and executing QML with QQuickWidget, you can connect to the <a href="qquickwidget.html#statusChanged">statusChanged</a>() signal and monitor for <a href="qquickwidget.html#Status-enum">QQuickWidget::Error</a>. The errors are available via <a href="qquickwidget.html#errors">QQuickWidget::errors</a>().</p> <p>QQuickWidget also manages sizing of the view and root object. By default, the <a href="qquickwidget.html#resizeMode-prop">resizeMode</a> is <a href="qquickwidget.html#ResizeMode-enum">SizeViewToRootObject</a>, which will load the component and resize it to the size of the view. Alternatively the <a href="qquickwidget.html#resizeMode-prop">resizeMode</a> may be set to <a href="qquickwidget.html#ResizeMode-enum">SizeRootObjectToView</a> which will resize the view to the size of the root object.</p> <div class="admonition note"> <p><b>Note: </b>QQuickWidget is an alternative to using <a href="qquickview.html">QQuickView</a> and <a href="qwidget.html#createWindowContainer">QWidget::createWindowContainer</a>(). The restrictions on stacking order do not apply, making QQuickWidget the more flexible alternative, behaving more like an ordinary widget.</p> </div> <div class="admonition note"> <p><b>Note: </b>However, the above mentioned advantages come at the expense of performance. Unlike <a href="qquickwindow.html">QQuickWindow</a> and <a href="qquickview.html">QQuickView</a>, QQuickWidget requires rendering into OpenGL framebuffer objects, which needs to be enforced by calling <a href="qquickwindow.html#setGraphicsApi">QQuickWindow::setGraphicsApi</a>(<a href="qsgrendererinterface.html#GraphicsApi-enum">QSGRendererInterface::OpenGLRhi</a>) at startup. This will naturally carry a minor performance hit.</p> </div> <div class="admonition note"> <p><b>Note: </b>Using QQuickWidget disables the threaded render loop on all platforms. This means that some of the benefits of threaded rendering, for example <a href="qml-qtquick-animator.html">Animator</a> classes and vsync driven animations, will not be available.</p> </div> <div class="admonition note"> <p><b>Note: </b>Avoid calling <a href="qwidget.html#winId">winId</a>() on a QQuickWidget. This function triggers the creation of a native window, resulting in reduced performance and possibly rendering glitches. The entire purpose of QQuickWidget is to render Quick scenes without a separate native window, hence making it a native widget should always be avoided.</p> </div> <h3 id="scene-graph-and-context-persistency">Scene Graph and Context Persistency
</h3> <p>QQuickWidget honors <a href="qquickwindow.html#isPersistentSceneGraph">QQuickWindow::isPersistentSceneGraph</a>(), meaning that applications can decide - by calling <a href="qquickwindow.html#setPersistentSceneGraph">QQuickWindow::setPersistentSceneGraph</a>() on the window returned from the <a href="qquickwidget.html#quickWindow">quickWindow</a>() function - to let scenegraph nodes and other Qt Quick scene related resources be released whenever the widget becomes hidden. By default persistency is enabled, just like with <a href="qquickwindow.html">QQuickWindow</a>.</p> <p>When running with the OpenGL backend of the scene graph, <a href="qquickwindow.html">QQuickWindow</a> offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by QQuickWidget and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a QQuickWidget into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the QOpenGLWidget documentation.</p> <div class="admonition note"> <p><b>Note: </b>QQuickWidget offers less fine-grained control over its internal OpenGL context than QOpenGLWidget, and there are subtle differences, most notably that disabling the persistent scene graph will lead to destroying the context on a window change regardless of the presence of QCoreApplication::AA_ShareOpenGLContexts.</p> </div> <h3 id="limitations">Limitations
</h3> <p>Putting other widgets underneath and making the QQuickWidget transparent will not lead to the expected results: the widgets underneath will not be visible. This is because in practice the QQuickWidget is drawn before all other regular, non-OpenGL widgets, and so see-through types of solutions are not feasible. Other type of layouts, like having widgets on top of the QQuickWidget, will function as expected.</p> <p>When absolutely necessary, this limitation can be overcome by setting the <a href="qt.html#WidgetAttribute-enum">Qt::WA_AlwaysStackOnTop</a> attribute on the QQuickWidget. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the QQuickWidget, so it should only be used in situations where a semi-transparent QQuickWidget with other widgets visible underneath is required.</p> <p>This limitation only applies when there are other widgets underneath the QQuickWidget inside the same window. Making the window semi-transparent, with other applications and the desktop visible in the background, is done in the traditional way: Set <a href="qt.html#WidgetAttribute-enum">Qt::WA_TranslucentBackground</a> on the top-level window, request an alpha channel, and change the Qt Quick Scenegraph's clear color to <a href="qt.html#GlobalColor-enum">Qt::transparent</a> via <a href="qquickwidget.html#setClearColor">setClearColor</a>().</p> <h3 id="support-when-not-using-opengl">Support when not using OpenGL
</h3> <p>In addition to OpenGL, the <code>software</code> backend of Qt Quick also supports QQuickWidget. Other backends, for example OpenVG, are not compatible however and attempting to construct a QQuickWidget will lead to problems.</p> <h3 id="tab-key-handling">Tab Key Handling
</h3> <p>On press of the <code>[TAB]</code> key, the item inside the QQuickWidget gets focus. If this item can handle <code>[TAB]</code> key press, focus will change accordingly within the item, otherwise the next widget in the focus chain gets focus.</p>  <p><b>See also </b><a href="qtqml-cppintegration-exposecppattributes.html">Exposing Attributes of C++ Types to QML</a>, <a href="https://doc.qt.io/qt-6.2/qtquick-quickwidgets-quickwidget-example.html">Qt Quick Widgets Example</a>, and <a href="qquickview.html">QQuickView</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="ResizeMode-enum">enum QQuickWidget::<span class="name">ResizeMode</span>
</h3> <p>This enum specifies how to resize the view.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QQuickWidget::SizeViewToRootObject</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The view resizes with the root item in the QML.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWidget::SizeRootObjectToView</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The view will automatically resize the root item to the size of the view.</td>
</tr> </table>   <h3 class="fn" id="Status-enum">enum QQuickWidget::<span class="name">Status</span>
</h3> <p>Specifies the loading status of the <a href="qquickwidget.html">QQuickWidget</a>.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QQuickWidget::Null</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">This <a href="qquickwidget.html">QQuickWidget</a> has no source set.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWidget::Ready</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">This <a href="qquickwidget.html">QQuickWidget</a> has loaded and created the QML component.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWidget::Loading</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">This <a href="qquickwidget.html">QQuickWidget</a> is loading network data.</td>
</tr> <tr>
<td class="topAlign"><code>QQuickWidget::Error</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">One or more errors occurred. Call <a href="qquickwidget.html#errors">errors</a>() to retrieve a list of errors.</td>
</tr> </table>   <div class="prop"> <h2>Property Documentation</h2>  <h3 class="fn" id="resizeMode-prop">
<span class="name">resizeMode</span> : <span class="type"><a href="qquickwidget.html#ResizeMode-enum">ResizeMode</a></span>
</h3> <p>Determines whether the view should resize the window contents.</p> <p>If this property is set to <a href="qquickwidget.html#ResizeMode-enum">SizeViewToRootObject</a> (the default), the view resizes to the size of the root item in the QML.</p> <p>If this property is set to <a href="qquickwidget.html#ResizeMode-enum">SizeRootObjectToView</a>, the view will automatically resize the root item to the size of the view.</p> <p>Regardless of this property, the sizeHint of the view is the initial size of the root item. Note though that since QML may load dynamically, that size may change.</p> <p><b>Access functions:</b></p> <table class="alignedsummary"> <tr>
<td class="memItemLeft topAlign rightAlign"> QQuickWidget::ResizeMode </td>
<td class="memItemRight bottomAlign">
<span class="name"><b>resizeMode</b></span>() const</td>
</tr> <tr>
<td class="memItemLeft topAlign rightAlign"> void </td>
<td class="memItemRight bottomAlign">
<span class="name"><b>setResizeMode</b></span>(QQuickWidget::ResizeMode)</td>
</tr> </table> <p><b>See also </b><a href="qquickwidget.html#initialSize">initialSize</a>().</p>   <h3 class="fn" id="source-prop">
<span class="name">source</span> : <span class="type"><a href="qurl.html">QUrl</a></span>
</h3> <p>This property holds the URL of the source of the QML component.</p> <p>Ensure that the URL provided is full and correct, in particular, use <a href="qurl.html#fromLocalFile">QUrl::fromLocalFile</a>() when loading a file from the local filesystem.</p> <div class="admonition note"> <p><b>Note: </b>Setting a source URL will result in the QML component being instantiated, even if the URL is unchanged from the current value.</p> </div> <p><b>Access functions:</b></p> <table class="alignedsummary"> <tr>
<td class="memItemLeft topAlign rightAlign"> QUrl </td>
<td class="memItemRight bottomAlign">
<span class="name"><b><a href="qquickwidget.html#source">source</a></b></span>() const</td>
</tr> <tr>
<td class="memItemLeft topAlign rightAlign"> void </td>
<td class="memItemRight bottomAlign">
<span class="name"><b><a href="qquickwidget.html#setSource">setSource</a></b></span>(const QUrl &amp;<i>url</i>)</td>
</tr> </table>   <h3 class="fn" id="status-prop">
<code>[read-only] </code><span class="name">status</span> : const <span class="type"><a href="qquickwidget.html#Status-enum">Status</a></span>
</h3> <p>The component's current <a href="qquickwidget.html#Status-enum">status</a>.</p> <p><b>Access functions:</b></p> <table class="alignedsummary"> <tr>
<td class="memItemLeft topAlign rightAlign"> QQuickWidget::Status </td>
<td class="memItemRight bottomAlign">
<span class="name"><b>status</b></span>() const</td>
</tr> </table> <p><b>Notifier signal:</b></p> <table class="alignedsummary"> <tr>
<td class="memItemLeft topAlign rightAlign"> void </td>
<td class="memItemRight bottomAlign">
<span class="name"><b><a href="qquickwidget.html#statusChanged">statusChanged</a></b></span>(QQuickWidget::Status <i>status</i>)</td>
</tr> </table>  </div>  <h2>Member Function Documentation</h2>  <h3 class="fn" id="QQuickWidget-2">QQuickWidget::<span class="name">QQuickWidget</span>(const <span class="type"><a href="qurl.html">QUrl</a></span> &amp;<i>source</i>, <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i> = nullptr)
</h3> <p>Constructs a QQuickWidget with the given QML <i>source</i> and <i>parent</i>. The default value of <i>parent</i> is 0.</p>   <h3 class="fn" id="QQuickWidget-1">QQuickWidget::<span class="name">QQuickWidget</span>(<span class="type"><a href="qqmlengine.html">QQmlEngine</a></span> *<i>engine</i>, <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i>)
</h3> <p>Constructs a QQuickWidget with the given QML <i>engine</i> and <i>parent</i>.</p> <p>Note: In this case, the QQuickWidget does not own the given <i>engine</i> object; it is the caller's responsibility to destroy the engine. If the <i>engine</i> is deleted before the view, <a href="qquickwidget.html#status-prop">status</a>() will return <a href="qquickwidget.html#Status-enum">QQuickWidget::Error</a>.</p> <p><b>See also </b><a href="qquickwidget.html#Status-enum">Status</a>, <a href="qquickwidget.html#status-prop">status</a>(), and <a href="qquickwidget.html#errors">errors</a>().</p>   <h3 class="fn" id="QQuickWidget">QQuickWidget::<span class="name">QQuickWidget</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i> = nullptr)
</h3> <p>Constructs a QQuickWidget with the given <i>parent</i>. The default value of <i>parent</i> is 0.</p>   <h3 class="fn" id="sceneGraphError">
<code>[signal] </code><span class="type">void</span> QQuickWidget::<span class="name">sceneGraphError</span>(<span class="type"><a href="qquickwindow.html#SceneGraphError-enum">QQuickWindow::SceneGraphError</a></span> <i>error</i>, const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>message</i>)
</h3> <p>This signal is emitted when an <i>error</i> occurred during scene graph initialization.</p> <p>Applications should connect to this signal if they wish to handle errors, like OpenGL context creation failures, in a custom way. When no slot is connected to the signal, the behavior will be different: Quick will print the <i>message</i>, or show a message box, and terminate the application.</p> <p>This signal will be emitted from the GUI thread.</p> <p><b>See also </b><a href="qquickwindow.html#sceneGraphError">QQuickWindow::sceneGraphError</a>().</p>   <h3 class="fn" id="setSource">
<code>[slot] </code><span class="type">void</span> QQuickWidget::<span class="name">setSource</span>(const <span class="type"><a href="qurl.html">QUrl</a></span> &amp;<i>url</i>)
</h3> <p>Sets the source to the <i>url</i>, loads the QML component and instantiates it.</p> <p>Ensure that the URL provided is full and correct, in particular, use <a href="qurl.html#fromLocalFile">QUrl::fromLocalFile</a>() when loading a file from the local filesystem.</p> <p>Calling this method multiple times with the same URL will result in the QML component being reinstantiated.</p> <p><b>Note: </b>Setter function for property <a href="qquickwidget.html#source">source</a>. </p> <p><b>See also </b><a href="qquickwidget.html#source">source</a>().</p>   <h3 class="fn" id="statusChanged">
<code>[signal] </code><span class="type">void</span> QQuickWidget::<span class="name">statusChanged</span>(<span class="type"><a href="qquickwidget.html#Status-enum">QQuickWidget::Status</a></span> <i>status</i>)
</h3> <p>This signal is emitted when the component's current <i>status</i> changes.</p> <p><b>Note: </b>Notifier signal for property <a href="qquickwidget.html#status-prop">status</a>. </p>   <h3 class="fn" id="dtor.QQuickWidget">
<code>[override virtual] </code>QQuickWidget::<span class="name">~QQuickWidget</span>()
</h3> <p>Destroys the <a href="qquickwidget.html">QQuickWidget</a>.</p>   <h3 class="fn" id="dragEnterEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">dragEnterEvent</span>(<span class="type"><a href="qdragenterevent.html">QDragEnterEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#dragEnterEvent">QWidget::dragEnterEvent</a>(QDragEnterEvent *event).</p>   <h3 class="fn" id="dragLeaveEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">dragLeaveEvent</span>(<span class="type"><a href="qdragleaveevent.html">QDragLeaveEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#dragLeaveEvent">QWidget::dragLeaveEvent</a>(QDragLeaveEvent *event).</p>   <h3 class="fn" id="dragMoveEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">dragMoveEvent</span>(<span class="type"><a href="qdragmoveevent.html">QDragMoveEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#dragMoveEvent">QWidget::dragMoveEvent</a>(QDragMoveEvent *event).</p>   <h3 class="fn" id="dropEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">dropEvent</span>(<span class="type"><a href="qdropevent.html">QDropEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#dropEvent">QWidget::dropEvent</a>(QDropEvent *event).</p>   <h3 class="fn" id="engine">
<span class="type"><a href="qqmlengine.html">QQmlEngine</a></span> *QQuickWidget::<span class="name">engine</span>() const
</h3> <p>Returns a pointer to the <a href="qqmlengine.html">QQmlEngine</a> used for instantiating QML Components.</p>   <h3 class="fn" id="errors">
<span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qqmlerror.html">QQmlError</a></span>&gt; QQuickWidget::<span class="name">errors</span>() const
</h3> <p>Return the list of errors that occurred during the last compile or create operation. When the status is not <a href="qquickwidget.html#Status-enum">Error</a>, an empty list is returned.</p> <p><b>See also </b><a href="qquickwidget.html#status-prop">status</a>.</p>   <h3 class="fn" id="event">
<code>[override virtual protected] </code><span class="type">bool</span> QQuickWidget::<span class="name">event</span>(<span class="type"><a href="qevent.html">QEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#event">QWidget::event</a>(QEvent *event).</p>   <h3 class="fn" id="focusInEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">focusInEvent</span>(<span class="type"><a href="qfocusevent.html">QFocusEvent</a></span> *<i>event</i>)
</h3> <p>Reimplements: <a href="qwidget.html#focusInEvent">QWidget::focusInEvent</a>(QFocusEvent *event).</p>   <h3 class="fn" id="focusNextPrevChild">
<code>[override virtual protected] </code><span class="type">bool</span> QQuickWidget::<span class="name">focusNextPrevChild</span>(<span class="type">bool</span> <i>next</i>)
</h3> <p>Reimplements: <a href="qwidget.html#focusNextPrevChild">QWidget::focusNextPrevChild</a>(bool next).</p>   <h3 class="fn" id="focusOutEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">focusOutEvent</span>(<span class="type"><a href="qfocusevent.html">QFocusEvent</a></span> *<i>event</i>)
</h3> <p>Reimplements: <a href="qwidget.html#focusOutEvent">QWidget::focusOutEvent</a>(QFocusEvent *event).</p>   <h3 class="fn" id="format">
<span class="type"><a href="qsurfaceformat.html">QSurfaceFormat</a></span> QQuickWidget::<span class="name">format</span>() const
</h3> <p>Returns the actual surface format.</p> <p>If the widget has not yet been shown, the requested format is returned.</p> <p><b>See also </b><a href="qquickwidget.html#setFormat">setFormat</a>().</p>   <h3 class="fn" id="grabFramebuffer">
<span class="type"><a href="qimage.html">QImage</a></span> QQuickWidget::<span class="name">grabFramebuffer</span>() const
</h3> <p>Renders a frame and reads it back into an image.</p> <div class="admonition note"> <p><b>Note: </b>This is a potentially expensive operation.</p> </div>   <h3 class="fn" id="hideEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">hideEvent</span>(<span class="type"><a href="qhideevent.html">QHideEvent</a></span> *)
</h3> <p>Reimplements: <a href="qwidget.html#hideEvent">QWidget::hideEvent</a>(QHideEvent *event).</p>   <h3 class="fn" id="initialSize">
<span class="type"><a href="qsize.html">QSize</a></span> QQuickWidget::<span class="name">initialSize</span>() const
</h3> <p>Returns the initial size of the root object.</p> <p>If <a href="qquickwidget.html#resizeMode-prop">resizeMode</a> is <a href="qquickwidget.html#ResizeMode-enum">SizeRootObjectToView</a>, the root object will be resized to the size of the view. This function returns the size of the root object before it was resized.</p>   <h3 class="fn" id="keyPressEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">keyPressEvent</span>(<span class="type"><a href="qkeyevent.html">QKeyEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#keyPressEvent">QWidget::keyPressEvent</a>(QKeyEvent *event).</p>   <h3 class="fn" id="keyReleaseEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">keyReleaseEvent</span>(<span class="type"><a href="qkeyevent.html">QKeyEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#keyReleaseEvent">QWidget::keyReleaseEvent</a>(QKeyEvent *event).</p>   <h3 class="fn" id="mouseDoubleClickEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">mouseDoubleClickEvent</span>(<span class="type"><a href="qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#mouseDoubleClickEvent">QWidget::mouseDoubleClickEvent</a>(QMouseEvent *event).</p>   <h3 class="fn" id="mouseMoveEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">mouseMoveEvent</span>(<span class="type"><a href="qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#mouseMoveEvent">QWidget::mouseMoveEvent</a>(QMouseEvent *event).</p>   <h3 class="fn" id="mousePressEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">mousePressEvent</span>(<span class="type"><a href="qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#mousePressEvent">QWidget::mousePressEvent</a>(QMouseEvent *event).</p>   <h3 class="fn" id="mouseReleaseEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">mouseReleaseEvent</span>(<span class="type"><a href="qmouseevent.html">QMouseEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#mouseReleaseEvent">QWidget::mouseReleaseEvent</a>(QMouseEvent *event).</p>   <h3 class="fn" id="paintEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">paintEvent</span>(<span class="type"><a href="qpaintevent.html">QPaintEvent</a></span> *<i>event</i>)
</h3> <p>Reimplements: <a href="qwidget.html#paintEvent">QWidget::paintEvent</a>(QPaintEvent *event).</p>   <h3 class="fn" id="quickWindow">
<code>[since 5.5] </code><span class="type"><a href="qquickwindow.html">QQuickWindow</a></span> *QQuickWidget::<span class="name">quickWindow</span>() const
</h3> <p>Returns the offscreen <a href="qquickwindow.html">QQuickWindow</a> which is used by this widget to drive the Qt Quick rendering. This is useful if you want to use <a href="qquickwindow.html">QQuickWindow</a> APIs that are not currently exposed by <a href="qquickwidget.html">QQuickWidget</a>, for instance connecting to the <a href="qquickwindow.html#beforeRendering">QQuickWindow::beforeRendering</a>() signal in order to draw native OpenGL content below Qt Quick's own rendering.</p> <div class="admonition warning"> <p><b>Warning: </b>Use the return value of this function with caution. In particular, do not ever attempt to show the <a href="qquickwindow.html">QQuickWindow</a>, and be very careful when using other <a href="qwindow.html">QWindow</a>-only APIs.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>The offscreen window may be deleted (and recreated) during the life time of the <a href="qquickwidget.html">QQuickWidget</a>, particularly when the widget is moved to another <a href="qquickwindow.html">QQuickWindow</a>. If you need to know when the window has been replaced, connect to its <a href="qobject.html#destroyed">destroyed</a>() signal.</p> </div> <p>This function was introduced in Qt 5.5.</p>   <h3 class="fn" id="rootContext">
<span class="type"><a href="qqmlcontext.html">QQmlContext</a></span> *QQuickWidget::<span class="name">rootContext</span>() const
</h3> <p>This function returns the root of the context hierarchy. Each QML component is instantiated in a <a href="qqmlcontext.html">QQmlContext</a>. <a href="qqmlcontext.html">QQmlContext</a>'s are essential for passing data to QML components. In QML, contexts are arranged hierarchically and this hierarchy is managed by the <a href="qqmlengine.html">QQmlEngine</a>.</p>   <h3 class="fn" id="rootObject">
<span class="type"><a href="qquickitem.html">QQuickItem</a></span> *QQuickWidget::<span class="name">rootObject</span>() const
</h3> <p>Returns the view's root <a href="qquickitem.html">item</a>. Can be null when <a href="qquickwidget.html#setSource">setSource</a>() has not been called, if it was called with broken <a href="https://doc.qt.io/qt-6.2/qtquick-module.html">QtQuick</a> code or while the <a href="https://doc.qt.io/qt-6.2/qtquick-module.html">QtQuick</a> contents are being created.</p>   <h3 class="fn" id="setClearColor">
<span class="type">void</span> QQuickWidget::<span class="name">setClearColor</span>(const <span class="type"><a href="qcolor.html">QColor</a></span> &amp;<i>color</i>)
</h3> <p>Sets the clear <i>color</i>. By default this is an opaque color.</p> <p>To get a semi-transparent <a href="qquickwidget.html">QQuickWidget</a>, call this function with <i>color</i> set to <a href="qt.html#GlobalColor-enum">Qt::transparent</a>, set the <a href="qt.html#WidgetAttribute-enum">Qt::WA_TranslucentBackground</a> widget attribute on the top-level window, and request an alpha channel via <a href="qquickwidget.html#setFormat">setFormat</a>().</p> <p><b>See also </b><a href="qquickwindow.html#color-prop">QQuickWindow::setColor</a>().</p>   <h3 class="fn" id="setFormat">
<span class="type">void</span> QQuickWidget::<span class="name">setFormat</span>(const <span class="type"><a href="qsurfaceformat.html">QSurfaceFormat</a></span> &amp;<i>format</i>)
</h3> <p>Sets the surface <i>format</i> for the context and offscreen surface used by this widget.</p> <p>Call this function when there is a need to request a context for a given OpenGL version or profile. The sizes for depth, stencil and alpha buffers are taken care of automatically and there is no need to request those explicitly.</p> <p><b>See also </b><a href="qwindow.html#setFormat">QWindow::setFormat</a>(), <a href="qwindow.html#format">QWindow::format</a>(), and <a href="qquickwidget.html#format">format</a>().</p>   <h3 class="fn" id="showEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">showEvent</span>(<span class="type"><a href="qshowevent.html">QShowEvent</a></span> *)
</h3> <p>Reimplements: <a href="qwidget.html#showEvent">QWidget::showEvent</a>(QShowEvent *event).</p>   <h3 class="fn" id="source">
<span class="type"><a href="qurl.html">QUrl</a></span> QQuickWidget::<span class="name">source</span>() const
</h3> <p>Returns the source URL, if set.</p> <p><b>Note: </b>Getter function for property source. </p> <p><b>See also </b><a href="qquickwidget.html#setSource">setSource</a>().</p>   <h3 class="fn" id="wheelEvent">
<code>[override virtual protected] </code><span class="type">void</span> QQuickWidget::<span class="name">wheelEvent</span>(<span class="type"><a href="qwheelevent.html">QWheelEvent</a></span> *<i>e</i>)
</h3> <p>Reimplements: <a href="qwidget.html#wheelEvent">QWidget::wheelEvent</a>(QWheelEvent *event).</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qquickwidget.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qquickwidget.html</a>
  </p>
</div>
