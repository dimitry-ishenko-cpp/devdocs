<h1 class="title">QFuture Class</h1> <span class="small-subtitle">template &lt;typename T&gt; class QFuture</span>  <p>The QFuture class represents the result of an asynchronous computation. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QFuture&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qfuture-members.html">List of all members, including inherited members</a></li> <li><a href="https://doc.qt.io/qt-6.2/qfuture-obsolete.html">Deprecated members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="threads-reentrancy.html">thread-safe</a> with the following exceptions:</p> <ul> <li><a href="qfuture-const-iterator.html">const_iterator</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> class </td>
<td class="memItemRight bottomAlign"><b><a href="qfuture-const-iterator.html">const_iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qfuture.html#ConstIterator-typedef">ConstIterator</a></b></td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#QFuture-4">QFuture</a></b>(const QFuture&lt;T&gt; &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#QFuture">QFuture</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#operator-eq-1">operator=</a></b>(const QFuture&lt;T&gt; &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#dtor.QFuture">~QFuture</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#begin">begin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#cancel">cancel</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#constBegin">constBegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#constEnd">constEnd</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#end">end</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#isCanceled">isCanceled</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#isFinished">isFinished</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#isResultReadyAt">isResultReadyAt</a></b>(int <i>index</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#isRunning">isRunning</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#isStarted">isStarted</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#isSuspended">isSuspended</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#isSuspending">isSuspending</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#isValid">isValid</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#onCanceled">onCanceled</a></b>(Function &amp;&amp;<i>handler</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#onCanceled-1">onCanceled</a></b>(QObject *<i>context</i>, Function &amp;&amp;<i>handler</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#onFailed">onFailed</a></b>(Function &amp;&amp;<i>handler</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#onFailed-1">onFailed</a></b>(QObject *<i>context</i>, Function &amp;&amp;<i>handler</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#progressMaximum">progressMaximum</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#progressMinimum">progressMinimum</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#progressText">progressText</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#progressValue">progressValue</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#result">result</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#resultAt">resultAt</a></b>(int <i>index</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#resultCount">resultCount</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#results">results</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#resume">resume</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#setSuspended">setSuspended</a></b>(bool <i>suspend</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#suspend">suspend</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#takeResult">takeResult</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;ResultType&lt;Function&gt; &gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#then">then</a></b>(Function &amp;&amp;<i>function</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;ResultType&lt;Function&gt; &gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#then-1">then</a></b>(QtFuture::Launch <i>policy</i>, Function &amp;&amp;<i>function</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;ResultType&lt;Function&gt; &gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#then-2">then</a></b>(QThreadPool *<i>pool</i>, Function &amp;&amp;<i>function</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;ResultType&lt;Function&gt; &gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#then-3">then</a></b>(QObject *<i>context</i>, Function &amp;&amp;<i>function</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#toggleSuspended">toggleSuspended</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuture.html#waitForFinished">waitForFinished</a></b>()</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>QFuture allows threads to be synchronized against one or more results which will be ready at a later point in time. The result can be of any type that has default, copy and possibly move constructors. If a result is not available at the time of calling the <a href="qfuture.html#result">result</a>(), <a href="qfuture.html#resultAt">resultAt</a>(), <a href="qfuture.html#results">results</a>() and <a href="qfuture.html#takeResult">takeResult</a>() functions, QFuture will wait until the result becomes available. You can use the <a href="qfuture.html#isResultReadyAt">isResultReadyAt</a>() function to determine if a result is ready or not. For QFuture objects that report more than one result, the <a href="qfuture.html#resultCount">resultCount</a>() function returns the number of continuous results. This means that it is always safe to iterate through the results from 0 to <a href="qfuture.html#resultCount">resultCount</a>(). <a href="qfuture.html#takeResult">takeResult</a>() invalidates a future, and any subsequent attempt to access result or results from the future leads to undefined behavior. <a href="qfuture.html#isValid">isValid</a>() tells you if results can be accessed.</p> <p>QFuture provides a <a href="java-style-iterators.html#java-style-iterators">Java-style iterator</a> (<a href="qfutureiterator.html">QFutureIterator</a>) and an <a href="containers.html#stl-style-iterators">STL-style iterator</a> (<a href="qfuture-const-iterator.html">QFuture::const_iterator</a>). Using these iterators is another way to access results in the future.</p> <p>If the result of one asynchronous computation needs to be passed to another, QFuture provides a convenient way of chaining multiple sequential computations using <a href="qfuture.html#then">then</a>(). <a href="qfuture.html#onCanceled">onCanceled</a>() can be used for adding a handler to be called if the QFuture is canceled. Additionally, <a href="qfuture.html#onFailed">onFailed</a>() can be used to handle any failures that occurred in the chain. Note that QFuture relies on exceptions for the error handling. If using exceptions is not an option, you can still indicate the error state of QFuture, by making the error type part of the QFuture type. For example, you can use std::variant, std::any or similar for keeping the result or failure or make your custom type.</p> <p>The example below demonstrates how the error handling can be done without using exceptions. Let's say we want to send a network request to obtain a large file from a network location. Then we want to write it to the file system and return its location in case of a success. Both of these operations may fail with different errors. So, we use <code>std::variant</code> to keep the result or error:</p> <pre data-language="cpp">using NetworkReply = std::variant&lt;QByteArray, QNetworkReply::NetworkError&gt;;

enum class IOError { FailedToRead, FailedToWrite };
using IOResult = std::variant&lt;QString, IOError&gt;;</pre> <p>And we combine the two operations using <a href="qfuture.html#then">then</a>():</p> <pre data-language="cpp">QFuture&lt;IOResult&gt; future = QtConcurrent::run([url] {
        ...
        return NetworkReply(QNetworkReply::TimeoutError);
}).then([](NetworkReply reply) {
    if (auto error = std::get_if&lt;QNetworkReply::NetworkError&gt;(&amp;reply))
        return IOResult(IOError::FailedToRead);

    auto data = std::get_if&lt;QByteArray&gt;(&amp;reply);
    // try to write *data and return IOError::FailedToWrite on failure
    ...
});

auto result = future.result();
if (auto filePath = std::get_if&lt;QString&gt;(&amp;result)) {
    // do something with *filePath
else
    // process the error</pre> <p>It's possible to chain multiple continuations and handlers in any order. For example:</p> <pre data-language="cpp">QFuture&lt;int&gt; testFuture = ...;
auto resultFuture = testFuture.then([](int res) {
    // Block 1
}).onCanceled([] {
    // Block 2
}).onFailed([] {
    // Block 3
}).then([] {
    // Block 4
}).onFailed([] {
    // Block 5
}).onCanceled([] {
    // Block 6
});</pre> <p>Depending on the state of <code>testFuture</code> (canceled, has exception or has a result), the next <a href="qfuture.html#onCanceled">onCanceled</a>(), <a href="qfuture.html#onFailed">onFailed</a>() or <a href="qfuture.html#then">then</a>() will be called. So if <code>testFuture</code> is successfully fulfilled, <code>Block 1</code> will be called. If it succeeds as well, the next <a href="qfuture.html#then">then</a>() (<code>Block 4</code>) is called. If <code>testFuture</code> gets canceled or fails with an exception, either <code>Block 2</code> or <code>Block 3</code> will be called respectively. The next <a href="qfuture.html#then">then</a>() will be called afterwards, and the story repeats.</p> <div class="admonition note"> <p><b>Note: </b>If <code>Block 2</code> is invoked and throws an exception, the following <a href="qfuture.html#onFailed">onFailed</a>() (<code>Block 3</code>) will handle it. If the order of <a href="qfuture.html#onFailed">onFailed</a>() and <a href="qfuture.html#onCanceled">onCanceled</a>() were reversed, the exception state would propagate to the next continuations and eventually would be caught in <code>Block 5</code>.</p> </div> <p>In the next example the first <a href="qfuture.html#onCanceled">onCanceled</a>() (<code>Block 2</code>) is removed:</p> <pre data-language="cpp">QFuture&lt;int&gt; testFuture = ...;
auto resultFuture = testFuture.then([](int res) {
    // Block 1
}).onFailed([] {
    // Block 3
}).then([] {
    // Block 4
}).onFailed([] {
    // Block 5
}).onCanceled([] {
    // Block 6
});</pre> <p>If <code>testFuture</code> gets canceled, its state is propagated to the next <a href="qfuture.html#then">then</a>(), which will be also canceled. So in this case <code>Block 6</code> will be called.</p> <p>QFuture also offers ways to interact with a running computation. For instance, the computation can be canceled with the <a href="qfuture.html#cancel">cancel</a>() function. To suspend or resume the computation, use the <a href="qfuture.html#setSuspended">setSuspended</a>() function or one of the <a href="qfuture.html#suspend">suspend</a>(), <a href="qfuture.html#resume">resume</a>(), or <a href="qfuture.html#toggleSuspended">toggleSuspended</a>() convenience functions. Be aware that not all running asynchronous computations can be canceled or suspended. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</p> <p>Progress information is provided by the <a href="qfuture.html#progressValue">progressValue</a>(), <a href="qfuture.html#progressMinimum">progressMinimum</a>(), <a href="qfuture.html#progressMaximum">progressMaximum</a>(), and <a href="qfuture.html#progressText">progressText</a>() functions. The <a href="qfuture.html#waitForFinished">waitForFinished</a>() function causes the calling thread to block and wait for the computation to finish, ensuring that all results are available.</p> <p>The state of the computation represented by a QFuture can be queried using the <a href="qfuture.html#isCanceled">isCanceled</a>(), <a href="qfuture.html#isStarted">isStarted</a>(), <a href="qfuture.html#isFinished">isFinished</a>(), <a href="qfuture.html#isRunning">isRunning</a>(), <a href="qfuture.html#isSuspending">isSuspending</a>() or <a href="qfuture.html#isSuspended">isSuspended</a>() functions.</p> <p>QFuture&lt;void&gt; is specialized to not contain any of the result fetching functions. Any QFuture&lt;T&gt; can be assigned or copied into a QFuture&lt;void&gt; as well. This is useful if only status or progress information is needed - not the actual result data.</p> <p>To interact with running tasks using signals and slots, use <a href="qfuturewatcher.html">QFutureWatcher</a>.</p> <p>You can also use <a href="qtfuture.html#connect">QtFuture::connect</a> to connect signals to a QFuture object which will be resolved when a signal is emitted. This allows working with signals like with QFuture objects. For example, if you combine it with <a href="qfuture.html#then">then</a>(), you can attach multiple continuations to a signal, which are invoked in the same thread or a new thread.</p> <p>A ready QFuture object with a value or a QFuture object holding exception can be created using convenience functions <a href="qtfuture.html#makeReadyFuture">QtFuture::makeReadyFuture</a> and <a href="qtfuture.html#makeExceptionalFuture">QtFuture::makeExceptionalFuture</a>.</p> <div class="admonition note"> <p><b>Note: </b>To start a computation and store results in a QFuture, use <a href="qpromise.html">QPromise</a> or one of the APIs in the <a href="qtconcurrent-index.html">Qt Concurrent</a> framework.</p> </div>  <p><b>See also </b><a href="qpromise.html">QPromise</a>, <a href="qtfuture.html#connect">QtFuture::connect</a>(), <a href="qtfuture.html#makeReadyFuture-1">QtFuture::makeReadyFuture</a>(), <a href="qtfuture.html#makeExceptionalFuture">QtFuture::makeExceptionalFuture</a>(), <a href="qfuturewatcher.html">QFutureWatcher</a>, and <a href="qtconcurrent-index.html">Qt Concurrent</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="ConstIterator-typedef">QFuture::<span class="name">ConstIterator</span>
</h3> <p>Qt-style synonym for <a href="qfuture-const-iterator.html">QFuture::const_iterator</a>.</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QFuture-4">QFuture::<span class="name">QFuture</span>(const <span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)
</h3> <p>Constructs a copy of <i>other</i>.</p> <p><b>See also </b><a href="qfuture.html#operator-eq-1">operator=</a>().</p>   <h3 class="fn" id="QFuture">QFuture::<span class="name">QFuture</span>()
</h3> <p>Constructs an empty, canceled future.</p>   <h3 class="fn" id="operator-eq-1">
<span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;QFuture::<span class="name">operator=</span>(const <span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)
</h3> <p>Assigns <i>other</i> to this future and returns a reference to this future.</p>   <h3 class="fn" id="dtor.QFuture">QFuture::<span class="name">~QFuture</span>()
</h3> <p>Destroys the future.</p> <p>Note that this neither waits nor cancels the asynchronous computation. Use <a href="qfuture.html#waitForFinished">waitForFinished</a>() or <a href="qfuturesynchronizer.html">QFutureSynchronizer</a> when you need to ensure that the computation is completed before the future is destroyed.</p>   <h3 class="fn" id="begin">template &lt;typename U, typename&gt; <span class="type"><a href="qfuture-const-iterator.html">QFuture::const_iterator</a></span> QFuture::<span class="name">begin</span>() const
</h3> <p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first result in the future.</p> <p><b>See also </b><a href="qfuture.html#constBegin">constBegin</a>() and <a href="qfuture.html#end">end</a>().</p>   <h3 class="fn" id="cancel">
<span class="type">void</span> QFuture::<span class="name">cancel</span>()
</h3> <p>Cancels the asynchronous computation represented by this future. Note that the cancellation is asynchronous. Use <a href="qfuture.html#waitForFinished">waitForFinished</a>() after calling cancel() when you need synchronous cancellation.</p> <p>Results currently available may still be accessed on a canceled future, but new results will <i>not</i> become available after calling this function. Any <a href="qfuturewatcher.html">QFutureWatcher</a> object that is watching this future will not deliver progress and result ready signals on a canceled future.</p> <p>Be aware that not all running asynchronous computations can be canceled. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</p>   <h3 class="fn" id="constBegin">template &lt;typename U, typename&gt; <span class="type"><a href="qfuture-const-iterator.html">QFuture::const_iterator</a></span> QFuture::<span class="name">constBegin</span>() const
</h3> <p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first result in the future.</p> <p><b>See also </b><a href="qfuture.html#begin">begin</a>() and <a href="qfuture.html#constEnd">constEnd</a>().</p>   <h3 class="fn" id="constEnd">template &lt;typename U, typename&gt; <span class="type"><a href="qfuture-const-iterator.html">QFuture::const_iterator</a></span> QFuture::<span class="name">constEnd</span>() const
</h3> <p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary result after the last result in the future.</p> <p><b>See also </b><a href="qfuture.html#constBegin">constBegin</a>() and <a href="qfuture.html#end">end</a>().</p>   <h3 class="fn" id="end">template &lt;typename U, typename&gt; <span class="type"><a href="qfuture-const-iterator.html">QFuture::const_iterator</a></span> QFuture::<span class="name">end</span>() const
</h3> <p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary result after the last result in the future.</p> <p><b>See also </b><a href="qfuture.html#begin">begin</a>() and <a href="qfuture.html#constEnd">constEnd</a>().</p>   <h3 class="fn" id="isCanceled">
<span class="type">bool</span> QFuture::<span class="name">isCanceled</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation has been canceled with the <a href="qfuture.html#cancel">cancel</a>() function; otherwise returns <code>false</code>.</p> <p>Be aware that the computation may still be running even though this function returns <code>true</code>. See <a href="qfuture.html#cancel">cancel</a>() for more details.</p>   <h3 class="fn" id="isFinished">
<span class="type">bool</span> QFuture::<span class="name">isFinished</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation represented by this future has finished; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="isResultReadyAt">template &lt;typename U, typename&gt; <span class="type">bool</span> QFuture::<span class="name">isResultReadyAt</span>(<span class="type">int</span> <i>index</i>) const
</h3> <p>Returns <code>true</code> if the result at <i>index</i> is immediately available; otherwise returns <code>false</code>.</p> <div class="admonition note"> <p><b>Note: </b>Calling isResultReadyAt() leads to undefined behavior if <a href="qfuture.html#isValid">isValid</a>() returns <code>false</code> for this <a href="qfuture.html">QFuture</a>.</p> </div> <p><b>See also </b><a href="qfuture.html#resultAt">resultAt</a>(), <a href="qfuture.html#resultCount">resultCount</a>(), and <a href="qfuture.html#takeResult">takeResult</a>().</p>   <h3 class="fn" id="isRunning">
<span class="type">bool</span> QFuture::<span class="name">isRunning</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation represented by this future is currently running; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="isStarted">
<span class="type">bool</span> QFuture::<span class="name">isStarted</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation represented by this future has been started; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="isSuspended">
<code>[since 6.0] </code><span class="type">bool</span> QFuture::<span class="name">isSuspended</span>() const
</h3> <p>Returns <code>true</code> if a suspension of the asynchronous computation has been requested, and it is in effect, meaning that no more results or progress changes are expected.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#setSuspended">setSuspended</a>(), <a href="qfuture.html#toggleSuspended">toggleSuspended</a>(), and <a href="qfuture.html#isSuspending">isSuspending</a>().</p>   <h3 class="fn" id="isSuspending">
<code>[since 6.0] </code><span class="type">bool</span> QFuture::<span class="name">isSuspending</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation has been suspended with the <a href="qfuture.html#suspend">suspend</a>() function, but the work is not yet suspended, and computation is still running. Returns <code>false</code> otherwise.</p> <p>To check if suspension is actually in effect, use <a href="qfuture.html#isSuspended">isSuspended</a>() instead.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#setSuspended">setSuspended</a>(), <a href="qfuture.html#toggleSuspended">toggleSuspended</a>(), and <a href="qfuture.html#isSuspended">isSuspended</a>().</p>   <h3 class="fn" id="isValid">
<code>[since 6.0] </code><span class="type">bool</span> QFuture::<span class="name">isValid</span>() const
</h3> <p>Returns <code>true</code> if a result or results can be accessed or taken from this <a href="qfuture.html">QFuture</a> object. Returns false after the result was taken from the future.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#takeResult">takeResult</a>(), <a href="qfuture.html#result">result</a>(), <a href="qfuture.html#results">results</a>(), and <a href="qfuture.html#resultAt">resultAt</a>().</p>   <h3 class="fn" id="onCanceled">
<code>[since 6.0] </code>template &lt;typename Function, typename&gt; <span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">onCanceled</span>(<span class="type">Function</span> &amp;&amp;<i>handler</i>)
</h3> <p>Attaches a cancellation <i>handler</i> to this future. The returned future behaves exactly as this future (has the same state and result) unless this future is cancelled. The <i>handler</i> is a callable which takes no arguments and returns a value of the type packaged by this future. After cancellation, the returned future packages the value returned by <i>handler</i>.</p> <p>If attached before the cancellation, <i>handler</i> will be invoked in the same thread that reports the future as finished after the cancellation. If the handler is attached after this future has already been canceled, it will be invoked immediately in the thread that executes <code>onCanceled()</code>. Therefore, the handler cannot always make assumptions about which thread it will be run on. Use the overload that takes a context object if you want to control which thread the handler is invoked on.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#then">then</a>() and <a href="qfuture.html#onFailed">onFailed</a>().</p>   <h3 class="fn" id="onCanceled-1">
<code>[since 6.1] </code>template &lt;typename Function, typename&gt; <span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">onCanceled</span>(<span class="type"><a href="qobject.html">QObject</a></span> *<i>context</i>, <span class="type">Function</span> &amp;&amp;<i>handler</i>)
</h3> <p>This is an overloaded function.</p> <p>Attaches a cancellation <i>handler</i> to this future, to be called when the future is canceled. The <i>handler</i> is a callable which doesn't take any arguments. It will be invoked in the thread of the <i>context</i> object. This can be useful if the cancellation needs to be handled in a specific thread.</p> <div class="admonition note"> <p><b>Note: </b>When calling this method, it should be guaranteed that the <i>context</i> stays alive throughout the execution of the chain.</p> </div> <p>See the documentation of the other overload for more details about <i>handler</i>.</p> <p>This function was introduced in Qt 6.1.</p> <p><b>See also </b><a href="qfuture.html#then">then</a>() and <a href="qfuture.html#onFailed">onFailed</a>().</p>   <h3 class="fn" id="onFailed">
<code>[since 6.0] </code>template &lt;typename Function, typename&gt; <span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">onFailed</span>(<span class="type">Function</span> &amp;&amp;<i>handler</i>)
</h3> <p>Attaches a failure handler to this future, to handle any exceptions. The returned future behaves exactly as this future (has the same state and result) unless this future fails with an exception.</p> <p>The <i>handler</i> is a callable which takes either no argument or one argument, to filter by specific error types, similar to the <a href="https://en.cppreference.com/w/cpp/language/try_catch">catch</a> statement. It returns a value of the type packaged by this future. After the failure, the returned future packages the value returned by <i>handler</i>.</p> <p>The handler will only be invoked if an exception is raised. If the exception is raised after this handler is attached, the handler is executed in the thread that reports the future as finished as a result of the exception. If the handler is attached after this future has already failed, it will be invoked immediately, in the thread that executes <code>onFailed()</code>. Therefore, the handler cannot always make assumptions about which thread it will be run on. Use the overload that takes a context object if you want to control which thread the handler is invoked on.</p> <p>The example below demonstrates how to attach a failure handler:</p> <pre data-language="cpp">QFuture&lt;int&gt; future = ...;
auto resultFuture = future.then([](int res) {
    ...
    throw Error();
    ...
}).onFailed([](const Error &amp;e) {
    // Handle exceptions of type Error
    ...
    return -1;
}).onFailed([] {
    // Handle all other types of errors
    ...
    return -1;
});

auto result = resultFuture.result(); // result is -1</pre> <p>If there are multiple handlers attached, the first handler that matches with the thrown exception type will be invoked. For example:</p> <pre data-language="cpp">QFuture&lt;int&gt; future = ...;
future.then([](int res) {
    ...
    throw std::runtime_error("message");
    ...
}).onFailed([](const std::exception &amp;e) {
    // This handler will be invoked
}).onFailed([](const std::runtime_error &amp;e) {
    // This handler won't be invoked, because of the handler above.
});</pre> <p>If none of the handlers matches with the thrown exception type, the exception will be propagated to the resulted future:</p> <pre data-language="cpp">QFuture&lt;int&gt; future = ...;
auto resultFuture = future.then([](int res) {
    ...
    throw Error("message");
    ...
}).onFailed([](const std::exception &amp;e) {
    // Won't be invoked
}).onFailed([](const QException &amp;e) {
    // Won't be invoked
});

try {
    auto result = resultFuture.result();
} catch(...) {
    // Handle the exception
}</pre> <div class="admonition note"> <p><b>Note: </b>You can always attach a handler taking no argument, to handle all exception types and avoid writing the try-catch block.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#then">then</a>() and <a href="qfuture.html#onCanceled">onCanceled</a>().</p>   <h3 class="fn" id="onFailed-1">
<code>[since 6.1] </code>template &lt;typename Function, typename&gt; <span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">onFailed</span>(<span class="type"><a href="qobject.html">QObject</a></span> *<i>context</i>, <span class="type">Function</span> &amp;&amp;<i>handler</i>)
</h3> <p>This is an overloaded function.</p> <p>Attaches a failure handler to this future, to handle any exceptions that the future raises, or that it has already raised. Returns a <a href="qfuture.html">QFuture</a> of the same type as this future. The handler will be invoked only in case of an exception, in the thread of the <i>context</i> object. This can be useful if the failure needs to be handled in a specific thread. For example:</p> <pre data-language="cpp">// somewhere in the main thread
auto future = QtConcurrent::run([] {
    // This will run in a separate thread
    ...
    throw std::exception();
}).onFailed(this, [] {
   // Update UI elements
});</pre> <p>The failure handler attached into <a href="qtconcurrent.html#run">QtConcurrent::run</a> updates the UI elements and cannot be invoked from a non-gui thread. So <code>this</code> is provided as a context to <code>.onFailed()</code>, to make sure that it will be invoked in the main thread.</p> <div class="admonition note"> <p><b>Note: </b>When calling this method, it should be guaranteed that the <i>context</i> stays alive throughout the execution of the chain.</p> </div> <p>See the documentation of the other overload for more details about <i>handler</i>.</p> <p>This function was introduced in Qt 6.1.</p> <p><b>See also </b><a href="qfuture.html#then">then</a>() and <a href="qfuture.html#onCanceled">onCanceled</a>().</p>   <h3 class="fn" id="progressMaximum">
<span class="type">int</span> QFuture::<span class="name">progressMaximum</span>() const
</h3> <p>Returns the maximum <a href="qfuture.html#progressValue">progressValue</a>().</p> <p><b>See also </b><a href="qfuture.html#progressValue">progressValue</a>() and <a href="qfuture.html#progressMinimum">progressMinimum</a>().</p>   <h3 class="fn" id="progressMinimum">
<span class="type">int</span> QFuture::<span class="name">progressMinimum</span>() const
</h3> <p>Returns the minimum <a href="qfuture.html#progressValue">progressValue</a>().</p> <p><b>See also </b><a href="qfuture.html#progressValue">progressValue</a>() and <a href="qfuture.html#progressMaximum">progressMaximum</a>().</p>   <h3 class="fn" id="progressText">
<span class="type"><a href="qstring.html">QString</a></span> QFuture::<span class="name">progressText</span>() const
</h3> <p>Returns the (optional) textual representation of the progress as reported by the asynchronous computation.</p> <p>Be aware that not all computations provide a textual representation of the progress, and as such, this function may return an empty string.</p>   <h3 class="fn" id="progressValue">
<span class="type">int</span> QFuture::<span class="name">progressValue</span>() const
</h3> <p>Returns the current progress value, which is between the <a href="qfuture.html#progressMinimum">progressMinimum</a>() and <a href="qfuture.html#progressMaximum">progressMaximum</a>().</p> <p><b>See also </b><a href="qfuture.html#progressMinimum">progressMinimum</a>() and <a href="qfuture.html#progressMaximum">progressMaximum</a>().</p>   <h3 class="fn" id="result">template &lt;typename U, typename&gt; <span class="type">T</span> QFuture::<span class="name">result</span>() const
</h3> <p>Returns the first result in the future. If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <a href="qfuture.html#resultAt">resultAt</a>(0). Note that <code>result()</code> returns a copy of the internally stored result. If <code>T</code> is a move-only type, or you don't want to copy the result, use <a href="qfuture.html#takeResult">takeResult</a>() instead.</p> <div class="admonition note"> <p><b>Note: </b>Calling <code>result()</code> leads to undefined behavior if <a href="qfuture.html#isValid">isValid</a>() returns <code>false</code> for this <a href="qfuture.html">QFuture</a>.</p> </div> <p><b>See also </b><a href="qfuture.html#resultAt">resultAt</a>(), <a href="qfuture.html#results">results</a>(), and <a href="qfuture.html#takeResult">takeResult</a>().</p>   <h3 class="fn" id="resultAt">template &lt;typename U, typename&gt; <span class="type">T</span> QFuture::<span class="name">resultAt</span>(<span class="type">int</span> <i>index</i>) const
</h3> <p>Returns the result at <i>index</i> in the future. If the result is not immediately available, this function will block and wait for the result to become available.</p> <div class="admonition note"> <p><b>Note: </b>Calling resultAt() leads to undefined behavior if <a href="qfuture.html#isValid">isValid</a>() returns <code>false</code> for this <a href="qfuture.html">QFuture</a>.</p> </div> <p><b>See also </b><a href="qfuture.html#result">result</a>(), <a href="qfuture.html#results">results</a>(), <a href="qfuture.html#takeResult">takeResult</a>(), and <a href="qfuture.html#resultCount">resultCount</a>().</p>   <h3 class="fn" id="resultCount">
<span class="type">int</span> QFuture::<span class="name">resultCount</span>() const
</h3> <p>Returns the number of continuous results available in this future. The real number of results stored might be different from this value, due to gaps in the result set. It is always safe to iterate through the results from 0 to resultCount().</p> <p><b>See also </b><a href="qfuture.html#result">result</a>(), <a href="qfuture.html#resultAt">resultAt</a>(), <a href="qfuture.html#results">results</a>(), and <a href="qfuture.html#takeResult">takeResult</a>().</p>   <h3 class="fn" id="results">template &lt;typename U, typename&gt; <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">results</span>() const
</h3> <p>Returns all results from the future. If the results are not immediately available, this function will block and wait for them to become available. Note that <code>results()</code> returns a copy of the internally stored results. Getting all results of a move-only type <code>T</code> is not supported at the moment. However you can still iterate through the list of move-only results by using <a href="containers.html#stl-style-iterators">STL-style iterators</a> or read-only <a href="java-style-iterators.html#java-style-iterators">Java-style iterators</a>.</p> <div class="admonition note"> <p><b>Note: </b>Calling <code>results()</code> leads to undefined behavior if <a href="qfuture.html#isValid">isValid</a>() returns <code>false</code> for this <a href="qfuture.html">QFuture</a>.</p> </div> <p><b>See also </b><a href="qfuture.html#result">result</a>(), <a href="qfuture.html#resultAt">resultAt</a>(), <a href="qfuture.html#takeResult">takeResult</a>(), <a href="qfuture.html#resultCount">resultCount</a>(), and <a href="qfuture.html#isValid">isValid</a>().</p>   <h3 class="fn" id="resume">
<span class="type">void</span> QFuture::<span class="name">resume</span>()
</h3> <p>Resumes the asynchronous computation represented by the future(). This is a convenience method that simply calls <a href="qfuture.html#setSuspended">setSuspended</a>(false).</p> <p><b>See also </b><a href="qfuture.html#suspend">suspend</a>().</p>   <h3 class="fn" id="setSuspended">
<code>[since 6.0] </code><span class="type">void</span> QFuture::<span class="name">setSuspended</span>(<span class="type">bool</span> <i>suspend</i>)
</h3> <p>If <i>suspend</i> is true, this function suspends the asynchronous computation represented by the future(). If the computation is already suspended, this function does nothing. <a href="qfuturewatcher.html">QFutureWatcher</a> will not immediately stop delivering progress and result ready signals when the future is suspended. At the moment of suspending there may still be computations that are in progress and cannot be stopped. Signals for such computations will still be delivered.</p> <p>If <i>suspend</i> is false, this function resumes the asynchronous computation. If the computation was not previously suspended, this function does nothing.</p> <p>Be aware that not all computations can be suspended. For example, the <a href="qfuture.html">QFuture</a> returned by QtConcurrent::run() cannot be suspended; but the <a href="qfuture.html">QFuture</a> returned by QtConcurrent::mappedReduced() can.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#isSuspended">isSuspended</a>(), <a href="qfuture.html#suspend">suspend</a>(), <a href="qfuture.html#resume">resume</a>(), and <a href="qfuture.html#toggleSuspended">toggleSuspended</a>().</p>   <h3 class="fn" id="suspend">
<code>[since 6.0] </code><span class="type">void</span> QFuture::<span class="name">suspend</span>()
</h3> <p>Suspends the asynchronous computation represented by this future. This is a convenience method that simply calls <a href="qfuture.html#setSuspended">setSuspended</a>(true).</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#resume">resume</a>().</p>   <h3 class="fn" id="takeResult">
<code>[since 6.0] </code>template &lt;typename U, typename&gt; <span class="type">T</span> QFuture::<span class="name">takeResult</span>()
</h3> <p>Call this function only if <a href="qfuture.html#isValid">isValid</a>() returns <code>true</code>, otherwise the behavior is undefined. This function takes (moves) the first result from the <a href="qfuture.html">QFuture</a> object, when only one result is expected. If there are any other results, they are discarded after taking the first one. If the result is not immediately available, this function will block and wait for the result to become available. The <a href="qfuture.html">QFuture</a> will try to use move semantics if possible, and will fall back to copy construction if the type is not movable. After the result was taken, <a href="qfuture.html#isValid">isValid</a>() will evaluate as <code>false</code>.</p> <div class="admonition note"> <p><b>Note: </b><a href="qfuture.html">QFuture</a> in general allows sharing the results between different <a href="qfuture.html">QFuture</a> objects (and potentially between different threads). takeResult() was introduced to make <a href="qfuture.html">QFuture</a> also work with move-only types (like std::unique_ptr), so it assumes that only one thread can move the results out of the future, and do it only once. Also note that taking the list of all results is not supported at the moment. However you can still iterate through the list of move-only results by using <a href="containers.html#stl-style-iterators">STL-style iterators</a> or read-only <a href="java-style-iterators.html#java-style-iterators">Java-style iterators</a>.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#result">result</a>(), <a href="qfuture.html#results">results</a>(), <a href="qfuture.html#resultAt">resultAt</a>(), and <a href="qfuture.html#isValid">isValid</a>().</p>   <h3 class="fn" id="then">
<code>[since 6.0] </code>template &lt;typename Function&gt; <span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">ResultType</span>&lt;<span class="type">Function</span>&gt; &gt; QFuture::<span class="name">then</span>(<span class="type">Function</span> &amp;&amp;<i>function</i>)
</h3> <p>This is an overloaded function.</p> <p>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired, using the <a href="qtfuture.html#Launch-enum">Sync</a> policy. <i>function</i> is a callable that takes an argument of the type packaged by this future if this has a result (is not a <a href="qfuture.html">QFuture</a>&lt;void&gt;). Otherwise it takes no arguments. This method returns a new <a href="qfuture.html">QFuture</a> that packages a value of the type returned by <i>function</i>. The returned future will be in an uninitialized state until the attached continuation is invoked, or until this future fails or is canceled.</p> <div class="admonition note"> <p><b>Note: </b>Use other overloads of this method if you need to launch the continuation in a separate thread.</p> </div> <p>You can chain multiple operations like this:</p> <pre data-language="cpp">QFuture&lt;int&gt; future = ...;
future.then([](int res1){ ... }).then([](int res2){ ... })...</pre> <p>Or:</p> <pre data-language="cpp">QFuture&lt;void&gt; future = ...;
future.then([](){ ... }).then([](){ ... })...</pre> <p>The continuation can also take a <a href="qfuture.html">QFuture</a> argument (instead of its value), representing the previous future. This can be useful if, for example, <a href="qfuture.html">QFuture</a> has multiple results, and the user wants to access them inside the continuation. Or the user needs to handle the exception of the previous future inside the continuation, to not interrupt the chain of multiple continuations. For example:</p> <pre data-language="cpp">QFuture&lt;int&gt; future = ...;
    future.then([](QFuture&lt;int&gt; f) {
        try {
            ...
            auto result = f.result();
            ...
        } catch (QException &amp;e) {
            // handle the exception
        }
    }).then(...);</pre> <p>If the previous future throws an exception and it is not handled inside the continuation, the exception will be propagated to the continuation future, to allow the caller to handle it:</p> <pre data-language="cpp">QFuture&lt;int&gt; future = ...;
auto continuation = future.then([](int res1){ ... }).then([](int res2){ ... })...
...
// future throws an exception
try {
    auto result = continuation.result();
} catch (QException &amp;e) {
    // handle the exception
}</pre> <p>In this case the whole chain of continuations will be interrupted.</p> <div class="admonition note"> <p><b>Note: </b>If this future gets canceled, the continuations attached to it will also be canceled.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#onFailed">onFailed</a>() and <a href="qfuture.html#onCanceled">onCanceled</a>().</p>   <h3 class="fn" id="then-1">
<code>[since 6.0] </code>template &lt;typename Function&gt; <span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">ResultType</span>&lt;<span class="type">Function</span>&gt; &gt; QFuture::<span class="name">then</span>(<span class="type"><a href="qtfuture.html#Launch-enum">QtFuture::Launch</a></span> <i>policy</i>, <span class="type">Function</span> &amp;&amp;<i>function</i>)
</h3> <p>This is an overloaded function.</p> <p>Attaches a continuation to this future, allowing to chain multiple asynchronous computations. When the asynchronous computation represented by this future finishes, <i>function</i> will be invoked according to the given launch <i>policy</i>. A new <a href="qfuture.html">QFuture</a> representing the result of the continuation is returned.</p> <p>Depending on the <i>policy</i>, continuation will be invoked in the same thread as this future, in a new thread, or will inherit the launch policy and thread pool of this future. If no launch policy is specified (see the overload taking only a callable), the <code>Sync</code> policy will be used.</p> <p>In the following example both continuations will be invoked in a new thread (but in the same one).</p> <pre data-language="cpp">QFuture&lt;int&gt; future = ...;
future.then(QtFuture::Launch::Async, [](int res){ ... }).then([](int res2){ ... });</pre> <p>In the following example both continuations will be invoked in new threads using the same thread pool.</p> <pre data-language="cpp">QFuture&lt;int&gt; future = ...;
future.then(QtFuture::Launch::Async, [](int res){ ... })
      .then(QtFuture::Launch::Inherit, [](int res2){ ... });</pre> <p>See the documentation of the other overload for more details about <i>function</i>.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#onFailed">onFailed</a>() and <a href="qfuture.html#onCanceled">onCanceled</a>().</p>   <h3 class="fn" id="then-2">
<code>[since 6.0] </code>template &lt;typename Function&gt; <span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">ResultType</span>&lt;<span class="type">Function</span>&gt; &gt; QFuture::<span class="name">then</span>(<span class="type"><a href="qthreadpool.html">QThreadPool</a></span> *<i>pool</i>, <span class="type">Function</span> &amp;&amp;<i>function</i>)
</h3> <p>This is an overloaded function.</p> <p>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired. When the asynchronous computation represented by this future finishes, <i>function</i> will be invoked in a separate thread taken from the <a href="qthreadpool.html">QThreadPool</a> <i>pool</i>.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#onFailed">onFailed</a>() and <a href="qfuture.html#onCanceled">onCanceled</a>().</p>   <h3 class="fn" id="then-3">
<code>[since 6.1] </code>template &lt;typename Function&gt; <span class="type"><a href="qfuture.html#QFuture">QFuture</a></span>&lt;<span class="type">ResultType</span>&lt;<span class="type">Function</span>&gt; &gt; QFuture::<span class="name">then</span>(<span class="type"><a href="qobject.html">QObject</a></span> *<i>context</i>, <span class="type">Function</span> &amp;&amp;<i>function</i>)
</h3> <p>This is an overloaded function.</p> <p>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired. When the asynchronous computation represented by this future finishes, <i>function</i> will be invoked in the thread of the <i>context</i> object. This can be useful if the continuation needs to be invoked in a specific thread. For example:</p> <pre data-language="cpp">// somewhere in the main thread
auto future = QtConcurrent::run([] {
    // This will run in a separate thread
    ...
}).then(this, [] {
   // Update UI elements
});</pre> <p>The continuation attached into <a href="qtconcurrent.html#run">QtConcurrent::run</a> updates the UI elements and cannot be invoked from a non-gui thread. So <code>this</code> is provided as a context to <code>.then()</code>, to make sure that it will be invoked in the main thread.</p> <p>The following continuations will be also invoked from the same context, unless a different context or launch policy is specified:</p> <pre data-language="cpp">auto future = QtConcurrent::run([] {
    ...
}).then(this, [] {
   // Update UI elements
}).then([] {
    // This will also run in the main thread
});</pre> <p>This is because by default <code>.then()</code> is invoked from the same thread as the previous one.</p> <p>But note that if the continuation is attached after this future has already finished, it will be invoked immediately, in the thread that executes <code>then()</code>:</p> <pre data-language="cpp">QObject *context = ...;
auto future = cachedResultsReady ? QtFuture::makeReadyFuture(results)
                                 : QtConcurrent::run([] { /* compute results */});
auto continuation = future.then(context, [] (Results results) {
    // Runs in the context's thread
}).then([] {
    // May or may not run in the context's thread
});</pre> <p>In the above example if <code>cachedResultsReady</code> is <code>true</code>, and a ready future is returned, it is possible that the first <code>.then()</code> finishes before the second one is attached. In this case it will be resolved in the current thread. Therefore, when in doubt, pass the context explicitly.</p> <div class="admonition note"> <p><b>Note: </b>When calling this method, it should be guaranteed that the <i>context</i> stays alive throughout the execution of the chain.</p> </div> <p>This function was introduced in Qt 6.1.</p> <p><b>See also </b><a href="qfuture.html#onFailed">onFailed</a>() and <a href="qfuture.html#onCanceled">onCanceled</a>().</p>   <h3 class="fn" id="toggleSuspended">
<code>[since 6.0] </code><span class="type">void</span> QFuture::<span class="name">toggleSuspended</span>()
</h3> <p>Toggles the suspended state of the asynchronous computation. In other words, if the computation is currently suspending or suspended, calling this function resumes it; if the computation is running, it is suspended. This is a convenience method for calling <a href="qfuture.html#setSuspended">setSuspended</a>(!(<a href="qfuture.html#isSuspending">isSuspending</a>() || <a href="qfuture.html#isSuspended">isSuspended</a>())).</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuture.html#setSuspended">setSuspended</a>(), <a href="qfuture.html#suspend">suspend</a>(), and <a href="qfuture.html#resume">resume</a>().</p>   <h3 class="fn" id="waitForFinished">
<span class="type">void</span> QFuture::<span class="name">waitForFinished</span>()
</h3> <p>Waits for the asynchronous computation to finish (including <a href="qfuture.html#cancel">cancel</a>()ed computations), i.e. until <a href="qfuture.html#isFinished">isFinished</a>() returns <code>true</code>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qfuture.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qfuture.html</a>
  </p>
</div>
