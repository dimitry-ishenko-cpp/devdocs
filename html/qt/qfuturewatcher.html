<h1 class="title">QFutureWatcher Class</h1> <span class="small-subtitle">template &lt;typename T&gt; class QFutureWatcher</span>  <p>The QFutureWatcher class allows monitoring a <a href="qfuture.html">QFuture</a> using signals and slots. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QFutureWatcher&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qobject.html">QObject</a>
</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qfuturewatcher-members.html">List of all members, including inherited members</a></li> <li><a href="https://doc.qt.io/qt-6.2/qfuturewatcher-obsolete.html">Deprecated members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="17-qdoc-commands-thread.html#reentrant">reentrant</a>.</p> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#QFutureWatcher">QFutureWatcher</a></b>(QObject *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#dtor.QFutureWatcher">~QFutureWatcher</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#future">future</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#isCanceled">isCanceled</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#isFinished">isFinished</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#isRunning">isRunning</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#isStarted">isStarted</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#isSuspended">isSuspended</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#isSuspending">isSuspending</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#progressMaximum">progressMaximum</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#progressMinimum">progressMinimum</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#progressText">progressText</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#progressValue">progressValue</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#result">result</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#resultAt">resultAt</a></b>(int <i>index</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#setFuture">setFuture</a></b>(const QFuture&lt;T&gt; &amp;<i>future</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#setPendingResultsLimit">setPendingResultsLimit</a></b>(int <i>limit</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#waitForFinished">waitForFinished</a></b>()</td>
</tr> </table> <h2 id="public-slots">Public Slots
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#cancel">cancel</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#resume">resume</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#setSuspended">setSuspended</a></b>(bool <i>suspend</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#suspend">suspend</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#toggleSuspended">toggleSuspended</a></b>()</td>
</tr> </table> <h2 id="signals">Signals
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#canceled">canceled</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#finished">finished</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#progressRangeChanged">progressRangeChanged</a></b>(int <i>minimum</i>, int <i>maximum</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#progressTextChanged">progressTextChanged</a></b>(const QString &amp;<i>progressText</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#progressValueChanged">progressValueChanged</a></b>(int <i>progressValue</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#resultReadyAt">resultReadyAt</a></b>(int <i>index</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#resultsReadyAt">resultsReadyAt</a></b>(int <i>beginIndex</i>, int <i>endIndex</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#resumed">resumed</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#started">started</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#suspended">suspended</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher.html#suspending">suspending</a></b>()</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>QFutureWatcher provides information and notifications about a <a href="qfuture.html">QFuture</a>. Use the <a href="qfuturewatcher.html#setFuture">setFuture</a>() function to start watching a particular <a href="qfuture.html">QFuture</a>. The <a href="qfuturewatcher.html#future">future</a>() function returns the future set with <a href="qfuturewatcher.html#setFuture">setFuture</a>().</p> <p>For convenience, several of <a href="qfuture.html">QFuture</a>'s functions are also available in QFutureWatcher: <a href="qfuturewatcher.html#progressValue">progressValue</a>(), <a href="qfuturewatcher.html#progressMinimum">progressMinimum</a>(), <a href="qfuturewatcher.html#progressMaximum">progressMaximum</a>(), <a href="qfuturewatcher.html#progressText">progressText</a>(), <a href="qfuturewatcher.html#isStarted">isStarted</a>(), <a href="qfuturewatcher.html#isFinished">isFinished</a>(), <a href="qfuturewatcher.html#isRunning">isRunning</a>(), <a href="qfuturewatcher.html#isCanceled">isCanceled</a>(), <a href="qfuturewatcher.html#isSuspending">isSuspending</a>(), <a href="qfuturewatcher.html#isSuspended">isSuspended</a>(), <a href="qfuturewatcher.html#waitForFinished">waitForFinished</a>(), <a href="qfuturewatcher.html#result">result</a>(), and <a href="qfuturewatcher.html#resultAt">resultAt</a>(). The <a href="qfuturewatcher.html#cancel">cancel</a>(), <a href="qfuturewatcher.html#setSuspended">setSuspended</a>(), <a href="qfuturewatcher.html#suspend">suspend</a>(), <a href="qfuturewatcher.html#resume">resume</a>(), and <a href="qfuturewatcher.html#toggleSuspended">toggleSuspended</a>() functions are slots in QFutureWatcher.</p> <p>Status changes are reported via the <a href="qfuturewatcher.html#started">started</a>(), <a href="qfuturewatcher.html#finished">finished</a>(), <a href="qfuturewatcher.html#canceled">canceled</a>(), <a href="qfuturewatcher.html#suspending">suspending</a>(), <a href="qfuturewatcher.html#suspended">suspended</a>(), <a href="qfuturewatcher.html#resumed">resumed</a>(), <a href="qfuturewatcher.html#resultReadyAt">resultReadyAt</a>(), and <a href="qfuturewatcher.html#resultsReadyAt">resultsReadyAt</a>() signals. Progress information is provided from the <a href="qfuturewatcher.html#progressRangeChanged">progressRangeChanged</a>(), void <a href="qfuturewatcher.html#progressValueChanged">progressValueChanged</a>(), and <a href="qfuturewatcher.html#progressTextChanged">progressTextChanged</a>() signals.</p> <p>Throttling control is provided by the <a href="qfuturewatcher.html#setPendingResultsLimit">setPendingResultsLimit</a>() function. When the number of pending <a href="qfuturewatcher.html#resultReadyAt">resultReadyAt</a>() or <a href="qfuturewatcher.html#resultsReadyAt">resultsReadyAt</a>() signals exceeds the limit, the computation represented by the future will be throttled automatically. The computation will resume once the number of pending signals drops below the limit.</p> <p>Example: Starting a computation and getting a slot callback when it's finished:</p> <pre data-language="cpp">// Instantiate the objects and connect to the finished signal.
MyClass myObject;
QFutureWatcher&lt;int&gt; watcher;
connect(&amp;watcher, &amp;QFutureWatcher&lt;int&gt;::finished, &amp;myObject, &amp;MyClass::handleFinished);

// Start the computation.
QFuture&lt;int&gt; future = QtConcurrent::run(...);
watcher.setFuture(future);</pre> <p>Be aware that not all running asynchronous computations can be canceled or suspended. For example, the future returned by QtConcurrent::run() cannot be canceled; but the future returned by QtConcurrent::mappedReduced() can.</p> <p>QFutureWatcher&lt;void&gt; is specialized to not contain any of the result fetching functions. Any <a href="qfuture.html">QFuture</a>&lt;T&gt; can be watched by a QFutureWatcher&lt;void&gt; as well. This is useful if only status or progress information is needed; not the actual result data.</p>  <p><b>See also </b><a href="qfuture.html">QFuture</a> and <a href="qtconcurrent-index.html">Qt Concurrent</a>.</p>   <h2>Member Function Documentation</h2>  <h3 class="fn" id="QFutureWatcher">QFutureWatcher::<span class="name">QFutureWatcher</span>(<span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)
</h3> <p>Constructs a new QFutureWatcher with the given <i>parent</i>. Until a future is set with <a href="qfuturewatcher.html#setFuture">setFuture</a>(), the functions <a href="qfuturewatcher.html#isStarted">isStarted</a>(), <a href="qfuturewatcher.html#isCanceled">isCanceled</a>(), and <a href="qfuturewatcher.html#isFinished">isFinished</a>() return <code>true</code>.</p>   <h3 class="fn" id="cancel">
<code>[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">cancel</span>()
</h3> <p>Cancels the asynchronous computation represented by the <a href="qfuturewatcher.html#future">future</a>(). Note that the cancellation is asynchronous. Use <a href="qfuturewatcher.html#waitForFinished">waitForFinished</a>() after calling cancel() when you need synchronous cancellation.</p> <p>Currently available results may still be accessed on a canceled <a href="qfuture.html">QFuture</a>, but new results will <i>not</i> become available after calling this function. Also, this <a href="qfuturewatcher.html">QFutureWatcher</a> will not deliver progress and result ready signals once canceled. This includes the <a href="qfuturewatcher.html#progressValueChanged">progressValueChanged</a>(), <a href="qfuturewatcher.html#progressRangeChanged">progressRangeChanged</a>(), <a href="qfuturewatcher.html#progressTextChanged">progressTextChanged</a>(), <a href="qfuturewatcher.html#resultReadyAt">resultReadyAt</a>(), and <a href="qfuturewatcher.html#resultsReadyAt">resultsReadyAt</a>() signals.</p> <p>Be aware that not all running asynchronous computations can be canceled. For example, the <a href="qfuture.html">QFuture</a> returned by QtConcurrent::run() cannot be canceled; but the <a href="qfuture.html">QFuture</a> returned by QtConcurrent::mappedReduced() can.</p>   <h3 class="fn" id="canceled">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">canceled</span>()
</h3> <p>This signal is emitted if the watched future is canceled.</p>   <h3 class="fn" id="finished">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">finished</span>()
</h3> <p>This signal is emitted when the watched future finishes.</p>   <h3 class="fn" id="progressRangeChanged">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">progressRangeChanged</span>(<span class="type">int</span> <i>minimum</i>, <span class="type">int</span> <i>maximum</i>)
</h3> <p>The progress range for the watched future has changed to <i>minimum</i> and <i>maximum</i></p>   <h3 class="fn" id="progressTextChanged">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">progressTextChanged</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>progressText</i>)
</h3> <p>This signal is emitted when the watched future reports textual progress information, <i>progressText</i>.</p>   <h3 class="fn" id="progressValueChanged">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">progressValueChanged</span>(<span class="type">int</span> <i>progressValue</i>)
</h3> <p>This signal is emitted when the watched future reports progress, <i>progressValue</i> gives the current progress. In order to avoid overloading the GUI event loop, <a href="qfuturewatcher.html">QFutureWatcher</a> limits the progress signal emission rate. This means that listeners connected to this slot might not get all progress reports the future makes. The last progress update (where <i>progressValue</i> equals the maximum value) will always be delivered.</p>   <h3 class="fn" id="resultReadyAt">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">resultReadyAt</span>(<span class="type">int</span> <i>index</i>)
</h3> <p>This signal is emitted when the watched future reports a ready result at <i>index</i>. If the future reports multiple results, the index will indicate which one it is. Results can be reported out-of-order. To get the result, call <a href="qfuturewatcher.html#resultAt">resultAt</a>(index);</p>   <h3 class="fn" id="resultsReadyAt">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">resultsReadyAt</span>(<span class="type">int</span> <i>beginIndex</i>, <span class="type">int</span> <i>endIndex</i>)
</h3> <p>This signal is emitted when the watched future reports ready results. The results are indexed from <i>beginIndex</i> to <i>endIndex</i>.</p>   <h3 class="fn" id="resume">
<code>[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">resume</span>()
</h3> <p>Resumes the asynchronous computation represented by the <a href="qfuturewatcher.html#future">future</a>(). This is a convenience method that simply calls <a href="qfuturewatcher.html#setSuspended">setSuspended</a>(false).</p> <p><b>See also </b><a href="qfuturewatcher.html#suspend">suspend</a>().</p>   <h3 class="fn" id="resumed">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">resumed</span>()
</h3> <p>This signal is emitted when the watched future is resumed.</p>   <h3 class="fn" id="setSuspended">
<code>[slot, since 6.0] </code><span class="type">void</span> QFutureWatcher::<span class="name">setSuspended</span>(<span class="type">bool</span> <i>suspend</i>)
</h3> <p>If <i>suspend</i> is true, this function suspends the asynchronous computation represented by the <a href="qfuturewatcher.html#future">future</a>(). If the computation is already suspended, this function does nothing. <a href="qfuturewatcher.html">QFutureWatcher</a> will not immediately stop delivering progress and result ready signals when the future is suspended. At the moment of suspending there may still be computations that are in progress and cannot be stopped. Signals for such computations will still be delivered.</p> <p>If <i>suspend</i> is false, this function resumes the asynchronous computation. If the computation was not previously suspended, this function does nothing.</p> <p>Be aware that not all computations can be suspended. For example, the <a href="qfuture.html">QFuture</a> returned by QtConcurrent::run() cannot be suspended; but the <a href="qfuture.html">QFuture</a> returned by QtConcurrent::mappedReduced() can.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuturewatcher.html#suspended">suspended</a>(), <a href="qfuturewatcher.html#suspend">suspend</a>(), <a href="qfuturewatcher.html#resume">resume</a>(), and <a href="qfuturewatcher.html#toggleSuspended">toggleSuspended</a>().</p>   <h3 class="fn" id="started">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">started</span>()
</h3> <p>This signal is emitted when this <a href="qfuturewatcher.html">QFutureWatcher</a> starts watching the future set with <a href="qfuturewatcher.html#setFuture">setFuture</a>().</p>   <h3 class="fn" id="suspend">
<code>[slot, since 6.0] </code><span class="type">void</span> QFutureWatcher::<span class="name">suspend</span>()
</h3> <p>Suspends the asynchronous computation represented by this future. This is a convenience method that simply calls <a href="qfuturewatcher.html#setSuspended">setSuspended</a>(true).</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuturewatcher.html#resume">resume</a>().</p>   <h3 class="fn" id="suspended">
<code>[signal, since 6.0] </code><span class="type">void</span> QFutureWatcher::<span class="name">suspended</span>()
</h3> <p>This signal is emitted when <a href="qfuturewatcher.html#suspend">suspend</a>() took effect, meaning that there are no more running computations. After receiving this signal no more result ready or progress reporting signals are expected.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuturewatcher.html#setSuspended">setSuspended</a>(), <a href="qfuturewatcher.html#suspend">suspend</a>(), and suspended().</p>   <h3 class="fn" id="suspending">
<code>[signal, since 6.0] </code><span class="type">void</span> QFutureWatcher::<span class="name">suspending</span>()
</h3> <p>This signal is emitted when the state of the watched future is set to suspended.</p> <div class="admonition note"> <p><b>Note: </b>This signal only informs that suspension has been requested. It doesn't indicate that all background operations are stopped. Signals for computations that were in progress at the moment of suspending will still be delivered. To be informed when suspension actually took effect, use the <a href="qfuturewatcher.html#suspended">suspended</a>() signal.</p> </div> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuturewatcher.html#setSuspended">setSuspended</a>(), <a href="qfuturewatcher.html#suspend">suspend</a>(), and <a href="qfuturewatcher.html#suspended">suspended</a>().</p>   <h3 class="fn" id="toggleSuspended">
<code>[slot, since 6.0] </code><span class="type">void</span> QFutureWatcher::<span class="name">toggleSuspended</span>()
</h3> <p>Toggles the suspended state of the asynchronous computation. In other words, if the computation is currently suspending or suspended, calling this function resumes it; if the computation is running, it is suspended. This is a convenience method for calling <a href="qfuturewatcher.html#setSuspended">setSuspended</a>(!(<a href="qfuturewatcher.html#isSuspending">isSuspending</a>() || <a href="qfuturewatcher.html#isSuspended">isSuspended</a>())).</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuturewatcher.html#setSuspended">setSuspended</a>(), <a href="qfuturewatcher.html#suspend">suspend</a>(), and <a href="qfuturewatcher.html#resume">resume</a>().</p>   <h3 class="fn" id="dtor.QFutureWatcher">
<code>[virtual] </code>QFutureWatcher::<span class="name">~QFutureWatcher</span>()
</h3> <p>Destroys the <a href="qfuturewatcher.html">QFutureWatcher</a>.</p>   <h3 class="fn" id="future">
<span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFutureWatcher::<span class="name">future</span>() const
</h3> <p>Returns the watched future.</p> <p><b>See also </b><a href="qfuturewatcher.html#setFuture">setFuture</a>().</p>   <h3 class="fn" id="isCanceled">
<span class="type">bool</span> QFutureWatcher::<span class="name">isCanceled</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation has been canceled with the <a href="qfuturewatcher.html#cancel">cancel</a>() function, or if no future has been set; otherwise returns <code>false</code>.</p> <p>Be aware that the computation may still be running even though this function returns <code>true</code>. See <a href="qfuturewatcher.html#cancel">cancel</a>() for more details.</p>   <h3 class="fn" id="isFinished">
<span class="type">bool</span> QFutureWatcher::<span class="name">isFinished</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation represented by the <a href="qfuturewatcher.html#future">future</a>() has finished, or if no future has been set; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="isRunning">
<span class="type">bool</span> QFutureWatcher::<span class="name">isRunning</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation represented by the <a href="qfuturewatcher.html#future">future</a>() is currently running; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="isStarted">
<span class="type">bool</span> QFutureWatcher::<span class="name">isStarted</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation represented by the <a href="qfuturewatcher.html#future">future</a>() has been started, or if no future has been set; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="isSuspended">
<code>[since 6.0] </code><span class="type">bool</span> QFutureWatcher::<span class="name">isSuspended</span>() const
</h3> <p>Returns <code>true</code> if a suspension of the asynchronous computation has been requested, and it is in effect, meaning that no more results or progress changes are expected.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuturewatcher.html#suspended">suspended</a>(), <a href="qfuturewatcher.html#setSuspended">setSuspended</a>(), and <a href="qfuturewatcher.html#isSuspending">isSuspending</a>().</p>   <h3 class="fn" id="isSuspending">
<code>[since 6.0] </code><span class="type">bool</span> QFutureWatcher::<span class="name">isSuspending</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation has been suspended with the <a href="qfuturewatcher.html#suspend">suspend</a>() function, but the work is not yet suspended, and computation is still running. Returns <code>false</code> otherwise.</p> <p>To check if suspension is actually in effect, use <a href="qfuturewatcher.html#isSuspended">isSuspended</a>() instead.</p> <p>This function was introduced in Qt 6.0.</p> <p><b>See also </b><a href="qfuturewatcher.html#setSuspended">setSuspended</a>(), <a href="qfuturewatcher.html#toggleSuspended">toggleSuspended</a>(), and <a href="qfuturewatcher.html#isSuspended">isSuspended</a>().</p>   <h3 class="fn" id="progressMaximum">
<span class="type">int</span> QFutureWatcher::<span class="name">progressMaximum</span>() const
</h3> <p>Returns the maximum <a href="qfuturewatcher.html#progressValue">progressValue</a>().</p> <p><b>See also </b><a href="qfuturewatcher.html#progressValue">progressValue</a>() and <a href="qfuturewatcher.html#progressMinimum">progressMinimum</a>().</p>   <h3 class="fn" id="progressMinimum">
<span class="type">int</span> QFutureWatcher::<span class="name">progressMinimum</span>() const
</h3> <p>Returns the minimum <a href="qfuturewatcher.html#progressValue">progressValue</a>().</p> <p><b>See also </b><a href="qfuturewatcher.html#progressValue">progressValue</a>() and <a href="qfuturewatcher.html#progressMaximum">progressMaximum</a>().</p>   <h3 class="fn" id="progressText">
<span class="type"><a href="qstring.html">QString</a></span> QFutureWatcher::<span class="name">progressText</span>() const
</h3> <p>Returns the (optional) textual representation of the progress as reported by the asynchronous computation.</p> <p>Be aware that not all computations provide a textual representation of the progress, and as such, this function may return an empty string.</p>   <h3 class="fn" id="progressValue">
<span class="type">int</span> QFutureWatcher::<span class="name">progressValue</span>() const
</h3> <p>Returns the current progress value, which is between the <a href="qfuturewatcher.html#progressMinimum">progressMinimum</a>() and <a href="qfuturewatcher.html#progressMaximum">progressMaximum</a>().</p> <p><b>See also </b><a href="qfuturewatcher.html#progressMinimum">progressMinimum</a>() and <a href="qfuturewatcher.html#progressMaximum">progressMaximum</a>().</p>   <h3 class="fn" id="result">template &lt;typename U, typename&gt; <span class="type">T</span> QFutureWatcher::<span class="name">result</span>() const
</h3> <p>Returns the first result in the <a href="qfuturewatcher.html#future">future</a>(). If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <a href="qfuturewatcher.html#resultAt">resultAt</a>(0).</p> <p><b>See also </b><a href="qfuturewatcher.html#resultAt">resultAt</a>().</p>   <h3 class="fn" id="resultAt">template &lt;typename U, typename&gt; <span class="type">T</span> QFutureWatcher::<span class="name">resultAt</span>(<span class="type">int</span> <i>index</i>) const
</h3> <p>Returns the result at <i>index</i> in the <a href="qfuturewatcher.html#future">future</a>(). If the result is not immediately available, this function will block and wait for the result to become available.</p> <p><b>See also </b><a href="qfuturewatcher.html#result">result</a>().</p>   <h3 class="fn" id="setFuture">
<span class="type">void</span> QFutureWatcher::<span class="name">setFuture</span>(const <span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>future</i>)
</h3> <p>Starts watching the given <i>future</i>.</p> <p>One of the signals might be emitted for the current state of the <i>future</i>. For example, if the future is already stopped, the finished signal will be emitted.</p> <p>To avoid a race condition, it is important to call this function <i>after</i> doing the connections.</p> <p><b>See also </b><a href="qfuturewatcher.html#future">future</a>().</p>   <h3 class="fn" id="setPendingResultsLimit">
<span class="type">void</span> QFutureWatcher::<span class="name">setPendingResultsLimit</span>(<span class="type">int</span> <i>limit</i>)
</h3> <p>The setPendingResultsLimit() provides throttling control. When the number of pending <a href="qfuturewatcher.html#resultReadyAt">resultReadyAt</a>() or <a href="qfuturewatcher.html#resultsReadyAt">resultsReadyAt</a>() signals exceeds the <i>limit</i>, the computation represented by the future will be throttled automatically. The computation will resume once the number of pending signals drops below the <i>limit</i>.</p>   <h3 class="fn" id="waitForFinished">
<span class="type">void</span> QFutureWatcher::<span class="name">waitForFinished</span>()
</h3> <p>Waits for the asynchronous computation to finish (including <a href="qfuturewatcher.html#cancel">cancel</a>()ed computations), i.e. until <a href="qfuturewatcher.html#isFinished">isFinished</a>() returns <code>true</code>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qfuturewatcher.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qfuturewatcher.html</a>
  </p>
</div>
