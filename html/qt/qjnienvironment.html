<h1 class="title">QJniEnvironment Class</h1>  <p>The QJniEnvironment class provides access to the JNI Environment (JNIEnv). <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QJniEnvironment&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 6.1</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qjnienvironment-members.html">List of all members, including inherited members</a></li> <li><a href="https://doc.qt.io/qt-6.2/qjnienvironment-obsolete.html">Deprecated members</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum class </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#OutputMode-enum">OutputMode</a></b> { Silent, Verbose }</td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#QJniEnvironment">QJniEnvironment</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#dtor.QJniEnvironment">~QJniEnvironment</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#checkAndClearExceptions">checkAndClearExceptions</a></b>(QJniEnvironment::OutputMode <i>outputMode</i> = OutputMode::Verbose)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> jclass </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#findClass">findClass</a></b>(const char *<i>className</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> jfieldID </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#findField">findField</a></b>(jclass <i>clazz</i>, const char *<i>fieldName</i>, const char *<i>signature</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> jmethodID </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#findMethod">findMethod</a></b>(jclass <i>clazz</i>, const char *<i>methodName</i>, const char *<i>signature</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> jfieldID </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#findStaticField">findStaticField</a></b>(jclass <i>clazz</i>, const char *<i>fieldName</i>, const char *<i>signature</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> jmethodID </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#findStaticMethod">findStaticMethod</a></b>(jclass <i>clazz</i>, const char *<i>methodName</i>, const char *<i>signature</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#isValid">isValid</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> JNIEnv *</td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#jniEnv">jniEnv</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#registerNativeMethods">registerNativeMethods</a></b>(const char *<i>className</i>, const JNINativeMethod [] <i>methods</i>, int <i>size</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#registerNativeMethods-1">registerNativeMethods</a></b>(jclass <i>clazz</i>, const JNINativeMethod [] <i>methods</i>, int <i>size</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> JNIEnv &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#operator-2a">operator*</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> JNIEnv *</td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#operator--gt">operator-&gt;</a></b>() const</td>
</tr> </table> <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#checkAndClearExceptions-1">checkAndClearExceptions</a></b>(JNIEnv *<i>env</i>, QJniEnvironment::OutputMode <i>outputMode</i> = OutputMode::Verbose)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> JavaVM *</td>
<td class="memItemRight bottomAlign">
<b><a href="qjnienvironment.html#javaVM">javaVM</a></b>()</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>When using JNI, the <a href="https://developer.android.com/training/articles/perf-jni#javavm-and-jnienv">JNIEnv</a> class is a pointer to a function table and a member function for each JNI function that indirects through the table. <code>JNIEnv</code> provides most of the JNI functions. Every C++ native function receives a <code>JNIEnv</code> as the first argument. The JNI environment cannot be shared between threads.</p> <p>Since <code>JNIEnv</code> doesn't do much error checking, such as exception checking and clearing, QJniEnvironment allows you to do that easily.</p> <p>For more information about JNIEnv, see <a href="https://docs.oracle.com/en/java/javase/13/docs/specs/jni/functions.html#interface-function-table">Java: Interface Function Table</a>.</p> <div class="admonition note"> <p><b>Note: </b>This API has been designed and tested for use with Android. It has not been tested for other platforms.</p> </div>    <h2>Member Type Documentation</h2>  <h3 class="fn" id="OutputMode-enum">enum class QJniEnvironment::<span class="name">OutputMode</span>
</h3> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QJniEnvironment::OutputMode::Silent</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The exceptions are cleaned silently</td>
</tr> <tr>
<td class="topAlign"><code>QJniEnvironment::OutputMode::Verbose</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">Prints the exceptions and their stack backtrace as an error to <code>stderr</code> stream.</td>
</tr> </table>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QJniEnvironment">QJniEnvironment::<span class="name">QJniEnvironment</span>()
</h3> <p>Constructs a new JNI Environment object and attaches the current thread to the Java VM.</p>   <h3 class="fn" id="dtor.QJniEnvironment">QJniEnvironment::<span class="name">~QJniEnvironment</span>()
</h3> <p>Detaches the current thread from the Java VM and destroys the <a href="qjnienvironment.html">QJniEnvironment</a> object. This will clear any pending exception by calling <a href="qjnienvironment.html#checkAndClearExceptions">checkAndClearExceptions</a>().</p>   <h3 class="fn" id="checkAndClearExceptions">
<span class="type">bool</span> QJniEnvironment::<span class="name">checkAndClearExceptions</span>(<span class="type"><a href="qjnienvironment.html#OutputMode-enum">QJniEnvironment::OutputMode</a></span> <i>outputMode</i> = OutputMode::Verbose)
</h3> <p>Cleans any pending exceptions either silently or reporting stack backtrace, depending on the <i>outputMode</i>.</p> <p>In contrast to <a href="qjniobject.html">QJniObject</a>, which handles exceptions internally, if you make JNI calls directly via <code>JNIEnv</code>, you need to clear any potential exceptions after the call using this function. For more information about <code>JNIEnv</code> calls that can throw an exception, see <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html">JNI Functions</a>.</p> <p>Returns <code>true</code> when a pending exception was cleared.</p>   <h3 class="fn" id="checkAndClearExceptions-1">
<code>[static] </code><span class="type">bool</span> QJniEnvironment::<span class="name">checkAndClearExceptions</span>(<span class="type">JNIEnv</span> *<i>env</i>, <span class="type"><a href="qjnienvironment.html#OutputMode-enum">QJniEnvironment::OutputMode</a></span> <i>outputMode</i> = OutputMode::Verbose)
</h3> <p>Cleans any pending exceptions for <i>env</i>, either silently or reporting stack backtrace, depending on the <i>outputMode</i>. This is useful when you already have a <code>JNIEnv</code> pointer such as in a native function implementation.</p> <p>In contrast to <a href="qjniobject.html">QJniObject</a>, which handles exceptions internally, if you make JNI calls directly via <code>JNIEnv</code>, you need to clear any potential exceptions after the call using this function. For more information about <code>JNIEnv</code> calls that can throw an exception, see <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html">JNI Functions</a>.</p> <p>Returns <code>true</code> when a pending exception was cleared.</p>   <h3 class="fn" id="findClass">
<span class="type">jclass</span> QJniEnvironment::<span class="name">findClass</span>(const <span class="type">char</span> *<i>className</i>)
</h3> <p>Searches for <i>className</i> using all available class loaders. Qt on Android uses a custom class loader to load all the .jar files and it must be used to find any classes that are created by that class loader because these classes are not visible when using the default class loader.</p> <p>Returns the class pointer or null if <i>className</i> is not found.</p> <p>A use case for this function is searching for a class to call a JNI method that takes a <code>jclass</code>. This can be useful when doing multiple JNI calls on the same class object which can a bit faster than using a class name in each call. Additionally, this call looks for internally cached classes first before doing a JNI call, and returns such a class if found. The following code snippet creates an instance of the class <code>CustomClass</code> and then calls the <code>printFromJava()</code> method:</p> <pre data-language="cpp">QJniEnvironment env;
jclass javaClass = env.findClass("org/qtproject/example/android/CustomClass");
QJniObject javaMessage = QJniObject::fromString("findClass example");
QJniObject::callStaticMethod&lt;void&gt;(javaClass, "printFromJava",
                                   "(Ljava/lang/String;)V", javaMessage.object&lt;jstring&gt;());</pre> <div class="admonition note"> <p><b>Note: </b>This call returns a global reference to the class object from the internally cached classes.</p> </div>   <h3 class="fn" id="findField">
<code>[since 6.2] </code><span class="type">jfieldID</span> QJniEnvironment::<span class="name">findField</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>fieldName</i>, const <span class="type">char</span> *<i>signature</i>)
</h3> <p>Searches for an member field of a class <i>clazz</i>. The field is specified by its <i>fieldName</i> and <i>signature</i>.</p> <p>Returns the field ID or <code>nullptr</code> if the field is not found.</p> <p>A usecase for this method is searching for class fields and caching their IDs, so that they could later be used for getting/setting the fields.</p> <p>This function was introduced in Qt 6.2.</p>   <h3 class="fn" id="findMethod">
<code>[since 6.2] </code><span class="type">jmethodID</span> QJniEnvironment::<span class="name">findMethod</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>methodName</i>, const <span class="type">char</span> *<i>signature</i>)
</h3> <p>Searches for an instance method of a class <i>clazz</i>. The method is specified by its <i>methodName</i> and <i>signature</i>.</p> <p>Returns the method ID or <code>nullptr</code> if the method is not found.</p> <p>A usecase for this method is searching for class methods and caching their IDs, so that they could later be used for calling the methods.</p> <p>This function was introduced in Qt 6.2.</p>   <h3 class="fn" id="findStaticField">
<code>[since 6.2] </code><span class="type">jfieldID</span> QJniEnvironment::<span class="name">findStaticField</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>fieldName</i>, const <span class="type">char</span> *<i>signature</i>)
</h3> <p>Searches for a static field of a class <i>clazz</i>. The field is specified by its <i>fieldName</i> and <i>signature</i>.</p> <p>Returns the field ID or <code>nullptr</code> if the field is not found.</p> <p>A usecase for this method is searching for class fields and caching their IDs, so that they could later be used for getting/setting the fields.</p> <p>This function was introduced in Qt 6.2.</p>   <h3 class="fn" id="findStaticMethod">
<code>[since 6.2] </code><span class="type">jmethodID</span> QJniEnvironment::<span class="name">findStaticMethod</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">char</span> *<i>methodName</i>, const <span class="type">char</span> *<i>signature</i>)
</h3> <p>Searches for a static method of a class <i>clazz</i>. The method is specified by its <i>methodName</i> and <i>signature</i>.</p> <p>Returns the method ID or <code>nullptr</code> if the method is not found.</p> <p>A usecase for this method is searching for class methods and caching their IDs, so that they could later be used for calling the methods.</p> <pre data-language="cpp">QJniEnvironment env;
jclass javaClass = env.findClass("org/qtproject/example/android/CustomClass");
jmethodID methodId = env.findStaticMethod(javaClass,
                                          "staticJavaMethod",
                                          "(Ljava/lang/String;)V");
QJniObject javaMessage = QJniObject::fromString("findStaticMethod example");
QJniObject::callStaticMethod&lt;void&gt;(javaClass,
                                   methodId,
                                   javaMessage.object&lt;jstring&gt;());</pre> <p>This function was introduced in Qt 6.2.</p>   <h3 class="fn" id="isValid">
<code>[since 6.2] </code><span class="type">bool</span> QJniEnvironment::<span class="name">isValid</span>() const
</h3> <p>Returns <code>true</code> if this instance holds a valid JNIEnv object.</p> <p>This function was introduced in Qt 6.2.</p>   <h3 class="fn" id="javaVM">
<code>[static] </code><span class="type">JavaVM</span> *QJniEnvironment::<span class="name">javaVM</span>()
</h3> <p>Returns the Java VM interface for the current process. Although it might be possible to have multiple Java VMs per process, Android allows only one.</p>   <h3 class="fn" id="jniEnv">
<span class="type">JNIEnv</span> *QJniEnvironment::<span class="name">jniEnv</span>() const
</h3> <p>Returns the JNI Environment's <code>JNIEnv</code> pointer.</p>   <h3 class="fn" id="registerNativeMethods">
<span class="type">bool</span> QJniEnvironment::<span class="name">registerNativeMethods</span>(const <span class="type">char</span> *<i>className</i>, const <span class="type">JNINativeMethod</span> [] <i>methods</i>, <span class="type">int</span> <i>size</i>)
</h3> <p>Registers the Java methods in the array <i>methods</i> of size <i>size</i>, each of which can call native C++ functions from class <i>className</i>. These methods must be registered before any attempt to call them.</p> <p>Returns <code>true</code> if the registration is successful, otherwise <code>false</code>.</p> <p>Each element in the methods array consists of:</p> <ul> <li>The Java method name</li> <li>Method signature</li> <li>The C++ functions that will be executed</li> </ul> <pre data-language="cpp">const JNINativeMethod methods[] =
                        {{"callNativeOne", "(I)V", reinterpret_cast&lt;void *&gt;(fromJavaOne)},
                        {"callNativeTwo", "(I)V", reinterpret_cast&lt;void *&gt;(fromJavaTwo)}};
QJniEnvironment env;
env.registerNativeMethods("org/qtproject/android/TestJavaClass", methods, 2);</pre>   <h3 class="fn" id="registerNativeMethods-1">
<span class="type">bool</span> QJniEnvironment::<span class="name">registerNativeMethods</span>(<span class="type">jclass</span> <i>clazz</i>, const <span class="type">JNINativeMethod</span> [] <i>methods</i>, <span class="type">int</span> <i>size</i>)
</h3> <p>This is an overloaded function.</p> <p>This overload uses a previously cached jclass instance <i>clazz</i>.</p> <pre data-language="cpp">JNINativeMethod methods[] {{"callNativeOne", "(I)V", reinterpret_cast&lt;void *&gt;(fromJavaOne)},
                           {"callNativeTwo", "(I)V", reinterpret_cast&lt;void *&gt;(fromJavaTwo)}};
QJniEnvironment env;
jclass clazz = env.findClass("org/qtproject/android/TestJavaClass");
env.registerNativeMethods(clazz, methods, 2);</pre>   <h3 class="fn" id="operator-2a">
<span class="type">JNIEnv</span> &amp;QJniEnvironment::<span class="name">operator*</span>() const
</h3> <p>Returns the JNI Environment's <code>JNIEnv</code> object.</p>   <h3 class="fn" id="operator--gt">
<span class="type">JNIEnv</span> *QJniEnvironment::<span class="name">operator-&gt;</span>() const
</h3> <p>Provides access to the JNI Environment's <code>JNIEnv</code> pointer.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qjnienvironment.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qjnienvironment.html</a>
  </p>
</div>
