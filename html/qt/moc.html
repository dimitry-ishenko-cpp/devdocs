<h1 class="title">Using the Meta-Object Compiler (moc)</h1>   <p>The Meta-Object Compiler, <code>moc</code>, is the program that handles <a href="metaobjects.html">Qt's C++ extensions</a>.</p> <p>The <code>moc</code> tool reads a C++ header file. If it finds one or more class declarations that contain the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro, it produces a C++ source file containing the meta-object code for those classes. Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system.</p> <p>The C++ source file generated by <code>moc</code> must be compiled and linked with the implementation of the class.</p> <p>If you use <a href="https://doc.qt.io/qt-6.2/qtquick-deployment.html#qmake">qmake</a> to create your makefiles, build rules will be included that call the moc when required, so you will not need to use the moc directly. For more background information on <code>moc</code>, see <a href="why-moc.html">Why Does Qt Use Moc for Signals and Slots?</a></p> <h2 id="usage">Usage
</h2> <p><code>moc</code> is typically used with an input file containing class declarations like this:</p> <pre data-language="cpp">class MyClass : public QObject
{
    Q_OBJECT

public:
    MyClass(QObject *parent = 0);
    ~MyClass();

signals:
    void mySignal();

public slots:
    void mySlot();
};</pre> <p>In addition to the signals and slots shown above, <code>moc</code> also implements object properties as in the next example. The <a href="qobject.html#Q_PROPERTY">Q_PROPERTY</a>() macro declares an object property, while <a href="qobject.html#Q_ENUM">Q_ENUM</a>() declares a list of enumeration types within the class to be usable inside the <a href="properties.html">property system</a>.</p> <p>In the following example, we declare a property of the enumeration type <code>Priority</code> that is also called <code>priority</code> and has a get function <code>priority()</code> and a set function <code>setPriority()</code>.</p> <pre data-language="cpp">class MyClass : public QObject
{
    Q_OBJECT
    Q_PROPERTY(Priority priority READ priority WRITE setPriority)
    Q_ENUMS(Priority)

public:
    enum Priority { High, Low, VeryHigh, VeryLow };

    MyClass(QObject *parent = 0);
    ~MyClass();

    void setPriority(Priority priority) { m_priority = priority; }
    Priority priority() const { return m_priority; }

private:
    Priority m_priority;
};</pre> <p>The Q_FLAGS() macro declares enums that are to be used as flags, i.e. OR'd together. Another macro, <a href="qobject.html#Q_CLASSINFO">Q_CLASSINFO</a>(), allows you to attach additional name/value pairs to the class's meta-object:</p> <pre data-language="cpp">class MyClass : public QObject
{
    Q_OBJECT
    Q_CLASSINFO("Author", "Oscar Peterson")
    Q_CLASSINFO("Status", "Active")

public:
    MyClass(QObject *parent = 0);
    ~MyClass();
};</pre> <p>The output produced by <code>moc</code> must be compiled and linked, just like the other C++ code in your program; otherwise, the build will fail in the final link phase. If you use <code>qmake</code>, this is done automatically. Whenever <code>qmake</code> is run, it parses the project's header files and generates make rules to invoke <code>moc</code> for those files that contain a <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro.</p> <p>If the class declaration is found in the file <code>myclass.h</code>, the moc output should be put in a file called <code>moc_myclass.cpp</code>. This file should then be compiled as usual, resulting in an object file, e.g., <code>moc_myclass.obj</code> on Windows. This object should then be included in the list of object files that are linked together in the final building phase of the program.</p> <h2 id="writing-make-rules-for-invoking-moc">Writing Make Rules for Invoking <code>moc</code>
</h2> <p>For anything but the simplest test programs, it is recommended that you automate running the <code>moc</code>. By adding some rules to your program's makefile, <code>make</code> can take care of running moc when necessary and handling the moc output.</p> <p>We recommend using the <a href="https://doc.qt.io/qt-6.2/qtquick-deployment.html#qmake">qmake</a> makefile generation tool for building your makefiles. This tool generates a makefile that does all the necessary <code>moc</code> handling.</p> <p>If you want to create your makefiles yourself, here are some tips on how to include moc handling.</p> <p>For <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> class declarations in header files, here is a useful makefile rule if you only use GNU make:</p> <pre data-language="cpp">moc_%.cpp: %.h
        moc $(DEFINES) $(INCPATH) $&lt; -o $@</pre> <p>If you want to write portably, you can use individual rules of the following form:</p> <pre data-language="cpp">moc_foo.cpp: foo.h
        moc $(DEFINES) $(INCPATH) $&lt; -o $@</pre> <p>You must also remember to add <code>moc_foo.cpp</code> to your <code>SOURCES</code> (substitute your favorite name) variable and <code>moc_foo.o</code> or <code>moc_foo.obj</code> to your <code>OBJECTS</code> variable.</p> <p>Both examples assume that <code>$(DEFINES)</code> and <code>$(INCPATH)</code> expand to the define and include path options that are passed to the C++ compiler. These are required by <code>moc</code> to preprocess the source files.</p> <p>While we prefer to name our C++ source files <code>.cpp</code>, you can use any other extension, such as <code>.C</code>, <code>.cc</code>, <code>.CC</code>, <code>.cxx</code>, and <code>.c++</code>, if you prefer.</p> <p>For <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> class declarations in implementation (<code>.cpp</code>) files, we suggest a makefile rule like this:</p> <pre data-language="cpp">foo.o: foo.moc

foo.moc: foo.cpp
        moc $(DEFINES) $(INCPATH) -i $&lt; -o $@</pre> <p>This guarantees that make will run the moc before it compiles <code>foo.cpp</code>. You can then put</p> <pre data-language="cpp">#include "foo.moc"</pre> <p>at the end of <code>foo.cpp</code>, where all the classes declared in that file are fully known.</p> <h2 id="command-line-options">Command-Line Options
</h2> <p>Here are the command-line options supported by the moc:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Option</th>
<th>Description</th>
</tr></thead> <tr class="odd" valign="top">
<td><code>-o&lt;file&gt;</code></td>
<td>Write output to <code>&lt;file&gt;</code> rather than to standard output.</td>
</tr> <tr class="even" valign="top">
<td><code>-f[&lt;file&gt;]</code></td>
<td>Force the generation of an <code>#include</code> statement in the output. This is the default for header files whose extension starts with <code>H</code> or <code>h</code>. This option is useful if you have header files that do not follow the standard naming conventions. The <code>&lt;file&gt;</code> part is optional.</td>
</tr> <tr class="odd" valign="top">
<td><code>-i</code></td>
<td>Do not generate an <code>#include</code> statement in the output. This may be used to run the moc on on a C++ file containing one or more class declarations. You should then <code>#include</code> the meta-object code in the <code>.cpp</code> file.</td>
</tr> <tr class="even" valign="top">
<td><code>-nw</code></td>
<td>Do not generate any warnings. (Not recommended.)</td>
</tr> <tr class="odd" valign="top">
<td><code>-p&lt;path&gt;</code></td>
<td>Makes the moc prepend <code>&lt;path&gt;/</code> to the file name in the generated <code>#include</code> statement.</td>
</tr> <tr class="even" valign="top">
<td><code>-I&lt;dir&gt;</code></td>
<td>Add dir to the include path for header files.</td>
</tr> <tr class="odd" valign="top">
<td><code>-E</code></td>
<td>Preprocess only; do not generate meta-object code.</td>
</tr> <tr class="even" valign="top">
<td><code>-D&lt;macro&gt;[=&lt;def&gt;]</code></td>
<td>Define macro, with optional definition.</td>
</tr> <tr class="odd" valign="top">
<td><code>-U&lt;macro&gt;</code></td>
<td>Undefine macro.</td>
</tr> <tr class="even" valign="top">
<td><code>-M&lt;key=value&gt;</code></td>
<td>Append additional meta data to plugins. If a class has <a href="qtplugin.html#Q_PLUGIN_METADATA">Q_PLUGIN_METADATA</a> specified, the key-value pair will be added to its meta data. This will end up in the Json object that gets resolved for the plugin at run time (accessible from <a href="qpluginloader.html">QPluginLoader</a>). This argument is typically used for tagging static plugins with information resolved by the build system.</td>
</tr> <tr class="odd" valign="top">
<td><code>@&lt;file&gt;</code></td>
<td>Read additional command-line options from <code>&lt;file&gt;</code>. Each line of the file is treated as a single option. Empty lines are ignored. Note that this option is not supported within the options file itself (i.e. an options file can't "include" another file).</td>
</tr> <tr class="even" valign="top">
<td><code>-h</code></td>
<td>Display the usage and the list of options.</td>
</tr> <tr class="odd" valign="top">
<td><code>-v</code></td>
<td>Display <code>moc</code>'s version number.</td>
</tr> <tr class="even" valign="top">
<td><code>-Fdir</code></td>
<td>macOS. Add the framework directory <code>dir</code> to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by -I options and are scanned in a left-to-right order (see the manpage for gcc). Normally, use -F /Library/Frameworks/</td>
</tr> </table> <p>You can explicitly tell the moc not to parse parts of a header file. <code>moc</code> defines the preprocessor symbol <code>Q_MOC_RUN</code>. Any code surrounded by</p> <pre data-language="cpp">#ifndef Q_MOC_RUN
    ...
#endif</pre> <p>is skipped by the <code>moc</code>.</p> <h2 id="diagnostics">Diagnostics
</h2> <p><code>moc</code> will warn you about a number of dangerous or illegal constructs in the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> class declarations.</p> <p>If you get linkage errors in the final building phase of your program, saying that <code>YourClass::className()</code> is undefined or that <code>YourClass</code> lacks a vtable, something has been done wrong. Most often, you have forgotten to compile or <code>#include</code> the moc-generated C++ code, or (in the former case) include that object file in the link command. If you use <code>qmake</code>, try rerunning it to update your makefile. This should do the trick.</p> <h2 id="build-systems">Build Systems
</h2> <h3 id="including-header-moc-files">Including header moc files
</h3> <p>qmake and CMake behave differently with regards to including header moc files.</p> <p>To illustrate this with an example, suppose that you have two headers with corresponding source files: <code>a.h</code>, <code>a.cpp</code>, <code>b.h</code>, and <code>b.cpp</code>. Each header has a <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro:</p> <pre data-language="cpp">// a.h
class A : public QObject
{
    Q_OBJECT

    public:
        // ...
};</pre> <pre data-language="cpp">// a.cpp
#include "a.h"

// ...

#include "moc_a.cpp"</pre> <pre data-language="cpp">// b.h
class B : public QObject
{
    Q_OBJECT

    public:
        // ...
};</pre> <pre data-language="cpp">// b.cpp
#include "b.h"

// ...

#include "moc_b.cpp"</pre> <p>With qmake, if you don't include the moc-generated file (<code>moc_a.cpp</code>/<code>moc_b.cpp</code>), <code>a.cpp</code>, <code>b.cpp</code>, <code>moc_a.cpp</code>, and <code>moc_b.cpp</code> will be compiled separately. This can result in slower builds. If you include the moc generated files, only a.cpp and b.cpp will need to be compiled, as the moc generated code is included in those files.</p> <p>With CMake, if you don't include the files, an single additional file is generated by moc (let's call it <code>cmake.cpp</code> for the sake of the example). <code>cmake.cpp</code> would include both <code>moc_a.cpp</code> and <code>moc_b.cpp</code>. Including the moc-generated file is still allowed with CMake, but it's not necessary.</p> <p>For more information on CMake's moc support regarding this topic, see <a href="https://cmake.org/cmake/help/latest/prop_tgt/AUTOMOC.html#including-header-moc-files-in-sources">Including header moc files in sources</a>.</p> <h2 id="limitations">Limitations
</h2> <p><code>moc</code> does not handle all of C++. The main problem is that class templates cannot have the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro. Here is an example:</p> <pre data-language="cpp">class SomeTemplate&lt;int&gt; : public QFrame
{
    Q_OBJECT
    ...

signals:
    void mySignal(int);
};</pre> <p>The following constructs are illegal. All of them have alternatives which we think are usually better, so removing these limitations is not a high priority for us.</p> <h3 id="multiple-inheritance-requires-qobject-to-be-first">Multiple Inheritance Requires QObject to Be First
</h3> <p>If you are using multiple inheritance, <code>moc</code> assumes that the first inherited class is a subclass of <a href="qobject.html">QObject</a>. Also, be sure that only the first inherited class is a <a href="qobject.html">QObject</a>.</p> <pre data-language="cpp">// correct
class SomeClass : public QObject, public OtherClass
{
    ...
};</pre> <p>Virtual inheritance with <a href="qobject.html">QObject</a> is <i>not</i> supported.</p> <h3 id="function-pointers-cannot-be-signal-or-slot-parameters">Function Pointers Cannot Be Signal or Slot Parameters
</h3> <p>In most cases where you would consider using function pointers as signal or slot parameters, we think inheritance is a better alternative. Here is an example of illegal syntax:</p> <pre data-language="cpp">class SomeClass : public QObject
{
    Q_OBJECT

public slots:
    void apply(void (*apply)(List *, void *), char *); // WRONG
};</pre> <p>You can work around this restriction like this:</p> <pre data-language="cpp">typedef void (*ApplyFunction)(List *, void *);

class SomeClass : public QObject
{
    Q_OBJECT

public slots:
    void apply(ApplyFunction, char *);
};</pre> <p>It may sometimes be even better to replace the function pointer with inheritance and virtual functions.</p> <h3 id="enums-and-typedefs-must-be-fully-qualified-for-signal-and-slot-parameters">Enums and Typedefs Must Be Fully Qualified for Signal and Slot Parameters
</h3> <p>When checking the signatures of its arguments, <a href="qobject.html#connect">QObject::connect</a>() compares the data types literally. Thus, <a href="qt.html#AlignmentFlag-enum">Alignment</a> and <a href="qt.html#AlignmentFlag-enum">Qt::Alignment</a> are treated as two distinct types. To work around this limitation, make sure to fully qualify the data types when declaring signals and slots, and when establishing connections. For example:</p> <pre data-language="cpp">class MyClass : public QObject
{
    Q_OBJECT

    enum Error {
        ConnectionRefused,
        RemoteHostClosed,
        UnknownError
    };

signals:
    void stateChanged(MyClass::Error error);
};</pre> <h3 id="nested-classes-cannot-have-signals-or-slots">Nested Classes Cannot Have Signals or Slots
</h3> <p>Here's an example of the offending construct:</p> <pre data-language="cpp">class A
{
public:
    class B
    {
        Q_OBJECT

    public slots:   // WRONG
        void b();
    };
};</pre> <h3 id="signal-slot-return-types-cannot-be-references">Signal/Slot return types cannot be references
</h3> <p>Signals and slots can have return types, but signals or slots returning references will be treated as returning void.</p> <h3 id="only-signals-and-slots-may-appear-in-the-keyword-signals-keyword-and-keyword-slots-keyword-sections-of-a-class">Only Signals and Slots May Appear in the <code>signals</code> and <code>slots</code> Sections of a Class
</h3> <p><code>moc</code> will complain if you try to put other constructs in the <code>signals</code> or <code>slots</code> sections of a class than signals and slots.</p>  <p><b>See also </b><a href="metaobjects.html">Meta-Object System</a>, <a href="https://doc.qt.io/qt-6.2/exceptionsafety.html#signals-and-slots">Signals and Slots</a>, and <a href="properties.html">Qt's Property System</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/moc.html" class="_attribution-link">https://doc.qt.io/qt-6.2/moc.html</a>
  </p>
</div>
