<h1 class="title">QVulkanDeviceFunctions Class</h1>  <p>The QVulkanDeviceFunctions class provides cross-platform access to the device level core Vulkan 1.2 API. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QVulkanDeviceFunctions&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Gui REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Gui)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += gui</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.10</td>
</tr>
</table>   <h2 id="details">Detailed Description
</h2> <p>Qt and Qt applications do not link to any Vulkan libraries by default. Instead, all functions are resolved dynamically at run time. Each <a href="qvulkaninstance.html">QVulkanInstance</a> provides a <a href="qvulkanfunctions.html">QVulkanFunctions</a> object retrievable via <a href="qvulkaninstance.html#functions">QVulkanInstance::functions</a>(). This does not contain device level functions in order to avoid the potential overhead of an internal dispatching. Instead, functions that rely on a device, or a dispatchable child object of a device, are exposed via QVulkanDeviceFunctions and <a href="qvulkaninstance.html#deviceFunctions">QVulkanInstance::deviceFunctions</a>(). <a href="qvulkanfunctions.html">QVulkanFunctions</a> and QVulkanDeviceFunctions together provides access to the full core Vulkan API, excluding any extensions.</p> <div class="admonition note"> <p><b>Note: </b>QVulkanDeviceFunctions instances cannot be constructed directly.</p> </div> <p>The typical usage is the following:</p> <pre data-language="cpp">void Window::render()
{
    QVulkanInstance *inst = vulkanInstance();
    QVulkanDeviceFunctions *df = inst-&gt;deviceFunctions(device);
    VkResult err = df-&gt;vkAllocateCommandBuffers(device, &amp;cmdBufInfo, &amp;cmdBuf);
    // ...
}</pre> <p>The QVulkanDeviceFunctions object specific to the provided VkDevice is created when <a href="qvulkaninstance.html#deviceFunctions">QVulkanInstance::deviceFunctions</a>() is first called with the device in question. The object is then cached internally.</p> <p>To access additional functions, applications can use <a href="qvulkaninstance.html#getInstanceProcAddr">QVulkanInstance::getInstanceProcAddr</a>() and vkGetDeviceProcAddr(). Applications can also decide to link to a Vulkan library directly, as many implementations export function symbols for the core commands. See <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html">the man page for vkGetInstanceProcAddr</a> for more information.</p>  <p><b>See also </b><a href="qvulkaninstance.html">QVulkanInstance</a>, <a href="qvulkanfunctions.html">QVulkanFunctions</a>, <a href="qwindow.html#setVulkanInstance">QWindow::setVulkanInstance</a>(), and <a href="qwindow.html#setSurfaceType">QWindow::setSurfaceType</a>().</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qvulkandevicefunctions.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qvulkandevicefunctions.html</a>
  </p>
</div>
