<h1 class="title">QDtls Class</h1>  <p>This class provides encryption for UDP sockets. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QDtls&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Network REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Network)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += network</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.12</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qobject.html">QObject</a>
</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qdtls-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qdtls.html#GeneratorParameters-typedef">GeneratorParameters</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#HandshakeState-enum">HandshakeState</a></b> { HandshakeNotStarted, HandshakeInProgress, PeerVerificationFailed, HandshakeComplete }</td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#QDtls">QDtls</a></b>(QSslSocket::SslMode <i>mode</i>, QObject *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#dtor.QDtls">~QDtls</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#abortHandshake">abortHandshake</a></b>(QUdpSocket *<i>socket</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDtls::GeneratorParameters </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#cookieGeneratorParameters">cookieGeneratorParameters</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArray </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#decryptDatagram">decryptDatagram</a></b>(QUdpSocket *<i>socket</i>, const QByteArray &amp;<i>dgram</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#doHandshake">doHandshake</a></b>(QUdpSocket *<i>socket</i>, const QByteArray &amp;<i>dgram</i> = {})</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSslConfiguration </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#dtlsConfiguration">dtlsConfiguration</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDtlsError </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#dtlsError">dtlsError</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#dtlsErrorString">dtlsErrorString</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#handleTimeout">handleTimeout</a></b>(QUdpSocket *<i>socket</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDtls::HandshakeState </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#handshakeState">handshakeState</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#ignoreVerificationErrors">ignoreVerificationErrors</a></b>(const QList&lt;QSslError&gt; &amp;<i>errorsToIgnore</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#isConnectionEncrypted">isConnectionEncrypted</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> quint16 </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#mtuHint">mtuHint</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QHostAddress </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#peerAddress">peerAddress</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> quint16 </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#peerPort">peerPort</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QList&lt;QSslError&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#peerVerificationErrors">peerVerificationErrors</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#peerVerificationName">peerVerificationName</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#resumeHandshake">resumeHandshake</a></b>(QUdpSocket *<i>socket</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSslCipher </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#sessionCipher">sessionCipher</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSsl::SslProtocol </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#sessionProtocol">sessionProtocol</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#setCookieGeneratorParameters">setCookieGeneratorParameters</a></b>(const QDtls::GeneratorParameters &amp;<i>params</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#setDtlsConfiguration">setDtlsConfiguration</a></b>(const QSslConfiguration &amp;<i>configuration</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#setMtuHint">setMtuHint</a></b>(quint16 <i>mtuHint</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#setPeer">setPeer</a></b>(const QHostAddress &amp;<i>address</i>, quint16 <i>port</i>, const QString &amp;<i>verificationName</i> = {})</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#setPeerVerificationName">setPeerVerificationName</a></b>(const QString &amp;<i>name</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#shutdown">shutdown</a></b>(QUdpSocket *<i>socket</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSslSocket::SslMode </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#sslMode">sslMode</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qint64 </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#writeDatagramEncrypted">writeDatagramEncrypted</a></b>(QUdpSocket *<i>socket</i>, const QByteArray &amp;<i>dgram</i>)</td>
</tr> </table> <h2 id="signals">Signals
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#handshakeTimeout">handshakeTimeout</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#pskRequired">pskRequired</a></b>(QSslPreSharedKeyAuthenticator *<i>authenticator</i>)</td>
</tr> </table> <h2 id="related-non-members">Related Non-Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum class </td>
<td class="memItemRight bottomAlign">
<b><a href="qdtls.html#QDtlsError-enum">QDtlsError</a></b> { NoError, InvalidInputParameters, InvalidOperation, UnderlyingSocketError, RemoteClosedConnectionError, â€¦, TlsNonFatalError }</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>The QDtls class can be used to establish a secure connection with a network peer using User Datagram Protocol (UDP). DTLS connection over essentially connectionless UDP means that two peers first have to successfully complete a TLS handshake by calling <a href="qdtls.html#doHandshake">doHandshake</a>(). After the handshake has completed, encrypted datagrams can be sent to the peer using <a href="qdtls.html#writeDatagramEncrypted">writeDatagramEncrypted</a>(). Encrypted datagrams coming from the peer can be decrypted by <a href="qdtls.html#decryptDatagram">decryptDatagram</a>().</p> <p>QDtls is designed to work with <a href="qudpsocket.html">QUdpSocket</a>. Since <a href="qudpsocket.html">QUdpSocket</a> can receive datagrams coming from different peers, an application must implement demultiplexing, forwarding datagrams coming from different peers to their corresponding instances of QDtls. An association between a network peer and its QDtls object can be established using the peer's address and port number. Before starting a handshake, the application must set the peer's address and port number using <a href="qdtls.html#setPeer">setPeer</a>().</p> <p>QDtls does not read datagrams from <a href="qudpsocket.html">QUdpSocket</a>, this is expected to be done by the application, for example, in a slot attached to the <a href="qiodevice.html#readyRead">QUdpSocket::readyRead</a>() signal. Then, these datagrams must be processed by QDtls.</p> <div class="admonition note"> <p><b>Note: </b>QDtls does <i>not</i> take ownership of the <a href="qudpsocket.html">QUdpSocket</a> object.</p> </div> <p>Normally, several datagrams are to be received and sent by both peers during the handshake phase. Upon reading datagrams, server and client must pass these datagrams to <a href="qdtls.html#doHandshake">doHandshake</a>() until some error is found or <a href="qdtls.html#handshakeState">handshakeState</a>() returns <a href="qdtls.html#HandshakeState-enum">HandshakeComplete</a>:</p> <pre data-language="cpp">// A client initiates a handshake:
QUdpSocket clientSocket;
QDtls clientDtls;
clientDtls.setPeer(address, port, peerName);
clientDtls.doHandshake(&amp;clientSocket);

// A server accepting an incoming connection; address, port, clientHello are
// read by QUdpSocket::readDatagram():
QByteArray clientHello(serverSocket.pendingDatagramSize(), Qt::Uninitialized);
QHostAddress address;
quin16 port = {};
serverSocket.readDatagram(clientHello.data(), clientHello.size(), &amp;address, &amp;port);

QDtls serverDtls;
serverDtls.setPeer(address, port);
serverDtls.doHandshake(&amp;serverSocket, clientHello);

// Handshake completion, both for server and client:
void DtlsConnection::continueHandshake(const QByteArray &amp;datagram)
{
    if (dtls.doHandshake(&amp;udpSocket, datagram)) {
        // Check handshake status:
        if (dtls.handshakeStatus() == QDlts::HandshakeComplete) {
            // Secure DTLS connection is now established.
        }
    } else {
        // Error handling.
    }
}</pre> <p>For a server, the first call to <a href="qdtls.html#doHandshake">doHandshake</a>() requires a non-empty datagram containing a ClientHello message. If the server also deploys <a href="qdtlsclientverifier.html">QDtlsClientVerifier</a>, the first ClientHello message is expected to be the one verified by <a href="qdtlsclientverifier.html">QDtlsClientVerifier</a>.</p> <p>In case the peer's identity cannot be validated during the handshake, the application must inspect errors returned by <a href="qdtls.html#peerVerificationErrors">peerVerificationErrors</a>() and then either ignore errors by calling <a href="qdtls.html#ignoreVerificationErrors">ignoreVerificationErrors</a>() or abort the handshake by calling <a href="qdtls.html#abortHandshake">abortHandshake</a>(). If errors were ignored, the handshake can be resumed by calling <a href="qdtls.html#resumeHandshake">resumeHandshake</a>().</p> <p>After the handshake has been completed, datagrams can be sent to and received from the network peer securely:</p> <pre data-language="cpp">// Sending an encrypted datagram:
dtlsConnection.writeDatagramEncrypted(&amp;clientSocket, "Hello DTLS server!");

// Decryption:
QByteArray encryptedMessage(dgramSize);
socket.readDatagram(encryptedMessage.data(), dgramSize);
const QByteArray plainText = dtlsConnection.decryptDatagram(&amp;socket, encryptedMessage);</pre> <p>A DTLS connection may be closed using <a href="qdtls.html#shutdown">shutdown</a>().</p> <pre data-language="cpp">DtlsClient::~DtlsClient()
{
    clientDtls.shutdown(&amp;clientSocket);
}</pre> <div class="admonition warning"> <p><b>Warning: </b>It's recommended to call <a href="qdtls.html#shutdown">shutdown</a>() before destroying the client's QDtls object if you are planning to re-use the same port number to connect to the server later. Otherwise, the server may drop incoming ClientHello messages, see <a href="https://datatracker.ietf.org/doc/html/rfc6347#section-4.2.8">RFC 6347, section 4.2.8</a> for more details and implementation hints.</p> </div> <p>If the server does not use <a href="qdtlsclientverifier.html">QDtlsClientVerifier</a>, it <i>must</i> configure its QDtls objects to disable the cookie verification procedure:</p> <pre data-language="cpp">auto config = QSslConfiguration::defaultDtlsConfiguration();
config.setDtlsCookieVerificationEnabled(false);
// Some other customization ...
dtlsConnection.setDtlsConfiguration(config);</pre> <p>A server that uses cookie verification with non-default generator parameters <i>must</i> set the same parameters for its QDtls object before starting the handshake.</p> <div class="admonition note"> <p><b>Note: </b>The DTLS protocol leaves Path Maximum Transmission Unit (PMTU) discovery to the application. The application may provide QDtls with the MTU using <a href="qdtls.html#setMtuHint">setMtuHint</a>(). This hint affects only the handshake phase, since only handshake messages can be fragmented and reassembled by the DTLS. All other messages sent by the application must fit into a single datagram.</p> </div> <div class="admonition note"> <p><b>Note: </b>DTLS-specific headers add some overhead to application data further reducing the possible message size.</p> </div> <div class="admonition warning"> <p><b>Warning: </b>A server configured to reply with HelloVerifyRequest will drop all fragmented ClientHello messages, never starting a handshake.</p> </div> <p>The <a href="https://doc.qt.io/qt-6.2/qtnetwork-secureudpserver-example.html">DTLS server</a> and <a href="https://doc.qt.io/qt-6.2/qtnetwork-secureudpclient-example.html">DTLS client</a> examples illustrate how to use QDtls in applications.</p>  <p><b>See also </b><a href="qudpsocket.html">QUdpSocket</a>, <a href="qdtlsclientverifier.html">QDtlsClientVerifier</a>, <a href="qdtls.html#HandshakeState-enum">HandshakeState</a>, <a href="qdtls.html#QDtlsError-enum">QDtlsError</a>, and <a href="qsslconfiguration.html">QSslConfiguration</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="GeneratorParameters-typedef">
<code>[alias] </code>QDtls::<span class="name">GeneratorParameters</span>
</h3>   <h3 class="fn" id="HandshakeState-enum">
<code>[since 5.12] </code>enum QDtls::<span class="name">HandshakeState</span>
</h3> <p>Describes the current state of DTLS handshake.</p> <p>This enum describes the current state of DTLS handshake for a <a href="qdtls.html">QDtls</a> connection.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QDtls::HandshakeNotStarted</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">Nothing done yet.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::HandshakeInProgress</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">Handshake was initiated and no errors were found so far.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::PeerVerificationFailed</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">The identity of the peer can't be established.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::HandshakeComplete</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">Handshake completed successfully and encrypted connection was established.</td>
</tr> </table> <p>This enum was introduced or modified in Qt 5.12.</p> <p><b>See also </b><a href="qdtls.html#doHandshake">QDtls::doHandshake</a>() and <a href="qdtls.html#handshakeState">QDtls::handshakeState</a>().</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QDtls">QDtls::<span class="name">QDtls</span>(<span class="type"><a href="qsslsocket.html#SslMode-enum">QSslSocket::SslMode</a></span> <i>mode</i>, <span class="type"><a href="qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)
</h3> <p>Creates a QDtls object, <i>parent</i> is passed to the <a href="qobject.html">QObject</a> constructor. <i>mode</i> is <a href="qsslsocket.html#SslMode-enum">QSslSocket::SslServerMode</a> for a server-side DTLS connection or <a href="qsslsocket.html#SslMode-enum">QSslSocket::SslClientMode</a> for a client.</p> <p><b>See also </b><a href="qdtls.html#sslMode">sslMode</a>() and <a href="qsslsocket.html#SslMode-enum">QSslSocket::SslMode</a>.</p>   <h3 class="fn" id="handshakeTimeout">
<code>[signal] </code><span class="type">void</span> QDtls::<span class="name">handshakeTimeout</span>()
</h3> <p>Packet loss can result in timeouts during the handshake phase. In this case <a href="qdtls.html">QDtls</a> emits a handshakeTimeout() signal. Call <a href="qdtls.html#handleTimeout">handleTimeout</a>() to retransmit the handshake messages:</p> <pre data-language="cpp">DtlsClient::DtlsClient()
{
    // Some initialization code here ...
    connect(&amp;clientDtls, &amp;QDtls::handshakeTimeout, this, &amp;DtlsClient::handleTimeout);
}

void DtlsClient::handleTimeout()
{
    clientDtls.handleTimeout(&amp;clientSocket);
}</pre> <p><b>See also </b><a href="qdtls.html#handleTimeout">handleTimeout</a>().</p>   <h3 class="fn" id="pskRequired">
<code>[signal] </code><span class="type">void</span> QDtls::<span class="name">pskRequired</span>(<span class="type"><a href="qsslpresharedkeyauthenticator.html">QSslPreSharedKeyAuthenticator</a></span> *<i>authenticator</i>)
</h3> <p><a href="qdtls.html">QDtls</a> emits this signal when it negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</p> <p>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the TLS handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <i>authenticator</i> object according to their needs.</p> <div class="admonition note"> <p><b>Note: </b>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</p> </div> <div class="admonition note"> <p><b>Note: </b>The <i>authenticator</i> object is owned by <a href="qdtls.html">QDtls</a> and must not be deleted by the application.</p> </div> <p><b>See also </b><a href="qsslpresharedkeyauthenticator.html">QSslPreSharedKeyAuthenticator</a>.</p>   <h3 class="fn" id="dtor.QDtls">
<code>[virtual] </code>QDtls::<span class="name">~QDtls</span>()
</h3> <p>Destroys the <a href="qdtls.html">QDtls</a> object.</p>   <h3 class="fn" id="abortHandshake">
<span class="type">bool</span> QDtls::<span class="name">abortHandshake</span>(<span class="type"><a href="qudpsocket.html">QUdpSocket</a></span> *<i>socket</i>)
</h3> <p>Aborts the ongoing handshake. Returns true if one was on-going on <i>socket</i>; otherwise, sets a suitable error and returns false.</p> <p><b>See also </b><a href="qdtls.html#doHandshake">doHandshake</a>() and <a href="qdtls.html#resumeHandshake">resumeHandshake</a>().</p>   <h3 class="fn" id="cookieGeneratorParameters">
<span class="type">QDtls::GeneratorParameters</span> QDtls::<span class="name">cookieGeneratorParameters</span>() const
</h3> <p>Returns the current hash algorithm and secret, either default ones or previously set by a call to <a href="qdtls.html#setCookieGeneratorParameters">setCookieGeneratorParameters</a>().</p> <p>The default hash algorithm is <a href="qcryptographichash.html#Algorithm-enum">QCryptographicHash::Sha256</a> if Qt was configured to support it, <a href="qcryptographichash.html#Algorithm-enum">QCryptographicHash::Sha1</a> otherwise. The default secret is obtained from the backend-specific cryptographically strong pseudorandom number generator.</p> <p><b>See also </b><a href="qdtls.html#setCookieGeneratorParameters">setCookieGeneratorParameters</a>(), <a href="qdtlsclientverifier.html">QDtlsClientVerifier</a>, and cookieGeneratorParameters().</p>   <h3 class="fn" id="decryptDatagram">
<span class="type"><a href="qbytearray.html">QByteArray</a></span> QDtls::<span class="name">decryptDatagram</span>(<span class="type"><a href="qudpsocket.html">QUdpSocket</a></span> *<i>socket</i>, const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>dgram</i>)
</h3> <p>Decrypts <i>dgram</i> and returns its contents as plain text. The handshake must be completed before datagrams can be decrypted. Depending on the type of the TLS message the connection may write into <i>socket</i>, which must be a valid pointer.</p>   <h3 class="fn" id="doHandshake">
<span class="type">bool</span> QDtls::<span class="name">doHandshake</span>(<span class="type"><a href="qudpsocket.html">QUdpSocket</a></span> *<i>socket</i>, const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>dgram</i> = {})
</h3> <p>Starts or continues a DTLS handshake. <i>socket</i> must be a valid pointer. When starting a server-side DTLS handshake, <i>dgram</i> must contain the initial ClientHello message read from <a href="qudpsocket.html">QUdpSocket</a>. This function returns <code>true</code> if no error was found. Handshake state can be tested using <a href="qdtls.html#handshakeState">handshakeState</a>(). <code>false</code> return means some error occurred, use <a href="qdtls.html#dtlsError">dtlsError</a>() for more detailed information.</p> <div class="admonition note"> <p><b>Note: </b>If the identity of the peer can't be established, the error is set to <a href="qdtls.html#QDtlsError-enum">QDtlsError::PeerVerificationError</a>. If you want to ignore verification errors and continue connecting, you must call <a href="qdtls.html#ignoreVerificationErrors">ignoreVerificationErrors</a>() and then <a href="qdtls.html#resumeHandshake">resumeHandshake</a>(). If the errors cannot be ignored, you must call <a href="qdtls.html#abortHandshake">abortHandshake</a>().</p> </div> <pre data-language="cpp">if (!dtls.doHandshake(&amp;socket, dgram)) {
    if (dtls.dtlsError() == QDtlsError::PeerVerificationError)
        dtls.abortAfterError(&amp;socket);
}</pre> <p><b>See also </b><a href="qdtls.html#handshakeState">handshakeState</a>(), <a href="qdtls.html#dtlsError">dtlsError</a>(), <a href="qdtls.html#ignoreVerificationErrors">ignoreVerificationErrors</a>(), <a href="qdtls.html#resumeHandshake">resumeHandshake</a>(), and <a href="qdtls.html#abortHandshake">abortHandshake</a>().</p>   <h3 class="fn" id="dtlsConfiguration">
<span class="type"><a href="qsslconfiguration.html">QSslConfiguration</a></span> QDtls::<span class="name">dtlsConfiguration</span>() const
</h3> <p>Returns either the default DTLS configuration or the configuration set by an earlier call to <a href="qdtls.html#setDtlsConfiguration">setDtlsConfiguration</a>().</p> <p><b>See also </b><a href="qdtls.html#setDtlsConfiguration">setDtlsConfiguration</a>() and <a href="qsslconfiguration.html#defaultDtlsConfiguration">QSslConfiguration::defaultDtlsConfiguration</a>().</p>   <h3 class="fn" id="dtlsError">
<span class="type"><a href="qdtls.html#QDtlsError-enum">QDtlsError</a></span> QDtls::<span class="name">dtlsError</span>() const
</h3> <p>Returns the last error encountered by the connection or <a href="qdtls.html#QDtlsError-enum">QDtlsError::NoError</a>.</p> <p><b>See also </b><a href="qdtls.html#dtlsErrorString">dtlsErrorString</a>() and <a href="qdtls.html#QDtlsError-enum">QDtlsError</a>.</p>   <h3 class="fn" id="dtlsErrorString">
<span class="type"><a href="qstring.html">QString</a></span> QDtls::<span class="name">dtlsErrorString</span>() const
</h3> <p>Returns a textual description for the last error encountered by the connection or empty string.</p> <p><b>See also </b><a href="qdtls.html#dtlsError">dtlsError</a>().</p>   <h3 class="fn" id="handleTimeout">
<span class="type">bool</span> QDtls::<span class="name">handleTimeout</span>(<span class="type"><a href="qudpsocket.html">QUdpSocket</a></span> *<i>socket</i>)
</h3> <p>If a timeout occurs during the handshake, the <a href="qdtls.html#handshakeTimeout">handshakeTimeout</a>() signal is emitted. The application must call handleTimeout() to retransmit handshake messages; handleTimeout() returns <code>true</code> if a timeout has occurred, false otherwise. <i>socket</i> must be a valid pointer.</p> <p><b>See also </b><a href="qdtls.html#handshakeTimeout">handshakeTimeout</a>().</p>   <h3 class="fn" id="handshakeState">
<span class="type"><a href="qdtls.html#HandshakeState-enum">QDtls::HandshakeState</a></span> QDtls::<span class="name">handshakeState</span>() const
</h3> <p>Returns the current handshake state for this <a href="qdtls.html">QDtls</a>.</p> <p><b>See also </b><a href="qdtls.html#doHandshake">doHandshake</a>() and <a href="qdtls.html#HandshakeState-enum">QDtls::HandshakeState</a>.</p>   <h3 class="fn" id="ignoreVerificationErrors">
<span class="type">void</span> QDtls::<span class="name">ignoreVerificationErrors</span>(const <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qsslerror.html">QSslError</a></span>&gt; &amp;<i>errorsToIgnore</i>)
</h3> <p>This method tells <a href="qdtls.html">QDtls</a> to ignore only the errors given in <i>errorsToIgnore</i>.</p> <p>If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</p> <pre data-language="cpp">QList&lt;QSslCertificate&gt; cert = QSslCertificate::fromPath(QLatin1String("server-certificate.pem"));
QSslError error(QSslError::SelfSignedCertificate, cert.at(0));
QList&lt;QSslError&gt; expectedSslErrors;
expectedSslErrors.append(error);

QDtls dtls;
dtls.ignoreVerificationErrors(expectedSslErrors);
dtls.doHandshake(udpSocket);</pre> <p>You can also call this function after <a href="qdtls.html#doHandshake">doHandshake</a>() encountered the <a href="qdtls.html#QDtlsError-enum">QDtlsError::PeerVerificationError</a> error, and then resume the handshake by calling <a href="qdtls.html#resumeHandshake">resumeHandshake</a>().</p> <p>Later calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</p> <p><b>See also </b><a href="qdtls.html#doHandshake">doHandshake</a>(), <a href="qdtls.html#resumeHandshake">resumeHandshake</a>(), and <a href="qsslerror.html">QSslError</a>.</p>   <h3 class="fn" id="isConnectionEncrypted">
<span class="type">bool</span> QDtls::<span class="name">isConnectionEncrypted</span>() const
</h3> <p>Returns <code>true</code> if DTLS handshake completed successfully.</p> <p><b>See also </b><a href="qdtls.html#doHandshake">doHandshake</a>() and <a href="qdtls.html#handshakeState">handshakeState</a>().</p>   <h3 class="fn" id="mtuHint">
<span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> QDtls::<span class="name">mtuHint</span>() const
</h3> <p>Returns the value previously set by <a href="qdtls.html#setMtuHint">setMtuHint</a>(). The default value is 0.</p> <p><b>See also </b><a href="qdtls.html#setMtuHint">setMtuHint</a>().</p>   <h3 class="fn" id="peerAddress">
<span class="type"><a href="qhostaddress.html">QHostAddress</a></span> QDtls::<span class="name">peerAddress</span>() const
</h3> <p>Returns the peer's address, set by <a href="qdtls.html#setPeer">setPeer</a>(), or <a href="qhostaddress.html#SpecialAddress-enum">QHostAddress::Null</a>.</p> <p><b>See also </b><a href="qdtls.html#setPeer">setPeer</a>().</p>   <h3 class="fn" id="peerPort">
<span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> QDtls::<span class="name">peerPort</span>() const
</h3> <p>Returns the peer's port number, set by <a href="qdtls.html#setPeer">setPeer</a>(), or 0.</p> <p><b>See also </b><a href="qdtls.html#setPeer">setPeer</a>().</p>   <h3 class="fn" id="peerVerificationErrors">
<span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qsslerror.html">QSslError</a></span>&gt; QDtls::<span class="name">peerVerificationErrors</span>() const
</h3> <p>Returns errors found while establishing the identity of the peer.</p> <p>If you want to continue connecting despite the errors that have occurred, you must call <a href="qdtls.html#ignoreVerificationErrors">ignoreVerificationErrors</a>().</p>   <h3 class="fn" id="peerVerificationName">
<span class="type"><a href="qstring.html">QString</a></span> QDtls::<span class="name">peerVerificationName</span>() const
</h3> <p>Returns the host name set by <a href="qdtls.html#setPeer">setPeer</a>() or <a href="qdtls.html#setPeerVerificationName">setPeerVerificationName</a>(). The default value is an empty string.</p> <p><b>See also </b><a href="qdtls.html#setPeerVerificationName">setPeerVerificationName</a>() and <a href="qdtls.html#setPeer">setPeer</a>().</p>   <h3 class="fn" id="resumeHandshake">
<span class="type">bool</span> QDtls::<span class="name">resumeHandshake</span>(<span class="type"><a href="qudpsocket.html">QUdpSocket</a></span> *<i>socket</i>)
</h3> <p>If peer verification errors were ignored during the handshake, resumeHandshake() resumes and completes the handshake and returns <code>true</code>. <i>socket</i> must be a valid pointer. Returns <code>false</code> if the handshake could not be resumed.</p> <p><b>See also </b><a href="qdtls.html#doHandshake">doHandshake</a>(), <a href="qdtls.html#abortHandshake">abortHandshake</a>(), <a href="qdtls.html#peerVerificationErrors">peerVerificationErrors</a>(), and <a href="qdtls.html#ignoreVerificationErrors">ignoreVerificationErrors</a>().</p>   <h3 class="fn" id="sessionCipher">
<span class="type"><a href="qsslcipher.html">QSslCipher</a></span> QDtls::<span class="name">sessionCipher</span>() const
</h3> <p>Returns the cryptographic <a href="qsslcipher.html">cipher</a> used by this connection, or a null cipher if the connection isn't encrypted. The cipher for the session is selected during the handshake phase. The cipher is used to encrypt and decrypt data.</p> <p><a href="qsslconfiguration.html">QSslConfiguration</a> provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</p> <p><b>See also </b><a href="qsslconfiguration.html">QSslConfiguration</a>, <a href="qdtls.html#setDtlsConfiguration">setDtlsConfiguration</a>(), and <a href="qdtls.html#dtlsConfiguration">dtlsConfiguration</a>().</p>   <h3 class="fn" id="sessionProtocol">
<span class="type"><a href="qssl.html#SslProtocol-enum">QSsl::SslProtocol</a></span> QDtls::<span class="name">sessionProtocol</span>() const
</h3> <p>Returns the DTLS protocol version used by this connection, or UnknownProtocol if the connection isn't encrypted yet. The protocol for the connection is selected during the handshake phase.</p> <p><a href="qdtls.html#setDtlsConfiguration">setDtlsConfiguration</a>() can set the preferred version before the handshake starts.</p> <p><b>See also </b><a href="qdtls.html#setDtlsConfiguration">setDtlsConfiguration</a>(), <a href="qsslconfiguration.html">QSslConfiguration</a>, <a href="qsslconfiguration.html#defaultDtlsConfiguration">QSslConfiguration::defaultDtlsConfiguration</a>(), and <a href="qsslconfiguration.html#setProtocol">QSslConfiguration::setProtocol</a>().</p>   <h3 class="fn" id="setCookieGeneratorParameters">
<span class="type">bool</span> QDtls::<span class="name">setCookieGeneratorParameters</span>(const <span class="type">QDtls::GeneratorParameters</span> &amp;<i>params</i>)
</h3> <p>Sets the cryptographic hash algorithm and the secret from <i>params</i>. This function is only needed for a server-side <a href="qdtls.html">QDtls</a> connection. Returns <code>true</code> if successful.</p> <div class="admonition note"> <p><b>Note: </b>This function must be called before the handshake starts.</p> </div> <p><b>See also </b><a href="qdtls.html#cookieGeneratorParameters">cookieGeneratorParameters</a>(), <a href="qdtls.html#doHandshake">doHandshake</a>(), <a href="qdtlsclientverifier.html">QDtlsClientVerifier</a>, and <a href="qdtlsclientverifier.html#cookieGeneratorParameters">QDtlsClientVerifier::cookieGeneratorParameters</a>().</p>   <h3 class="fn" id="setDtlsConfiguration">
<span class="type">bool</span> QDtls::<span class="name">setDtlsConfiguration</span>(const <span class="type"><a href="qsslconfiguration.html">QSslConfiguration</a></span> &amp;<i>configuration</i>)
</h3> <p>Sets the connection's TLS configuration from <i>configuration</i> and returns <code>true</code> if successful.</p> <div class="admonition note"> <p><b>Note: </b>This function must be called before the handshake starts.</p> </div> <p><b>See also </b><a href="qdtls.html#dtlsConfiguration">dtlsConfiguration</a>() and <a href="qdtls.html#doHandshake">doHandshake</a>().</p>   <h3 class="fn" id="setMtuHint">
<span class="type">void</span> QDtls::<span class="name">setMtuHint</span>(<span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <i>mtuHint</i>)
</h3> <p><i>mtuHint</i> is the maximum transmission unit (MTU), either discovered or guessed by the application. The application is not required to set this value.</p> <p><b>See also </b><a href="qdtls.html#mtuHint">mtuHint</a>() and <a href="qabstractsocket.html#SocketOption-enum">QAbstractSocket::PathMtuSocketOption</a>.</p>   <h3 class="fn" id="setPeer">
<span class="type">bool</span> QDtls::<span class="name">setPeer</span>(const <span class="type"><a href="qhostaddress.html">QHostAddress</a></span> &amp;<i>address</i>, <span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <i>port</i>, const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>verificationName</i> = {})
</h3> <p>Sets the peer's address, <i>port</i>, and host name and returns <code>true</code> if successful. <i>address</i> must not be null, multicast, or broadcast. <i>verificationName</i> is the host name used for the certificate validation.</p> <p><b>See also </b><a href="qdtls.html#peerAddress">peerAddress</a>(), <a href="qdtls.html#peerPort">peerPort</a>(), and <a href="qdtls.html#peerVerificationName">peerVerificationName</a>().</p>   <h3 class="fn" id="setPeerVerificationName">
<span class="type">bool</span> QDtls::<span class="name">setPeerVerificationName</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>name</i>)
</h3> <p>Sets the host <i>name</i> that will be used for the certificate validation and returns <code>true</code> if successful.</p> <div class="admonition note"> <p><b>Note: </b>This function must be called before the handshake starts.</p> </div> <p><b>See also </b><a href="qdtls.html#peerVerificationName">peerVerificationName</a>() and <a href="qdtls.html#setPeer">setPeer</a>().</p>   <h3 class="fn" id="shutdown">
<span class="type">bool</span> QDtls::<span class="name">shutdown</span>(<span class="type"><a href="qudpsocket.html">QUdpSocket</a></span> *<i>socket</i>)
</h3> <p>Sends an encrypted shutdown alert message and closes the DTLS connection. Handshake state changes to <a href="qdtls.html#HandshakeState-enum">QDtls::HandshakeNotStarted</a>. <i>socket</i> must be a valid pointer. This function returns <code>true</code> on success.</p> <p><b>See also </b><a href="qdtls.html#doHandshake">doHandshake</a>().</p>   <h3 class="fn" id="sslMode">
<span class="type"><a href="qsslsocket.html#SslMode-enum">QSslSocket::SslMode</a></span> QDtls::<span class="name">sslMode</span>() const
</h3> <p>Returns <a href="qsslsocket.html#SslMode-enum">QSslSocket::SslServerMode</a> for a server-side connection and <a href="qsslsocket.html#SslMode-enum">QSslSocket::SslClientMode</a> for a client.</p> <p><b>See also </b><a href="qdtls.html#QDtls">QDtls</a>() and <a href="qsslsocket.html#SslMode-enum">QSslSocket::SslMode</a>.</p>   <h3 class="fn" id="writeDatagramEncrypted">
<span class="type"><a href="qtglobal.html#qint64-typedef">qint64</a></span> QDtls::<span class="name">writeDatagramEncrypted</span>(<span class="type"><a href="qudpsocket.html">QUdpSocket</a></span> *<i>socket</i>, const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>dgram</i>)
</h3> <p>Encrypts <i>dgram</i> and writes the encrypted data into <i>socket</i>. Returns the number of bytes written, or -1 in case of error. The handshake must be completed before writing encrypted data. <i>socket</i> must be a valid pointer.</p> <p><b>See also </b><a href="qdtls.html#doHandshake">doHandshake</a>(), <a href="qdtls.html#handshakeState">handshakeState</a>(), <a href="qdtls.html#isConnectionEncrypted">isConnectionEncrypted</a>(), and <a href="qdtls.html#dtlsError">dtlsError</a>().</p>   <div class="relnonmem"> <h2>Related Non-Members</h2>  <h3 class="fn" id="QDtlsError-enum">
<code>[since 5.12] </code>enum class <span class="name">QDtlsError</span>
</h3> <p>Describes errors that can be found by <a href="qdtls.html">QDtls</a> and <a href="qdtlsclientverifier.html">QDtlsClientVerifier</a>.</p> <p>This enum describes general and TLS-specific errors that can be encountered by objects of the classes <a href="qdtlsclientverifier.html">QDtlsClientVerifier</a> and <a href="qdtls.html">QDtls</a>.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QDtls::QDtlsError::NoError</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">No error occurred, the last operation was successful.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::QDtlsError::InvalidInputParameters</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">Input parameters provided by a caller were invalid.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::QDtlsError::InvalidOperation</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">An operation was attempted in a state that did not permit it.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::QDtlsError::UnderlyingSocketError</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">
<a href="qudpsocket.html#writeDatagram">QUdpSocket::writeDatagram</a>() failed, <a href="qabstractsocket.html#error">QUdpSocket::error</a>() and <a href="qiodevice.html#errorString">QUdpSocket::errorString</a>() can provide more specific information.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::QDtlsError::RemoteClosedConnectionError</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">TLS shutdown alert message was received.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::QDtlsError::PeerVerificationError</code></td>
<td class="topAlign tblval"><code>5</code></td>
<td class="topAlign">Peer's identity could not be verified during the TLS handshake.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::QDtlsError::TlsInitializationError</code></td>
<td class="topAlign tblval"><code>6</code></td>
<td class="topAlign">An error occurred while initializing an underlying TLS backend.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::QDtlsError::TlsFatalError</code></td>
<td class="topAlign tblval"><code>7</code></td>
<td class="topAlign">A fatal error occurred during TLS handshake, other than peer verification error or TLS initialization error.</td>
</tr> <tr>
<td class="topAlign"><code>QDtls::QDtlsError::TlsNonFatalError</code></td>
<td class="topAlign tblval"><code>8</code></td>
<td class="topAlign">A failure to encrypt or decrypt a datagram, non-fatal, meaning <a href="qdtls.html">QDtls</a> can continue working after this error.</td>
</tr> </table> <p>This enum was introduced or modified in Qt 5.12.</p>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qdtls.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qdtls.html</a>
  </p>
</div>
