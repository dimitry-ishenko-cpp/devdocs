<h1 class="title">Qt State Machine C++ Guide</h1>   <p>The State Machine framework provides classes for creating and executing state graphs. This page illustrates the framework's key features in C++.</p> <h2 id="c-classes-in-the-state-machine-framework">C++ Classes in the State Machine Framework
</h2> <p>For the full list of C++ classes in the State Machine framework see <a href="https://doc.qt.io/qt-6.2/qtstatemachine-module.html">Qt State Machine C++ Classes</a></p> <h2 id="a-simple-state-machine">A Simple State Machine
</h2> <p>To demonstrate the core functionality of the State Machine API, let's look at a small example: A state machine with three states, <code>s1</code>, <code>s2</code> and <code>s3</code>. The state machine is controlled by a single <a href="qpushbutton.html">QPushButton</a>; when the button is clicked, the machine transitions to another state. Initially, the state machine is in state <code>s1</code>. The statechart for this machine is as follows:</p> <p class="centerAlign"><img alt="" src="data:image/png;base64,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"></p>
<p>The following snippet shows the code needed to create such a state machine. First, we create the state machine and states:</p> <pre data-language="cpp">    QStateMachine machine;
    QState *s1 = new QState();
    QState *s2 = new QState();
    QState *s3 = new QState();</pre> <p>Then, we create the transitions by using the <a href="qstate.html#addTransition">QState::addTransition</a>() function:</p> <pre data-language="cpp">    s1-&gt;addTransition(button, &amp;QPushButton::clicked, s2);
    s2-&gt;addTransition(button, &amp;QPushButton::clicked, s3);
    s3-&gt;addTransition(button, &amp;QPushButton::clicked, s1);</pre> <p>Next, we add the states to the machine and set the machine's initial state:</p> <pre data-language="cpp">    machine.addState(s1);
    machine.addState(s2);
    machine.addState(s3);
    machine.setInitialState(s1);</pre> <p>Finally, we start the state machine:</p> <pre data-language="cpp">    machine.start();</pre> <p>The state machine executes asynchronously, i.e. it becomes part of your application's event loop.</p> <h2 id="doing-useful-work-on-state-entry-and-exit">Doing Useful Work on State Entry and Exit
</h2> <p>The above state machine merely transitions from one state to another, it doesn't perform any operations. The <a href="qstate.html#assignProperty">QState::assignProperty</a>() function can be used to have a state set a property of a <a href="qobject.html">QObject</a> when the state is entered. In the following snippet, the value that should be assigned to a <a href="qlabel.html">QLabel</a>'s text property is specified for each state:</p> <pre data-language="cpp">    s1-&gt;assignProperty(label, "text", "In state s1");
    s2-&gt;assignProperty(label, "text", "In state s2");
    s3-&gt;assignProperty(label, "text", "In state s3");</pre> <p>When any of the states is entered, the label's text will be changed accordingly.</p> <p>The <a href="qabstractstate.html#entered">QState::entered</a>() signal is emitted when the state is entered, and the <a href="qabstractstate.html#exited">QState::exited</a>() signal is emitted when the state is exited. In the following snippet, the button's <a href="qwidget.html#showMaximized">showMaximized</a>() slot will be called when state <code>s3</code> is entered, and the button's <a href="qwidget.html#showMinimized">showMinimized</a>() slot will be called when <code>s3</code> is exited:</p> <pre data-language="cpp">    QObject::connect(s3, &amp;QState::entered, button, &amp;QPushButton:showMaximized);
    QObject::connect(s3, &amp;QState::exited, button, &amp;QPushButton::showMinimized);</pre> <p>Custom states can reimplement QAbstractState::onEntry() and QAbstractState::onExit().</p> <h2 id="state-machines-that-finish">State Machines That Finish
</h2> <p>The state machine defined in the previous section never finishes. In order for a state machine to be able to finish, it needs to have a top-level <i>final</i> state (<a href="qfinalstate.html">QFinalState</a> object). When the state machine enters a top-level final state, the machine will emit the <a href="qstate.html#finished">QStateMachine::finished</a>() signal and halt.</p> <p>All you need to do to introduce a final state in the graph is create a <a href="qfinalstate.html">QFinalState</a> object and use it as the target of one or more transitions.</p> <h2 id="sharing-transitions-by-grouping-states">Sharing Transitions By Grouping States
</h2> <p>Assume we wanted the user to be able to quit the application at any time by clicking a Quit button. In order to achieve this, we need to create a final state and make it the target of a transition associated with the Quit button's <a href="qabstractbutton.html#clicked">clicked</a>() signal. We could add a transition from each of <code>s1</code>, <code>s2</code> and <code>s3</code>; however, this seems redundant, and one would also have to remember to add such a transition from every new state that is added in the future.</p> <p>We can achieve the same behavior (namely that clicking the Quit button quits the state machine, regardless of which state the state machine is in) by grouping states <code>s1</code>, <code>s2</code> and <code>s3</code>. This is done by creating a new top-level state and making the three original states children of the new state. The following diagram shows the new state machine.</p> <p class="centerAlign"><img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA5YAAAGmBAMAAAD1wAbJAAAAGFBMVEVHcEwPDx8AAAAAAAD///8AAAD09PT8/PxPXwWLAAAABHRSTlMAEAgD/mUeWAAAC+9JREFUeNrt3dtS20gQxnFXUX4ASO39BmrvKSjeQL3cmt0e9gUS8wJO8vprHWzL4BjJGs2h59+bJRyDpZ++1oxsSYsFRVEURVEURVEURVEURVEURVEURVEURc1WS+fcI6vBCiWYNqqhdP/csyasWL5gaaXFOnfHqjBj+YVVYcbyhlVhZHeJpYV6whJLiv0lNVtddfNLxrF2LJlfmtlhXt+zJvKvhz9qSo7HmmiyD9fX1zdPrAgbmLe3j0vWg51asQrszDNZBQSTIpgUlhRNlmBSBJMimBSWFE2WYFIEkyKYFJY0WcpOMAG1E0wssaTSa7JY2gkmo1k7wcTSTjCxxJJKqsE2e0sszWCusDSDucTSDuaKCaYZTCztYDosTQ2AHDWi/r1PmNNV1IiShDGX8IzETPfSHYrOyEr2eg/E0k4wsRxv+YUWS5PFMrl6wXJ0L0v1sb38ieXIUizt9FgsLViKUyyNWCq5xBLL9HoslnbGPg5LO+NYxj5YYokllrPtLl3zRrHk2DqWFJZYYoklllhiiSWViyUnFYwvckkuscQSSywpLLHEEkssscQSSwpLLLHEEkssuxp2YPm/jSWWi5Y5fcuB1/kRS5iXLXPyljJ0+eXNDOWFy5y85fAd56uZYF64zKlbyoit+a20WL5bZiyxDGU5Zm5ipcleusxYYhnV0p0et79+M2zZnpV0dplztBTZvSnHsl5cOfGl3C3bwUFZlt3iiiXLps0UZnlYZlOWUmAuxWguS7c0tb/UAveXQ5c5N0vR8iwPy6y25iRS4DhW+suNpQlLxdKK5alj7jmPY53Wb1z3poxx7G6Zt/87c8d9fnec2fJxnwHLjCWWWGKJJZZYYoklllj6txxzfRsrlpcuM7kkl1hiiSWWWGKJJZZYYoklllhiiSWWxVjq59/w8WXkgmXalnr6EWBpybLCMhNL1xqquPpPVbn2g9bMdbncviONYP1VcVgmaem601a1y2VDpto+GG3+a75B5fDVoddXwjJ4j9W+pXZWWu3P62gTKXL4gFzmY6mnLBVLM5bN7tI5LA1Y9j6LZcqWMsBSsMxiHKvH49j9AKg/jt2xMo5NeX65nT420ZTd/LIDO55f1n/8zS8VSzPH1kWxNPM8STfJwdLCc16CpRnL3eElLCsTmFiaeV2Bw3LcOTUpF5bkEkv2l1gyjsWS+SXHfbDkeCyWcYrnSYzNSbDEEkssg1n+GDFwWG9sWF66zFhiGcryeXjDebVy/8tLlzl5y+/DN1Ezlhcuc/L3i/576D3NX6202IuXOXnLaj3wIn/rN+dsUOrz8GWusrL8te7Vd7f+Xb1tXOUscMq7ZT5Tb5u8LI8W7Izlpj2amb+mVoMxj/cqGVgeLaeeGeOJaGUilheWKUuP5+dEfqqkAEtpTsc5053yD+aEJTBmKeV22Nws9Xz0tMo+mFqKpXwSPZ20u8k9lrYspaoy77JajKV+0kZl8urIOZYGLaXUWGZl2b12VD5ZF1poLHM7VvAJlGYdzKnjNluWbbkiO6xNy0y77OR+YtJSioylTcssgzl9A7RpKSXG8ozlqn6zdO7sKl9239e9XXx4P45lhsH0sPmds1z1rJbNn2ws8zssq9WsPXaY5SJFy+y6rI951HvLpVt2bqulW7V/1x9ue23dbpeu+aDV6r7evNOm2DWfTcEysy7rZdN7b7lauJ1lm8uOtstl/cnlso1j97VV89dq/9XFMglLKa3DfrDsuXVJW/U/1767ai1Xi8P3LVarwwdJWGYVTD8b3meWx7nsR/TY0i1Ss8xp+KNhLLv95WeWTS6d+61l/TLrf+9DWmbUZT09Um+Wvc+esGyGaTIC04NlPl1WZ7V0x5buc8vF6ozlstv+7oJaSiKpklMXlVD/j/P0OHZ5nMvl8Th2PwDqj2N3rCfHsbsH/s99SMtAwZT+e3KBpc5kWc8vt1PE1mjVHsNzbTQX+/llB3Y8v6x/4P38cnUUyzHB9GIpyVhWZyy9Pd368bjP0uMR8i6iWt8noDlpZ3AwvVj2VtPkRnjmJ+s7IzSMzjWnJrUfu/aHXXf/i/qd5sW9ze363OFcCn8b3LyWHaa213bd/vUS1rJSb43w7OSnvcfF7p9uPpbdK8mk2t/FRPdf7c2YNBfL5l9btrFsNtm7sJbiqxGe/x3St2zf1cMrPGV3pksdRundg8jzfmD25y9dY7m7YLF8CWt5WGXTGuF4y+qEpas+WmpGlvW4uGd5E9hS/DRCP5baDhz6lj6HZwFeV+BiWvbW2YRG6Muy91n1P20Kcy14iWfZZWtaIxxk6T63rPSdpddZU4hcPsXMZbe6JjXCQeNYOW7f+9z32/fut+zat9/j/yH2l3Et9y9mv7wRDphfbgdKTTSr/bCqAzseVtWOvWGV3wNTocexESxlaiNM/fmRUJbv55fTLOt/5tdFwZzQCJN/fiSQZXPc56p33GfS/LLdIkZj1iQTGmEusZzZsj2Ed3U4Hvsy6bhPd+WwTeyVlmYsZ7bsnid52q/U6/sYlmk+K+19CwtyDsLDbl2+3Eyx7Gap7q0yEUzN0vLqr10sJz1/ebllisH0v32FOTfooX29z/BYnrVcVwaCOcMYOYzl1dfa4OV62ut93OWW6Z0rPUOnCHTO3uPX623dTXsd3o8Jlql12TkaRajzLx9vb29HUPq3FPOxzOuaMFMs0wrmLFtWTpbP3fzyrco+mIrlFMuUgjnPdpXV9QraHeb6WzKzgKRimZflz+815cX3IUmmy840QcrrOiI/mxs5JBaHZLapvCyff06hTCWYimXCazGNLaosyySGP4pl2plI4SEUZplAl1UsrQRzxgdQmmX0YCqWVoI55/OoxVnGfVZ61i2pPMuoXVaxtNJl5/3VBVpGDKZiaSWYM//iEi2jBVOxtHJYdu5+UKRlnC47+xZUpmWULjv77yzUUux12GItIwRTsbQy/AnQCUq1DN5lFUsrXTbEplOupViLZcGWQYMZZMMp2DJgMMOMtAq2DPisdJgWULJlsC4bqAMUbSmmYlm2ZfAbmGCZ+1pWLK2s5mDj5cItQ0wWFEsrQ8xwM5/SLWdPTcAjEsVbipUOi+XcKzvkEXws5x3+KJYBLWeNTtAn1rCcNTuKZVhLsRFLLGdNj2IZ2nKu+AQ+bRfL+VZ66Jf6YTlfM1QsY1iKgVhiOV+GFMs4lpJ/LLGcLUWKZSxL34dlI5wViOU8K18Uy3iWfptihMeP5TzBjHJBBCxnyZJiGdfS3z4uztWgsJyDQLGMbenLINJF2rCcAUGxjG/pRyHWtROx9M4gimUKlj6elY710LH0LhHvstFY+qZQLFOxnGoR8WruWHrGUCzTsZymEfNWNlj6mlNo7Fhi6S1b6mlKg2X0LiuxOyyW3oIpsTsslt6CKdFjiaWv4Y9EjyWWvrqsxr/nLZaeuqzGv+Utlp6CqfFvRY2ln2BKAreIx9JPMCXuYQIsz9Y4G2nmJA7LJC3H9cztLEYcc5JULUd1WRddEstPgukG1X+byiXwgLH0sM+ULWaFZdKWg7usvGGZuOXwB/G6wTJpyxGDnySCiSWWhYxjs2qyWGJZrGU9TXEfZ5Ov37DMzbI+7iondqVYZphLOT0swjIvS+ewNGLZV2R/acXSfTxOi2VePVbJpRlLUfaXZsaxgiWWWKZqKewvsx/H1kfupB7DMo61fWwdSyyxxBJLLLHEEkssscTSc7kRhSW5xBJLLLHEEkssscQSSyyxxBJLLLHEEkssscQSSyyxxBJLLLHEEkssscQSSyyxxBJLLLHEEkssscQSSyyxxBJLLLHEEkssscQSSyyxxBJLLLHEEkssscRyWP0Y/q2y3mCJJZYh6nn4g3jl/peJW34fHkss07as/h54H3f3mkKLxfJsrQde2HDNfdyTt/y1HlZvGyxTtxyKmQQlloYKSyyxxBJLLCksscQSSyyx/FhP0Iwtub7H0orlTaKWVzTZ0S32yyJRy7/AGdti7xK1XDw4eEZRvqTaYrfB/OqoEfWSbiwXi8ev19SIurtfJIx5Sw2vpCkpiqIoiqIoiqIoiqIoiqIoiqIoiqIoiqIoA/U/KiVWwCNSmScAAAAASUVORK5CYII="></p>
<p>The three original states have been renamed <code>s11</code>, <code>s12</code> and <code>s13</code> to reflect that they are now children of the new top-level state, <code>s1</code>. Child states implicitly inherit the transitions of their parent state. This means it is now sufficient to add a single transition from <code>s1</code> to the final state <code>s2</code>. New states added to <code>s1</code> will also automatically inherit this transition.</p> <p>All that's needed to group states is to specify the proper parent when the state is created. You also need to specify which of the child states is the initial one (i.e. which child state the state machine should enter when the parent state is the target of a transition).</p> <pre data-language="cpp">    QState *s1 = new QState();
    QState *s11 = new QState(s1);
    QState *s12 = new QState(s1);
    QState *s13 = new QState(s1);
    s1-&gt;setInitialState(s11);
    machine.addState(s1);
    QFinalState *s2 = new QFinalState();
    s1-&gt;addTransition(quitButton, &amp;QPushButton::clicked, s2);
    machine.addState(s2);
    machine.setInitialState(s1);

    QObject::connect(&amp;machine, &amp;QStateMachine::finished,
                     QCoreApplication::instance(), &amp;QCoreApplication::quit);</pre> <p>In this case we want the application to quit when the state machine is finished, so the machine's <a href="qstate.html#finished">finished</a>() signal is connected to the application's <a href="qcoreapplication.html#quit">quit</a>() slot.</p> <p>A child state can override an inherited transition. For example, the following code adds a transition that effectively causes the Quit button to be ignored when the state machine is in state <code>s12</code>.</p> <pre data-language="cpp">    s12-&gt;addTransition(quitButton, &amp;QPushButton::clicked, s12);</pre> <p>A transition can have any state as its target, i.e. the target state does not have to be on the same level in the state hierarchy as the source state.</p> <h2 id="using-history-states-to-save-and-restore-the-current-state">Using History States to Save and Restore the Current State
</h2> <p>Imagine that we wanted to add an "interrupt" mechanism to the example discussed in the previous section; the user should be able to click a button to have the state machine perform some non-related task, after which the state machine should resume whatever it was doing before (i.e. return to the old state, which is one of <code>s11</code>, <code>s12</code> and <code>s13</code> in this case).</p> <p>Such behavior can easily be modeled using <i>history states</i>. A history state (<a href="qhistorystate.html">QHistoryState</a> object) is a pseudo-state that represents the child state that the parent state was in the last time the parent state was exited.</p> <p>A history state is created as a child of the state for which we wish to record the current child state; when the state machine detects the presence of such a state at runtime, it automatically records the current (real) child state when the parent state is exited. A transition to the history state is in fact a transition to the child state that the state machine had previously saved; the state machine automatically "forwards" the transition to the real child state.</p> <p>The following diagram shows the state machine after the interrupt mechanism has been added.</p> <p class="centerAlign"><img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA+YAAAGrBAMAAAC/F5CPAAAAGFBMVEVHcEwPDx8AAAAAAAD///8AAAD09PT8/PxPXwWLAAAABHRSTlMAEAgD/mUeWAAADqFJREFUeNrs3e1ymzgUBmBmMrqApLP/t8ns/0wzvQPO5i9uz8neQGvfQNre/hpJ2Dj+EhiBpPOqaeKv2IaH9yABMVWFhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhqa6GRF5wWzQRg50Xc2Sy7dnzAlt5iuYayvtIk+YFerMP2FWqDN/wKxQtjqHuab2FeYwR8P6HK24dufH5+i3qzPH+FzfCv1eMCf0tC9/teQPzw1mhZ7i/uX+/v7hpTKYFZrQHx/bXamo7gobqrvCoTrk9TWBuc7qjr6cvuoOc4VBR3FXFvQG5hqrO4q7vuoOc4XVHcVdX3WHub7qjuKuqUm7Jc5gZ4s2dWkMiru6Fbo0+8Pe0T6278+lxr1GO9OoUHQD2gvoZR4uypC90Ir8W33EXF/QYX7Z/BNKO4o7zItvK5jPUE3Tekerv2EevTHM9dV2mGsyJ2GYKzNn5BzmMC+/tsNcXx9OYK6v344+HMxhDnOYl2YuYr8xzLGPBeYwhznMYQ5zmMMc5jCHOZo2c/yB0uWGnCPnMIc5zGEOc5jDHOYwhznMYQ5zmMMc5jCHOcxhDnOYwxzmMIc5GszRYA5zmMMc5jCHOcxhDnOYwxzmMIc5zGEOc5jDHOYwhznMB5lf/+O9/95z4xs1TXrMA865Rrmhj5smNeYUMg9pkxX5yGlSYx62kn/LKugjp0mLOQUmZ1NazE9ME8xhXqp56Pgtp+I+dppgDnNF5nJqtPP2I2tz94nCV6ZJrzlR960c83Zy6OgOmB92gcoy95NDMD+eP7b8FWa+nyaYn5g/VGDOCTlXbY71+YnZwDHM+foDjmNIk9X28GnSaU4c1ZxPLwBxzffTxDA/FUJaxryOaL6bpqOnhHk8c3HWTNJ+bXvS7op7QfE5314g+6rtvSQRzBnms5mL3xzCPueWltm9NNt/9gFM+3tDjnoYaH68FA01b9pvRuTig4x/nP9eHV1Ord/uMib+23S1nfvm7E1761mXcKL9lclyvpum7X+51bzpmRr7lb35pf0RE5vzKXOOYD5gmq7X9jDzCubh5nZ1LpKWuRHjfRsjjfvZXt3W+LbMG7FXnKq/315wVUHsrTA/a967NR3zppLO3OXcLwI+5+2Nxrh4+/sa+6PZ3VsZreYUYE7pmfd8fXKb/m3uYuPMm2r/uKpp9lfUmft+Ox/223cduX6/veOftN8+sflhzvuRPzSXSrE5u56zizp143MPezg+b79uGZ/zHOZ+fX7N3OZc5Ip5++cV35+LM5+xESdk3rv1rLktZxQR/dS8CD33WCb71Sz62Gm6aC6H5nLdvGqumhv/rp+Q81vQI/XbzWHOzWG/fdeR6/fbO/4L/fbunX57hvkNTWKMz7dDbGfZuG2v4qJe7cbnHvZwfN7+wunxeXMQ85hBV2Fey+Tb4czkEj74bquwxAy6DnPb8U/c3KOz63tsf6xSNM/pXLcZmNvnNC7mdp/WE3KeVM6jNLHm3UJKn2Ce1Po8Fnrf/AHmCfXb46HDfPnx+fz9DoL5RNvhcsn5V+Q8ze3tEdfnMJ+iRdivNlO/HeZTyKdt/nF8DvPize12uLvedjiMz0s3d5te7/bb21fYDle6ud+v9nXX97zHPpby1+e2fene6eoB5krM7/7pYo7951rMqy/ueLh4MYd5cuZ3n9t+++oex8PpMa9ePt9v29MzzPWYVy+Pj48RyWGeoHnsBnOYwxzmMIc5zGEOc5jDHOYwhznMYQ5zmMMc5jCHOcxhDnOYwxzmMIc5zE+b/wqbPbR+z8d87DTBHOalmr+GFcK3nM5/Pnaa1Jj/DItEVuYjp0mLef1vwKdm01tOpX30NKnpt7+uAz4Md70RyYc8dJpqnebE9Z/19bZ5l1pyYac6cJqUmrMEzaD3duHwp5XOYngeNE06zSn4HBhEuVT28W9Uh7k7dWHYnMxlhc4wn8i85htmZh4x12FO9RBzKjzmOsy7E5sFzksuO+YqzKkeZp5B0IlhftHcMXJ4gLjkyq7CnAZVbKozCPptb1DLNpng+WQfJiXHHOan5ycXHHNF5oMyRAXHHOZxZmvKMYd5pPmacMxhnl/Qb14ctexXq8sJOsM8knmyQb99YYR5lM2bKccc5rlV9wneFcyDEsXXH0tHr0SjYnrlmRjmMc1PzukzW+5HmI96pimKj5LjZG5ddQZI1ZOZX3imSToZMA8KOosTYpL2y52IenvJPUx8OrcX3I769l6S0+Y3PdMk/UqYBwVd/B549um0IMzdDhl2UuwPvHP3nt47d9MzTdOthHnQeG2PxPXuy5+Omrq1sN31Tvsr52r7+GdimEc378/sYyk+JcVjzAOfaaLRI8yDqnu4lF0Ji0xgfvxMDPNg8xvyQUOlerfeaH70TFNtJIJ5UNC9DAVIUZD5mGdimM9jTv3eNh/2tnfdr35vu0O73G8f8UyTbQuGeVDQ2Y2TXUCpG1V7jsNRdft1bXw+6pkY5qHm7VmY/yy7UyOVnStazMl+2sIt6Ikc+MwwDzX3n7DxnsTcTqPcwDyT6s4wDzUn/1E6mzrvoE+53ME8i6ATw3yw+brOOuiTvoHSzWUScyqospdv/msS86XHawzz+c2Xre4TlxmszzOo7gzzIeavfny+qfMN+tTLG8zTDzrDfNh2OLdCX/+osw365Etb8ea/f7bkE3wuO5UScwX7Un/bD7ROcd4vtayVb/76exryabd/LrmoqTk3R5KJW+ZFYZ54dWeYL2pORcQc5mkHPUofAuZJBz3KpMA85aDHWcZgnvJ4jUsyl8Ht+3MK5vNW90gvtoz5iEMQKByd84verK+1iLkZtdA/JWFO2cd8GfNxKN+eUzCfMehckLkZudg/JWFOucc8K/NPSZjPFnSex7wJ6XFfflBTGQfbR57GJLS4c11C0OO9zEnzc6qmZ9o+qJnXfJWG+UwHPnM9a22/zby6xZwunIc6dD3E+XLMUk0+5rwxUpm2fG//m+3lRhrTorWXt3Xdmbfc2wd1j7O/ZG39/e0FY6Xbe40MMOcLczQZc8o65sfmTfvNKlemJbUptZcbn/PGRdzl3NLaX9rdZ9yys7+3kkEm6ZvPEPSYi9VHc9lxGk/szasuuVL1zZvdL/kS3v2iMfsrgTkn4UzMowc96nb9o5xfM/+Q897FD+bNYHO+Mj/TMY8e9KjPf85cRM6ZmzBzVxRkoLnPeurmlPPTn895daN579bQ2p5PziOP1zgBc/lobgLMzVBzPyM5B/OoLJGryDlz01+fm4N+u+m6972e+b73t++3d/wD+u2cjzllG/PT5saPz/0mlnaIbsfnlbhtr+24vX2Q6cbnHvZwfG4LxOH4vCnHPCJM7FFB6Hw00+xdaa6Zcybr85gyXJS5Qz83TSLZ9Ntj0kQf/M9sbp+HI7/Xmcwp05jPv/9cijGPhBN/Y/78x0xIMeZxNpBygeaVlGIeJZIz7LOTBVox5jEyOcObR87TCuUcu+axPk8qlcQlmsuYP1xyLUFzyq+yz29e0Pg8AtI8h9TObH5xO1yO5tMWYy7Q/Nr29vzMJ43mTEfOz2veVMWZT5lNLtG8KtCccos5zBNKJ8M8F3PKLOYwTyefDPN8zCmvmMN8iiZZxRzmqZTlGT+nBuaJ1GWGeV7mt4vN+blzME8i6MQwz8381qDP+pZhnkLQ5/28aJinMF5jmOdofovbzB8LD/MEqjvDPE/z8XJzn/0B5ssHnWGeq/lwO1ok5jBfMui0SMxhvmTQaZGYw3zSoPOIZYRhnrP50MzyIjGH+ZLVnReJOcyXDDovc65lmC8XdFronOowXy7otMzZtWG+YNBpkcoO8yXHa2QXEIF57uYDskvtCl2Q8/zNw6s7Mwn6cEWYBwddZJl3CvMoQb/+4Tj/vS+wJod5vBagSVt0mJdjHlTdaQPzgszD3sDbO8yLMQ/sxC0WdJjDHObzDdCXKu4whznMo5jLqU0wbz9gXq653bJ+tKKHedE5P3kkO8xLNW/PIAZzVeZ9bazPtZnLx63wMC+1tjNyrs6cGOtzdf12gjnMYa7FnLA+V9Nvb7e4UttnR79d13a4kw3mMIc5zGEOc5jDPL65SON+Nsbf0vS+u2ZgXpK58aJmLwvz8mu7OckK848t9NzeaZuL7ES3F832X1vom8psfzRGbMXf3i8wLybnppdoW9tNy7693t7StD/8dYF5UeYu69682ZuLu2D6a3qY578+bz7mvHLmxt0K8wLNTdPvw+3NXcjbom5X8zAvqd9uzpi7+u6KPMxnNvcfXQBzPeZ21yyNQA82d+vv5ow5+u2zm/uDbkb8dWtYv70dfbf99o/m0q3PMT6f3bx7leF/6Yh9LJma746t80EnmBdvvn8RG3RimCszH0IO80zNd6dyYVvcuYa5MnOpYa7LfC01zJWZSw1zDebcN8+gwfx281/W3M5M5FyVOdbnavtw6LcrNMf4XIP5K+/M3zbYDqfRHNvbNWxv/9WZ0/p9V+xhXrT57+5V3pw5anv55vVP35lbb2qYKzH/1x0PNzzmMM/WvF7bv3lbb2qYqzF/Xdv2DnNFx7f/GUcO84zN68jzEeYwv6V9HbmJ+f4Z5trMH2CerfndOJTVpwrm2Zr/M660P8E8W/Pqy4gzf9MqtLTDPEXzu8/DD6JbBccc5imaVy+f7we3p2eY52xevTwObeHki5v/ClxbjdmGlrF5ktt8YA7z0Ts/wt7Am6bznxdv/jMs5jAvx9wfznCF/G2p0g7zKG0d8AG/i8Uc5lHan/X1tnmHeUnmIeiLkcNcYYM5zGH+fzt3cAIgDARRNGAH2oHBuxcLSf/NWIAQJIKHyXstfHaPo7nmmmuuueaaa6655pprrrnmmmuuueaaa6655pprrjmao7nmmmuuueaaa6655pprrrnm/7hk7Xm9uaZ5TvM1sPniuXdf+1YCmx/C9l57DWw+tEU2TfKW+NrHtshm0TLPfGyLbBb1LKHRdz5vrgEAAAAAAAAAAAAAAA83MkeuXYMX8/IAAAAASUVORK5CYII="></p>
<p>The following code shows how it can be implemented; in this example we simply display a message box when <code>s3</code> is entered, then immediately return to the previous child state of <code>s1</code> via the history state.</p> <pre data-language="cpp">    QHistoryState *s1h = new QHistoryState(s1);

    QState *s3 = new QState();
    s3-&gt;assignProperty(label, "text", "In s3");
    QMessageBox *mbox = new QMessageBox(mainWindow);
    mbox-&gt;addButton(QMessageBox::Ok);
    mbox-&gt;setText("Interrupted!");
    mbox-&gt;setIcon(QMessageBox::Information);
    QObject::connect(s3, &amp;QState::entered, mbox, &amp;QMessageBox::exec);
    s3-&gt;addTransition(s1h);
    machine.addState(s3);

    s1-&gt;addTransition(interruptButton, &amp;QPushButton::clicked, s3);</pre> <h2 id="using-parallel-states-to-avoid-a-combinatorial-explosion-of-states">Using Parallel States to Avoid a Combinatorial Explosion of States
</h2> <p>Assume that you wanted to model a set of mutually exclusive properties of a car in a single state machine. Let's say the properties we are interested in are Clean vs Dirty, and Moving vs Not moving. It would take four mutually exclusive states and eight transitions to be able to represent and freely move between all possible combinations.</p> <p class="centerAlign"><img alt="" src="data:image/png;base64,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"></p>
<p>If we added a third property (say, Red vs Blue), the total number of states would double, to eight; and if we added a fourth property (say, Enclosed vs Convertible), the total number of states would double again, to 16.</p> <p>Using parallel states, the total number of states and transitions grows linearly as we add more properties, instead of exponentially. Furthermore, states can be added to or removed from the parallel state without affecting any of their sibling states.</p> <p class="centerAlign"><img alt="" src="data:image/png;base64,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"></p>
<p>To create a parallel state group, pass <a href="qstate.html#ChildMode-enum">QState::ParallelStates</a> to the <a href="qstate.html">QState</a> constructor.</p> <pre data-language="cpp">    QState *s1 = new QState(QState::ParallelStates);
    // s11 and s12 will be entered in parallel
    QState *s11 = new QState(s1);
    QState *s12 = new QState(s1);</pre> <p>When a parallel state group is entered, all its child states will be simultaneously entered. Transitions within the individual child states operate normally. However, any of the child states may take a transition which exits the parent state. When this happens, the parent state and all of its child states are exited.</p> <p>The parallelism in the State Machine framework follows an interleaved semantics. All parallel operations will be executed in a single, atomic step of the event processing, so no event can interrupt the parallel operations. However, events will still be processed sequentially, since the machine itself is single threaded. As an example: Consider the situation where there are two transitions that exit the same parallel state group, and their conditions become true simultaneously. In this case, the event that is processed last of the two will not have any effect, since the first event will already have caused the machine to exit from the parallel state.</p> <h2 id="detecting-that-a-composite-state-has-finished">Detecting that a Composite State has Finished
</h2> <p>A child state can be final (a <a href="qfinalstate.html">QFinalState</a> object); when a final child state is entered, the parent state emits the <a href="qstate.html#finished">QState::finished</a>() signal. The following diagram shows a composite state <code>s1</code> which does some processing before entering a final state:</p> <p class="centerAlign"><img alt="" src="data:image/png;base64,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"></p>
<p>When <code>s1</code> 's final state is entered, <code>s1</code> will automatically emit <a href="qstate.html#finished">finished</a>(). We use a signal transition to cause this event to trigger a state change:</p> <pre data-language="cpp">  s1-&gt;addTransition(s1, &amp;QState::finished, s2);</pre> <p>Using final states in composite states is useful when you want to hide the internal details of a composite state; i.e. the only thing the outside world should be able to do is enter the state, and get a notification when the state has completed its work. This is a very powerful abstraction and encapsulation mechanism when building complex (deeply nested) state machines. (In the above example, you could of course create a transition directly from <code>s1</code> 's <code>done</code> state rather than relying on <code>s1</code> 's <a href="qstate.html#finished">finished</a>() signal, but with the consequence that implementation details of <code>s1</code> are exposed and depended on).</p> <p>For parallel state groups, the <a href="qstate.html#finished">QState::finished</a>() signal is emitted when <i>all</i> the child states have entered final states.</p> <h2 id="targetless-transitions">Targetless Transitions
</h2> <p>A transition need not have a target state. A transition without a target can be triggered the same way as any other transition; the difference is that when a targetless transition is triggered, it doesn't cause any state changes. This allows you to react to a signal or event when your machine is in a certain state, without having to leave that state. Example:</p> <pre data-language="cpp">QStateMachine machine;
QState *s1 = new QState(&amp;machine);

QPushButton button;
QSignalTransition *trans = new QSignalTransition(&amp;button, &amp;QPushButton::clicked);
s1-&gt;addTransition(trans);

QMessageBox msgBox;
msgBox.setText("The button was clicked; carry on.");
QObject::connect(trans, QSignalTransition::triggered, &amp;msgBox, &amp;QMessageBox::exec);

machine.setInitialState(s1);</pre> <p>The message box will be displayed each time the button is clicked, but the state machine will remain in its current state (s1). If the target state were explicitly set to s1, however, s1 would be exited and re-entered each time (e.g. the <a href="qml-qtqml-statemachine-qabstractstate.html#entered-signal">QAbstractState::entered</a>() and <a href="qml-qtqml-statemachine-qabstractstate.html#exited-signal">QAbstractState::exited</a>() signals would be emitted).</p> <h2 id="events-transitions-and-guards">Events, Transitions and Guards
</h2> <p>A <a href="qstatemachine.html">QStateMachine</a> runs its own event loop. For signal transitions (<a href="qml-qtqml-statemachine-qsignaltransition.html">QSignalTransition</a> objects), <a href="qstatemachine.html">QStateMachine</a> automatically posts a <a href="qstatemachine-signalevent.html">QStateMachine::SignalEvent</a> to itself when it intercepts the corresponding signal; similarly, for <a href="qobject.html">QObject</a> event transitions (<a href="qeventtransition.html">QEventTransition</a> objects) a <a href="qstatemachine-wrappedevent.html">QStateMachine::WrappedEvent</a> is posted.</p> <p>You can post your own events to the state machine using <a href="qstatemachine.html#postEvent">QStateMachine::postEvent</a>().</p> <p>When posting a custom event to the state machine, you typically also have one or more custom transitions that can be triggered from events of that type. To create such a transition, you subclass <a href="qml-qtqml-statemachine-qabstracttransition.html">QAbstractTransition</a> and reimplement <a href="qabstracttransition.html#eventTest">eventTest</a>(), where you check if an event matches your event type (and optionally other criteria, e.g. attributes of the event object).</p> <p>Here we define our own custom event type, <code>StringEvent</code>, for posting strings to the state machine:</p> <pre data-language="cpp">struct StringEvent : public QEvent
{
    StringEvent(const QString &amp;val)
    : QEvent(QEvent::Type(QEvent::User+1)),
      value(val) {}

    QString value;
};</pre> <p>Next, we define a transition that only triggers when the event's string matches a particular string (a <i>guarded</i> transition):</p> <pre data-language="cpp">class StringTransition : public QAbstractTransition
{
    Q_OBJECT

public:
    StringTransition(const QString &amp;value)
        : m_value(value) {}

protected:
    bool eventTest(QEvent *e) override
    {
        if (e-&gt;type() != QEvent::Type(QEvent::User+1)) // StringEvent
            return false;
        StringEvent *se = static_cast&lt;StringEvent*&gt;(e);
        return (m_value == se-&gt;value);
    }

    void onTransition(QEvent *) override {}

private:
    QString m_value;
};</pre> <p>In the <a href="qabstracttransition.html#eventTest">eventTest</a>() reimplementation, we first check if the event type is the desired one; if so, we cast the event to a <code>StringEvent</code> and perform the string comparison.</p> <p>The following is a statechart that uses the custom event and transition:</p> <p class="centerAlign"><img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAxAAAACwBAMAAABtI5W9AAAAD1BMVEVHcEwKChYAAAD///8AAAABISMEAAAAA3RSTlMADAPPytpoAAAEf0lEQVR42u2dAXKiMBRA2U4OsDAeQB1vIAeI5d//TCshAnbFCgnmB9+bdjsdqfuTl59PgLRFAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAfIyJHukGFB0wowHmQy56eQAT0M5NIRVcgAkYiSrpCQ4lARHJOiEAEUCP08eXXEZw1IQJGRaJkZZ2aw+7qYYeI9HPTobzyTUeoMHG09IOSs1i6QAmkBCkBiGBuAlKClABE5Dc3YUNJSiBCSUogQklKIEKJCE5ilcxNiFCSEohQkhKISC/BIkKPCYsIHSYMIpSYsCwkdJhAhBITggg9FVte5nufKs4cYgxu4/ll6lStzCHG4Jw4z6CuiHEtmjmNPKfZFpxDjG8dbImGWw4xImIrIuZlfZq8zyFGRGxeRP34lctfPTHWoifG9UQ0+kU05/oDRJz1i5gKcjMiupTXLcJPS9sW0WSQEc0nZEQ+IjZeI+oMRGiLcZ1CKBkUa5lMiC2dNTUZnDU1UyEi4t0x1mdEqIix2boIEfdPo1lEG6MoivH9F9T+EiMiEPFbI+3dd0amXvmBub5s+70Bpj/amkIsIuY00j4UUYSLKBCxRESBiIQijNjrR2Hbz2vftfORuEc4jd+L1E4v1u/UE/tURPvTpj8QEbMaabtPcV+sdfuPjL0Nbdv58CKmd2LY0fHjA+OLCChkDzK+DdSO3yQQmcn/IrovMgz+vv9HIvwmMfdbZ7v/1I4CuDkY3uKucwJijFTIpkRE3OgTMjWNRdiXRExlxHMRoRkRXsh0i+iy4LEItwNGhjRxifBERJshq4iIUcjEb8B1hcxIV9M0iRj67aEIucuIYmJqsv1WvlVERClk/SCx7meNn4uLIg8RffjGPkn+94gIK2SdQnOL1Aw71JWKGAabn5D8OEp41hSlkCkX0Q4bP9iHSXYk4jqPusbJ5PQ7iLhfR/QibPhgiVHIrgca3/u/iVi8Vyb2YsnGGibOgUuwwBgjFLLXRcjivTJRRdwm+wjLHN8HzsSaIl4qZC+LMMufR4+bEWJjr/xNdBELC9moikyfNTXLH4NWfx1HAtc6sQqZ7QvZbR0xEmHvEmJRSui/oCbxY4xWyPoLx/1ZRS3uRvP8lMjgyqbEjTFiIRvepD+rkO5G+voiJAGRB0v8QuZTw3QJ0abE/Lnp8zJivVpmbuO02aQIyeTGkNyJKDcnQrK5QyebFrFkHSGJaHyJ2KKICCvr92XEabsZEeNa0/vm0A2LsEU2In6cNW2vWGcS4891BCLSxOjm0K/RyrpCRIoYu1r2NbrWhIgkMfqLJqf+6uv8vwWLiIgc+vsRiEj77OvulhBVgYiUIg7dPesFCYGIuJTu2duyKhCRVsSxdOwRkXp/RGui2heIYFcpIhCBCGJEBCIQgQhEIIJGfoyI07w21ktW758QIyK2IuJrXt5fKmJcqZG7eYOtIsaV+DPnL1pd0mR9DjGGD7dyxm8bSTTYcogxHH8v4yWqPTFqaGW6Nh4/wAMAAAAAAAAAAAAAAAAAAAAAAAAAAADAPf8A1fnQD6t/u3kAAAAASUVORK5CYII="></p>
<p>Here's what the implementation of the statechart looks like:</p> <pre data-language="cpp">    QStateMachine machine;
    QState *s1 = new QState();
    QState *s2 = new QState();
    QFinalState *done = new QFinalState();

    StringTransition *t1 = new StringTransition("Hello");
    t1-&gt;setTargetState(s2);
    s1-&gt;addTransition(t1);
    StringTransition *t2 = new StringTransition("world");
    t2-&gt;setTargetState(done);
    s2-&gt;addTransition(t2);

    machine.addState(s1);
    machine.addState(s2);
    machine.addState(done);
    machine.setInitialState(s1);</pre> <p>Once the machine is started, we can post events to it.</p> <pre data-language="cpp">    machine.postEvent(new StringEvent("Hello"));
    machine.postEvent(new StringEvent("world"));</pre> <p>An event that is not handled by any relevant transition will be silently consumed by the state machine. It can be useful to group states and provide a default handling of such events; for example, as illustrated in the following statechart:</p> <p class="centerAlign"><img alt="" src="data:image/png;base64,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"></p>
<p>For deeply nested statecharts, you can add such "fallback" transitions at the level of granularity that's most appropriate.</p> <h2 id="using-restore-policy-to-automatically-restore-properties">Using Restore Policy To Automatically Restore Properties
</h2> <p>In some state machines it can be useful to focus the attention on assigning properties in states, not on restoring them when the state is no longer active. If you know that a property should always be restored to its initial value when the machine enters a state that does not explicitly give the property a value, you can set the global restore policy to QStateMachine::RestoreProperties.</p> <pre data-language="cpp">QStateMachine machine;
machine.setGlobalRestorePolicy(QStateMachine::RestoreProperties);</pre> <p>When this restore policy is set, the machine will automatically restore all properties. If it enters a state where a given property is not set, it will first search the hierarchy of ancestors to see if the property is defined there. If it is, the property will be restored to the value defined by the closest ancestor. If not, it will be restored to its initial value (i.e. the value of the property before any property assignments in states were executed.)</p> <p>Take the following code:</p> <pre data-language="cpp">    QStateMachine machine;
    machine.setGlobalRestorePolicy(QStateMachine::RestoreProperties);

    QState *s1 = new QState();
    s1-&gt;assignProperty(object, "fooBar", 1.0);
    machine.addState(s1);
    machine.setInitialState(s1);

    QState *s2 = new QState();
    machine.addState(s2);</pre> <p>Lets say the property <code>fooBar</code> is 0.0 when the machine starts. When the machine is in state <code>s1</code>, the property will be 1.0, since the state explicitly assigns this value to it. When the machine is in state <code>s2</code>, no value is explicitly defined for the property, so it will implicitly be restored to 0.0.</p> <p>If we are using nested states, the parent defines a value for the property which is inherited by all descendants that do not explicitly assign a value to the property.</p> <pre data-language="cpp">    QStateMachine machine;
    machine.setGlobalRestorePolicy(QStateMachine::RestoreProperties);

    QState *s1 = new QState();
    s1-&gt;assignProperty(object, "fooBar", 1.0);
    machine.addState(s1);
    machine.setInitialState(s1);

    QState *s2 = new QState(s1);
    s2-&gt;assignProperty(object, "fooBar", 2.0);
    s1-&gt;setInitialState(s2);

    QState *s3 = new QState(s1);</pre> <p>Here <code>s1</code> has two children: <code>s2</code> and <code>s3</code>. When <code>s2</code> is entered, the property <code>fooBar</code> will have the value 2.0, since this is explicitly defined for the state. When the machine is in state <code>s3</code>, no value is defined for the state, but <code>s1</code> defines the property to be 1.0, so this is the value that will be assigned to <code>fooBar</code>.</p> <h2 id="animations-and-states-machines">Animations and States Machines
</h2> <p>The State Machine API connects with the <a href="https://doc.qt.io/qt-6.2/animation-overview.html">The Animation Framework</a> to allow automatically animating properties as they are assigned in states.</p> <p>The state machine provides a special state that can play an animation. A <a href="qstate.html">QState</a> can also set properties when the state is entered or exited, and this special animation state will interpolate between these values when given a <a href="qpropertyanimation.html">QPropertyAnimation</a>.</p> <p>We can associate one or more animations to a transition between states using a <a href="qml-qtqml-statemachine-qsignaltransition.html">QSignalTransition</a> or <a href="qeventtransition.html">QEventTransition</a> class. These classes are both derived from <a href="qml-qtqml-statemachine-qabstracttransition.html">QAbstractTransition</a>, which defines the convenience function <a href="qabstracttransition.html#addAnimation">addAnimation</a>() that enables the appending of one or more animations triggered when the transition occurs.</p> <p>We also have the possibility to associate properties with the states rather than setting the start and end values ourselves.</p> <p>Say we have the following code:</p> <pre data-language="cpp">    QState *s1 = new QState();
    QState *s2 = new QState();

    s1-&gt;assignProperty(button, "geometry", QRectF(0, 0, 50, 50));
    s2-&gt;assignProperty(button, "geometry", QRectF(0, 0, 100, 100));

    s1-&gt;addTransition(button, &amp;QPushButton::clicked, s2);</pre> <p>Here we define two states of a user interface. In <code>s1</code> the <code>button</code> is small, and in <code>s2</code> it is bigger. If we click the button to transition from <code>s1</code> to <code>s2</code>, the geometry of the button will be set immediately when a given state has been entered. If we want the transition to be smooth, however, all we need to do is make a <a href="qpropertyanimation.html">QPropertyAnimation</a> and add this to the transition object.</p> <pre data-language="cpp">    QState *s1 = new QState();
    QState *s2 = new QState();

    s1-&gt;assignProperty(button, "geometry", QRectF(0, 0, 50, 50));
    s2-&gt;assignProperty(button, "geometry", QRectF(0, 0, 100, 100));

    QSignalTransition *transition = s1-&gt;addTransition(button, &amp;QPushButton::clicked, s2);
    transition-&gt;addAnimation(new QPropertyAnimation(button, "geometry"));</pre> <p>Adding an animation for the property in question means that the property assignment will no longer take immediate effect when the state has been entered. Instead, the animation will start playing when the state has been entered and smoothly animate the property assignment. Since we do not set the start value or end value of the animation, these will be set implicitly. The start value of the animation will be the property's current value when the animation starts, and the end value will be set based on the property assignments defined for the state.</p> <p>If the global restore policy of the state machine is set to QStateMachine::RestoreProperties, it is possible to also add animations for the property restorations.</p> <h2 id="detecting-that-all-properties-have-been-set-in-a-state">Detecting That All Properties Have Been Set In A State
</h2> <p>When animations are used to assign properties, a state no longer defines the exact values that a property will have when the machine is in the given state. While the animation is running, the property can potentially have any value, depending on the animation.</p> <p>In some cases, it can be useful to be able to detect when the property has actually been assigned the value defined by a state.</p> <p>Say we have the following code:</p> <pre data-language="cpp">    QMessageBox *messageBox = new QMessageBox(mainWindow);
    messageBox-&gt;addButton(QMessageBox::Ok);
    messageBox-&gt;setText("Button geometry has been set!");
    messageBox-&gt;setIcon(QMessageBox::Information);

    QState *s1 = new QState();

    QState *s2 = new QState();
    s2-&gt;assignProperty(button, "geometry", QRectF(0, 0, 50, 50));
    connect(s2, &amp;QState::entered, messageBox, SLOT(exec()));

    s1-&gt;addTransition(button, &amp;QPushButton::clicked, s2);</pre> <p>When <code>button</code> is clicked, the machine will transition into state <code>s2</code>, which will set the geometry of the button, and then pop up a message box to alert the user that the geometry has been changed.</p> <p>In the normal case, where animations are not used, this will operate as expected. However, if an animation for the <code>geometry</code> of <code>button</code> is set on the transition between <code>s1</code> and <code>s2</code>, the animation will be started when <code>s2</code> is entered, but the <code>geometry</code> property will not actually reach its defined value before the animation is finished running. In this case, the message box will pop up before the geometry of the button has actually been set.</p> <p>To ensure that the message box does not pop up until the geometry actually reaches its final value, we can use the state's <a href="qstate.html#propertiesAssigned">propertiesAssigned</a>() signal. The <a href="qstate.html#propertiesAssigned">propertiesAssigned</a>() signal will be emitted when the property is assigned its final value, whether this is done immediately or after the animation has finished playing.</p> <pre data-language="cpp">    QMessageBox *messageBox = new QMessageBox(mainWindow);
    messageBox-&gt;addButton(QMessageBox::Ok);
    messageBox-&gt;setText("Button geometry has been set!");
    messageBox-&gt;setIcon(QMessageBox::Information);

    QState *s1 = new QState();

    QState *s2 = new QState();
    s2-&gt;assignProperty(button, "geometry", QRectF(0, 0, 50, 50));

    QState *s3 = new QState();
    connect(s3, &amp;QState::entered, messageBox, SLOT(exec()));

    s1-&gt;addTransition(button, &amp;QPushButton::clicked, s2);
    s2-&gt;addTransition(s2, &amp;QState::propertiesAssigned, s3);</pre> <p>In this example, when <code>button</code> is clicked, the machine will enter <code>s2</code>. It will remain in state <code>s2</code> until the <code>geometry</code> property has been set to <code>QRect(0, 0, 50, 50)</code>. Then it will transition into <code>s3</code>. When <code>s3</code> is entered, the message box will pop up. If the transition into <code>s2</code> has an animation for the <code>geometry</code> property, then the machine will stay in <code>s2</code> until the animation has finished playing. If there is no such animation, it will simply set the property and immediately enter state <code>s3</code>.</p> <p>Either way, when the machine is in state <code>s3</code>, you are guaranteed that the property <code>geometry</code> has been assigned the defined value.</p> <p>If the global restore policy is set to QStateMachine::RestoreProperties, the state will not emit the <a href="qstate.html#propertiesAssigned">propertiesAssigned</a>() signal until these have been executed as well.</p> <h2 id="what-happens-if-a-state-is-exited-before-the-animation-has-finished">What Happens If A State Is Exited Before The Animation Has Finished
</h2> <p>If a state has property assignments, and the transition into the state has animations for the properties, the state can potentially be exited before the properties have been assigned to the values defines by the state. This is true in particular when there are transitions out from the state that do not depend on the <a href="qstate.html#propertiesAssigned">propertiesAssigned</a>() signal, as described in the previous section.</p> <p>The State Machine API guarantees that a property assigned by the state machine either:</p> <ul> <li>Has a value explicitly assigned to the property.</li> <li>Is currently being animated into a value explicitly assigned to the property.</li> </ul> <p>When a state is exited prior to the animation finishing, the behavior of the state machine depends on the target state of the transition. If the target state explicitly assigns a value to the property, no additional action will be taken. The property will be assigned the value defined by the target state.</p> <p>If the target state does not assign any value to the property, there are two options: By default, the property will be assigned the value defined by the state it is leaving (the value it would have been assigned if the animation had been permitted to finish playing). If a global restore policy is set, however, this will take precedence, and the property will be restored as usual.</p> <h2 id="default-animations">Default Animations
</h2> <p>As described earlier, you can add animations to transitions to make sure property assignments in the target state are animated. If you want a specific animation to be used for a given property regardless of which transition is taken, you can add it as a default animation to the state machine. This is in particular useful when the properties assigned (or restored) by specific states is not known when the machine is constructed.</p> <pre data-language="cpp">QState *s1 = new QState();
QState *s2 = new QState();

s2-&gt;assignProperty(object, "fooBar", 2.0);
s1-&gt;addTransition(s2);

QStateMachine machine;
machine.setInitialState(s1);
machine.addDefaultAnimation(new QPropertyAnimation(object, "fooBar"));</pre> <p>When the machine is in state <code>s2</code>, the machine will play the default animation for the property <code>fooBar</code> since this property is assigned by <code>s2</code>.</p> <p>Note that animations explicitly set on transitions will take precedence over any default animation for the given property.</p> <h2 id="nesting-state-machines">Nesting State Machines
</h2> <p><a href="qstatemachine.html">QStateMachine</a> is a subclass of <a href="qstate.html">QState</a>. This allows for a state machine to be a child state of another machine. <a href="qstatemachine.html">QStateMachine</a> reimplements <a href="qstate.html#onEntry">QState::onEntry</a>() and calls <a href="qstatemachine.html#start">QStateMachine::start</a>(), so that when the child state machine is entered, it will automatically start running.</p> <p>The parent state machine treats the child machine as an <i>atomic</i> state in the state machine algorithm. The child state machine is self-contained; it maintains its own event queue and configuration. In particular, note that the <a href="qstatemachine.html#configuration">configuration</a>() of the child machine is not part of the parent machine's configuration (only the child machine itself is).</p> <p>States of the child state machine cannot be specified as targets of transitions in the parent state machine; only the child state machine itself can. Conversely, states of the parent state machine cannot be specified as targets of transitions in the child state machine. The child state machine's <a href="qstate.html#finished">finished</a>() signal can be used to trigger a transition in the parent machine.</p>  <p><b>See also </b><a href="https://doc.qt.io/qt-6.2/qtstatemachine-overview.html">Qt State Machine Overview</a> and <a href="qmlstatemachine-qml-guide.html">Qt State Machine QML Guide</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qtstatemachine-cpp-guide.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qtstatemachine-cpp-guide.html</a>
  </p>
</div>
