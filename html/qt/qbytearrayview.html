<h1 class="title">QByteArrayView Class</h1>  <p>The QByteArrayView class provides a view on an array of bytes with a read-only subset of the <a href="qbytearray.html">QByteArray</a> API. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QByteArrayView&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 6.0</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qbytearrayview-members.html">List of all members, including inherited members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="17-qdoc-commands-thread.html#reentrant">reentrant</a>.</p> <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#const_iterator-typedef">const_iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#const_pointer-typedef">const_pointer</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#const_reference-typedef">const_reference</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#const_reverse_iterator-typedef">const_reverse_iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#difference_type-typedef">difference_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#iterator-typedef">iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#pointer-typedef">pointer</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#reference-typedef">reference</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#reverse_iterator-typedef">reverse_iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#size_type-typedef">size_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#storage_type-typedef">storage_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign"><b><a href="qbytearrayview.html#value_type-typedef">value_type</a></b></td>
</tr> </table> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#QByteArrayView-7">QByteArrayView</a></b>(const char (&amp;)[Size] <i>data</i> = Size)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#QByteArrayView-6">QByteArrayView</a></b>(const Container &amp;<i>c</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#QByteArrayView-5">QByteArrayView</a></b>(const QByteArray &amp;<i>byteArray</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#QByteArrayView-4">QByteArrayView</a></b>(const Byte *<i>data</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#QByteArrayView-3">QByteArrayView</a></b>(const Byte *<i>first</i>, const Byte *<i>last</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#QByteArrayView-2">QByteArrayView</a></b>(const Byte *<i>data</i>, qsizetype <i>len</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#QByteArrayView-1">QByteArrayView</a></b>(std::nullptr_t)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#at">at</a></b>(qsizetype <i>n</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#back">back</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#begin">begin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#cbegin">cbegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#cend">cend</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#chop">chop</a></b>(qsizetype <i>length</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#chopped">chopped</a></b>(qsizetype <i>length</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#compare">compare</a></b>(QByteArrayView <i>bv</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_pointer </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#constData">constData</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#contains">contains</a></b>(QByteArrayView <i>bv</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#contains-1">contains</a></b>(char <i>ch</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#count">count</a></b>(QByteArrayView <i>bv</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#count-1">count</a></b>(char <i>ch</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_reverse_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#crbegin">crbegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_reverse_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#crend">crend</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_pointer </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#data">data</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#empty">empty</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#end">end</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#endsWith">endsWith</a></b>(QByteArrayView <i>bv</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#endsWith-1">endsWith</a></b>(char <i>ch</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#first">first</a></b>(qsizetype <i>n</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#front">front</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#indexOf">indexOf</a></b>(QByteArrayView <i>bv</i>, qsizetype <i>from</i> = 0) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#indexOf-1">indexOf</a></b>(char <i>ch</i>, qsizetype <i>from</i> = 0) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#isEmpty">isEmpty</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#isNull">isNull</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#last">last</a></b>(qsizetype <i>n</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#lastIndexOf">lastIndexOf</a></b>(QByteArrayView <i>bv</i>, qsizetype <i>from</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#lastIndexOf-1">lastIndexOf</a></b>(QByteArrayView <i>bv</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#lastIndexOf-2">lastIndexOf</a></b>(char <i>ch</i>, qsizetype <i>from</i> = -1) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#length">length</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_reverse_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#rbegin">rbegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView::const_reverse_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#rend">rend</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#size">size</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#sliced">sliced</a></b>(qsizetype <i>pos</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#sliced-1">sliced</a></b>(qsizetype <i>pos</i>, qsizetype <i>n</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#startsWith">startsWith</a></b>(QByteArrayView <i>bv</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#startsWith-1">startsWith</a></b>(char <i>ch</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArray </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#toByteArray">toByteArray</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#truncate">truncate</a></b>(qsizetype <i>length</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> char </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#operator-5b-5d">operator[]</a></b>(qsizetype <i>n</i>) const</td>
</tr> </table> <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QByteArrayView </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#fromArray">fromArray</a></b>(const Byte (&amp;)[Size] <i>data</i> = Size)</td>
</tr> </table> <h2 id="related-non-members">Related Non-Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#operator-not-eq">operator!=</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#operator-lt">operator&lt;</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#operator-lt-eq">operator&lt;=</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#operator-eq-eq">operator==</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#operator-gt">operator&gt;</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qbytearrayview.html#operator-gt-eq">operator&gt;=</a></b>(QByteArrayView <i>lhs</i>, QByteArrayView <i>rhs</i>)</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>A QByteArrayView references a contiguous portion of raw bytes it does not own. It acts as an interface type to all kinds of byte-array-like data, without the need to construct a <a href="qbytearray.html">QByteArray</a> first.</p> <p>The byte array data may be represented as an array (or an array-compatible data-structure such as <a href="qbytearray.html">QByteArray</a>, std::basic_string, etc.) of <code>char</code>, <code>signed char</code>, <code>unsigned char</code> or <code>std::byte</code>.</p> <p>QByteArrayView is designed as an interface type; its main use-case is as a function parameter type. When QByteArrayViews are used as automatic variables or data members, care must be taken to ensure that the referenced data (for example, owned by a <a href="qbytearray.html">QByteArray</a>) outlives the QByteArrayView on all code paths, lest the byte array view ends up referencing deleted data.</p> <p>When used as an interface type, QByteArrayView allows a single function to accept a wide variety of byte-array-like data sources. One function accepting QByteArrayView thus replaces several function overloads (taking, for example, <a href="qbytearray.html">QByteArray</a>, const char *, etc.) while at the same time enabling even more byte array data sources to be passed to the function.</p> <p>QByteArrayView should be passed by value, not by reference-to-const:</p> <pre data-language="cpp">    void myfun1(QByteArrayView bv);        // preferred
    void myfun2(const QByteArrayView &amp;bv); // compiles and works, but slower</pre> <p>If you want to give your users maximum freedom in what type of data they can pass to your function, accompany the QByteArrayView overload with overloads for</p> <ul> <li>
<i>char</i>: this overload can delegate to the QByteArrayView version:<pre data-language="cpp">    void fun(QByteArrayView bv);
    void fun(char ch) { fun(QByteArrayView(&amp;ch, 1)); }</pre> <p>even though, for technical reasons, QByteArrayView cannot provide a char constructor by itself.</p> </li> <li>
<i>QByteArray</i>: if you store an unmodified copy of the byte array and thus would like to take advantage of <a href="qbytearray.html">QByteArray</a>'s implicit sharing.</li> </ul> <p>QByteArrayView can also be used as the return value of a function. If you call a function returning QByteArrayView, take extra care to not keep the QByteArrayView around longer than the function promises to keep the referenced data alive. If in doubt, obtain a strong reference to the data by calling <a href="qbytearrayview.html#toByteArray">toByteArray</a>() to convert the QByteArrayView into a <a href="qbytearray.html">QByteArray</a>.</p> <h3 id="compatible-byte-types">Compatible Byte Types
</h3> <p>QByteArrayView can be constructed on any container of bytes, where the byte type is one of:</p> <ul> <li>
<code>char</code> (both signed and unsigned)</li> <li><code>std::byte</code></li> </ul>  <p><b>See also </b><a href="qbytearray.html">QByteArray</a> and <a href="qstringview.html">QStringView</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="const_iterator-typedef">QByteArrayView::<span class="name">const_iterator</span>
</h3> <p>This typedef provides an STL-style const iterator for <a href="qbytearrayview.html">QByteArrayView</a>.</p> <p><b>See also </b><a href="qbytearrayview.html#iterator-typedef">iterator</a> and <a href="qbytearrayview.html#const_reverse_iterator-typedef">const_reverse_iterator</a>.</p>   <h3 class="fn" id="const_pointer-typedef">QByteArrayView::<span class="name">const_pointer</span>
</h3> <p>Alias for <code>value_type *</code>. Provided for compatibility with the STL.</p>   <h3 class="fn" id="const_reference-typedef">QByteArrayView::<span class="name">const_reference</span>
</h3> <p>Alias for <code>value_type &amp;</code>. Provided for compatibility with the STL.</p>   <h3 class="fn" id="const_reverse_iterator-typedef">QByteArrayView::<span class="name">const_reverse_iterator</span>
</h3> <p>This typedef provides an STL-style const reverse iterator for <a href="qbytearrayview.html">QByteArrayView</a>.</p> <p><b>See also </b><a href="qbytearrayview.html#reverse_iterator-typedef">reverse_iterator</a> and <a href="qbytearrayview.html#const_iterator-typedef">const_iterator</a>.</p>   <h3 class="fn" id="difference_type-typedef">QByteArrayView::<span class="name">difference_type</span>
</h3> <p>Alias for <code>std::ptrdiff_t</code>. Provided for compatibility with the STL.</p>   <h3 class="fn" id="iterator-typedef">QByteArrayView::<span class="name">iterator</span>
</h3> <p>This typedef provides an STL-style const iterator for <a href="qbytearrayview.html">QByteArrayView</a>.</p> <p><a href="qbytearrayview.html">QByteArrayView</a> does not support mutable iterators, so this is the same as <a href="qbytearrayview.html#const_iterator-typedef">const_iterator</a>.</p> <p><b>See also </b><a href="qbytearrayview.html#const_iterator-typedef">const_iterator</a> and <a href="qbytearrayview.html#reverse_iterator-typedef">reverse_iterator</a>.</p>   <h3 class="fn" id="pointer-typedef">QByteArrayView::<span class="name">pointer</span>
</h3> <p>Alias for <code>value_type *</code>. Provided for compatibility with the STL.</p> <p><a href="qbytearrayview.html">QByteArrayView</a> does not support mutable pointers, so this is the same as <a href="qbytearrayview.html#const_pointer-typedef">const_pointer</a>.</p>   <h3 class="fn" id="reference-typedef">QByteArrayView::<span class="name">reference</span>
</h3> <p>Alias for <code>value_type &amp;</code>. Provided for compatibility with the STL.</p> <p><a href="qbytearrayview.html">QByteArrayView</a> does not support mutable references, so this is the same as <a href="qbytearrayview.html#const_reference-typedef">const_reference</a>.</p>   <h3 class="fn" id="reverse_iterator-typedef">QByteArrayView::<span class="name">reverse_iterator</span>
</h3> <p>This typedef provides an STL-style const reverse iterator for <a href="qbytearrayview.html">QByteArrayView</a>.</p> <p><a href="qbytearrayview.html">QByteArrayView</a> does not support mutable reverse iterators, so this is the same as <a href="qbytearrayview.html#const_reverse_iterator-typedef">const_reverse_iterator</a>.</p> <p><b>See also </b><a href="qbytearrayview.html#const_reverse_iterator-typedef">const_reverse_iterator</a> and <a href="qbytearrayview.html#iterator-typedef">iterator</a>.</p>   <h3 class="fn" id="size_type-typedef">QByteArrayView::<span class="name">size_type</span>
</h3> <p>Alias for qsizetype. Provided for compatibility with the STL.</p>   <h3 class="fn" id="storage_type-typedef">QByteArrayView::<span class="name">storage_type</span>
</h3> <p>Alias for <code>char</code>.</p>   <h3 class="fn" id="value_type-typedef">QByteArrayView::<span class="name">value_type</span>
</h3> <p>Alias for <code>const char</code>. Provided for compatibility with the STL.</p>    <h2>Member Function Documentation</h2>  <div class="fngroup"> <h3 class="fn fngroupitem" id="lastIndexOf">
<span class="type">qsizetype</span> QByteArrayView::<span class="name">lastIndexOf</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>bv</i>, <span class="type">qsizetype</span> <i>from</i>) const
</h3>
<h3 class="fn fngroupitem" id="lastIndexOf-2">
<span class="type">qsizetype</span> QByteArrayView::<span class="name">lastIndexOf</span>(<span class="type">char</span> <i>ch</i>, <span class="type">qsizetype</span> <i>from</i> = -1) const
</h3>
</div> <p>Returns the index position of either the start of the last occurrence of the sequence of bytes viewed by <i>bv</i> or the last occurrence of byte <i>ch</i>, respectively, in this byte array view, searching backward from index position <i>from</i>. If <i>from</i> is -1, the search starts at the last character; if <i>from</i> is -2, at the next to last character and so on. Returns -1 if no match is found.</p> <div class="admonition note"> <p><b>Note: </b>When searching for a 0-length <i>bv</i>, the match at the end of the data is excluded from the search by a negative <i>from</i>, even though <code>-1</code> is normally thought of as searching from the end of the view: the match at the end is <i>after</i> the last character, so it is excluded. To include such a final empty match, either give a positive value for <i>from</i> or omit the <i>from</i> parameter entirely.</p> </div> <p><b>See also </b><a href="qbytearrayview.html#indexOf">indexOf</a>() and <a href="qbytearrayview.html#contains">contains</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="contains">
<span class="type">bool</span> QByteArrayView::<span class="name">contains</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>bv</i>) const
</h3>
<h3 class="fn fngroupitem" id="contains-1">
<span class="type">bool</span> QByteArrayView::<span class="name">contains</span>(<span class="type">char</span> <i>ch</i>) const
</h3>
</div> <p>Returns <code>true</code> if this byte array view contains an occurrence of the sequence of bytes viewed by <i>bv</i> or character <i>ch</i>, respectively; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qbytearrayview.html#indexOf">indexOf</a>() and <a href="qbytearrayview.html#lastIndexOf">lastIndexOf</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="indexOf">
<span class="type">qsizetype</span> QByteArrayView::<span class="name">indexOf</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>bv</i>, <span class="type">qsizetype</span> <i>from</i> = 0) const
</h3>
<h3 class="fn fngroupitem" id="indexOf-1">
<span class="type">qsizetype</span> QByteArrayView::<span class="name">indexOf</span>(<span class="type">char</span> <i>ch</i>, <span class="type">qsizetype</span> <i>from</i> = 0) const
</h3>
</div> <p>Returns the index position of either the start of the first occurrence of the sequence of bytes viewed by <i>bv</i> or the first occurrence of byte <i>ch</i>, respectively, in this byte array view, searching forward from index position <i>from.Returns</i> -1 if no match is found.</p> <p>If <i>from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.</p> <p><b>See also </b><a href="qbytearrayview.html#lastIndexOf">lastIndexOf</a>() and <a href="qbytearrayview.html#contains">contains</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="endsWith">
<span class="type">bool</span> QByteArrayView::<span class="name">endsWith</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>bv</i>) const
</h3>
<h3 class="fn fngroupitem" id="endsWith-1">
<span class="type">bool</span> QByteArrayView::<span class="name">endsWith</span>(<span class="type">char</span> <i>ch</i>) const
</h3>
</div> <p>Returns <code>true</code> if this byte array view ends with byte array view <i>bv</i> or character <i>ch</i>, respectively; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qbytearrayview.html#startsWith">startsWith</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="startsWith">
<span class="type">bool</span> QByteArrayView::<span class="name">startsWith</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>bv</i>) const
</h3>
<h3 class="fn fngroupitem" id="startsWith-1">
<span class="type">bool</span> QByteArrayView::<span class="name">startsWith</span>(<span class="type">char</span> <i>ch</i>) const
</h3>
</div> <p>Returns <code>true</code> if this byte array view starts with byte array view <i>bv</i> or character <i>ch</i>, respectively; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qbytearrayview.html#endsWith">endsWith</a>().</p>   <h3 class="fn" id="QByteArrayView-7">template &lt;size_t Size&gt; QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type">char</span> (&amp;)[<span class="type">Size</span>] <i>data</i> = Size)
</h3> <p>Constructs a byte array view on the char array <i>data</i>. The view covers the array until the first <code>'\0'</code> is encountered, or <code>Size</code>, whichever comes first. If you need the full array, use <a href="qbytearrayview.html#fromArray">fromArray</a>() instead.</p> <p><i>data</i> must remain valid for the lifetime of this byte array view object.</p> <div class="admonition note"> <p><b>Note: </b>This constructor is only available for char array literals. The reasoning behind that is for compatibility with C-libraries which predefine "large-enough" arrays, but only use some of the preallocated space. To support this in an intuitive way in an implicit constructor overload, we need to stop at the first <code>char(0)</code>. This is logical for a char array, but not for a <code>std::byte</code> array.</p> </div> <p><b>See also </b><a href="qbytearrayview.html#fromArray">fromArray</a>.</p>   <h3 class="fn" id="QByteArrayView-6">template &lt;typename Container, if_compatible_container&lt;Container&gt;&gt; QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type">Container</span> &amp;<i>c</i>)
</h3> <p>Constructs a byte array view on the array-like container <i>c</i>. The length and data are set via <code>std::size(c)</code> and <code>std::data(c)</code> respectively.</p> <p>The container's data must remain valid for the lifetime of this byte array view object.</p> <p>This constructor participates in overload resolution if <i>c</i> is any contiguous container container with elements of a compatible byte type.</p> <p><b>See also </b><a href="qbytearrayview.html#compatible-byte-types">Compatible Byte Types</a>.</p>   <h3 class="fn" id="QByteArrayView-5">QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp;<i>byteArray</i>)
</h3> <p>Constructs a byte array view on <i>byteArray</i>.</p> <p><code>byteArray.data()</code> must remain valid for the lifetime of this byte array view object.</p> <p>The byte array view will be null if and only if <code>byteArray.isNull()</code>.</p>   <h3 class="fn" id="QByteArrayView-4">template &lt;typename Byte&gt; QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type">Byte</span> *<i>data</i>)
</h3> <p>Constructs a byte array view on <i>data</i>. The length is determined by scanning for the first <code>Byte(0)</code>.</p> <p><i>data</i> must remain valid for the lifetime of this byte array view object.</p> <p>Passing <code>nullptr</code> as <i>data</i> is safe and results in a null byte array view.</p> <p>This constructor only participates in overload resolution if <i>data</i> is not an array and if <code>Byte</code> is a compatible byte type.</p> <p><b>See also </b><a href="qbytearrayview.html#compatible-byte-types">Compatible Byte Types</a>.</p>   <h3 class="fn" id="QByteArrayView-3">template &lt;typename Byte, if_compatible_byte&lt;Byte&gt;&gt; QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type">Byte</span> *<i>first</i>, const <span class="type">Byte</span> *<i>last</i>)
</h3> <p>Constructs a byte array view on <i>first</i> with length (<i>last</i> - <i>first</i>).</p> <p>The range <code>[first,last)</code> must remain valid for the lifetime of this QByteArrayView.</p> <p>Passing <code>\nullptr</code> as <i>first</i> is safe if <i>last</i> is <code>nullptr</code>, too, and results in a null byte array view.</p> <p>The behavior is undefined if <i>last</i> precedes <i>first</i>, or <i>first</i> is <code>nullptr</code> and <i>last</i> is not.</p> <p>This constructor only participates in overload resolution if <code>Byte</code> is a compatible byte type.</p> <p><b>See also </b><a href="qbytearrayview.html#compatible-byte-types">Compatible Byte Types</a>.</p>   <h3 class="fn" id="QByteArrayView-2">template &lt;typename Byte, if_compatible_byte&lt;Byte&gt;&gt; QByteArrayView::<span class="name">QByteArrayView</span>(const <span class="type">Byte</span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)
</h3> <p>Constructs a byte array view on <i>data</i> with length <i>len</i>.</p> <p>The range <code>[data,len)</code> must remain valid for the lifetime of this QByteArrayView.</p> <p>Passing <code>nullptr</code> as <i>data</i> is safe if <i>len</i> is 0, too, and results in a null byte array view.</p> <p>The behavior is undefined if <i>len</i> is negative or, when positive, if <i>data</i> is <code>nullptr</code>.</p> <p>This constructor only participates in overload resolution if <code>Byte</code> is a compatible byte type.</p> <p><b>See also </b><a href="qbytearrayview.html#compatible-byte-types">Compatible Byte Types</a>.</p>   <h3 class="fn" id="QByteArrayView-1">QByteArrayView::<span class="name">QByteArrayView</span>(<span class="type">std::nullptr_t</span>)
</h3> <p>Constructs a null byte array view.</p> <p><b>See also </b><a href="qbytearrayview.html#isNull">isNull</a>().</p>   <h3 class="fn" id="QByteArrayView">QByteArrayView::<span class="name">QByteArrayView</span>()
</h3> <p>Constructs a null byte array view.</p> <p><b>See also </b><a href="qbytearrayview.html#isNull">isNull</a>().</p>   <h3 class="fn" id="at">
<span class="type">char</span> QByteArrayView::<span class="name">at</span>(<span class="type">qsizetype</span> <i>n</i>) const
</h3> <p>Returns the character at position <i>n</i> in this byte array view.</p> <p>The behavior is undefined if <i>n</i> is negative or not less than <a href="qbytearrayview.html#size">size</a>().</p> <p><b>See also </b><a href="qbytearrayview.html#operator-5b-5d">operator[]</a>(), <a href="qbytearrayview.html#front">front</a>(), and <a href="qbytearrayview.html#back">back</a>().</p>   <h3 class="fn" id="back">
<span class="type">char</span> QByteArrayView::<span class="name">back</span>() const
</h3> <p>Returns the last byte in the byte array.</p> <p>This function is provided for STL compatibility.</p> <div class="admonition warning"> <p><b>Warning: </b>Calling this function on an empty byte array view constitutes undefined behavior.</p> </div> <p><b>See also </b><a href="qbytearrayview.html#front">front</a>().</p>   <h3 class="fn" id="begin">
<span class="type"><a href="qbytearrayview.html#const_iterator-typedef">QByteArrayView::const_iterator</a></span> QByteArrayView::<span class="name">begin</span>() const
</h3> <p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first byte in the byte array.</p> <p>This function is provided for STL compatibility.</p> <p><b>See also </b><a href="qbytearrayview.html#end">end</a>(), <a href="qbytearrayview.html#cbegin">cbegin</a>(), <a href="qbytearrayview.html#rbegin">rbegin</a>(), and <a href="qbytearrayview.html#data">data</a>().</p>   <h3 class="fn" id="cbegin">
<span class="type"><a href="qbytearrayview.html#const_iterator-typedef">QByteArrayView::const_iterator</a></span> QByteArrayView::<span class="name">cbegin</span>() const
</h3> <p>Same as <a href="qbytearrayview.html#begin">begin</a>().</p> <p>This function is provided for STL compatibility.</p> <p><b>See also </b><a href="qbytearrayview.html#cend">cend</a>(), <a href="qbytearrayview.html#begin">begin</a>(), <a href="qbytearrayview.html#crbegin">crbegin</a>(), and <a href="qbytearrayview.html#data">data</a>().</p>   <h3 class="fn" id="cend">
<span class="type"><a href="qbytearrayview.html#const_iterator-typedef">QByteArrayView::const_iterator</a></span> QByteArrayView::<span class="name">cend</span>() const
</h3> <p>Same as <a href="qbytearrayview.html#end">end</a>().</p> <p>This function is provided for STL compatibility.</p> <p><b>See also </b><a href="qbytearrayview.html#cbegin">cbegin</a>(), <a href="qbytearrayview.html#end">end</a>(), and <a href="qbytearrayview.html#crend">crend</a>().</p>   <h3 class="fn" id="chop">
<span class="type">void</span> QByteArrayView::<span class="name">chop</span>(<span class="type">qsizetype</span> <i>length</i>)
</h3> <p>Truncates this byte array view by <i>length</i> characters.</p> <p>Same as <code>*this = first(size() - length)</code>.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>length</i> &lt; 0 or <i>length</i> &gt; <a href="qbytearrayview.html#size">size</a>().</p> </div> <p><b>See also </b><a href="qbytearrayview.html#sliced">sliced</a>(), <a href="qbytearrayview.html#first">first</a>(), <a href="qbytearrayview.html#last">last</a>(), <a href="qbytearrayview.html#chopped">chopped</a>(), and <a href="qbytearrayview.html#truncate">truncate</a>().</p>   <h3 class="fn" id="chopped">
<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> QByteArrayView::<span class="name">chopped</span>(<span class="type">qsizetype</span> <i>length</i>) const
</h3> <p>Returns a copy of this byte array view that omits its last <i>length</i> bytes. In other words, returns a byte array view of length <a href="qbytearrayview.html#size">size</a>() - <i>length</i> starting at the beginning of this object.</p> <p>Same as <code>first(size() - length)</code>.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>length</i> &lt; 0 or <i>length</i> &gt; <a href="qbytearrayview.html#size">size</a>().</p> </div> <p><b>See also </b><a href="qbytearrayview.html#first">first</a>(), <a href="qbytearrayview.html#last">last</a>(), <a href="qbytearrayview.html#sliced">sliced</a>(), <a href="qbytearrayview.html#chop">chop</a>(), and <a href="qbytearrayview.html#truncate">truncate</a>().</p>   <h3 class="fn" id="compare">
<code>[since 6.2] </code><span class="type">int</span> QByteArrayView::<span class="name">compare</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>bv</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const
</h3> <p>Returns an integer less than, equal to, or greater than zero depending on whether this <a href="qbytearrayview.html">QByteArrayView</a> sorts before, at the same position as, or after the <a href="qbytearrayview.html">QByteArrayView</a> <i>bv</i>. The comparison is performed according to case sensitivity <i>cs</i>.</p> <p>This function was introduced in Qt 6.2.</p> <p><b>See also </b><a href="qbytearrayview.html#operator-eq-eq">operator==</a>().</p>   <h3 class="fn" id="constData">
<span class="type"><a href="qbytearrayview.html#const_pointer-typedef">QByteArrayView::const_pointer</a></span> QByteArrayView::<span class="name">constData</span>() const
</h3> <p>Returns a const <code>char</code> pointer to the first byte in the byte array.</p> <div class="admonition note"> <p><b>Note: </b>The character array represented by the return value is <i>not</i> guaranteed to be null-terminated. The returned pointer is only safe to use for accessing bytes at indices that are less than this byte array view's <a href="qbytearrayview.html#size">size</a>().</p> </div> <p><b>See also </b><a href="qbytearrayview.html#data">data</a>(), <a href="qbytearrayview.html#begin">begin</a>(), and <a href="qbytearrayview.html#end">end</a>().</p>   <h3 class="fn" id="count">
<span class="type">qsizetype</span> QByteArrayView::<span class="name">count</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>bv</i>) const
</h3> <p>Returns the number of (potentially overlapping) occurrences of the sequence of bytes viewed by <i>bv</i> in this byte array view.</p> <p><b>See also </b><a href="qbytearrayview.html#contains">contains</a>() and <a href="qbytearrayview.html#indexOf">indexOf</a>().</p>   <h3 class="fn" id="count-1">
<span class="type">qsizetype</span> QByteArrayView::<span class="name">count</span>(<span class="type">char</span> <i>ch</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns the number of occurrences of byte <i>ch</i> in this byte array view.</p> <p><b>See also </b><a href="qbytearrayview.html#contains">contains</a>() and <a href="qbytearrayview.html#indexOf">indexOf</a>().</p>   <h3 class="fn" id="crbegin">
<span class="type"><a href="qbytearrayview.html#const_reverse_iterator-typedef">QByteArrayView::const_reverse_iterator</a></span> QByteArrayView::<span class="name">crbegin</span>() const
</h3> <p>Same as <a href="qbytearrayview.html#rbegin">rbegin</a>().</p> <p>This function is provided for STL compatibility.</p> <p><b>See also </b><a href="qbytearrayview.html#crend">crend</a>(), <a href="qbytearrayview.html#rbegin">rbegin</a>(), and <a href="qbytearrayview.html#cbegin">cbegin</a>().</p>   <h3 class="fn" id="crend">
<span class="type"><a href="qbytearrayview.html#const_reverse_iterator-typedef">QByteArrayView::const_reverse_iterator</a></span> QByteArrayView::<span class="name">crend</span>() const
</h3> <p>Same as <a href="qbytearrayview.html#rend">rend</a>().</p> <p>This function is provided for STL compatibility.</p> <p><b>See also </b><a href="qbytearrayview.html#crbegin">crbegin</a>(), <a href="qbytearrayview.html#rend">rend</a>(), and <a href="qbytearrayview.html#cend">cend</a>().</p>   <h3 class="fn" id="data">
<span class="type"><a href="qbytearrayview.html#const_pointer-typedef">QByteArrayView::const_pointer</a></span> QByteArrayView::<span class="name">data</span>() const
</h3> <p>Returns a const <code>char</code> pointer to the first byte in the byte array.</p> <div class="admonition note"> <p><b>Note: </b>The character array represented by the return value is <i>not</i> guaranteed to be null-terminated. The returned pointer is only safe to use for accessing bytes at indices that are less than this byte array view's <a href="qbytearrayview.html#size">size</a>().</p> </div> <p><b>See also </b><a href="qbytearrayview.html#begin">begin</a>() and <a href="qbytearrayview.html#end">end</a>().</p>   <h3 class="fn" id="empty">
<span class="type">bool</span> QByteArrayView::<span class="name">empty</span>() const
</h3> <p>Returns <code>true</code> if this byte array view is empty - that is, <code>size() == 0</code>.</p> <p>This function is provided for STL compatibility.</p> <p><b>See also </b><a href="qbytearrayview.html#isEmpty">isEmpty</a>(), <a href="qbytearrayview.html#isNull">isNull</a>(), and <a href="qbytearrayview.html#size">size</a>().</p>   <h3 class="fn" id="end">
<span class="type"><a href="qbytearrayview.html#const_iterator-typedef">QByteArrayView::const_iterator</a></span> QByteArrayView::<span class="name">end</span>() const
</h3> <p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing just after the last byte in the byte array.</p> <p>This function is provided for STL compatibility.</p> <p><b>See also </b><a href="qbytearrayview.html#begin">begin</a>(), <a href="qbytearrayview.html#cend">cend</a>(), and <a href="qbytearrayview.html#rend">rend</a>().</p>   <h3 class="fn" id="first">
<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> QByteArrayView::<span class="name">first</span>(<span class="type">qsizetype</span> <i>n</i>) const
</h3> <p>Returns a byte array view that points to the first <i>n</i> bytes of this byte array view. Equivalent to <code>sliced(0, n)</code>.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>n</i> &lt; 0 or <i>n</i> &gt; <a href="qbytearrayview.html#size">size</a>().</p> </div> <p><b>See also </b><a href="qbytearrayview.html#last">last</a>(), <a href="qbytearrayview.html#startsWith">startsWith</a>(), <a href="qbytearrayview.html#chopped">chopped</a>(), <a href="qbytearrayview.html#chop">chop</a>(), and <a href="qbytearrayview.html#truncate">truncate</a>().</p>   <h3 class="fn" id="fromArray">
<code>[static] </code>template &lt;typename Byte, size_t Size&gt; <span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> QByteArrayView::<span class="name">fromArray</span>(const <span class="type">Byte</span> (&amp;)[<span class="type">Size</span>] <i>data</i> = Size)
</h3> <p>Constructs a byte array view on the array literal <i>data</i>. The view covers the full array. That includes the trailing null-terminator of <code>char</code> array literals. If you don't want the null-terminator included in the view, you can <a href="qbytearrayview.html#chop">chop</a>() it off when you are certain it is at the end. Alternatively you can use the constructor overload taking a char array literal which will create a view up to, but not including, the first null-terminator in the data.</p> <p>This function will work with any array literal of a compatible byte type.</p> <p><b>See also </b><a href="qbytearrayview.html#compatible-byte-types">Compatible Byte Types</a> and <a href="qbytearrayview.html">QByteArrayView</a>.</p>   <h3 class="fn" id="front">
<span class="type">char</span> QByteArrayView::<span class="name">front</span>() const
</h3> <p>Returns the first byte in the byte array.</p> <p>This function is provided for STL compatibility.</p> <div class="admonition warning"> <p><b>Warning: </b>Calling this function on an empty byte array view constitutes undefined behavior.</p> </div> <p><b>See also </b><a href="qbytearrayview.html#back">back</a>().</p>   <h3 class="fn" id="isEmpty">
<span class="type">bool</span> QByteArrayView::<span class="name">isEmpty</span>() const
</h3> <p>Returns <code>true</code> if this byte array view is empty - that is, <code>size() == 0</code>.</p> <p><b>See also </b><a href="qbytearrayview.html#empty">empty</a>(), <a href="qbytearrayview.html#isNull">isNull</a>(), and <a href="qbytearrayview.html#size">size</a>().</p>   <h3 class="fn" id="isNull">
<span class="type">bool</span> QByteArrayView::<span class="name">isNull</span>() const
</h3> <p>Returns <code>true</code> if this byte array view is null - that is, <code>data() == nullptr</code>.</p> <p><b>See also </b><a href="qbytearrayview.html#empty">empty</a>(), <a href="qbytearrayview.html#isEmpty">isEmpty</a>(), and <a href="qbytearrayview.html#size">size</a>().</p>   <h3 class="fn" id="last">
<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> QByteArrayView::<span class="name">last</span>(<span class="type">qsizetype</span> <i>n</i>) const
</h3> <p>Returns a byte array view that points to the last <i>n</i> bytes of this byte array view.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>n</i> &lt; 0 or <i>n</i> &gt; <a href="qbytearrayview.html#size">size</a>().</p> </div> <p><b>See also </b><a href="qbytearrayview.html#first">first</a>(), <a href="qbytearrayview.html#endsWith">endsWith</a>(), <a href="qbytearrayview.html#chopped">chopped</a>(), <a href="qbytearrayview.html#chop">chop</a>(), and <a href="qbytearrayview.html#truncate">truncate</a>().</p>   <h3 class="fn" id="lastIndexOf-1">
<code>[since 6.2] </code><span class="type">qsizetype</span> QByteArrayView::<span class="name">lastIndexOf</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>bv</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns the index position of the start of the last occurrence of the sequence of bytes viewed by <i>bv</i> in this byte array view, searching backward from the end of this byte array view. Returns -1 if no match is found.</p> <p>This function was introduced in Qt 6.2.</p> <p><b>See also </b><a href="qbytearrayview.html#indexOf">indexOf</a>() and <a href="qbytearrayview.html#contains">contains</a>().</p>   <h3 class="fn" id="length">
<span class="type">qsizetype</span> QByteArrayView::<span class="name">length</span>() const
</h3> <p>Same as <a href="qbytearrayview.html#size">size</a>().</p> <p><b>See also </b><a href="qbytearrayview.html#empty">empty</a>(), <a href="qbytearrayview.html#isEmpty">isEmpty</a>(), <a href="qbytearrayview.html#isNull">isNull</a>(), and <a href="qbytearrayview.html#size">size</a>().</p>   <h3 class="fn" id="rbegin">
<span class="type"><a href="qbytearrayview.html#const_reverse_iterator-typedef">QByteArrayView::const_reverse_iterator</a></span> QByteArrayView::<span class="name">rbegin</span>() const
</h3> <p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first byte in the byte array, in reverse order.</p> <p>This function is provided for STL compatibility.</p> <p><b>See also </b><a href="qbytearrayview.html#rend">rend</a>(), <a href="qbytearrayview.html#crbegin">crbegin</a>(), and <a href="qbytearrayview.html#begin">begin</a>().</p>   <h3 class="fn" id="rend">
<span class="type"><a href="qbytearrayview.html#const_reverse_iterator-typedef">QByteArrayView::const_reverse_iterator</a></span> QByteArrayView::<span class="name">rend</span>() const
</h3> <p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to one past the last byte in the byte array, in reverse order.</p> <p>This function is provided for STL compatibility.</p> <p><b>See also </b><a href="qbytearrayview.html#rbegin">rbegin</a>(), <a href="qbytearrayview.html#crend">crend</a>(), and <a href="qbytearrayview.html#end">end</a>().</p>   <h3 class="fn" id="size">
<span class="type">qsizetype</span> QByteArrayView::<span class="name">size</span>() const
</h3> <p>Returns the number of bytes in this byte array view.</p> <p><b>See also </b><a href="qbytearrayview.html#empty">empty</a>(), <a href="qbytearrayview.html#isEmpty">isEmpty</a>(), and <a href="qbytearrayview.html#isNull">isNull</a>().</p>   <h3 class="fn" id="sliced">
<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> QByteArrayView::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>) const
</h3> <p>Returns a byte array view starting at position <i>pos</i> in this object, and extending to its end.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>pos</i> &lt; 0 or <i>pos</i> &gt; <a href="qbytearrayview.html#size">size</a>().</p> </div> <p><b>See also </b><a href="qbytearrayview.html#first">first</a>(), <a href="qbytearrayview.html#last">last</a>(), <a href="qbytearrayview.html#chopped">chopped</a>(), <a href="qbytearrayview.html#chop">chop</a>(), and <a href="qbytearrayview.html#truncate">truncate</a>().</p>   <h3 class="fn" id="sliced-1">
<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> QByteArrayView::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>n</i>) const
</h3> <p>Returns a byte array view that points to <i>n</i> bytes of this byte array view, starting at position <i>pos</i>.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>pos</i> &lt; 0, <i>n</i> &lt; 0, or <i>pos</i> + <i>n</i> &gt; <a href="qbytearrayview.html#size">size</a>().</p> </div> <p><b>See also </b><a href="qbytearrayview.html#first">first</a>(), <a href="qbytearrayview.html#last">last</a>(), <a href="qbytearrayview.html#chopped">chopped</a>(), <a href="qbytearrayview.html#chop">chop</a>(), and <a href="qbytearrayview.html#truncate">truncate</a>().</p>   <h3 class="fn" id="toByteArray">
<span class="type"><a href="qbytearray.html">QByteArray</a></span> QByteArrayView::<span class="name">toByteArray</span>() const
</h3> <p>Returns a deep copy of this byte array view's data as a <a href="qbytearray.html">QByteArray</a>.</p> <p>The return value will be a null <a href="qbytearray.html">QByteArray</a> if and only if this byte array view is null.</p> <div class="admonition warning"> <p><b>Warning: </b><a href="qbytearrayview.html">QByteArrayView</a> can store data with more than 2<sup>31</sup> bytes while <a href="qbytearray.html">QByteArray</a> cannot. Calling this function on a byte array view for which <a href="qbytearrayview.html#size">size</a>() returns a value greater than <code>INT_MAX / 2</code> constitutes undefined behavior.</p> </div>   <h3 class="fn" id="truncate">
<span class="type">void</span> QByteArrayView::<span class="name">truncate</span>(<span class="type">qsizetype</span> <i>length</i>)
</h3> <p>Truncates this byte array view to length <i>length</i>.</p> <p>Same as <code>*this = first(length)</code>.</p> <div class="admonition note"> <p><b>Note: </b>The behavior is undefined when <i>length</i> &lt; 0 or <i>length</i> &gt; <a href="qbytearrayview.html#size">size</a>().</p> </div> <p><b>See also </b><a href="qbytearrayview.html#first">first</a>(), <a href="qbytearrayview.html#last">last</a>(), <a href="qbytearrayview.html#sliced">sliced</a>(), <a href="qbytearrayview.html#chopped">chopped</a>(), and <a href="qbytearrayview.html#chop">chop</a>().</p>   <h3 class="fn" id="operator-5b-5d">
<span class="type">char</span> QByteArrayView::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>n</i>) const
</h3> <p>Returns the character at position <i>n</i> in this byte array view.</p> <p>The behavior is undefined if <i>n</i> is negative or not less than <a href="qbytearrayview.html#size">size</a>().</p> <p><b>See also </b><a href="qbytearrayview.html#at">at</a>(), <a href="qbytearrayview.html#front">front</a>(), and <a href="qbytearrayview.html#back">back</a>().</p>   <div class="relnonmem"> <h2>Related Non-Members</h2>  <div class="fngroup"> <h3 class="fn fngroupitem" id="operator-not-eq">
<span class="type">bool</span> <span class="name">operator!=</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>rhs</i>)
</h3>
<h3 class="fn fngroupitem" id="operator-lt">
<span class="type">bool</span> <span class="name">operator&lt;</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>rhs</i>)
</h3>
<h3 class="fn fngroupitem" id="operator-lt-eq">
<span class="type">bool</span> <span class="name">operator&lt;=</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>rhs</i>)
</h3>
<h3 class="fn fngroupitem" id="operator-eq-eq">
<span class="type">bool</span> <span class="name">operator==</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>rhs</i>)
</h3>
<h3 class="fn fngroupitem" id="operator-gt">
<span class="type">bool</span> <span class="name">operator&gt;</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>rhs</i>)
</h3>
<h3 class="fn fngroupitem" id="operator-gt-eq">
<span class="type">bool</span> <span class="name">operator&gt;=</span>(<span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>lhs</i>, <span class="type"><a href="qbytearrayview.html#QByteArrayView">QByteArrayView</a></span> <i>rhs</i>)
</h3>
</div> <p>Comparison operators for <a href="qbytearrayview.html">QByteArrayView</a>.</p>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qbytearrayview.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qbytearrayview.html</a>
  </p>
</div>
