<h1>perlintern</h1>   <h2><a id="toc">CONTENTS</a></h2> <ul> <li> <a class="text-decoration-none" href="#NAME">NAME</a> </li> <li> <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION </a> </li> <li> <a class="text-decoration-none" href="#AV-Handling">AV Handling</a> </li> <li> <a class="text-decoration-none" href="#Callback-Functions">Callback Functions</a> </li> <li> <a class="text-decoration-none" href="#Casting">Casting </a> </li> <li> <a class="text-decoration-none" href="#Character-case-changing">Character case changing</a> </li> <li> <a class="text-decoration-none" href="#Character-classification">Character classification</a> </li> <li> <a class="text-decoration-none" href="#Compiler-and-Preprocessor-information">Compiler and Preprocessor information</a> </li> <li> <a class="text-decoration-none" href="#Compiler-directives">Compiler directives</a> </li> <li> <a class="text-decoration-none" href="#Compile-time-scope-hooks">Compile-time scope hooks</a> </li> <li> <a class="text-decoration-none" href="#Concurrency">Concurrency</a> </li> <li> <a class="text-decoration-none" href="#COPs-and-Hint-Hashes">COPs and Hint Hashes</a> </li> <li> <a class="text-decoration-none" href="#Custom-Operators">Custom Operators</a> </li> <li> <a class="text-decoration-none" href="#CV-Handling">CV Handling</a> </li> <li> <a class="text-decoration-none" href="#Debugging">Debugging</a> </li> <li> <a class="text-decoration-none" href="#Display-functions">Display functions </a> </li> <li> <a class="text-decoration-none" href="#Embedding,-Threads,-and-Interpreter-Cloning">Embedding, Threads, and Interpreter Cloning</a> </li> <li> <a class="text-decoration-none" href="#Errno">Errno</a> </li> <li> <a class="text-decoration-none" href="#Exception-Handling-(simple)-Macros">Exception Handling (simple) Macros</a> </li> <li> <a class="text-decoration-none" href="#Filesystem-configuration-values">Filesystem configuration values</a> </li> <li> <a class="text-decoration-none" href="#Floating-point">Floating point</a> </li> <li> <a class="text-decoration-none" href="#General-Configuration">General Configuration</a> </li> <li> <a class="text-decoration-none" href="#Global-Variables">Global Variables</a> </li> <li> <a class="text-decoration-none" href="#GV-Handling-and-Stashes">GV Handling and Stashes </a> </li> <li> <a class="text-decoration-none" href="#Hook-manipulation">Hook manipulation</a> </li> <li> <a class="text-decoration-none" href="#HV-Handling">HV Handling </a> </li> <li> <a class="text-decoration-none" href="#Input/Output">Input/Output</a> </li> <li> <a class="text-decoration-none" href="#Integer">Integer</a> </li> <li> <a class="text-decoration-none" href="#I/O-Formats">I/O Formats</a> </li> <li> <a class="text-decoration-none" href="#Lexer-interface">Lexer interface</a> </li> <li> <a class="text-decoration-none" href="#Locales">Locales</a> </li> <li> <a class="text-decoration-none" href="#Magic">Magic</a> </li> <li> <a class="text-decoration-none" href="#Memory-Management">Memory Management</a> </li> <li> <a class="text-decoration-none" href="#MRO">MRO</a> </li> <li> <a class="text-decoration-none" href="#Multicall-Functions">Multicall Functions</a> </li> <li> <a class="text-decoration-none" href="#Numeric-Functions">Numeric Functions</a> </li> <li> <a class="text-decoration-none" href="#Optrees">Optrees</a> </li> <li> <a class="text-decoration-none" href="#Pack-and-Unpack">Pack and Unpack</a> </li> <li> <a class="text-decoration-none" href="#Pad-Data-Structures">Pad Data Structures</a> </li> <li> <a class="text-decoration-none" href="#Password-and-Group-access">Password and Group access</a> </li> <li> <a class="text-decoration-none" href="#Paths-to-system-commands">Paths to system commands</a> </li> <li> <a class="text-decoration-none" href="#Prototype-information">Prototype information</a> </li> <li> <a class="text-decoration-none" href="#REGEXP-Functions">REGEXP Functions</a> </li> <li> <a class="text-decoration-none" href="#Reports-and-Formats">Reports and Formats</a> </li> <li> <a class="text-decoration-none" href="#Signals">Signals</a> </li> <li> <a class="text-decoration-none" href="#Site-configuration">Site configuration</a> </li> <li> <a class="text-decoration-none" href="#Sockets-configuration-values">Sockets configuration values</a> </li> <li> <a class="text-decoration-none" href="#Source-Filters">Source Filters</a> </li> <li> <a class="text-decoration-none" href="#Stack-Manipulation-Macros">Stack Manipulation Macros</a> </li> <li> <a class="text-decoration-none" href="#String-Handling">String Handling</a> </li> <li> <a class="text-decoration-none" href="#SV-Flags">SV Flags</a> </li> <li> <a class="text-decoration-none" href="#SV-Handling">SV Handling</a> </li> <li> <a class="text-decoration-none" href="#Tainting">Tainting</a> </li> <li> <a class="text-decoration-none" href="#Time">Time</a> </li> <li> <a class="text-decoration-none" href="#Typedef-names">Typedef names</a> </li> <li> <a class="text-decoration-none" href="#Unicode-Support">Unicode Support </a> </li> <li> <a class="text-decoration-none" href="#Utility-Functions">Utility Functions</a> </li> <li> <a class="text-decoration-none" href="#Versioning">Versioning</a> </li> <li> <a class="text-decoration-none" href="#Warning-and-Dieing">Warning and Dieing</a> </li> <li> <a class="text-decoration-none" href="#XS">XS</a> </li> <li> <a class="text-decoration-none" href="#Undocumented-elements">Undocumented elements</a> </li> <li> <a class="text-decoration-none" href="#AUTHORS">AUTHORS</a> </li> <li> <a class="text-decoration-none" href="#SEE-ALSO">SEE ALSO</a> </li> </ul> <h2 id="NAME">NAME</h2> <p>perlintern - autogenerated documentation of purely <b>internal</b> Perl functions</p> <h2 id="DESCRIPTION">DESCRIPTION </h2> <p>This file is the autogenerated documentation of functions in the Perl interpreter that are documented using Perl's internal documentation format but are not marked as part of the Perl API. In other words, <b>they are not for use in extensions</b>!</p> <p>It has the same sections as <a href="perlapi.html">perlapi</a>, though some may be empty.</p> <h2 id="AV-Handling">
AV Handling</h2> <dl> <dt id="av_fetch_simple">
<code>av_fetch_simple</code> </dt> <dd> <p>This is a cut-down version of av_fetch that assumes that the array is very straightforward - no magic, not readonly, and AvREAL - and that <code>key</code> is not negative. This function MUST NOT be used in situations where any of those assumptions may not hold.</p> <p>Returns the SV at the specified index in the array. The <code>key</code> is the index. If lval is true, you are guaranteed to get a real SV back (in case it wasn't real before), which you can then modify. Check that the return value is non-null before dereferencing it to a <code>SV*</code>.</p> <p>The rough perl equivalent is <code>$myarray[$key]</code>.</p> 
<pre data-language="perl"><code class="plaintext">SV **  av_fetch_simple(AV *av, SSize_t key, I32 lval)</code></pre> </dd> </dl> <dl> <dt id="AvFILLp">
<code>AvFILLp</code> </dt> <dd> <p>If the array <code>av</code> is empty, this returns -1; otherwise it returns the maximum value of the indices of all the array elements which are currently defined in <code>av</code>. It does not handle magic, hence the <code>p</code> private indication in its name.</p> 
<pre data-language="perl"><code class="plaintext">SSize_t  AvFILLp(AV* av)</code></pre> </dd> </dl> <dl> <dt id="av_new_alloc">
<code>av_new_alloc</code> </dt> <dd> <p>This implements <a href="perlapi.html#newAV_alloc_x">"<code>newAV_alloc_x</code>" in perlapi</a> and <a href="perlapi.html#newAV_alloc_xz">"<code>newAV_alloc_xz</code>" in perlapi</a>, which are the public API for this functionality.</p> <p>Creates a new AV and allocates its SV* array.</p> <p>This is similar to, but more efficient than doing:</p> <pre data-language="perl"><code>AV *av = newAV();
av_extend(av, key);</code></pre> <p>The size parameter is used to pre-allocate a SV* array large enough to hold at least elements <code>0..(size-1)</code>. <code>size</code> must be at least 1.</p> <p>The <code>zeroflag</code> parameter controls whether or not the array is NULL initialized.</p> 
<pre data-language="perl"><code class="plaintext">AV *  av_new_alloc(SSize_t size, bool zeroflag)</code></pre> </dd> </dl> <dl> <dt id="av_store_simple">
<code>av_store_simple</code> </dt> <dd> <p>This is a cut-down version of av_store that assumes that the array is very straightforward - no magic, not readonly, and AvREAL - and that <code>key</code> is not negative. This function MUST NOT be used in situations where any of those assumptions may not hold.</p> <p>Stores an SV in an array. The array index is specified as <code>key</code>. It can be dereferenced to get the <code>SV*</code> that was stored there (= <code>val</code>)).</p> <p>Note that the caller is responsible for suitably incrementing the reference count of <code>val</code> before the call.</p> <p>Approximate Perl equivalent: <code>splice(@myarray, $key, 1, $val)</code>.</p> 
<pre data-language="perl"><code class="plaintext">SV **  av_store_simple(AV *av, SSize_t key, SV *val)</code></pre> </dd> </dl> <h2 id="Callback-Functions">
Callback Functions</h2> <dl> <dt id="dowantarray">
<code>dowantarray</code> </dt> <dd> <p><code><b>DEPRECATED!</b></code> It is planned to remove <code>dowantarray</code> from a future release of Perl. Do not use it for new code; remove it from existing code.</p> <p>Implements the deprecated <a href="perlapi.html#GIMME">"<code>GIMME</code>" in perlapi</a>.</p> 
<pre data-language="perl"><code class="plaintext">U8  dowantarray()</code></pre> </dd> </dl> <dl> <dt id="leave_scope">
<code>leave_scope</code> </dt> <dd> <p>Implements <code>LEAVE_SCOPE</code> which you should use instead.</p> 
<pre data-language="perl"><code class="plaintext">void  leave_scope(I32 base)</code></pre> </dd> </dl> <dl> <dt id="magic_freedestruct">
<code>magic_freedestruct</code> </dt> <dd> <p>This function is called via magic to implement the <code>mortal_destructor_sv()</code> and <code>mortal_destructor_x()</code> functions. It should not be called directly and has no user servicable parts.</p> 
<pre data-language="perl"><code class="plaintext">int  magic_freedestruct(SV *sv, MAGIC *mg)</code></pre> </dd> </dl> <dl> <dt id="mortal_svfunc_x">
<code>mortal_svfunc_x</code> </dt> <dd> <p>This function arranges for a C function reference to be called at the <b>end of the current statement</b> with the arguments provided. It is a wrapper around <code>mortal_destructor_sv()</code> which ensures that the latter function is called appropriately.</p> <p>Be aware that there is a signficant difference in timing between the <i>end of the current statement</i> and the <i>end of the current pseudo block</i>. If you are looking for a mechanism to trigger a function at the end of the <b>current pseudo block</b> you should look at <code>SAVEDESTRUCTORX()</code> instead of this function.</p> 
<pre data-language="perl"><code class="plaintext">void  mortal_svfunc_x(SVFUNC_t f, SV *p)</code></pre> </dd> </dl> <dl> <dt id="pop_scope">
<code>pop_scope</code> </dt> <dd> <p>Implements <a href="perlapi.html#LEAVE">"<code>LEAVE</code>" in perlapi</a></p> 
<pre data-language="perl"><code class="plaintext">void  pop_scope()</code></pre> </dd> </dl> <dl> <dt id="push_scope">
<code>push_scope</code> </dt> <dd> <p>Implements <a href="perlapi.html#ENTER">"<code>ENTER</code>" in perlapi</a></p> 
<pre data-language="perl"><code class="plaintext">void  push_scope()</code></pre> </dd> </dl> <dl> <dt id="save_adelete">
<code>save_adelete</code> </dt> <dd> <p>Implements <code>SAVEADELETE</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  save_adelete(AV *av, SSize_t key)</code></pre> </dd> </dl> <dl> <dt id="save_freercpv">
<code>save_freercpv</code> </dt> <dd> <p>Implements <code>SAVEFREERCPV</code>.</p> <p>Saves and frees a refcounted string. Calls rcpv_free() on the argument when the current pseudo block is finished.</p> 
<pre data-language="perl"><code class="plaintext">void  save_freercpv(char *rcpv)</code></pre> </dd> </dl> <dl> <dt id="save_generic_pvref">
<code>save_generic_pvref</code> </dt> <dd> <p>Implements <code>SAVEGENERICPV</code>.</p> <p>Like save_pptr(), but also Safefree()s the new value if it is different from the old one. Can be used to restore a global char* to its prior contents, freeing new value.</p> 
<pre data-language="perl"><code class="plaintext">void  save_generic_pvref(char **str)</code></pre> </dd> </dl> <dl> <dt id="save_generic_svref">
<code>save_generic_svref</code> </dt> <dd> <p>Implements <code>SAVEGENERICSV</code>.</p> <p>Like save_sptr(), but also SvREFCNT_dec()s the new value. Can be used to restore a global SV to its prior contents, freeing new value.</p> 
<pre data-language="perl"><code class="plaintext">void  save_generic_svref(SV **sptr)</code></pre> </dd> </dl> <dl> <dt id="save_hdelete">
<code>save_hdelete</code> </dt> <dd> <p>Implements <code>SAVEHDELETE</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  save_hdelete(HV *hv, SV *keysv)</code></pre> </dd> </dl> <dl> <dt id="save_hints">
<code>save_hints</code> </dt> <dd> <p>Implements <code>SAVEHINTS</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  save_hints()</code></pre> </dd> </dl> <dl> <dt id="save_op">
<code>save_op</code> </dt> <dd> <p>Implements <code>SAVEOP</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  save_op()</code></pre> </dd> </dl> <dl> <dt id="save_padsv_and_mortalize">
<code>save_padsv_and_mortalize</code> </dt> <dd> <p>Implements <code>SAVEPADSVANDMORTALIZE</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  save_padsv_and_mortalize(PADOFFSET off)</code></pre> </dd> </dl> <dl> <dt id="save_pushptr">
<code>save_pushptr</code> </dt> <dd> <p>The refcnt of object <code>ptr</code> will be decremented at the end of the current <i>pseudo-block</i>. <code>type</code> gives the type of <code>ptr</code>, expressed as one of the constants in <i>scope.h</i> whose name begins with <code>SAVEt_</code>.</p> <p>This is the underlying implementation of several macros, like <code>SAVEFREESV</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  save_pushptr(void * const ptr, const int type)</code></pre> </dd> </dl> <dl> <dt id="save_rcpv">
<code>save_rcpv</code> </dt> <dd> <p>Implements <code>SAVERCPV</code>.</p> <p>Saves and restores a refcounted string, similar to what save_generic_svref would do for a SV*. Can be used to restore a refcounted string to its previous state. Performs the appropriate refcount counting so that nothing should leak or be prematurely freed.</p> 
<pre data-language="perl"><code class="plaintext">void  save_rcpv(char **prcpv)</code></pre> </dd> </dl> <dl> <dt id="save_scalar_at">
<code>save_scalar_at</code> </dt> <dd> <p>A helper function for localizing the SV referenced by <code>*sptr</code>.</p> <p>If <code>SAVEf_KEEPOLDELEM</code> is set in in <code>flags</code>, the function returns the input scalar untouched.</p> <p>Otherwise it replaces <code>*sptr</code> with a new <code>undef</code> scalar, and returns that. The new scalar will have the old one's magic (if any) copied to it. If there is such magic, and <code>SAVEf_SETMAGIC</code> is set in in <code>flags</code>, 'set' magic will be processed on the new scalar. If unset, 'set' magic will be skipped. The latter typically means that assignment will soon follow (<i>e.g.</i>, <span style="white-space: nowrap;"><code>'local $x = $y'</code></span>), and that will handle the magic.</p> 
<pre data-language="perl"><code class="plaintext">SV *  save_scalar_at(SV **sptr, const U32 flags)</code></pre> </dd> </dl> <dl> <dt id="save_set_svflags">
<code>save_set_svflags</code> </dt> <dd> <p>Implements <code>SAVESETSVFLAGS</code>.</p> <p>Set the SvFLAGS specified by mask to the values in val</p> 
<pre data-language="perl"><code class="plaintext">void  save_set_svflags(SV *sv, U32 mask, U32 val)</code></pre> </dd> </dl> <dl> <dt id="save_shared_pvref">
<code>save_shared_pvref</code> </dt> <dd> <p>Implements <code>SAVESHAREDPV</code>.</p> <p>Like save_generic_pvref(), but uses PerlMemShared_free() rather than Safefree(). Can be used to restore a shared global char* to its prior contents, freeing new value.</p> 
<pre data-language="perl"><code class="plaintext">void  save_shared_pvref(char **str)</code></pre> </dd> </dl> <dl> <dt id="save_vptr">
<code>save_vptr</code> </dt> <dd> <p>Implements <code>SAVEVPTR</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  save_vptr(void *ptr)</code></pre> </dd> </dl> <h2 id="Casting">Casting </h2> <p>There are currently no internal API items in Casting</p> <h2 id="Character-case-changing">
Character case changing</h2> <p>There are currently no internal API items in Character case changing</p> <h2 id="Character-classification">
Character classification</h2> <p>There are currently no internal API items in Character classification</p> <h2 id="Compiler-and-Preprocessor-information">
Compiler and Preprocessor information</h2> <p>There are currently no internal API items in Compiler and Preprocessor information</p> <h2 id="Compiler-directives">
Compiler directives</h2> <p>There are currently no internal API items in Compiler directives</p> <h2 id="Compile-time-scope-hooks">
Compile-time scope hooks</h2> <dl> <dt id="BhkENTRY">
<code>BhkENTRY</code> </dt> <dd> <p>NOTE: <code>BhkENTRY</code> is <b>experimental</b> and may change or be removed without notice.</p> <p>Return an entry from the BHK structure. <code>which</code> is a preprocessor token indicating which entry to return. If the appropriate flag is not set this will return <code>NULL</code>. The type of the return value depends on which entry you ask for.</p> 
<pre data-language="perl"><code class="plaintext">void *  BhkENTRY(BHK *hk, token which)</code></pre> </dd> </dl> <dl> <dt id="BhkFLAGS">
<code>BhkFLAGS</code> </dt> <dd> <p>NOTE: <code>BhkFLAGS</code> is <b>experimental</b> and may change or be removed without notice.</p> <p>Return the BHK's flags.</p> 
<pre data-language="perl"><code class="plaintext">U32  BhkFLAGS(BHK *hk)</code></pre> </dd> </dl> <dl> <dt id="CALL_BLOCK_HOOKS">
<code>CALL_BLOCK_HOOKS</code> </dt> <dd> <p>NOTE: <code>CALL_BLOCK_HOOKS</code> is <b>experimental</b> and may change or be removed without notice.</p> <p>Call all the registered block hooks for type <code>which</code>. <code>which</code> is a preprocessing token; the type of <code>arg</code> depends on <code>which</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  CALL_BLOCK_HOOKS(token which, arg)</code></pre> </dd> </dl> <h2 id="Concurrency">Concurrency</h2> <dl> <dt id="CVf_SLABBED"><code>CVf_SLABBED</code></dt>  <dt id="CvROOT"><code>CvROOT</code></dt>  <dt id="CvSTART"><code>CvSTART</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> </dd> </dl> <dl> <dt id="CX_CUR"><code>CX_CUR</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> 
<pre data-language="perl"><code class="plaintext">CX_CUR()</code></pre> </dd> </dl> <dl> <dt id="CXINC"><code>CXINC</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> </dd> </dl> <dl> <dt id="CX_LEAVE_SCOPE"><code>CX_LEAVE_SCOPE</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> 
<pre data-language="perl"><code class="plaintext">void  CX_LEAVE_SCOPE(PERL_CONTEXT* cx)</code></pre> </dd> </dl> <dl> <dt id="CX_POP"><code>CX_POP</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> 
<pre data-language="perl"><code class="plaintext">void  CX_POP(PERL_CONTEXT* cx)</code></pre> </dd> </dl> <dl> <dt id="cxstack"><code>cxstack</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> </dd> </dl> <dl> <dt id="cxstack_ix"><code>cxstack_ix</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> </dd> </dl> <dl> <dt id="CXt_BLOCK"><code>CXt_BLOCK</code></dt>  <dt id="CXt_EVAL"><code>CXt_EVAL</code></dt>  <dt id="CXt_FORMAT"><code>CXt_FORMAT</code></dt>  <dt id="CXt_GIVEN"><code>CXt_GIVEN</code></dt>  <dt id="CXt_LOOP_ARY"><code>CXt_LOOP_ARY</code></dt>  <dt id="CXt_LOOP_LAZYIV"><code>CXt_LOOP_LAZYIV</code></dt>  <dt id="CXt_LOOP_LAZYSV"><code>CXt_LOOP_LAZYSV</code></dt>  <dt id="CXt_LOOP_LIST"><code>CXt_LOOP_LIST</code></dt>  <dt id="CXt_LOOP_PLAIN"><code>CXt_LOOP_PLAIN</code></dt>  <dt id="CXt_NULL"><code>CXt_NULL</code></dt>  <dt id="CXt_SUB"><code>CXt_SUB</code></dt>  <dt id="CXt_SUBST"><code>CXt_SUBST</code></dt>  <dt id="CXt_WHEN"><code>CXt_WHEN</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> </dd> </dl> <dl> <dt id="cx_type"><code>cx_type</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> </dd> </dl> <dl> <dt id="dounwind"><code>dounwind</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> 
<pre data-language="perl"><code class="plaintext">void  dounwind(I32 cxix)</code></pre> </dd> </dl> <dl> <dt id="my_fork">
<code>my_fork</code> </dt> <dd> <p>This is for the use of <code>PerlProc_fork</code> as a wrapper for the C library <a href="http://man.he.net/man2/fork">fork(2)</a> on some platforms to hide some platform quirks. It should not be used except through <code>PerlProc_fork</code>.</p> 
<pre data-language="perl"><code class="plaintext">Pid_t  my_fork()</code></pre> </dd> </dl> <dl> <dt id="PERL_CONTEXT"><code>PERL_CONTEXT</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> </dd> </dl> <h2 id="COPs-and-Hint-Hashes">
COPs and Hint Hashes</h2> <p>There are currently no internal API items in COPs and Hint Hashes</p> <h2 id="Custom-Operators">
Custom Operators</h2> <dl> <dt id="core_prototype">
<code>core_prototype</code> </dt> <dd> <p>This function assigns the prototype of the named core function to <code>sv</code>, or to a new mortal SV if <code>sv</code> is <code>NULL</code>. It returns the modified <code>sv</code>, or <code>NULL</code> if the core function has no prototype. <code>code</code> is a code as returned by <code>keyword()</code>. It must not be equal to 0.</p> 
<pre data-language="perl"><code class="plaintext">SV *  core_prototype(SV *sv, const char *name, const int code,
                     int * const opnum)</code></pre> </dd> </dl> <h2 id="CV-Handling">
CV Handling</h2> <dl> <dt id="CvREFCOUNTED_ANYSV">
<code>CvREFCOUNTED_ANYSV</code> </dt> <dd> <p>If true, indicates that the <code>CvXSUBANY(cv).any_sv</code> member contains an SV pointer whose reference count should be decremented when the CV itself is freed. In addition, <code>cv_clone()</code> will increment the reference count, and <code>sv_dup()</code> will duplicate the entire pointed-to SV if this flag is set.</p> <p>Any CV that wraps an XSUB has an <code>ANY</code> union that the XSUB function is free to use for its own purposes. It may be the case that the code wishes to store an SV in the <code>any_sv</code> member of this union. By setting this flag, this SV reference will be properly reclaimed or duplicated when the CV itself is.</p> 
<pre data-language="perl"><code class="plaintext">bool  CvREFCOUNTED_ANYSV(CV *cv)</code></pre> </dd> </dl> <dl> <dt id="CvREFCOUNTED_ANYSV_off">
<code>CvREFCOUNTED_ANYSV_off</code> </dt> <dd> <p>Helper macro to turn off the <code>CvREFCOUNTED_ANYSV</code> flag.</p> 
<pre data-language="perl"><code class="plaintext">void  CvREFCOUNTED_ANYSV_off(CV *cv)</code></pre> </dd> </dl> <dl> <dt id="CvREFCOUNTED_ANYSV_on">
<code>CvREFCOUNTED_ANYSV_on</code> </dt> <dd> <p>Helper macro to turn on the <code>CvREFCOUNTED_ANYSV</code> flag.</p> 
<pre data-language="perl"><code class="plaintext">void  CvREFCOUNTED_ANYSV_on(CV *cv)</code></pre> </dd> </dl> <dl> <dt id="CvWEAKOUTSIDE">
<code>CvWEAKOUTSIDE</code> </dt> <dd> <p>Each CV has a pointer, <code>CvOUTSIDE()</code>, to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in <code>&amp;</code> pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by <code>CvOUTSIDE</code> in the <i>one specific instance</i> that the parent has a <code>&amp;</code> pad slot pointing back to us. In this case, we set the <code>CvWEAKOUTSIDE</code> flag in the child. This allows us to determine under what circumstances we should decrement the refcount of the parent when freeing the child.</p> <p>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, <i>e.g.</i>,</p> <pre data-language="perl"><code>BEGIN { $a = sub { eval '$x' } }</code></pre> <p>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has <code>CvWEAKOUTSIDE</code> set since it's not a closure, and $a points to the same CV, so it doesn't contribute to BEGIN's refcount either. When $a is executed, the <code>eval '$x'</code> causes the chain of <code>CvOUTSIDE</code>s to be followed, and the freed BEGIN is accessed.</p> <p>To avoid this, whenever a CV and its associated pad is freed, any <code>&amp;</code> entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child's <code>CvOUTSIDE</code> is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as <code>$a</code> above).</p> <p>One other thing to consider is that a CV may be merely undefined rather than freed, eg <code>undef &amp;foo</code>. In this case, its refcount may not have reached zero, but we still delete its pad and its <code>CvROOT</code> etc. Since various children may still have their <code>CvOUTSIDE</code> pointing at this undefined CV, we keep its own <code>CvOUTSIDE</code> for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</p> <pre data-language="perl"><code>my $x = 123;
sub tmp { sub { eval '$x' } }
my $a = tmp();
undef &amp;tmp;
print  $a-&gt;();</code></pre> 
<pre data-language="perl"><code class="plaintext">bool  CvWEAKOUTSIDE(CV *cv)</code></pre> </dd> </dl> <dl> <dt id="docatch">
<code>docatch</code> </dt> <dd> <p>Interpose, for the current op and RUNOPS loop,</p> <pre data-language="perl"><code class="plaintext">- a new JMPENV stack catch frame, and
- an inner RUNOPS loop to run all the remaining ops following the
  current PL_op.</code></pre> <p>Then handle any exceptions raised while in that loop. For a caught eval at this level, re-enter the loop with the specified restart op (i.e. the op following the OP_LEAVETRY etc); otherwise re-throw the exception.</p> <p>docatch() is intended to be used like this:</p> <pre data-language="perl"><code>PP(pp_entertry)
{
    if (CATCH_GET)
        return docatch(Perl_pp_entertry);

    ... rest of function ...
    return PL_op-&gt;op_next;
}</code></pre> <p>If a new catch frame isn't needed, the op behaves normally. Otherwise it calls docatch(), which recursively calls pp_entertry(), this time with CATCH_GET() false, so the rest of the body of the entertry is run. Then docatch() calls CALLRUNOPS() which executes all the ops following the entertry. When the loop finally finishes, control returns to docatch(), which pops the JMPENV and returns to the parent pp_entertry(), which itself immediately returns. Note that *all* subsequent ops are run within the inner RUNOPS loop, not just the body of the eval. For example, in</p> <pre data-language="perl"><code>sub TIEARRAY { eval {1}; my $x }
tie @a, "main";</code></pre> <p>at the point the 'my' is executed, the C stack will look something like:</p> <pre data-language="perl"><code class="plaintext">#10 main()
#9  perl_run()              # JMPENV_PUSH level 1 here
#8  S_run_body()
#7  Perl_runops_standard()  # main RUNOPS loop
#6  Perl_pp_tie()
#5  Perl_call_sv()
#4  Perl_runops_standard()  # unguarded RUNOPS loop: no new JMPENV
#3  Perl_pp_entertry()
#2  S_docatch()             # JMPENV_PUSH level 2 here
#1  Perl_runops_standard()  # docatch()'s RUNOPs loop
#0  Perl_pp_padsv()</code></pre> <p>Basically, any section of the perl core which starts a RUNOPS loop may make a promise that it will catch any exceptions and restart the loop if necessary. If it's not prepared to do that (like call_sv() isn't), then it sets CATCH_GET() to true, so that any later eval-like code knows to set up a new handler and loop (via docatch()).</p> <p>See <a href="perlinterp.html#Exception-handing">"Exception handing" in perlinterp</a> for further details.</p> 
<pre data-language="perl"><code class="plaintext">OP *  docatch(Perl_ppaddr_t firstpp)</code></pre> </dd> </dl> <h2 id="Debugging">Debugging</h2> <dl> <dt id="comma_aDEPTH">
<code>comma_aDEPTH</code> </dt> <dd> <p>Some functions when compiled under DEBUGGING take an extra final argument named <code>depth</code>, indicating the C stack depth. This argument is omitted otherwise. This macro expands to either <span style="white-space: nowrap;"><code>, depth</code></span> under DEBUGGING, or to nothing at all when not under DEBUGGING, reducing the number of <code>#ifdef</code>'s in the code.</p> <p>The program is responsible for maintaining the correct value for <code>depth</code>.</p> 
<pre data-language="perl"><code class="plaintext">comma_aDEPTH</code></pre> </dd> </dl> <dl> <dt id="comma_pDEPTH">
<code>comma_pDEPTH</code> </dt> <dd> <p>This is used in the prototype declarations for functions that take a <a href="#comma_aDEPTH">"<code>comma_aDEPTH</code>"</a> final parameter, much like <a href="perlguts.html#Background-and-MULTIPLICITY"><code>pTHX_</code></a> is used in functions that take a thread context initial parameter.</p> </dd> </dl> <dl> <dt id="debop">
<code>debop</code> </dt> <dd> <p>Implements <b>-Dt</b> perl command line option on OP <code>o</code>.</p> 
<pre data-language="perl"><code class="plaintext">I32  debop(const OP *o)</code></pre> </dd> </dl> <dl> <dt id="debprof">
<code>debprof</code> </dt> <dd> <p>Called to indicate that <code>o</code> was executed, for profiling purposes under the <code>-DP</code> command line option.</p> 
<pre data-language="perl"><code class="plaintext">void  debprof(const OP *o)</code></pre> </dd> </dl> <dl> <dt id="debprofdump">
<code>debprofdump</code> </dt> <dd> <p>Dumps the contents of the data collected by the <code>-DP</code> perl command line option.</p> 
<pre data-language="perl"><code class="plaintext">void  debprofdump()</code></pre> </dd> </dl> <dl> <dt id="debug_aDEPTH">
<code>debug_aDEPTH</code> </dt> <dd> <p>Same as <a href="#comma_aDEPTH">"<code>comma_aDEPTH</code>"</a> but with no leading argument. Intended for functions with no normal arguments, and used by <a href="#comma_aDEPTH">"<code>comma_aDEPTH</code>"</a> itself.</p> 
<pre data-language="perl"><code class="plaintext">debug_aDEPTH</code></pre> </dd> </dl> <dl> <dt id="debug_pDEPTH">
<code>debug_pDEPTH</code> </dt> <dd> <p>Same as <a href="#comma_pDEPTH">"<code>comma_pDEPTH</code>"</a> but with no leading argument. Intended for functions with no normal arguments, and used by <a href="#comma_pDEPTH">"<code>comma_pDEPTH</code>"</a> itself.</p> 
<pre data-language="perl"><code class="plaintext">debug_pDEPTH</code></pre> </dd> </dl> <dl> <dt id="free_c_backtrace">
<code>free_c_backtrace</code> </dt> <dd> <p>Deallocates a backtrace received from get_c_backtrace.</p> 
<pre data-language="perl"><code class="plaintext">void  free_c_backtrace(Perl_c_backtrace *bt)</code></pre> </dd> </dl> <dl> <dt id="get_c_backtrace">
<code>get_c_backtrace</code> </dt> <dd> <p>Collects the backtrace (aka "stacktrace") into a single linear malloced buffer, which the caller <b>must</b> <code>Perl_free_c_backtrace()</code>.</p> <p>Scans the frames back by <span style="white-space: nowrap;"><code>depth + skip</code></span>, then drops the <code>skip</code> innermost, returning at most <code>depth</code> frames.</p> 
<pre data-language="perl"><code class="plaintext">Perl_c_backtrace *  get_c_backtrace(int max_depth, int skip)</code></pre> </dd> </dl> <dl> <dt id="PL_DBsingle">
<code>PL_DBsingle</code> </dt> <dd> <p>When Perl is run in debugging mode, with the <b>-d</b> switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See <code><a href="#PL_DBsub">"PL_DBsub"</a></code>.</p> <p>On threaded perls, each thread has an independent copy of this variable; each initialized at creation time with the current value of the creating thread's copy.</p> 
<pre data-language="perl"><code class="plaintext">SV *  PL_DBsingle</code></pre> </dd> </dl> <dl> <dt id="PL_DBsub">
<code>PL_DBsub</code> </dt> <dd> <p>When Perl is run in debugging mode, with the <b>-d</b> switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See <code><a href="#PL_DBsingle">"PL_DBsingle"</a></code>.</p> <p>On threaded perls, each thread has an independent copy of this variable; each initialized at creation time with the current value of the creating thread's copy.</p> 
<pre data-language="perl"><code class="plaintext">GV *  PL_DBsub</code></pre> </dd> </dl> <dl> <dt id="PL_DBtrace">
<code>PL_DBtrace</code> </dt> <dd> <p>Trace variable used when Perl is run in debugging mode, with the <b>-d</b> switch. This is the C variable which corresponds to Perl's $DB::trace variable. See <code><a href="#PL_DBsingle">"PL_DBsingle"</a></code>.</p> <p>On threaded perls, each thread has an independent copy of this variable; each initialized at creation time with the current value of the creating thread's copy.</p> 
<pre data-language="perl"><code class="plaintext">SV *  PL_DBtrace</code></pre> </dd> </dl> <dl> <dt id="runops_debug"><code>runops_debug</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> 
<pre data-language="perl"><code class="plaintext">int  runops_debug()</code></pre> </dd> </dl> <dl> <dt id="runops_standard"><code>runops_standard</code></dt> <dd> <p>Described in <a href="perlguts.html">perlguts</a>.</p> 
<pre data-language="perl"><code class="plaintext">int  runops_standard()</code></pre> </dd> </dl> <h2 id="Display-functions">
Display functions </h2> <dl> <dt id="sv_peek">
<code>sv_peek</code> </dt> <dd> <p>Implements <code>SvPEEK</code></p> 
<pre data-language="perl"><code class="plaintext">char *  sv_peek(SV *sv)</code></pre> </dd> </dl> <h2 id="Embedding,-Threads,-and-Interpreter-Cloning">
Embedding, Threads, and Interpreter Cloning</h2> <dl> <dt id="cv_dump">
<code>cv_dump</code> </dt> <dd> <p>dump the contents of a CV</p> 
<pre data-language="perl"><code class="plaintext">void  cv_dump(const CV *cv, const char *title)</code></pre> </dd> </dl> <dl> <dt id="cv_forget_slab">
<code>cv_forget_slab</code> </dt> <dd> <p>When a CV has a reference count on its slab (<code>CvSLABBED</code>), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and <code>CvROOT</code> attached, it has finished its job, so it can forget the slab.</p> 
<pre data-language="perl"><code class="plaintext">void  cv_forget_slab(CV *cv)</code></pre> </dd> </dl> <dl> <dt id="do_dump_pad">
<code>do_dump_pad</code> </dt> <dd> <p>Dump the contents of a padlist</p> 
<pre data-language="perl"><code class="plaintext">void  do_dump_pad(I32 level, PerlIO *file, PADLIST *padlist,
                  int full)</code></pre> </dd> </dl> <dl> <dt id="get_context">
<code>get_context</code> </dt> <dd> <p>Implements <a href="perlapi.html#PERL_GET_CONTEXT">"<code>PERL_GET_CONTEXT</code>" in perlapi</a>, which you should use instead.</p> 
<pre data-language="perl"><code class="plaintext">void *  get_context()</code></pre> </dd> </dl> <dl> <dt id="pad_alloc_name">
<code>pad_alloc_name</code> </dt> <dd> <p>Allocates a place in the currently-compiling pad (via <a href="perlapi.html#pad_alloc">"pad_alloc" in perlapi</a>) and then stores a name for that entry. <code>name</code> is adopted and becomes the name entry; it must already contain the name string. <code>typestash</code> and <code>ourstash</code> and the <code>padadd_STATE</code> flag get added to <code>name</code>. None of the other processing of <a href="perlapi.html#pad_add_name_pvn">"pad_add_name_pvn" in perlapi</a> is done. Returns the offset of the allocated pad slot.</p> 
<pre data-language="perl"><code class="plaintext">PADOFFSET  pad_alloc_name(PADNAME *name, U32 flags, HV *typestash,
                          HV *ourstash)</code></pre> </dd> </dl> <dl> <dt id="pad_block_start">
<code>pad_block_start</code> </dt> <dd> <p>Update the pad compilation state variables on entry to a new block.</p> 
<pre data-language="perl"><code class="plaintext">void  pad_block_start(int full)</code></pre> </dd> </dl> <dl> <dt id="pad_check_dup">
<code>pad_check_dup</code> </dt> <dd> <p>Check for duplicate declarations: report any of:</p> <pre data-language="perl"><code>* a 'my' in the current scope with the same name;
* an 'our' (anywhere in the pad) with the same name and the
  same stash as 'ourstash'</code></pre> <p><code>is_our</code> indicates that the name to check is an <code>"our"</code> declaration.</p> 
<pre data-language="perl"><code class="plaintext">void  pad_check_dup(PADNAME *name, U32 flags, const HV *ourstash)</code></pre> </dd> </dl> <dl> <dt id="pad_findlex">
<code>pad_findlex</code> </dt> <dd> <p>Find a named lexical anywhere in a chain of nested pads. Add fake entries in the inner pads if it's found in an outer one.</p> <p>Returns the offset in the bottom pad of the lex or the fake lex. <code>cv</code> is the CV in which to start the search, and seq is the current <code>cop_seq</code> to match against. If <code>warn</code> is true, print appropriate warnings. The <code>out_</code>* vars return values, and so are pointers to where the returned values should be stored. <code>out_capture</code>, if non-null, requests that the innermost instance of the lexical is captured; <code>out_name</code> is set to the innermost matched pad name or fake pad name; <code>out_flags</code> returns the flags normally associated with the <code>PARENT_FAKELEX_FLAGS</code> field of a fake pad name.</p> <p>Note that <code>pad_findlex()</code> is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon prototypes have to store in <code>xpadn_low</code> the index into the parent pad.</p> 
<pre data-language="perl"><code class="plaintext">PADOFFSET  pad_findlex(const char *namepv, STRLEN namelen,
                       U32 flags, const CV *cv, U32 seq, int warn,
                       SV **out_capture, PADNAME **out_name,
                       int *out_flags)</code></pre> </dd> </dl> <dl> <dt id="pad_fixup_inner_anons">
<code>pad_fixup_inner_anons</code> </dt> <dd> <p>For any anon CVs in the pad, change <code>CvOUTSIDE</code> of that CV from <code>old_cv</code> to <code>new_cv</code> if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</p> 
<pre data-language="perl"><code class="plaintext">void  pad_fixup_inner_anons(PADLIST *padlist, CV *old_cv,
                            CV *new_cv)</code></pre> </dd> </dl> <dl> <dt id="pad_free">
<code>pad_free</code> </dt> <dd> <p>Free the SV at offset po in the current pad.</p> 
<pre data-language="perl"><code class="plaintext">void  pad_free(PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="pad_leavemy">
<code>pad_leavemy</code> </dt> <dd> <p>Cleanup at end of scope during compilation: set the max seq number for lexicals in this scope and warn of any lexicals that never got introduced.</p> 
<pre data-language="perl"><code class="plaintext">OP *  pad_leavemy()</code></pre> </dd> </dl> <dl> <dt id="padlist_dup">
<code>padlist_dup</code> </dt> <dd> <p>Duplicates a pad.</p> 
<pre data-language="perl"><code class="plaintext">PADLIST *  padlist_dup(PADLIST *srcpad, CLONE_PARAMS *param)</code></pre> </dd> </dl> <dl> <dt id="padname_dup">
<code>padname_dup</code> </dt> <dd> <p>Duplicates a pad name.</p> 
<pre data-language="perl"><code class="plaintext">PADNAME *  padname_dup(PADNAME *src, CLONE_PARAMS *param)</code></pre> </dd> </dl> <dl> <dt id="padnamelist_dup">
<code>padnamelist_dup</code> </dt> <dd> <p>Duplicates a pad name list.</p> 
<pre data-language="perl"><code class="plaintext">PADNAMELIST *  padnamelist_dup(PADNAMELIST *srcpad,
                               CLONE_PARAMS *param)</code></pre> </dd> </dl> <dl> <dt id="pad_push">
<code>pad_push</code> </dt> <dd> <p>Push a new pad frame onto the padlist, unless there's already a pad at this depth, in which case don't bother creating a new one. Then give the new pad an <code>@_</code> in slot zero.</p> 
<pre data-language="perl"><code class="plaintext">void  pad_push(PADLIST *padlist, int depth)</code></pre> </dd> </dl> <dl> <dt id="pad_reset">
<code>pad_reset</code> </dt> <dd> <p>Mark all the current temporaries for reuse</p> 
<pre data-language="perl"><code class="plaintext">void  pad_reset()</code></pre> </dd> </dl> <dl> <dt id="pad_setsv">
<code>pad_setsv</code> </dt> <dd> <p>Set the value at offset <code>po</code> in the current (compiling or executing) pad. Use the macro <code>PAD_SETSV()</code> rather than calling this function directly.</p> 
<pre data-language="perl"><code class="plaintext">void  pad_setsv(PADOFFSET po, SV *sv)</code></pre> </dd> </dl> <dl> <dt id="pad_sv">
<code>pad_sv</code> </dt> <dd> <p>Get the value at offset <code>po</code> in the current (compiling or executing) pad. Use macro <code>PAD_SV</code> instead of calling this function directly.</p> 
<pre data-language="perl"><code class="plaintext">SV *  pad_sv(PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="pad_swipe">
<code>pad_swipe</code> </dt> <dd> <p>Abandon the tmp in the current pad at offset <code>po</code> and replace with a new one.</p> 
<pre data-language="perl"><code class="plaintext">void  pad_swipe(PADOFFSET po, bool refadjust)</code></pre> </dd> </dl> <dl> <dt id="set_context">
<code>set_context</code> </dt> <dd> <p>Implements <a href="perlapi.html#PERL_SET_CONTEXT">"<code>PERL_SET_CONTEXT</code>" in perlapi</a>, which you should use instead.</p> 
<pre data-language="perl"><code class="plaintext">void  set_context(void *t)</code></pre> </dd> </dl> <dl> <dt id="si_dup">
<code>si_dup</code> </dt> <dd> <p>Duplicate a stack info structure, returning a pointer to the cloned object.</p> 
<pre data-language="perl"><code class="plaintext">PERL_SI *  si_dup(PERL_SI *si, CLONE_PARAMS *param)</code></pre> </dd> </dl> <dl> <dt id="ss_dup">
<code>ss_dup</code> </dt> <dd> <p>Duplicate the save stack, returning a pointer to the cloned object.</p> 
<pre data-language="perl"><code class="plaintext">ANY *  ss_dup(PerlInterpreter *proto_perl, CLONE_PARAMS *param)</code></pre> </dd> </dl> <h2 id="Errno">Errno</h2> <dl> <dt id="dSAVEDERRNO">
<code>dSAVEDERRNO</code> </dt> <dd> <p>Declare variables needed to save <code>errno</code> and any operating system specific error number.</p> 
<pre data-language="perl"><code class="plaintext">void  dSAVEDERRNO</code></pre> </dd> </dl> <dl> <dt id="dSAVE_ERRNO">
<code>dSAVE_ERRNO</code> </dt> <dd> <p>Declare variables needed to save <code>errno</code> and any operating system specific error number, and save them for optional later restoration by <code>RESTORE_ERRNO</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  dSAVE_ERRNO</code></pre> </dd> </dl> <dl> <dt id="RESTORE_ERRNO">
<code>RESTORE_ERRNO</code> </dt> <dd> <p>Restore <code>errno</code> and any operating system specific error number that was saved by <code>dSAVE_ERRNO</code> or <code>RESTORE_ERRNO</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  RESTORE_ERRNO</code></pre> </dd> </dl> <dl> <dt id="SAVE_ERRNO">
<code>SAVE_ERRNO</code> </dt> <dd> <p>Save <code>errno</code> and any operating system specific error number for optional later restoration by <code>RESTORE_ERRNO</code>. Requires <code>dSAVEDERRNO</code> or <code>dSAVE_ERRNO</code> in scope.</p> 
<pre data-language="perl"><code class="plaintext">void  SAVE_ERRNO</code></pre> </dd> </dl> <dl> <dt id="SETERRNO">
<code>SETERRNO</code> </dt> <dd> <p>Set <code>errno</code>, and on VMS set <code>vaxc$errno</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  SETERRNO(int errcode, int vmserrcode)</code></pre> </dd> </dl> <h2 id="Exception-Handling-(simple)-Macros">
Exception Handling (simple) Macros</h2> <p>There are currently no internal API items in Exception Handling (simple) Macros</p> <h2 id="Filesystem-configuration-values">
Filesystem configuration values</h2> <p>There are currently no internal API items in Filesystem configuration values</p> <h2 id="Floating-point">
Floating point</h2> <p>There are currently no internal API items in Floating point</p> <h2 id="General-Configuration">
General Configuration</h2> <p>There are currently no internal API items in General Configuration</p> <h2 id="Global-Variables">
Global Variables</h2> <p>There are currently no internal API items in Global Variables</p> <h2 id="GV-Handling-and-Stashes">
GV Handling and Stashes </h2> <dl> <dt id="amagic_applies">
<code>amagic_applies</code> </dt> <dd> <p>Check <code>sv</code> to see if the overloaded (active magic) operation <code>method</code> applies to it. If the sv is not SvROK or it is not an object then returns false, otherwise checks if the object is blessed into a class supporting overloaded operations, and returns true if a call to amagic_call() with this SV and the given method would trigger an amagic operation, including via the overload fallback rules or via nomethod. Thus a call like:</p> <pre data-language="perl"><code class="plaintext">amagic_applies(sv, string_amg, AMG_unary)</code></pre> <p>would return true for an object with overloading set up in any of the following ways:</p> <pre data-language="perl"><code>use overload q("") =&gt; sub { ... };
use overload q(0+) =&gt; sub { ... }, fallback =&gt; 1;</code></pre> <p>and could be used to tell if a given object would stringify to something other than the normal default ref stringification.</p> <p>Note that the fact that this function returns TRUE does not mean you can succesfully perform the operation with amagic_call(), for instance any overloaded method might throw a fatal exception, however if this function returns FALSE you can be confident that it will NOT perform the given overload operation.</p> <p><code>method</code> is an integer enum, one of the values found in <i>overload.h</i>, for instance <code>string_amg</code>.</p> <p><code>flags</code> should be set to AMG_unary for unary operations.</p> 
<pre data-language="perl"><code class="plaintext">bool  amagic_applies(SV *sv, int method, int flags)</code></pre> </dd> </dl> <dl> <dt id="gp_dup">
<code>gp_dup</code> </dt> <dd> <p>Duplicate a typeglob, returning a pointer to the cloned object.</p> 
<pre data-language="perl"><code class="plaintext">GP *  gp_dup(GP * const gp, CLONE_PARAMS * const param)</code></pre> </dd> </dl> <dl> <dt id="gv_handler">
<code>gv_handler</code> </dt> <dd> <p>Implements <code>StashHANDLER</code>, which you should use instead</p> 
<pre data-language="perl"><code class="plaintext">CV *  gv_handler(HV *stash, I32 id)</code></pre> </dd> </dl> <dl> <dt id="gv_stashsvpvn_cached">
<code>gv_stashsvpvn_cached</code> </dt> <dd> <p>Returns a pointer to the stash for a specified package, possibly cached. Implements both <a href="perlapi.html#gv_stashpvn">"<code>gv_stashpvn</code>" in perlapi</a> and <a href="perlapi.html#gv_stashsv">"<code>gv_stashsv</code>" in perlapi</a>.</p> <p>Requires one of either <code>namesv</code> or <code>namepv</code> to be non-null.</p> <p>If the flag <code>GV_CACHE_ONLY</code> is set, return the stash only if found in the cache; see <a href="perlapi.html#gv_stashpvn">"<code>gv_stashpvn</code>" in perlapi</a> for details on the other <code>flags</code>.</p> <p>Note it is strongly preferred for <code>namesv</code> to be non-null, for performance reasons.</p> 
<pre data-language="perl"><code class="plaintext">HV *  gv_stashsvpvn_cached(SV *namesv, const char *name,
                           U32 namelen, I32 flags)</code></pre> </dd> </dl> <dl> <dt id="gv_try_downgrade">
<code>gv_try_downgrade</code> </dt> <dd> <p>NOTE: <code>gv_try_downgrade</code> is <b>experimental</b> and may change or be removed without notice.</p> <p>If the typeglob <code>gv</code> can be expressed more succinctly, by having something other than a real GV in its place in the stash, replace it with the optimised form. Basic requirements for this are that <code>gv</code> is a real typeglob, is sufficiently ordinary, and is only referenced from its package. This function is meant to be used when a GV has been looked up in part to see what was there, causing upgrading, but based on what was found it turns out that the real GV isn't required after all.</p> <p>If <code>gv</code> is a completely empty typeglob, it is deleted from the stash.</p> <p>If <code>gv</code> is a typeglob containing only a sufficiently-ordinary constant sub, the typeglob is replaced with a scalar-reference placeholder that more compactly represents the same thing.</p> 
<pre data-language="perl"><code class="plaintext">void  gv_try_downgrade(GV *gv)</code></pre> </dd> </dl> <h2 id="Hook-manipulation">
Hook manipulation</h2> <p>There are currently no internal API items in Hook manipulation</p> <h2 id="HV-Handling">
HV Handling </h2> <dl> <dt id="hv_eiter_p">
<code>hv_eiter_p</code> </dt> <dd> <p>Implements <code>HvEITER</code> which you should use instead.</p> <p>NOTE: <code>hv_eiter_p</code> must be explicitly called as <code>Perl_hv_eiter_p</code> with an <code>aTHX_</code> parameter.</p> 
<pre data-language="perl"><code class="plaintext">HE **  Perl_hv_eiter_p(pTHX_ HV *hv)</code></pre> </dd> </dl> <dl> <dt id="hv_eiter_set">
<code>hv_eiter_set</code> </dt> <dd> <p>Implements <code>HvEITER_set</code> which you should use instead.</p> <p>NOTE: <code>hv_eiter_set</code> must be explicitly called as <code>Perl_hv_eiter_set</code> with an <code>aTHX_</code> parameter.</p> 
<pre data-language="perl"><code class="plaintext">void  Perl_hv_eiter_set(pTHX_ HV *hv, HE *eiter)</code></pre> </dd> </dl> <dl> <dt id="hv_ename_add">
<code>hv_ename_add</code> </dt> <dd> <p>Adds a name to a stash's internal list of effective names. See <code><a href="#hv_ename_delete">"hv_ename_delete"</a></code>.</p> <p>This is called when a stash is assigned to a new location in the symbol table.</p> 
<pre data-language="perl"><code class="plaintext">void  hv_ename_add(HV *hv, const char *name, U32 len, U32 flags)</code></pre> </dd> </dl> <dl> <dt id="hv_ename_delete">
<code>hv_ename_delete</code> </dt> <dd> <p>Removes a name from a stash's internal list of effective names. If this is the name returned by <code>HvENAME</code>, then another name in the list will take its place (<code>HvENAME</code> will use it).</p> <p>This is called when a stash is deleted from the symbol table.</p> 
<pre data-language="perl"><code class="plaintext">void  hv_ename_delete(HV *hv, const char *name, U32 len,
                      U32 flags)</code></pre> </dd> </dl> <dl> <dt id="hv_fill">
<code>hv_fill</code> </dt> <dd> <p>Returns the number of hash buckets that happen to be in use.</p> <p>This function implements the <a href="perlapi.html#HvFILL"><code>HvFILL</code> macro</a> which you should use instead.</p> <p>As of perl 5.25 this function is used only for debugging purposes, and the number of used hash buckets is not in any way cached, thus this function can be costly to execute as it must iterate over all the buckets in the hash.</p> <p>NOTE: <code>hv_fill</code> must be explicitly called as <code>Perl_hv_fill</code> with an <code>aTHX_</code> parameter.</p> 
<pre data-language="perl"><code class="plaintext">STRLEN  Perl_hv_fill(pTHX_ HV * const hv)</code></pre> </dd> </dl> <dl> <dt id="hv_placeholders_get">
<code>hv_placeholders_get</code> </dt> <dd> <p>Implements <code>HvPLACEHOLDERS_get</code>, which you should use instead.</p> <p>NOTE: <code>hv_placeholders_get</code> must be explicitly called as <code>Perl_hv_placeholders_get</code> with an <code>aTHX_</code> parameter.</p> 
<pre data-language="perl"><code class="plaintext">I32  Perl_hv_placeholders_get(pTHX_ const HV *hv)</code></pre> </dd> </dl> <dl> <dt id="hv_placeholders_set">
<code>hv_placeholders_set</code> </dt> <dd> <p>Implements <code>HvPLACEHOLDERS_set</code>, which you should use instead.</p> <p>NOTE: <code>hv_placeholders_set</code> must be explicitly called as <code>Perl_hv_placeholders_set</code> with an <code>aTHX_</code> parameter.</p> 
<pre data-language="perl"><code class="plaintext">void  Perl_hv_placeholders_set(pTHX_ HV *hv, I32 ph)</code></pre> </dd> </dl> <dl> <dt id="hv_riter_p">
<code>hv_riter_p</code> </dt> <dd> <p>Implements <code>HvRITER</code> which you should use instead.</p> <p>NOTE: <code>hv_riter_p</code> must be explicitly called as <code>Perl_hv_riter_p</code> with an <code>aTHX_</code> parameter.</p> 
<pre data-language="perl"><code class="plaintext">I32 *  Perl_hv_riter_p(pTHX_ HV *hv)</code></pre> </dd> </dl> <dl> <dt id="hv_riter_set">
<code>hv_riter_set</code> </dt> <dd> <p>Implements <code>HvRITER_set</code> which you should use instead.</p> <p>NOTE: <code>hv_riter_set</code> must be explicitly called as <code>Perl_hv_riter_set</code> with an <code>aTHX_</code> parameter.</p> 
<pre data-language="perl"><code class="plaintext">void  Perl_hv_riter_set(pTHX_ HV *hv, I32 riter)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_chain_2hv">
<code>refcounted_he_chain_2hv</code> </dt> <dd> <p>Generates and returns a <code>HV *</code> representing the content of a <code>refcounted_he</code> chain. <code>flags</code> is currently unused and must be zero.</p> 
<pre data-language="perl"><code class="plaintext">HV *  refcounted_he_chain_2hv(const struct refcounted_he *c,
                              U32 flags)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_fetch_pv">
<code>refcounted_he_fetch_pv</code> </dt> <dd> <p>Like <a href="#refcounted_he_fetch_pvn">"refcounted_he_fetch_pvn"</a>, but takes a nul-terminated string instead of a string/length pair.</p> 
<pre data-language="perl"><code class="plaintext">SV *  refcounted_he_fetch_pv(const struct refcounted_he *chain,
                             const char *key, U32 hash, U32 flags)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_fetch_pvn">
<code>refcounted_he_fetch_pvn</code> </dt> <dd> <p>Search along a <code>refcounted_he</code> chain for an entry with the key specified by <code>keypv</code> and <code>keylen</code>. If <code>flags</code> has the <code>REFCOUNTED_HE_KEY_UTF8</code> bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. <code>hash</code> is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar representing the value associated with the key, or <code>&amp;PL_sv_placeholder</code> if there is no value associated with the key.</p> 
<pre data-language="perl"><code class="plaintext">SV *  refcounted_he_fetch_pvn(const struct refcounted_he *chain,
                              const char *keypv, STRLEN keylen,
                              U32 hash, U32 flags)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_fetch_pvs">
<code>refcounted_he_fetch_pvs</code> </dt> <dd> <p>Like <a href="#refcounted_he_fetch_pvn">"refcounted_he_fetch_pvn"</a>, but takes a literal string instead of a string/length pair, and no precomputed hash.</p> 
<pre data-language="perl"><code class="plaintext">SV *  refcounted_he_fetch_pvs(const struct refcounted_he *chain,
                              "key", U32 flags)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_fetch_sv">
<code>refcounted_he_fetch_sv</code> </dt> <dd> <p>Like <a href="#refcounted_he_fetch_pvn">"refcounted_he_fetch_pvn"</a>, but takes a Perl scalar instead of a string/length pair.</p> 
<pre data-language="perl"><code class="plaintext">SV *  refcounted_he_fetch_sv(const struct refcounted_he *chain,
                             SV *key, U32 hash, U32 flags)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_free">
<code>refcounted_he_free</code> </dt> <dd> <p>Decrements the reference count of a <code>refcounted_he</code> by one. If the reference count reaches zero the structure's memory is freed, which (recursively) causes a reduction of its parent <code>refcounted_he</code>'s reference count. It is safe to pass a null pointer to this function: no action occurs in this case.</p> 
<pre data-language="perl"><code class="plaintext">void  refcounted_he_free(struct refcounted_he *he)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_inc">
<code>refcounted_he_inc</code> </dt> <dd> <p>Increment the reference count of a <code>refcounted_he</code>. The pointer to the <code>refcounted_he</code> is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</p> 
<pre data-language="perl"><code class="plaintext">struct refcounted_he *  refcounted_he_inc(
                                         struct refcounted_he *he)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_new_pv">
<code>refcounted_he_new_pv</code> </dt> <dd> <p>Like <a href="#refcounted_he_new_pvn">"refcounted_he_new_pvn"</a>, but takes a nul-terminated string instead of a string/length pair.</p> 
<pre data-language="perl"><code class="plaintext">struct refcounted_he *  refcounted_he_new_pv(
                                     struct refcounted_he *parent,
                                     const char *key, U32 hash,
                                     SV *value, U32 flags)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_new_pvn">
<code>refcounted_he_new_pvn</code> </dt> <dd> <p>Creates a new <code>refcounted_he</code>. This consists of a single key/value pair and a reference to an existing <code>refcounted_he</code> chain (which may be empty), and thus forms a longer chain. When using the longer chain, the new key/value pair takes precedence over any entry for the same key further along the chain.</p> <p>The new key is specified by <code>keypv</code> and <code>keylen</code>. If <code>flags</code> has the <code>REFCOUNTED_HE_KEY_UTF8</code> bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. <code>hash</code> is a precomputed hash of the key string, or zero if it has not been precomputed.</p> <p><code>value</code> is the scalar value to store for this key. <code>value</code> is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the <code>refcounted_he</code>. Complex types of scalar will not be stored with referential integrity, but will be coerced to strings. <code>value</code> may be either null or <code>&amp;PL_sv_placeholder</code> to indicate that no value is to be associated with the key; this, as with any non-null value, takes precedence over the existence of a value for the key further along the chain.</p> <p><code>parent</code> points to the rest of the <code>refcounted_he</code> chain to be attached to the new <code>refcounted_he</code>. This function takes ownership of one reference to <code>parent</code>, and returns one reference to the new <code>refcounted_he</code>.</p> 
<pre data-language="perl"><code class="plaintext">struct refcounted_he *  refcounted_he_new_pvn(
                                     struct refcounted_he *parent,
                                     const char *keypv,
                                     STRLEN keylen, U32 hash,
                                     SV *value, U32 flags)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_new_pvs">
<code>refcounted_he_new_pvs</code> </dt> <dd> <p>Like <a href="#refcounted_he_new_pvn">"refcounted_he_new_pvn"</a>, but takes a literal string instead of a string/length pair, and no precomputed hash.</p> 
<pre data-language="perl"><code class="plaintext">struct refcounted_he *  refcounted_he_new_pvs(
                                     struct refcounted_he *parent,
                                     "key", SV *value, U32 flags)</code></pre> </dd> </dl> <dl> <dt id="refcounted_he_new_sv">
<code>refcounted_he_new_sv</code> </dt> <dd> <p>Like <a href="#refcounted_he_new_pvn">"refcounted_he_new_pvn"</a>, but takes a Perl scalar instead of a string/length pair.</p> 
<pre data-language="perl"><code class="plaintext">struct refcounted_he *  refcounted_he_new_sv(
                                     struct refcounted_he *parent,
                                     SV *key, U32 hash, SV *value,
                                     U32 flags)</code></pre> </dd> </dl> <dl> <dt id="unsharepvn">
<code>unsharepvn</code> </dt> <dd> <p>If no one has access to shared string <code>str</code> with length <code>len</code>, free it.</p> <p><code>len</code> and <code>hash</code> must both be valid for <code>str</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  unsharepvn(const char *sv, I32 len, U32 hash)</code></pre> </dd> </dl> <h2 id="Input/Output">
Input/Output</h2> <dl> <dt id="dirp_dup">
<code>dirp_dup</code> </dt> <dd> <p>Duplicate a directory handle, returning a pointer to the cloned object.</p> 
<pre data-language="perl"><code class="plaintext">DIR *  dirp_dup(DIR * const dp, CLONE_PARAMS * const param)</code></pre> </dd> </dl> <dl> <dt id="fp_dup">
<code>fp_dup</code> </dt> <dd> <p>Duplicate a file handle, returning a pointer to the cloned object.</p> 
<pre data-language="perl"><code class="plaintext">PerlIO *  fp_dup(PerlIO * const fp, const char type,
                 CLONE_PARAMS * const param)</code></pre> </dd> </dl> <dl> <dt id="my_fflush_all">
<code>my_fflush_all</code> </dt> <dd> <p>Implements <code>PERL_FLUSHALL_FOR_CHILD</code> on some platforms.</p> 
<pre data-language="perl"><code class="plaintext">I32  my_fflush_all()</code></pre> </dd> </dl> <dl> <dt id="my_mkostemp">
<code>my_mkostemp</code> </dt> <dd> <p>The C library <code><a href="http://man.he.net/man3/mkostemp">mkostemp(3)</a></code> if available, or a Perl implementation of it.</p> <p>NOTE: <code>my_mkostemp</code> must be explicitly called as <code>Perl_my_mkostemp</code> .</p> 
<pre data-language="perl"><code class="plaintext">int  Perl_my_mkostemp(char *templte, int flags)</code></pre> </dd> </dl> <dl> <dt id="my_mkstemp">
<code>my_mkstemp</code> </dt> <dd> <p>The C library <code><a href="http://man.he.net/man3/mkstemp">mkstemp(3)</a></code> if available, or a Perl implementation of it.</p> <p>NOTE: <code>my_mkstemp</code> must be explicitly called as <code>Perl_my_mkstemp</code> .</p> 
<pre data-language="perl"><code class="plaintext">int  Perl_my_mkstemp(char *templte)</code></pre> </dd> </dl> <dl> <dt id="PL_last_in_gv">
<code>PL_last_in_gv</code> </dt> <dd> <p>The GV which was last used for a filehandle input operation. (<code>&lt;FH&gt;</code>)</p> <p>On threaded perls, each thread has an independent copy of this variable; each initialized at creation time with the current value of the creating thread's copy.</p> 
<pre data-language="perl"><code class="plaintext">GV*  PL_last_in_gv</code></pre> </dd> </dl> <dl> <dt id="PL_ofsgv">
<code>PL_ofsgv</code> </dt> <dd> <p>The glob containing the output field separator - <code>*,</code> in Perl space.</p> <p>On threaded perls, each thread has an independent copy of this variable; each initialized at creation time with the current value of the creating thread's copy.</p> 
<pre data-language="perl"><code class="plaintext">GV*  PL_ofsgv</code></pre> </dd> </dl> <dl> <dt id="PL_rs">
<code>PL_rs</code> </dt> <dd> <p>The input record separator - <code>$/</code> in Perl space.</p> <p>On threaded perls, each thread has an independent copy of this variable; each initialized at creation time with the current value of the creating thread's copy.</p> 
<pre data-language="perl"><code class="plaintext">SV*  PL_rs</code></pre> </dd> </dl> <dl> <dt id="start_glob">
<code>start_glob</code> </dt> <dd> <p>NOTE: <code>start_glob</code> is <b>experimental</b> and may change or be removed without notice.</p> <p>Function called by <code>do_readline</code> to spawn a glob (or do the glob inside perl on VMS). This code used to be inline, but now perl uses <code>File::Glob</code> this glob starter is only used by miniperl during the build process, or when PERL_EXTERNAL_GLOB is defined. Moving it away shrinks <i>pp_hot.c</i>; shrinking <i>pp_hot.c</i> helps speed perl up.</p> <p>NOTE: <code>start_glob</code> must be explicitly called as <code>Perl_start_glob</code> with an <code>aTHX_</code> parameter.</p> 
<pre data-language="perl"><code class="plaintext">PerlIO *  Perl_start_glob(pTHX_ SV *tmpglob, IO *io)</code></pre> </dd> </dl> <h2 id="Integer">Integer</h2> <p>There are currently no internal API items in Integer</p> <h2 id="I/O-Formats">
I/O Formats</h2> <p>There are currently no internal API items in I/O Formats</p> <h2 id="Lexer-interface">
Lexer interface</h2> <dl> <dt id="resume_compcv_and_save">
<code>resume_compcv_and_save</code> </dt> <dd> <p>Resumes a buffer previously suspended by the <code>suspend_compcv</code> function, in a way that will be re-suspended at the end of the scope so it can be used again later. This should be used within an <code>ENTER</code>/<code>LEAVE</code> scoped pair.</p> 
<pre data-language="perl"><code class="plaintext">void  resume_compcv_and_save(struct suspended_compcv *buffer)</code></pre> </dd> </dl> <dl> <dt id="resume_compcv_final">
<code>resume_compcv_final</code> </dt> <dd> <p>Resumes the parser state previously saved using the <code>suspend_compcv</code> function for a final time before being compiled into a full CV. This should be used within an <code>ENTER</code>/<code>LEAVE</code> scoped pair.</p> 
<pre data-language="perl"><code class="plaintext">void  resume_compcv_final(struct suspended_compcv *buffer)</code></pre> </dd> </dl> <dl> <dt id="validate_proto">
<code>validate_proto</code> </dt> <dd> <p>NOTE: <code>validate_proto</code> is <b>experimental</b> and may change or be removed without notice.</p> <p>This function performs syntax checking on a prototype, <code>proto</code>. If <code>warn</code> is true, any illegal characters or mismatched brackets will trigger illegalproto warnings, declaring that they were detected in the prototype for <code>name</code>.</p> <p>The return value is <code>true</code> if this is a valid prototype, and <code>false</code> if it is not, regardless of whether <code>warn</code> was <code>true</code> or <code>false</code>.</p> <p>Note that <code>NULL</code> is a valid <code>proto</code> and will always return <code>true</code>.</p> 
<pre data-language="perl"><code class="plaintext">bool  validate_proto(SV *name, SV *proto, bool warn,
                     bool curstash)</code></pre> </dd> </dl> <h2 id="Locales">Locales</h2> <p>There are currently no internal API items in Locales</p> <h2 id="Magic">Magic</h2> <dl> <dt id="magic_clearhint">
<code>magic_clearhint</code> </dt> <dd> <p>Triggered by a delete from <code>%^H</code>, records the key to <code>PL_compiling.cop_hints_hash</code>.</p> 
<pre data-language="perl"><code class="plaintext">int  magic_clearhint(SV *sv, MAGIC *mg)</code></pre> </dd> </dl> <dl> <dt id="magic_clearhints">
<code>magic_clearhints</code> </dt> <dd> <p>Triggered by clearing <code>%^H</code>, resets <code>PL_compiling.cop_hints_hash</code>.</p> 
<pre data-language="perl"><code class="plaintext">int  magic_clearhints(SV *sv, MAGIC *mg)</code></pre> </dd> </dl> <dl> <dt id="magic_methcall">
<code>magic_methcall</code> </dt> <dd> <p>Invoke a magic method (like FETCH).</p> <p><code>sv</code> and <code>mg</code> are the tied thingy and the tie magic.</p> <p><code>meth</code> is the name of the method to call.</p> <p><code>argc</code> is the number of args (in addition to $self) to pass to the method.</p> <p>The <code>flags</code> can be:</p> <pre data-language="perl"><code class="plaintext">G_DISCARD     invoke method with G_DISCARD flag and don't
              return a value
G_UNDEF_FILL  fill the stack with argc pointers to
              PL_sv_undef</code></pre> <p>The arguments themselves are any values following the <code>flags</code> argument.</p> <p>Returns the SV (if any) returned by the method, or <code>NULL</code> on failure.</p> <p>NOTE: <code>magic_methcall</code> must be explicitly called as <code>Perl_magic_methcall</code> with an <code>aTHX_</code> parameter.</p> 
<pre data-language="perl"><code class="plaintext">SV *  Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg,
                          SV *meth, U32 flags, U32 argc, ...)</code></pre> </dd> </dl> <dl> <dt id="magic_sethint">
<code>magic_sethint</code> </dt> <dd> <p>Triggered by a store to <code>%^H</code>, records the key/value pair to <code>PL_compiling.cop_hints_hash</code>. It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</p> 
<pre data-language="perl"><code class="plaintext">int  magic_sethint(SV *sv, MAGIC *mg)</code></pre> </dd> </dl> <dl> <dt id="mg_dup">
<code>mg_dup</code> </dt> <dd> <p>Duplicate a chain of magic, returning a pointer to the cloned object.</p> 
<pre data-language="perl"><code class="plaintext">MAGIC *  mg_dup(MAGIC *mg, CLONE_PARAMS * const param)</code></pre> </dd> </dl> <dl> <dt id="mg_localize">
<code>mg_localize</code> </dt> <dd> <p>Copy some of the magic from an existing SV to new localized version of that SV. Container magic (<i>e.g.</i>, <code>%ENV</code>, <code>$1</code>, <code>tie</code>) gets copied, value magic doesn't (<i>e.g.</i>, <code>taint</code>, <code>pos</code>).</p> <p>If <code>setmagic</code> is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. <span style="white-space: nowrap;"><code>'local $x = $y'</code></span>), and that will handle the magic.</p> 
<pre data-language="perl"><code class="plaintext">void  mg_localize(SV *sv, SV *nsv, bool setmagic)</code></pre> </dd> </dl> <h2 id="Memory-Management">
Memory Management</h2> <dl> <dt id="calloc">
<code>calloc</code> </dt> <dd> <p>Implements <a href="perlapi.html#Newxz">"<code>Newxz</code>" in perlapi</a> which you should use instead.</p> <p>NOTE: <code>calloc</code> must be explicitly called as <code>Perl_calloc</code> .</p> 
<pre data-language="perl"><code class="plaintext">Malloc_t  Perl_calloc(MEM_SIZE elements, MEM_SIZE size)</code></pre> </dd> </dl> <dl> <dt id="malloc">
<code>malloc</code> </dt> <dd> <p>Implements <a href="perlapi.html#Newx">"<code>Newx</code>" in perlapi</a> which you should use instead.</p> <p>NOTE: <code>malloc</code> must be explicitly called as <code>Perl_malloc</code> .</p> 
<pre data-language="perl"><code class="plaintext">Malloc_t  Perl_malloc(MEM_SIZE nbytes)</code></pre> </dd> </dl> <dl> <dt id="mfree">
<code>mfree</code> </dt> <dd> <p>Implements <a href="perlapi.html#Safefree">"<code>Safefree</code>" in perlapi</a> which you should use instead.</p> <p>NOTE: <code>mfree</code> must be explicitly called as <code>Perl_mfree</code> .</p> 
<pre data-language="perl"><code class="plaintext">Free_t  Perl_mfree(Malloc_t where)</code></pre> </dd> </dl> <dl> <dt id="realloc">
<code>realloc</code> </dt> <dd> <p>Implements <a href="perlapi.html#Renew">"<code>Renew</code>" in perlapi</a> which you should use instead.</p> <p>NOTE: <code>realloc</code> must be explicitly called as <code>Perl_realloc</code> .</p> 
<pre data-language="perl"><code class="plaintext">Malloc_t  Perl_realloc(Malloc_t where, MEM_SIZE nbytes)</code></pre> </dd> </dl> <h2 id="MRO">MRO</h2> <dl> <dt id="mro_get_linear_isa_dfs">
<code>mro_get_linear_isa_dfs</code> </dt> <dd> <p>Returns the Depth-First Search linearization of <code>@ISA</code> the given stash. The return value is a read-only AV* whose elements are string SVs giving class names. <code>level</code> should be 0 (it is used internally in this function's recursion).</p> <p>You are responsible for <code>SvREFCNT_inc()</code> on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</p> 
<pre data-language="perl"><code class="plaintext">AV *  mro_get_linear_isa_dfs(HV *stash, U32 level)</code></pre> </dd> </dl> <dl> <dt id="mro_isa_changed_in">
<code>mro_isa_changed_in</code> </dt> <dd> <p>Takes the necessary steps (cache invalidations, mostly) when the <code>@ISA</code> of the given package has changed. Invoked by the <code>setisa</code> magic, should not need to invoke directly.</p> 
<pre data-language="perl"><code class="plaintext">void  mro_isa_changed_in(HV *stash)</code></pre> </dd> </dl> <dl> <dt id="mro_package_moved">
<code>mro_package_moved</code> </dt> <dd> <p>Call this function to signal to a stash that it has been assigned to another spot in the stash hierarchy. <code>stash</code> is the stash that has been assigned. <code>oldstash</code> is the stash it replaces, if any. <code>gv</code> is the glob that is actually being assigned to.</p> <p>This can also be called with a null first argument to indicate that <code>oldstash</code> has been deleted.</p> <p>This function invalidates isa caches on the old stash, on all subpackages nested inside it, and on the subclasses of all those, including non-existent packages that have corresponding entries in <code>stash</code>.</p> <p>It also sets the effective names (<code>HvENAME</code>) on all the stashes as appropriate.</p> <p>If the <code>gv</code> is present and is not in the symbol table, then this function simply returns. This checked will be skipped if <code>flags &amp; 1</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  mro_package_moved(HV * const stash, HV * const oldstash,
                        const GV * const gv, U32 flags)</code></pre> </dd> </dl> <h2 id="Multicall-Functions">
Multicall Functions</h2> <p>There are currently no internal API items in Multicall Functions</p> <h2 id="Numeric-Functions">
Numeric Functions</h2> <dl> <dt id="isinfnansv">
<code>isinfnansv</code> </dt> <dd> <p>Checks whether the argument would be either an infinity or <code>NaN</code> when used as a number, but is careful not to trigger non-numeric or uninitialized warnings. it assumes the caller has done <code>SvGETMAGIC(sv)</code> already.</p> <p>Note that this always accepts trailing garbage (similar to <code>grok_number_flags</code> with <code>PERL_SCAN_TRAILING</code>), so <code>"inferior"</code> and <code>"NAND gates"</code> will return true.</p> 
<pre data-language="perl"><code class="plaintext">bool  isinfnansv(SV *sv)</code></pre> </dd> </dl> <h2 id="Optrees">Optrees</h2> <dl> <dt id="newATTRSUB_x">
<code>newATTRSUB_x</code> </dt> <dd> <p>Construct a Perl subroutine, also performing some surrounding jobs.</p> <p>This function is expected to be called in a Perl compilation context, and some aspects of the subroutine are taken from global variables associated with compilation. In particular, <code>PL_compcv</code> represents the subroutine that is currently being compiled. It must be non-null when this function is called, and some aspects of the subroutine being constructed are taken from it. The constructed subroutine may actually be a reuse of the <code>PL_compcv</code> object, but will not necessarily be so.</p> <p>If <code>block</code> is null then the subroutine will have no body, and for the time being it will be an error to call it. This represents a forward subroutine declaration such as <span style="white-space: nowrap;"><code>sub foo ($$);</code></span>. If <code>block</code> is non-null then it provides the Perl code of the subroutine body, which will be executed when the subroutine is called. This body includes any argument unwrapping code resulting from a subroutine signature or similar. The pad use of the code must correspond to the pad attached to <code>PL_compcv</code>. The code is not expected to include a <code>leavesub</code> or <code>leavesublv</code> op; this function will add such an op. <code>block</code> is consumed by this function and will become part of the constructed subroutine.</p> <p><code>proto</code> specifies the subroutine's prototype, unless one is supplied as an attribute (see below). If <code>proto</code> is null, then the subroutine will not have a prototype. If <code>proto</code> is non-null, it must point to a <code>const</code> op whose value is a string, and the subroutine will have that string as its prototype. If a prototype is supplied as an attribute, the attribute takes precedence over <code>proto</code>, but in that case <code>proto</code> should preferably be null. In any case, <code>proto</code> is consumed by this function.</p> <p><code>attrs</code> supplies attributes to be applied the subroutine. A handful of attributes take effect by built-in means, being applied to <code>PL_compcv</code> immediately when seen. Other attributes are collected up and attached to the subroutine by this route. <code>attrs</code> may be null to supply no attributes, or point to a <code>const</code> op for a single attribute, or point to a <code>list</code> op whose children apart from the <code>pushmark</code> are <code>const</code> ops for one or more attributes. Each <code>const</code> op must be a string, giving the attribute name optionally followed by parenthesised arguments, in the manner in which attributes appear in Perl source. The attributes will be applied to the sub by this function. <code>attrs</code> is consumed by this function.</p> <p>If <code>o_is_gv</code> is false and <code>o</code> is null, then the subroutine will be anonymous. If <code>o_is_gv</code> is false and <code>o</code> is non-null, then <code>o</code> must point to a <code>const</code> OP, which will be consumed by this function, and its string value supplies a name for the subroutine. The name may be qualified or unqualified, and if it is unqualified then a default stash will be selected in some manner. If <code>o_is_gv</code> is true, then <code>o</code> doesn't point to an <code>OP</code> at all, but is instead a cast pointer to a <code>GV</code> by which the subroutine will be named.</p> <p>If there is already a subroutine of the specified name, then the new sub will either replace the existing one in the glob or be merged with the existing one. A warning may be generated about redefinition.</p> <p>If the subroutine has one of a few special names, such as <code>BEGIN</code> or <code>END</code>, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of <code>BEGIN</code>, the subroutine will be executed and the reference to it disposed of before this function returns.</p> <p>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase's automatic run queue. But a <code>BEGIN</code> subroutine, having already been executed, will quite likely have been destroyed already by the time this function returns, making it erroneous for the caller to make any use of the returned pointer. It is the caller's responsibility to ensure that it knows which of these situations applies.</p> 
<pre data-language="perl"><code class="plaintext">CV *  newATTRSUB_x(I32 floor, OP *o, OP *proto, OP *attrs,
                   OP *block, bool o_is_gv)</code></pre> </dd> </dl> <dl> <dt id="newXS_len_flags">
<code>newXS_len_flags</code> </dt> <dd> <p>Construct an XS subroutine, also performing some surrounding jobs.</p> <p>The subroutine will have the entry point <code>subaddr</code>. It will have the prototype specified by the nul-terminated string <code>proto</code>, or no prototype if <code>proto</code> is null. The prototype string is copied; the caller can mutate the supplied string afterwards. If <code>filename</code> is non-null, it must be a nul-terminated filename, and the subroutine will have its <code>CvFILE</code> set accordingly. By default <code>CvFILE</code> is set to point directly to the supplied string, which must be static. If <code>flags</code> has the <code>XS_DYNAMIC_FILENAME</code> bit set, then a copy of the string will be taken instead.</p> <p>Other aspects of the subroutine will be left in their default state. If anything else needs to be done to the subroutine for it to function correctly, it is the caller's responsibility to do that after this function has constructed it. However, beware of the subroutine potentially being destroyed before this function returns, as described below.</p> <p>If <code>name</code> is null then the subroutine will be anonymous, with its <code>CvGV</code> referring to an <code>__ANON__</code> glob. If <code>name</code> is non-null then the subroutine will be named accordingly, referenced by the appropriate glob. <code>name</code> is a string of length <code>len</code> bytes giving a sigilless symbol name, in UTF-8 if <code>flags</code> has the <code>SVf_UTF8</code> bit set and in Latin-1 otherwise. The name may be either qualified or unqualified, with the stash defaulting in the same manner as for <code>gv_fetchpvn_flags</code>. <code>flags</code> may contain flag bits understood by <code>gv_fetchpvn_flags</code> with the same meaning as they have there, such as <code>GV_ADDWARN</code>. The symbol is always added to the stash if necessary, with <code>GV_ADDMULTI</code> semantics.</p> <p>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition. If the old subroutine was <code>CvCONST</code> then the decision about whether to warn is influenced by an expectation about whether the new subroutine will become a constant of similar value. That expectation is determined by <code>const_svp</code>. (Note that the call to this function doesn't make the new subroutine <code>CvCONST</code> in any case; that is left to the caller.) If <code>const_svp</code> is null then it indicates that the new subroutine will not become a constant. If <code>const_svp</code> is non-null then it indicates that the new subroutine will become a constant, and it points to an <code>SV*</code> that provides the constant value that the subroutine will have.</p> <p>If the subroutine has one of a few special names, such as <code>BEGIN</code> or <code>END</code>, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of <code>BEGIN</code>, the subroutine will be executed and the reference to it disposed of before this function returns, and also before its prototype is set. If a <code>BEGIN</code> subroutine would not be sufficiently constructed by this function to be ready for execution then the caller must prevent this happening by giving the subroutine a different name.</p> <p>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase's automatic run queue. But a <code>BEGIN</code> subroutine, having already been executed, will quite likely have been destroyed already by the time this function returns, making it erroneous for the caller to make any use of the returned pointer. It is the caller's responsibility to ensure that it knows which of these situations applies.</p> 
<pre data-language="perl"><code class="plaintext">CV *  newXS_len_flags(const char *name, STRLEN len,
                      XSUBADDR_t subaddr,
                      const char * const filename,
                      const char * const proto, SV ** const_svp,
                      U32 flags)</code></pre> </dd> </dl> <dl> <dt id="op_refcnt_lock">
<code>op_refcnt_lock</code> </dt> <dd> <p>Implements the <code>OP_REFCNT_LOCK</code> macro which you should use instead.</p> 
<pre data-language="perl"><code class="plaintext">void  op_refcnt_lock()</code></pre> </dd> </dl> <dl> <dt id="op_refcnt_unlock">
<code>op_refcnt_unlock</code> </dt> <dd> <p>Implements the <code>OP_REFCNT_UNLOCK</code> macro which you should use instead.</p> 
<pre data-language="perl"><code class="plaintext">void  op_refcnt_unlock()</code></pre> </dd> </dl> <dl> <dt id="traverse_op_tree">
<code>traverse_op_tree</code> </dt> <dd> <p>Return the next op in a depth-first traversal of the op tree, returning NULL when the traversal is complete.</p> <p>The initial call must supply the root of the tree as both top and o.</p> <p>For now it's static, but it may be exposed to the API in the future.</p> 
<pre data-language="perl"><code class="plaintext">OP *  traverse_op_tree(OP *top, OP *o)</code></pre> </dd> </dl> <h2 id="Pack-and-Unpack">
Pack and Unpack</h2> <p>There are currently no internal API items in Pack and Unpack</p> <h2 id="Pad-Data-Structures">
Pad Data Structures</h2> <dl> <dt id="CX_CURPAD_SAVE">
<code>CX_CURPAD_SAVE</code> </dt> <dd> <p>Save the current pad in the given context block structure.</p> 
<pre data-language="perl"><code class="plaintext">void  CX_CURPAD_SAVE(struct context)</code></pre> </dd> </dl> <dl> <dt id="CX_CURPAD_SV">
<code>CX_CURPAD_SV</code> </dt> <dd> <p>Access the SV at offset <code>po</code> in the saved current pad in the given context block structure (can be used as an lvalue).</p> 
<pre data-language="perl"><code class="plaintext">SV *  CX_CURPAD_SV(struct context, PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="PAD_BASE_SV">
<code>PAD_BASE_SV</code> </dt> <dd> <p>Get the value from slot <code>po</code> in the base (DEPTH=1) pad of a padlist</p> 
<pre data-language="perl"><code class="plaintext">SV *  PAD_BASE_SV(PADLIST padlist, PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="PAD_CLONE_VARS">
<code>PAD_CLONE_VARS</code> </dt> <dd> <p>Clone the state variables associated with running and compiling pads.</p> 
<pre data-language="perl"><code class="plaintext">void  PAD_CLONE_VARS(PerlInterpreter *proto_perl,
                     CLONE_PARAMS* param)</code></pre> </dd> </dl> <dl> <dt id="PAD_COMPNAME_FLAGS">
<code>PAD_COMPNAME_FLAGS</code> </dt> <dd> <p>Return the flags for the current compiling pad name at offset <code>po</code>. Assumes a valid slot entry.</p> 
<pre data-language="perl"><code class="plaintext">U32  PAD_COMPNAME_FLAGS(PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="PAD_COMPNAME_GEN">
<code>PAD_COMPNAME_GEN</code> </dt> <dd> <p>The generation number of the name at offset <code>po</code> in the current compiling pad (lvalue).</p> 
<pre data-language="perl"><code class="plaintext">STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="PAD_COMPNAME_GEN_set">
<code>PAD_COMPNAME_GEN_set</code> </dt> <dd> <p>Sets the generation number of the name at offset <code>po</code> in the current ling pad (lvalue) to <code>gen</code>.</p> 
<pre data-language="perl"><code class="plaintext">STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)</code></pre> </dd> </dl> <dl> <dt id="PAD_COMPNAME_OURSTASH">
<code>PAD_COMPNAME_OURSTASH</code> </dt> <dd> <p>Return the stash associated with an <code>our</code> variable. Assumes the slot entry is a valid <code>our</code> lexical.</p> 
<pre data-language="perl"><code class="plaintext">HV *  PAD_COMPNAME_OURSTASH(PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="PAD_COMPNAME_PV">
<code>PAD_COMPNAME_PV</code> </dt> <dd> <p>Return the name of the current compiling pad name at offset <code>po</code>. Assumes a valid slot entry.</p> 
<pre data-language="perl"><code class="plaintext">char *  PAD_COMPNAME_PV(PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="PAD_COMPNAME_TYPE">
<code>PAD_COMPNAME_TYPE</code> </dt> <dd> <p>Return the type (stash) of the current compiling pad name at offset <code>po</code>. Must be a valid name. Returns null if not typed.</p> 
<pre data-language="perl"><code class="plaintext">HV *  PAD_COMPNAME_TYPE(PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="PadnameIsFIELD">
<code>PadnameIsFIELD</code> </dt> <dd> <p>Whether this is a "field" variable. PADNAMEs where this is true will have additional information available via <code>PadnameFIELDINFO</code>.</p> 
<pre data-language="perl"><code class="plaintext">bool  PadnameIsFIELD(PADNAME * pn)</code></pre> </dd> </dl> <dl> <dt id="PadnameIsOUR">
<code>PadnameIsOUR</code> </dt> <dd> <p>Whether this is an "our" variable.</p> 
<pre data-language="perl"><code class="plaintext">bool  PadnameIsOUR(PADNAME * pn)</code></pre> </dd> </dl> <dl> <dt id="PadnameIsSTATE">
<code>PadnameIsSTATE</code> </dt> <dd> <p>Whether this is a "state" variable.</p> 
<pre data-language="perl"><code class="plaintext">bool  PadnameIsSTATE(PADNAME * pn)</code></pre> </dd> </dl> <dl> <dt id="PadnameOURSTASH">
<code>PadnameOURSTASH</code> </dt> <dd> <p>The stash in which this "our" variable was declared.</p> 
<pre data-language="perl"><code class="plaintext">HV *  PadnameOURSTASH(PADNAME * pn)</code></pre> </dd> </dl> <dl> <dt id="PadnameOUTER">
<code>PadnameOUTER</code> </dt> <dd> <p>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</p> 
<pre data-language="perl"><code class="plaintext">bool  PadnameOUTER(PADNAME * pn)</code></pre> </dd> </dl> <dl> <dt id="PadnameTYPE">
<code>PadnameTYPE</code> </dt> <dd> <p>The stash associated with a typed lexical. This returns the <code>%Foo::</code> hash for <code>my Foo $bar</code>.</p> 
<pre data-language="perl"><code class="plaintext">HV *  PadnameTYPE(PADNAME * pn)</code></pre> </dd> </dl> <dl> <dt id="PAD_RESTORE_LOCAL">
<code>PAD_RESTORE_LOCAL</code> </dt> <dd> <p>Restore the old pad saved into the local variable <code>opad</code> by <code>PAD_SAVE_LOCAL()</code></p> 
<pre data-language="perl"><code class="plaintext">void  PAD_RESTORE_LOCAL(PAD *opad)</code></pre> </dd> </dl> <dl> <dt id="PAD_SAVE_LOCAL">
<code>PAD_SAVE_LOCAL</code> </dt> <dd> <p>Save the current pad to the local variable <code>opad</code>, then make the current pad equal to <code>npad</code></p> 
<pre data-language="perl"><code class="plaintext">void  PAD_SAVE_LOCAL(PAD *opad, PAD *npad)</code></pre> </dd> </dl> <dl> <dt id="PAD_SAVE_SETNULLPAD">
<code>PAD_SAVE_SETNULLPAD</code> </dt> <dd> <p>Save the current pad then set it to null.</p> 
<pre data-language="perl"><code class="plaintext">void  PAD_SAVE_SETNULLPAD()</code></pre> </dd> </dl> <dl> <dt id="PAD_SET_CUR">
<code>PAD_SET_CUR</code> </dt> <dd> <p>Set the current pad to be pad <code>n</code> in the padlist, saving the previous current pad. NB currently this macro expands to a string too long for some compilers, so it's best to replace it with</p> <pre data-language="perl"><code>SAVECOMPPAD();
PAD_SET_CUR_NOSAVE(padlist,n);</code></pre> 
<pre data-language="perl"><code class="plaintext">void  PAD_SET_CUR(PADLIST padlist, I32 n)</code></pre> </dd> </dl> <dl> <dt id="PAD_SET_CUR_NOSAVE">
<code>PAD_SET_CUR_NOSAVE</code> </dt> <dd> <p>like PAD_SET_CUR, but without the save</p> 
<pre data-language="perl"><code class="plaintext">void  PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)</code></pre> </dd> </dl> <dl> <dt id="PAD_SETSV">
<code>PAD_SETSV</code> </dt> <dd> <p>Set the slot at offset <code>po</code> in the current pad to <code>sv</code></p> 
<pre data-language="perl"><code class="plaintext">SV *  PAD_SETSV(PADOFFSET po, SV* sv)</code></pre> </dd> </dl> <dl> <dt id="PAD_SV">
<code>PAD_SV</code> </dt> <dd> <p>Get the value at offset <code>po</code> in the current pad</p> 
<pre data-language="perl"><code class="plaintext">SV *  PAD_SV(PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="PAD_SVl">
<code>PAD_SVl</code> </dt> <dd> <p>Lightweight and lvalue version of <code>PAD_SV</code>. Get or set the value at offset <code>po</code> in the current pad. Unlike <code>PAD_SV</code>, does not print diagnostics with -DX. For internal use only.</p> 
<pre data-language="perl"><code class="plaintext">SV *  PAD_SVl(PADOFFSET po)</code></pre> </dd> </dl> <dl> <dt id="SAVECLEARSV">
<code>SAVECLEARSV</code> </dt> <dd> <p>Clear the pointed to pad value on scope exit. (i.e. the runtime action of <code>my</code>)</p> 
<pre data-language="perl"><code class="plaintext">void  SAVECLEARSV(SV **svp)</code></pre> </dd> </dl> <dl> <dt id="SAVECOMPPAD">
<code>SAVECOMPPAD</code> </dt> <dd> <p>save <code>PL_comppad</code> and <code>PL_curpad</code></p> 
<pre data-language="perl"><code class="plaintext">void  SAVECOMPPAD()</code></pre> </dd> </dl> <dl> <dt id="SAVEPADSV">
<code>SAVEPADSV</code> </dt> <dd> <p>Save a pad slot (used to restore after an iteration)</p> 
<pre data-language="perl"><code class="plaintext">void  SAVEPADSV(PADOFFSET po)</code></pre> </dd> </dl> <h2 id="Password-and-Group-access">
Password and Group access</h2> <p>There are currently no internal API items in Password and Group access</p> <h2 id="Paths-to-system-commands">
Paths to system commands</h2> <p>There are currently no internal API items in Paths to system commands</p> <h2 id="Prototype-information">
Prototype information</h2> <p>There are currently no internal API items in Prototype information</p> <h2 id="REGEXP-Functions">
REGEXP Functions</h2> <dl> <dt id="regnode"><code>regnode</code></dt> <dd> <p>Described in <a href="perlreguts.html">perlreguts</a>.</p> </dd> </dl> <h2 id="Reports-and-Formats">
Reports and Formats</h2> <p>There are currently no internal API items in Reports and Formats</p> <h2 id="Signals">Signals</h2> <p>There are currently no internal API items in Signals</p> <h2 id="Site-configuration">
Site configuration</h2> <p>There are currently no internal API items in Site configuration</p> <h2 id="Sockets-configuration-values">
Sockets configuration values</h2> <p>There are currently no internal API items in Sockets configuration values</p> <h2 id="Source-Filters">
Source Filters</h2> <p>There are currently no internal API items in Source Filters</p> <h2 id="Stack-Manipulation-Macros">
Stack Manipulation Macros</h2> <dl> <dt id="djSP">
<code>djSP</code> </dt> <dd> <p>Declare Just <code>SP</code>. This is actually identical to <code>dSP</code>, and declares a local copy of perl's stack pointer, available via the <code>SP</code> macro. See <code><a href="perlapi.html#SP">"SP" in perlapi</a></code>. (Available for backward source code compatibility with the old (Perl 5.005) thread model.)</p> 
<pre data-language="perl"><code>djSP();</code></pre> </dd> </dl> <dl> <dt id="LVRET">
<code>LVRET</code> </dt> <dd> <p>True if this op will be the return value of an lvalue subroutine</p> </dd> </dl> <dl> <dt id="save_alloc">
<code>save_alloc</code> </dt> <dd> <p>Implements <a href="perlapi.html#SSNEW">"<code>SSNEW</code>" in perlapi</a> and kin, which should be used instead of this function.</p> 
<pre data-language="perl"><code class="plaintext">SSize_t  save_alloc(SSize_t size, I32 pad)</code></pre> </dd> </dl> <h2 id="String-Handling">
String Handling</h2> <dl> <dt id="delimcpy_no_escape">
<code>delimcpy_no_escape</code> </dt> <dd> <p>Copy a source buffer to a destination buffer, stopping at (but not including) the first occurrence in the source of the delimiter byte, <code>delim</code>. The source is the bytes between <span style="white-space: nowrap;"><code>from</code> and <code>from_end</code> - 1</span>. Similarly, the dest is <code>to</code> up to <code>to_end</code>.</p> <p>The number of bytes copied is written to <code>*retlen</code>.</p> <p>Returns the position of <code>delim</code> in the <code>from</code> buffer, but if there is no such occurrence before <code>from_end</code>, then <code>from_end</code> is returned, and the entire buffer <span style="white-space: nowrap;"><code>from</code> .. <code>from_end</code> - 1</span> is copied.</p> <p>If there is room in the destination available after the copy, an extra terminating safety <code>NUL</code> byte is appended (not included in the returned length).</p> <p>The error case is if the destination buffer is not large enough to accommodate everything that should be copied. In this situation, a value larger than <span style="white-space: nowrap;"><code>to_end</code> - <code>to</code></span> is written to <code>*retlen</code>, and as much of the source as fits will be written to the destination. Not having room for the safety <code>NUL</code> is not considered an error.</p> 
<pre data-language="perl"><code class="plaintext">char *  delimcpy_no_escape(char *to, const char *to_end,
                           const char *from, const char *from_end,
                           const int delim, I32 *retlen)</code></pre> </dd> </dl> <dl> <dt id="my_cxt_init">
<code>my_cxt_init</code> </dt> <dd> <p>Implements the <a href="perlxs.html#MY_CXT_INIT">"<code>MY_CXT_INIT</code>" in perlxs</a> macro, which you should use instead.</p> <p>The first time a module is loaded, the global <code>PL_my_cxt_index</code> is incremented, and that value is assigned to that module's static <code>my_cxt_index</code> (whose address is passed as an arg). Then, for each interpreter this function is called for, it makes sure a <code>void*</code> slot is available to hang the static data off, by allocating or extending the interpreter's <code>PL_my_cxt_list</code> array</p> <p>NOTE: <code>my_cxt_init</code> must be explicitly called as <code>Perl_my_cxt_init</code> with an <code>aTHX_</code> parameter.</p> 
<pre data-language="perl"><code class="plaintext">void *  Perl_my_cxt_init(pTHX_ int *indexp, size_t size)</code></pre> </dd> </dl> <dl> <dt id="quadmath_format_needed">
<code>quadmath_format_needed</code> </dt> <dd> <p><code>quadmath_format_needed()</code> returns true if the <code>format</code> string seems to contain at least one non-Q-prefixed <code>%[efgaEFGA]</code> format specifier, or returns false otherwise.</p> <p>The format specifier detection is not complete printf-syntax detection, but it should catch most common cases.</p> <p>If true is returned, those arguments <b>should</b> in theory be processed with <code>quadmath_snprintf()</code>, but in case there is more than one such format specifier (see <a href="#quadmath_format_valid">"quadmath_format_valid"</a>), and if there is anything else beyond that one (even just a single byte), they <b>cannot</b> be processed because <code>quadmath_snprintf()</code> is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</p> 
<pre data-language="perl"><code class="plaintext">bool  quadmath_format_needed(const char *format)</code></pre> </dd> </dl> <dl> <dt id="quadmath_format_valid">
<code>quadmath_format_valid</code> </dt> <dd> <p><code>quadmath_snprintf()</code> is very strict about its <code>format</code> string and will fail, returning -1, if the format is invalid. It accepts exactly one format spec.</p> <p><code>quadmath_format_valid()</code> checks that the intended single spec looks sane: begins with <code>%</code>, has only one <code>%</code>, ends with <code>[efgaEFGA]</code>, and has <code>Q</code> before it. This is not a full "printf syntax check", just the basics.</p> <p>Returns true if it is valid, false if not.</p> <p>See also <a href="#quadmath_format_needed">"quadmath_format_needed"</a>.</p> 
<pre data-language="perl"><code class="plaintext">bool  quadmath_format_valid(const char *format)</code></pre> </dd> </dl> <h2 id="SV-Flags">
SV Flags</h2> <dl> <dt id="SVt_INVLIST">
<code>SVt_INVLIST</code> </dt> <dd> <p>Type flag for scalars. See <a href="perlapi.html#svtype">"svtype" in perlapi</a>.</p> </dd> </dl> <h2 id="SV-Handling">
SV Handling</h2> <dl> <dt id="PL_Sv">
<code>PL_Sv</code> </dt> <dd> <p>A scratch pad SV for whatever temporary use you need. Chiefly used as a fallback by macros on platforms where <a href="perlapi.html#PERL_USE_GCC_BRACE_GROUPS">"PERL_USE_GCC_BRACE_GROUPS" in perlapi</a>&gt; is unavailable, and which would otherwise evaluate their SV parameter more than once.</p> <p><b>BUT BEWARE</b>, if this is used in a situation where something that is using it is in a call stack with something else that is using it, this variable would get zapped, leading to hard-to-diagnose errors.</p> 
<pre data-language="perl"><code class="plaintext">PL_Sv</code></pre> </dd> </dl> <dl> <dt id="sv_add_arena">
<code>sv_add_arena</code> </dt> <dd> <p>Given a chunk of memory, link it to the head of the list of arenas, and split it into a list of free SVs.</p> 
<pre data-language="perl"><code class="plaintext">void  sv_add_arena(char * const ptr, const U32 size,
                   const U32 flags)</code></pre> </dd> </dl> <dl> <dt id="sv_2bool">
<code>sv_2bool</code> </dt> <dd> <p>This macro is only used by <code>sv_true()</code> or its macro equivalent, and only if the latter's argument is neither <code>SvPOK</code>, <code>SvIOK</code> nor <code>SvNOK</code>. It calls <code>sv_2bool_flags</code> with the <code>SV_GMAGIC</code> flag.</p> 
<pre data-language="perl"><code class="plaintext">bool  sv_2bool(SV * const sv)</code></pre> </dd> </dl> <dl> <dt id="sv_2bool_flags">
<code>sv_2bool_flags</code> </dt> <dd> <p>This function is only used by <code>sv_true()</code> and friends, and only if the latter's argument is neither <code>SvPOK</code>, <code>SvIOK</code> nor <code>SvNOK</code>. If the flags contain <code>SV_GMAGIC</code>, then it does an <code>mg_get()</code> first.</p> 
<pre data-language="perl"><code class="plaintext">bool  sv_2bool_flags(SV *sv, I32 flags)</code></pre> </dd> </dl> <dl> <dt id="sv_clean_all">
<code>sv_clean_all</code> </dt> <dd> <p>Decrement the refcnt of each remaining SV, possibly triggering a cleanup. This function may have to be called multiple times to free SVs which are in complex self-referential hierarchies.</p> 
<pre data-language="perl"><code class="plaintext">I32  sv_clean_all()</code></pre> </dd> </dl> <dl> <dt id="sv_clean_objs">
<code>sv_clean_objs</code> </dt> <dd> <p>Attempt to destroy all objects not yet freed.</p> 
<pre data-language="perl"><code class="plaintext">void  sv_clean_objs()</code></pre> </dd> </dl> <dl> <dt id="sv_free_arenas">
<code>sv_free_arenas</code> </dt> <dd> <p>Deallocate the memory used by all arenas. Note that all the individual SV heads and bodies within the arenas must already have been freed.</p> 
<pre data-language="perl"><code class="plaintext">void  sv_free_arenas()</code></pre> </dd> </dl> <dl> <dt id="sv_grow">
<code>sv_grow</code> </dt> <dd> <p>Expands the character buffer in the SV. If necessary, uses <code>sv_unref</code> and upgrades the SV to <code>SVt_PV</code>. Returns a pointer to the character buffer. Use the <code>SvGROW</code> wrapper instead.</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_grow(SV * const sv, STRLEN newlen)</code></pre> </dd> </dl> <dl> <dt id="sv_grow_fresh">
<code>sv_grow_fresh</code> </dt> <dd> <p>A cut-down version of sv_grow intended only for when sv is a freshly-minted SVt_PV, SVt_PVIV, SVt_PVNV, or SVt_PVMG. i.e. sv has the default flags, has never been any other type, and does not have an existing string. Basically, just assigns a char buffer and returns a pointer to it.</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_grow_fresh(SV * const sv, STRLEN newlen)</code></pre> </dd> </dl> <dl> <dt id="sv_newref">
<code>sv_newref</code> </dt> <dd> <p>Increment an SV's reference count. Use the <code>SvREFCNT_inc()</code> wrapper instead.</p> 
<pre data-language="perl"><code class="plaintext">SV *  sv_newref(SV * const sv)</code></pre> </dd> </dl> <dl> <dt id="sv_2num">
<code>sv_2num</code> </dt> <dd> <p>NOTE: <code>sv_2num</code> is <b>experimental</b> and may change or be removed without notice.</p> <p>Return an SV with the numeric value of the source SV, doing any necessary reference or overload conversion. The caller is expected to have handled get-magic already.</p> 
<pre data-language="perl"><code class="plaintext">SV *  sv_2num(SV * const sv)</code></pre> </dd> </dl> <dl> <dt id="sv_pv">
<code>sv_pv</code> </dt> <dd> <p>Use the <code>SvPV_nolen</code> macro instead</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_pv(SV *sv)</code></pre> </dd> </dl> <dl> <dt id="sv_pvbyte">
<code>sv_pvbyte</code> </dt> <dd> <p>Use <code>SvPVbyte_nolen</code> instead.</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_pvbyte(SV *sv)</code></pre> </dd> </dl> <dl> <dt id="sv_pvbyten_force">
<code>sv_pvbyten_force</code> </dt> <dd> <p>The backend for the <code>SvPVbytex_force</code> macro. Always use the macro instead. If the SV cannot be downgraded from UTF-8, this croaks.</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_pvbyten_force(SV * const sv, STRLEN * const lp)</code></pre> </dd> </dl> <dl> <dt id="sv_2pvbyte_nolen">
<code>sv_2pvbyte_nolen</code> </dt> <dd> <p>Return a pointer to the byte-encoded representation of the SV. May cause the SV to be downgraded from UTF-8 as a side-effect.</p> <p>Usually accessed via the <code>SvPVbyte_nolen</code> macro.</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_2pvbyte_nolen(SV *sv)</code></pre> </dd> </dl> <dl> <dt id="sv_pvn_force">
<code>sv_pvn_force</code> </dt> <dd> <p>Get a sensible string out of the SV somehow. A private implementation of the <code>SvPV_force</code> macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_pvn_force(SV *sv, STRLEN *lp)</code></pre> </dd> </dl> <dl> <dt id="sv_2pv_nolen">
<code>sv_2pv_nolen</code> </dt> <dd> <p>Like <code>sv_2pv()</code>, but doesn't return the length too. You should usually use the macro wrapper <code>SvPV_nolen(sv)</code> instead.</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_2pv_nolen(SV *sv)</code></pre> </dd> </dl> <dl> <dt id="sv_pvutf8n_force">
<code>sv_pvutf8n_force</code> </dt> <dd> <p>The backend for the <code>SvPVutf8x_force</code> macro. Always use the macro instead.</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_pvutf8n_force(SV * const sv, STRLEN * const lp)</code></pre> </dd> </dl> <dl> <dt id="sv_2pvutf8_nolen">
<code>sv_2pvutf8_nolen</code> </dt> <dd> <p>Return a pointer to the UTF-8-encoded representation of the SV. May cause the SV to be upgraded to UTF-8 as a side-effect.</p> <p>Usually accessed via the <code>SvPVutf8_nolen</code> macro.</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_2pvutf8_nolen(SV *sv)</code></pre> </dd> </dl> <dl> <dt id="sv_pvutf8">
<code>sv_pvutf8</code> </dt> <dd> <p>Use the <code>SvPVutf8_nolen</code> macro instead</p> 
<pre data-language="perl"><code class="plaintext">char *  sv_pvutf8(SV *sv)</code></pre> </dd> </dl> <dl> <dt id="sv_tainted">
<code>sv_tainted</code> </dt> <dd> <p>Test an SV for taintedness. Use <code>SvTAINTED</code> instead.</p> 
<pre data-language="perl"><code class="plaintext">bool  sv_tainted(SV * const sv)</code></pre> </dd> </dl> <dl> <dt id="SvTHINKFIRST">
<code>SvTHINKFIRST</code> </dt> <dd> <p>A quick flag check to see whether an <code>sv</code> should be passed to <code>sv_force_normal</code> to be "downgraded" before <code>SvIVX</code> or <code>SvPVX</code> can be modified directly.</p> <p>For example, if your scalar is a reference and you want to modify the <code>SvIVX</code> slot, you can't just do <code>SvROK_off</code>, as that will leak the referent.</p> <p>This is used internally by various sv-modifying functions, such as <code>sv_setsv</code>, <code>sv_setiv</code> and <code>sv_pvn_force</code>.</p> <p>One case that this does not handle is a gv without SvFAKE set. After</p> <pre data-language="perl"><code>if (SvTHINKFIRST(gv)) sv_force_normal(gv);</code></pre> <p>it will still be a gv.</p> <p><code>SvTHINKFIRST</code> sometimes produces false positives. In those cases <code>sv_force_normal</code> does nothing.</p> 
<pre data-language="perl"><code class="plaintext">U32  SvTHINKFIRST(SV *sv)</code></pre> </dd> </dl> <dl> <dt id="sv_true">
<code>sv_true</code> </dt> <dd> <p>Returns true if the SV has a true value by Perl's rules. Use the <code>SvTRUE</code> macro instead, which may call <code>sv_true()</code> or may instead use an in-line version.</p> 
<pre data-language="perl"><code class="plaintext">I32  sv_true(SV * const sv)</code></pre> </dd> </dl> <dl> <dt id="sv_untaint">
<code>sv_untaint</code> </dt> <dd> <p>Untaint an SV. Use <code>SvTAINTED_off</code> instead.</p> 
<pre data-language="perl"><code class="plaintext">void  sv_untaint(SV * const sv)</code></pre> </dd> </dl> <h2 id="Tainting">Tainting</h2> <dl> <dt id="sv_taint">
<code>sv_taint</code> </dt> <dd> <p>Taint an SV. Use <code>SvTAINTED_on</code> instead.</p> 
<pre data-language="perl"><code class="plaintext">void  sv_taint(SV *sv)</code></pre> </dd> </dl> <dl> <dt id="TAINT">
<code>TAINT</code> </dt> <dd> <p>If we aren't in taint checking mode, do nothing; otherwise indicate to <a href="#TAINT_set">"<code>TAINT_set</code>"</a> and <a href="#TAINT_PROPER">"<code>TAINT_PROPER</code>"</a> that some unspecified element is tainted.</p> 
<pre data-language="perl"><code class="plaintext">void  TAINT()</code></pre> </dd> </dl> <dl> <dt id="TAINT_ENV">
<code>TAINT_ENV</code> </dt> <dd> <p>Looks at several components of <a href="perlvar.html#%25ENV"><code>%ENV</code></a> for taintedness, and calls <a href="#taint_proper">"<code>taint_proper</code>"</a> if any are tainted. The components it searches are things like <code>$PATH</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  TAINT_ENV</code></pre> </dd> </dl> <dl> <dt id="taint_env">
<code>taint_env</code> </dt> <dd> <p>Implements the <a href="#TAINT_ENV">"TAINT_ENV"</a> macro, which you should generally use instead.</p> 
<pre data-language="perl"><code class="plaintext">void  taint_env()</code></pre> </dd> </dl> <dl> <dt id="TAINT_get">
<code>TAINT_get</code> </dt> <dd> <p>Returns a boolean as to whether some element is tainted or not.</p> 
<pre data-language="perl"><code class="plaintext">bool  TAINT_get()</code></pre> </dd> </dl> <dl> <dt id="TAINT_IF">
<code>TAINT_IF</code> </dt> <dd> <p>If <code>c</code> evaluates to true, call <a href="#TAINT">"<code>TAINT</code>"</a> to indicate that something is tainted; otherwise do nothing.</p> 
<pre data-language="perl"><code class="plaintext">void  TAINT_IF(bool c)</code></pre> </dd> </dl> <dl> <dt id="TAINTING_get">
<code>TAINTING_get</code> </dt> <dd> <p>Returns a boolean as to whether taint checking is enabled or not.</p> 
<pre data-language="perl"><code class="plaintext">bool  TAINTING_get()</code></pre> </dd> </dl> <dl> <dt id="TAINTING_set">
<code>TAINTING_set</code> </dt> <dd> <p>Turn taint checking mode off/on</p> 
<pre data-language="perl"><code class="plaintext">void  TAINTING_set(bool s)</code></pre> </dd> </dl> <dl> <dt id="TAINT_NOT">
<code>TAINT_NOT</code> </dt> <dd> <p>Remove any taintedness previously set by, <i>e.g.</i>, <code>TAINT</code>.</p> 
<pre data-language="perl"><code class="plaintext">void  TAINT_NOT()</code></pre> </dd> </dl> <dl> <dt id="TAINT_PROPER">
<code>TAINT_PROPER</code> </dt> <dd> <p>If no element is tainted, do nothing; otherwise output a message (containing <code>s</code>) that indicates there is a tainting violation. If such violations are fatal, it croaks.</p> 
<pre data-language="perl"><code class="plaintext">void  TAINT_PROPER(const char * s)</code></pre> </dd> </dl> <dl> <dt id="taint_proper">
<code>taint_proper</code> </dt> <dd> <p>Implements the <a href="#TAINT_PROPER">"TAINT_PROPER"</a> macro, which you should generally use instead.</p> 
<pre data-language="perl"><code class="plaintext">void  taint_proper(const char *f, const char * const s)</code></pre> </dd> </dl> <dl> <dt id="TAINT_set">
<code>TAINT_set</code> </dt> <dd> <p>If <code>s</code> is true, <a href="#TAINT_get">"<code>TAINT_get</code>"</a> returns true; If <code>s</code> is false, <a href="#TAINT_get">"<code>TAINT_get</code>"</a> returns false;</p> 
<pre data-language="perl"><code class="plaintext">void  TAINT_set(bool s)</code></pre> </dd> </dl> <dl> <dt id="TAINT_WARN_get">
<code>TAINT_WARN_get</code> </dt> <dd> <p>Returns false if tainting violations are fatal; Returns true if they're just warnings</p> 
<pre data-language="perl"><code class="plaintext">bool  TAINT_WARN_get()</code></pre> </dd> </dl> <dl> <dt id="TAINT_WARN_set">
<code>TAINT_WARN_set</code> </dt> <dd> <p><code>s</code> being true indicates <a href="#TAINT_WARN_get">"<code>TAINT_WARN_get</code>"</a> should return that tainting violations are just warnings</p> <p><code>s</code> being false indicates <a href="#TAINT_WARN_get">"<code>TAINT_WARN_get</code>"</a> should return that tainting violations are fatal.</p> 
<pre data-language="perl"><code class="plaintext">void  TAINT_WARN_set(bool s)</code></pre> </dd> </dl> <h2 id="Time">Time</h2> <p>There are currently no internal API items in Time</p> <h2 id="Typedef-names">
Typedef names</h2> <p>There are currently no internal API items in Typedef names</p> <h2 id="Unicode-Support">
Unicode Support </h2> <dl> <dt id="bytes_from_utf8_loc">
<code>bytes_from_utf8_loc</code> </dt> <dd> <p>NOTE: <code>bytes_from_utf8_loc</code> is <b>experimental</b> and may change or be removed without notice.</p> <p>Like <code><a href="perlapi.html#bytes_from_utf8">"bytes_from_utf8" in perlapi</a>()</code>, but takes an extra parameter, a pointer to where to store the location of the first character in <code>"s"</code> that cannot be converted to non-UTF8.</p> <p>If that parameter is <code>NULL</code>, this function behaves identically to <code>bytes_from_utf8</code>.</p> <p>Otherwise if <code>*is_utf8p</code> is 0 on input, the function behaves identically to <code>bytes_from_utf8</code>, except it also sets <code>*first_non_downgradable</code> to <code>NULL</code>.</p> <p>Otherwise, the function returns a newly created <code>NUL</code>-terminated string containing the non-UTF8 equivalent of the convertible first portion of <code>"s"</code>. <code>*lenp</code> is set to its length, not including the terminating <code>NUL</code>. If the entire input string was converted, <code>*is_utf8p</code> is set to a FALSE value, and <code>*first_non_downgradable</code> is set to <code>NULL</code>.</p> <p>Otherwise, <code>*first_non_downgradable</code> is set to point to the first byte of the first character in the original string that wasn't converted. <code>*is_utf8p</code> is unchanged. Note that the new string may have length 0.</p> <p>Another way to look at it is, if <code>*first_non_downgradable</code> is non-<code>NULL</code> and <code>*is_utf8p</code> is TRUE, this function starts at the beginning of <code>"s"</code> and converts as many characters in it as possible stopping at the first one it finds that can't be converted to non-UTF-8. <code>*first_non_downgradable</code> is set to point to that. The function returns the portion that could be converted in a newly created <code>NUL</code>-terminated string, and <code>*lenp</code> is set to its length, not including the terminating <code>NUL</code>. If the very first character in the original could not be converted, <code>*lenp</code> will be 0, and the new string will contain just a single <code>NUL</code>. If the entire input string was converted, <code>*is_utf8p</code> is set to FALSE and <code>*first_non_downgradable</code> is set to <code>NULL</code>.</p> <p>Upon successful return, the number of variants in the converted portion of the string can be computed by having saved the value of <code>*lenp</code> before the call, and subtracting the after-call value of <code>*lenp</code> from it.</p> 
<pre data-language="perl"><code class="plaintext">U8 *  bytes_from_utf8_loc(const U8 *s, STRLEN *lenp,
                          bool *is_utf8p,
                          const U8 **first_unconverted)</code></pre> </dd> </dl> <dl> <dt id="find_uninit_var">
<code>find_uninit_var</code> </dt> <dd> <p>NOTE: <code>find_uninit_var</code> is <b>experimental</b> and may change or be removed without notice.</p> <p>Find the name of the undefined variable (if any) that caused the operator to issue a "Use of uninitialized value" warning. If match is true, only return a name if its value matches <code>uninit_sv</code>. So roughly speaking, if a unary operator (such as <code>OP_COS</code>) generates a warning, then following the direct child of the op may yield an <code>OP_PADSV</code> or <code>OP_GV</code> that gives the name of the undefined variable. On the other hand, with <code>OP_ADD</code> there are two branches to follow, so we only print the variable name if we get an exact match. <code>desc_p</code> points to a string pointer holding the description of the op. This may be updated if needed.</p> <p>The name is returned as a mortal SV.</p> <p>Assumes that <code>PL_op</code> is the OP that originally triggered the error, and that <code>PL_comppad</code>/<code>PL_curpad</code> points to the currently executing pad.</p> 
<pre data-language="perl"><code class="plaintext">SV *  find_uninit_var(const OP * const obase,
                      const SV * const uninit_sv, bool match,
                      const char **desc_p)</code></pre> </dd> </dl> <dl> <dt id="isSCRIPT_RUN">
<code>isSCRIPT_RUN</code> </dt> <dd> <p>Returns a bool as to whether or not the sequence of bytes from <code>s</code> up to but not including <code>send</code> form a "script run". <code>utf8_target</code> is TRUE iff the sequence starting at <code>s</code> is to be treated as UTF-8. To be precise, except for two degenerate cases given below, this function returns TRUE iff all code points in it come from any combination of three "scripts" given by the Unicode "Script Extensions" property: Common, Inherited, and possibly one other. Additionally all decimal digits must come from the same consecutive sequence of 10.</p> <p>For example, if all the characters in the sequence are Greek, or Common, or Inherited, this function will return TRUE, provided any decimal digits in it are from the same block of digits in Common. (These are the ASCII digits "0".."9" and additionally a block for full width forms of these, and several others used in mathematical notation.) For scripts (unlike Greek) that have their own digits defined this will accept either digits from that set or from one of the Common digit sets, but not a combination of the two. Some scripts, such as Arabic, have more than one set of digits. All digits must come from the same set for this function to return TRUE.</p> <p><code>*ret_script</code>, if <code>ret_script</code> is not NULL, will on return of TRUE contain the script found, using the <code>SCX_enum</code> typedef. Its value will be <code>SCX_INVALID</code> if the function returns FALSE.</p> <p>If the sequence is empty, TRUE is returned, but <code>*ret_script</code> (if asked for) will be <code>SCX_INVALID</code>.</p> <p>If the sequence contains a single code point which is unassigned to a character in the version of Unicode being used, the function will return TRUE, and the script will be <code>SCX_Unknown</code>. Any other combination of unassigned code points in the input sequence will result in the function treating the input as not being a script run.</p> <p>The returned script will be <code>SCX_Inherited</code> iff all the code points in it are from the Inherited script.</p> <p>Otherwise, the returned script will be <code>SCX_Common</code> iff all the code points in it are from the Inherited or Common scripts.</p> 
<pre data-language="perl"><code class="plaintext">bool  isSCRIPT_RUN(const U8 *s, const U8 *send,
                   const bool utf8_target)</code></pre> </dd> </dl> <dl> <dt id="is_utf8_non_invariant_string">
<code>is_utf8_non_invariant_string</code> </dt> <dd> <p>Returns TRUE if <a href="perlapi.html#is_utf8_invariant_string">"is_utf8_invariant_string" in perlapi</a> returns FALSE for the first <code>len</code> bytes of the string <code>s</code>, but they are, nonetheless, legal Perl-extended UTF-8; otherwise returns FALSE.</p> <p>A TRUE return means that at least one code point represented by the sequence either is a wide character not representable as a single byte, or the representation differs depending on whether the sequence is encoded in UTF-8 or not.</p> <p>See also <code><a href="perlapi.html#is_utf8_invariant_string">"is_utf8_invariant_string" in perlapi</a></code>, <code><a href="perlapi.html#is_utf8_string">"is_utf8_string" in perlapi</a></code></p> 
<pre data-language="perl"><code class="plaintext">bool  is_utf8_non_invariant_string(const U8 * const s, STRLEN len)</code></pre> </dd> </dl> <dl> <dt id="utf8n_to_uvuni">
<code>utf8n_to_uvuni</code> </dt> <dd> <p><code><b>DEPRECATED!</b></code> It is planned to remove <code>utf8n_to_uvuni</code> from a future release of Perl. Do not use it for new code; remove it from existing code.</p> <p>Instead use <a href="perlapi.html#utf8_to_uvchr_buf">"utf8_to_uvchr_buf" in perlapi</a>, or rarely, <a href="perlapi.html#utf8n_to_uvchr">"utf8n_to_uvchr" in perlapi</a>.</p> <p>This function was useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want. If you do need this precise functionality, use instead <code><a href="perlapi.html#utf8_to_uvchr_buf">NATIVE_TO_UNI(utf8_to_uvchr_buf(...))</a></code> or <code><a href="perlapi.html#utf8n_to_uvchr">NATIVE_TO_UNI(utf8n_to_uvchr(...))</a></code>.</p> 
<pre data-language="perl"><code class="plaintext">UV  utf8n_to_uvuni(const U8 *s, STRLEN curlen, STRLEN *retlen,
                   U32 flags)</code></pre> </dd> </dl> <dl> <dt id="utf8_to_uvuni">
<code>utf8_to_uvuni</code> </dt> <dd> <p><code><b>DEPRECATED!</b></code> It is planned to remove <code>utf8_to_uvuni</code> from a future release of Perl. Do not use it for new code; remove it from existing code.</p> <p>Returns the Unicode code point of the first character in the string <code>s</code> which is assumed to be in UTF-8 encoding; <code>retlen</code> will be set to the length, in bytes, of that character.</p> <p>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you.</p> <p>If <code>s</code> points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and <code>*retlen</code> is set (if <code>retlen</code> doesn't point to NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and <code>*retlen</code> is set (if <code>retlen</code> isn't NULL) so that (<span style="white-space: nowrap;"><code>s</code> + <code>*retlen</code></span>) is the next possible position in <code>s</code> that could begin a non-malformed character. See <a href="perlapi.html#utf8n_to_uvchr">"utf8n_to_uvchr" in perlapi</a> for details on when the REPLACEMENT CHARACTER is returned.</p> 
<pre data-language="perl"><code class="plaintext">UV  utf8_to_uvuni(const U8 *s, STRLEN *retlen)</code></pre> </dd> </dl> <dl> <dt id="uvoffuni_to_utf8_flags">
<code>uvoffuni_to_utf8_flags</code> </dt> <dd> <p>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, <b>Almost all code should use <a href="perlapi.html#uvchr_to_utf8">"uvchr_to_utf8" in perlapi</a> or <a href="perlapi.html#uvchr_to_utf8_flags">"uvchr_to_utf8_flags" in perlapi</a></b>.</p> <p>This function is like them, but the input is a strict Unicode (as opposed to native) code point. Only in very rare circumstances should code not be using the native code point.</p> <p>For details, see the description for <a href="perlapi.html#uvchr_to_utf8_flags">"uvchr_to_utf8_flags" in perlapi</a>.</p> 
<pre data-language="perl"><code class="plaintext">U8 *  uvoffuni_to_utf8_flags(U8 *d, UV uv, UV flags)</code></pre> </dd> </dl> <dl> <dt id="valid_utf8_to_uvchr">
<code>valid_utf8_to_uvchr</code> </dt> <dd> <p>Like <code><a href="perlapi.html#utf8_to_uvchr_buf">"utf8_to_uvchr_buf" in perlapi</a></code>, but should only be called when it is known that the next character in the input UTF-8 string <code>s</code> is well-formed (<i>e.g.</i>, it passes <code><a href="perlapi.html#isUTF8_CHAR">"isUTF8_CHAR" in perlapi</a></code>. Surrogates, non-character code points, and non-Unicode code points are allowed.</p> 
<pre data-language="perl"><code class="plaintext">UV  valid_utf8_to_uvchr(const U8 *s, STRLEN *retlen)</code></pre> </dd> </dl> <dl> <dt id="variant_under_utf8_count">
<code>variant_under_utf8_count</code> </dt> <dd> <p>This function looks at the sequence of bytes between <code>s</code> and <code>e</code>, which are assumed to be encoded in ASCII/Latin1, and returns how many of them would change should the string be translated into UTF-8. Due to the nature of UTF-8, each of these would occupy two bytes instead of the single one in the input string. Thus, this function returns the precise number of bytes the string would expand by when translated to UTF-8.</p> <p>Unlike most of the other functions that have <code>utf8</code> in their name, the input to this function is NOT a UTF-8-encoded string. The function name is slightly <i>odd</i> to emphasize this.</p> <p>This function is internal to Perl because khw thinks that any XS code that would want this is probably operating too close to the internals. Presenting a valid use case could change that.</p> <p>See also <code><a href="perlapi.html#is_utf8_invariant_string">"is_utf8_invariant_string" in perlapi</a></code> and <code><a href="perlapi.html#is_utf8_invariant_string_loc">"is_utf8_invariant_string_loc" in perlapi</a></code>,</p> 
<pre data-language="perl"><code class="plaintext">Size_t  variant_under_utf8_count(const U8 * const s,
                                 const U8 * const e)</code></pre> </dd> </dl> <h2 id="Utility-Functions">
Utility Functions</h2> <dl> <dt id="my_popen_list">
<code>my_popen_list</code> </dt> <dd> <p>Implementing function on some systems for PerlProc_popen_list()</p> 
<pre data-language="perl"><code class="plaintext">PerlIO *  my_popen_list(const char *mode, int n, SV **args)</code></pre> </dd> </dl> <dl> <dt id="my_socketpair">
<code>my_socketpair</code> </dt> <dd> <p>Emulates <a href="http://man.he.net/man2/socketpair">socketpair(2)</a> on systems that don't have it, but which do have enough functionality for the emulation.</p> 
<pre data-language="perl"><code class="plaintext">int  my_socketpair(int family, int type, int protocol, int fd[2])</code></pre> </dd> </dl> <h2 id="Versioning">Versioning</h2> <p>There are currently no internal API items in Versioning</p> <h2 id="Warning-and-Dieing">
Warning and Dieing</h2> <dl> <dt id="deprecate">
<code>deprecate</code> </dt> <dd> <p>Wrapper around Perl_ck_warner_d() to produce a deprecated warning in the given category with an appropriate message. The <code>message</code> argument must be a C string. The string " is deprecated" will automatically be added to the end of the <code>message</code>.</p> 
<pre data-language="perl"><code class="plaintext">deprecate(U32 category, "message")</code></pre> </dd> </dl> <dl> <dt id="deprecate_disappears_in">
<code>deprecate_disappears_in</code> </dt> <dd> <p>Wrapper around Perl_ck_warner_d() to produce a deprecated warning in the given category with an appropriate message that the construct referred to by the message will disappear in a specific release. The <code>when</code> and <code>message</code> arguments must be a C string. The <code>when</code> string is expected to be of the form "5.40", with no minor element in the version. The actual message output will be the result of the following expression <code>message " is deprecated, and will disappear in Perl " when</code> which is why <code>message</code> and <code>when</code> must be literal C strings.</p> 
<pre data-language="perl"><code class="plaintext">deprecate_disappears_in(U32 category, "when", "message")</code></pre> </dd> </dl> <dl> <dt id="deprecate_fatal_in">
<code>deprecate_fatal_in</code> </dt> <dd> <p>Wrapper around Perl_ck_warner_d() to produce a deprecated warning in the given category with an appropriate message that the construct referred to by the message will become fatal in a specific release. The <code>when</code> and <code>message</code> arguments must be a C string. The <code>when</code> string is expected to be of the form "5.40", with no minor element in the version. The actual message output will be the result of the following expression <code>message " is deprecated, and will become fatal in Perl " when</code> which is why <code>message</code> and <code>when</code> must be literal C strings.</p> 
<pre data-language="perl"><code class="plaintext">deprecate_fatal_in(U32 category, "when", "message")</code></pre> </dd> </dl> <dl> <dt id="PL_dowarn">
<code>PL_dowarn</code> </dt> <dd> <p>The C variable that roughly corresponds to Perl's <code>$^W</code> warning variable. However, <code>$^W</code> is treated as a boolean, whereas <code>PL_dowarn</code> is a collection of flag bits.</p> <p>On threaded perls, each thread has an independent copy of this variable; each initialized at creation time with the current value of the creating thread's copy.</p> 
<pre data-language="perl"><code class="plaintext">U8  PL_dowarn</code></pre> </dd> </dl> <dl> <dt id="report_uninit">
<code>report_uninit</code> </dt> <dd> <p>Print appropriate "Use of uninitialized variable" warning.</p> 
<pre data-language="perl"><code class="plaintext">void  report_uninit(const SV *uninit_sv)</code></pre> </dd> </dl> <h2 id="XS">XS</h2> <p>There are currently no internal API items in XS</p> <h2 id="Undocumented-elements">
Undocumented elements</h2> <p>This section lists the elements that are otherwise undocumented. If you use any of them, please consider creating and submitting documentation for it.</p> <p>Experimental and deprecated undocumented elements are listed separately at the end.</p>  <pre data-language="perl"><code class="nohighlight">abort_execution
add_above_Latin1_folds
add_cp_to_invlist
_add_range_to_invlist
allocmy
amagic_cmp
amagic_cmp_desc
amagic_cmp_locale
amagic_cmp_locale_desc
amagic_i_ncmp
amagic_i_ncmp_desc
amagic_is_enabled
amagic_ncmp
amagic_ncmp_desc
any_dup
append_utf8_from_native_byte
apply
atfork_lock
atfork_unlock
av_arylen_p
av_extend_guts
av_iter_p
av_nonelem
av_reify
bind_match
block_gimme
boot_core_builtin
boot_core_mro
boot_core_PerlIO
boot_core_UNIVERSAL
build_infix_plugin
_byte_dump_string
call_list
cando
capture_clear
cast_iv
cast_i32
cast_ulong
cast_uv
check_hash_fields_and_hekify
check_regnode_after
check_utf8_print
ck_anoncode
ck_backtick
ck_bitop
ck_cmp
ck_concat
ck_defined
ck_delete
ck_each
ck_entersub_args_core
ck_eof
ck_eval
ck_exec
ck_exists
ck_ftst
ck_fun
ck_glob
ck_grep
ck_helemexistsor
ck_index
ck_isa
ck_join
ck_length
ck_lfun
ck_listiob
ck_match
ck_method
ck_null
ck_open
ck_prototype
ck_readline
ck_refassign
ck_repeat
ck_require
ck_return
ck_rfun
ck_rvconst
ck_sassign
ck_select
ck_shift
ck_smartmatch
ck_sort
ck_spair
ck_split
ck_stringify
ck_subr
ck_substr
ck_svconst
ck_tell
ck_trunc
ck_trycatch
ckwarn
ckwarn_d
class_add_ADJUST
class_add_field
class_apply_attributes
class_apply_field_attributes
class_prepare_initfield_parse
class_prepare_method_parse
class_seal_stash
class_set_field_defop
class_setup_stash
class_wrap_method_body
clear_defarray
closest_cop
cmpchain_extend
cmpchain_finish
cmpchain_start
cmp_desc
cmp_locale_desc
cntrl_to_mnemonic
construct_ahocorasick_from_trie
cop_file_avn
coresub_op
croak_caller
croak_kw_unless_class
croak_memory_wrap
croak_no_mem
croak_popstack
csighandler
csighandler1
csighandler3
current_re_engine
custom_op_get_field
cv_clone_into
cv_const_sv_or_av
cvgv_from_hek
cvgv_set
cvstash_set
cv_undef_flags
cx_dump
cx_dup
cxinc
deb_stack_all
debstackptrs
debug_hash_seed
debug_peep
debug_show_study_flags
debug_studydata
defelem_target
despatch_signals
die_unwind
do_aexec
do_aexec5
do_aspawn
do_eof
does_utf8_overflow
do_exec
do_exec3
dofile
do_gv_dump
do_gvgv_dump
do_hv_dump
doing_taint
do_ipcctl
do_ipcget
do_magic_dump
do_msgrcv
do_msgsnd
do_ncmp
do_op_dump
do_pmop_dump
do_print
do_readline
doref
do_seek
do_semop
do_shmio
do_spawn
do_spawn_nowait
do_sv_dump
do_sysseek
do_tell
do_trans
do_uniprop_match
do_vecget
do_vecset
do_vop
drand48_init_r
drand48_r
dtrace_probe_call
dtrace_probe_load
dtrace_probe_op
dtrace_probe_phase
dump_all_perl
dump_indent
dump_packsubs_perl
dump_sub_perl
dump_sv_child
dumpuntil
dump_vindent
dup_warnings
find_first_differing_byte_pos
find_lexical_cv
find_runcv_where
find_script
foldEQ_latin1_s2_folded
foldEQ_latin1
foldEQ_utf8_flags
force_locale_unlock
_force_out_malformed_utf8_message
form_alien_digit_msg
form_cp_too_large_msg
free_tied_hv_pool
free_tmps
get_and_check_backslash_N_name
get_ANYOFHbbm_contents
get_ANYOFM_contents
get_db_sub
get_debug_opts
get_deprecated_property_msg
getenv_len
get_extended_os_errno
get_hash_seed
get_invlist_iter_addr
get_invlist_offset_addr
get_invlist_previous_index_addr
get_mstats
get_prop_definition
get_prop_values
get_regclass_aux_data
get_re_gclass_aux_data
get_regex_charset_name
get_win32_message_utf8ness
gp_free
gp_ref
grok_bin_oct_hex
grok_bslash_c
grok_bslash_o
grok_bslash_x
gv_check
gv_fetchmeth_internal
gv_override
gv_setref
gv_stashpvn_internal
he_dup
hek_dup
hfree_next_entry
hv_auxalloc
hv_common
hv_common_key_len
hv_delayfree_ent
hv_free_ent
hv_placeholders_p
hv_pushkv
hv_rand_set
hv_undef_flags
infix_plugin_standard
init_argv_symbols
init_constants
init_dbargs
init_debugger
init_i18nl10n
init_named_cv
init_stacks
init_tm
init_uniprops
_inverse_folds
invert
invlist_array
_invlist_array_init
invlist_clear
invlist_clone
_invlist_contains_cp
invlist_contents
_invlist_dump
_invlistEQ
invlist_extend
invlist_highest
_invlist_intersection
_invlist_intersection_maybe_complement_2nd
_invlist_invert
invlist_is_iterating
invlist_iterfinish
invlist_iterinit
invlist_iternext
_invlist_len
invlist_max
invlist_previous_index
_invlist_search
invlist_set_len
invlist_set_previous_index
_invlist_subtract
invlist_trim
_invlist_union
_invlist_union_maybe_complement_2nd
invmap_dump
invoke_exception_hook
io_close
isFF_overlong
is_grapheme
_is_in_locale_category
is_invlist
is_ssc_worth_it
_is_uni_FOO
_is_uni_perl_idcont
_is_uni_perl_idstart
is_utf8_char_helper_
is_utf8_common
is_utf8_FF_helper_
_is_utf8_FOO
is_utf8_overlong
_is_utf8_perl_idcont
_is_utf8_perl_idstart
jmaybe
join_exact
keyword
keyword_plugin_standard
list
load_charnames
locale_panic
localize
lossless_NV_to_IV
lsbit_pos32
lsbit_pos64
magic_clear_all_env
magic_cleararylen_p
magic_clearenv
magic_clearhook
magic_clearhookall
magic_clearisa
magic_clearpack
magic_clearsig
magic_copycallchecker
magic_existspack
magic_freearylen_p
magic_freecollxfrm
magic_freemglob
magic_freeovrld
magic_freeutf8
magic_get
magic_getarylen
magic_getdebugvar
magic_getdefelem
magic_getnkeys
magic_getpack
magic_getpos
magic_getsig
magic_getsubstr
magic_gettaint
magic_getuvar
magic_getvec
magic_killbackrefs
magic_nextpack
magic_regdata_cnt
magic_regdatum_get
magic_regdatum_set
magic_scalarpack
magic_set
magic_set_all_env
magic_setarylen
magic_setcollxfrm
magic_setdbline
magic_setdebugvar
magic_setdefelem
magic_setenv
magic_sethook
magic_sethookall
magic_setisa
magic_setlvref
magic_setmglob
magic_setnkeys
magic_setnonelem
magic_setpack
magic_setpos
magic_setregexp
magic_setsig
magic_setsigall
magic_setsubstr
magic_settaint
magic_setutf8
magic_setuvar
magic_setvec
magic_sizepack
magic_wipepack
make_trie
malloced_size
malloc_good_size
markstack_grow
mbtowc_
mem_collxfrm_
mem_log_alloc
mem_log_del_sv
mem_log_free
mem_log_new_sv
mem_log_realloc
mg_find_mglob
mg_size
mode_from_discipline
more_bodies
more_sv
moreswitches
mortal_getenv
mortalized_pv_copy
mro_get_private_data
mro_meta_dup
mro_meta_init
msbit_pos32
msbit_pos64
multiconcat_stringify
multideref_stringify
my_atof2
my_atof3
my_attrs
my_clearenv
my_lstat
my_lstat_flags
my_memrchr
my_mkostemp_cloexec
my_mkstemp_cloexec
my_stat
my_stat_flags
my_strerror
my_strftime8_temp
my_unexec
newFORM
_new_invlist
_new_invlist_C_array
newMETHOP_internal
newMYSUB
newPROG
new_stackinfo
newSTUB
newSVavdefelem
newXS_deffile
nextargv
no_bareword_allowed
no_bareword_filehandle
noperl_die
notify_parser_that_changed_to_utf8
oopsAV
oopsHV
op_clear
op_integerize
op_lvalue_flags
opmethod_stash
op_prune_chain_head
op_relocate_sv
opslab_force_free
opslab_free
opslab_free_nopad
op_std_init
op_varname
package
package_version
pad_add_weakref
padlist_store
padname_free
PadnameIN_SCOPE
padnamelist_free
parser_dup
parser_free
parser_free_nexttoke_ops
parse_unicode_opts
path_is_searchable
peep
perl_alloc_using
perl_clone_using
PerlEnv_putenv
PerlIO_context_layers
PerlIO_restore_errno
PerlIO_save_errno
PerlLIO_dup_cloexec
PerlLIO_dup2_cloexec
PerlLIO_open_cloexec
PerlLIO_open3_cloexec
PerlProc_pipe_cloexec
PerlSock_accept_cloexec
PerlSock_socket_cloexec
PerlSock_socketpair_cloexec
perly_sighandler
pmruntime
POPMARK
populate_anyof_bitmap_from_invlist
populate_bitmap_from_invlist
populate_invlist_from_bitmap
populate_isa
pregfree
pregfree2
ptr_hash
qerror
ReANY
reentrant_free
reentrant_init
reentrant_retry
reentrant_size
re_exec_indentf
ref
reg_add_data
regcurly
regdump
regdupe_internal
regexec_flags
regfree_internal
reginitcolors
reg_named_buff
reg_named_buff_all
reg_named_buff_exists
reg_named_buff_fetch
reg_named_buff_firstkey
reg_named_buff_iter
reg_named_buff_nextkey
reg_named_buff_scalar
regnext
regnode_after
reg_numbered_buff_fetch
reg_numbered_buff_fetch_flags
reg_numbered_buff_length
reg_numbered_buff_store
regprop
reg_qr_package
reg_skipcomment
reg_temp_copy
re_indentf
re_intuit_start
re_intuit_string
re_op_compile
report_evil_fh
report_redefined_cv
report_wrongway_fh
re_printf
rpeep
rsignal_restore
rsignal_save
rvpv_dup
rxres_save
same_dirent
save_bool
save_clearsv
save_delete
save_destructor
save_destructor_x
save_freeop
save_freepv
save_freesv
save_int
save_iv
save_I8
save_I16
save_I32
save_mortalizesv
save_pptr
save_pushi32ptr
save_pushptrptr
save_re_context
save_sptr
savestack_grow
savestack_grow_cnt
save_strlen
sawparens
scalar
scalarvoid
scan_commit
scan_num
seed
set_ANYOF_arg
set_caret_X
setfd_cloexec
setfd_cloexec_for_nonsysfd
setfd_cloexec_or_inhexec_by_sysfdness
setfd_inhexec
setfd_inhexec_for_sysfd
set_numeric_standard
set_numeric_underlying
set_padlist
_setup_canned_invlist
share_hek
should_warn_nl
should_we_output_Debug_r
sighandler
sighandler1
sighandler3
single_1bit_pos32
single_1bit_pos64
Slab_Alloc
Slab_Free
Slab_to_ro
Slab_to_rw
softref2xv
sortsv_flags_impl
ssc_finalize
ssc_init
stack_grow
str_to_version
strxfrm
study_chunk
sub_crush_depth
sv_add_backref
sv_buf_to_ro
sv_del_backref
sv_i_ncmp
sv_i_ncmp_desc
sv_2iv
sv_magicext_mglob
sv_ncmp
sv_ncmp_desc
sv_only_taint_gmagic
sv_or_pv_pos_u2b
sv_pvbyten_force_wrapper
sv_pvutf8n_force_wrapper
sv_resetpvn
sv_sethek
SvTRUE_common
sv_unglob
sv_2uv
switch_locale_context
sys_init
sys_init3
sys_intern_clear
sys_intern_dup
sys_intern_init
sys_term
tied_method
tmps_grow_p
_to_fold_latin1
TOPMARK
to_uni_fold
_to_uni_fold_flags
to_uni_lower
to_uni_title
to_uni_upper
_to_upper_title_latin1
_to_utf8_fold_flags
_to_utf8_lower_flags
_to_utf8_title_flags
_to_utf8_upper_flags
translate_substr_offsets
try_amagic_bin
try_amagic_un
uiv_2buf
unlnk
unshare_hek
unwind_paren
_utf8n_to_uvchr_msgs_helper
utf16_to_utf8_base
utf16_to_utf8_reversed
utf16_to_utf8
utf8_to_uvchr_buf_helper
utilize
uvoffuni_to_utf8_flags_msgs
uvuni_to_utf8
variant_byte_number
varname
vivify_defelem
vivify_ref
wait4pid
warn_elem_scalar_context
_warn_problematic_locale
was_lvalue_sub
watch
win32_croak_not_implemented
write_to_stderr
xs_boot_epilog
xs_handshake
yyerror
yyerror_pv
yyerror_pvn
yylex
yyparse
yyquit
yyunlex</code></pre> <p>Next are the experimental undocumented elements</p>  <pre data-language="perl"><code class="plaintext">alloc_LOGOP           cx_pushloop_for              invlist_lowest
create_eval_scope     cx_pushloop_plain            newGP
cv_ckproto_len_flags  cx_pushsub                   new_warnings_bitfield
cx_popblock           cx_pushtry                   op_refcnt_dec
cx_popeval            cx_pushwhen                  op_refcnt_inc
cx_popformat          cx_topblock                  op_unscope
cx_popgiven           delete_eval_scope            scan_str
cx_poploop            do_open_raw                  scan_word
cx_popsub             do_open6                     scan_word6
cx_popsub_args        emulate_cop_io               skipspace_flags
cx_popsub_common      get_re_arg                   sv_free2
cx_popwhen            get_vtbl                     sv_kill_backrefs
cx_pushblock          gimme_V                      sv_setpv_freshbuf
cx_pusheval           hv_backreferences_p          sv_setsv_cow
cx_pushformat         hv_kill_backrefs             utf8_to_utf16_base
cx_pushgiven          invlist_highest_range_start  </code></pre> <p>Finally are the deprecated undocumented elements. Do not use any for new code; remove all occurrences of all of these from existing code.</p>  <pre data-language="perl"><code class="plaintext">get_no_modify  get_opargs  get_ppaddr  </code></pre> <h2 id="AUTHORS">AUTHORS</h2> <p>The autodocumentation system was originally added to the Perl core by Benjamin Stuhl. Documentation is by whoever was kind enough to document their functions.</p> <h2 id="SEE-ALSO">
SEE ALSO</h2> <p><i>config.h</i>, <a href="perlapi.html">perlapi</a>, <a href="perlapio.html">perlapio</a>, <a href="perlcall.html">perlcall</a>, <a href="perlclib.html">perlclib</a>, <a href="perlembed.html">perlembed</a>, <a href="perlfilter.html">perlfilter</a>, <a href="perlguts.html">perlguts</a>, <a href="perlhacktips.html">perlhacktips</a>, <a href="perlinterp.html">perlinterp</a>, <a href="perliol.html">perliol</a>, <a href="perlmroapi.html">perlmroapi</a>, <a href="perlreapi.html">perlreapi</a>, <a href="perlreguts.html">perlreguts</a>, <a href="perlxs.html">perlxs</a></p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2023 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.38.0/perlintern" class="_attribution-link">https://perldoc.perl.org/5.38.0/perlintern</a>
  </p>
</div>
