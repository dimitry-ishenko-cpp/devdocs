<h1>VMS::Filespec</h1>   <h2><a id="toc">CONTENTS</a></h2> <ul> <li> <a class="text-decoration-none" href="#NAME">NAME</a> </li> <li> <a class="text-decoration-none" href="#SYNOPSIS">SYNOPSIS</a> </li> <li> <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION</a> <ul> <li> <a class="text-decoration-none" href="#rmsexpand">rmsexpand</a> </li> <li> <a class="text-decoration-none" href="#vmsify">vmsify</a> </li> <li> <a class="text-decoration-none" href="#unixify">unixify</a> </li> <li> <a class="text-decoration-none" href="#pathify">pathify</a> </li> <li> <a class="text-decoration-none" href="#fileify">fileify</a> </li> <li> <a class="text-decoration-none" href="#vmspath">vmspath</a> </li> <li> <a class="text-decoration-none" href="#unixpath">unixpath</a> </li> <li> <a class="text-decoration-none" href="#candelete">candelete</a> </li> <li> <a class="text-decoration-none" href="#case_tolerant_process">case_tolerant_process</a> </li> <li> <a class="text-decoration-none" href="#unixrealpath">unixrealpath</a> </li> <li> <a class="text-decoration-none" href="#vmsrealpath">vmsrealpath</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#REVISION">REVISION</a> </li> </ul> <h2 id="NAME">NAME</h2> <p>VMS::Filespec - convert between VMS and Unix file specification syntax</p> <h2 id="SYNOPSIS">SYNOPSIS</h2> <pre data-language="perl"><code>use VMS::Filespec;
$fullspec = rmsexpand('[.VMS]file.specification'[, 'default:[file.spec]']);
$vmsspec = vmsify('/my/Unix/file/specification');
$unixspec = unixify('my:[VMS]file.specification');
$path = pathify('my:[VMS.or.Unix.directory]specification.dir');
$dirfile = fileify('my:[VMS.or.Unix.directory.specification]');
$vmsdir = vmspath('my/VMS/or/Unix/directory/specification.dir');
$unixdir = unixpath('my:[VMS.or.Unix.directory]specification.dir');
candelete('my:[VMS.or.Unix]file.specification');
$case_tolerant = case_tolerant_process;
$unixspec = unixrealpath('file_specification');
$vmsspec = vmsrealpath('file_specification');</code></pre> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>This package provides routines to simplify conversion between VMS and Unix syntax when processing file specifications. This is useful when porting scripts designed to run under either OS, and also allows you to take advantage of conveniences provided by either syntax (<i>e.g.</i> ability to easily concatenate Unix-style specifications). In addition, it provides an additional file test routine, <code>candelete</code>, which determines whether you have delete access to a file.</p> <p>If you're running under VMS, the routines in this package are special, in that they're automatically made available to any Perl script, whether you're running <i>miniperl</i> or the full <i>perl</i>. The <code>use VMS::Filespec</code> or <code>require VMS::Filespec; import VMS::Filespec ...</code> statement can be used to import the function names into the current package, but they're always available if you use the fully qualified name, whether or not you've mentioned the <i>.pm</i> file in your script. If you're running under another OS and have installed this package, it behaves like a normal Perl extension (in fact, you're using Perl substitutes to emulate the necessary VMS system calls).</p> <p>Each of these routines accepts a file specification in either VMS or Unix syntax, and returns the converted file specification, or <code>undef</code> if an error occurs. The conversions are, for the most part, simply string manipulations; the routines do not check the details of syntax (e.g. that only legal characters are used). There is one exception: when running under VMS, conversions from VMS syntax use the $PARSE service to expand specifications, so illegal syntax, or a relative directory specification which extends above the tope of the current directory path (e.g [---.foo] when in dev:[dir.sub]) will cause errors. In general, any legal file specification will be converted properly, but garbage input tends to produce garbage output.</p> <p>Each of these routines is prototyped as taking a single scalar argument, so you can use them as unary operators in complex expressions (as long as you don't use the <code>&amp;</code> form of subroutine call, which bypasses prototype checking).</p> <p>The routines provided are:</p> <h3 id="rmsexpand">rmsexpand</h3> <p>Uses the RMS $PARSE and $SEARCH services to expand the input specification to its fully qualified form, except that a null type or version is not added unless it was present in either the original file specification or the default specification passed to <code>rmsexpand</code>. (If the file does not exist, the input specification is expanded as much as possible.) If an error occurs, returns <code>undef</code> and sets <code>$!</code> and <code>$^E</code>.</p> <p><code>rmsexpand</code> on success will produce a name that fits in a 255 byte buffer, which is required for parameters passed to the DCL interpreter.</p> <h3 id="vmsify">vmsify</h3> <p>Converts a file specification to VMS syntax. If the file specification cannot be converted to or is already in VMS syntax, it will be passed through unchanged.</p> <p>The file specifications of <code>.</code> and <code>..</code> will be converted to <code>[]</code> and <code>[-]</code>.</p> <p>If the file specification is already in a valid VMS syntax, it will be passed through unchanged, except that the UTF-8 flag will be cleared since VMS format file specifications are never in UTF-8.</p> <p>When Perl is running on an OpenVMS system, if the <code>DECC$EFS_CHARSET</code> feature is not enabled, extra dots in the file specification will be converted to underscore characters, and the <code>?</code> character will be converted to a <code>%</code> character, if a conversion is done.</p> <p>When Perl is running on an OpenVMS system, if the <code>DECC$EFS_CHARSET</code> feature is enabled, this implies that the Unix pathname cannot have a version, and that a path consisting of three dots, <code>./.../</code>, will be converted to <code>[.^.^.^.]</code>.</p> <p>Unix style shell macros like <code>$(abcd)</code> are passed through instead of being converted to <code>$^(abcd^)</code> independent of the <code>DECC$EFS_CHARSET</code> feature setting. Unix style shell macros should not use characters that are not in the ASCII character set, as the resulting specification may or may not be still in UTF8 format.</p> <p>The feature logical name <code>PERL_VMS_VTF7_FILENAMES</code> controls if UNICODE characters in Unix filenames are encoded in VTF-7 notation in the resulting OpenVMS file specification. [Currently under development]</p> <p><code>unixify</code> on the resulting file specification may not result in the original Unix file specification, so programs should not plan to convert a file specification from Unix to VMS and then back to Unix again after modification of the components.</p> <h3 id="unixify">unixify</h3> <p>Converts a file specification to Unix syntax. If the file specification cannot be converted to or is already in Unix syntax, it will be passed through unchanged.</p> <p>When Perl is running on an OpenVMS system, the following <code>DECC$</code> feature settings will control how the filename is converted:</p> <pre data-language="perl"><code>C&lt;decc$disable_to_vms_logname_translation:&gt; default = C&lt;ENABLE&gt;
C&lt;decc$disable_posix_root:&gt;                 default = C&lt;ENABLE&gt;
C&lt;decc$efs_charset:&gt;                        default = C&lt;DISABLE&gt;
C&lt;decc$filename_unix_no_version:&gt;           default = C&lt;DISABLE&gt;
C&lt;decc$readdir_dropdotnotype:&gt;              default = C&lt;ENABLE&gt;</code></pre> <p>When Perl is being run under a Unix shell on OpenVMS, the defaults at a future time may be more appropriate for it.</p> <p>When Perl is running on an OpenVMS system with <code>DECC$EFS_CHARSET</code> enabled, a wild card directory name of <code>[...]</code> cannot be translated to a valid Unix file specification. Also, directory file specifications will have their implied ".dir;1" removed, and a trailing <code>.</code> character indicating a null extension will be removed.</p> <p>Note that <code>DECC$EFS_CHARSET</code> requires <code>DECC$FILENAME_UNIX_NO_VERSION</code> because the conversion routine cannot differentiate whether the last <code>.</code> of a Unix specification is delimiting a version, or is just part of a file specification.</p> <p><code>vmsify</code> on the resulting file specification may not result in the original VMS file specification, so programs should not plan to convert a file specification from VMS to Unix and then back to VMS again after modification.</p> <h3 id="pathify">pathify</h3> <p>Converts a directory specification to a path - that is, a string you can prepend to a file name to form a valid file specification. If the input file specification uses VMS syntax, the returned path does, too; likewise for Unix syntax (Unix paths are guaranteed to end with '/'). Note that this routine will insist that the input be a legal directory file specification; the file type and version, if specified, must be <i>.DIR;1</i>. For compatibility with Unix usage, the type and version may also be omitted.</p> <h3 id="fileify">fileify</h3> <p>Converts a directory specification to the file specification of the directory file - that is, a string you can pass to functions like <code>stat</code> or <code>rmdir</code> to manipulate the directory file. If the input directory specification uses VMS syntax, the returned file specification does, too; likewise for Unix syntax. As with <code>pathify</code>, the input file specification must have a type and version of <i>.DIR;1</i>, or the type and version must be omitted.</p> <h3 id="vmspath">vmspath</h3> <p>Acts like <code>pathify</code>, but insures the returned path uses VMS syntax.</p> <h3 id="unixpath">unixpath</h3> <p>Acts like <code>pathify</code>, but insures the returned path uses Unix syntax.</p> <h3 id="candelete">candelete</h3> <p>Determines whether you have delete access to a file. If you do, <code>candelete</code> returns true. If you don't, or its argument isn't a legal file specification, <code>candelete</code> returns FALSE. Unlike other file tests, the argument to <code>candelete</code> must be a file name (not a FileHandle), and, since it's an XSUB, it's a list operator, so you need to be careful about parentheses. Both of these restrictions may be removed in the future if the functionality of <code>candelete</code> becomes part of the Perl core.</p> <h3 id="case_tolerant_process">case_tolerant_process</h3> <p>This reports whether the VMS process has been set to a case tolerant state, and returns true when the process is in the traditional case tolerant mode and false when case sensitivity has been enabled for the process. It is intended for use by the File::Spec::VMS-&gt;case_tolerant method only, and it is recommended that you only use File::Spec-&gt;case_tolerant.</p> <h3 id="unixrealpath">unixrealpath</h3> <p>This exposes the VMS C library <code>realpath</code> function where available. It will always return a Unix format specification.</p> <p>If the <code>realpath</code> function is not available, or is unable to return the real path of the file, <code>unixrealpath</code> will use the same internal procedure as the <code>vmsrealpath</code> function and convert the output to a Unix format specification. It is not available on non-VMS systems.</p> <h3 id="vmsrealpath">vmsrealpath</h3> <p>This uses the <code>LIB$FID_TO_NAME</code> run-time library call to find the name of the primary link to a file, and returns the filename in VMS format. This function is not available on non-VMS systems.</p> <h2 id="REVISION">REVISION</h2> <p>This document was last revised 8-DEC-2007, for Perl 5.10.0</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2023 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.38.0/VMS::Filespec" class="_attribution-link">https://perldoc.perl.org/5.38.0/VMS::Filespec</a>
  </p>
</div>
