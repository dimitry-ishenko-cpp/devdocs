<h1>Math::BigInt</h1>   <h2><a id="toc">CONTENTS</a></h2> <ul> <li> <a class="text-decoration-none" href="#NAME">NAME</a> </li> <li> <a class="text-decoration-none" href="#SYNOPSIS">SYNOPSIS</a> </li> <li> <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION</a> <ul> <li> <a class="text-decoration-none" href="#Input">Input</a> </li> <li> <a class="text-decoration-none" href="#Output">Output</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#METHODS">METHODS</a> <ul> <li> <a class="text-decoration-none" href="#Configuration-methods">Configuration methods</a> </li> <li> <a class="text-decoration-none" href="#Constructor-methods">Constructor methods</a> </li> <li> <a class="text-decoration-none" href="#Boolean-methods">Boolean methods</a> </li> <li> <a class="text-decoration-none" href="#Comparison-methods">Comparison methods</a> </li> <li> <a class="text-decoration-none" href="#Arithmetic-methods">Arithmetic methods</a> </li> <li> <a class="text-decoration-none" href="#Bitwise-methods">Bitwise methods</a> </li> <li> <a class="text-decoration-none" href="#Rounding-methods">Rounding methods</a> </li> <li> <a class="text-decoration-none" href="#Other-mathematical-methods">Other mathematical methods</a> </li> <li> <a class="text-decoration-none" href="#Object-property-methods">Object property methods</a> </li> <li> <a class="text-decoration-none" href="#String-conversion-methods">String conversion methods</a> </li> <li> <a class="text-decoration-none" href="#Other-conversion-methods">Other conversion methods</a> </li> <li> <a class="text-decoration-none" href="#Utility-methods">Utility methods</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#ACCURACY-and-PRECISION">ACCURACY and PRECISION</a> <ul> <li> <a class="text-decoration-none" href="#Precision-P">Precision P</a> </li> <li> <a class="text-decoration-none" href="#Accuracy-A">Accuracy A</a> </li> <li> <a class="text-decoration-none" href="#Fallback-F">Fallback F</a> </li> <li> <a class="text-decoration-none" href="#Rounding-mode-R">Rounding mode R</a> <ul> <li> <a class="text-decoration-none" href="#Directed-rounding">Directed rounding</a> </li> <li> <a class="text-decoration-none" href="#Rounding-to-nearest">Rounding to nearest</a> </li> </ul> </li> </ul> </li> <li> <a class="text-decoration-none" href="#Infinity-and-Not-a-Number">Infinity and Not a Number</a> </li> <li> <a class="text-decoration-none" href="#INTERNALS">INTERNALS</a> <ul> <li> <a class="text-decoration-none" href="#MATH-LIBRARY">MATH LIBRARY</a> <ul> <li> <a class="text-decoration-none" href="#The-default-library">The default library</a> </li> <li> <a class="text-decoration-none" href="#Specifying-a-library">Specifying a library</a> </li> <li> <a class="text-decoration-none" href="#Which-library-to-use?">Which library to use?</a> </li> <li> <a class="text-decoration-none" href="#Loading-multiple-libraries">Loading multiple libraries</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#SIGN">SIGN</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#EXAMPLES">EXAMPLES</a> </li> <li> <a class="text-decoration-none" href="#NUMERIC-LITERALS">NUMERIC LITERALS</a> <ul> <li> <a class="text-decoration-none" href="#Hexadecimal,-octal,-and-binary-floating-point-literals">Hexadecimal, octal, and binary floating point literals</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#PERFORMANCE">PERFORMANCE</a> <ul> <li> <a class="text-decoration-none" href="#Alternative-math-libraries">Alternative math libraries</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#SUBCLASSING">SUBCLASSING</a> <ul> <li> <a class="text-decoration-none" href="#Subclassing-Math::BigInt">Subclassing Math::BigInt</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#UPGRADING">UPGRADING</a> <ul> <li> <a class="text-decoration-none" href="#Auto-upgrade">Auto-upgrade</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#EXPORTS">EXPORTS</a> </li> <li> <a class="text-decoration-none" href="#CAVEATS">CAVEATS</a> </li> <li> <a class="text-decoration-none" href="#BUGS">BUGS</a> </li> <li> <a class="text-decoration-none" href="#SUPPORT">SUPPORT</a> </li> <li> <a class="text-decoration-none" href="#LICENSE">LICENSE</a> </li> <li> <a class="text-decoration-none" href="#SEE-ALSO">SEE ALSO</a> </li> <li> <a class="text-decoration-none" href="#AUTHORS">AUTHORS</a> </li> </ul> <h2 id="NAME">NAME</h2> <p>Math::BigInt - arbitrary size integer math package</p> <h2 id="SYNOPSIS">SYNOPSIS</h2> <pre data-language="perl"><code class="nohighlight">use Math::BigInt;

# or make it faster with huge numbers: install (optional)
# Math::BigInt::GMP and always use (it falls back to
# pure Perl if the GMP library is not installed):
# (See also the L&lt;MATH LIBRARY&gt; section!)

# to warn if Math::BigInt::GMP cannot be found, use
use Math::BigInt lib =&gt; 'GMP';

# to suppress the warning if Math::BigInt::GMP cannot be found, use
# use Math::BigInt try =&gt; 'GMP';

# to die if Math::BigInt::GMP cannot be found, use
# use Math::BigInt only =&gt; 'GMP';

# Configuration methods (may be used as class methods and instance methods)

Math::BigInt-&gt;accuracy();     # get class accuracy
Math::BigInt-&gt;accuracy($n);   # set class accuracy
Math::BigInt-&gt;precision();    # get class precision
Math::BigInt-&gt;precision($n);  # set class precision
Math::BigInt-&gt;round_mode();   # get class rounding mode
Math::BigInt-&gt;round_mode($m); # set global round mode, must be one of
                              # 'even', 'odd', '+inf', '-inf', 'zero',
                              # 'trunc', or 'common'
Math::BigInt-&gt;config();       # return hash with configuration

# Constructor methods (when the class methods below are used as instance
# methods, the value is assigned the invocand)

$x = Math::BigInt-&gt;new($str);             # defaults to 0
$x = Math::BigInt-&gt;new('0x123');          # from hexadecimal
$x = Math::BigInt-&gt;new('0b101');          # from binary
$x = Math::BigInt-&gt;from_hex('cafe');      # from hexadecimal
$x = Math::BigInt-&gt;from_oct('377');       # from octal
$x = Math::BigInt-&gt;from_bin('1101');      # from binary
$x = Math::BigInt-&gt;from_base('why', 36);  # from any base
$x = Math::BigInt-&gt;from_base_num([1, 0], 2);  # from any base
$x = Math::BigInt-&gt;bzero();               # create a +0
$x = Math::BigInt-&gt;bone();                # create a +1
$x = Math::BigInt-&gt;bone('-');             # create a -1
$x = Math::BigInt-&gt;binf();                # create a +inf
$x = Math::BigInt-&gt;binf('-');             # create a -inf
$x = Math::BigInt-&gt;bnan();                # create a Not-A-Number
$x = Math::BigInt-&gt;bpi();                 # returns pi

$y = $x-&gt;copy();        # make a copy (unlike $y = $x)
$y = $x-&gt;as_int();      # return as a Math::BigInt
$y = $x-&gt;as_float();    # return as a Math::BigFloat
$y = $x-&gt;as_rat();      # return as a Math::BigRat

# Boolean methods (these don't modify the invocand)

$x-&gt;is_zero();          # if $x is 0
$x-&gt;is_one();           # if $x is +1
$x-&gt;is_one("+");        # ditto
$x-&gt;is_one("-");        # if $x is -1
$x-&gt;is_inf();           # if $x is +inf or -inf
$x-&gt;is_inf("+");        # if $x is +inf
$x-&gt;is_inf("-");        # if $x is -inf
$x-&gt;is_nan();           # if $x is NaN

$x-&gt;is_positive();      # if $x &gt; 0
$x-&gt;is_pos();           # ditto
$x-&gt;is_negative();      # if $x &lt; 0
$x-&gt;is_neg();           # ditto

$x-&gt;is_odd();           # if $x is odd
$x-&gt;is_even();          # if $x is even
$x-&gt;is_int();           # if $x is an integer

# Comparison methods

$x-&gt;bcmp($y);           # compare numbers (undef, &lt; 0, == 0, &gt; 0)
$x-&gt;bacmp($y);          # compare absolutely (undef, &lt; 0, == 0, &gt; 0)
$x-&gt;beq($y);            # true if and only if $x == $y
$x-&gt;bne($y);            # true if and only if $x != $y
$x-&gt;blt($y);            # true if and only if $x &lt; $y
$x-&gt;ble($y);            # true if and only if $x &lt;= $y
$x-&gt;bgt($y);            # true if and only if $x &gt; $y
$x-&gt;bge($y);            # true if and only if $x &gt;= $y

# Arithmetic methods

$x-&gt;bneg();             # negation
$x-&gt;babs();             # absolute value
$x-&gt;bsgn();             # sign function (-1, 0, 1, or NaN)
$x-&gt;bnorm();            # normalize (no-op)
$x-&gt;binc();             # increment $x by 1
$x-&gt;bdec();             # decrement $x by 1
$x-&gt;badd($y);           # addition (add $y to $x)
$x-&gt;bsub($y);           # subtraction (subtract $y from $x)
$x-&gt;bmul($y);           # multiplication (multiply $x by $y)
$x-&gt;bmuladd($y,$z);     # $x = $x * $y + $z
$x-&gt;bdiv($y);           # division (floored), set $x to quotient
                        # return (quo,rem) or quo if scalar
$x-&gt;btdiv($y);          # division (truncated), set $x to quotient
                        # return (quo,rem) or quo if scalar
$x-&gt;bmod($y);           # modulus (x % y)
$x-&gt;btmod($y);          # modulus (truncated)
$x-&gt;bmodinv($mod);      # modular multiplicative inverse
$x-&gt;bmodpow($y,$mod);   # modular exponentiation (($x ** $y) % $mod)
$x-&gt;bpow($y);           # power of arguments (x ** y)
$x-&gt;blog();             # logarithm of $x to base e (Euler's number)
$x-&gt;blog($base);        # logarithm of $x to base $base (e.g., base 2)
$x-&gt;bexp();             # calculate e ** $x where e is Euler's number
$x-&gt;bnok($y);           # x over y (binomial coefficient n over k)
$x-&gt;buparrow($n, $y);   # Knuth's up-arrow notation
$x-&gt;backermann($y);     # the Ackermann function
$x-&gt;bsin();             # sine
$x-&gt;bcos();             # cosine
$x-&gt;batan();            # inverse tangent
$x-&gt;batan2($y);         # two-argument inverse tangent
$x-&gt;bsqrt();            # calculate square root
$x-&gt;broot($y);          # $y'th root of $x (e.g. $y == 3 =&gt; cubic root)
$x-&gt;bfac();             # factorial of $x (1*2*3*4*..$x)
$x-&gt;bdfac();            # double factorial of $x ($x*($x-2)*($x-4)*...)
$x-&gt;btfac();            # triple factorial of $x ($x*($x-3)*($x-6)*...)
$x-&gt;bmfac($k);          # $k'th multi-factorial of $x ($x*($x-$k)*...)

$x-&gt;blsft($n);          # left shift $n places in base 2
$x-&gt;blsft($n,$b);       # left shift $n places in base $b
                        # returns (quo,rem) or quo (scalar context)
$x-&gt;brsft($n);          # right shift $n places in base 2
$x-&gt;brsft($n,$b);       # right shift $n places in base $b
                        # returns (quo,rem) or quo (scalar context)

# Bitwise methods

$x-&gt;band($y);           # bitwise and
$x-&gt;bior($y);           # bitwise inclusive or
$x-&gt;bxor($y);           # bitwise exclusive or
$x-&gt;bnot();             # bitwise not (two's complement)

# Rounding methods
$x-&gt;round($A,$P,$mode); # round to accuracy or precision using
                        # rounding mode $mode
$x-&gt;bround($n);         # accuracy: preserve $n digits
$x-&gt;bfround($n);        # $n &gt; 0: round to $nth digit left of dec. point
                        # $n &lt; 0: round to $nth digit right of dec. point
$x-&gt;bfloor();           # round towards minus infinity
$x-&gt;bceil();            # round towards plus infinity
$x-&gt;bint();             # round towards zero

# Other mathematical methods

$x-&gt;bgcd($y);            # greatest common divisor
$x-&gt;blcm($y);            # least common multiple

# Object property methods (do not modify the invocand)

$x-&gt;sign();              # the sign, either +, - or NaN
$x-&gt;digit($n);           # the nth digit, counting from the right
$x-&gt;digit(-$n);          # the nth digit, counting from the left
$x-&gt;length();            # return number of digits in number
($xl,$f) = $x-&gt;length(); # length of number and length of fraction
                         # part, latter is always 0 digits long
                         # for Math::BigInt objects
$x-&gt;mantissa();          # return (signed) mantissa as a Math::BigInt
$x-&gt;exponent();          # return exponent as a Math::BigInt
$x-&gt;parts();             # return (mantissa,exponent) as a Math::BigInt
$x-&gt;sparts();            # mantissa and exponent (as integers)
$x-&gt;nparts();            # mantissa and exponent (normalised)
$x-&gt;eparts();            # mantissa and exponent (engineering notation)
$x-&gt;dparts();            # integer and fraction part
$x-&gt;fparts();            # numerator and denominator
$x-&gt;numerator();         # numerator
$x-&gt;denominator();       # denominator

# Conversion methods (do not modify the invocand)

$x-&gt;bstr();         # decimal notation, possibly zero padded
$x-&gt;bsstr();        # string in scientific notation with integers
$x-&gt;bnstr();        # string in normalized notation
$x-&gt;bestr();        # string in engineering notation
$x-&gt;bfstr();        # string in fractional notation

$x-&gt;to_hex();       # as signed hexadecimal string
$x-&gt;to_bin();       # as signed binary string
$x-&gt;to_oct();       # as signed octal string
$x-&gt;to_bytes();     # as byte string
$x-&gt;to_base($b);    # as string in any base
$x-&gt;to_base_num($b);   # as array of integers in any base

$x-&gt;as_hex();       # as signed hexadecimal string with prefixed 0x
$x-&gt;as_bin();       # as signed binary string with prefixed 0b
$x-&gt;as_oct();       # as signed octal string with prefixed 0

# Other conversion methods

$x-&gt;numify();           # return as scalar (might overflow or underflow)</code></pre> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>Math::BigInt provides support for arbitrary precision integers. Overloading is also provided for Perl operators.</p> <h3 id="Input">Input</h3> <p>Input values to these routines may be any scalar number or string that looks like a number and represents an integer. Anything that is accepted by Perl as a literal numeric constant should be accepted by this module, except that finite non-integers return NaN.</p> <ul> <li>
<p>Leading and trailing whitespace is ignored.</p> </li> <li>
<p>Leading zeros are ignored, except for floating point numbers with a binary exponent, in which case the number is interpreted as an octal floating point number. For example, "01.4p+0" gives 1.5, "00.4p+0" gives 0.5, but "0.4p+0" gives a NaN. And while "0377" gives 255, "0377p0" gives 255.</p> </li> <li>
<p>If the string has a "0x" or "0X" prefix, it is interpreted as a hexadecimal number.</p> </li> <li>
<p>If the string has a "0o" or "0O" prefix, it is interpreted as an octal number. A floating point literal with a "0" prefix is also interpreted as an octal number.</p> </li> <li>
<p>If the string has a "0b" or "0B" prefix, it is interpreted as a binary number.</p> </li> <li>
<p>Underline characters are allowed in the same way as they are allowed in literal numerical constants.</p> </li> <li>
<p>If the string can not be interpreted, or does not represent a finite integer, NaN is returned.</p> </li> <li>
<p>For hexadecimal, octal, and binary floating point numbers, the exponent must be separated from the significand (mantissa) by the letter "p" or "P", not "e" or "E" as with decimal numbers.</p> </li> </ul> <p>Some examples of valid string input</p> <pre data-language="perl"><code class="plaintext">Input string                Resulting value

123                         123
1.23e2                      123
12300e-2                    123

67_538_754                  67538754
-4_5_6.7_8_9e+0_1_0         -4567890000000

0x13a                       314
0x13ap0                     314
0x1.3ap+8                   314
0x0.00013ap+24              314
0x13a000p-12                314

0o472                       314
0o1.164p+8                  314
0o0.0001164p+20             314
0o1164000p-10               314

0472                        472     Note!
01.164p+8                   314
00.0001164p+20              314
01164000p-10                314

0b100111010                 314
0b1.0011101p+8              314
0b0.00010011101p+12         314
0b100111010000p-3           314</code></pre> <p>Input given as scalar numbers might lose precision. Quote your input to ensure that no digits are lost:</p> <pre data-language="perl"><code>$x = Math::BigInt-&gt;new( 56789012345678901234 );   # bad
$x = Math::BigInt-&gt;new('56789012345678901234');   # good</code></pre> <p>Currently, <code>Math::BigInt-</code>new()&gt; (no input argument) and <code>Math::BigInt-</code>new("")&gt; return 0. This might change in the future, so always use the following explicit forms to get a zero:</p> <pre data-language="perl"><code>$zero = Math::BigInt-&gt;bzero();</code></pre> <h3 id="Output">Output</h3> <p>Output values are usually Math::BigInt objects.</p> <p>Boolean operators <code>is_zero()</code>, <code>is_one()</code>, <code>is_inf()</code>, etc. return true or false.</p> <p>Comparison operators <code>bcmp()</code> and <code>bacmp()</code>) return -1, 0, 1, or undef.</p> <h2 id="METHODS">METHODS</h2> <h3 id="Configuration-methods">
Configuration methods</h3> <p>Each of the methods below (except config(), accuracy() and precision()) accepts three additional parameters. These arguments <code>$A</code>, <code>$P</code> and <code>$R</code> are <code>accuracy</code>, <code>precision</code> and <code>round_mode</code>. Please see the section about <a href="#ACCURACY-and-PRECISION">"ACCURACY and PRECISION"</a> for more information.</p> <p>Setting a class variable effects all object instance that are created afterwards.</p> <dl> <dt id="accuracy()">
accuracy()</dt> <dd> <pre data-language="perl"><code>Math::BigInt-&gt;accuracy(5);      # set class accuracy
$x-&gt;accuracy(5);                # set instance accuracy

$A = Math::BigInt-&gt;accuracy();  # get class accuracy
$A = $x-&gt;accuracy();            # get instance accuracy</code></pre> <p>Set or get the accuracy, i.e., the number of significant digits. The accuracy must be an integer. If the accuracy is set to <code>undef</code>, no rounding is done.</p> <p>Alternatively, one can round the results explicitly using one of <a href="#round%28%29">"round()"</a>, <a href="#bround%28%29">"bround()"</a> or <a href="#bfround%28%29">"bfround()"</a> or by passing the desired accuracy to the method as an additional parameter:</p> <pre data-language="perl"><code>my $x = Math::BigInt-&gt;new(30000);
my $y = Math::BigInt-&gt;new(7);
print scalar $x-&gt;copy()-&gt;bdiv($y, 2);               # prints 4300
print scalar $x-&gt;copy()-&gt;bdiv($y)-&gt;bround(2);       # prints 4300</code></pre> <p>Please see the section about <a href="#ACCURACY-and-PRECISION">"ACCURACY and PRECISION"</a> for further details.</p> <pre data-language="perl"><code>$y = Math::BigInt-&gt;new(1234567);    # $y is not rounded
Math::BigInt-&gt;accuracy(4);          # set class accuracy to 4
$x = Math::BigInt-&gt;new(1234567);    # $x is rounded automatically
print "$x $y";                      # prints "1235000 1234567"

print $x-&gt;accuracy();       # prints "4"
print $y-&gt;accuracy();       # also prints "4", since
                            #   class accuracy is 4

Math::BigInt-&gt;accuracy(5);  # set class accuracy to 5
print $x-&gt;accuracy();       # prints "4", since instance
                            #   accuracy is 4
print $y-&gt;accuracy();       # prints "5", since no instance
                            #   accuracy, and class accuracy is 5</code></pre> <p>Note: Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</p> </dd> <dt id="precision()">
precision()</dt> <dd> <pre data-language="perl"><code>Math::BigInt-&gt;precision(-2);     # set class precision
$x-&gt;precision(-2);               # set instance precision

$P = Math::BigInt-&gt;precision();  # get class precision
$P = $x-&gt;precision();            # get instance precision</code></pre> <p>Set or get the precision, i.e., the place to round relative to the decimal point. The precision must be a integer. Setting the precision to $P means that each number is rounded up or down, depending on the rounding mode, to the nearest multiple of 10**$P. If the precision is set to <code>undef</code>, no rounding is done.</p> <p>You might want to use <a href="#accuracy%28%29">"accuracy()"</a> instead. With <a href="#accuracy%28%29">"accuracy()"</a> you set the number of digits each result should have, with <a href="#precision%28%29">"precision()"</a> you set the place where to round.</p> <p>Please see the section about <a href="#ACCURACY-and-PRECISION">"ACCURACY and PRECISION"</a> for further details.</p> <pre data-language="perl"><code>$y = Math::BigInt-&gt;new(1234567);    # $y is not rounded
Math::BigInt-&gt;precision(4);         # set class precision to 4
$x = Math::BigInt-&gt;new(1234567);    # $x is rounded automatically
print $x;                           # prints "1230000"</code></pre> <p>Note: Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</p> </dd> <dt id="div_scale()">
div_scale()</dt> <dd> <p>Set/get the fallback accuracy. This is the accuracy used when neither accuracy nor precision is set explicitly. It is used when a computation might otherwise attempt to return an infinite number of digits.</p> </dd> <dt id="round_mode()">
round_mode()</dt> <dd> <p>Set/get the rounding mode.</p> </dd> <dt id="upgrade()">
upgrade()</dt> <dd> <p>Set/get the class for upgrading. When a computation might result in a non-integer, the operands are upgraded to this class. This is used for instance by <a href="bignum.html">bignum</a>. The default is <code>undef</code>, i.e., no upgrading.</p> <pre data-language="perl"><code># with no upgrading
$x = Math::BigInt-&gt;new(12);
$y = Math::BigInt-&gt;new(5);
print $x / $y, "\n";                # 2 as a Math::BigInt

# with upgrading to Math::BigFloat
Math::BigInt -&gt; upgrade("Math::BigFloat");
print $x / $y, "\n";                # 2.4 as a Math::BigFloat

# with upgrading to Math::BigRat (after loading Math::BigRat)
Math::BigInt -&gt; upgrade("Math::BigRat");
print $x / $y, "\n";                # 12/5 as a Math::BigRat</code></pre> </dd> <dt id="downgrade()">
downgrade()</dt> <dd> <p>Set/get the class for downgrading. The default is <code>undef</code>, i.e., no downgrading. Downgrading is not done by Math::BigInt.</p> </dd> <dt id="modify()">
modify()</dt> <dd> <pre data-language="perl"><code>$x-&gt;modify('bpowd');</code></pre> <p>This method returns 0 if the object can be modified with the given operation, or 1 if not.</p> <p>This is used for instance by <a href="Math::BigInt::Constant.html">Math::BigInt::Constant</a>.</p> </dd> <dt id="config()">
config()</dt> <dd> <pre data-language="perl"><code>Math::BigInt-&gt;config("trap_nan" =&gt; 1);      # set
$accu = Math::BigInt-&gt;config("accuracy");   # get</code></pre> <p>Set or get class variables. Read-only parameters are marked as RO. Read-write parameters are marked as RW. The following parameters are supported.</p> <pre data-language="perl"><code class="plaintext">Parameter       RO/RW   Description
                        Example
============================================================
lib             RO      Name of the math backend library
                        Math::BigInt::Calc
lib_version     RO      Version of the math backend library
                        0.30
class           RO      The class of config you just called
                        Math::BigRat
version         RO      version number of the class you used
                        0.10
upgrade         RW      To which class numbers are upgraded
                        undef
downgrade       RW      To which class numbers are downgraded
                        undef
precision       RW      Global precision
                        undef
accuracy        RW      Global accuracy
                        undef
round_mode      RW      Global round mode
                        even
div_scale       RW      Fallback accuracy for division etc.
                        40
trap_nan        RW      Trap NaNs
                        undef
trap_inf        RW      Trap +inf/-inf
                        undef</code></pre> </dd> </dl> <h3 id="Constructor-methods">
Constructor methods</h3> <dl> <dt id="new()">
new()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;new($str,$A,$P,$R);</code></pre> <p>Creates a new Math::BigInt object from a scalar or another Math::BigInt object. The input is accepted as decimal, hexadecimal (with leading '0x'), octal (with leading ('0o') or binary (with leading '0b').</p> <p>See <a href="#Input">"Input"</a> for more info on accepted input formats.</p> </dd> <dt id="from_dec()">
from_dec()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;from_dec("314159");    # input is decimal</code></pre> <p>Interpret input as a decimal. It is equivalent to new(), but does not accept anything but strings representing finite, decimal numbers.</p> </dd> <dt id="from_hex()">
from_hex()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;from_hex("0xcafe");    # input is hexadecimal</code></pre> <p>Interpret input as a hexadecimal string. A "0x" or "x" prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</p> </dd> <dt id="from_oct()">
from_oct()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;from_oct("0775");      # input is octal</code></pre> <p>Interpret the input as an octal string and return the corresponding value. A "0" (zero) prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</p> </dd> <dt id="from_bin()">
from_bin()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;from_bin("0b10011");   # input is binary</code></pre> <p>Interpret the input as a binary string. A "0b" or "b" prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</p> </dd> <dt id="from_bytes()">
from_bytes()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;from_bytes("\xf3\x6b");  # $x = 62315</code></pre> <p>Interpret the input as a byte string, assuming big endian byte order. The output is always a non-negative, finite integer.</p> <p>In some special cases, from_bytes() matches the conversion done by unpack():</p> <pre data-language="perl"><code>$b = "\x4e";                             # one char byte string
$x = Math::BigInt-&gt;from_bytes($b);       # = 78
$y = unpack "C", $b;                     # ditto, but scalar

$b = "\xf3\x6b";                         # two char byte string
$x = Math::BigInt-&gt;from_bytes($b);       # = 62315
$y = unpack "S&gt;", $b;                    # ditto, but scalar

$b = "\x2d\xe0\x49\xad";                 # four char byte string
$x = Math::BigInt-&gt;from_bytes($b);       # = 769673645
$y = unpack "L&gt;", $b;                    # ditto, but scalar

$b = "\x2d\xe0\x49\xad\x2d\xe0\x49\xad"; # eight char byte string
$x = Math::BigInt-&gt;from_bytes($b);       # = 3305723134637787565
$y = unpack "Q&gt;", $b;                    # ditto, but scalar</code></pre> </dd> <dt id="from_base()">
from_base()</dt> <dd> <p>Given a string, a base, and an optional collation sequence, interpret the string as a number in the given base. The collation sequence describes the value of each character in the string.</p> <p>If a collation sequence is not given, a default collation sequence is used. If the base is less than or equal to 36, the collation sequence is the string consisting of the 36 characters "0" to "9" and "A" to "Z". In this case, the letter case in the input is ignored. If the base is greater than 36, and smaller than or equal to 62, the collation sequence is the string consisting of the 62 characters "0" to "9", "A" to "Z", and "a" to "z". A base larger than 62 requires the collation sequence to be specified explicitly.</p> <p>These examples show standard binary, octal, and hexadecimal conversion. All cases return 250.</p> <pre data-language="perl"><code>$x = Math::BigInt-&gt;from_base("11111010", 2);
$x = Math::BigInt-&gt;from_base("372", 8);
$x = Math::BigInt-&gt;from_base("fa", 16);</code></pre> <p>When the base is less than or equal to 36, and no collation sequence is given, the letter case is ignored, so both of these also return 250:</p> <pre data-language="perl"><code>$x = Math::BigInt-&gt;from_base("6Y", 16);
$x = Math::BigInt-&gt;from_base("6y", 16);</code></pre> <p>When the base greater than 36, and no collation sequence is given, the default collation sequence contains both uppercase and lowercase letters, so the letter case in the input is not ignored:</p> <pre data-language="perl"><code>$x = Math::BigInt-&gt;from_base("6S", 37);         # $x is 250
$x = Math::BigInt-&gt;from_base("6s", 37);         # $x is 276
$x = Math::BigInt-&gt;from_base("121", 3);         # $x is 16
$x = Math::BigInt-&gt;from_base("XYZ", 36);        # $x is 44027
$x = Math::BigInt-&gt;from_base("Why", 42);        # $x is 58314</code></pre> <p>The collation sequence can be any set of unique characters. These two cases are equivalent</p> <pre data-language="perl"><code>$x = Math::BigInt-&gt;from_base("100", 2, "01");   # $x is 4
$x = Math::BigInt-&gt;from_base("|--", 2, "-|");   # $x is 4</code></pre> </dd> <dt id="from_base_num()">
from_base_num()</dt> <dd> <p>Returns a new Math::BigInt object given an array of values and a base. This method is equivalent to <code>from_base()</code>, but works on numbers in an array rather than characters in a string. Unlike <code>from_base()</code>, all input values may be arbitrarily large.</p> <pre data-language="perl"><code>$x = Math::BigInt-&gt;from_base_num([1, 1, 0, 1], 2)     # $x is 13
$x = Math::BigInt-&gt;from_base_num([3, 125, 39], 128)   # $x is 65191</code></pre> </dd> <dt id="bzero()">
bzero()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;bzero();
$x-&gt;bzero();</code></pre> <p>Returns a new Math::BigInt object representing zero. If used as an instance method, assigns the value to the invocand.</p> </dd> <dt id="bone()">
bone()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;bone();          # +1
$x = Math::BigInt-&gt;bone("+");       # +1
$x = Math::BigInt-&gt;bone("-");       # -1
$x-&gt;bone();                         # +1
$x-&gt;bone("+");                      # +1
$x-&gt;bone('-');                      # -1</code></pre> <p>Creates a new Math::BigInt object representing one. The optional argument is either '-' or '+', indicating whether you want plus one or minus one. If used as an instance method, assigns the value to the invocand.</p> </dd> <dt id="binf()">
binf()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;binf($sign);</code></pre> <p>Creates a new Math::BigInt object representing infinity. The optional argument is either '-' or '+', indicating whether you want infinity or minus infinity. If used as an instance method, assigns the value to the invocand.</p> <pre data-language="perl"><code>$x-&gt;binf();
$x-&gt;binf('-');</code></pre> </dd> <dt id="bnan()">
bnan()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;bnan();</code></pre> <p>Creates a new Math::BigInt object representing NaN (Not A Number). If used as an instance method, assigns the value to the invocand.</p> <pre data-language="perl"><code>$x-&gt;bnan();</code></pre> </dd> <dt id="bpi()">
bpi()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;bpi(100);        # 3
$x-&gt;bpi(100);                       # 3</code></pre> <p>Creates a new Math::BigInt object representing PI. If used as an instance method, assigns the value to the invocand. With Math::BigInt this always returns 3.</p> <p>If upgrading is in effect, returns PI, rounded to N digits with the current rounding mode:</p> <pre data-language="perl"><code>use Math::BigFloat;
use Math::BigInt upgrade =&gt; "Math::BigFloat";
print Math::BigInt-&gt;bpi(3), "\n";           # 3.14
print Math::BigInt-&gt;bpi(100), "\n";         # 3.1415....</code></pre> </dd> <dt id="copy()">
copy()</dt> <dd> <pre data-language="perl"><code>$x-&gt;copy();         # make a true copy of $x (unlike $y = $x)</code></pre> </dd> <dt id="as_int()">
as_int()</dt>  <dt id="as_number()">
as_number()</dt> <dd> <p>These methods are called when Math::BigInt encounters an object it doesn't know how to handle. For instance, assume $x is a Math::BigInt, or subclass thereof, and $y is defined, but not a Math::BigInt, or subclass thereof. If you do</p> <pre data-language="perl"><code>$x -&gt; badd($y);</code></pre> <p>$y needs to be converted into an object that $x can deal with. This is done by first checking if $y is something that $x might be upgraded to. If that is the case, no further attempts are made. The next is to see if $y supports the method <code>as_int()</code>. If it does, <code>as_int()</code> is called, but if it doesn't, the next thing is to see if $y supports the method <code>as_number()</code>. If it does, <code>as_number()</code> is called. The method <code>as_int()</code> (and <code>as_number()</code>) is expected to return either an object that has the same class as $x, a subclass thereof, or a string that <code>ref($x)-&gt;new()</code> can parse to create an object.</p> <p><code>as_number()</code> is an alias to <code>as_int()</code>. <code>as_number</code> was introduced in v1.22, while <code>as_int()</code> was introduced in v1.68.</p> <p>In Math::BigInt, <code>as_int()</code> has the same effect as <code>copy()</code>.</p> </dd> <dt id="as_float()">
as_float()</dt> <dd> <p>Return the argument as a Math::BigFloat object.</p> </dd> <dt id="as_rat()">
as_rat()</dt> <dd> <p>Return the argument as a Math::BigRat object.</p> </dd> </dl> <h3 id="Boolean-methods">
Boolean methods</h3> <p>None of these methods modify the invocand object.</p> <dl> <dt id="is_zero()">
is_zero()</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_zero();              # true if $x is 0</code></pre> <p>Returns true if the invocand is zero and false otherwise.</p> </dd> <dt id="is_one(-[-SIGN-])">
is_one( [ SIGN ])</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_one();               # true if $x is +1
$x-&gt;is_one("+");            # ditto
$x-&gt;is_one("-");            # true if $x is -1</code></pre> <p>Returns true if the invocand is one and false otherwise.</p> </dd> <dt id="is_finite()">
is_finite()</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_finite();    # true if $x is not +inf, -inf or NaN</code></pre> <p>Returns true if the invocand is a finite number, i.e., it is neither +inf, -inf, nor NaN.</p> </dd> <dt id="is_inf(-[-SIGN-]-)">
is_inf( [ SIGN ] )</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_inf();               # true if $x is +inf
$x-&gt;is_inf("+");            # ditto
$x-&gt;is_inf("-");            # true if $x is -inf</code></pre> <p>Returns true if the invocand is infinite and false otherwise.</p> </dd> <dt id="is_nan()">
is_nan()</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_nan();               # true if $x is NaN</code></pre> </dd> <dt id="is_positive()">
is_positive()</dt>  <dt id="is_pos()">
is_pos()</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_positive();          # true if &gt; 0
$x-&gt;is_pos();               # ditto</code></pre> <p>Returns true if the invocand is positive and false otherwise. A <code>NaN</code> is neither positive nor negative.</p> </dd> <dt id="is_negative()">
is_negative()</dt>  <dt id="is_neg()">
is_neg()</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_negative();          # true if &lt; 0
$x-&gt;is_neg();               # ditto</code></pre> <p>Returns true if the invocand is negative and false otherwise. A <code>NaN</code> is neither positive nor negative.</p> </dd> <dt id="is_non_positive()">
is_non_positive()</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_non_positive();      # true if &lt;= 0</code></pre> <p>Returns true if the invocand is negative or zero.</p> </dd> <dt id="is_non_negative()">
is_non_negative()</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_non_negative();      # true if &gt;= 0</code></pre> <p>Returns true if the invocand is positive or zero.</p> </dd> <dt id="is_odd()">
is_odd()</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_odd();               # true if odd, false for even</code></pre> <p>Returns true if the invocand is odd and false otherwise. <code>NaN</code>, <code>+inf</code>, and <code>-inf</code> are neither odd nor even.</p> </dd> <dt id="is_even()">
is_even()</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_even();              # true if $x is even</code></pre> <p>Returns true if the invocand is even and false otherwise. <code>NaN</code>, <code>+inf</code>, <code>-inf</code> are not integers and are neither odd nor even.</p> </dd> <dt id="is_int()">
is_int()</dt> <dd> <pre data-language="perl"><code>$x-&gt;is_int();               # true if $x is an integer</code></pre> <p>Returns true if the invocand is an integer and false otherwise. <code>NaN</code>, <code>+inf</code>, <code>-inf</code> are not integers.</p> </dd> </dl> <h3 id="Comparison-methods">
Comparison methods</h3> <p>None of these methods modify the invocand object. Note that a <code>NaN</code> is neither less than, greater than, or equal to anything else, even a <code>NaN</code>.</p> <dl> <dt id="bcmp()">
bcmp()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bcmp($y);</code></pre> <p>Returns -1, 0, 1 depending on whether $x is less than, equal to, or grater than $y. Returns undef if any operand is a NaN.</p> </dd> <dt id="bacmp()">
bacmp()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bacmp($y);</code></pre> <p>Returns -1, 0, 1 depending on whether the absolute value of $x is less than, equal to, or grater than the absolute value of $y. Returns undef if any operand is a NaN.</p> </dd> <dt id="beq()">
beq()</dt> <dd> <pre data-language="perl"><code>$x -&gt; beq($y);</code></pre> <p>Returns true if and only if $x is equal to $y, and false otherwise.</p> </dd> <dt id="bne()">
bne()</dt> <dd> <pre data-language="perl"><code>$x -&gt; bne($y);</code></pre> <p>Returns true if and only if $x is not equal to $y, and false otherwise.</p> </dd> <dt id="blt()">
blt()</dt> <dd> <pre data-language="perl"><code>$x -&gt; blt($y);</code></pre> <p>Returns true if and only if $x is equal to $y, and false otherwise.</p> </dd> <dt id="ble()">
ble()</dt> <dd> <pre data-language="perl"><code>$x -&gt; ble($y);</code></pre> <p>Returns true if and only if $x is less than or equal to $y, and false otherwise.</p> </dd> <dt id="bgt()">
bgt()</dt> <dd> <pre data-language="perl"><code>$x -&gt; bgt($y);</code></pre> <p>Returns true if and only if $x is greater than $y, and false otherwise.</p> </dd> <dt id="bge()">
bge()</dt> <dd> <pre data-language="perl"><code>$x -&gt; bge($y);</code></pre> <p>Returns true if and only if $x is greater than or equal to $y, and false otherwise.</p> </dd> </dl> <h3 id="Arithmetic-methods">
Arithmetic methods</h3> <p>These methods modify the invocand object and returns it.</p> <dl> <dt id="bneg()">
bneg()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bneg();</code></pre> <p>Negate the number, e.g. change the sign between '+' and '-', or between '+inf' and '-inf', respectively. Does nothing for NaN or zero.</p> </dd> <dt id="babs()">
babs()</dt> <dd> <pre data-language="perl"><code>$x-&gt;babs();</code></pre> <p>Set the number to its absolute value, e.g. change the sign from '-' to '+' and from '-inf' to '+inf', respectively. Does nothing for NaN or positive numbers.</p> </dd> <dt id="bsgn()">
bsgn()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bsgn();</code></pre> <p>Signum function. Set the number to -1, 0, or 1, depending on whether the number is negative, zero, or positive, respectively. Does not modify NaNs.</p> </dd> <dt id="bnorm()">
bnorm()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bnorm();                        # normalize (no-op)</code></pre> <p>Normalize the number. This is a no-op and is provided only for backwards compatibility.</p> </dd> <dt id="binc()">
binc()</dt> <dd> <pre data-language="perl"><code>$x-&gt;binc();                 # increment x by 1</code></pre> </dd> <dt id="bdec()">
bdec()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bdec();                 # decrement x by 1</code></pre> </dd> <dt id="badd()">
badd()</dt> <dd> <pre data-language="perl"><code>$x-&gt;badd($y);               # addition (add $y to $x)</code></pre> </dd> <dt id="bsub()">
bsub()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bsub($y);               # subtraction (subtract $y from $x)</code></pre> </dd> <dt id="bmul()">
bmul()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bmul($y);               # multiplication (multiply $x by $y)</code></pre> </dd> <dt id="bmuladd()">
bmuladd()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bmuladd($y,$z);</code></pre> <p>Multiply $x by $y, and then add $z to the result,</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> <dt id="bdiv()">
bdiv()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bdiv($y);               # divide, set $x to quotient</code></pre> <p>Divides $x by $y by doing floored division (F-division), where the quotient is the floored (rounded towards negative infinity) quotient of the two operands. In list context, returns the quotient and the remainder. The remainder is either zero or has the same sign as the second operand. In scalar context, only the quotient is returned.</p> <p>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</p> <pre data-language="perl"><code class="plaintext">  1 /  4  =&gt; ( 0,  1)
  1 / -4  =&gt; (-1, -3)
 -3 /  4  =&gt; (-1,  1)
 -3 / -4  =&gt; ( 0, -3)
-11 /  2  =&gt; (-5,  1)
 11 / -2  =&gt; (-5, -1)</code></pre> <p>The behavior of the overloaded operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</p> <pre data-language="perl"><code>$x == ($x / $y) * $y + ($x % $y)</code></pre> <p>holds true for any finite $x and finite, non-zero $y.</p> <p>Perl's "use integer" might change the behaviour of % and / for scalars. This is because under 'use integer' Perl does what the underlying C library thinks is right, and this varies. However, "use integer" does not change the way things are done with Math::BigInt objects.</p> </dd> <dt id="btdiv()">
btdiv()</dt> <dd> <pre data-language="perl"><code>$x-&gt;btdiv($y);              # divide, set $x to quotient</code></pre> <p>Divides $x by $y by doing truncated division (T-division), where quotient is the truncated (rouneded towards zero) quotient of the two operands. In list context, returns the quotient and the remainder. The remainder is either zero or has the same sign as the first operand. In scalar context, only the quotient is returned.</p> </dd> <dt id="bmod()">
bmod()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bmod($y);               # modulus (x % y)</code></pre> <p>Returns $x modulo $y, i.e., the remainder after floored division (F-division). This method is like Perl's % operator. See <a href="#bdiv%28%29">"bdiv()"</a>.</p> </dd> <dt id="btmod()">
btmod()</dt> <dd> <pre data-language="perl"><code>$x-&gt;btmod($y);              # modulus</code></pre> <p>Returns the remainer after truncated division (T-division). See <a href="#btdiv%28%29">"btdiv()"</a>.</p> </dd> <dt id="bmodinv()">
bmodinv()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bmodinv($mod);          # modular multiplicative inverse</code></pre> <p>Returns the multiplicative inverse of <code>$x</code> modulo <code>$mod</code>. If</p> <pre data-language="perl"><code>$y = $x -&gt; copy() -&gt; bmodinv($mod)</code></pre> <p>then <code>$y</code> is the number closest to zero, and with the same sign as <code>$mod</code>, satisfying</p> <pre data-language="perl"><code>($x * $y) % $mod = 1 % $mod</code></pre> <p>If <code>$x</code> and <code>$y</code> are non-zero, they must be relative primes, i.e., <code>bgcd($y, $mod)==1</code>. '<code>NaN</code>' is returned when no modular multiplicative inverse exists.</p> </dd> <dt id="bmodpow()">
bmodpow()</dt> <dd> <pre data-language="perl"><code>$num-&gt;bmodpow($exp,$mod);           # modular exponentiation
                                    # ($num**$exp % $mod)</code></pre> <p>Returns the value of <code>$num</code> taken to the power <code>$exp</code> in the modulus <code>$mod</code> using binary exponentiation. <code>bmodpow</code> is far superior to writing</p> <pre data-language="perl"><code>$num ** $exp % $mod</code></pre> <p>because it is much faster - it reduces internal variables into the modulus whenever possible, so it operates on smaller numbers.</p> <p><code>bmodpow</code> also supports negative exponents.</p> <pre data-language="perl"><code>bmodpow($num, -1, $mod)</code></pre> <p>is exactly equivalent to</p> <pre data-language="perl"><code>bmodinv($num, $mod)</code></pre> </dd> <dt id="bpow()">
bpow()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bpow($y);               # power of arguments (x ** y)</code></pre> <p><code>bpow()</code> (and the rounding functions) now modifies the first argument and returns it, unlike the old code which left it alone and only returned the result. This is to be consistent with <code>badd()</code> etc. The first three modifies $x, the last one won't:</p> <pre data-language="perl"><code>print bpow($x,$i),"\n";         # modify $x
print $x-&gt;bpow($i),"\n";        # ditto
print $x **= $i,"\n";           # the same
print $x ** $i,"\n";            # leave $x alone</code></pre> <p>The form <code>$x **= $y</code> is faster than <code>$x = $x ** $y;</code>, though.</p> </dd> <dt id="blog()">
blog()</dt> <dd> <pre data-language="perl"><code>$x-&gt;blog($base, $accuracy);         # logarithm of x to the base $base</code></pre> <p>If <code>$base</code> is not defined, Euler's number (e) is used:</p> <pre data-language="perl"><code>print $x-&gt;blog(undef, 100);         # log(x) to 100 digits</code></pre> </dd> <dt id="bexp()">
bexp()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bexp($accuracy);                # calculate e ** X</code></pre> <p>Calculates the expression <code>e ** $x</code> where <code>e</code> is Euler's number.</p> <p>This method was added in v1.82 of Math::BigInt (April 2007).</p> <p>See also <a href="#blog%28%29">"blog()"</a>.</p> </dd> <dt id="bnok()">
bnok()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bnok($y);               # x over y (binomial coefficient n over k)</code></pre> <p>Calculates the binomial coefficient n over k, also called the "choose" function, which is</p> <pre data-language="perl"><code class="plaintext">( n )       n!
|   |  = --------
( k )    k!(n-k)!</code></pre> <p>when n and k are non-negative. This method implements the full Kronenburg extension (Kronenburg, M.J. "The Binomial Coefficient for Negative Arguments." 18 May 2011. http://arxiv.org/abs/1105.3689/) illustrated by the following pseudo-code:</p> <pre data-language="perl"><code class="plaintext">if n &gt;= 0 and k &gt;= 0:
    return binomial(n, k)
if k &gt;= 0:
    return (-1)^k*binomial(-n+k-1, k)
if k &lt;= n:
    return (-1)^(n-k)*binomial(-k-1, n-k)
else
    return 0</code></pre> <p>The behaviour is identical to the behaviour of the Maple and Mathematica function for negative integers n, k.</p> </dd> <dt id="buparrow()">
buparrow()</dt>  <dt id="uparrow()">
uparrow()</dt> <dd> <pre data-language="perl"><code>$a -&gt; buparrow($n, $b);         # modifies $a
$x = $a -&gt; uparrow($n, $b);     # does not modify $a</code></pre> <p>This method implements Knuth's up-arrow notation, where $n is a non-negative integer representing the number of up-arrows. $n = 0 gives multiplication, $n = 1 gives exponentiation, $n = 2 gives tetration, $n = 3 gives hexation etc. The following illustrates the relation between the first values of $n.</p> <p>See <a href="https://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation">https://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation</a>.</p> </dd> <dt id="backermann()">
backermann()</dt>  <dt id="ackermann()">
ackermann()</dt> <dd> <pre data-language="perl"><code>$m -&gt; backermann($n);           # modifies $a
$x = $m -&gt; ackermann($n);       # does not modify $a</code></pre> <p>This method implements the Ackermann function:</p> <pre data-language="perl"><code class="plaintext">          / n + 1              if m = 0
A(m, n) = | A(m-1, 1)          if m &gt; 0 and n = 0
          \ A(m-1, A(m, n-1))  if m &gt; 0 and n &gt; 0</code></pre> <p>Its value grows rapidly, even for small inputs. For example, A(4, 2) is an integer of 19729 decimal digits.</p> <p>See https://en.wikipedia.org/wiki/Ackermann_function</p> </dd> <dt id="bsin()">
bsin()</dt> <dd> <pre data-language="perl"><code>my $x = Math::BigInt-&gt;new(1);
print $x-&gt;bsin(100), "\n";</code></pre> <p>Calculate the sine of $x, modifying $x in place.</p> <p>In Math::BigInt, unless upgrading is in effect, the result is truncated to an integer.</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> <dt id="bcos()">
bcos()</dt> <dd> <pre data-language="perl"><code>my $x = Math::BigInt-&gt;new(1);
print $x-&gt;bcos(100), "\n";</code></pre> <p>Calculate the cosine of $x, modifying $x in place.</p> <p>In Math::BigInt, unless upgrading is in effect, the result is truncated to an integer.</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> <dt id="batan()">
batan()</dt> <dd> <pre data-language="perl"><code>my $x = Math::BigFloat-&gt;new(0.5);
print $x-&gt;batan(100), "\n";</code></pre> <p>Calculate the arcus tangens of $x, modifying $x in place.</p> <p>In Math::BigInt, unless upgrading is in effect, the result is truncated to an integer.</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> <dt id="batan2()">
batan2()</dt> <dd> <pre data-language="perl"><code>my $x = Math::BigInt-&gt;new(1);
my $y = Math::BigInt-&gt;new(1);
print $y-&gt;batan2($x), "\n";</code></pre> <p>Calculate the arcus tangens of <code>$y</code> divided by <code>$x</code>, modifying $y in place.</p> <p>In Math::BigInt, unless upgrading is in effect, the result is truncated to an integer.</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> <dt id="bsqrt()">
bsqrt()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bsqrt();                # calculate square root</code></pre> <p><code>bsqrt()</code> returns the square root truncated to an integer.</p> <p>If you want a better approximation of the square root, then use:</p> <pre data-language="perl"><code>$x = Math::BigFloat-&gt;new(12);
Math::BigFloat-&gt;precision(0);
Math::BigFloat-&gt;round_mode('even');
print $x-&gt;copy-&gt;bsqrt(),"\n";           # 4

Math::BigFloat-&gt;precision(2);
print $x-&gt;bsqrt(),"\n";                 # 3.46
print $x-&gt;bsqrt(3),"\n";                # 3.464</code></pre> </dd> <dt id="broot()">
broot()</dt> <dd> <pre data-language="perl"><code>$x-&gt;broot($N);</code></pre> <p>Calculates the N'th root of <code>$x</code>.</p> </dd> <dt id="bfac()">
bfac()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bfac();             # factorial of $x</code></pre> <p>Returns the factorial of <code>$x</code>, i.e., $x*($x-1)*($x-2)*...*2*1, the product of all positive integers up to and including <code>$x</code>. <code>$x</code> must be &gt; -1. The factorial of N is commonly written as N!, or N!1, when using the multifactorial notation.</p> </dd> <dt id="bdfac()">
bdfac()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bdfac();                # double factorial of $x</code></pre> <p>Returns the double factorial of <code>$x</code>, i.e., $x*($x-2)*($x-4)*... <code>$x</code> must be &gt; -2. The double factorial of N is commonly written as N!!, or N!2, when using the multifactorial notation.</p> </dd> <dt id="btfac()">
btfac()</dt> <dd> <pre data-language="perl"><code>$x-&gt;btfac();            # triple factorial of $x</code></pre> <p>Returns the triple factorial of <code>$x</code>, i.e., $x*($x-3)*($x-6)*... <code>$x</code> must be &gt; -3. The triple factorial of N is commonly written as N!!!, or N!3, when using the multifactorial notation.</p> </dd> <dt id="bmfac()">
bmfac()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bmfac($k);          # $k'th multifactorial of $x</code></pre> <p>Returns the multi-factorial of <code>$x</code>, i.e., $x*($x-$k)*($x-2*$k)*... <code>$x</code> must be &gt; -$k. The multi-factorial of N is commonly written as N!K.</p> </dd> <dt id="bfib()">
bfib()</dt> <dd> <pre data-language="perl"><code>$F = $n-&gt;bfib();            # a single Fibonacci number
@F = $n-&gt;bfib();            # a list of Fibonacci numbers</code></pre> <p>In scalar context, returns a single Fibonacci number. In list context, returns a list of Fibonacci numbers. The invocand is the last element in the output.</p> <p>The Fibonacci sequence is defined by</p> <pre data-language="perl"><code class="plaintext">F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2)</code></pre> <p>In list context, F(0) and F(n) is the first and last number in the output, respectively. For example, if $n is 12, then <code>@F = $n-&gt;bfib()</code> returns the following values, F(0) to F(12):</p> <pre data-language="perl"><code class="plaintext">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144</code></pre> <p>The sequence can also be extended to negative index n using the re-arranged recurrence relation</p> <pre data-language="perl"><code class="plaintext">F(n-2) = F(n) - F(n-1)</code></pre> <p>giving the bidirectional sequence</p> <pre data-language="perl"><code class="plaintext">   n  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7
F(n)  13  -8   5  -3   2  -1   1   0   1   1   2   3   5   8  13</code></pre> <p>If $n is -12, the following values, F(0) to F(12), are returned:</p> <pre data-language="perl"><code class="plaintext">0, 1, -1, 2, -3, 5, -8, 13, -21, 34, -55, 89, -144</code></pre> </dd> <dt id="blucas()">
blucas()</dt> <dd> <pre data-language="perl"><code>$F = $n-&gt;blucas();          # a single Lucas number
@F = $n-&gt;blucas();          # a list of Lucas numbers</code></pre> <p>In scalar context, returns a single Lucas number. In list context, returns a list of Lucas numbers. The invocand is the last element in the output.</p> <p>The Lucas sequence is defined by</p> <pre data-language="perl"><code class="plaintext">L(0) = 2
L(1) = 1
L(n) = L(n-1) + L(n-2)</code></pre> <p>In list context, L(0) and L(n) is the first and last number in the output, respectively. For example, if $n is 12, then <code>@L = $n-&gt;blucas()</code> returns the following values, L(0) to L(12):</p> <pre data-language="perl"><code class="plaintext">2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, 322</code></pre> <p>The sequence can also be extended to negative index n using the re-arranged recurrence relation</p> <pre data-language="perl"><code class="plaintext">L(n-2) = L(n) - L(n-1)</code></pre> <p>giving the bidirectional sequence</p> <pre data-language="perl"><code class="plaintext">   n  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7
L(n)  29 -18  11  -7   4  -3   1   2   1   3   4   7  11  18  29</code></pre> <p>If $n is -12, the following values, L(0) to L(-12), are returned:</p> <pre data-language="perl"><code class="plaintext">2, 1, -3, 4, -7, 11, -18, 29, -47, 76, -123, 199, -322</code></pre> </dd> <dt id="brsft()">
brsft()</dt> <dd> <pre data-language="perl"><code>$x-&gt;brsft($n);              # right shift $n places in base 2
$x-&gt;brsft($n, $b);          # right shift $n places in base $b</code></pre> <p>The latter is equivalent to</p> <pre data-language="perl"><code>$x -&gt; bdiv($b -&gt; copy() -&gt; bpow($n))</code></pre> </dd> <dt id="blsft()">
blsft()</dt> <dd> <pre data-language="perl"><code>$x-&gt;blsft($n);              # left shift $n places in base 2
$x-&gt;blsft($n, $b);          # left shift $n places in base $b</code></pre> <p>The latter is equivalent to</p> <pre data-language="perl"><code>$x -&gt; bmul($b -&gt; copy() -&gt; bpow($n))</code></pre> </dd> </dl> <h3 id="Bitwise-methods">
Bitwise methods</h3> <dl> <dt id="band()">
band()</dt> <dd> <pre data-language="perl"><code>$x-&gt;band($y);               # bitwise and</code></pre> </dd> <dt id="bior()">
bior()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bior($y);               # bitwise inclusive or</code></pre> </dd> <dt id="bxor()">
bxor()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bxor($y);               # bitwise exclusive or</code></pre> </dd> <dt id="bnot()">
bnot()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bnot();                 # bitwise not (two's complement)</code></pre> <p>Two's complement (bitwise not). This is equivalent to, but faster than,</p> <pre data-language="perl"><code>$x-&gt;binc()-&gt;bneg();</code></pre> </dd> </dl> <h3 id="Rounding-methods">
Rounding methods</h3> <dl> <dt id="round()">
round()</dt> <dd> <pre data-language="perl"><code>$x-&gt;round($A,$P,$round_mode);</code></pre> <p>Round $x to accuracy <code>$A</code> or precision <code>$P</code> using the round mode <code>$round_mode</code>.</p> </dd> <dt id="bround()">
bround()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bround($N);               # accuracy: preserve $N digits</code></pre> <p>Rounds $x to an accuracy of $N digits.</p> </dd> <dt id="bfround()">
bfround()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bfround($N);</code></pre> <p>Rounds to a multiple of 10**$N. Examples:</p> <pre data-language="perl"><code class="plaintext">Input            N          Result

123456.123456    3          123500
123456.123456    2          123450
123456.123456   -2          123456.12
123456.123456   -3          123456.123</code></pre> </dd> <dt id="bfloor()">
bfloor()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bfloor();</code></pre> <p>Round $x towards minus infinity, i.e., set $x to the largest integer less than or equal to $x.</p> </dd> <dt id="bceil()">
bceil()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bceil();</code></pre> <p>Round $x towards plus infinity, i.e., set $x to the smallest integer greater than or equal to $x).</p> </dd> <dt id="bint()">
bint()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bint();</code></pre> <p>Round $x towards zero.</p> </dd> </dl> <h3 id="Other-mathematical-methods">
Other mathematical methods</h3> <dl> <dt id="bgcd()">
bgcd()</dt> <dd> <pre data-language="perl"><code>$x -&gt; bgcd($y);             # GCD of $x and $y
$x -&gt; bgcd($y, $z, ...);    # GCD of $x, $y, $z, ...</code></pre> <p>Returns the greatest common divisor (GCD).</p> </dd> <dt id="blcm()">
blcm()</dt> <dd> <pre data-language="perl"><code>$x -&gt; blcm($y);             # LCM of $x and $y
$x -&gt; blcm($y, $z, ...);    # LCM of $x, $y, $z, ...</code></pre> <p>Returns the least common multiple (LCM).</p> </dd> </dl> <h3 id="Object-property-methods">
Object property methods</h3> <dl> <dt id="sign()">
sign()</dt> <dd> <pre data-language="perl"><code>$x-&gt;sign();</code></pre> <p>Return the sign, of $x, meaning either <code>+</code>, <code>-</code>, <code>-inf</code>, <code>+inf</code> or NaN.</p> <p>If you want $x to have a certain sign, use one of the following methods:</p> <pre data-language="perl"><code>$x-&gt;babs();                 # '+'
$x-&gt;babs()-&gt;bneg();         # '-'
$x-&gt;bnan();                 # 'NaN'
$x-&gt;binf();                 # '+inf'
$x-&gt;binf('-');              # '-inf'</code></pre> </dd> <dt id="digit()">
digit()</dt> <dd> <pre data-language="perl"><code>$x-&gt;digit($n);       # return the nth digit, counting from right</code></pre> <p>If <code>$n</code> is negative, returns the digit counting from left.</p> </dd> <dt id="digitsum()">
digitsum()</dt> <dd> <pre data-language="perl"><code>$x-&gt;digitsum();</code></pre> <p>Computes the sum of the base 10 digits and returns it.</p> </dd> <dt id="bdigitsum()">
bdigitsum()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bdigitsum();</code></pre> <p>Computes the sum of the base 10 digits and assigns the result to the invocand.</p> </dd> <dt id="length()">
length()</dt> <dd> <pre data-language="perl"><code>$x-&gt;length();
($xl, $fl) = $x-&gt;length();</code></pre> <p>Returns the number of digits in the decimal representation of the number. In list context, returns the length of the integer and fraction part. For Math::BigInt objects, the length of the fraction part is always 0.</p> <p>The following probably doesn't do what you expect:</p> <pre data-language="perl"><code>$c = Math::BigInt-&gt;new(123);
print $c-&gt;length(),"\n";                # prints 30</code></pre> <p>It prints both the number of digits in the number and in the fraction part since print calls <code>length()</code> in list context. Use something like:</p> <pre data-language="perl"><code>print scalar $c-&gt;length(),"\n";         # prints 3</code></pre> </dd> <dt id="mantissa()">
mantissa()</dt> <dd> <pre data-language="perl"><code>$x-&gt;mantissa();</code></pre> <p>Return the signed mantissa of $x as a Math::BigInt.</p> </dd> <dt id="exponent()">
exponent()</dt> <dd> <pre data-language="perl"><code>$x-&gt;exponent();</code></pre> <p>Return the exponent of $x as a Math::BigInt.</p> </dd> <dt id="parts()">
parts()</dt> <dd> <pre data-language="perl"><code>$x-&gt;parts();</code></pre> <p>Returns the significand (mantissa) and the exponent as integers. In Math::BigFloat, both are returned as Math::BigInt objects.</p> </dd> <dt id="sparts()">
sparts()</dt> <dd> <p>Returns the significand (mantissa) and the exponent as integers. In scalar context, only the significand is returned. The significand is the integer with the smallest absolute value. The output of <code>sparts()</code> corresponds to the output from <code>bsstr()</code>.</p> <p>In Math::BigInt, this method is identical to <code>parts()</code>.</p> </dd> <dt id="nparts()">
nparts()</dt> <dd> <p>Returns the significand (mantissa) and exponent corresponding to normalized notation. In scalar context, only the significand is returned. For finite non-zero numbers, the significand's absolute value is greater than or equal to 1 and less than 10. The output of <code>nparts()</code> corresponds to the output from <code>bnstr()</code>. In Math::BigInt, if the significand can not be represented as an integer, upgrading is performed or NaN is returned.</p> </dd> <dt id="eparts()">
eparts()</dt> <dd> <p>Returns the significand (mantissa) and exponent corresponding to engineering notation. In scalar context, only the significand is returned. For finite non-zero numbers, the significand's absolute value is greater than or equal to 1 and less than 1000, and the exponent is a multiple of 3. The output of <code>eparts()</code> corresponds to the output from <code>bestr()</code>. In Math::BigInt, if the significand can not be represented as an integer, upgrading is performed or NaN is returned.</p> </dd> <dt id="dparts()">
dparts()</dt> <dd> <p>Returns the integer part and the fraction part. If the fraction part can not be represented as an integer, upgrading is performed or NaN is returned. The output of <code>dparts()</code> corresponds to the output from <code>bdstr()</code>.</p> </dd> <dt id="fparts()">
fparts()</dt> <dd> <p>Returns the smallest possible numerator and denominator so that the numerator divided by the denominator gives back the original value. For finite numbers, both values are integers. Mnemonic: fraction.</p> </dd> <dt id="numerator()">
numerator()</dt> <dd> <p>Together with <a href="#denominator%28%29">"denominator()"</a>, returns the smallest integers so that the numerator divided by the denominator reproduces the original value. With Math::BigInt, numerator() simply returns a copy of the invocand.</p> </dd> <dt id="denominator()">
denominator()</dt> <dd> <p>Together with <a href="#numerator%28%29">"numerator()"</a>, returns the smallest integers so that the numerator divided by the denominator reproduces the original value. With Math::BigInt, denominator() always returns either a 1 or a NaN.</p> </dd> </dl> <h3 id="String-conversion-methods">
String conversion methods</h3> <dl> <dt id="bstr()">
bstr()</dt> <dd> <p>Returns a string representing the number using decimal notation. In Math::BigFloat, the output is zero padded according to the current accuracy or precision, if any of those are defined.</p> </dd> <dt id="bsstr()">
bsstr()</dt> <dd> <p>Returns a string representing the number using scientific notation where both the significand (mantissa) and the exponent are integers. The output corresponds to the output from <code>sparts()</code>.</p> <pre data-language="perl"><code class="plaintext">  123 is returned as "123e+0"
 1230 is returned as "123e+1"
12300 is returned as "123e+2"
12000 is returned as "12e+3"
10000 is returned as "1e+4"</code></pre> </dd> <dt id="bnstr()">
bnstr()</dt> <dd> <p>Returns a string representing the number using normalized notation, the most common variant of scientific notation. For finite non-zero numbers, the absolute value of the significand is greater than or equal to 1 and less than 10. The output corresponds to the output from <code>nparts()</code>.</p> <pre data-language="perl"><code class="plaintext">  123 is returned as "1.23e+2"
 1230 is returned as "1.23e+3"
12300 is returned as "1.23e+4"
12000 is returned as "1.2e+4"
10000 is returned as "1e+4"</code></pre> </dd> <dt id="bestr()">
bestr()</dt> <dd> <p>Returns a string representing the number using engineering notation. For finite non-zero numbers, the absolute value of the significand is greater than or equal to 1 and less than 1000, and the exponent is a multiple of 3. The output corresponds to the output from <code>eparts()</code>.</p> <pre data-language="perl"><code class="plaintext">  123 is returned as "123e+0"
 1230 is returned as "1.23e+3"
12300 is returned as "12.3e+3"
12000 is returned as "12e+3"
10000 is returned as "10e+3"</code></pre> </dd> <dt id="bdstr()">
bdstr()</dt> <dd> <p>Returns a string representing the number using decimal notation. The output corresponds to the output from <code>dparts()</code>.</p> <pre data-language="perl"><code class="plaintext">  123 is returned as "123"
 1230 is returned as "1230"
12300 is returned as "12300"
12000 is returned as "12000"
10000 is returned as "10000"</code></pre> </dd> <dt id="bfstr()">
bfstr()</dt> <dd> <p>Returns a string representing the number using fractional notation. The output corresponds to the output from <code>fparts()</code>.</p> <pre data-language="perl"><code class="plaintext">    12.345 is returned as "2469/200"
   123.45 is returned as "2469/20"
  1234.5 is returned as "2469/2"
 12345 is returned as "12345"
123450 is returned as "123450"</code></pre> </dd> <dt id="to_hex()">
to_hex()</dt> <dd> <pre data-language="perl"><code>$x-&gt;to_hex();</code></pre> <p>Returns a hexadecimal string representation of the number. See also from_hex().</p> </dd> <dt id="to_bin()">
to_bin()</dt> <dd> <pre data-language="perl"><code>$x-&gt;to_bin();</code></pre> <p>Returns a binary string representation of the number. See also from_bin().</p> </dd> <dt id="to_oct()">
to_oct()</dt> <dd> <pre data-language="perl"><code>$x-&gt;to_oct();</code></pre> <p>Returns an octal string representation of the number. See also from_oct().</p> </dd> <dt id="to_bytes()">
to_bytes()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;new("1667327589");
$s = $x-&gt;to_bytes();                    # $s = "cafe"</code></pre> <p>Returns a byte string representation of the number using big endian byte order. The invocand must be a non-negative, finite integer. See also from_bytes().</p> </dd> <dt id="to_base()">
to_base()</dt> <dd> <pre data-language="perl"><code>$x = Math::BigInt-&gt;new("250");
$x-&gt;to_base(2);     # returns "11111010"
$x-&gt;to_base(8);     # returns "372"
$x-&gt;to_base(16);    # returns "fa"</code></pre> <p>Returns a string representation of the number in the given base. If a collation sequence is given, the collation sequence determines which characters are used in the output.</p> <p>Here are some more examples</p> <pre data-language="perl"><code>$x = Math::BigInt-&gt;new("16")-&gt;to_base(3);       # returns "121"
$x = Math::BigInt-&gt;new("44027")-&gt;to_base(36);   # returns "XYZ"
$x = Math::BigInt-&gt;new("58314")-&gt;to_base(42);   # returns "Why"
$x = Math::BigInt-&gt;new("4")-&gt;to_base(2, "-|");  # returns "|--"</code></pre> <p>See from_base() for information and examples.</p> </dd> <dt id="to_base_num()">
to_base_num()</dt> <dd> <p>Converts the given number to the given base. This method is equivalent to <code>_to_base()</code>, but returns numbers in an array rather than characters in a string. In the output, the first element is the most significant. Unlike <code>_to_base()</code>, all input values may be arbitrarily large.</p> <pre data-language="perl"><code>$x = Math::BigInt-&gt;new(13);
$x-&gt;to_base_num(2);                         # returns [1, 1, 0, 1]

$x = Math::BigInt-&gt;new(65191);
$x-&gt;to_base_num(128);                       # returns [3, 125, 39]</code></pre> </dd> <dt id="as_hex()">
as_hex()</dt> <dd> <pre data-language="perl"><code>$x-&gt;as_hex();</code></pre> <p>As, <code>to_hex()</code>, but with a "0x" prefix.</p> </dd> <dt id="as_bin()">
as_bin()</dt> <dd> <pre data-language="perl"><code>$x-&gt;as_bin();</code></pre> <p>As, <code>to_bin()</code>, but with a "0b" prefix.</p> </dd> <dt id="as_oct()">
as_oct()</dt> <dd> <pre data-language="perl"><code>$x-&gt;as_oct();</code></pre> <p>As, <code>to_oct()</code>, but with a "0" prefix.</p> </dd> <dt id="as_bytes()">
as_bytes()</dt> <dd> <p>This is just an alias for <code>to_bytes()</code>.</p> </dd> </dl> <h3 id="Other-conversion-methods">
Other conversion methods</h3> <dl> <dt id="numify()">
numify()</dt> <dd> <pre data-language="perl"><code>print $x-&gt;numify();</code></pre> <p>Returns a Perl scalar from $x. It is used automatically whenever a scalar is needed, for instance in array index operations.</p> </dd> </dl> <h3 id="Utility-methods">
Utility methods</h3> <p>These utility methods are made public</p> <dl> <dt id="dec_str_to_dec_flt_str()">
dec_str_to_dec_flt_str()</dt> <dd> <p>Takes a string representing any valid number using decimal notation and converts it to a string representing the same number using decimal floating point notation. The output consists of five parts joined together: the sign of the significand, the absolute value of the significand as the smallest possible integer, the letter "e", the sign of the exponent, and the absolute value of the exponent. If the input is invalid, nothing is returned.</p> <pre data-language="perl"><code>$str2 = $class -&gt; dec_str_to_dec_flt_str($str1);</code></pre> <p>Some examples</p> <pre data-language="perl"><code class="plaintext">Input           Output
31400.00e-4     +314e-2
-0.00012300e8   -123e+2
0               +0e+0</code></pre> </dd> <dt id="hex_str_to_dec_flt_str()">
hex_str_to_dec_flt_str()</dt> <dd> <p>Takes a string representing any valid number using hexadecimal notation and converts it to a string representing the same number using decimal floating point notation. The output has the same format as that of <a href="#dec_str_to_dec_flt_str%28%29">"dec_str_to_dec_flt_str()"</a>.</p> <pre data-language="perl"><code>$str2 = $class -&gt; hex_str_to_dec_flt_str($str1);</code></pre> <p>Some examples</p> <pre data-language="perl"><code class="plaintext">Input           Output
0xff            +255e+0</code></pre> <p>Some examples</p> </dd> <dt id="oct_str_to_dec_flt_str()">
oct_str_to_dec_flt_str()</dt> <dd> <p>Takes a string representing any valid number using octal notation and converts it to a string representing the same number using decimal floating point notation. The output has the same format as that of <a href="#dec_str_to_dec_flt_str%28%29">"dec_str_to_dec_flt_str()"</a>.</p> <pre data-language="perl"><code>$str2 = $class -&gt; oct_str_to_dec_flt_str($str1);</code></pre> </dd> <dt id="bin_str_to_dec_flt_str()">
bin_str_to_dec_flt_str()</dt> <dd> <p>Takes a string representing any valid number using binary notation and converts it to a string representing the same number using decimal floating point notation. The output has the same format as that of <a href="#dec_str_to_dec_flt_str%28%29">"dec_str_to_dec_flt_str()"</a>.</p> <pre data-language="perl"><code>$str2 = $class -&gt; bin_str_to_dec_flt_str($str1);</code></pre> </dd> <dt id="dec_str_to_dec_str()">
dec_str_to_dec_str()</dt> <dd> <p>Takes a string representing any valid number using decimal notation and converts it to a string representing the same number using decimal notation. If the number represents an integer, the output consists of a sign and the absolute value. If the number represents a non-integer, the output consists of a sign, the integer part of the number, the decimal point ".", and the fraction part of the number without any trailing zeros. If the input is invalid, nothing is returned.</p> </dd> <dt id="hex_str_to_dec_str()">
hex_str_to_dec_str()</dt> <dd> <p>Takes a string representing any valid number using hexadecimal notation and converts it to a string representing the same number using decimal notation. The output has the same format as that of <a href="#dec_str_to_dec_str%28%29">"dec_str_to_dec_str()"</a>.</p> </dd> <dt id="oct_str_to_dec_str()">
oct_str_to_dec_str()</dt> <dd> <p>Takes a string representing any valid number using octal notation and converts it to a string representing the same number using decimal notation. The output has the same format as that of <a href="#dec_str_to_dec_str%28%29">"dec_str_to_dec_str()"</a>.</p> </dd> <dt id="bin_str_to_dec_str()">
bin_str_to_dec_str()</dt> <dd> <p>Takes a string representing any valid number using binary notation and converts it to a string representing the same number using decimal notation. The output has the same format as that of <a href="#dec_str_to_dec_str%28%29">"dec_str_to_dec_str()"</a>.</p> </dd> </dl> <h2 id="ACCURACY-and-PRECISION">
ACCURACY and PRECISION</h2> <p>Math::BigInt and Math::BigFloat have full support for accuracy and precision based rounding, both automatically after every operation, as well as manually.</p> <p>This section describes the accuracy/precision handling in Math::BigInt and Math::BigFloat as it used to be and as it is now, complete with an explanation of all terms and abbreviations.</p> <p>Not yet implemented things (but with correct description) are marked with '!', things that need to be answered are marked with '?'.</p> <p>In the next paragraph follows a short description of terms used here (because these may differ from terms used by others people or documentation).</p> <p>During the rest of this document, the shortcuts A (for accuracy), P (for precision), F (fallback) and R (rounding mode) are be used.</p> <h3 id="Precision-P">
Precision P</h3> <p>Precision is a fixed number of digits before (positive) or after (negative) the decimal point. For example, 123.45 has a precision of -2. 0 means an integer like 123 (or 120). A precision of 2 means at least two digits to the left of the decimal point are zero, so 123 with P = 1 becomes 120. Note that numbers with zeros before the decimal point may have different precisions, because 1200 can have P = 0, 1 or 2 (depending on what the initial value was). It could also have p &lt; 0, when the digits after the decimal point are zero.</p> <p>The string output (of floating point numbers) is padded with zeros:</p> <pre data-language="perl"><code class="plaintext">Initial value    P      A       Result          String
------------------------------------------------------------
1234.01         -3              1000            1000
1234            -2              1200            1200
1234.5          -1              1230            1230
1234.001         1              1234            1234.0
1234.01          0              1234            1234
1234.01          2              1234.01         1234.01
1234.01          5              1234.01         1234.01000</code></pre> <p>For Math::BigInt objects, no padding occurs.</p> <h3 id="Accuracy-A">
Accuracy A</h3> <p>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.45000 has 8 and 0.000123 has 3.</p> <p>The string output (of floating point numbers) is padded with zeros:</p> <pre data-language="perl"><code class="plaintext">Initial value    P      A       Result          String
------------------------------------------------------------
1234.01                 3       1230            1230
1234.01                 6       1234.01         1234.01
1234.1                  8       1234.1          1234.1000</code></pre> <p>For Math::BigInt objects, no padding occurs.</p> <h3 id="Fallback-F">
Fallback F</h3> <p>When both A and P are undefined, this is used as a fallback accuracy when dividing numbers.</p> <h3 id="Rounding-mode-R">
Rounding mode R</h3> <p>When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)</p> <h4 id="Directed-rounding">
Directed rounding</h4> <p>These round modes always round in the same direction.</p> <dl> <dt id="'trunc'">
'trunc'</dt> <dd> <p>Round towards zero. Remove all digits following the rounding place, i.e., replace them with zeros. Thus, 987.65 rounded to tens (P=1) becomes 980, and rounded to the fourth significant digit becomes 987.6 (A=4). 123.456 rounded to the second place after the decimal point (P=-2) becomes 123.46. This corresponds to the IEEE 754 rounding mode 'roundTowardZero'.</p> </dd> </dl> <h4 id="Rounding-to-nearest">
Rounding to nearest</h4> <p>These rounding modes round to the nearest digit. They differ in how they determine which way to round in the ambiguous case when there is a tie.</p> <dl> <dt id="'even'">
'even'</dt> <dd> <p>Round towards the nearest even digit, e.g., when rounding to nearest integer, -5.5 becomes -6, 4.5 becomes 4, but 4.501 becomes 5. This corresponds to the IEEE 754 rounding mode 'roundTiesToEven'.</p> </dd> <dt id="'odd'">
'odd'</dt> <dd> <p>Round towards the nearest odd digit, e.g., when rounding to nearest integer, 4.5 becomes 5, -5.5 becomes -5, but 5.501 becomes 6. This corresponds to the IEEE 754 rounding mode 'roundTiesToOdd'.</p> </dd> <dt id="'+inf'">
'+inf'</dt> <dd> <p>Round towards plus infinity, i.e., always round up. E.g., when rounding to the nearest integer, 4.5 becomes 5, -5.5 becomes -5, and 4.501 also becomes 5. This corresponds to the IEEE 754 rounding mode 'roundTiesToPositive'.</p> </dd> <dt id="'-inf'">
'-inf'</dt> <dd> <p>Round towards minus infinity, i.e., always round down. E.g., when rounding to the nearest integer, 4.5 becomes 4, -5.5 becomes -6, but 4.501 becomes 5. This corresponds to the IEEE 754 rounding mode 'roundTiesToNegative'.</p> </dd> <dt id="'zero'">
'zero'</dt> <dd> <p>Round towards zero, i.e., round positive numbers down and negative numbers up. E.g., when rounding to the nearest integer, 4.5 becomes 4, -5.5 becomes -5, but 4.501 becomes 5. This corresponds to the IEEE 754 rounding mode 'roundTiesToZero'.</p> </dd> <dt id="'common'">
'common'</dt> <dd> <p>Round away from zero, i.e., round to the number with the largest absolute value. E.g., when rounding to the nearest integer, -1.5 becomes -2, 1.5 becomes 2 and 1.49 becomes 1. This corresponds to the IEEE 754 rounding mode 'roundTiesToAway'.</p> </dd> </dl> <p>The handling of A &amp; P in MBI/MBF (the old core code shipped with Perl versions &lt;= 5.7.2) is like this:</p> <dl> <dt id="Precision">Precision</dt> <dd> <pre data-language="perl"><code>* bfround($p) is able to round to $p number of digits after the decimal
  point
* otherwise P is unused</code></pre> </dd> <dt id="Accuracy-(significant-digits)">
Accuracy (significant digits)</dt> <dd> <pre data-language="perl"><code> * bround($a) rounds to $a significant digits
 * only bdiv() and bsqrt() take A as (optional) parameter
   + other operations simply create the same number (bneg etc), or
     more (bmul) of digits
   + rounding/truncating is only done when explicitly calling one
     of bround or bfround, and never for Math::BigInt (not implemented)
 * bsqrt() simply hands its accuracy argument over to bdiv.
 * the documentation and the comment in the code indicate two
   different ways on how bdiv() determines the maximum number
   of digits it should calculate, and the actual code does yet
   another thing
   POD:
     max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
   Comment:
     result has at most max(scale, length(dividend), length(divisor)) digits
   Actual code:
     scale = max(scale, length(dividend)-1,length(divisor)-1);
     scale += length(divisor) - length(dividend);
   So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10
   So for lx = 3, ly = 9, scale = 10, scale will actually be 16
   (10+9-3). Actually, the 'difference' added to the scale is cal-
   culated from the number of "significant digits" in dividend and
   divisor, which is derived by looking at the length of the man-
   tissa. Which is wrong, since it includes the + sign (oops) and
   actually gets 2 for '+100' and 4 for '+101'. Oops again. Thus
   124/3 with div_scale=1 will get you '41.3' based on the strange
   assumption that 124 has 3 significant digits, while 120/7 will
   get you '17', not '17.1' since 120 is thought to have 2 signif-
   icant digits. The rounding after the division then uses the
   remainder and $y to determine whether it must round up or down.
?  I have no idea which is the right way. That's why I used a slightly more
?  simple scheme and tweaked the few failing testcases to match it.</code></pre> </dd> </dl> <p>This is how it works now:</p> <dl> <dt id="Setting/Accessing">
Setting/Accessing</dt> <dd> <pre data-language="perl"><code>* You can set the A global via Math::BigInt-&gt;accuracy() or
  Math::BigFloat-&gt;accuracy() or whatever class you are using.
* You can also set P globally by using Math::SomeClass-&gt;precision()
  likewise.
* Globals are classwide, and not inherited by subclasses.
* to undefine A, use Math::SomeClass-&gt;accuracy(undef);
* to undefine P, use Math::SomeClass-&gt;precision(undef);
* Setting Math::SomeClass-&gt;accuracy() clears automatically
  Math::SomeClass-&gt;precision(), and vice versa.
* To be valid, A must be &gt; 0, P can have any value.
* If P is negative, this means round to the P'th place to the right of the
  decimal point; positive values mean to the left of the decimal point.
  P of 0 means round to integer.
* to find out the current global A, use Math::SomeClass-&gt;accuracy()
* to find out the current global P, use Math::SomeClass-&gt;precision()
* use $x-&gt;accuracy() respective $x-&gt;precision() for the local
  setting of $x.
* Please note that $x-&gt;accuracy() respective $x-&gt;precision()
  return eventually defined global A or P, when $x's A or P is not
  set.</code></pre> </dd> <dt id="Creating-numbers">
Creating numbers</dt> <dd> <pre data-language="perl"><code>* When you create a number, you can give the desired A or P via:
  $x = Math::BigInt-&gt;new($number,$A,$P);
* Only one of A or P can be defined, otherwise the result is NaN
* If no A or P is give ($x = Math::BigInt-&gt;new($number) form), then the
  globals (if set) will be used. Thus changing the global defaults later on
  will not change the A or P of previously created numbers (i.e., A and P of
  $x will be what was in effect when $x was created)
* If given undef for A and P, NO rounding will occur, and the globals will
  NOT be used. This is used by subclasses to create numbers without
  suffering rounding in the parent. Thus a subclass is able to have its own
  globals enforced upon creation of a number by using
  $x = Math::BigInt-&gt;new($number,undef,undef):

      use Math::BigInt::SomeSubclass;
      use Math::BigInt;

      Math::BigInt-&gt;accuracy(2);
      Math::BigInt::SomeSubclass-&gt;accuracy(3);
      $x = Math::BigInt::SomeSubclass-&gt;new(1234);

  $x is now 1230, and not 1200. A subclass might choose to implement
  this otherwise, e.g. falling back to the parent's A and P.</code></pre> </dd> <dt id="Usage">Usage</dt> <dd> <pre data-language="perl"><code class="plaintext">* If A or P are enabled/defined, they are used to round the result of each
  operation according to the rules below
* Negative P is ignored in Math::BigInt, since Math::BigInt objects never
  have digits after the decimal point
* Math::BigFloat uses Math::BigInt internally, but setting A or P inside
  Math::BigInt as globals does not tamper with the parts of a Math::BigFloat.
  A flag is used to mark all Math::BigFloat numbers as 'never round'.</code></pre> </dd> <dt id="Precedence">Precedence</dt> <dd> <pre data-language="perl"><code> * It only makes sense that a number has only one of A or P at a time.
   If you set either A or P on one object, or globally, the other one will
   be automatically cleared.
 * If two objects are involved in an operation, and one of them has A in
   effect, and the other P, this results in an error (NaN).
 * A takes precedence over P (Hint: A comes before P).
   If neither of them is defined, nothing is used, i.e. the result will have
   as many digits as it can (with an exception for bdiv/bsqrt) and will not
   be rounded.
 * There is another setting for bdiv() (and thus for bsqrt()). If neither of
   A or P is defined, bdiv() will use a fallback (F) of $div_scale digits.
   If either the dividend's or the divisor's mantissa has more digits than
   the value of F, the higher value will be used instead of F.
   This is to limit the digits (A) of the result (just consider what would
   happen with unlimited A and P in the case of 1/3 :-)
 * bdiv will calculate (at least) 4 more digits than required (determined by
   A, P or F), and, if F is not used, round the result
   (this will still fail in the case of a result like 0.12345000000001 with A
   or P of 5, but this can not be helped - or can it?)
 * Thus you can have the math done by on Math::Big* class in two modi:
   + never round (this is the default):
     This is done by setting A and P to undef. No math operation
     will round the result, with bdiv() and bsqrt() as exceptions to guard
     against overflows. You must explicitly call bround(), bfround() or
     round() (the latter with parameters).
     Note: Once you have rounded a number, the settings will 'stick' on it
     and 'infect' all other numbers engaged in math operations with it, since
     local settings have the highest precedence. So, to get SaferRound[tm],
     use a copy() before rounding like this:

       $x = Math::BigFloat-&gt;new(12.34);
       $y = Math::BigFloat-&gt;new(98.76);
       $z = $x * $y;                           # 1218.6984
       print $x-&gt;copy()-&gt;bround(3);            # 12.3 (but A is now 3!)
       $z = $x * $y;                           # still 1218.6984, without
                                               # copy would have been 1210!

   + round after each op:
     After each single operation (except for testing like is_zero()), the
     method round() is called and the result is rounded appropriately. By
     setting proper values for A and P, you can have all-the-same-A or
     all-the-same-P modes. For example, Math::Currency might set A to undef,
     and P to -2, globally.

?Maybe an extra option that forbids local A &amp; P settings would be in order,
?so that intermediate rounding does not 'poison' further math?</code></pre> </dd> <dt id="Overriding-globals">
Overriding globals</dt> <dd> <pre data-language="perl"><code class="plaintext">* you will be able to give A, P and R as an argument to all the calculation
  routines; the second parameter is A, the third one is P, and the fourth is
  R (shift right by one for binary operations like badd). P is used only if
  the first parameter (A) is undefined. These three parameters override the
  globals in the order detailed as follows, i.e. the first defined value
  wins:
  (local: per object, global: global default, parameter: argument to sub)
    + parameter A
    + parameter P
    + local A (if defined on both of the operands: smaller one is taken)
    + local P (if defined on both of the operands: bigger one is taken)
    + global A
    + global P
    + global F
* bsqrt() will hand its arguments to bdiv(), as it used to, only now for two
  arguments (A and P) instead of one</code></pre> </dd> <dt id="Local-settings">
Local settings</dt> <dd> <pre data-language="perl"><code>* You can set A or P locally by using $x-&gt;accuracy() or
  $x-&gt;precision()
  and thus force different A and P for different objects/numbers.
* Setting A or P this way immediately rounds $x to the new value.
* $x-&gt;accuracy() clears $x-&gt;precision(), and vice versa.</code></pre> </dd> <dt id="Rounding">Rounding</dt> <dd> <pre data-language="perl"><code>* the rounding routines will use the respective global or local settings.
  bround() is for accuracy rounding, while bfround() is for precision
* the two rounding functions take as the second parameter one of the
  following rounding modes (R):
  'even', 'odd', '+inf', '-inf', 'zero', 'trunc', 'common'
* you can set/get the global R by using Math::SomeClass-&gt;round_mode()
  or by setting $Math::SomeClass::round_mode
* after each operation, $result-&gt;round() is called, and the result may
  eventually be rounded (that is, if A or P were set either locally,
  globally or as parameter to the operation)
* to manually round a number, call $x-&gt;round($A,$P,$round_mode);
  this will round the number by using the appropriate rounding function
  and then normalize it.
* rounding modifies the local settings of the number:

      $x = Math::BigFloat-&gt;new(123.456);
      $x-&gt;accuracy(5);
      $x-&gt;bround(4);

  Here 4 takes precedence over 5, so 123.5 is the result and $x-&gt;accuracy()
  will be 4 from now on.</code></pre> </dd> <dt id="Default-values">
Default values</dt> <dd> <pre data-language="perl"><code class="plaintext">* R: 'even'
* F: 40
* A: undef
* P: undef</code></pre> </dd> <dt id="Remarks">Remarks</dt> <dd> <pre data-language="perl"><code class="plaintext">* The defaults are set up so that the new code gives the same results as
  the old code (except in a few cases on bdiv):
  + Both A and P are undefined and thus will not be used for rounding
    after each operation.
  + round() is thus a no-op, unless given extra parameters A and P</code></pre> </dd> </dl> <h2 id="Infinity-and-Not-a-Number">
Infinity and Not a Number</h2> <p>While Math::BigInt has extensive handling of inf and NaN, certain quirks remain.</p> <dl> <dt id="oct()/hex()">
oct()/hex()</dt> <dd> <p>These perl routines currently (as of Perl v.5.8.6) cannot handle passed inf.</p> <pre data-language="perl"><code>te@linux:~&gt; perl -wle 'print 2 ** 3333'
Inf
te@linux:~&gt; perl -wle 'print 2 ** 3333 == 2 ** 3333'
1
te@linux:~&gt; perl -wle 'print oct(2 ** 3333)'
0
te@linux:~&gt; perl -wle 'print hex(2 ** 3333)'
Illegal hexadecimal digit 'I' ignored at -e line 1.
0</code></pre> <p>The same problems occur if you pass them Math::BigInt-&gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from Math::BigInt.</p> </dd> </dl> <h2 id="INTERNALS">INTERNALS</h2> <p>You should neither care about nor depend on the internal representation; it might change without notice. Use <b>ONLY</b> method calls like <code>$x-&gt;sign();</code> instead relying on the internal representation.</p> <h3 id="MATH-LIBRARY">
MATH LIBRARY</h3> <p>The mathematical computations are performed by a backend library. It is not required to specify which backend library to use, but some backend libraries are much faster than the default library.</p> <h4 id="The-default-library">
The default library</h4> <p>The default library is <a href="Math::BigInt::Calc.html">Math::BigInt::Calc</a>, which is implemented in pure Perl and hence does not require a compiler.</p> <h4 id="Specifying-a-library">
Specifying a library</h4> <p>The simple case</p> <pre data-language="perl"><code>use Math::BigInt;</code></pre> <p>is equivalent to saying</p> <pre data-language="perl"><code>use Math::BigInt try =&gt; 'Calc';</code></pre> <p>You can use a different backend library with, e.g.,</p> <pre data-language="perl"><code>use Math::BigInt try =&gt; 'GMP';</code></pre> <p>which attempts to load the <a href="Math::BigInt::GMP.html">Math::BigInt::GMP</a> library, and falls back to the default library if the specified library can't be loaded.</p> <p>Multiple libraries can be specified by separating them by a comma, e.g.,</p> <pre data-language="perl"><code>use Math::BigInt try =&gt; 'GMP,Pari';</code></pre> <p>If you request a specific set of libraries and do not allow fallback to the default library, specify them using "only",</p> <pre data-language="perl"><code>use Math::BigInt only =&gt; 'GMP,Pari';</code></pre> <p>If you prefer a specific set of libraries, but want to see a warning if the fallback library is used, specify them using "lib",</p> <pre data-language="perl"><code>use Math::BigInt lib =&gt; 'GMP,Pari';</code></pre> <p>The following first tries to find Math::BigInt::Foo, then Math::BigInt::Bar, and if this also fails, reverts to Math::BigInt::Calc:</p> <pre data-language="perl"><code>use Math::BigInt try =&gt; 'Foo,Math::BigInt::Bar';</code></pre> <h4 id="Which-library-to-use?">
Which library to use?</h4> <p><b>Note</b>: General purpose packages should not be explicit about the library to use; let the script author decide which is best.</p> <p><a href="Math::BigInt::GMP.html">Math::BigInt::GMP</a>, <a href="Math::BigInt::Pari.html">Math::BigInt::Pari</a>, and <a href="Math::BigInt::GMPz.html">Math::BigInt::GMPz</a> are in cases involving big numbers much faster than <a href="Math::BigInt::Calc.html">Math::BigInt::Calc</a>. However these libraries are slower when dealing with very small numbers (less than about 20 digits) and when converting very large numbers to decimal (for instance for printing, rounding, calculating their length in decimal etc.).</p> <p>So please select carefully what library you want to use.</p> <p>Different low-level libraries use different formats to store the numbers, so mixing them won't work. You should not depend on the number having a specific internal format.</p> <p>See the respective math library module documentation for further details.</p> <h4 id="Loading-multiple-libraries">
Loading multiple libraries</h4> <p>The first library that is successfully loaded is the one that will be used. Any further attempts at loading a different module will be ignored. This is to avoid the situation where module A requires math library X, and module B requires math library Y, causing modules A and B to be incompatible. For example,</p> <pre data-language="perl"><code>use Math::BigInt;                   # loads default "Calc"
use Math::BigFloat only =&gt; "GMP";   # ignores "GMP"</code></pre> <h3 id="SIGN">SIGN</h3> <p>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</p> <p>A sign of 'NaN' is used to represent the result when input arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively minus infinity. You get '+inf' when dividing a positive number by 0, and '-inf' when dividing any negative number by 0.</p> <h2 id="EXAMPLES">EXAMPLES</h2> <pre data-language="perl"><code>use Math::BigInt;

sub bigint { Math::BigInt-&gt;new(shift); }

$x = Math::BigInt-&gt;bstr("1234")       # string "1234"
$x = "$x";                            # same as bstr()
$x = Math::BigInt-&gt;bneg("1234");      # Math::BigInt "-1234"
$x = Math::BigInt-&gt;babs("-12345");    # Math::BigInt "12345"
$x = Math::BigInt-&gt;bnorm("-0.00");    # Math::BigInt "0"
$x = bigint(1) + bigint(2);           # Math::BigInt "3"
$x = bigint(1) + "2";                 # ditto ("2" becomes a Math::BigInt)
$x = bigint(1);                       # Math::BigInt "1"
$x = $x + 5 / 2;                      # Math::BigInt "3"
$x = $x ** 3;                         # Math::BigInt "27"
$x *= 2;                              # Math::BigInt "54"
$x = Math::BigInt-&gt;new(0);            # Math::BigInt "0"
$x--;                                 # Math::BigInt "-1"
$x = Math::BigInt-&gt;badd(4,5)          # Math::BigInt "9"
print $x-&gt;bsstr();                    # 9e+0</code></pre> <p>Examples for rounding:</p> <pre data-language="perl"><code>use Math::BigFloat;
use Test::More;

$x = Math::BigFloat-&gt;new(123.4567);
$y = Math::BigFloat-&gt;new(123.456789);
Math::BigFloat-&gt;accuracy(4);          # no more A than 4

is ($x-&gt;copy()-&gt;bround(),123.4);      # even rounding
print $x-&gt;copy()-&gt;bround(),"\n";      # 123.4
Math::BigFloat-&gt;round_mode('odd');    # round to odd
print $x-&gt;copy()-&gt;bround(),"\n";      # 123.5
Math::BigFloat-&gt;accuracy(5);          # no more A than 5
Math::BigFloat-&gt;round_mode('odd');    # round to odd
print $x-&gt;copy()-&gt;bround(),"\n";      # 123.46
$y = $x-&gt;copy()-&gt;bround(4),"\n";      # A = 4: 123.4
print "$y, ",$y-&gt;accuracy(),"\n";     # 123.4, 4

Math::BigFloat-&gt;accuracy(undef);      # A not important now
Math::BigFloat-&gt;precision(2);         # P important
print $x-&gt;copy()-&gt;bnorm(),"\n";       # 123.46
print $x-&gt;copy()-&gt;bround(),"\n";      # 123.46</code></pre> <p>Examples for converting:</p> <pre data-language="perl"><code>my $x = Math::BigInt-&gt;new('0b1'.'01' x 123);
print "bin: ",$x-&gt;as_bin()," hex:",$x-&gt;as_hex()," dec: ",$x,"\n";</code></pre> <h2 id="NUMERIC-LITERALS">
NUMERIC LITERALS</h2> <p>After <code>use Math::BigInt ':constant'</code> all numeric literals in the given scope are converted to <code>Math::BigInt</code> objects. This conversion happens at compile time. Every non-integer is convert to a NaN.</p> <p>For example,</p> <pre data-language="perl"><code class="plaintext">perl -MMath::BigInt=:constant -le 'print 2**150'</code></pre> <p>prints the exact value of <code>2**150</code>. Note that without conversion of constants to objects the expression <code>2**150</code> is calculated using Perl scalars, which leads to an inaccurate result.</p> <p>Please note that strings are not affected, so that</p> <pre data-language="perl"><code>use Math::BigInt qw/:constant/;

$x = "1234567890123456789012345678901234567890"
        + "123456789123456789";</code></pre> <p>does give you what you expect. You need an explicit Math::BigInt-&gt;new() around at least one of the operands. You should also quote large constants to prevent loss of precision:</p> <pre data-language="perl"><code>use Math::BigInt;

$x = Math::BigInt-&gt;new("1234567889123456789123456789123456789");</code></pre> <p>Without the quotes Perl first converts the large number to a floating point constant at compile time, and then converts the result to a Math::BigInt object at run time, which results in an inaccurate result.</p> <h3 id="Hexadecimal,-octal,-and-binary-floating-point-literals">
Hexadecimal, octal, and binary floating point literals</h3> <p>Perl (and this module) accepts hexadecimal, octal, and binary floating point literals, but use them with care with Perl versions before v5.32.0, because some versions of Perl silently give the wrong result. Below are some examples of different ways to write the number decimal 314.</p> <p>Hexadecimal floating point literals:</p> <pre data-language="perl"><code class="plaintext">0x1.3ap+8         0X1.3AP+8
0x1.3ap8          0X1.3AP8
0x13a0p-4         0X13A0P-4</code></pre> <p>Octal floating point literals (with "0" prefix):</p> <pre data-language="perl"><code class="plaintext">01.164p+8         01.164P+8
01.164p8          01.164P8
011640p-4         011640P-4</code></pre> <p>Octal floating point literals (with "0o" prefix) (requires v5.34.0):</p> <pre data-language="perl"><code class="plaintext">0o1.164p+8        0O1.164P+8
0o1.164p8         0O1.164P8
0o11640p-4        0O11640P-4</code></pre> <p>Binary floating point literals:</p> <pre data-language="perl"><code class="plaintext">0b1.0011101p+8    0B1.0011101P+8
0b1.0011101p8     0B1.0011101P8
0b10011101000p-2  0B10011101000P-2</code></pre> <h2 id="PERFORMANCE">PERFORMANCE</h2> <p>Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x must be made in the second case. For long numbers, the copy can eat up to 20% of the work (in the case of addition/subtraction, less for multiplication/division). If $y is very small compared to $x, the form $x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes more time then the actual addition.</p> <p>With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.</p> <p>The rewritten version of this module (vs. v0.01) is slower on certain operations, like <code>new()</code>, <code>bstr()</code> and <code>numify()</code>. The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</p> <p>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like <code>bneg()</code>, <code>babs()</code> etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</p> <p>If you find the Calc module to slow, try to install any of the replacement modules and see if they help you.</p> <h3 id="Alternative-math-libraries">
Alternative math libraries</h3> <p>You can use an alternative library to drive Math::BigInt. See the section <a href="#MATH-LIBRARY">"MATH LIBRARY"</a> for more information.</p> <p>For more benchmark results see <a href="http://bloodgate.com/perl/benchmarks.html">http://bloodgate.com/perl/benchmarks.html</a>.</p> <h2 id="SUBCLASSING">SUBCLASSING</h2> <h3 id="Subclassing-Math::BigInt">
Subclassing Math::BigInt</h3> <p>The basic design of Math::BigInt allows simple subclasses with very little work, as long as a few simple rules are followed:</p> <ul> <li>
<p>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</p> </li> <li>
<p>The private object hash keys like <code>$x-&gt;{sign}</code> may not be changed, but additional keys can be added, like <code>$x-&gt;{_custom}</code>.</p> </li> <li>
<p>Accessor functions are available for all existing object hash keys and should be used instead of directly accessing the internal hash keys. The reason for this is that Math::BigInt itself has a pluggable interface which permits it to support different storage methods.</p> </li> </ul> <p>More complex sub-classes may have to replicate more of the logic internal of Math::BigInt if they need to change more basic behaviors. A subclass that needs to merely change the output only needs to overload <code>bstr()</code>.</p> <p>All other object methods and overloaded functions can be directly inherited from the parent class.</p> <p>At the very minimum, any subclass needs to provide its own <code>new()</code> and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</p> <pre data-language="perl"><code># Globals
$accuracy = undef;
$precision = -2;       # round to 2 decimal places
$round_mode = 'even';
$div_scale = 40;</code></pre> <p>Additionally, you might want to provide the following two globals to allow auto-upgrading and auto-downgrading to work correctly:</p> <pre data-language="perl"><code>$upgrade = undef;
$downgrade = undef;</code></pre> <p>This allows Math::BigInt to correctly retrieve package globals from the subclass, like <code>$SubClass::precision</code>. See t/Math/BigInt/Subclass.pm or t/Math/BigFloat/SubClass.pm completely functional subclass examples.</p> <p>Don't forget to</p> <pre data-language="perl"><code>use overload;</code></pre> <p>in your subclass to automatically inherit the overloading from the parent. If you like, you can change part of the overloading, look at Math::String for an example.</p> <h2 id="UPGRADING">UPGRADING</h2> <p>When used like this:</p> <pre data-language="perl"><code>use Math::BigInt upgrade =&gt; 'Foo::Bar';</code></pre> <p>certain operations 'upgrade' their calculation and thus the result to the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:</p> <pre data-language="perl"><code>use Math::BigInt upgrade =&gt; 'Math::BigFloat';</code></pre> <p>As a shortcut, you can use the module <a href="bignum.html">bignum</a>:</p> <pre data-language="perl"><code>use bignum;</code></pre> <p>Also good for one-liners:</p> <pre data-language="perl"><code class="plaintext">perl -Mbignum -le 'print 2 ** 255'</code></pre> <p>This makes it possible to mix arguments of different classes (as in 2.5 + 2) as well es preserve accuracy (as in sqrt(3)).</p> <p>Beware: This feature is not fully implemented yet.</p> <h3 id="Auto-upgrade">
Auto-upgrade</h3> <p>The following methods upgrade themselves unconditionally; that is if upgrade is in effect, they always hands up their work:</p> <pre data-language="perl"><code class="plaintext">div bsqrt blog bexp bpi bsin bcos batan batan2</code></pre> <p>All other methods upgrade themselves only when one (or all) of their arguments are of the class mentioned in $upgrade.</p> <h2 id="EXPORTS">EXPORTS</h2> <p><code>Math::BigInt</code> exports nothing by default, but can export the following methods:</p> <pre data-language="perl"><code class="plaintext">bgcd
blcm</code></pre> <h2 id="CAVEATS">CAVEATS</h2> <p>Some things might not work as you expect them. Below is documented what is known to be troublesome:</p> <dl> <dt id="Comparing-numbers-as-strings">
Comparing numbers as strings</dt> <dd> <p>Both <code>bstr()</code> and <code>bsstr()</code> as well as stringify via overload drop the leading '+'. This is to be consistent with Perl and to make <code>cmp</code> (especially with overloading) to work as you expect. It also solves problems with <code>Test.pm</code> and <a href="Test::More.html">Test::More</a>, which stringify arguments before comparing them.</p> <p>Mark Biggar said, when asked about to drop the '+' altogether, or make only <code>cmp</code> work:</p> <pre data-language="perl"><code class="plaintext">I agree (with the first alternative), don't add the '+' on positive
numbers.  It's not as important anymore with the new internal form
for numbers.  It made doing things like abs and neg easier, but
those have to be done differently now anyway.</code></pre> <p>So, the following examples now works as expected:</p> <pre data-language="perl"><code>use Test::More tests =&gt; 1;
use Math::BigInt;

my $x = Math::BigInt -&gt; new(3*3);
my $y = Math::BigInt -&gt; new(3*3);

is($x,3*3, 'multiplication');
print "$x eq 9" if $x eq $y;
print "$x eq 9" if $x eq '9';
print "$x eq 9" if $x eq 3*3;</code></pre> <p>Additionally, the following still works:</p> <pre data-language="perl"><code>print "$x == 9" if $x == $y;
print "$x == 9" if $x == 9;
print "$x == 9" if $x == 3*3;</code></pre> <p>There is now a <code>bsstr()</code> method to get the string in scientific notation aka <code>1e+2</code> instead of <code>100</code>. Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl represents some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</p> <pre data-language="perl"><code>use Test::More tests =&gt; 3;
use Math::BigInt;

$x = Math::BigInt-&gt;new('1e56');
$y = 1e56;
is($x,$y);                     # fails
is($x-&gt;bsstr(), $y);           # okay
$y = Math::BigInt-&gt;new($y);
is($x, $y);                    # okay</code></pre> <p>Alternatively, simply use <code>&lt;=&gt;</code> for comparisons, this always gets it right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</p> <p>See also the section about <a href="#Infinity-and-Not-a-Number">"Infinity and Not a Number"</a> for problems in comparing NaNs.</p> </dd> <dt id="int()">
int()</dt> <dd> <p><code>int()</code> returns (at least for Perl v5.7.1 and up) another Math::BigInt, not a Perl scalar:</p> <pre data-language="perl"><code>$x = Math::BigInt-&gt;new(123);
$y = int($x);                           # 123 as a Math::BigInt
$x = Math::BigFloat-&gt;new(123.45);
$y = int($x);                           # 123 as a Math::BigFloat</code></pre> <p>If you want a real Perl scalar, use <code>numify()</code>:</p> <pre data-language="perl"><code>$y = $x-&gt;numify();                      # 123 as a scalar</code></pre> <p>This is seldom necessary, though, because this is done automatically, like when you access an array:</p> <pre data-language="perl"><code>$z = $array[$x];                        # does work automatically</code></pre> </dd> <dt id="Modifying-and-=">
Modifying and =</dt> <dd> <p>Beware of:</p> <pre data-language="perl"><code>$x = Math::BigFloat-&gt;new(5);
$y = $x;</code></pre> <p>This makes a second reference to the <b>same</b> object and stores it in $y. Thus anything that modifies $x (except overloaded operators) also modifies $y, and vice versa. Or in other words, <code>=</code> is only safe if you modify your Math::BigInt objects only via overloaded math. As soon as you use a method call it breaks:</p> <pre data-language="perl"><code>$x-&gt;bmul(2);
print "$x, $y\n";       # prints '10, 10'</code></pre> <p>If you want a true copy of $x, use:</p> <pre data-language="perl"><code>$y = $x-&gt;copy();</code></pre> <p>You can also chain the calls like this, this first makes a copy and then multiply it by 2:</p> <pre data-language="perl"><code>$y = $x-&gt;copy()-&gt;bmul(2);</code></pre> <p>See also the documentation for overload.pm regarding <code>=</code>.</p> </dd> <dt id="Overloading-$x">
Overloading -$x</dt> <dd> <p>The following:</p> <pre data-language="perl"><code>$x = -$x;</code></pre> <p>is slower than</p> <pre data-language="perl"><code>$x-&gt;bneg();</code></pre> <p>since overload calls <code>sub($x,0,1);</code> instead of <code>neg($x)</code>. The first variant needs to preserve $x since it does not know that it later gets overwritten. This makes a copy of $x and takes O(N), but $x-&gt;bneg() is O(1).</p> </dd> <dt id="Mixing-different-object-types">
Mixing different object types</dt> <dd> <p>With overloaded operators, it is the first (dominating) operand that determines which method is called. Here are some examples showing what actually gets called in various cases.</p> <pre data-language="perl"><code>use Math::BigInt;
use Math::BigFloat;

$mbf  = Math::BigFloat-&gt;new(5);
$mbi2 = Math::BigInt-&gt;new(5);
$mbi  = Math::BigInt-&gt;new(2);
                                # what actually gets called:
$float = $mbf + $mbi;           # $mbf-&gt;badd($mbi)
$float = $mbf / $mbi;           # $mbf-&gt;bdiv($mbi)
$integer = $mbi + $mbf;         # $mbi-&gt;badd($mbf)
$integer = $mbi2 / $mbi;        # $mbi2-&gt;bdiv($mbi)
$integer = $mbi2 / $mbf;        # $mbi2-&gt;bdiv($mbf)</code></pre> <p>For instance, Math::BigInt-&gt;bdiv() always returns a Math::BigInt, regardless of whether the second operant is a Math::BigFloat. To get a Math::BigFloat you either need to call the operation manually, make sure each operand already is a Math::BigFloat, or cast to that type via Math::BigFloat-&gt;new():</p> <pre data-language="perl"><code>$float = Math::BigFloat-&gt;new($mbi2) / $mbi;     # = 2.5</code></pre> <p>Beware of casting the entire expression, as this would cast the result, at which point it is too late:</p> <pre data-language="perl"><code>$float = Math::BigFloat-&gt;new($mbi2 / $mbi);     # = 2</code></pre> <p>Beware also of the order of more complicated expressions like:</p> <pre data-language="perl"><code>$integer = ($mbi2 + $mbi) / $mbf;               # int / float =&gt; int
$integer = $mbi2 / Math::BigFloat-&gt;new($mbi);   # ditto</code></pre> <p>If in doubt, break the expression into simpler terms, or cast all operands to the desired resulting type.</p> <p>Scalar values are a bit different, since:</p> <pre data-language="perl"><code>$float = 2 + $mbf;
$float = $mbf + 2;</code></pre> <p>both result in the proper type due to the way the overloaded math works.</p> <p>This section also applies to other overloaded math packages, like Math::String.</p> <p>One solution to you problem might be autoupgrading|upgrading. See the pragmas <a href="bignum.html">bignum</a>, <a href="bigint.html">bigint</a> and <a href="bigrat.html">bigrat</a> for an easy way to do this.</p> </dd> </dl> <h2 id="BUGS">BUGS</h2> <p>Please report any bugs or feature requests to <code>bug-math-bigint at rt.cpan.org</code>, or through the web interface at <a href="https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt">https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt</a> (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</p> <h2 id="SUPPORT">SUPPORT</h2> <p>You can find documentation for this module with the perldoc command.</p> <pre data-language="perl"><code class="plaintext">perldoc Math::BigInt</code></pre> <p>You can also look for information at:</p> <ul> <li>
<p>GitHub</p> <p><a href="https://github.com/pjacklam/p5-Math-BigInt">https://github.com/pjacklam/p5-Math-BigInt</a></p> </li> <li>
<p>RT: CPAN's request tracker</p> <p><a href="https://rt.cpan.org/Dist/Display.html?Name=Math-BigInt">https://rt.cpan.org/Dist/Display.html?Name=Math-BigInt</a></p> </li> <li>
<p>MetaCPAN</p> <p><a href="https://metacpan.org/release/Math-BigInt">https://metacpan.org/release/Math-BigInt</a></p> </li> <li>
<p>CPAN Testers Matrix</p> <p><a href="http://matrix.cpantesters.org/?dist=Math-BigInt">http://matrix.cpantesters.org/?dist=Math-BigInt</a></p> </li> <li>
<p>CPAN Ratings</p> <p><a href="https://cpanratings.perl.org/dist/Math-BigInt">https://cpanratings.perl.org/dist/Math-BigInt</a></p> </li> <li>
<p>The Bignum mailing list</p> <ul> <li>
<p>Post to mailing list</p> <p><code>bignum at lists.scsys.co.uk</code></p> </li> <li>
<p>View mailing list</p> <p><a href="http://lists.scsys.co.uk/pipermail/bignum/">http://lists.scsys.co.uk/pipermail/bignum/</a></p> </li> <li>
<p>Subscribe/Unsubscribe</p> <p><a href="http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum">http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum</a></p> </li> </ul> </li> </ul> <h2 id="LICENSE">LICENSE</h2> <p>This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p> <h2 id="SEE-ALSO">
SEE ALSO</h2> <p><a href="Math::BigFloat.html">Math::BigFloat</a> and <a href="Math::BigRat.html">Math::BigRat</a> as well as the backends <a href="Math::BigInt::FastCalc.html">Math::BigInt::FastCalc</a>, <a href="Math::BigInt::GMP.html">Math::BigInt::GMP</a>, and <a href="Math::BigInt::Pari.html">Math::BigInt::Pari</a>.</p> <p>The pragmas <a href="bignum.html">bignum</a>, <a href="bigint.html">bigint</a> and <a href="bigrat.html">bigrat</a> also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</p> <h2 id="AUTHORS">AUTHORS</h2> <ul> <li>
<p>Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.</p> </li> <li>
<p>Completely rewritten by Tels <a href="http://bloodgate.com">http://bloodgate.com</a>, 2001-2008.</p> </li> <li>
<p>Florian Ragwitz &lt;flora@cpan.org&gt;, 2010.</p> </li> <li>
<p>Peter John Acklam &lt;pjacklam@gmail.com&gt;, 2011-.</p> </li> </ul> <p>Many people contributed in one or more ways to the final beast, see the file CREDITS for an (incomplete) list. If you miss your name, please drop me a mail. Thank you!</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2023 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.38.0/Math::BigInt" class="_attribution-link">https://perldoc.perl.org/5.38.0/Math::BigInt</a>
  </p>
</div>
