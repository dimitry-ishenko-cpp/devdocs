<h1>File::Fetch</h1>   <h2><a id="toc">CONTENTS</a></h2> <ul> <li> <a class="text-decoration-none" href="#NAME">NAME</a> </li> <li> <a class="text-decoration-none" href="#SYNOPSIS">SYNOPSIS</a> </li> <li> <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION</a> </li> <li> <a class="text-decoration-none" href="#ACCESSORS">ACCESSORS</a> </li> <li> <a class="text-decoration-none" href="#METHODS">METHODS</a> <ul> <li> <a class="text-decoration-none" href="#$ff-=-File::Fetch-%3Enew(-uri-=%3E-'http://some.where.com/dir/file.txt'-);">$ff = File::Fetch-&gt;new( uri =&gt; 'http://some.where.com/dir/file.txt' );</a> </li> <li> <a class="text-decoration-none" href="#$where-=-$ff-%3Efetch(-%5Bto-=%3E-/my/output/dir/-%7C-%5C$scalar%5D-)">$where = $ff-&gt;fetch( [to =&gt; /my/output/dir/ | \$scalar] )</a> </li> <li> <a class="text-decoration-none" href="#$ff-%3Eerror(%5BBOOL%5D)">$ff-&gt;error([BOOL])</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#HOW-IT-WORKS">HOW IT WORKS</a> </li> <li> <a class="text-decoration-none" href="#GLOBAL-VARIABLES">GLOBAL VARIABLES</a> <ul> <li> <a class="text-decoration-none" href="#$File::Fetch::FROM_EMAIL">$File::Fetch::FROM_EMAIL</a> </li> <li> <a class="text-decoration-none" href="#$File::Fetch::USER_AGENT">$File::Fetch::USER_AGENT</a> </li> <li> <a class="text-decoration-none" href="#$File::Fetch::FTP_PASSIVE">$File::Fetch::FTP_PASSIVE</a> </li> <li> <a class="text-decoration-none" href="#$File::Fetch::TIMEOUT">$File::Fetch::TIMEOUT</a> </li> <li> <a class="text-decoration-none" href="#$File::Fetch::WARN">$File::Fetch::WARN</a> </li> <li> <a class="text-decoration-none" href="#$File::Fetch::DEBUG">$File::Fetch::DEBUG</a> </li> <li> <a class="text-decoration-none" href="#$File::Fetch::BLACKLIST">$File::Fetch::BLACKLIST</a> </li> <li> <a class="text-decoration-none" href="#$File::Fetch::METHOD_FAIL">$File::Fetch::METHOD_FAIL</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#MAPPING">MAPPING</a> </li> <li> <a class="text-decoration-none" href="#FREQUENTLY-ASKED-QUESTIONS">FREQUENTLY ASKED QUESTIONS</a> <ul> <li> <a class="text-decoration-none" href="#So-how-do-I-use-a-proxy-with-File::Fetch?">So how do I use a proxy with File::Fetch?</a> </li> <li> <a class="text-decoration-none" href="#I-used-'lynx'-to-fetch-a-file,-but-its-contents-is-all-wrong!">I used 'lynx' to fetch a file, but its contents is all wrong!</a> </li> <li> <a class="text-decoration-none" href="#Files-I'm-trying-to-fetch-have-reserved-characters-or-non-ASCII-characters-in-them.-What-do-I-do?">Files I'm trying to fetch have reserved characters or non-ASCII characters in them. What do I do?</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#TODO">TODO</a> </li> <li> <a class="text-decoration-none" href="#BUG-REPORTS">BUG REPORTS</a> </li> <li> <a class="text-decoration-none" href="#AUTHOR">AUTHOR</a> </li> <li> <a class="text-decoration-none" href="#COPYRIGHT">COPYRIGHT</a> </li> </ul> <h2 id="NAME">NAME</h2> <p>File::Fetch - A generic file fetching mechanism</p> <h2 id="SYNOPSIS">SYNOPSIS</h2> <pre data-language="perl"><code>use File::Fetch;

### build a File::Fetch object ###
my $ff = File::Fetch-&gt;new(uri =&gt; 'http://some.where.com/dir/a.txt');

### fetch the uri to cwd() ###
my $where = $ff-&gt;fetch() or die $ff-&gt;error;

### fetch the uri to /tmp ###
my $where = $ff-&gt;fetch( to =&gt; '/tmp' );

### parsed bits from the uri ###
$ff-&gt;uri;
$ff-&gt;scheme;
$ff-&gt;host;
$ff-&gt;path;
$ff-&gt;file;</code></pre> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>File::Fetch is a generic file fetching mechanism.</p> <p>It allows you to fetch any file pointed to by a <code>ftp</code>, <code>http</code>, <code>file</code>, <code>git</code> or <code>rsync</code> uri by a number of different means.</p> <p>See the <code>HOW IT WORKS</code> section further down for details.</p> <h2 id="ACCESSORS">ACCESSORS</h2> <p>A <code>File::Fetch</code> object has the following accessors</p> <dl> <dt id="$ff-&gt;uri">
$ff-&gt;uri</dt> <dd> <p>The uri you passed to the constructor</p> </dd> <dt id="$ff-&gt;scheme">
$ff-&gt;scheme</dt> <dd> <p>The scheme from the uri (like 'file', 'http', etc)</p> </dd> <dt id="$ff-&gt;host">
$ff-&gt;host</dt> <dd> <p>The hostname in the uri. Will be empty if host was originally 'localhost' for a 'file://' url.</p> </dd> <dt id="$ff-&gt;vol">
$ff-&gt;vol</dt> <dd> <p>On operating systems with the concept of a volume the second element of a file:// is considered to the be volume specification for the file. Thus on Win32 this routine returns the volume, on other operating systems this returns nothing.</p> <p>On Windows this value may be empty if the uri is to a network share, in which case the 'share' property will be defined. Additionally, volume specifications that use '|' as ':' will be converted on read to use ':'.</p> <p>On VMS, which has a volume concept, this field will be empty because VMS file specifications are converted to absolute UNIX format and the volume information is transparently included.</p> </dd> <dt id="$ff-&gt;share">
$ff-&gt;share</dt> <dd> <p>On systems with the concept of a network share (currently only Windows) returns the sharename from a file://// url. On other operating systems returns empty.</p> </dd> <dt id="$ff-&gt;path">
$ff-&gt;path</dt> <dd> <p>The path from the uri, will be at least a single '/'.</p> </dd> <dt id="$ff-&gt;file">
$ff-&gt;file</dt> <dd> <p>The name of the remote file. For the local file name, the result of $ff-&gt;output_file will be used.</p> </dd> <dt id="$ff-&gt;file_default">
$ff-&gt;file_default</dt> <dd> <p>The name of the default local file, that $ff-&gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like http://www.abc.net.au/ the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</p> </dd> <dt id="$ff-&gt;output_file">
$ff-&gt;output_file</dt> <dd> <p>The name of the output file. This is the same as $ff-&gt;file, but any query parameters are stripped off. For example:</p> <pre data-language="perl"><code class="plaintext">http://example.com/index.html?x=y</code></pre> <p>would make the output file be <code>index.html</code> rather than <code>index.html?x=y</code>.</p> </dd> </dl> <h2 id="METHODS">METHODS</h2> <h3 id="$ff-=-File::Fetch-&gt;new(-uri-=&gt;-'http://some.where.com/dir/file.txt'-);">
$ff = File::Fetch-&gt;new( uri =&gt; 'http://some.where.com/dir/file.txt' );</h3> <p>Parses the uri and creates a corresponding File::Fetch::Item object, that is ready to be <code>fetch</code>ed and returns it.</p> <p>Returns false on failure.</p> <h3 id="$where-=-$ff-&gt;fetch(-[to-=&gt;-/my/output/dir/-|-\$scalar]-)">
$where = $ff-&gt;fetch( [to =&gt; /my/output/dir/ | \$scalar] )</h3> <p>Fetches the file you requested and returns the full path to the file.</p> <p>By default it writes to <code>cwd()</code>, but you can override that by specifying the <code>to</code> argument:</p> <pre data-language="perl"><code>### file fetch to /tmp, full path to the file in $where
$where = $ff-&gt;fetch( to =&gt; '/tmp' );

### file slurped into $scalar, full path to the file in $where
### file is downloaded to a temp directory and cleaned up at exit time
$where = $ff-&gt;fetch( to =&gt; \$scalar );</code></pre> <p>Returns the full path to the downloaded file on success, and false on failure.</p> <h3 id="$ff-&gt;error([BOOL])">
$ff-&gt;error([BOOL])</h3> <p>Returns the last encountered error as string. Pass it a true value to get the <code>Carp::longmess()</code> output instead.</p> <h2 id="HOW-IT-WORKS">
HOW IT WORKS</h2> <p>File::Fetch is able to fetch a variety of uris, by using several external programs and modules.</p> <p>Below is a mapping of what utilities will be used in what order for what schemes, if available:</p> <pre data-language="perl"><code class="plaintext">file    =&gt; LWP, lftp, file
http    =&gt; LWP, HTTP::Tiny, wget, curl, lftp, fetch, HTTP::Lite, lynx, iosock
ftp     =&gt; LWP, Net::FTP, wget, curl, lftp, fetch, ncftp, ftp
rsync   =&gt; rsync
git     =&gt; git</code></pre> <p>If you'd like to disable the use of one or more of these utilities and/or modules, see the <code>$BLACKLIST</code> variable further down.</p> <p>If a utility or module isn't available, it will be marked in a cache (see the <code>$METHOD_FAIL</code> variable further down), so it will not be tried again. The <code>fetch</code> method will only fail when all options are exhausted, and it was not able to retrieve the file.</p> <p>The <code>fetch</code> utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from <code>pkgsrc</code>. We only check for <code>fetch</code> on those three platforms.</p> <p><code>iosock</code> is a very limited <a href="IO::Socket::INET.html">IO::Socket::INET</a> based mechanism for retrieving <code>http</code> schemed urls. It doesn't follow redirects for instance.</p> <p><code>git</code> only supports <code>git://</code> style urls.</p> <p>A special note about fetching files from an ftp uri:</p> <p>By default, all ftp connections are done in passive mode. To change that, see the <code>$FTP_PASSIVE</code> variable further down.</p> <p>Furthermore, ftp uris only support anonymous connections, so no named user/password pair can be passed along.</p> <p><code>/bin/ftp</code> is blacklisted by default; see the <code>$BLACKLIST</code> variable further down.</p> <h2 id="GLOBAL-VARIABLES">
GLOBAL VARIABLES</h2> <p>The behaviour of File::Fetch can be altered by changing the following global variables:</p> <h3 id="$File::Fetch::FROM_EMAIL">
$File::Fetch::FROM_EMAIL</h3> <p>This is the email address that will be sent as your anonymous ftp password.</p> <p>Default is <code>File-Fetch@example.com</code>.</p> <h3 id="$File::Fetch::USER_AGENT">
$File::Fetch::USER_AGENT</h3> <p>This is the useragent as <code>LWP</code> will report it.</p> <p>Default is <code>File::Fetch/$VERSION</code>.</p> <h3 id="$File::Fetch::FTP_PASSIVE">
$File::Fetch::FTP_PASSIVE</h3> <p>This variable controls whether the environment variable <code>FTP_PASSIVE</code> and any passive switches to commandline tools will be set to true.</p> <p>Default value is 1.</p> <p>Note: When $FTP_PASSIVE is true, <code>ncftp</code> will not be used to fetch files, since passive mode can only be set interactively for this binary</p> <h3 id="$File::Fetch::TIMEOUT">
$File::Fetch::TIMEOUT</h3> <p>When set, controls the network timeout (counted in seconds).</p> <p>Default value is 0.</p> <h3 id="$File::Fetch::WARN">
$File::Fetch::WARN</h3> <p>This variable controls whether errors encountered internally by <code>File::Fetch</code> should be <code>carp</code>'d or not.</p> <p>Set to false to silence warnings. Inspect the output of the <code>error()</code> method manually to see what went wrong.</p> <p>Defaults to <code>true</code>.</p> <h3 id="$File::Fetch::DEBUG">
$File::Fetch::DEBUG</h3> <p>This enables debugging output when calling commandline utilities to fetch files. This also enables <code>Carp::longmess</code> errors, instead of the regular <code>carp</code> errors.</p> <p>Good for tracking down why things don't work with your particular setup.</p> <p>Default is 0.</p> <h3 id="$File::Fetch::BLACKLIST">
$File::Fetch::BLACKLIST</h3> <p>This is an array ref holding blacklisted modules/utilities for fetching files with.</p> <p>To disallow the use of, for example, <code>LWP</code> and <code>Net::FTP</code>, you could set $File::Fetch::BLACKLIST to:</p> <pre data-language="perl"><code>$File::Fetch::BLACKLIST = [qw|lwp netftp|]</code></pre> <p>The default blacklist is [qw|ftp|], as <code>/bin/ftp</code> is rather unreliable.</p> <p>See the note on <code>MAPPING</code> below.</p> <h3 id="$File::Fetch::METHOD_FAIL">
$File::Fetch::METHOD_FAIL</h3> <p>This is a hashref registering what modules/utilities were known to fail for fetching files (mostly because they weren't installed).</p> <p>You can reset this cache by assigning an empty hashref to it, or individually remove keys.</p> <p>See the note on <code>MAPPING</code> below.</p> <h2 id="MAPPING">MAPPING</h2> <p>Here's a quick mapping for the utilities/modules, and their names for the $BLACKLIST, $METHOD_FAIL and other internal functions.</p> <pre data-language="perl"><code class="plaintext">LWP         =&gt; lwp
HTTP::Lite  =&gt; httplite
HTTP::Tiny  =&gt; httptiny
Net::FTP    =&gt; netftp
wget        =&gt; wget
lynx        =&gt; lynx
ncftp       =&gt; ncftp
ftp         =&gt; ftp
curl        =&gt; curl
rsync       =&gt; rsync
lftp        =&gt; lftp
fetch       =&gt; fetch
IO::Socket  =&gt; iosock</code></pre> <h2 id="FREQUENTLY-ASKED-QUESTIONS">
FREQUENTLY ASKED QUESTIONS</h2> <h3 id="So-how-do-I-use-a-proxy-with-File::Fetch?">
So how do I use a proxy with File::Fetch?</h3> <p><code>File::Fetch</code> currently only supports proxies with LWP::UserAgent. You will need to set your environment variables accordingly. For example, to use an ftp proxy:</p> <pre data-language="perl"><code>$ENV{ftp_proxy} = 'foo.com';</code></pre> <p>Refer to the LWP::UserAgent manpage for more details.</p> <h3 id="I-used-'lynx'-to-fetch-a-file,-but-its-contents-is-all-wrong!">
I used 'lynx' to fetch a file, but its contents is all wrong!</h3> <p><code>lynx</code> can only fetch remote files by dumping its contents to <code>STDOUT</code>, which we in turn capture. If that content is a 'custom' error file (like, say, a <code>404 handler</code>), you will get that contents instead.</p> <p>Sadly, <code>lynx</code> doesn't support any options to return a different exit code on non-<code>200 OK</code> status, giving us no way to tell the difference between a 'successful' fetch and a custom error page.</p> <p>Therefor, we recommend to only use <code>lynx</code> as a last resort. This is why it is at the back of our list of methods to try as well.</p> <h3 id="Files-I'm-trying-to-fetch-have-reserved-characters-or-non-ASCII-characters-in-them.-What-do-I-do?">
Files I'm trying to fetch have reserved characters or non-ASCII characters in them. What do I do?</h3> <p><code>File::Fetch</code> is relatively smart about things. When trying to write a file to disk, it removes the <code>query parameters</code> (see the <code>output_file</code> method for details) from the file name before creating it. In most cases this suffices.</p> <p>If you have any other characters you need to escape, please install the <code>URI::Escape</code> module from CPAN, and pre-encode your URI before passing it to <code>File::Fetch</code>. You can read about the details of URIs and URI encoding here:</p> <p><a href="https://datatracker.ietf.org/doc/html/rfc2396">https://datatracker.ietf.org/doc/html/rfc2396</a></p> <h2 id="TODO">TODO</h2> <dl> <dt id="Implement-$PREFER_BIN">
Implement $PREFER_BIN</dt> <dd> <p>To indicate to rather use commandline tools than modules</p> </dd> </dl> <h2 id="BUG-REPORTS">
BUG REPORTS</h2> <p>Please report bugs or other issues to &lt;bug-file-fetch@rt.cpan.org&lt;gt&gt;.</p> <h2 id="AUTHOR">AUTHOR</h2> <p>This module by Jos Boumans &lt;kane@cpan.org&gt;.</p> <h2 id="COPYRIGHT">COPYRIGHT</h2> <p>This library is free software; you may redistribute and/or modify it under the same terms as Perl itself.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2023 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.38.0/File::Fetch" class="_attribution-link">https://perldoc.perl.org/5.38.0/File::Fetch</a>
  </p>
</div>
