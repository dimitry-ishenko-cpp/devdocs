<h1 id="observerbase">ObserverBase</h1> <dl class="py class"> <dt class="sig sig-object py" id="torch.ao.quantization.observer.ObserverBase">
<code>class torch.ao.quantization.observer.ObserverBase(dtype)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/ao/quantization/observer.html#ObserverBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Base observer Module. Any observer implementation should derive from this class.</p> <p>Concrete observers should follow the same API. In forward, they will update the statistics of the observed Tensor. And they should provide a <code>calculate_qparams</code> function that computes the quantization parameters given the collected statistics.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>dtype</strong> â€“ dtype argument to the <code>quantize</code> node needed to implement the reference model spec.</p> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.ao.quantization.observer.ObserverBase.with_args">
<code>classmethod with_args(**kwargs)</code> </dt> <dd>
<p>Wrapper that allows creation of class factories.</p> <p>This can be useful when there is a need to create classes with the same constructor arguments, but different instances. Can be used in conjunction with _callable_args</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; Foo.with_args = classmethod(_with_args)
&gt;&gt;&gt; foo_builder = Foo.with_args(a=3, b=4).with_args(answer=42)
&gt;&gt;&gt; foo_instance1 = foo_builder()
&gt;&gt;&gt; foo_instance2 = foo_builder()
&gt;&gt;&gt; id(foo_instance1) == id(foo_instance2)
False
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.ao.quantization.observer.ObserverBase.with_callable_args">
<code>classmethod with_callable_args(**kwargs)</code> </dt> <dd>
<p>Wrapper that allows creation of class factories args that need to be called at construction time.</p> <p>This can be useful when there is a need to create classes with the same constructor arguments, but different instances and those arguments should only be calculated at construction time. Can be used in conjunction with _with_args</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; Foo.with_callable_args = classmethod(_with_callable_args)
&gt;&gt;&gt; Foo.with_args = classmethod(_with_args)
&gt;&gt;&gt; foo_builder = Foo.with_callable_args(cur_time=get_time_func).with_args(name="dan")
&gt;&gt;&gt; foo_instance1 = foo_builder()
&gt;&gt;&gt; # wait 50
&gt;&gt;&gt; foo_instance2 = foo_builder()
&gt;&gt;&gt; id(foo_instance1.creation_time) == id(foo_instance2.creation_time)
False
</pre> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/generated/torch.ao.quantization.observer.ObserverBase.html" class="_attribution-link">https://pytorch.org/docs/2.1/generated/torch.ao.quantization.observer.ObserverBase.html</a>
  </p>
</div>
