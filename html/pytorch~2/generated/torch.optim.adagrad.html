<h1 id="adagrad">Adagrad</h1> <dl class="py class"> <dt class="sig sig-object py" id="torch.optim.Adagrad">
<code>class torch.optim.Adagrad(params, lr=0.01, lr_decay=0, weight_decay=0, initial_accumulator_value=0, eps=1e-10, foreach=None, *, maximize=False, differentiable=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/optim/adagrad.html#Adagrad"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements Adagrad algorithm.</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="31.298em" height="0.04em"></mspace></mpadded></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext mathvariant="bold">input</mtext><mo>:</mo><mi>γ</mi><mtext> (lr)</mtext><mo separator="true">,</mo><msub><mi>θ</mi><mn>0</mn></msub><mtext> (params)</mtext><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mtext> (objective)</mtext><mo separator="true">,</mo><mi>λ</mi><mtext> (weight decay)</mtext><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="3.4143em"></mspace><mi>τ</mi><mtext> (initial accumulator value)</mtext><mo separator="true">,</mo><mi>η</mi><mtext> (lr decay)</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext mathvariant="bold">initialize</mtext><mo>:</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>u</mi><msub><mi>m</mi><mn>0</mn></msub><mo>←</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="31.298em" height="0.04em"></mspace></mpadded></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext mathvariant="bold">for</mtext><mi>t</mi><mo>=</mo><mn>1</mn><mtext mathvariant="bold">to</mtext><mo>…</mo><mtext mathvariant="bold">do</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1.4226em"></mspace><msub><mi>g</mi><mi>t</mi></msub><mo>←</mo><msub><mi mathvariant="normal">∇</mi><mi>θ</mi></msub><msub><mi>f</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>θ</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1.4226em"></mspace><mover accent="true"><mi>γ</mi><mo>~</mo></mover><mo>←</mo><mi>γ</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>η</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1.4226em"></mspace><mtext mathvariant="bold">if</mtext><mi>λ</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="2.8453em"></mspace><msub><mi>g</mi><mi>t</mi></msub><mo>←</mo><msub><mi>g</mi><mi>t</mi></msub><mo>+</mo><mi>λ</mi><msub><mi>θ</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1.4226em"></mspace><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>t</mi></msub><mo>←</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msubsup><mi>g</mi><mi>t</mi><mn>2</mn></msubsup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1.4226em"></mspace><msub><mi>θ</mi><mi>t</mi></msub><mo>←</mo><msub><mi>θ</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mover accent="true"><mi>γ</mi><mo>~</mo></mover><mfrac><msub><mi>g</mi><mi>t</mi></msub><mrow><msqrt><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>t</mi></msub></mrow></msqrt><mo>+</mo><mi>ϵ</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="31.298em" height="0.04em"></mspace></mpadded></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mrow><mi mathvariant="bold">r</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">n</mi></mrow><msub><mi mathvariant="bold">θ</mi><mi mathvariant="bold">t</mi></msub></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="31.298em" height="0.04em"></mspace></mpadded></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} &amp;\rule{110mm}{0.4pt} \\ &amp;\textbf{input} : \gamma \text{ (lr)}, \: \theta_0 \text{ (params)}, \: f(\theta) \text{ (objective)}, \: \lambda \text{ (weight decay)}, \\ &amp;\hspace{12mm} \tau \text{ (initial accumulator value)}, \: \eta\text{ (lr decay)}\\ &amp;\textbf{initialize} : state\_sum_0 \leftarrow 0 \\[-1.ex] &amp;\rule{110mm}{0.4pt} \\ &amp;\textbf{for} \: t=1 \: \textbf{to} \: \ldots \: \textbf{do} \\ &amp;\hspace{5mm}g_t \leftarrow \nabla_{\theta} f_t (\theta_{t-1}) \\ &amp;\hspace{5mm} \tilde{\gamma} \leftarrow \gamma / (1 +(t-1) \eta) \\ &amp;\hspace{5mm} \textbf{if} \: \lambda \neq 0 \\ &amp;\hspace{10mm} g_t \leftarrow g_t + \lambda \theta_{t-1} \\ &amp;\hspace{5mm}state\_sum_t \leftarrow state\_sum_{t-1} + g^2_t \\ &amp;\hspace{5mm}\theta_t \leftarrow \theta_{t-1}- \tilde{\gamma} \frac{g_t}{\sqrt{state\_sum_t}+\epsilon} \\ &amp;\rule{110mm}{0.4pt} \\[-1.ex] &amp;\bf{return} \: \theta_t \\[-1.ex] &amp;\rule{110mm}{0.4pt} \\[-1.ex] \end{aligned} </annotation></semantics></math></span></span></span>
</div>
<p>For further details regarding the algorithm we refer to <a class="reference external" href="http://jmlr.org/papers/v12/duchi11a.html">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a><em>, </em><em>optional</em>) – learning rate (default: 1e-2)</li> <li>
<strong>lr_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a><em>, </em><em>optional</em>) – learning rate decay (default: 0)</li> <li>
<strong>weight_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a><em>, </em><em>optional</em>) – weight decay (L2 penalty) (default: 0)</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a><em>, </em><em>optional</em>) – term added to the denominator to improve numerical stability (default: 1e-10)</li> <li>
<strong>foreach</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – whether foreach implementation of optimizer is used. If unspecified by the user (so foreach is None), we will try to use foreach over the for-loop implementation on CUDA, since it is usually significantly more performant. Note that the foreach implementation uses ~ sizeof(params) more peak memory than the for-loop version due to the intermediates being a tensorlist vs just one tensor. If memory is prohibitive, batch fewer parameters through the optimizer at a time or switch this flag to False (default: None)</li> <li>
<strong>maximize</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – maximize the params based on the objective, instead of minimizing (default: False)</li> <li>
<strong>differentiable</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – whether autograd should occur through the optimizer step in training. Otherwise, the step() function runs in a torch.no_grad() context. Setting to True can impair performance, so leave it False if you don’t intend to run autograd through this instance (default: False)</li> </ul> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.add_param_group">
<code>add_param_group(param_group)</code> </dt> <dd>
<p>Add a param group to the <a class="reference internal" href="../optim.html#torch.optim.Optimizer" title="torch.optim.Optimizer"><code>Optimizer</code></a> s <code>param_groups</code>.</p> <p>This can be useful when fine tuning a pre-trained network as frozen layers can be made trainable and added to the <a class="reference internal" href="../optim.html#torch.optim.Optimizer" title="torch.optim.Optimizer"><code>Optimizer</code></a> as training progresses.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>param_group</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)">dict</a>) – Specifies what Tensors should be optimized along with group specific optimization options.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.load_state_dict">
<code>load_state_dict(state_dict)</code> </dt> <dd>
<p>Loads the optimizer state.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>state_dict</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)">dict</a>) – optimizer state. Should be an object returned from a call to <a class="reference internal" href="#torch.optim.Adagrad.state_dict" title="torch.optim.Adagrad.state_dict"><code>state_dict()</code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.register_load_state_dict_post_hook">
<code>register_load_state_dict_post_hook(hook, prepend=False)</code> </dt> <dd>
<p>Register a load_state_dict post-hook which will be called after <a class="reference internal" href="torch.optim.optimizer.load_state_dict.html#torch.optim.Optimizer.load_state_dict" title="torch.optim.Optimizer.load_state_dict"><code>load_state_dict()</code></a> is called. It should have the following signature:</p> <pre data-language="python">hook(optimizer) -&gt; None
</pre> <p>The <code>optimizer</code> argument is the optimizer instance being used.</p> <p>The hook will be called with argument <code>self</code> after calling <code>load_state_dict</code> on <code>self</code>. The registered hook can be used to perform post-processing after <code>load_state_dict</code> has loaded the <code>state_dict</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>hook</strong> (<em>Callable</em>) – The user defined hook to be registered.</li> <li>
<strong>prepend</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If True, the provided post <code>hook</code> will be fired before all the already registered post-hooks on <code>load_state_dict</code>. Otherwise, the provided <code>hook</code> will be fired after all the already registered post-hooks. (default: False)</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a handle that can be used to remove the added hook by calling <code>handle.remove()</code></p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><code>torch.utils.hooks.RemoveableHandle</code></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.register_load_state_dict_pre_hook">
<code>register_load_state_dict_pre_hook(hook, prepend=False)</code> </dt> <dd>
<p>Register a load_state_dict pre-hook which will be called before <a class="reference internal" href="torch.optim.optimizer.load_state_dict.html#torch.optim.Optimizer.load_state_dict" title="torch.optim.Optimizer.load_state_dict"><code>load_state_dict()</code></a> is called. It should have the following signature:</p> <pre data-language="python">hook(optimizer, state_dict) -&gt; state_dict or None
</pre> <p>The <code>optimizer</code> argument is the optimizer instance being used and the <code>state_dict</code> argument is a shallow copy of the <code>state_dict</code> the user passed in to <code>load_state_dict</code>. The hook may modify the state_dict inplace or optionally return a new one. If a state_dict is returned, it will be used to be loaded into the optimizer.</p> <p>The hook will be called with argument <code>self</code> and <code>state_dict</code> before calling <code>load_state_dict</code> on <code>self</code>. The registered hook can be used to perform pre-processing before the <code>load_state_dict</code> call is made.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>hook</strong> (<em>Callable</em>) – The user defined hook to be registered.</li> <li>
<strong>prepend</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If True, the provided pre <code>hook</code> will be fired before all the already registered pre-hooks on <code>load_state_dict</code>. Otherwise, the provided <code>hook</code> will be fired after all the already registered pre-hooks. (default: False)</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a handle that can be used to remove the added hook by calling <code>handle.remove()</code></p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><code>torch.utils.hooks.RemoveableHandle</code></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.register_state_dict_post_hook">
<code>register_state_dict_post_hook(hook, prepend=False)</code> </dt> <dd>
<p>Register a state dict post-hook which will be called after <a class="reference internal" href="torch.optim.optimizer.state_dict.html#torch.optim.Optimizer.state_dict" title="torch.optim.Optimizer.state_dict"><code>state_dict()</code></a> is called. It should have the following signature:</p> <pre data-language="python">hook(optimizer, state_dict) -&gt; state_dict or None
</pre> <p>The hook will be called with arguments <code>self</code> and <code>state_dict</code> after generating a <code>state_dict</code> on <code>self</code>. The hook may modify the state_dict inplace or optionally return a new one. The registered hook can be used to perform post-processing on the <code>state_dict</code> before it is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>hook</strong> (<em>Callable</em>) – The user defined hook to be registered.</li> <li>
<strong>prepend</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If True, the provided post <code>hook</code> will be fired before all the already registered post-hooks on <code>state_dict</code>. Otherwise, the provided <code>hook</code> will be fired after all the already registered post-hooks. (default: False)</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a handle that can be used to remove the added hook by calling <code>handle.remove()</code></p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><code>torch.utils.hooks.RemoveableHandle</code></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.register_state_dict_pre_hook">
<code>register_state_dict_pre_hook(hook, prepend=False)</code> </dt> <dd>
<p>Register a state dict pre-hook which will be called before <a class="reference internal" href="torch.optim.optimizer.state_dict.html#torch.optim.Optimizer.state_dict" title="torch.optim.Optimizer.state_dict"><code>state_dict()</code></a> is called. It should have the following signature:</p> <pre data-language="python">hook(optimizer) -&gt; None
</pre> <p>The <code>optimizer</code> argument is the optimizer instance being used. The hook will be called with argument <code>self</code> before calling <code>state_dict</code> on <code>self</code>. The registered hook can be used to perform pre-processing before the <code>state_dict</code> call is made.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>hook</strong> (<em>Callable</em>) – The user defined hook to be registered.</li> <li>
<strong>prepend</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If True, the provided pre <code>hook</code> will be fired before all the already registered pre-hooks on <code>state_dict</code>. Otherwise, the provided <code>hook</code> will be fired after all the already registered pre-hooks. (default: False)</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a handle that can be used to remove the added hook by calling <code>handle.remove()</code></p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><code>torch.utils.hooks.RemoveableHandle</code></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.register_step_post_hook">
<code>register_step_post_hook(hook)</code> </dt> <dd>
<p>Register an optimizer step post hook which will be called after optimizer step. It should have the following signature:</p> <pre data-language="python">hook(optimizer, args, kwargs) -&gt; None
</pre> <p>The <code>optimizer</code> argument is the optimizer instance being used.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>hook</strong> (<em>Callable</em>) – The user defined hook to be registered.</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a handle that can be used to remove the added hook by calling <code>handle.remove()</code></p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><code>torch.utils.hooks.RemovableHandle</code></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.register_step_pre_hook">
<code>register_step_pre_hook(hook)</code> </dt> <dd>
<p>Register an optimizer step pre hook which will be called before optimizer step. It should have the following signature:</p> <pre data-language="python">hook(optimizer, args, kwargs) -&gt; None or modified args and kwargs
</pre> <p>The <code>optimizer</code> argument is the optimizer instance being used. If args and kwargs are modified by the pre-hook, then the transformed values are returned as a tuple containing the new_args and new_kwargs.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>hook</strong> (<em>Callable</em>) – The user defined hook to be registered.</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a handle that can be used to remove the added hook by calling <code>handle.remove()</code></p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><code>torch.utils.hooks.RemovableHandle</code></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.state_dict">
<code>state_dict()</code> </dt> <dd>
<p>Returns the state of the optimizer as a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code>dict</code></a>.</p> <p>It contains two entries:</p> <ul class="simple"> <li>
<dl class="simple"> <dt>
<code>state: a Dict holding current optimization state. Its content</code> </dt>
<dd>
<p>differs between optimizer classes, but some common characteristics hold. For example, state is saved per parameter, and the parameter itself is NOT saved. <code>state</code> is a Dictionary mapping parameter ids to a Dict with state corresponding to each parameter.</p> </dd> </dl> </li> <li>
<dl class="simple"> <dt>
<code>param_groups: a List containing all parameter groups where each</code> </dt>
<dd>
<p>parameter group is a Dict. Each parameter group contains metadata specific to the optimizer, such as learning rate and weight decay, as well as a List of parameter IDs of the parameters in the group.</p> </dd> </dl> </li> </ul> <p>NOTE: The parameter IDs may look like indices but they are just IDs associating state with param_group. When loading from a state_dict, the optimizer will zip the param_group <code>params</code> (int IDs) and the optimizer <code>param_groups</code> (actual <code>nn.Parameter</code> s) in order to match state WITHOUT additional verification.</p> <p>A returned state dict might look something like:</p> <pre data-language="text">{
    'state': {
        0: {'momentum_buffer': tensor(...), ...},
        1: {'momentum_buffer': tensor(...), ...},
        2: {'momentum_buffer': tensor(...), ...},
        3: {'momentum_buffer': tensor(...), ...}
    },
    'param_groups': [
        {
            'lr': 0.01,
            'weight_decay': 0,
            ...
            'params': [0]
        },
        {
            'lr': 0.001,
            'weight_decay': 0.5,
            ...
            'params': [1, 2, 3]
        }
    ]
}
</pre> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Dict" title="(in Python v3.12)">Dict</a>[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.12)">Any</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/optim/adagrad.html#Adagrad.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>Callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.optim.Adagrad.zero_grad">
<code>zero_grad(set_to_none=True)</code> </dt> <dd>
<p>Resets the gradients of all optimized <a class="reference internal" href="../tensors.html#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> s.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>set_to_none</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – instead of setting to zero, set the grads to None. This will in general have lower memory footprint, and can modestly improve performance. However, it changes certain behaviors. For example: 1. When the user tries to access a gradient and perform manual ops on it, a None attribute or a Tensor full of 0s will behave differently. 2. If the user requests <code>zero_grad(set_to_none=True)</code> followed by a backward pass, <code>.grad</code>s are guaranteed to be None for params that did not receive a gradient. 3. <code>torch.optim</code> optimizers have a different behavior if the gradient is 0 or None (in one case it does the step with a gradient of 0 and in the other it skips the step altogether).</p> </dd> </dl> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/generated/torch.optim.Adagrad.html" class="_attribution-link">https://pytorch.org/docs/2.1/generated/torch.optim.Adagrad.html</a>
  </p>
</div>
