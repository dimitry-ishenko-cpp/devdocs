<h1 id="lstm">LSTM</h1> <dl class="py class"> <dt class="sig sig-object py" id="torch.nn.LSTM">
<code>class torch.nn.LSTM(self, input_size, hidden_size, num_layers=1, bias=True, batch_first=False, dropout=0.0, bidirectional=False, proj_size=0, device=None, dtype=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/nn/modules/rnn.html#LSTM"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies a multi-layer long short-term memory (LSTM) RNN to an input sequence.</p> <p>For each element in the input sequence, each layer computes the following function:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>i</mi><mi>t</mi></msub><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub><msub><mi>x</mi><mi>t</mi></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>+</mo><msub><mi>W</mi><mrow><mi>h</mi><mi>i</mi></mrow></msub><msub><mi>h</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>h</mi><mi>i</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>f</mi><mi>t</mi></msub><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mrow><mi>i</mi><mi>f</mi></mrow></msub><msub><mi>x</mi><mi>t</mi></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>i</mi><mi>f</mi></mrow></msub><mo>+</mo><msub><mi>W</mi><mrow><mi>h</mi><mi>f</mi></mrow></msub><msub><mi>h</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>h</mi><mi>f</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>g</mi><mi>t</mi></msub><mo>=</mo><mi>tanh</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>W</mi><mrow><mi>i</mi><mi>g</mi></mrow></msub><msub><mi>x</mi><mi>t</mi></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>i</mi><mi>g</mi></mrow></msub><mo>+</mo><msub><mi>W</mi><mrow><mi>h</mi><mi>g</mi></mrow></msub><msub><mi>h</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>h</mi><mi>g</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>o</mi><mi>t</mi></msub><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mrow><mi>i</mi><mi>o</mi></mrow></msub><msub><mi>x</mi><mi>t</mi></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>i</mi><mi>o</mi></mrow></msub><mo>+</mo><msub><mi>W</mi><mrow><mi>h</mi><mi>o</mi></mrow></msub><msub><mi>h</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>h</mi><mi>o</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>c</mi><mi>t</mi></msub><mo>=</mo><msub><mi>f</mi><mi>t</mi></msub><mo>⊙</mo><msub><mi>c</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>i</mi><mi>t</mi></msub><mo>⊙</mo><msub><mi>g</mi><mi>t</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>h</mi><mi>t</mi></msub><mo>=</mo><msub><mi>o</mi><mi>t</mi></msub><mo>⊙</mo><mi>tanh</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>c</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{ll} \\ i_t = \sigma(W_{ii} x_t + b_{ii} + W_{hi} h_{t-1} + b_{hi}) \\ f_t = \sigma(W_{if} x_t + b_{if} + W_{hf} h_{t-1} + b_{hf}) \\ g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hg} h_{t-1} + b_{hg}) \\ o_t = \sigma(W_{io} x_t + b_{io} + W_{ho} h_{t-1} + b_{ho}) \\ c_t = f_t \odot c_{t-1} + i_t \odot g_t \\ h_t = o_t \odot \tanh(c_t) \\ \end{array} </annotation></semantics></math></span></span></span>
</div>
<p>where <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">h_t</annotation></semantics></math></span></span></span> is the hidden state at time <code>t</code>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">c_t</annotation></semantics></math></span></span></span> is the cell state at time <code>t</code>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">x_t</annotation></semantics></math></span></span></span> is the input at time <code>t</code>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{t-1}</annotation></semantics></math></span></span></span> is the hidden state of the layer at time <code>t-1</code> or the initial hidden state at time <code>0</code>, and <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">i_t</annotation></semantics></math></span></span></span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">f_t</annotation></semantics></math></span></span></span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">g_t</annotation></semantics></math></span></span></span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">o_t</annotation></semantics></math></span></span></span> are the input, forget, cell, and output gates, respectively. <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span></span></span> is the sigmoid function, and <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊙</mo></mrow><annotation encoding="application/x-tex">\odot</annotation></semantics></math></span></span></span> is the Hadamard product.</p> <p>In a multilayer LSTM, the input <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>x</mi><mi>t</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">x^{(l)}_t</annotation></semantics></math></span></span></span> of the <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span></span></span> -th layer (<span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">l \ge 2</annotation></semantics></math></span></span></span>) is the hidden state <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>t</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">h^{(l-1)}_t</annotation></semantics></math></span></span></span> of the previous layer multiplied by dropout <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>δ</mi><mi>t</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\delta^{(l-1)}_t</annotation></semantics></math></span></span></span> where each <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>δ</mi><mi>t</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\delta^{(l-1)}_t</annotation></semantics></math></span></span></span> is a Bernoulli random variable which is <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span></span></span> with probability <code>dropout</code>.</p> <p>If <code>proj_size &gt; 0</code> is specified, LSTM with projections will be used. This changes the LSTM cell in the following way. First, the dimension of <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">h_t</annotation></semantics></math></span></span></span> will be changed from <code>hidden_size</code> to <code>proj_size</code> (dimensions of <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>h</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{hi}</annotation></semantics></math></span></span></span> will be changed accordingly). Second, the output hidden state of each layer will be multiplied by a learnable projection matrix: <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>t</mi></msub><mo>=</mo><msub><mi>W</mi><mrow><mi>h</mi><mi>r</mi></mrow></msub><msub><mi>h</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">h_t = W_{hr}h_t</annotation></semantics></math></span></span></span>. Note that as a consequence of this, the output of LSTM network will be of different shape as well. See Inputs/Outputs sections below for exact dimensions of all variables. You can find more details in <a class="reference external" href="https://arxiv.org/abs/1402.1128">https://arxiv.org/abs/1402.1128</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input_size</strong> – The number of expected features in the input <code>x</code>
</li> <li>
<strong>hidden_size</strong> – The number of features in the hidden state <code>h</code>
</li> <li>
<strong>num_layers</strong> – Number of recurrent layers. E.g., setting <code>num_layers=2</code> would mean stacking two LSTMs together to form a <code>stacked LSTM</code>, with the second LSTM taking in outputs of the first LSTM and computing the final results. Default: 1</li> <li>
<strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code>
</li> <li>
<strong>batch_first</strong> – If <code>True</code>, then the input and output tensors are provided as <code>(batch, seq, feature)</code> instead of <code>(seq, batch, feature)</code>. Note that this does not apply to hidden or cell states. See the Inputs/Outputs sections below for details. Default: <code>False</code>
</li> <li>
<strong>dropout</strong> – If non-zero, introduces a <code>Dropout</code> layer on the outputs of each LSTM layer except the last layer, with dropout probability equal to <code>dropout</code>. Default: 0</li> <li>
<strong>bidirectional</strong> – If <code>True</code>, becomes a bidirectional LSTM. Default: <code>False</code>
</li> <li>
<strong>proj_size</strong> – If <code>&gt; 0</code>, will use LSTM with projections of corresponding size. Default: 0</li> </ul> </dd> </dl> <dl> <dt>Inputs: input, (h_0, c_0)</dt>
<dd>
<ul class="simple"> <li>
<strong>input</strong>: tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L, H_{in})</annotation></semantics></math></span></span></span> for unbatched input, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mi>N</mi><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L, N, H_{in})</annotation></semantics></math></span></span></span> when <code>batch_first=False</code> or <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>L</mi><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N, L, H_{in})</annotation></semantics></math></span></span></span> when <code>batch_first=True</code> containing the features of the input sequence. The input can also be a packed variable length sequence. See <a class="reference internal" href="torch.nn.utils.rnn.pack_padded_sequence.html#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>torch.nn.utils.rnn.pack_padded_sequence()</code></a> or <a class="reference internal" href="torch.nn.utils.rnn.pack_sequence.html#torch.nn.utils.rnn.pack_sequence" title="torch.nn.utils.rnn.pack_sequence"><code>torch.nn.utils.rnn.pack_sequence()</code></a> for details.</li> <li>
<strong>h_0</strong>: tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>∗</mo><mtext>num_layers</mtext><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D * \text{num\_layers}, H_{out})</annotation></semantics></math></span></span></span> for unbatched input or <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>∗</mo><mtext>num_layers</mtext><mo separator="true">,</mo><mi>N</mi><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D * \text{num\_layers}, N, H_{out})</annotation></semantics></math></span></span></span> containing the initial hidden state for each element in the input sequence. Defaults to zeros if (h_0, c_0) is not provided.</li> <li>
<strong>c_0</strong>: tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>∗</mo><mtext>num_layers</mtext><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>c</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D * \text{num\_layers}, H_{cell})</annotation></semantics></math></span></span></span> for unbatched input or <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>∗</mo><mtext>num_layers</mtext><mo separator="true">,</mo><mi>N</mi><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>c</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D * \text{num\_layers}, N, H_{cell})</annotation></semantics></math></span></span></span> containing the initial cell state for each element in the input sequence. Defaults to zeros if (h_0, c_0) is not provided.</li> </ul> <p>where:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>N</mi><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>batch size</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>L</mi><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>sequence length</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>D</mi><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>2</mn><mtext> if bidirectional=True otherwise </mtext><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>H</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>input_size</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>H</mi><mrow><mi>c</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow></msub><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>hidden_size</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>=</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>proj_size if proj_size</mtext><mo>&gt;</mo><mn>0</mn><mtext> otherwise hidden_size</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} N ={} &amp; \text{batch size} \\ L ={} &amp; \text{sequence length} \\ D ={} &amp; 2 \text{ if bidirectional=True otherwise } 1 \\ H_{in} ={} &amp; \text{input\_size} \\ H_{cell} ={} &amp; \text{hidden\_size} \\ H_{out} ={} &amp; \text{proj\_size if } \text{proj\_size}&gt;0 \text{ otherwise hidden\_size} \\ \end{aligned} </annotation></semantics></math></span></span></span>
</div>
</dd> <dt>Outputs: output, (h_n, c_n)</dt>
<dd>
<ul class="simple"> <li>
<strong>output</strong>: tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mi>D</mi><mo>∗</mo><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L, D * H_{out})</annotation></semantics></math></span></span></span> for unbatched input, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mi>N</mi><mo separator="true">,</mo><mi>D</mi><mo>∗</mo><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L, N, D * H_{out})</annotation></semantics></math></span></span></span> when <code>batch_first=False</code> or <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>L</mi><mo separator="true">,</mo><mi>D</mi><mo>∗</mo><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N, L, D * H_{out})</annotation></semantics></math></span></span></span> when <code>batch_first=True</code> containing the output features <code>(h_t)</code> from the last layer of the LSTM, for each <code>t</code>. If a <a class="reference internal" href="torch.nn.utils.rnn.packedsequence.html#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>torch.nn.utils.rnn.PackedSequence</code></a> has been given as the input, the output will also be a packed sequence. When <code>bidirectional=True</code>, <code>output</code> will contain a concatenation of the forward and reverse hidden states at each time step in the sequence.</li> <li>
<strong>h_n</strong>: tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>∗</mo><mtext>num_layers</mtext><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D * \text{num\_layers}, H_{out})</annotation></semantics></math></span></span></span> for unbatched input or <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>∗</mo><mtext>num_layers</mtext><mo separator="true">,</mo><mi>N</mi><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D * \text{num\_layers}, N, H_{out})</annotation></semantics></math></span></span></span> containing the final hidden state for each element in the sequence. When <code>bidirectional=True</code>, <code>h_n</code> will contain a concatenation of the final forward and reverse hidden states, respectively.</li> <li>
<strong>c_n</strong>: tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>∗</mo><mtext>num_layers</mtext><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>c</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D * \text{num\_layers}, H_{cell})</annotation></semantics></math></span></span></span> for unbatched input or <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>∗</mo><mtext>num_layers</mtext><mo separator="true">,</mo><mi>N</mi><mo separator="true">,</mo><msub><mi>H</mi><mrow><mi>c</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D * \text{num\_layers}, N, H_{cell})</annotation></semantics></math></span></span></span> containing the final cell state for each element in the sequence. When <code>bidirectional=True</code>, <code>c_n</code> will contain a concatenation of the final forward and reverse cell states, respectively.</li> </ul> </dd> </dl> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>weight_ih_l[k]</strong> – the learnable input-hidden weights of the <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext>k</mtext><mrow><mi>t</mi><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\text{k}^{th}</annotation></semantics></math></span></span></span> layer <code>(W_ii|W_if|W_ig|W_io)</code>, of shape <code>(4*hidden_size, input_size)</code> for <code>k = 0</code>. Otherwise, the shape is <code>(4*hidden_size, num_directions * hidden_size)</code>. If <code>proj_size &gt; 0</code> was specified, the shape will be <code>(4*hidden_size, num_directions * proj_size)</code> for <code>k &gt; 0</code>
</li> <li>
<strong>weight_hh_l[k]</strong> – the learnable hidden-hidden weights of the <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext>k</mtext><mrow><mi>t</mi><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\text{k}^{th}</annotation></semantics></math></span></span></span> layer <code>(W_hi|W_hf|W_hg|W_ho)</code>, of shape <code>(4*hidden_size, hidden_size)</code>. If <code>proj_size &gt; 0</code> was specified, the shape will be <code>(4*hidden_size, proj_size)</code>.</li> <li>
<strong>bias_ih_l[k]</strong> – the learnable input-hidden bias of the <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext>k</mtext><mrow><mi>t</mi><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\text{k}^{th}</annotation></semantics></math></span></span></span> layer <code>(b_ii|b_if|b_ig|b_io)</code>, of shape <code>(4*hidden_size)</code>
</li> <li>
<strong>bias_hh_l[k]</strong> – the learnable hidden-hidden bias of the <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext>k</mtext><mrow><mi>t</mi><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\text{k}^{th}</annotation></semantics></math></span></span></span> layer <code>(b_hi|b_hf|b_hg|b_ho)</code>, of shape <code>(4*hidden_size)</code>
</li> <li>
<strong>weight_hr_l[k]</strong> – the learnable projection weights of the <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext>k</mtext><mrow><mi>t</mi><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\text{k}^{th}</annotation></semantics></math></span></span></span> layer of shape <code>(proj_size, hidden_size)</code>. Only present when <code>proj_size &gt; 0</code> was specified.</li> <li>
<strong>weight_ih_l[k]_reverse</strong> – Analogous to <code>weight_ih_l[k]</code> for the reverse direction. Only present when <code>bidirectional=True</code>.</li> <li>
<strong>weight_hh_l[k]_reverse</strong> – Analogous to <code>weight_hh_l[k]</code> for the reverse direction. Only present when <code>bidirectional=True</code>.</li> <li>
<strong>bias_ih_l[k]_reverse</strong> – Analogous to <code>bias_ih_l[k]</code> for the reverse direction. Only present when <code>bidirectional=True</code>.</li> <li>
<strong>bias_hh_l[k]_reverse</strong> – Analogous to <code>bias_hh_l[k]</code> for the reverse direction. Only present when <code>bidirectional=True</code>.</li> <li>
<strong>weight_hr_l[k]_reverse</strong> – Analogous to <code>weight_hr_l[k]</code> for the reverse direction. Only present when <code>bidirectional=True</code> and <code>proj_size &gt; 0</code> was specified.</li> </ul> </dd> </dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>All the weights and biases are initialized from <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">U</mi><mo stretchy="false">(</mo><mo>−</mo><msqrt><mi>k</mi></msqrt><mo separator="true">,</mo><msqrt><mi>k</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}(-\sqrt{k}, \sqrt{k})</annotation></semantics></math></span></span></span> where <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mfrac><mn>1</mn><mtext>hidden_size</mtext></mfrac></mrow><annotation encoding="application/x-tex">k = \frac{1}{\text{hidden\_size}}</annotation></semantics></math></span></span></span></p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For bidirectional LSTMs, forward and backward are directions 0 and 1 respectively. Example of splitting the output layers when <code>batch_first=False</code>: <code>output.view(seq_len, batch, num_directions, hidden_size)</code>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For bidirectional LSTMs, <code>h_n</code> is not equivalent to the last element of <code>output</code>; the former contains the final forward and reverse hidden states, while the latter contains the final forward hidden state and the initial reverse hidden state.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>batch_first</code> argument is ignored for unbatched inputs.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>proj_size</code> should be smaller than <code>hidden_size</code>.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>There are known non-determinism issues for RNN functions on some versions of cuDNN and CUDA. You can enforce deterministic behavior by setting the following environment variables:</p> <p>On CUDA 10.1, set environment variable <code>CUDA_LAUNCH_BLOCKING=1</code>. This may affect performance.</p> <p>On CUDA 10.2 or later, set environment variable (note the leading colon symbol) <code>CUBLAS_WORKSPACE_CONFIG=:16:8</code> or <code>CUBLAS_WORKSPACE_CONFIG=:4096:2</code>.</p> <p>See the <a class="reference external" href="https://docs.nvidia.com/deeplearning/sdk/cudnn-release-notes/rel_8.html">cuDNN 8 Release Notes</a> for more information.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If the following conditions are satisfied: 1) cudnn is enabled, 2) input data is on the GPU 3) input data has dtype <code>torch.float16</code> 4) V100 GPU is used, 5) input data is not in <code>PackedSequence</code> format persistent algorithm can be selected to improve performance.</p> </div> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; rnn = nn.LSTM(10, 20, 2)
&gt;&gt;&gt; input = torch.randn(5, 3, 10)
&gt;&gt;&gt; h0 = torch.randn(2, 3, 20)
&gt;&gt;&gt; c0 = torch.randn(2, 3, 20)
&gt;&gt;&gt; output, (hn, cn) = rnn(input, (h0, c0))
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/generated/torch.nn.LSTM.html" class="_attribution-link">https://pytorch.org/docs/2.1/generated/torch.nn.LSTM.html</a>
  </p>
</div>
