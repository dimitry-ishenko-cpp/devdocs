<h1 id="torch-utils-mobile-optimizer">torch.utils.mobile_optimizer</h1> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This API is in beta and may change in the near future.</p> </div> <p>Torch mobile supports <code>torch.utils.mobile_optimizer.optimize_for_mobile</code> utility to run a list of optimization pass with modules in eval mode. The method takes the following parameters: a torch.jit.ScriptModule object, a blocklisting optimization set, a preserved method list, and a backend.</p> <dl class="simple"> <dt>
<code>For CPU Backend, by default, if optimization blocklist is None or empty, optimize_for_mobile will run the following optimizations:</code> </dt>
<dd>
<ul class="simple"> <li>
<strong>Conv2D + BatchNorm fusion</strong> (blocklisting option <code>mobile_optimizer.MobileOptimizerType.CONV_BN_FUSION</code>): This optimization pass folds <code>Conv2d-BatchNorm2d</code> into <code>Conv2d</code> in <code>forward</code> method of this module and all its submodules. The weight and bias of the <code>Conv2d</code> are correspondingly updated.</li> <li>
<strong>Insert and Fold prepacked ops</strong> (blocklisting option <code>mobile_optimizer.MobileOptimizerType.INSERT_FOLD_PREPACK_OPS</code>): This optimization pass rewrites the graph to replace 2D convolutions and linear ops with their prepacked counterparts. Prepacked ops are stateful ops in that, they require some state to be created, such as weight prepacking and use this state, i.e. prepacked weights, during op execution. XNNPACK is one such backend that provides prepacked ops, with kernels optimized for mobile platforms (such as ARM CPUs). Prepacking of weight enables efficient memory access and thus faster kernel execution. At the moment <code>optimize_for_mobile</code> pass rewrites the graph to replace <code>Conv2D/Linear</code> with 1) op that pre-packs weight for XNNPACK conv2d/linear ops and 2) op that takes pre-packed weight and activation as input and generates output activations. Since 1 needs to be done only once, we fold the weight pre-packing such that it is done only once at model load time. This pass of the <code>optimize_for_mobile</code> does 1 and 2 and then folds, i.e. removes, weight pre-packing ops.</li> <li>
<strong>ReLU/Hardtanh fusion</strong>: XNNPACK ops support fusion of clamping. That is clamping of output activation is done as part of the kernel, including for 2D convolution and linear op kernels. Thus clamping effectively comes for free. Thus any op that can be expressed as clamping op, such as <code>ReLU</code> or <code>hardtanh</code>, can be fused with previous <code>Conv2D</code> or <code>linear</code> op in XNNPACK. This pass rewrites graph by finding <code>ReLU/hardtanh</code> ops that follow XNNPACK <code>Conv2D/linear</code> ops, written by the previous pass, and fuses them together.</li> <li>
<strong>Dropout removal</strong> (blocklisting option <code>mobile_optimizer.MobileOptimizerType.REMOVE_DROPOUT</code>): This optimization pass removes <code>dropout</code> and <code>dropout_</code> nodes from this module when training is false.</li> <li>
<strong>Conv packed params hoisting</strong> (blocklisting option <code>mobile_optimizer.MobileOptimizerType.HOIST_CONV_PACKED_PARAMS</code>): This optimization pass moves convolution packed params to the root module, so that the convolution structs can be deleted. This decreases model size without impacting numerics.</li> <li>
<strong>Add/ReLU fusion</strong> (blocklisting option <code>mobile_optimizer.MobileOptimizerType.FUSE_ADD_RELU</code>): This pass finds instances of <code>relu</code> ops that follow <code>add</code> ops and fuses them into a single <code>add_relu</code>.</li> </ul> </dd> <dt>
<code>for Vulkan Backend, by default, if optimization blocklist is None or empty, optimize_for_mobile will run the following optimization:</code> </dt>
<dd>
<ul class="simple"> <li>
<strong>Automatic GPU Transfer</strong> (blocklisting option <code>mobile_optimizer.MobileOptimizerType.VULKAN_AUTOMATIC_GPU_TRANSFER</code>): This optimization pass rewrites the graph so that moving input and output data to and from the GPU becomes part of the model.</li> </ul> </dd> </dl> <p><code>optimize_for_mobile</code> will also invoke freeze_module pass which only preserves <code>forward</code> method. If you have other method to that needed to be preserved, add them into the preserved method list and pass into the method.</p> <dl class="py function"> <dt class="sig sig-object py" id="torch.utils.mobile_optimizer.optimize_for_mobile">
<code>torch.utils.mobile_optimizer.optimize_for_mobile(script_module, optimization_blocklist=None, preserved_methods=None, backend='CPU')</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/utils/mobile_optimizer.html#optimize_for_mobile"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>script_module</strong> (<a class="reference internal" href="generated/torch.jit.scriptmodule.html#torch.jit.ScriptModule" title="torch.jit._script.ScriptModule">ScriptModule</a>) – An instance of torch script module with type of ScriptModule.</li> <li>
<strong>optimization_blocklist</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.12)">Optional</a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Set" title="(in Python v3.12)">Set</a><em>[</em><em>_MobileOptimizerType</em><em>]</em><em>]</em>) – A set with type of MobileOptimizerType. When set is not passed, optimization method will run all the optimizer pass; otherwise, optimizer method will run the optimization pass that is not included inside optimization_blocklist.</li> <li>
<strong>preserved_methods</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.12)">Optional</a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(in Python v3.12)">List</a><em>]</em>) – A list of methods that needed to be preserved when freeze_module pass is invoked</li> <li>
<strong>backend</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>) – Device type to use for running the result model (‘CPU’(default), ‘Vulkan’ or ‘Metal’).</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>A new optimized torch script module</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><em>RecursiveScriptModule</em></p> </dd> </dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/mobile_optimizer.html" class="_attribution-link">https://pytorch.org/docs/2.1/mobile_optimizer.html</a>
  </p>
</div>
