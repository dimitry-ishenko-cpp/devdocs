    <h1 id="firstHeading" class="firstHeading">C++ named requirements: RangeAdaptorClosureObject <span class="t-mark-rev t-since-cxx20">(since C++20)</span>
</h1>            <p><i>Range adaptor closure objects</i> are <a href="functionobject.html" title="cpp/named req/FunctionObject">FunctionObjects</a> that are callable via the pipe operator: if <code>C</code> is a range adaptor closure object and <code>R</code> is a <a href="../ranges/range.html" title="cpp/ranges/range"><code>range</code></a>, these two expressions are <a href="../language/expressions.html#Expression-equivalence" title="cpp/language/expressions">equivalent</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">C(R)
R | C</pre></div> <p>Two range adaptor closure objects can be chained by <code>operator|</code> to produce another range adaptor closure object: if <code>C</code> and <code>D</code> are range adaptor closure objects, then <code>C | D</code> produces a range adaptor closure object <code>E</code> with the following properties:</p>
<ul>
<li> <code>E</code> stores a copy of <code>C</code> and <code>D</code>, direct-non-list-initialized from <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>decltype<span class="br0">(</span><span class="br0">(</span>C<span class="br0">)</span><span class="br0">)</span><span class="sy1">&gt;</span><span class="br0">(</span>C<span class="br0">)</span></code> and <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>decltype<span class="br0">(</span><span class="br0">(</span>D<span class="br0">)</span><span class="br0">)</span><span class="sy1">&gt;</span><span class="br0">(</span>D<span class="br0">)</span></code> respectively. If such initialization is invalid, <code>C | D</code> is also invalid. </li>
<li> Let <code>c</code> and <code>d</code> be the stored copies (with the same constness and value category as <code>E</code>), and <code>R</code> be a <a href="../ranges/range.html" title="cpp/ranges/range"><code>range</code></a> object, the following expressions are <a href="../language/expressions.html#Expression-equivalence" title="cpp/language/expressions">equivalent</a>: </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">d(c(R))
R | c | d
E(R)
R | E // R | (C | D)</pre></div> <p>Notes: <code>operator()</code> is unsupported for volatile-qualified or const-volatile-qualified version of range adaptor object closure types.</p>
<p>Objects whose type is the same as one of the following objects (ignoring cv-qualification) are range adaptor closure objects:</p>
<ul><li> unary range adaptor objects, </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <ul><li> objects of user-defined types that meet <a href="../ranges/range_adaptor_closure.html" title="cpp/ranges/range adaptor closure">the requirements of implementing a range adaptor closure object</a>, </li></ul> </td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td>
</tr> </table> <ul>
<li> the results of binding trailing arguments by range adaptor objects, and </li>
<li> the results of chaining two range adaptor closure objects by <code>operator|</code>. </li>
</ul>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/named_req/RangeAdaptorClosureObject" class="_attribution-link">https://en.cppreference.com/w/cpp/named_req/RangeAdaptorClosureObject</a>
  </p>
</div>
