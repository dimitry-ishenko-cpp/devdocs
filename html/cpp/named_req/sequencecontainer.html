    <h1 id="firstHeading" class="firstHeading">C++ named requirements: SequenceContainer</h1>            <p>A <strong class="selflink">SequenceContainer</strong> is a <a href="container.html" title="cpp/named req/Container">Container</a> that stores objects of the same type in a linear arrangement.</p>
<h3 id="Requirements"> Requirements</h3> <table class="t-dsc-begin"> <tr> <td colspan="2"> <h5 id="Legend">  Legend </h5> </td>
</tr> <tr class="t-dsc"> <td> <code>X</code> </td> <td> A sequence container class </td>
</tr> <tr class="t-dsc"> <td> <code>T</code> </td> <td> The element type of <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>a</code> </td> <td> A value of type <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>u</code> </td> <td> The name of a declared variable </td>
</tr> <tr class="t-dsc"> <td> <code>A</code> </td> <td> The allocator type of <code>X</code>: <ul>
<li> <code>X::allocator_type</code> if it exists, </li>
<li> otherwise <a href="http://en.cppreference.com/w/cpp/memory/allocator"><span class="kw702">std::<span class="me2">allocator</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> </li>
</ul> </td>
</tr> <tr class="t-dsc"> <td> <code>i</code>, <code>j</code> </td> <td> <a href="inputiterator.html" title="cpp/named req/InputIterator">LegacyInputIterators</a> such that <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> is a <a href="../iterator.html#Ranges" title="cpp/iterator">valid range</a> and that the iterators refer to elements implicitly convertible to <code>value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>rg</code> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td> A value of a type <code>R</code> that models <a href="../ranges/to.html#container_compatible_range" title="cpp/ranges/to"><code>container-compatible-range</code></a><code>&lt;T&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>il</code> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td> An object of type <a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><span class="kw962">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>value_type<span class="sy1">&gt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>n</code> </td> <td> A value of type <code>X::size_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>p</code> </td> <td> A valid <a href="../iterator.html" title="cpp/iterator">const iterator</a> into <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>q</code> </td> <td> A <a href="../iterator.html#Dereferenceability_and_validity" title="cpp/iterator">valid dereferenceable</a> const iterator into <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>q1</code>, <code>q2</code> </td> <td> Two const iterators into <code>a</code> such that <code>[</code><code>q1</code><code>, </code><code>q2</code><code>)</code> is a valid range </td>
</tr> <tr class="t-dsc"> <td> <code>t</code> </td> <td> An <a href="../language/value_category.html" title="cpp/language/value category">lvalue</a><span class="t-rev-inl t-since-cxx11"><span> or const rvalue</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> of type <code>X::value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>rv</code> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td> A non-const rvalue of type <code>X::value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>Args</code> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td> A template parameter pack </td>
</tr> <tr class="t-dsc"> <td> <code>args</code> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td> A function parameter pack with the pattern <code>Arg&amp;&amp;</code> </td>
</tr> </table> <p>The type <code>X</code> satisfies SequenceContainer if</p>
<ul>
<li> The type <code>X</code> satisfies <a href="container.html" title="cpp/named req/Container">Container</a>, and </li>
<li> The following statements and expressions must be valid and have their specified effects for all sequence containers<span class="t-rev-inl t-since-cxx11"><span> except <code><a href="../container/array.html" title="cpp/container/array">std::array</a></code> (see <a href="#NotesT1">notes</a>)</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>: </li>
</ul> <table class="wikitable"> <tr> <th colspan="2">Statement </th> <th>Effects </th> <th colspan="2"> Conditions<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup> </th>
</tr> <tr> <td rowspan="2" colspan="2">
<code>X u(n, t)</code> </td> <td rowspan="2">Constructs the sequence container holding <code>n</code> copies of <code>t</code>. </td> <td>Pre </td> <td>
<code>T</code> is <a href="copyinsertable.html" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code>. </td>
</tr> <tr> <td>Post </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>u.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, u.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><br>    == n</code> is <code>true</code>. </td>
</tr> <tr> <td rowspan="2" colspan="2">
<code>X u(i, j)</code> </td> <td rowspan="2">Constructs the sequence container equal, element-wise, to the range <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code>. </td> <td>Pre </td> <td>
<code>T</code> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> from <code>*i</code> into <code>X</code>. </td>
</tr> <tr> <td>Post </td> <td>
<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>u.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, u.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><br>    <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>i, j<span class="br0">)</span></code> is <code>true</code>. </td>
</tr> <tr> <th>Expression </th> <th>Type </th> <th>Effects </th> <th colspan="2">Conditions </th>
</tr> <tr> <td rowspan="2">
<code>X<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/ranges/from_range"><span class="kw3504">std::<span class="me2">from_range</span></span></a>, rg<span class="br0">)</span></code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td rowspan="2">
<code>X</code> </td> <td rowspan="2">Constructs the sequence container equal, element-wise, to the range <code>rg</code>. </td> <td>Pre </td> <td>
<code>T</code> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>. </td>
</tr> <tr> <td>Post </td> <td> <ul>
<li> Each iterator in the range <code>rg</code> is dereferenced once. </li>
<li> <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>begin<span class="br0">(</span><span class="br0">)</span>, end<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><br>    <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code> is <code>true</code>. </li>
</ul> </td>
</tr> <tr> <td>
<code>X(il)</code><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td>
<code>X</code> </td> <td>Equivalent to <code>X(il.begin(),  il.end())</code>. </td> <td colspan="2" class="table-na"> <small>No explicit requirement</small> </td>
</tr> <tr> <td rowspan="2">
<code>a = il</code><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td rowspan="2">
<code>X&amp;</code> </td> <td rowspan="2">Assigns the range represented by <code>il</code> into <code>a</code>.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2">[2]</a></sup> </td> <td>Pre </td> <td>
<code>T</code> is <a href="copyinsertable.html" title="cpp/named req/CopyInsertable">CopyInsertable</a> and <a href="copyassignable.html" title="cpp/named req/CopyAssignable">CopyAssignable</a>. </td>
</tr> <tr> <td>Post </td> <td>Existing elements of <code>a</code> are destroyed or assigned to. </td>
</tr> <tr> <td rowspan="2">
<code>a.emplace(p, args)</code><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td rowspan="2">
<code>iterator</code> </td> <td rowspan="2">Insert an object of type <code>T</code>, constructed with <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span></code> before <code>p</code>. </td> <td>Pre </td> <td>
<code>T</code> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a>. </td>
</tr> <tr> <td>Post </td> <td>The returned iterator points at the element constructed from <code>args</code> into <code>a</code>. </td>
</tr> <tr> <td rowspan="2">
<code>a.insert(p, t)</code> </td> <td rowspan="2">
<code>iterator</code> </td> <td rowspan="2">Inserts a copy of <code>t</code> before <code>p</code>. </td> <td>Pre </td> <td>
<code>T</code> is <a href="copyinsertable.html" title="cpp/named req/CopyInsertable">CopyInsertable</a>. </td>
</tr> <tr> <td>Post </td> <td>The returned iterator points at the copy of <code>t</code> inserted into <code>a</code>. </td>
</tr> <tr> <td rowspan="2">
<code>a.insert(p, rv)</code><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td rowspan="2">
<code>iterator</code> </td> <td rowspan="2">Inserts a copy of <code>rv</code> before <code>p</code>, possibly using move semantics. </td> <td>Pre </td> <td>
<code>T</code> is <a href="moveinsertable.html" title="cpp/named req/MoveInsertable">MoveInsertable</a>. </td>
</tr> <tr> <td>Post </td> <td>The returned iterator points at the copy of <code>rv</code> inserted into <code>a</code>. </td>
</tr> <tr> <td rowspan="2">
<code>a.insert(p, n, t)</code> </td> <td rowspan="2">
<code>iterator</code> </td> <td rowspan="2">Inserts <code>n</code> copies of <code>t</code> before <code>p</code>. </td> <td>Pre </td> <td>
<code>T</code> is <a href="copyinsertable.html" title="cpp/named req/CopyInsertable">CopyInsertable</a> and <a href="copyassignable.html" title="cpp/named req/CopyAssignable">CopyAssignable</a>. </td>
</tr> <tr> <td>Post </td> <td>The returned iterator points at the copy of the first element inserted into <code>a</code> or is <code>p</code> for <code>n == 0</code>. </td>
</tr> <tr> <td rowspan="2">
<code>a.insert(p, i, j)</code> </td> <td rowspan="2">
<code>iterator</code> </td> <td rowspan="2">Inserts copies of elements in <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> before <code>p</code>. </td> <td>Pre </td> <td>
<code>T</code> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> and <code>i</code> and <code>j</code> are not in <code>a</code>. </td>
</tr> <tr> <td>Post </td> <td> <ul>
<li> Each iterator in <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> is dereferenced once. </li>
<li> The returned iterator points at the copy of the first element inserted into <code>a</code> or is <code>p</code> for <code>i == j</code>. </li>
</ul> </td>
</tr> <tr> <td rowspan="2">
<code>a.insert_range(p, rg)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td rowspan="2">
<code>iterator</code> </td> <td rowspan="2">Inserts copies of elements in <code>rg</code> before <code>p</code>. </td> <td>Pre </td> <td> <ul>
<li> <code>T</code> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>. </li>
<li> <code>rg</code> and <code>a</code> do not overlap. </li>
</ul> </td>
</tr> <tr> <td>Post </td> <td> <ul>
<li> Each iterator in the range <code>rg</code> is dereferenced once. </li>
<li> The returned iterator points at the copy of the first element inserted into <code>a</code> or at <code>p</code> if <code>rg</code> is empty. </li>
</ul> </td>
</tr> <tr> <td rowspan="2">
<code>a.insert(p, il)</code><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td rowspan="2">
<code>iterator</code> </td> <td rowspan="2">Equivalent to <code>a.insert(p,         il.begin(),         il.end())</code>. </td> <td>Pre </td> <td class="table-na"> <small>No explicit requirement</small> </td>
</tr> <tr> <td>Post </td> <td>The returned iterator points at the copy of the first element inserted into <code>a</code> or is <code>p</code> if <code>il</code> is empty. </td>
</tr> <tr> <td rowspan="2">
<code>a.erase(q)</code> </td> <td rowspan="2">
<code>iterator</code> </td> <td rowspan="2">Erases the element pointed to by <code>q</code>. </td> <td>Pre </td> <td class="table-na"> <small>No explicit requirement</small> </td>
</tr> <tr> <td>Post </td> <td>The returned iterator points at the element that was immediately following <code>q</code> prior to erasure, or <code>a.end()</code> if no such element exists. </td>
</tr> <tr> <td rowspan="2">
<code>a.erase(q1, q2)</code> </td> <td rowspan="2">
<code>iterator</code> </td> <td rowspan="2">Erases elements in <code>[</code><code>q1</code><code>, </code><code>q2</code><code>)</code>. </td> <td>Pre </td> <td class="table-na"> <small>No explicit requirement</small> </td>
</tr> <tr> <td>Post </td> <td>The returned iterator points at the element that was pointed by <code>q2</code> prior to any erasure, or <code>a.end()</code> if no such element exists. </td>
</tr> <tr> <td rowspan="2">
<code>a.clear()</code> </td> <td rowspan="2">
<span class="kw4">void</span> </td> <td rowspan="2">Destroys all elements in <code>a</code>. </td> <td>Pre </td> <td class="table-na"> <small>No explicit requirement</small> </td>
</tr> <tr> <td>Post </td> <td> <ul>
<li> All references, pointers, and iterators are invalidated, including the end iterator. </li>
<li> <code>a.empty()</code> is <code>true</code>. </li>
</ul> </td>
</tr> <tr> <td rowspan="2">
<code>a.assign(i, j)</code> </td> <td rowspan="2">
<span class="kw4">void</span> </td> <td rowspan="2">Replaces elements in <code>a</code> with a copy of <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code>. </td> <td>Pre </td> <td> <ul>
<li> <code>T</code> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a>. </li>
<li> <code>i</code> and <code>j</code> are not in <code>a</code>. </li>
</ul> </td>
</tr> <tr> <td>Post </td> <td>Each iterator in <code>[</code><code>i</code><code>, </code><code>j</code><code>)</code> is dereferenced once. </td>
</tr> <tr> <td rowspan="2">
<code>a.assign_range(rg)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td rowspan="2">
<span class="kw4">void</span> </td> <td rowspan="2">Replaces elements in <code>a</code> with a copy of each element in <code>rg</code>. </td> <td>Pre </td> <td> <ul>
<li> <code>T</code><sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[3]</a></sup> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>. </li>
<li> <code>rg</code> and <code>a</code> do not overlap. </li>
</ul> </td>
</tr> <tr> <td>Post </td> <td> <ul>
<li> Each iterator in the range <code>rg</code> is dereferenced once. </li>
<li> All references, pointers, and iterators are invalidated. </li>
</ul> </td>
</tr> <tr> <td>
<code>a.assign(il)</code><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td>
<span class="kw4">void</span> </td> <td>Equivalent to <code>a.assign(il.begin(),         il.end())</code>. </td> <td colspan="2" class="table-na"> <small>No explicit requirement</small> </td>
</tr> <tr> <td rowspan="2">
<code>a.assign(n, t)</code> </td> <td rowspan="2">
<span class="kw4">void</span> </td> <td rowspan="2">Replaces elements in <code>a</code> with <code>n</code> copies of <code>t</code>. </td> <td>Pre </td> <td>
<code>T</code> is <a href="copyinsertable.html" title="cpp/named req/CopyInsertable">CopyInsertable</a> and <a href="copyassignable.html" title="cpp/named req/CopyAssignable">CopyAssignable</a>. </td>
</tr> <tr> <td>Post </td> <td class="table-na"> <small>No explicit requirement</small> </td>
</tr> <tr> <th colspan="5">Notes  </th>
</tr> <tr> <td colspan="5">
<ol class="references"> <li id="cite_note-1"> <span class="reference-text">For an expression whose effect is equivalent to some other operations, the conditions of the expressions inside those operations are inherited on top of the conditions listed in the table.</span> </li> <li id="cite_note-2"> <span class="reference-text"><code><a href="../container/array.html" title="cpp/container/array">std::array</a></code> supports assignment from a braced-init-list, but not from an <code><a href="../utility/initializer_list.html" title="cpp/utility/initializer list">std::initializer_list</a></code>.</span> </li> <li id="cite_note-3"> <span class="reference-text"><code>T</code> and <code>R</code> are types such that <code>ranges<span class="sy4">::</span><span class="me2">assignable_from</span><span class="sy1">&lt;</span>T<span class="sy3">&amp;</span>, <a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2895">ranges::<span class="me2">range_reference_t</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span></code> is modeled.</span> </li> </ol> </td>
</tr>
</table> <h4 id="Optional_operations"> Optional operations</h4> <p>The following expressions must be valid and have their specified effects for the sequence containers named, all operations <span class="t-rev-inl t-since-cxx23"><span>except <code>prepend_range</code> and <code>append_range</code></span><span><span class="t-mark-rev t-since-cxx23">(since C++23)</span></span></span> take amortized constant time:</p>
<table class="wikitable"> <tr> <th>Expression</th> <th>Type</th> <th>Effects</th> <th> Preconditions<sup id="cite_ref-4" class="reference"><a href="#cite_note-4">[1]</a></sup>
</th> <th>Containers </th>
</tr> <tr> <td>
<code>a.front()</code> </td> <td>
<code>reference</code>, or <p><code>const_reference</code> for <span class="kw4">const</span> <code>a</code></p>
</td> <td>Returns <code>*a.begin()</code>. </td> <td class="table-na"> <small>No explicit requirement</small> </td> <td>
<code><a href="../string/basic_string.html" title="cpp/string/basic string">std::basic_string</a></code> <code><a href="../container/array.html" title="cpp/container/array">std::array</a></code> <code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/forward_list.html" title="cpp/container/forward list">std::forward_list</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> <code><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></code> </td>
</tr> <tr> <td>
<code>a.back()</code> </td> <td>
<code>reference</code>, or <p><code>const_reference</code> for <span class="kw4">const</span> <code>a</code></p>
</td> <td>Equivalent to <code>auto tmp = a.end();--tmp;return *tmp;</code>. </td> <td class="table-na"> <small>No explicit requirement</small> </td> <td>
<code><a href="../string/basic_string.html" title="cpp/string/basic string">std::basic_string</a></code> <code><a href="../container/array.html" title="cpp/container/array">std::array</a></code> <code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> <code><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></code> </td>
</tr> <tr> <td>
<code>a.emplace_front(args)</code><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td>
<span class="kw4">void</span> </td> <td>Prepends a <code>T</code> constructed with <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><br>    (args)...</code>. </td> <td>
<code>T</code> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>args</code>. </td> <td>
<code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/forward_list.html" title="cpp/container/forward list">std::forward_list</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> </td>
</tr> <tr> <td>
<code>a.emplace_back(args)</code><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td>
<span class="kw4">void</span> </td> <td>Appends a <code>T</code> constructed with <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><br>    (args)...</code>. </td> <td>
<code>T</code> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>args</code>. </td> <td>
<code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> <code><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></code> </td>
</tr> <tr> <td>
<code>a.push_front(t)</code> </td> <td>
<span class="kw4">void</span> </td> <td>Prepends a copy of <code>t</code>. </td> <td>
<code>T</code> is <a href="copyinsertable.html" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code>. </td> <td>
<code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/forward_list.html" title="cpp/container/forward list">std::forward_list</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> </td>
</tr> <tr> <td>
<code>a.push_front(rv)</code><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td>
<span class="kw4">void</span> </td> <td>Prepends a copy of <code>rv</code>, possibly using move semantics. </td> <td>
<code>T</code> is <a href="moveinsertable.html" title="cpp/named req/MoveInsertable">MoveInsertable</a> into <code>X</code>. </td> <td>
<code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/forward_list.html" title="cpp/container/forward list">std::forward_list</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> </td>
</tr> <tr> <td>
<code>a.prepend_range(rg)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td>
<span class="kw4">void</span> </td> <td>Inserts<sup id="cite_ref-range_5-0" class="reference"><a href="#cite_note-range-5">[2]</a></sup> copies of elements in <code>rg</code> before <code>begin()</code>, each iterator in <code>rg</code> is dereferenced once. </td> <td>
<code>T</code> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>. </td> <td>
<code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/forward_list.html" title="cpp/container/forward list">std::forward_list</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> </td>
</tr> <tr> <td>
<code>a.push_back(t)</code> </td> <td>
<span class="kw4">void</span> </td> <td>Appends a copy of <code>t</code>. </td> <td>
<code>T</code> is <a href="copyinsertable.html" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code>. </td> <td>
<code><a href="../string/basic_string.html" title="cpp/string/basic string">std::basic_string</a></code> <code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> <code><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></code> </td>
</tr> <tr> <td>
<code>a.push_back(rv)</code><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> <td>
<span class="kw4">void</span> </td> <td>Appends a copy of <code>rv</code>, possibly using move semantics. </td> <td>
<code>T</code> is <a href="moveinsertable.html" title="cpp/named req/MoveInsertable">MoveInsertable</a> into <code>X</code>. </td> <td>
<code><a href="../string/basic_string.html" title="cpp/string/basic string">std::basic_string</a></code> <code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> <code><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></code> </td>
</tr> <tr> <td>
<code>a.append_range(rg)</code><br><span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> <td>
<span class="kw4">void</span> </td> <td>Inserts<sup id="cite_ref-range_5-1" class="reference"><a href="#cite_note-range-5">[2]</a></sup> copies of elements in <code>rg</code> before <code>end()</code> dereferencing each iterator in <code>rg</code> once. </td> <td>
<code>T</code> is <a href="emplaceconstructible.html" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">ranges::<span class="me2">begin</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>. </td> <td>
<code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> <code><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></code> </td>
</tr> <tr> <td>
<code>a.pop_front()</code> </td> <td>
<span class="kw4">void</span> </td> <td>Destroys the first element. </td> <td>
<code>a.empty()</code> is <code>false</code>. </td> <td>
<code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/forward_list.html" title="cpp/container/forward list">std::forward_list</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> </td>
</tr> <tr> <td>
<code>a.pop_back()</code> </td> <td>
<span class="kw4">void</span> </td> <td>Destroys the last element. </td> <td>
<code>a.empty()</code> is <code>false</code>. </td> <td>
<code><a href="../string/basic_string.html" title="cpp/string/basic string">std::basic_string</a></code> <code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code> <code><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></code> </td>
</tr> <tr> <td>
<code>a[n]</code> </td> <td>
<code>reference</code>, or <p><code>const_reference</code> for <span class="kw4">const</span> <code>a</code></p>
</td> <td>Equivalent to <code>return    *(a.begin() + n);</code>. </td> <td class="table-na"> <small>No explicit requirement</small> </td> <td>
<code><a href="../string/basic_string.html" title="cpp/string/basic string">std::basic_string</a></code> <code><a href="../container/array.html" title="cpp/container/array">std::array</a></code> <code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></code> </td>
</tr> <tr> <td>
<code>a.at(n)</code> </td> <td>
<code>reference</code>, or <p><code>const_reference</code> for <span class="kw4">const</span> <code>a</code></p>
</td> <td>Returns <code>*(a.begin() + n)</code>, throws <code><a href="../error/out_of_range.html" title="cpp/error/out of range">std::out_of_range</a></code> if <code>n &gt;= size()</code>. </td> <td class="table-na"> <small>No explicit requirement</small> </td> <td>
<code><a href="../string/basic_string.html" title="cpp/string/basic string">std::basic_string</a></code> <code><a href="../container/array.html" title="cpp/container/array">std::array</a></code> <code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> <code><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></code> </td>
</tr> <tr> <th colspan="5">Notes </th>
</tr> <tr> <td colspan="5">
<ol class="references"> <li id="cite_note-4"> <span class="reference-text">For an expression whose effect is equivalent to some other operations, the preconditions of the expressions inside those operations are inherited on top of the preconditions listed in the table.</span> </li> <li id="cite_note-range-5"> <span class="reference-text">Insertion order, relative to order of elements in <code>rg</code>, is non-reversing.</span> </li> </ol> </td>
</tr>
</table> <p>Additionally, for every sequence container:</p>
<ul><li> A constructor template that takes two input iterators and the member function template overloads of <code>insert</code>, <code>append</code>, <code>assign</code>, <code>replace</code> that take two input iterators do not participate in overload resolution if the corresponding template argument does not satisfy <a href="inputiterator.html" title="cpp/named req/InputIterator">LegacyInputIterator</a>. </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> A deduction guide that has either a <a href="inputiterator.html" title="cpp/named req/InputIterator">LegacyInputIterator</a> or an <code>Allocator</code> template parameter does not participate in overload resolution if the type that does not qualify as an input iterator or an allocator respectively is deduced for that parameter. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Sequence_containers_in_the_standard_library"> Sequence containers in the standard library</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../string/basic_string.html" title="cpp/string/basic string"> <span class="t-lines"><span>basic_string</span></span></a></div> </td> <td> stores and manipulates sequences of characters <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/array.html" title="cpp/container/array"> <span class="t-lines"><span>array</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> static contiguous array <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/vector.html" title="cpp/container/vector"> <span class="t-lines"><span>vector</span></span></a></div> </td> <td> dynamic contiguous array <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/deque.html" title="cpp/container/deque"> <span class="t-lines"><span>deque</span></span></a></div> </td> <td> double-ended queue <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/forward_list.html" title="cpp/container/forward list"> <span class="t-lines"><span>forward_list</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> singly-linked list <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/list.html" title="cpp/container/list"> <span class="t-lines"><span>list</span></span></a></div> </td> <td> doubly-linked list <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table> <h4 id="Trade-offs_.2F_usage_notes"> Trade-offs / usage notes</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <code><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></code> </td> <td> Fast access but mostly inefficient insertions/deletions </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../container/array.html" title="cpp/container/array">std::array</a></code> </td> <td> Fast access but fixed number of elements </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../container/list.html" title="cpp/container/list">std::list</a></code><br><code><a href="../container/forward_list.html" title="cpp/container/forward list">std::forward_list</a></code> </td> <td> Efficient insertion/deletion in the middle of the sequence </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></code> </td> <td> Efficient insertion/deletion at the beginning and at the end of the sequence </td>
</tr> </table> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue139">LWG 139</a> </td> <td>C++98 </td> <td>the optional operations were not required to<br>be implemented for the designated containers </td> <td>required with<br>amortized time </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue149">LWG 149</a> </td> <td>C++98 </td> <td>
<code>a.insert(p, t)</code> returned <code>iterator</code> while<br><code>a.insert(p, n, t)</code> and <code>a.insert(p, n, t)</code> returned <span class="kw4">void</span> </td> <td>they all return<br><code>iterator</code> </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue151">LWG 151</a> </td> <td>C++98 </td> <td>
<code>q1</code> was required to be dereferenceable<sup id="cite_ref-6" class="reference"><a href="#cite_note-6">[1]</a></sup> </td> <td>it can be non-dereferenceable </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue355">LWG 355</a> </td> <td>C++98 </td> <td>calling <code>a.back()</code> or <code>a.pop_back()</code> would<br>execute <code>--a.end()</code>, which is dangerous<sup id="cite_ref-7" class="reference"><a href="#cite_note-7">[2]</a></sup> </td> <td>decrements a copy<br>of <code>a.end()</code> instead </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue589">LWG 589</a> </td> <td>C++98 </td> <td>the elements that <code>i</code> and <code>j</code> refer to<br>might not be convertible to <code>value_type</code> </td> <td>they are implicitly<br>convertible to <code>value_type</code> </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue3927">LWG 3927</a> </td> <td>C++98 </td> <td>operator<span class="br0">[</span><span class="br0">]</span> had no implicit requirement </td> <td>added the implicit requirement </td>
</tr>
</table> <ol class="references"> <li id="cite_note-6"> <span class="reference-text">It is a defect because it makes the behavior of <code>a.erase(a.begin(), a.end())</code> undefined is <code>a</code> is an empty container.</span> </li> <li id="cite_note-7"> <span class="reference-text">If the type of <code>a.end()</code> is a fundamental type, <code>--a.end()</code> is ill-formed. It is dangerous when the type of <code>a</code> is templated, in this case this bug can be difficult to be found.</span> </li> </ol>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/named_req/SequenceContainer" class="_attribution-link">https://en.cppreference.com/w/cpp/named_req/SequenceContainer</a>
  </p>
</div>
