    <h1 id="firstHeading" class="firstHeading">std::multimap&lt;Key,T,Compare,Allocator&gt;::insert</h1>            <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">iterator insert( const value_type&amp; value );</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator insert( value_type&amp;&amp; value );</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class P &gt;
iterator insert( P&amp;&amp; value );</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(4)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">iterator insert( iterator pos, const value_type&amp; value );</pre></td>  <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator insert( const_iterator pos, const value_type&amp; value );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator insert( const_iterator pos, value_type&amp;&amp; value );</pre>
</td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class P &gt;
iterator insert( const_iterator pos, P&amp;&amp; value );</pre>
</td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">template&lt; class InputIt &gt;
void insert( InputIt first, InputIt last );</pre>
</td> <td> (7) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void insert( std::initializer_list&lt;value_type&gt; ilist );</pre>
</td> <td> (8) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator insert( node_type&amp;&amp; nh );</pre>
</td> <td> (9) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator insert( const_iterator pos, node_type&amp;&amp; nh );</pre>
</td> <td> (10) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Inserts element(s) into the container.</p>
<div class="t-li1">
<span class="t-li">1-3)</span> Inserts <code>value</code>. If the container has elements with equivalent key, inserts at the upper bound of that range.</div> <div class="t-li1">
 Overload <span class="t-v">(3)</span> is equivalent to <code>emplace<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>P<span class="sy1">&gt;</span><span class="br0">(</span>value<span class="br0">)</span><span class="br0">)</span></code> and only participates in overload resolution if <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">std::<span class="me2">is_constructible</span></span></a><span class="sy1">&lt;</span>value_type, P<span class="sy3">&amp;&amp;</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span> <span class="sy1">==</span> <span class="kw2">true</span></code>.</div> <div class="t-li1">
<span class="t-li">4-6)</span> Inserts <code>value</code> in the position as close as possible to the position just prior to <code>pos</code>.</div> <div class="t-li1">
 Overload <span class="t-v">(6)</span> is equivalent to <code>emplace_hint<span class="br0">(</span>hint, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>P<span class="sy1">&gt;</span><span class="br0">(</span>value<span class="br0">)</span><span class="br0">)</span></code> and only participates in overload resolution if <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">std::<span class="me2">is_constructible</span></span></a><span class="sy1">&lt;</span>value_type, P<span class="sy3">&amp;&amp;</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span> <span class="sy1">==</span> <span class="kw2">true</span></code>.</div> <div class="t-li1">
<span class="t-li">7)</span> Inserts elements from range <code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</div> <div class="t-li1">
<span class="t-li">8)</span> Inserts elements from initializer list <code>ilist</code>.</div> <div class="t-li1">
<span class="t-li">9)</span> If <code>nh</code> is an empty <a href="../node_handle.html" title="cpp/container/node handle">node handle</a>, does nothing. Otherwise, inserts the element owned by <code>nh</code> into the container and returns an iterator pointing at the inserted element. If a range containing elements with keys equivalent to <code>nh.key()</code> exists in the container, the element is inserted at the end of that range. The behavior is undefined if <code>nh</code> is not empty and <code>get_allocator() != nh.get_allocator()</code>.</div> <div class="t-li1">
<span class="t-li">10)</span> If <code>nh</code> is an empty <a href="../node_handle.html" title="cpp/container/node handle">node handle</a>, does nothing and returns the end iterator. Otherwise, inserts the element owned by <code>nh</code> into the container, and returns the iterator pointing to the element with key equivalent to <code>nh.key()</code>. The element is inserted as close as possible to the position just prior to <code>pos</code>. The behavior is undefined if <code>nh</code> is not empty and <code>get_allocator() != nh.get_allocator()</code>.</div> <p>No iterators or references are invalidated. <span class="t-rev-inl t-since-cxx17"><span>If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span></p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> pos </td> <td> - </td> <td> iterator to the position before which the new element will be inserted </td>
</tr> <tr class="t-par"> <td> value </td> <td> - </td> <td> element value to insert </td>
</tr> <tr class="t-par"> <td> first, last </td> <td> - </td> <td> range of elements to insert </td>
</tr> <tr class="t-par"> <td> ilist </td> <td> - </td> <td> initializer list to insert the values from </td>
</tr> <tr class="t-par"> <td> nh </td> <td> - </td> <td> a compatible <a href="../node_handle.html" title="cpp/container/node handle">node handle</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3"> Type requirements </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>InputIt</code> must meet the requirements of <a href="../../named_req/inputiterator.html" title="cpp/named req/InputIterator">LegacyInputIterator</a>. </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1-6)</span> Returns an iterator to the inserted element.</div> <div class="t-li1">
<span class="t-li">7,8)</span> (none)</div> <div class="t-li1">
<span class="t-li">9,10)</span> End iterator if <code>nh</code> was empty, iterator pointing to the inserted element otherwise.</div> <h3 id="Exceptions"> Exceptions</h3> <div class="t-li1">
<span class="t-li">1-6)</span> If an exception is thrown by any operation, the insertion has no effect.</div> <div class="t-li1">
<span class="t-li">7,8)</span> No exception safety guarantee.</div> <div class="t-li1">
<span class="t-li">9,10)</span> If an exception is thrown by any operation, the insertion has no effect.</div> <h3 id="Complexity"> Complexity</h3> <div class="t-li1">
<span class="t-li">1-3)</span> <code>O(log(size()))</code>
</div> <div class="t-li1">
<span class="t-li">4-6)</span> Amortized constant if the insertion happens in the position just before <code>pos</code>, <code>O(log(size()))</code> otherwise.</div> <div class="t-li1">
<span class="t-li">7,8)</span> <code>O(N·log(size() + N))</code>, where <code>N</code> is the number of elements to insert.</div> <div class="t-li1">
<span class="t-li">9)</span> <code>O(log(size()))</code>
</div> <div class="t-li1">
<span class="t-li">10)</span> Amortized constant if the insertion happens in the position just before <code>pos</code>, <code>O(log(size()))</code> otherwise.</div> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;utility&gt;
 
template&lt;class M&gt;
void print(const std::string_view rem, const M&amp; mmap)
{
    std::cout &lt;&lt; rem &lt;&lt; ' ';
    for (const auto&amp; e : mmap)
        std::cout &lt;&lt; '{' &lt;&lt; e.first &lt;&lt; ',' &lt;&lt; e.second &lt;&lt; "} ";
    std::cout &lt;&lt; '\n';
}
 
int main()
{
    // list-initialize
    std::multimap&lt;int, std::string, std::greater&lt;int&gt;&gt; mmap
        {{2, "foo"}, {2, "bar"}, {3, "baz"}, {1, "abc"}, {5, "def"}};
    print("#1", mmap);
 
    // insert using value_type
    mmap.insert(decltype(mmap)::value_type(5, "pqr"));
    print("#2", mmap);
 
    // insert using pair
    mmap.insert(std::pair{6, "uvw"});
    print("#3", mmap);
 
    mmap.insert({7, "xyz"});
    print("#4", mmap);
 
    // insert using initializer_list
    mmap.insert({{5, "one"}, {5, "two"}});
    print("#5", mmap);
 
    // insert using a pair of iterators
    mmap.clear();
    const auto il = {std::pair{1, "ä"}, {2, "ё"}, {2, "ö"}, {3, "ü"}};
    mmap.insert(il.begin(), il.end());
    print("#6", mmap);
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">#1 {5,def} {3,baz} {2,foo} {2,bar} {1,abc}
#2 {5,def} {5,pqr} {3,baz} {2,foo} {2,bar} {1,abc}
#3 {6,uvw} {5,def} {5,pqr} {3,baz} {2,foo} {2,bar} {1,abc}
#4 {7,xyz} {6,uvw} {5,def} {5,pqr} {3,baz} {2,foo} {2,bar} {1,abc}
#5 {7,xyz} {6,uvw} {5,def} {5,pqr} {5,one} {5,two} {3,baz} {2,foo} {2,bar} {1,abc}
#6 {3,ü} {2,ё} {2,ö} {1,ä}</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue233">LWG 233</a> </td> <td>C++98 </td> <td>
<code>pos</code> was just a hint, it could be totally ignored </td> <td>the insertion is required to<br>be as close as possible to the<br>position just prior to <code>pos</code> </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue264">LWG 264</a> </td> <td>C++98 </td> <td>the complexity of overload <span class="t-v">(5)</span> was required to be linear if<br>the range <code>[</code><code>first</code><code>, </code><code>last</code><code>)</code> is sorted according to <code>Compare</code> </td> <td>removed the linear requirement<br>in this special case </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue371">LWG 371</a> </td> <td>C++98 </td> <td>the order of equivalent elements<br>was not guaranteed to be preserved </td> <td>required to be preserved </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2005">LWG 2005</a> </td> <td>C++11 </td> <td>overloads <span class="t-v">(3,6)</span> were poorly described </td> <td>improved the description </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace.html" title="cpp/container/multimap/emplace"> <span class="t-lines"><span>emplace</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> constructs element in-place <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="emplace_hint.html" title="cpp/container/multimap/emplace hint"> <span class="t-lines"><span>emplace_hint</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> constructs elements in-place using a hint <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/inserter.html" title="cpp/iterator/inserter"> <span class="t-lines"><span>inserter</span></span></a></div> </td> <td> creates a <code><a href="../../iterator/insert_iterator.html" title="cpp/iterator/insert iterator">std::insert_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/container/multimap/insert" class="_attribution-link">https://en.cppreference.com/w/cpp/container/multimap/insert</a>
  </p>
</div>
