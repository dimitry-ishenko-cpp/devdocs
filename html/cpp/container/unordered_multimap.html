    <h1 id="firstHeading" class="firstHeading">std::unordered_multimap</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/unordered_map.html" title="cpp/header/unordered map">&lt;unordered_map&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt;
    class Key,
    class T,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;
&gt; class unordered_multimap;</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">namespace pmr {
    template&lt;
        class Key,
        class T,
        class Hash = std::hash&lt;Key&gt;,
        class Pred = std::equal_to&lt;Key&gt;
    &gt; using unordered_multimap =
          std::unordered_multimap&lt;Key, T, Hash, Pred,
              std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;;
}</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p><code>std::unordered_multimap</code> is an unordered associative container that supports equivalent keys (an unordered_multimap may contain multiple copies of each key value) and that associates values of another type with the keys. The unordered_multimap class supports forward iterators. Search, insertion, and removal have average constant-time complexity.</p>
<p>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. This allows fast access to individual elements, since once the hash is computed, it refers to the exact bucket the element is placed into.</p>
<p>The iteration order of this container is not required to be stable (so, for example, <code><a href="../algorithm/equal.html" title="cpp/algorithm/equal">std::equal</a></code> cannot be used to compare two <code>std::unordered_multimap</code>s), except that every group of elements whose keys compare <i>equivalent</i> (compare equal with <code><a href="unordered_multimap/key_eq.html" title="cpp/container/unordered multimap/key eq">key_eq()</a></code> as the comparator) forms a contiguous subrange in the iteration order, also accessible with <code><a href="unordered_multimap/equal_range.html" title="cpp/container/unordered multimap/equal range">equal_range()</a></code>.</p>
<p><code>std::unordered_multimap</code> meets the requirements of <a href="../named_req/container.html" title="cpp/named req/Container">Container</a>, <a href="../named_req/allocatorawarecontainer.html" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a>, <a href="../named_req/unorderedassociativecontainer.html" title="cpp/named req/UnorderedAssociativeContainer">UnorderedAssociativeContainer</a>.</p>
<h3 id="Template_parameters"> Template parameters</h3>  <h3 id="Member_types"> Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>key_type</code> </td> <td> <code>Key</code> </td>
</tr> <tr class="t-dsc"> <td> <code>mapped_type</code> </td> <td> <code>T</code> </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> Key, T<span class="sy1">&gt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>size_type</code> </td> <td> Unsigned integer type (usually <code><a href="../types/size_t.html" title="cpp/types/size t">std::size_t</a></code>) </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> Signed integer type (usually <code><a href="../types/ptrdiff_t.html" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code>) </td>
</tr> <tr class="t-dsc"> <td> <code>hasher</code> </td> <td> <code>Hash</code> </td>
</tr> <tr class="t-dsc"> <td> <code>key_equal</code> </td> <td> <code>KeyEqual</code> </td>
</tr> <tr class="t-dsc"> <td> <code>allocator_type</code> </td> <td> <code>Allocator</code> </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> </td> <td> <code>value_type&amp;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>const_reference</code> </td> <td> <span class="kw4">const</span> value_type<span class="sy3">&amp;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>Allocator<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">pointer</span> </td>
</tr> <tr class="t-dsc"> <td> <code>const_pointer</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>Allocator<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_pointer</span> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator</code> </td> <td> <a href="../named_req/forwarditerator.html" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a> to <code>value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>const_iterator</code> </td> <td> <a href="../named_req/forwarditerator.html" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a> to <span class="kw4">const</span> value_type </td>
</tr> <tr class="t-dsc"> <td> <code>local_iterator</code> </td> <td> An iterator type whose category, value, difference, pointer and<br>reference types are the same as <code>iterator</code>. This iterator<br>can be used to iterate through a single bucket but not across buckets </td>
</tr> <tr class="t-dsc"> <td> <code>const_local_iterator</code> </td> <td> An iterator type whose category, value, difference, pointer and<br>reference types are the same as <code>const_iterator</code>. This iterator<br>can be used to iterate through a single bucket but not across buckets </td>
</tr> <tr class="t-dsc"> <td> <code>node_type</code> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td> a specialization of <a href="node_handle.html" title="cpp/container/node handle">node handle</a> representing a container node </td>
</tr> </table> <h3 id="Member_functions"> Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/unordered_multimap.html" title="cpp/container/unordered multimap/unordered multimap"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> constructs the <code>unordered_multimap</code> <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/~unordered_multimap.html" title="cpp/container/unordered multimap/~unordered multimap"> <span class="t-lines"><span>(destructor)</span></span></a></div> </td> <td> destructs the <code>unordered_multimap</code> <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/operator=.html" title="cpp/container/unordered multimap/operator="> <span class="t-lines"><span>operator=</span></span></a></div> </td> <td> assigns values to the container <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/get_allocator.html" title="cpp/container/unordered multimap/get allocator"> <span class="t-lines"><span>get_allocator</span></span></a></div> </td> <td> returns the associated allocator <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Iterators">  Iterators </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/begin.html" title="cpp/container/unordered multimap/begin"> <span class="t-lines"><span>begin</span><span>cbegin</span></span></a></div> </td> <td> returns an iterator to the beginning <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/end.html" title="cpp/container/unordered multimap/end"> <span class="t-lines"><span>end</span><span>cend</span></span></a></div> </td> <td> returns an iterator to the end <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Capacity">  Capacity </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/empty.html" title="cpp/container/unordered multimap/empty"> <span class="t-lines"><span>empty</span></span></a></div> </td> <td> checks whether the container is empty <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/size.html" title="cpp/container/unordered multimap/size"> <span class="t-lines"><span>size</span></span></a></div> </td> <td> returns the number of elements <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/max_size.html" title="cpp/container/unordered multimap/max size"> <span class="t-lines"><span>max_size</span></span></a></div> </td> <td> returns the maximum possible number of elements <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Modifiers">  Modifiers </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/clear.html" title="cpp/container/unordered multimap/clear"> <span class="t-lines"><span>clear</span></span></a></div> </td> <td> clears the contents <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/insert.html" title="cpp/container/unordered multimap/insert"> <span class="t-lines"><span>insert</span></span></a></div> </td> <td> inserts elements <span class="t-rev-inl t-since-cxx17"><span>or nodes</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/insert_range.html" title="cpp/container/unordered multimap/insert range"> <span class="t-lines"><span>insert_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> inserts a range of elements <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/emplace.html" title="cpp/container/unordered multimap/emplace"> <span class="t-lines"><span>emplace</span></span></a></div> </td> <td> constructs element in-place <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/emplace_hint.html" title="cpp/container/unordered multimap/emplace hint"> <span class="t-lines"><span>emplace_hint</span></span></a></div> </td> <td> constructs elements in-place using a hint <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/erase.html" title="cpp/container/unordered multimap/erase"> <span class="t-lines"><span>erase</span></span></a></div> </td> <td> erases elements <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/swap.html" title="cpp/container/unordered multimap/swap"> <span class="t-lines"><span>swap</span></span></a></div> </td> <td> swaps the contents <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/extract.html" title="cpp/container/unordered multimap/extract"> <span class="t-lines"><span>extract</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> extracts nodes from the container <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/merge.html" title="cpp/container/unordered multimap/merge"> <span class="t-lines"><span>merge</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> splices nodes from another container <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Lookup">  Lookup </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/count.html" title="cpp/container/unordered multimap/count"> <span class="t-lines"><span>count</span></span></a></div> </td> <td> returns the number of elements matching specific key <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/find.html" title="cpp/container/unordered multimap/find"> <span class="t-lines"><span>find</span></span></a></div> </td> <td> finds element with specific key <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/contains.html" title="cpp/container/unordered multimap/contains"> <span class="t-lines"><span>contains</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> checks if the container contains element with specific key <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/equal_range.html" title="cpp/container/unordered multimap/equal range"> <span class="t-lines"><span>equal_range</span></span></a></div> </td> <td> returns range of elements matching a specific key <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Bucket_interface">  Bucket interface </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/begin2.html" title="cpp/container/unordered multimap/begin2"> <span class="t-lines"><span>begin<span class="t-dsc-small">(size_type)</span></span><span>cbegin<span class="t-dsc-small">(size_type)</span></span></span></a></div> </td> <td> returns an iterator to the beginning of the specified bucket <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/end2.html" title="cpp/container/unordered multimap/end2"> <span class="t-lines"><span>end<span class="t-dsc-small">(size_type)</span></span><span>cend<span class="t-dsc-small">(size_type)</span></span></span></a></div> </td> <td> returns an iterator to the end of the specified bucket <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/bucket_count.html" title="cpp/container/unordered multimap/bucket count"> <span class="t-lines"><span>bucket_count</span></span></a></div> </td> <td> returns the number of buckets <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/max_bucket_count.html" title="cpp/container/unordered multimap/max bucket count"> <span class="t-lines"><span>max_bucket_count</span></span></a></div> </td> <td> returns the maximum number of buckets <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/bucket_size.html" title="cpp/container/unordered multimap/bucket size"> <span class="t-lines"><span>bucket_size</span></span></a></div> </td> <td> returns the number of elements in specific bucket <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/bucket.html" title="cpp/container/unordered multimap/bucket"> <span class="t-lines"><span>bucket</span></span></a></div> </td> <td> returns the bucket for specific key <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Hash_policy">  Hash policy </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/load_factor.html" title="cpp/container/unordered multimap/load factor"> <span class="t-lines"><span>load_factor</span></span></a></div> </td> <td> returns average number of elements per bucket <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/max_load_factor.html" title="cpp/container/unordered multimap/max load factor"> <span class="t-lines"><span>max_load_factor</span></span></a></div> </td> <td> manages maximum average number of elements per bucket <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/rehash.html" title="cpp/container/unordered multimap/rehash"> <span class="t-lines"><span>rehash</span></span></a></div> </td> <td> reserves at least the specified number of buckets and regenerates the hash table <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/reserve.html" title="cpp/container/unordered multimap/reserve"> <span class="t-lines"><span>reserve</span></span></a></div> </td> <td> reserves space for at least the specified number of elements and regenerates the hash table <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Observers">  Observers </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/hash_function.html" title="cpp/container/unordered multimap/hash function"> <span class="t-lines"><span>hash_function</span></span></a></div> </td> <td> returns function used to hash the keys <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/key_eq.html" title="cpp/container/unordered multimap/key eq"> <span class="t-lines"><span>key_eq</span></span></a></div> </td> <td> returns the function used to compare keys for equality <br> <span class="t-mark">(public member function)</span>  </td>
</tr> </table> <h3 id="Non-member_functions"> Non-member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/operator_cmp.html" title="cpp/container/unordered multimap/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares the values in the unordered_multimap <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/swap2.html" title="cpp/container/unordered multimap/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::unordered_multimap)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> specializes the <code><a href="../algorithm/swap.html" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/erase_if.html" title="cpp/container/unordered multimap/erase if"> <span class="t-lines"><span>erase_if<span class="t-dsc-small">(std::unordered_multimap)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> erases all elements satisfying specific criteria <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <h3 id="Deduction_guides"> <a href="unordered_multimap/deduction_guides.html" title="cpp/container/unordered multimap/deduction guides">Deduction guides</a>
</h3> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Notes"> Notes</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test.html" title="cpp/utility/feature test">Feature-test</a> macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Feature </th>
</tr> <tr> <td><a href="../feature_test.html#cpp_lib_containers_ranges" title="cpp/feature test"><code>__cpp_lib_containers_ranges</code></a></td> <td><span class="nu0">202202L</span></td> <td><span class="t-mark">(C++23)</span></td> <td>Ranges construction and insertion for containers </td>
</tr>
</table> <h3 id="Example"> Example</h3>  <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2050">LWG 2050</a> </td> <td>C++11 </td> <td>the definitions of <code>reference</code>, <code>const_reference</code>, <code>pointer</code><br>and <code>const_pointer</code> were based on <code>allocator_type</code> </td> <td>based on <code>value_type</code> and<br><code><a href="../memory/allocator_traits.html" title="cpp/memory/allocator traits">std::allocator_traits</a></code> </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/container/unordered_multimap" class="_attribution-link">https://en.cppreference.com/w/cpp/container/unordered_multimap</a>
  </p>
</div>
