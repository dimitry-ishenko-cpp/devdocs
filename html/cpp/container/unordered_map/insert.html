    <h1 id="firstHeading" class="firstHeading">std::unordered_map&lt;Key,T,Hash,KeyEqual,Allocator&gt;::insert</h1>            <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std::pair&lt;iterator,bool&gt; insert( const value_type&amp; value );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">std::pair&lt;iterator,bool&gt; insert( value_type&amp;&amp; value );</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class P &gt;
std::pair&lt;iterator,bool&gt; insert( P&amp;&amp; value );</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator insert( const_iterator hint, const value_type&amp; value );</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator insert( const_iterator hint, value_type&amp;&amp; value );</pre>
</td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class P &gt;
iterator insert( const_iterator hint, P&amp;&amp; value );</pre>
</td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class InputIt &gt;
void insert( InputIt first, InputIt last );</pre>
</td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void insert( std::initializer_list&lt;value_type&gt; ilist );</pre>
</td> <td> (8) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">insert_return_type insert( node_type&amp;&amp; nh );</pre>
</td> <td> (9) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator insert( const_iterator hint, node_type&amp;&amp; nh );</pre>
</td> <td> (10) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.</p>
<div class="t-li1">
<span class="t-li">1-3)</span> Inserts <code>value</code>.</div> <div class="t-li1">
 Overload <span class="t-v">(3)</span> is equivalent to <code>emplace<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>P<span class="sy1">&gt;</span><span class="br0">(</span>value<span class="br0">)</span><span class="br0">)</span></code> and only participates in overload resolution if <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">std::<span class="me2">is_constructible</span></span></a><span class="sy1">&lt;</span>value_type, P<span class="sy3">&amp;&amp;</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span> <span class="sy1">==</span> <span class="kw2">true</span></code>.</div> <div class="t-li1">
<span class="t-li">4-6)</span> Inserts <code>value</code>, using <code>hint</code> as a non-binding suggestion to where the search should start.</div> <div class="t-li1">
 Overload <span class="t-v">(6)</span> is equivalent to <code>emplace_hint<span class="br0">(</span>hint, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>P<span class="sy1">&gt;</span><span class="br0">(</span>value<span class="br0">)</span><span class="br0">)</span></code> and only participates in overload resolution if <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">std::<span class="me2">is_constructible</span></span></a><span class="sy1">&lt;</span>value_type, P<span class="sy3">&amp;&amp;</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span> <span class="sy1">==</span> <span class="kw2">true</span></code>.</div> <div class="t-li1">
<span class="t-li">7)</span> Inserts elements from range <code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>).</div> <div class="t-li1">
 If <code>[</code><code>first</code><code>, </code><code>last</code><code>)</code> is not a <a href="../../iterator.html#Ranges" title="cpp/iterator">valid range</a>, or <code>first</code> and/or <code>last</code> are iterators into <code>*this</code>, the behavior is undefined.</div> <div class="t-li1">
<span class="t-li">8)</span> Inserts elements from initializer list <code>ilist</code>. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2844">LWG2844</a>).</div> <div class="t-li1">
<span class="t-li">9)</span> If <code>nh</code> is an empty <a href="../node_handle.html" title="cpp/container/node handle">node handle</a>, does nothing. Otherwise, inserts the element owned by <code>nh</code> into the container , if the container doesn't already contain an element with a key equivalent to <code>nh.key()</code>. The behavior is undefined if <code>nh</code> is not empty and <code>get_allocator() != nh.get_allocator()</code>.</div> <div class="t-li1">
<span class="t-li">10)</span> If <code>nh</code> is an empty <a href="../node_handle.html" title="cpp/container/node handle">node handle</a>, does nothing and returns the end iterator. Otherwise, inserts the element owned by <code>nh</code> into the container, if the container doesn't already contain an element with a key equivalent to <code>nh.key()</code>, and returns the iterator pointing to the element with key equivalent to <code>nh.key()</code>(regardless of whether the insert succeeded or failed). If the insertion succeeds, <code>nh</code> is moved from, otherwise it retains ownership of the element. <code>hint</code> is used as a non-binding suggestion to where the search should start. The behavior is undefined if <code>nh</code> is not empty and <code>get_allocator() != nh.get_allocator()</code>.</div> <p>If after the operation the new number of elements is greater than old <code><a href="max_load_factor.html" title="cpp/container/unordered map/max load factor">max_load_factor()</a> * <a href="bucket_count.html" title="cpp/container/unordered map/bucket count">bucket_count()</a></code> a rehashing takes place.<br>If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise (no rehashing), iterators are not invalidated. <span class="t-rev-inl t-since-cxx17"><span>If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span></p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> hint </td> <td> - </td> <td> iterator, used as a suggestion as to where to insert the content </td>
</tr> <tr class="t-par"> <td> value </td> <td> - </td> <td> element value to insert </td>
</tr> <tr class="t-par"> <td> first, last </td> <td> - </td> <td> range of elements to insert </td>
</tr> <tr class="t-par"> <td> ilist </td> <td> - </td> <td> initializer list to insert the values from </td>
</tr> <tr class="t-par"> <td> nh </td> <td> - </td> <td> a compatible <a href="../node_handle.html" title="cpp/container/node handle">node handle</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3"> Type requirements </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>InputIt</code> must meet the requirements of <a href="../../named_req/inputiterator.html" title="cpp/named req/InputIterator">LegacyInputIterator</a>. </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1-3)</span> Returns a <code><a href="../../utility/pair.html" title="cpp/utility/pair">std::pair</a></code> consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a <code>bool</code> denoting whether the insertion took place (<code>true</code> if insertion happened, <code>false</code> if it did not). </div> <div class="t-li1">
<span class="t-li">4-6)</span> Returns an iterator to the inserted element, or to the element that prevented the insertion.</div> <div class="t-li1">
<span class="t-li">7,8)</span> (none)</div> <span class="t-li">9)</span> Returns an <a href="../unordered_map.html#Member_types" title="cpp/container/unordered map"><code>insert_return_type</code></a> with the members initialized as follows: <ul>
<li> If <code>nh</code> is empty, <code>inserted</code> is <code>false</code>, <code>position</code> is <code>end()</code>, and <code>node</code> is empty. </li>
<li> Otherwise if the insertion took place, <code>inserted</code> is <code>true</code>, <code>position</code> points to the inserted element, and <code>node</code> is empty. </li>
<li> If the insertion failed, <code>inserted</code> is <code>false</code>, <code>node</code> has the previous value of <code>nh</code>, and <code>position</code> points to an element with a key equivalent to <code>nh.key()</code>.</li>
</ul> <div class="t-li1">
<span class="t-li">10)</span> End iterator if <code>nh</code> was empty, iterator pointing to the inserted element if insertion took place, and iterator pointing to an element with a key equivalent to <code>nh.key()</code> if it failed.</div> <h3 id="Exceptions"> Exceptions</h3> <div class="t-li1">
<span class="t-li">1-6)</span> If an exception is thrown for any reason, these functions have no effect (<a href="../../language/exceptions.html#Exception_safety" title="cpp/language/exceptions">strong exception safety guarantee</a>).</div> <div class="t-li1">
<span class="t-li">7,8)</span> No exception safety guarantee.</div> <div class="t-li1">
<span class="t-li">9,10)</span> If an exception is thrown for any reason, these functions have no effect (<a href="../../language/exceptions.html#Exception_safety" title="cpp/language/exceptions">strong exception safety guarantee</a>).</div> <h3 id="Complexity"> Complexity</h3> <div class="t-li1">
<span class="t-li">1-6)</span> Average case: <code>O(1)</code>, worst case <code>O(size())</code>.</div> <div class="t-li1">
<span class="t-li">7,8)</span> Average case: <code>O(N)</code>, where N is the number of elements to insert. Worst case: <code>O(N * size() + N)</code>.</div> <div class="t-li1">
<span class="t-li">9,10)</span> Average case: <code>O(1)</code>, worst case <code>O(size())</code>.</div> <h3 id="Notes"> Notes</h3> <p>The hinted insert <span class="t-v">(4-6)</span> does not return a boolean in order to be signature-compatible with positional insert on sequential containers, such as <code><a href="../vector/insert.html" title="cpp/container/vector/insert">std::vector::insert</a></code>. This makes it possible to create generic inserters such as <code><a href="../../iterator/inserter.html" title="cpp/iterator/inserter">std::inserter</a></code>. One way to check success of a hinted insert is to compare <a href="size.html" title="cpp/container/unordered map/size"><code>size()</code></a> before and after.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
 
int main ()
{
    std::unordered_map&lt;int, std::string&gt; dict = {{1, "one"}, {2, "two"}};
    dict.insert({3, "three"});
    dict.insert(std::make_pair(4, "four"));
    dict.insert({{4, "another four"}, {5, "five"}});
 
    bool ok = dict.insert({1, "another one"}).second;
    std::cout &lt;&lt; "inserting 1 =&gt; \"another one\" " 
              &lt;&lt; (ok ? "succeeded" : "failed") &lt;&lt; '\n';
 
    std::cout &lt;&lt; "contents:\n";
    for (auto&amp; p : dict)
        std::cout &lt;&lt; ' ' &lt;&lt; p.first &lt;&lt; " =&gt; " &lt;&lt; p.second &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">inserting 1 =&gt; "another one" failed
contents:
 5 =&gt; five
 1 =&gt; one
 2 =&gt; two
 3 =&gt; three
 4 =&gt; four</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2005">LWG 2005</a> </td> <td>C++11 </td> <td>overloads <span class="t-v">(3,6)</span> would only particiate in overload<br>resolution if <code>P</code> is implicitly convertible to <code>value_type</code> </td> <td>only participates if <code>value_type</code><br>is constructible from <code>P&amp;&amp;</code> </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace.html" title="cpp/container/unordered map/emplace"> <span class="t-lines"><span>emplace</span></span></a></div> </td> <td> constructs element in-place <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="emplace_hint.html" title="cpp/container/unordered map/emplace hint"> <span class="t-lines"><span>emplace_hint</span></span></a></div> </td> <td> constructs elements in-place using a hint <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="insert_or_assign.html" title="cpp/container/unordered map/insert or assign"> <span class="t-lines"><span>insert_or_assign</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> inserts an element or assigns to the current element if the key already exists <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/inserter.html" title="cpp/iterator/inserter"> <span class="t-lines"><span>inserter</span></span></a></div> </td> <td> creates a <code><a href="../../iterator/insert_iterator.html" title="cpp/iterator/insert iterator">std::insert_iterator</a></code> of type inferred from the argument <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/container/unordered_map/insert" class="_attribution-link">https://en.cppreference.com/w/cpp/container/unordered_map/insert</a>
  </p>
</div>
