    <h1 id="firstHeading" class="firstHeading">Lambda expressions <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</h1>            <p>Constructs a <a href="https://en.wikipedia.org/wiki/Closure_(computer_science)" class="extiw" title="enwiki:Closure (computer science)">closure</a>: an unnamed function object capable of capturing variables in scope.</p>
<h3 id="Syntax"> Syntax</h3> <h5 id="Lambda_expressions_without_an_explicit_template_parameter_list_.28possibly_non-generic.29"> Lambda expressions without an explicit template parameter list (possibly non-generic)</h5> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar">captures</span> ﻿<code>]</code> <span class="t-spar">front-attr</span> ﻿<span class="t-mark">(optional)</span> <code>(</code><span class="t-spar">params</span> ﻿<code>)</code> <span class="t-spar">specs</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">exception</span> ﻿<span class="t-mark">(optional)</span><br><span class="t-spar">back-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">trailing-type</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">requires</span> ﻿<span class="t-mark">(optional)</span> <code>{</code> <span class="t-spar">body</span> <code>}</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar">captures</span> ﻿<code>] {</code> <span class="t-spar">body</span> <code>}</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-until-cxx23">(until C++23)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar">captures</span> ﻿<code>]</code> <span class="t-spar">front-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">trailing-type</span> ﻿<span class="t-mark">(optional)</span> <code>{</code> <span class="t-spar">body</span> <code>}</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar">captures</span> ﻿<code>]</code> <span class="t-spar">front-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">exception</span><br><span class="t-spar">back-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">trailing-type</span> ﻿<span class="t-mark">(optional)</span> <code>{</code> <span class="t-spar">body</span> <code>}</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar">captures</span> ﻿<code>]</code> <span class="t-spar">front-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">specs</span> <span class="t-spar">exception</span> ﻿<span class="t-mark">(optional)</span><br><span class="t-spar">back-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">trailing-type</span> ﻿<span class="t-mark">(optional)</span> <code>{</code> <span class="t-spar">body</span> <code>}</code> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td>
</tr> 
</table> <h5 id="Lambda_expressions_with_an_explicit_template_parameter_list_.28always_generic.29_.28since_C.2B.2B20.29"> Lambda expressions with an explicit template parameter list (always generic) <span class="t-mark-rev t-since-cxx20">(since C++20)</span>
</h5> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar">captures</span> ﻿<code>] &lt;</code><span class="t-spar">tparams</span> ﻿<code>&gt;</code> <span class="t-spar">t-requires</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">front-attr</span> ﻿<span class="t-mark">(optional)</span> <code>(</code><span class="t-spar">params</span> ﻿<code>)</code> <span class="t-spar">specs</span> ﻿<span class="t-mark">(optional)</span><br><span class="t-spar">exception</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">back-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">trailing-type</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">requires</span> ﻿<span class="t-mark">(optional)</span> <code>{</code> <span class="t-spar">body</span> <code>}</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar">captures</span> ﻿<code>] &lt;</code><span class="t-spar">tparams</span> ﻿<code>&gt;</code> <span class="t-spar">t-requires</span> ﻿<span class="t-mark">(optional)</span> <code>{</code> <span class="t-spar">body</span> <code>}</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-until-cxx23">(until C++23)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar">captures</span> ﻿<code>] &lt;</code><span class="t-spar">tparams</span> ﻿<code>&gt;</code> <span class="t-spar">t-requires</span> ﻿<span class="t-mark">(optional)</span><br><span class="t-spar">front-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">trailing-type</span> ﻿<span class="t-mark">(optional)</span> <code>{</code> <span class="t-spar">body</span> <code>}</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar">captures</span> ﻿<code>] &lt;</code><span class="t-spar">tparams</span> ﻿<code>&gt;</code> <span class="t-spar">t-requires</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">front-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">exception</span><br><span class="t-spar">back-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">trailing-type</span> ﻿<span class="t-mark">(optional)</span> <code>{</code> <span class="t-spar">body</span> <code>}</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar">captures</span> ﻿<code>] &lt;</code><span class="t-spar">tparams</span> ﻿<code>&gt;</code> <span class="t-spar">t-requires</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">front-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">specs</span> <span class="t-spar">exception</span> ﻿<span class="t-mark">(optional)</span><br><span class="t-spar">back-attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">trailing-type</span> ﻿<span class="t-mark">(optional)</span> <code>{</code> <span class="t-spar">body</span> <code>}</code> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> The lambda expression with a parameter list.</div> <div class="t-li1">
<span class="t-li">2-4)</span> The lambda expression without a parameter list.</div> <div class="t-li2">
<span class="t-li">2)</span> The simplest syntax. <span class="t-spar">back-attr</span> cannot be applied.</div> <div class="t-li2">
<span class="t-li">3,4)</span> <span class="t-spar">back-attr</span> can only be applied if any of <span class="t-spar">specs</span> and <span class="t-spar">exception</span> is present.</div> <h3 id="Explanation"> Explanation</h3> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">captures</span> </td> <td> - </td> <td> a comma-separated list of zero or more <a href="#Lambda_capture">captures</a>, optionally beginning with a <span class="t-spar">capture-default</span>. <p>See <a href="#Lambda_capture">below</a> for the detailed description of captures.</p>
<p>A lambda expression can use a variable without capturing it if the variable</p>
<ul>
<li> is a non-local variable or has static or thread local <a href="storage_duration.html" title="cpp/language/storage duration">storage duration</a> (in which case the variable cannot be captured), or </li>
<li> is a reference that has been initialized with a <a href="constant_expression.html#Constant_expression" title="cpp/language/constant expression">constant expression</a>. </li>
</ul> <p>A lambda expression can read the value of a variable without capturing it if the variable</p>
<ul>
<li> has const non-volatile integral or enumeration type and has been initialized with a <a href="constant_expression.html#Constant_expression" title="cpp/language/constant expression">constant expression</a>, or </li>
<li> is constexpr and has no mutable members. </li>
</ul> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">tparams</span> </td> <td> - </td> <td> a non-empty comma-separated list of <a href="template_parameters.html" title="cpp/language/template parameters">template parameters</a>, used to provide names to the template parameters of a generic lambda (see <code>ClosureType::operator()</code> below) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">t-requires</span> </td> <td> - </td> <td> adds <a href="constraints.html" title="cpp/language/constraints">constraints</a> to <span class="t-spar">tparams</span> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>If <span class="t-spar">t-requires</span> ends with an attribute specifier sequence, the attributes in the sequence are treated as attributes in <span class="t-spar">front-attr</span>.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">front-attr</span> </td> <td> - </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> an <a href="attributes.html" title="cpp/language/attributes">attribute specifier sequence</a> applies to <code>operator()</code> of the closure type (and thus the <code>[[<a href="attributes/noreturn.html" title="cpp/language/attributes/noreturn">noreturn</a>]]</code> attribute can be used) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">params</span> </td> <td> - </td> <td> the <a href="function.html#Parameter_list" title="cpp/language/function">parameter list</a> of <code>operator()</code> of the closure type </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">specs</span> </td> <td> - </td> <td> A list of the following specifiers, each specifier is allowed at most once in each sequence. If not provided, the objects captured by copy are const in the lambda body. <ul><li> <code>mutable</code>: allows <span class="t-spar">body</span> to modify the objects captured by copy, and to call their non-const member functions </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> <code>constexpr</code>: explicitly specifies that <code>operator()</code> is a <a href="constexpr.html#constexpr_function" title="cpp/language/constexpr">constexpr function</a>. When this specifier is not present, <code>operator()</code> will be constexpr anyway, if it happens to satisfy all constexpr function requirements </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> <code>consteval</code>: specifies that <code>operator()</code> is an <a href="consteval.html" title="cpp/language/consteval">immediate function</a>. consteval and <span class="kw4">constexpr</span> cannot be used at the same time. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <ul><li> <code>static</code>: specifies that <code>operator()</code> is a <a href="static.html#Static_member_functions" title="cpp/language/static">static member function</a>. mutable and <span class="kw4">static</span> cannot be used at the same time, and <span class="t-spar">captures</span> must be empty if <span class="kw4">static</span> is present. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">exception</span> </td> <td> - </td> <td> provides<span class="t-rev-inl t-until-cxx20"><span> the <a href="except_spec.html" title="cpp/language/except spec">dynamic exception specification</a> or</span><span><span class="t-mark-rev t-until-cxx20">(until C++20)</span></span></span> the <a href="noexcept_spec.html" title="cpp/language/noexcept spec">noexcept specifier</a> for <code>operator()</code> of the closure type </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">back-attr</span> </td> <td> - </td> <td> an <a href="attributes.html" title="cpp/language/attributes">attribute specifier sequence</a> applies to the type of <code>operator()</code> of the closure type (and thus the <code>[[<a href="attributes/noreturn.html" title="cpp/language/attributes/noreturn">noreturn</a>]]</code> attribute cannot be used) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">trailing-type</span> </td> <td> - </td> <td> <code>-&gt;</code> <span class="t-spar">ret</span>, where <span class="t-spar">ret</span> specifies the return type </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">requires</span> </td> <td> - </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> adds <a href="constraints.html" title="cpp/language/constraints">constraints</a> to <code>operator()</code> of the closure type </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">body</span> </td> <td> - </td> <td> function body </td>
</tr>
</table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>If <a href="auto.html" title="cpp/language/auto"><code>auto</code></a> is used as a type of a parameter<span class="t-rev-inl t-since-cxx20"><span> or an explicit template parameter list is provided</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, the lambda is a <i>generic lambda</i>.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>A variable <code>__func__</code> is implicitly defined at the beginning of <span class="t-spar">body</span>, with semantics as described <a href="function.html#func" title="cpp/language/function">here</a>.</p>
<p>The lambda expression is a prvalue expression of unique unnamed non-<a href="union.html" title="cpp/language/union">union</a> non-<a href="aggregate_initialization.html" title="cpp/language/aggregate initialization">aggregate</a> non-<a href="template_parameters.html#Non-type_template_parameter" title="cpp/language/template parameters">structural</a> class type, known as <i>closure type</i>, which is declared (for the purposes of <a href="adl.html" title="cpp/language/adl">ADL</a>) in the smallest block scope, class scope, or namespace scope that contains the lambda expression. The closure type has the following members, they cannot be <span class="t-rev-inl t-since-cxx14"><span><a href="function_template.html#Explicit_instantiation" title="cpp/language/function template">explicitly instantiated</a>, <a href="template_specialization.html" title="cpp/language/template specialization">explicitly specialized</a>, or</span><span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span> named in a <a href="friend.html" title="cpp/language/friend">friend declaration</a>:</p>
<div class="t-member"> <h2 id="ClosureType::operator.28.29.28params.29"> ClosureType::operator()(<span class="t-spar">params</span>)</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">ret operator()(params) { body }</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark">(static and const may be present, see below)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">template&lt;template-params&gt;
ret operator()(params) { body }</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> <br><span class="t-mark">(generic lambda, static and const may be present, see below)</span> </td> </tr>  </table> <p>Executes the body of the lambda-expression, when invoked. When accessing a variable, accesses its captured copy (for the entities captured by copy), or the original object (for the entities captured by reference).</p>
<p>The parameter list of <code>operator()</code> is <span class="t-spar">params</span> if it is provided, otherwise the parameter list is empty.</p>
<p>The return type of <code>operator()</code> is the type specified in <span class="t-spar">trailing-type</span>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <p>If <span class="t-spar">trailing-type</span> is not provided, the return type of <code>operator()</code> is determinted as follows:</p>
<ul>
<li> If <span class="t-spar">body</span> only consists of a <a href="return.html" title="cpp/language/return">return statement</a> that returns an expression, the return type is the type of that expression after lvalue-to-rvalue conversion, array-to-pointer conversion and function-to-pointer conversion. </li>
<li> Otherwise, the return type is <span class="kw4">void</span>. </li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx14">
<td> <p>If <span class="t-spar">trailing-type</span> is not provided, or provided as <code>-&gt; auto</code>, the return type of <code>operator()</code> is automatically <a href="function.html#Return_type_deduction" title="cpp/language/function">deduced</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>Unless the keyword mutable was used in the lambda specifiers, the cv-qualifier of <code>operator()</code> is <span class="kw4">const</span> and the objects that were captured by copy are non-modifiable from inside this <code>operator()</code>. Explicit <span class="kw4">const</span> qualifier is not allowed. <code>operator()</code> is never virtual and cannot have the <span class="kw4">volatile</span> qualifier.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p><code>operator()</code> is always constexpr if it satisfies the requirements of a <a href="constexpr.html" title="cpp/language/constexpr">constexpr function</a>. It is also constexpr if the keyword <span class="kw4">constexpr</span> was used in the lambda specifiers.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code>operator()</code> is an <a href="consteval.html" title="cpp/language/consteval">immediate function</a> if the keyword consteval was used in the lambda specifiers.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p><code>operator()</code> is a <a href="static.html#Static_member_functions" title="cpp/language/static">static member function</a> if the keyword <span class="kw4">static</span> was used in the lambda specifiers.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>For each parameter in <span class="t-spar">params</span> whose type is specified as <span class="kw4">auto</span>, an invented template parameter is added to <span class="t-spar">template-params</span>, in order of appearance. The invented template parameter may be a <a href="parameter_pack.html" title="cpp/language/parameter pack">parameter pack</a> if the corresponding function member of <span class="t-spar">params</span> is a function parameter pack.</p>
<div class="cpp source-cpp"><pre data-language="cpp">// generic lambda, operator() is a template with two parameters
auto glambda = [](auto a, auto&amp;&amp; b) { return a &lt; b; };
bool b = glambda(3, 3.14); // OK
 
// generic lambda, operator() is a template with one parameter
auto vglambda = [](auto printer)
{
    return [=](auto&amp;&amp;... ts) // generic lambda, ts is a parameter pack
    { 
        printer(std::forward&lt;decltype(ts)&gt;(ts)...);
        // nullary lambda (takes no parameters):
        return [=] { printer(ts...); };
    };
};
 
auto p = vglambda([](auto v1, auto v2, auto v3)
{
    std::cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3;
});
 
auto q = p(1, 'a', 3.14); // outputs 1a3.14
q();                      // outputs 1a3.14</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>If the lambda definition uses an explicit template parameter list, that template parameter list is used with <code>operator()</code>. For each parameter in <span class="t-spar">params</span> whose type is specified as <span class="kw4">auto</span>, an additional invented template parameter is appended to the end of that template parameter list:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// generic lambda, operator() is a template with two parameters
auto glambda = []&lt;class T&gt;(T a, auto&amp;&amp; b) { return a &lt; b; };
 
// generic lambda, operator() is a template with one parameter pack
auto f = []&lt;typename... Ts&gt;(Ts&amp;&amp;... ts)
{
    return foo(std::forward&lt;Ts&gt;(ts)...);
};</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>The exception specification <span class="t-spar">exception</span> on the lambda-expression applies to <code>operator()</code>.</p>
<p>For the purpose of <a href="lookup.html" title="cpp/language/lookup">name lookup</a>, determining the type and value of the <a href="this.html" title="cpp/language/this"><code>this</code> pointer</a> and for accessing non-static class members, the body of the closure type's <code>operator()</code> is considered in the context of the lambda-expression.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct X
{
    int x, y;
    int operator()(int);
    void f()
    {
        // the context of the following lambda is the member function X::f
        [=]() -&gt; int
        {
            return operator()(this-&gt;x + y); // X::operator()(this-&gt;x + (*this).y)
                                            // this has type X*
        };
    }
};</pre></div> <h3 id="Dangling_references"> Dangling references</h3> <p>If a non-reference entity is captured by reference, implicitly or explicitly, and <code>operator()</code> of the closure object is invoked after the entity's lifetime has ended, undefined behavior occurs. The C++ closures do not extend the lifetimes of objects captured by reference.</p>
<p>Same applies to the lifetime of the current <code>*this</code> object captured via <code>this</code>.</p>
</div> <div class="t-member"> <h2 id="ClosureType::operator_ret.28.2A.29.28params.29.28.29"> ClosureType::operator <span class="t-spar">ret</span>(*)(<span class="t-spar">params</span>)()</h2> <table class="t-dcl-begin"> <tr class="t-dcl-h"> <td> capture-less non-generic lambda</td> <td></td> <td></td> </tr>   <tr class="t-dcl t-until-cxx17"> <td><pre data-language="cpp">using F = ret(*)(params);
operator F() const noexcept;</pre></td> <td class="t-dcl-nopad"> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">using F = ret(*)(params);
constexpr operator F() const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  <tr class="t-dcl-h"> <td> capture-less generic lambda</td> <td></td> <td></td> </tr>   <tr class="t-dcl t-since-cxx14 t-until-cxx17"> <td><pre data-language="cpp">template&lt;template-params&gt; using fptr_t = /* see below */;
template&lt;template-params&gt;
operator fptr_t&lt;template-params&gt;() const noexcept;</pre></td> <td class="t-dcl-nopad"> </td> <td>
<span class="t-mark-rev t-since-cxx14">(since C++14)</span> <br><span class="t-mark-rev t-until-cxx17">(until C++17)</span>
</td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt;template-params&gt; using fptr_t = /* see below */;
template&lt;template-params&gt;
constexpr operator fptr_t&lt;template-params&gt;() const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>   </table> <p>This <a href="cast_operator.html" title="cpp/language/cast operator">user-defined conversion function</a> is only defined if the capture list of the lambda-expression is empty. It is a public, <span class="t-rev-inl t-since-cxx17"><span>constexpr,</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> non-virtual, non-explicit, const noexcept member function of the closure object.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>This function is an <a href="consteval.html" title="cpp/language/consteval">immediate function</a> if the function call operator (or specialization, for generic lambdas) is an immediate function.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>A generic captureless lambda has a user-defined conversion function template with the same invented template parameter list as <code>operator()</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f1(int (*)(int)) {}
void f2(char (*)(int)) {}
void h(int (*)(int)) {}  // #1
void h(char (*)(int)) {} // #2
 
auto glambda = [](auto a) { return a; };
f1(glambda); // OK
f2(glambda); // error: not convertible
h(glambda);  // OK: calls #1 since #2 is not convertible
 
int&amp; (*fpi)(int*) = [](auto* a) -&gt; auto&amp; { return *a; }; // OK</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <p>The value returned by the conversion function is a pointer to a function with C++ <a href="language_linkage.html" title="cpp/language/language linkage">language linkage</a> that, when invoked, has the same effect as invoking the closure type's function call operator on a default-constructed instance of the closure type.</p>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx14 t-until-cxx23">
<td> <p>The value returned by the conversion function (template) is a pointer to a function with C++ <a href="language_linkage.html" title="cpp/language/language linkage">language linkage</a> that, when invoked, has the same effect as:</p>
<ul>
<li> for non-generic lambdas, invoking the closure type's <code>operator()</code> on a default-constructed instance of the closure type. </li>
<li> for generic lambdas, invoking the generic lambda's corresponding <code>operator()</code> specialization on a default-constructed instance of the closure type. </li>
</ul> </td> <td>
<span class="t-mark-rev t-since-cxx14">(since C++14)</span><br><span class="t-mark-rev t-until-cxx23">(until C++23)</span>
</td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>The value returned by the conversion function (template) is</p>
<ul>
<li> if <code>operator()</code> is static, a pointer to that <code>operator()</code> with C++ <a href="language_linkage.html" title="cpp/language/language linkage">language linkage</a>, </li>
<li> otherwise, a pointer to a function with C++ <a href="language_linkage.html" title="cpp/language/language linkage">language linkage</a> that, when invoked, has the same effect as: <ul>
<li> for non-generic lambdas, invoking the closure type's <code>operator()</code> on a default-constructed instance of the closure type. </li>
<li> for generic lambdas, invoking the generic lambda's corresponding <code>operator()</code> specialization on a default-constructed instance of the closure type. </li>
</ul> </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>This function is constexpr if the function call operator (or specialization, for generic lambdas) is constexpr.</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto Fwd = [](int(*fp)(int), auto a) { return fp(a); };
auto C = [](auto a) { return a; };
static_assert(Fwd(C, 3) == 3);  // OK
 
auto NC = [](auto a) { static int s; return a; };
static_assert(Fwd(NC, 3) == 3); // error: no specialization can be
                                // constexpr because of static s</pre></div> <p>If the closure object's <code>operator()</code> has a non-throwing exception specification, then the pointer returned by this function has the type pointer to noexcept function.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> </div> <div class="t-member"> <h2 id="ClosureType::ClosureType.28.29"> ClosureType::ClosureType()</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">ClosureType() = default;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> <br><span class="t-mark">(only if no captures are specified)</span> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">ClosureType(const ClosureType&amp;) = default;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">ClosureType(ClosureType&amp;&amp;) = default;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>Closure types are not <a href="../named_req/defaultconstructible.html" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>. Closure types have no default constructor.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>If no <span class="t-spar">captures</span> are specified, the closure type has a defaulted default constructor. Otherwise, it has no default constructor (this includes the case when there is a <span class="t-spar">capture-default</span>, even if it does not actually capture anything).</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>The copy constructor and the move constructor are declared as defaulted and may be implicitly-defined according to the usual rules for <a href="copy_constructor.html" title="cpp/language/copy constructor">copy constructors</a> and <a href="move_constructor.html" title="cpp/language/move constructor">move constructors</a>.</p>
</div> <div class="t-member"> <h2 id="ClosureType::operator.3D.28const_ClosureType.26.29"> ClosureType::operator=(const ClosureType&amp;)</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">ClosureType&amp; operator=(const ClosureType&amp;) = delete;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-until-cxx20">(until C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">ClosureType&amp; operator=(const ClosureType&amp;) = default;
ClosureType&amp; operator=(ClosureType&amp;&amp;) = default;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> <br><span class="t-mark">(only if no captures are specified)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">ClosureType&amp; operator=(const ClosureType&amp;) = delete;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> <br><span class="t-mark">(otherwise)</span> </td> </tr>  </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>The copy assignment operator is defined as deleted (and the move assignment operator is not declared). Closure types are not <a href="../named_req/copyassignable.html" title="cpp/named req/CopyAssignable">CopyAssignable</a>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>If no <span class="t-spar">captures</span> are specified, the closure type has a defaulted copy assignment operator and a defaulted move assignment operator. Otherwise, it has a deleted copy assignment operator (this includes the case when there is a <span class="t-spar">capture-default</span>, even if it does not actually capture anything).</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </div> <div class="t-member"> <h2 id="ClosureType::.7EClosureType.28.29"> ClosureType::~ClosureType()</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">~ClosureType() = default;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>The destructor is implicitly-declared.</p>
</div> <div class="t-member"> <h2 id="ClosureType::Captures"> ClosureType::<span class="t-spar">Captures</span>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T1 a;
T2 b;
...</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>If the lambda-expression captures anything by copy (either implicitly with capture clause <code>[=]</code> or explicitly with a capture that does not include the character &amp;, e.g. <code>[a, b, c]</code>), the closure type includes unnamed non-static data members, declared in unspecified order, that hold copies of all entities that were so captured.</p>
<p>Those data members that correspond to captures without initializers are <a href="direct_initialization.html" title="cpp/language/direct initialization">direct-initialized</a> when the lambda-expression is evaluated. Those that correspond to captures with initializers are initialized as the initializer requires (could be copy- or direct-initialization). If an array is captured, array elements are direct-initialized in increasing index order. The order in which the data members are initialized is the order in which they are declared (which is unspecified).</p>
<p>The type of each data member is the type of the corresponding captured entity, except if the entity has reference type (in that case, references to functions are captured as lvalue references to the referenced functions, and references to objects are captured as copies of the referenced objects).</p>
<p>For the entities that are captured by reference (with the capture-default <code>[&amp;]</code> or when using the character &amp;, e.g. <code>[&amp;a, &amp;b, &amp;c]</code>), it is unspecified if additional data members are declared in the closure type<span class="t-rev-inl t-since-cxx17"><span>, but any such additional members must satisfy <a href="../named_req/literaltype.html" title="cpp/named req/LiteralType">LiteralType</a></span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</p>
</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p> Lambda-expressions are not allowed in <a href="expressions.html#Unevaluated_expressions" title="cpp/language/expressions">unevaluated expressions</a>, <a href="template_parameters.html" title="cpp/language/template parameters">template arguments</a>, <a href="type_alias.html" title="cpp/language/type alias">alias declarations</a>, <a href="typedef.html" title="cpp/language/typedef">typedef declarations</a>, and anywhere in a function (or function template) declaration except the function body and the function's <a href="default_arguments.html" title="cpp/language/default arguments">default arguments</a>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> </table> <h3 id="Lambda_capture"> Lambda capture</h3> <p>The <span class="t-spar">captures</span> is a comma-separated list of zero or more <i>captures</i>, optionally beginning with the <span class="t-spar">capture-default</span>. The capture list defines the outside variables that are accessible from within the lambda function body. The only capture defaults are</p>
<ul>
<li> <code>&amp;</code> (implicitly capture the used variables with automatic storage duration by reference) and </li>
<li> <code>=</code> (implicitly capture the used variables with automatic storage duration by copy). </li>
</ul> <p>The current object (<code>*this</code>) can be implicitly captured if either capture default is present. If implicitly captured, it is always captured by reference, even if the capture default is <code>=</code>. <span class="t-rev-inl t-since-cxx20"><span>The implicit capture of <code>*this</code> when the capture default is <code>=</code> is deprecated.</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span></p>
<p>The syntax of an individual capture in <span class="t-spar">captures</span> is</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">identifier</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">identifier</span> <code>...</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">identifier</span> <span class="t-spar">initializer</span> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>&amp;</code> <span class="t-spar">identifier</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>&amp;</code> <span class="t-spar">identifier</span> <code>...</code> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>&amp;</code> <span class="t-spar">identifier</span> <span class="t-spar">initializer</span> </td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>this</code> </td> <td> (7) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>*</code> <code>this</code> </td> <td> (8) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>...</code> <span class="t-spar">identifier</span> <span class="t-spar">initializer</span> </td> <td> (9) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>&amp;</code> <code>...</code> <span class="t-spar">identifier</span> <span class="t-spar">initializer</span> </td> <td> (10) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> simple by-copy capture</div> <div class="t-li1">
<span class="t-li">2)</span> simple by-copy capture that is a <a href="parameter_pack.html" title="cpp/language/parameter pack">pack expansion</a>
</div> <div class="t-li1">
<span class="t-li">3)</span> by-copy capture with an <a href="initialization.html" title="cpp/language/initialization">initializer</a>
</div> <div class="t-li1">
<span class="t-li">4)</span> simple by-reference capture</div> <div class="t-li1">
<span class="t-li">5)</span> simple by-reference capture that is a <a href="parameter_pack.html" title="cpp/language/parameter pack">pack expansion</a>
</div> <div class="t-li1">
<span class="t-li">6)</span> by-reference capture with an initializer</div> <div class="t-li1">
<span class="t-li">7)</span> simple by-reference capture of the current object</div> <div class="t-li1">
<span class="t-li">8)</span> simple by-copy capture of the current object</div> <div class="t-li1">
<span class="t-li">9)</span> by-copy capture with an initializer that is a pack expansion</div> <div class="t-li1">
<span class="t-li">10)</span> by-reference capture with an initializer that is a pack expansion</div> <p>If the capture-default is <code>&amp;</code>, subsequent simple captures must not begin with <code>&amp;</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct S2 { void f(int i); };
void S2::f(int i)
{
    [&amp;] {};          // OK: by-reference capture default
    [&amp;, i] {};       // OK: by-reference capture, except i is captured by copy
    [&amp;, &amp;i] {};      // Error: by-reference capture when by-reference is the default
    [&amp;, this] {};    // OK, equivalent to [&amp;]
    [&amp;, this, i] {}; // OK, equivalent to [&amp;, i]
}</pre></div> <p>If the capture-default is <code>=</code>, subsequent simple captures must begin with <code>&amp;</code><span class="t-rev-inl t-since-cxx17"><span> or be <code>*this</code></span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <span class="t-rev-inl t-since-cxx20"><span>or <code>this</code></span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct S2 { void f(int i); };
void S2::f(int i)
{
    [=] {};        // OK: by-copy capture default
    [=, &amp;i] {};    // OK: by-copy capture, except i is captured by reference
    [=, *this] {}; // until C++17: Error: invalid syntax
                   // since C++17: OK: captures the enclosing S2 by copy
    [=, this] {};  // until C++20: Error: this when = is the default
                   // since C++20: OK, same as [=]
}</pre></div> <p>Any capture may appear only once, and its name must be different from any parameter name:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct S2 { void f(int i); };
void S2::f(int i)
{
    [i, i] {};        // Error: i repeated
    [this, *this] {}; // Error: "this" repeated (C++17)
 
    [i] (int i) {};   // Error: parameter and capture have the same name
}</pre></div> <p>Only lambda-expressions defined at block scope or in a <a href="data_members.html#Member_initialization" title="cpp/language/data members">default member initializer</a> may have a capture-default or captures without initializers. For such lambda-expression, the <i>reaching scope</i> is defined as the set of enclosing scopes up to and including the innermost enclosing function (and its parameters). This includes nested block scopes and the scopes of enclosing lambdas if this lambda is nested.</p>
<p>The <span class="t-spar">identifier</span> in any capture without an initializer (other than the <code>this</code>-capture) is looked up using usual <a href="lookup.html" title="cpp/language/lookup">unqualified name lookup</a> in the <i>reaching scope</i> of the lambda. The result of the lookup must be a <a href="object.html" title="cpp/language/object">variable</a> with automatic storage duration declared in the reaching scope<span class="t-rev-inl t-since-cxx20"><span>, or a <a href="structured_binding.html" title="cpp/language/structured binding">structured binding</a> whose corresponding variable satisfies such requirements</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>. The entity is <i>explicitly captured</i>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>A capture with an initializer acts as if it declares and explicitly captures a variable declared with type specifier <a href="auto.html" title="cpp/language/auto"><code>auto</code></a> and the same initializer, whose declarative region is the body of the lambda expression (that is, it is not in scope within its initializer), except that:</p>
<ul>
<li> if the capture is by-copy, the introduced non-static data member of the closure object is another way to refer to that variable; <ul><li> in other words, the source variable does not actually exist, and the type deduction via <span class="kw4">auto</span> and the initialization are applied to the non-static data member; </li></ul> </li>
<li> if the capture is by-reference, the reference variable's lifetime ends when the lifetime of the closure object ends. </li>
</ul> <p>This is used to capture move-only types with a capture such as <code>x = std::move(x)</code>.</p>
<p>This also makes it possible to capture by const reference, with <code><span class="sy3">&amp;</span>cr <span class="sy1">=</span> <a href="http://en.cppreference.com/w/cpp/utility/as_const"><span class="kw1124">std::<span class="me2">as_const</span></span></a><span class="br0">(</span>x<span class="br0">)</span></code> or similar.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int x = 4;
 
auto y = [&amp;r = x, x = x + 1]() -&gt; int
{
    r += 2;
    return x * x;
}(); // updates ::x to 6 and initializes y to 25.</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>If a capture list has a capture-default and does not explicitly capture the enclosing object (as <code>this</code> or <code>*this</code>), or an automatic variable that is <a href="definition.html#ODR-use" title="cpp/language/definition">odr-usable</a> in the lambda body<span class="t-rev-inl t-since-cxx20"><span>, or a <a href="structured_binding.html" title="cpp/language/structured binding">structured binding</a> whose corresponding variable has atomic storage duration</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, it captures the entity <i>implicitly</i> if the entity is named in a <a href="expressions.html#Potentially-evaluated_expressions" title="cpp/language/expressions">potentially-evaluated</a> expression within an expression (including when the implicit <code>this-&gt;</code> is added before a use of non-static class member).</p>
<p>For the purpose of determining implicit captures, <a href="typeid.html" title="cpp/language/typeid"><code>typeid</code></a> is never considered to make its operands unevaluated.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Entities might be implicitly captured even if they are only named within a <a href="if.html#Constexpr_if" title="cpp/language/if">discarded statement</a> after instantiation of the lambda body.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <div class="cpp source-cpp"><pre data-language="cpp">void f(int, const int (&amp;)[2] = {}) {}   // #1
void f(const int&amp;, const int (&amp;)[1]) {} // #2
 
struct NoncopyableLiteralType
{
    constexpr explicit NoncopyableLiteralType(int n) : n_(n) {}
    NoncopyableLiteralType(const NoncopyableLiteralType&amp;) = delete;
 
    int n_;
};
 
void test()
{
    const int x = 17;
 
    auto l0 = []{ f(x); };           // OK: calls #1, does not capture x
    auto g0 = [](auto a) { f(x); };  // same as above
 
    auto l1 = [=]{ f(x); };          // OK: captures x (since P0588R1) and calls #1
                                     // the capture can be optimized away
    auto g1 = [=](auto a) { f(x); }; // same as above
 
    auto ltid = [=]{ typeid(x); };   // OK: captures x (since P0588R1)
                                     // even though x is unevaluated
                                     // the capture can be optimized away
 
    auto g2 = [=](auto a)
    {
        int selector[sizeof(a) == 1 ? 1 : 2] = {};
        f(x, selector); // OK: is a dependent expression, so captures x
    };
 
    auto g3 = [=](auto a)
    {
        typeid(a + x);  // captures x regardless of
                        // whether a + x is an unevaluated operand
    };
 
    constexpr NoncopyableLiteralType w{42};
    auto l4 = []{ return w.n_; };      // OK: w is not odr-used, capture is unnecessary
    // auto l5 = [=]{ return w.n_; };  // error: w needs to be captured by copy
}</pre></div> <p>If the body of a lambda <a href="definition.html#ODR-use" title="cpp/language/definition">odr-uses</a> an entity captured by copy, the member of the closure type is accessed. If it is not odr-using the entity, the access is to the original object:</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f(const int*);
void g()
{
    const int N = 10;
    [=]
    { 
        int arr[N]; // not an odr-use: refers to g's const int N
        f(&amp;N); // odr-use: causes N to be captured (by copy)
               // &amp;N is the address of the closure object's member N, not g's N
    }();
}</pre></div> <p>If a lambda odr-uses a reference that is captured by reference, it is using the object referred-to by the original reference, not the captured reference itself:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
auto make_function(int&amp; x)
{
    return [&amp;] { std::cout &lt;&lt; x &lt;&lt; '\n'; };
}
 
int main()
{
    int i = 3;
    auto f = make_function(i); // the use of x in f binds directly to i
    i = 5;
    f(); // OK: prints 5
}</pre></div> </div> <p>Within the body of a lambda with capture default <code>=</code>, the type of any capturable entity is as if it were captured (and thus const-qualification is often added if the lambda is not mutable), even though the entity is in an unevaluated operand and not captured (e.g. in <a href="decltype.html" title="cpp/language/decltype"><code>decltype</code></a>):</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f3()
{
    float x, &amp;r = x;
    [=]
    { // x and r are not captured (appearance in a decltype operand is not an odr-use)
        decltype(x) y1;        // y1 has type float
        decltype((x)) y2 = y1; // y2 has type float const&amp; because this lambda
                               // is not mutable and x is an lvalue
        decltype(r) r1 = y1;   // r1 has type float&amp; (transformation not considered)
        decltype((r)) r2 = y2; // r2 has type float const&amp;
    };
}</pre></div> <p>Any entity captured by a lambda (implicitly or explicitly) is odr-used by the lambda-expression (therefore, implicit capture by a nested lambda triggers implicit capture in the enclosing lambda).</p>
<p>All implicitly-captured variables must be declared within the <i>reaching scope</i> of the lambda.</p>
<p>If a lambda captures the enclosing object (as <code>this</code> or <code>*this</code>), either the nearest enclosing function must be a non-static member function or the lambda must be in a <a href="data_members.html#Member_initialization" title="cpp/language/data members">default member initializer</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct s2
{
    double ohseven = .007;
    auto f() // nearest enclosing function for the following two lambdas
    {
        return [this]      // capture the enclosing s2 by reference
        {
            return [*this] // capture the enclosing s2 by copy (C++17)
            {
                return ohseven; // OK
            }
        }();
    }
 
    auto g()
    {
        return [] // capture nothing
        { 
            return [*this] {}; // error: *this not captured by outer lambda-expression
        }();
    }
};</pre></div> <p>If a lambda expression <span class="t-rev-inl t-since-cxx14"><span>(or a specialization of a generic lambda's function call operator)</span><span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span> ODR-uses <code>*this</code> or any variable with automatic storage duration, it must be captured by the lambda expression.</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f1(int i)
{
    int const N = 20;
    auto m1 = [=]
    {
        int const M = 30;
        auto m2 = [i]
        {
            int x[N][M]; // N and M are not odr-used 
                         // (ok that they are not captured)
            x[0][0] = i; // i is explicitly captured by m2
                         // and implicitly captured by m1
        };
    };
 
    struct s1 // local class within f1()
    {
        int f;
        void work(int n) // non-static member function
        {
            int m = n * n;
            int j = 40;
            auto m3 = [this, m]
            {
                auto m4 = [&amp;, j] // error: j is not captured by m3
                {
                    int x = n; // error: n is implicitly captured by m4
                               // but not captured by m3
                    x += m;    // OK: m is implicitly captured by m4
                               // and explicitly captured by m3
                    x += i;    // error: i is outside of the reaching scope
                               // (which ends at work())
                    x += f;    // OK: this is captured implicitly by m4
                               // and explicitly captured by m3
                };
            };
        }
    };
}</pre></div> <p>Class members cannot be captured explicitly by a capture without initializer (as mentioned above, only <a href="object.html" title="cpp/language/object">variables</a> are permitted in the capture list):</p>
<div class="cpp source-cpp"><pre data-language="cpp">class S
{
    int x = 0;
 
    void f()
    {
        int i = 0;
    //  auto l1 = [i, x] { use(i, x); };      // error: x is not a variable
        auto l2 = [i, x = x] { use(i, x); };  // OK, copy capture
        i = 1; x = 1; l2(); // calls use(0,0)
        auto l3 = [i, &amp;x = x] { use(i, x); }; // OK, reference capture
        i = 2; x = 2; l3(); // calls use(1,2)
    }
};</pre></div> <p>When a lambda captures a member using implicit by-copy capture, it does not make a copy of that member variable: the use of a member variable <code>m</code> is treated as an expression <code>(*this).m</code>, and <code>*this</code> is always implicitly captured by reference:</p>
<div class="cpp source-cpp"><pre data-language="cpp">class S
{
    int x = 0;
 
    void f()
    {
        int i = 0;
 
        auto l1 = [=] { use(i, x); }; // captures a copy of i and
                                      // a copy of the this pointer
        i = 1; x = 1; l1();           // calls use(0, 1), as if
                                      // i by copy and x by reference
 
        auto l2 = [i, this] { use(i, x); }; // same as above, made explicit
        i = 2; x = 2; l2();           // calls use(1, 2), as if
                                      // i by copy and x by reference
 
        auto l3 = [&amp;] { use(i, x); }; // captures i by reference and
                                      // a copy of the this pointer
        i = 3; x = 2; l3();           // calls use(3, 2), as if
                                      // i and x are both by reference
 
        auto l4 = [i, *this] { use(i, x); }; // makes a copy of *this,
                                             // including a copy of x
        i = 4; x = 4; l4();           // calls use(3, 2), as if
                                      // i and x are both by copy
    }
};</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>If a lambda expression appears in a <a href="default_arguments.html" title="cpp/language/default arguments">default argument</a>, it cannot explicitly or implicitly capture anything<span class="t-rev-inl t-since-cxx14"><span>, unless all captures have initializers which satisfy the constraints of an expression appearing in a default argument</span><span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f2()
{
    int i = 1;
 
    void g1(int = ([i] { return i; })()); // error: captures something
    void g2(int = ([i] { return 0; })()); // error: captures something
    void g3(int = ([=] { return i; })()); // error: captures something
 
    void g4(int = ([=] { return 0; })());       // OK: capture-less
    void g5(int = ([] { return sizeof i; })()); // OK: capture-less
 
    // C++14
    void g6(int = ([x = 1] { return x; }))(); // OK: 1 can appear
                                              //     in a default argument
    void g7(int = ([x = i] { return x; }))(); // error: i cannot appear
                                              //        in a default argument
}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>Members of <a href="union.html" title="cpp/language/union">anonymous unions</a> members cannot be captured. <a href="bit_field.html" title="cpp/language/bit field">Bit-fields</a> can only be captured by copy.</p>
<p>If a nested lambda <code>m2</code> captures something that is also captured by the immediately enclosing lambda <code>m1</code>, then <code>m2</code>'s capture is transformed as follows:</p>
<ul>
<li> if the enclosing lambda <code>m1</code> captures by copy, <code>m2</code> is capturing the non-static member of <code>m1</code>'s closure type, not the original variable or <code>*this</code>; if <code>m1</code> is not mutable, the non-static data member is considered to be const-qualified. </li>
<li> if the enclosing lambda <code>m1</code> captures by reference, <code>m2</code> is capturing the original variable or <code>*this</code>. </li>
</ul> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
int main()
{
    int a = 1, b = 1, c = 1;
 
    auto m1 = [a, &amp;b, &amp;c]() mutable
    {
        auto m2 = [a, b, &amp;c]() mutable
        {
            std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; '\n';
            a = 4; b = 4; c = 4;
        };
        a = 3; b = 3; c = 3;
        m2();
    };
 
    a = 2; b = 2; c = 2;
 
    m1();                             // calls m2() and prints 123
    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; '\n'; // prints 234
}</pre></div> </div> <h3 id="Notes"> Notes</h3> <table class="wikitable sortable ftm-begin ftm-has-value"> <tr> <th>Feature-test macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Feature </th>
</tr> <tr> <td><a href="../feature_test.html#cpp_lambdas" title="cpp/feature test"><code>__cpp_lambdas</code></a></td> <td><span class="nu0">200907L</span></td> <td><span class="t-mark">(C++11)</span></td> <td>Lambda expressions </td>
</tr> <tr> <td rowspan="2"><a href="../feature_test.html#cpp_generic_lambdas" title="cpp/feature test"><code>__cpp_generic_lambdas</code></a></td> <td><span class="nu0">201304L</span></td> <td><span class="t-mark">(C++14)</span></td> <td>Generic lambda expressions </td>
</tr> <tr> <td><span class="nu0">201707L</span></td> <td><span class="t-mark">(C++20)</span></td> <td>Explicit template parameter list for generic lambdas </td>
</tr> <tr> <td rowspan="2"><a href="../feature_test.html#cpp_init_captures" title="cpp/feature test"><code>__cpp_init_captures</code></a></td> <td><span class="nu0">201304L</span></td> <td><span class="t-mark">(C++14)</span></td> <td>Lambda init-capture </td>
</tr> <tr> <td><span class="nu0">201803L</span></td> <td><span class="t-mark">(C++20)</span></td> <td>Allow pack expansion in lambda init-capture </td>
</tr> <tr> <td><a href="../feature_test.html#cpp_capture_star_this" title="cpp/feature test"><code>__cpp_capture_star_this</code></a></td> <td><span class="nu0">201603L</span></td> <td><span class="t-mark">(C++17)</span></td> <td>Lambda capture of <code>*this</code> by value as <code>[=, *this]</code> </td>
</tr> <tr> <td><a href="../feature_test.html#cpp_constexpr" title="cpp/feature test"><code>__cpp_constexpr</code></a></td> <td><span class="nu0">201603L</span></td> <td><span class="t-mark">(C++17)</span></td> <td>constexpr lambda </td>
</tr> <tr> <td><a href="../feature_test.html#cpp_static_call_operator" title="cpp/feature test"><code>__cpp_static_call_operator</code></a></td> <td><span class="nu0">202207L</span></td> <td><span class="t-mark">(C++23)</span></td> <td>static <code>operator()</code> for captureless lambdas </td>
</tr>
</table> <p>The rule for implicit lambda capture is slightly changed by defect report <a rel="nofollow" class="external text" href="https://wg21.link/P0588R1">P0588R1</a>. As of 2023-10, some major implementations have not completely implemented the DR, and thus the old rule, which detects <a href="definition.html#ODR-use" title="cpp/language/definition">odr-using</a>, is still used in some cases.</p>
<div style="margin-left:0px"> <table class="mw-collapsible mw-collapsed"> <tr> <th>Old rule before P0588R1 </th>
</tr> <tr> <td> <p>If a capture list has a capture-default and does not explicitly capture the enclosing object (as <code>this</code> or <code>*this</code>), or an automatic variable that is <a href="definition.html#ODR-use" title="cpp/language/definition">odr-usable</a> in the lambda body<span class="t-rev-inl t-since-cxx20"><span>, or a <a href="structured_binding.html" title="cpp/language/structured binding">structured binding</a> whose corresponding variable has atomic storage duration</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, it captures the entity <i>implicitly</i> if the entity is</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <ul><li> named in a <a href="expressions.html#Potentially-evaluated_expressions" title="cpp/language/expressions">potentially-evaluated</a> expression within an expression that depends on a template parameter of a generic lambda, or </li></ul> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <ul><li> <a href="definition.html#ODR-use" title="cpp/language/definition">odr-used</a> by the body of the lambda. </li></ul> </td>
</tr>
</table>
</div> <h3 id="Example"> Example</h3> <div class="t-example">
<p>This example shows how to pass a lambda to a generic algorithm and how objects resulting from a lambda expression can be stored in <code><a href="../utility/functional/function.html" title="cpp/utility/functional/function">std::function</a></code> objects.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
int main()
{
    std::vector&lt;int&gt; c{1, 2, 3, 4, 5, 6, 7};
    int x = 5;
    c.erase(std::remove_if(c.begin(), c.end(), [x](int n) { return n &lt; x; }), c.end());
 
    std::cout &lt;&lt; "c: ";
    std::for_each(c.begin(), c.end(), [](int i) { std::cout &lt;&lt; i &lt;&lt; ' '; });
    std::cout &lt;&lt; '\n';
 
    // the type of a closure cannot be named, but can be inferred with auto
    // since C++14, lambda could own default arguments
    auto func1 = [](int i = 6) { return i + 4; };
    std::cout &lt;&lt; "func1: " &lt;&lt; func1() &lt;&lt; '\n';
 
    // like all callable objects, closures can be captured in std::function
    // (this may incur unnecessary overhead)
    std::function&lt;int(int)&gt; func2 = [](int i) { return i + 4; };
    std::cout &lt;&lt; "func2: " &lt;&lt; func2(6) &lt;&lt; '\n';
 
    constexpr int fib_max {8};
    std::cout &lt;&lt; "Emulate `recursive lambda` calls:\nFibonacci numbers: ";
    auto nth_fibonacci = [](int n)
    {
        std::function&lt;int(int, int, int)&gt; fib = [&amp;](int n, int a, int b)
        {
            return n ? fib(n - 1, a + b, a) : b;
        };
        return fib(n, 0, 1);
    };
 
    for (int i{1}; i &lt;= fib_max; ++i)
        std::cout &lt;&lt; nth_fibonacci(i) &lt;&lt; (i &lt; fib_max ? ", " : "\n");
 
    std::cout &lt;&lt; "Alternative approach to lambda recursion:\nFibonacci numbers: ";
    auto nth_fibonacci2 = [](auto self, int n, int a = 0, int b = 1) -&gt; int
    {
        return n ? self(self, n - 1, a + b, a) : b;
    };
 
    for (int i{1}; i &lt;= fib_max; ++i)
        std::cout &lt;&lt; nth_fibonacci2(nth_fibonacci2, i) &lt;&lt; (i &lt; fib_max ? ", " : "\n");
 
#ifdef __cpp_explicit_this_parameter
    std::cout &lt;&lt; "C++23 approach to lambda recursion:\n";
    auto nth_fibonacci3 = [](this auto self, int n, int a = 0, int b = 1) -&gt; int
    {
         return n ? self(n - 1, a + b, a) : b;
    };
 
    for (int i{1}; i &lt;= fib_max; ++i)
        std::cout &lt;&lt; nth_fibonacci3(i) &lt;&lt; (i &lt; fib_max ? ", " : "\n");
#endif
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">c: 5 6 7
func1: 10
func2: 10
Emulate `recursive lambda` calls:
Fibonacci numbers: 0, 1, 1, 2, 3, 5, 8, 13
Alternative approach to lambda recursion:
Fibonacci numbers: 0, 1, 1, 2, 3, 5, 8, 13</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/974.html">CWG 974</a> </td> <td>C++11 </td> <td>default argument was not allowed in the<br>parameter list of a lambda expression </td> <td>allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1249.html">CWG 1249</a> </td> <td>C++11 </td> <td>it is not clear that whether the captured member of the<br>enclosing non-mutable lambda is considered <span class="kw4">const</span> or not </td> <td>considered <span class="kw4">const</span> </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1557.html">CWG 1557</a> </td> <td>C++11 </td> <td>the language linkage of the returned function type of<br>the closure type's conversion function was not specified </td> <td>it has C++<br>language linkage </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1607.html">CWG 1607</a> </td> <td>C++11 </td> <td>lambda expressions could appear in<br>function and function template signatures </td> <td>not allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1612.html">CWG 1612</a> </td> <td>C++11 </td> <td>members of anonymous unions could be captured </td> <td>not allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1722.html">CWG 1722</a> </td> <td>C++11 </td> <td>the conversion function for captureless lambdas<br>had unspecified exception specification </td> <td>conversion function<br>is noexcept </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1772.html">CWG 1772</a> </td> <td>C++11 </td> <td>the semantic of <code>__func__</code> in lambda body was not clear </td> <td>it refers to the closure<br>class's operator() </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1780.html">CWG 1780</a> </td> <td>C++14 </td> <td>it was unclear whether the members of the closure types of generic<br>lambdas can be explicitly instantiated or explicitly specialized </td> <td>neither is allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1891.html">CWG 1891</a> </td> <td>C++11 </td> <td>closure had a deleted default constructor<br>and implicit copy/move constructors </td> <td>no default and defaulted<br>copy/move constructors </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1937.html">CWG 1937</a> </td> <td>C++11 </td> <td>as for the effect of invoking the result of the conversion function, it was<br>unspecified on which object calling its <code>operator()</code> has the same effect </td> <td>on a default-constructed<br>instance of the closure type </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1973.html">CWG 1973</a> </td> <td>C++11 </td> <td>the parameter list of the closure type's <code>operator()</code><br>could refer to the parameter list given in <span class="t-spar">trailing-type</span> </td> <td>can only refer<br>to <span class="t-spar">params</span> </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2011.html">CWG 2011</a> </td> <td>C++11 </td> <td>for a reference captured by reference, it was unspecified<br>which entity the identifier of the capture refers to </td> <td>it refers to the originally<br>referenced entity </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2095.html">CWG 2095</a> </td> <td>C++11 </td> <td>the behavior of capturing rvalue references<br>to functions by copy was not clear </td> <td>made clear </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2211.html">CWG 2211</a> </td> <td>C++11 </td> <td>the behavior was unspecified if a capture<br>has the same name as a parameter </td> <td>the program is ill-<br>formed in this case </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2358.html">CWG 2358</a> </td> <td>C++14 </td> <td>lambda expressions appearing in default arguments had<br>to be capture-less even if all captures are initialized with<br>expressions which can appear in default arguments </td> <td>allow such lambda<br>expressions with captures </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2509.html">CWG 2509</a> </td> <td>C++17 </td> <td>each specifier could have multiple<br>occurrences in the specifier sequence </td> <td>each specifier can only<br>appear at most once in<br>the specifier sequence </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2542.html">CWG 2542</a> </td> <td>C++11 </td> <td>it was unclear whether the closure type is structural </td> <td>it is not structural </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://wg21.link/P0588R1">P0588R1</a> </td> <td>C++11 </td> <td>the rule for implicit lambda capture detected odr-use </td> <td>the detection is simplified </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="auto.html" title="cpp/language/auto"> <code>auto</code> specifier </a><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> specifies a type deduced from an expression  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/function.html" title="cpp/utility/functional/function"> <span class="t-lines"><span>function</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> wraps callable object of any copy constructible type with specified function call signature <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/move_only_function.html" title="cpp/utility/functional/move only function"> <span class="t-lines"><span>move_only_function</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> wraps callable object of any type with specified function call signature <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table> <h3 id="External_links"> External links</h3> <table> <tr> <td>
<a href="https://en.wikipedia.org/wiki/Nested_function" class="extiw" title="enwiki:Nested function">Nested function</a> - a function which is defined within another (<i>enclosing</i>) function. </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/lambda" class="_attribution-link">https://en.cppreference.com/w/cpp/language/lambda</a>
  </p>
</div>
