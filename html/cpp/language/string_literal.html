    <h1 id="firstHeading" class="firstHeading">String literal</h1>             <h3 id="Syntax"> Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>"</code><span class="t-spar">s-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>"</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>R"</code><span class="t-spar">d-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>(</code><span class="t-spar">r-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>)</code><span class="t-spar">d-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>"</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>L"</code><span class="t-spar">s-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>"</code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>LR"</code><span class="t-spar">d-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>(</code><span class="t-spar">r-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>)</code><span class="t-spar">d-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>"</code> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>u8"</code><span class="t-spar">s-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>"</code> </td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>u8R"</code><span class="t-spar">d-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>(</code><span class="t-spar">r-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>)</code><span class="t-spar">d-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>"</code> </td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>u"</code><span class="t-spar">s-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>"</code> </td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>uR"</code><span class="t-spar">d-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>(</code><span class="t-spar">r-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>)</code><span class="t-spar">d-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>"</code> </td> <td> (8) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>U"</code><span class="t-spar">s-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>"</code> </td> <td> (9) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>UR"</code><span class="t-spar">d-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>(</code><span class="t-spar">r-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>)</code><span class="t-spar">d-char-seq</span> ﻿<span class="t-mark">(optional)</span><code>"</code> </td> <td> (10) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <h3 id="Explanation"> Explanation</h3> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">s-char-seq</span> </td> <td> - </td> <td> A sequence of one or more <span class="t-spar">s-char</span> ﻿s </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">s-char</span> </td> <td> - </td> <td> One of <ul>
<li> a <span class="t-spar">basic-s-char</span> </li>
<li> an escape sequence, as defined in <a href="escape.html" title="cpp/language/escape">escape sequences</a> </li>
<li> a universal character name, as defined in <a href="escape.html" title="cpp/language/escape">escape sequences</a> </li>
</ul> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">basic-s-char</span> </td> <td> - </td> <td> A character from the <a href="charset.html#Translation_character_set" title="cpp/language/charset">translation character set</a>, except the double-quote <code>"</code>, backslash <code>\</code>, or new-line character </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">d-char-seq</span> </td> <td> - </td> <td> A sequence of one or more <span class="t-spar">d-char</span> ﻿s, at most 16 characters long </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">d-char</span> </td> <td> - </td> <td> A character from the <a href="charset.html#Basic_character_set" title="cpp/language/charset">basic character set</a>, except parentheses, backslash and <a href="../string/byte/isspace.html" title="cpp/string/byte/isspace">spaces</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">r-char-seq</span> </td> <td> - </td> <td> A sequence of one or more <span class="t-spar">r-char</span> ﻿s, except that it must not contain the closing sequence <code>)d-char-seq"</code> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">r-char</span> </td> <td> - </td> <td> A character from the <a href="charset.html#Translation_character_set" title="cpp/language/charset">translation character set</a> </td>
</tr>
</table> <table class="wikitable"> <tr> <th> Syntax </th> <th>Kind </th> <th>Type </th> <th>Encoding </th>
</tr> <tr> <td>
<span class="t-v">(1,2)</span> </td> <td> ordinary string literal </td> <td>
<span class="kw4">const</span> <span class="kw4">char</span><span class="br0">[</span>N<span class="br0">]</span> </td> <td>
<a href="charset.html#Code_unit_and_literal_encoding" title="cpp/language/charset">ordinary literal encoding</a> </td>
</tr> <tr> <td>
<span class="t-v">(3,4)</span> </td> <td>wide string literal </td> <td>
<span class="kw4">const</span> <span class="kw4">wchar_t</span><span class="br0">[</span>N<span class="br0">]</span> </td> <td>
<a href="charset.html#Code_unit_and_literal_encoding" title="cpp/language/charset">wide literal encoding</a> </td>
</tr> <tr> <td>
<span class="t-v">(5,6)</span> </td> <td>UTF-8 string literal </td> <td>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><span class="kw4">const</span> <span class="kw4">char</span><span class="br0">[</span>N<span class="br0">]</span></p>
</td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><span class="kw4">const</span> char8_t<span class="br0">[</span>N<span class="br0">]</span></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td> <td>UTF-8 </td>
</tr> <tr> <td>
<span class="t-v">(7,8)</span> </td> <td>UTF-16 string literal </td> <td>
<span class="kw4">const</span> <span class="kw4">char16_t</span><span class="br0">[</span>N<span class="br0">]</span> </td> <td>UTF-16 </td>
</tr> <tr> <td>
<span class="t-v">(9,10)</span> </td> <td>UTF-32 string literal </td> <td>
<span class="kw4">const</span> <span class="kw4">char32_t</span><span class="br0">[</span>N<span class="br0">]</span> </td> <td>UTF-32 </td>
</tr>
</table> <p>In the types listed in the table above, <code>N</code> is the number of encoded code units, which is determined <a href="#Initialization">below</a>.</p>
<p>Ordinary<span class="t-rev-inl t-since-cxx11"><span> and UTF-8</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> string literals are collectively referred to as narrow string literals.</p>
<p>Evaluating a string literal results in a string literal object with static <a href="storage_duration.html" title="cpp/language/storage duration">storage duration</a>. Whether all string literals are stored in <a href="object.html#Subobjects" title="cpp/language/object">nonoverlapping objects</a> and whether successive evaluations of a string literal yield the same or a different object is unspecified.</p>
<p>The effect of attempting to modify a string literal object is undefined.</p>
<div class="cpp source-cpp"><pre data-language="cpp">bool b = "bar" == 3 + "foobar"; // can be true or false, unspecified
 
const char* pc = "Hello";
char* p = const_cast&lt;char*&gt;(pc);
p[0] = 'M'; // undefined behavior</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <h3 id="Raw_string_literals"> Raw string literals</h3> <p>Raw string literals are string literals with a prefix containing <code>R</code> (syntaxes <span class="t-v">(2,4,6,8,10)</span>). They do not escape any character, which means anything between the delimiters <code>d-char-seq ﻿(</code> and <code>)d-char-seq</code> becomes part of the string. The terminating <span class="t-spar">d-char-seq</span> is the same sequence of characters as the initial <span class="t-spar">d-char-seq</span>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">// OK: contains one backslash,
// equivalent to "\\"
R"(\)";
 
// OK: contains four \n pairs,
// equivalent to "\\n\\n\\n\\n"
R"(\n\n\n\n)";
 
// OK: contains one close-parenthesis, two double-quotes and one open-parenthesis,
// equivalent to ")\"\"("
R"-()""()-";
 
// OK: equivalent to "\n)\\\na\"\"\n"
R"a(
)\
a""
)a";
 
// OK: equivalent to "x = \"\"\\y\"\""
R"(x = ""\y"")";
 
// R"&lt;&lt;(-_-)&gt;&gt;"; // Error: begin and end delimiters do not match
// R"-()-"-()-"; // Error: )-" appears in the middle and terminates the literal</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Initialization"> Initialization</h3> <p>String literal objects are initialized with the sequence of code unit values corresponding to the string literal’s sequence of <span class="t-spar">s-char</span> ﻿s<span class="t-rev-inl t-since-cxx11"><span> and <span class="t-spar">r-char</span> ﻿s</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, plus a terminating null character (U+0000), in order as follows:</p>
<div class="t-li1">
<span class="t-li">1)</span> For each contiguous sequence of <span class="t-spar">basic-s-char</span> ﻿s,<span class="t-rev-inl t-since-cxx11"><span> <span class="t-spar">r-char</span> ﻿s,</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> <a href="escape.html" title="cpp/language/escape">simple escape sequences</a> and <a href="escape.html" title="cpp/language/escape">universal character names</a>, the sequence of character it denotes is encoded to a code unit sequence using the string literal’s associated character encoding. If a character lacks representation in the associated character encoding, then the program is ill-formed.</div> <div class="t-li1">
 If the associated character encoding is stateful, the first such sequence is encoded beginning with the initial encoding state and each subsequent sequence is encoded beginning with the final encoding state of the prior sequence.</div> <span class="t-li">2)</span> For each <a href="escape.html" title="cpp/language/escape">numeric escape sequence</a>, given <code>v</code> as the integer value represented by the octal or hexadecimal number comprising the sequence of digits in the escape sequence, and <code>T</code> as the string literal’s array element type (see the table <a href="#Info_table">above</a>): <ul>
<li> If <code>v</code> does not exceed the range of representable values of <code>T</code>, then the escape sequence contributes a single code unit with value <code>v</code>. </li>
<li> Otherwise, if<span class="t-rev-inl t-since-cxx11"><span> the string literal is of syntax <span class="t-v">(1)</span> or <span class="t-v">(3)</span>, and</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> <code>v</code> does not exceed the range of representable values of the corresponding unsigned type for the underlying type of <code>T</code>, then the escape sequence contributes a single code unit with a unique value of type <code>T</code>, that is congruent to \(v \bmod 2^S\)v mod 2<sup class="t-su">S</sup>, where <code>S</code> is the width of <code>T</code>. </li>
<li> Otherwise, the program is ill-formed.</li>
</ul> <div class="t-li1">
 If the associated character encoding is stateful, all such sequences have no effect on encoding state.</div> <div class="t-li1">
<span class="t-li">3)</span> Each <a href="escape.html" title="cpp/language/escape">conditional escape sequence</a> contributes an implementation-defined code unit sequence.</div> <div class="t-li1">
 If the associated character encoding is stateful, it is implementation-defined what effect these sequences have on encoding state.</div> <h3 id="Concatenation"> Concatenation</h3> <p>String literals placed side-by-side are concatenated at <a href="translation_phases.html#Phase_6" title="cpp/language/translation phases">translation phase 6</a> (after the preprocessor). That is, <code>"Hello," " world!"</code> yields the (single) string <code>"Hello, world!"</code>. If the two strings have the same encoding prefix (or neither has one), the resulting string will have the same encoding prefix (or no prefix).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>If one of the strings has an encoding prefix and the other does not, the one that does not will be considered to have the same encoding prefix as the other.</p>
<div class="cpp source-cpp"><pre data-language="cpp">L"Δx = %" PRId16 // at phase 4, PRId16 expands to "d"
                 // at phase 6, L"Δx = %" and "d" form L"Δx = %d"</pre></div> <p>If a UTF-8 string literal and a wide string literal are side by side, the program is ill-formed.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11 t-until-cxx23">
<td> <p>Any other combination of encoding prefixes is conditionally supported with implementation-defined semantics. (No known implementation supports such concatenation.)</p>
</td> <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx23">(until C++23)</span>
</td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>Any other combination of encoding prefixes is ill-formed.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td>
</tr> </table> <h3 id="Unevaluated_strings"> Unevaluated strings</h3> <p>The following contexts expect a string literal, but do not evaluate it:</p>
<ul>
<li> <a href="language_linkage.html" title="cpp/language/language linkage">language linkage</a> specification </li>
<li> <a href="static_assert.html" title="cpp/language/static assert"><code>static_assert</code></a> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </li>
<li> <a href="user_literal.html#Literal_operators" title="cpp/language/user literal">literal operator</a> name <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </li>
<li> <code>[[<a href="attributes/deprecated.html" title="cpp/language/attributes/deprecated">deprecated</a>]]</code> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </li>
<li> <code>[[<a href="attributes/nodiscard.html" title="cpp/language/attributes/nodiscard">nodiscard</a>]]</code> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx26">
<td> <p>It is unspecified whether an encoding prefix is allowed in these contexts<span class="t-rev-inl t-since-cxx11"><span> (except that a literal operator name must not have an encoding prefix)</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
</td> <td><span class="t-mark-rev t-until-cxx26">(until C++26)</span></td>
</tr> <tr class="t-rev t-since-cxx26">
<td> <p>No encoding prefix is allowed in these contexts.</p>
<p>Each <a href="escape.html" title="cpp/language/escape">universal character name</a> and each <a href="escape.html" title="cpp/language/escape">simple escape sequence</a> in an unevaluated string is replaced by the member of the <a href="charset.html" title="cpp/language/charset">translation character set</a> it denotes. An unevaluated string that contains a numeric escape sequence or a conditional escape sequence is ill-formed.</p>
</td> <td><span class="t-mark-rev t-since-cxx26">(since C++26)</span></td>
</tr> </table> <h3 id="Notes"> Notes</h3> <p>String literals can be used to <a href="aggregate_initialization.html" title="cpp/language/aggregate initialization">initialize character arrays</a>. If an array is initialized like <code>char str[] = "foo";</code>, <code>str</code> will contain a copy of the string <code>"foo"</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>String literals are convertible and assignable to non-const <span class="kw4">char</span><span class="sy2">*</span> or <span class="kw4">wchar_t</span><span class="sy2">*</span> in order to be compatible with C, where string literals are of types <span class="kw4">char</span><span class="br0">[</span>N<span class="br0">]</span> and <span class="kw4">wchar_t</span><span class="br0">[</span>N<span class="br0">]</span>. Such implicit conversion is deprecated.</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>String literals are not convertible or assignable to non-const <code>CharT*</code>. An explicit cast (e.g. <a href="const_cast.html" title="cpp/language/const cast"><code>const_cast</code></a>) must be used if such conversion is wanted.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>A string literal is not necessarily a null-terminated character sequence: if a string literal has embedded null characters, it represents an array which contains more than one string.</p>
<div class="cpp source-cpp"><pre data-language="cpp">const char* p = "abc\0def"; // std::strlen(p) == 3, but the array has size 8</pre></div> <p>If a valid hexadecimal digit follows a hexadecimal escape sequence in a string literal, it would fail to compile as an invalid escape sequence. String concatenation can be used as a workaround:</p>
<div class="cpp source-cpp"><pre data-language="cpp">//const char* p = "\xfff"; // error: hexadecimal escape sequence out of range
const char* p = "\xff""f"; // OK: the literal is const char[3] holding {'\xff','f','\0'}</pre></div> <table class="wikitable sortable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test.html" title="cpp/utility/feature test">Feature-test</a> macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Feature </th>
</tr> <tr> <td><a href="../feature_test.html#cpp_char8_t" title="cpp/feature test"><code>__cpp_char8_t</code></a></td> <td><span class="nu0">202207L</span></td> <td>
<span class="t-mark">(C++20)</span><br><span class="t-mark">(DR)</span>
</td> <td>char8_t compatibility and portability fix (allow <a href="aggregate_initialization.html#Character_arrays" title="cpp/language/aggregate initialization">initialization of (<span class="kw4">unsigned</span>) <span class="kw4">char</span> arrays</a> from UTF-8 string literals) </td>
</tr> <tr> <td><a href="../feature_test.html#cpp_raw_strings" title="cpp/feature test"><code>__cpp_raw_strings</code></a></td> <td><span class="nu0">200710L</span></td> <td><span class="t-mark">(C++11)</span></td> <td>Raw string literals </td>
</tr> <tr> <td><a href="../feature_test.html#cpp_unicode_literals" title="cpp/feature test"><code>__cpp_unicode_literals</code></a></td> <td><span class="nu0">200710L</span></td> <td><span class="t-mark">(C++11)</span></td> <td>Unicode string literals </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
char array1[] = "Foo" "bar";
// same as
char array2[] = { 'F', 'o', 'o', 'b', 'a', 'r', '\0' };
 
const char* s1 = R"foo(
Hello
  World
)foo";
// same as
const char* s2 = "\nHello\n  World\n";
// same as
const char* s3 = "\n"
                 "Hello\n"
                 "  World\n";
 
const wchar_t* s4 = L"ABC" L"DEF"; // ok, same as
const wchar_t* s5 = L"ABCDEF";
const char32_t* s6 = U"GHI" "JKL"; // ok, same as
const char32_t* s7 = U"GHIJKL";
const char16_t* s9 = "MN" u"OP" "QR"; // ok, same as
const char16_t* sA = u"MNOPQR";
 
// const auto* sB = u"Mixed" U"Types";
        // before C++23 may or may not be supported by
        // the implementation; ill-formed since C++23
 
const wchar_t* sC = LR"--(STUV)--"; // ok, raw string literal
 
int main()
{
    std::cout &lt;&lt; array1 &lt;&lt; ' ' &lt;&lt; array2 &lt;&lt; '\n'
              &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; s3 &lt;&lt; std::endl;
    std::wcout &lt;&lt; s4 &lt;&lt; ' ' &lt;&lt; s5 &lt;&lt; ' ' &lt;&lt; sC
               &lt;&lt; std::endl;
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Foobar Foobar
 
Hello
  World
 
Hello
  World
 
Hello
  World
 
ABCDEF ABCDEF STUV</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/411.html">CWG 411</a><br>(<a rel="nofollow" class="external text" href="https://wg21.link/P2029R4">P2029R4</a>) </td> <td>C++98 </td> <td>escape sequences in string literals were<br>not allowed to map to multiple code units </td> <td>allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1656.html">CWG 1656</a><br>(<a rel="nofollow" class="external text" href="https://wg21.link/P2029R4">P2029R4</a>) </td> <td>C++98 </td> <td>the characters denoted by numeric escape<br>sequences in string literals were unclear </td> <td>made clear </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1759.html">CWG 1759</a> </td> <td>C++11 </td> <td>a UTF-8 string literal might have code<br>units that are not representable in <span class="kw4">char</span> </td> <td>
<span class="kw4">char</span> can represent all UTF-8 code units </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1823.html">CWG 1823</a> </td> <td>C++98 </td> <td>whether string literals are distinct<br>was implementation-defined </td> <td>distinctness is unspecified, and same<br>string literal can yield different object </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2333.html">CWG 2333</a><br>(<a rel="nofollow" class="external text" href="https://wg21.link/P2029R4">P2029R4</a>) </td> <td>C++11 </td> <td>it was unclear whether numeric escape sequences<br>were allowed in UTF-8/16/32 string literals </td> <td>made clear </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://wg21.link/P1854R4">P1854R4</a> </td> <td>C++98 </td> <td>ordinary and wide string literals with non-encodable<br>characters were conditionally-supported </td> <td>programs with such literals are ill-formed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://wg21.link/P2029R4">P2029R4</a> </td> <td>C++98 </td> <td>1. it was unclear whether string literals<br> could contain non-encodable characters<br>2. it was unclear whether string literals could<br> contain numeric escape sequences such<br> that the code units they represent are not<br> representable in the literals' array element type </td> <td>1. made conditionally-supported for<br> ordinary and wide string literals<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup><br>2. ill-formed if the code units are<br> neither representable in the<br> unsigned integer type corresponding<br> to the underlying type </td>
</tr>
</table> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">P1854R4 was accepted as a DR later, overriding this resolution.</span> </li> </ol> <h3 id="References"> References</h3>  <ul>
<li> C++23 standard (ISO/IEC 14882:2023): </li>
<ul><li> 5.13.5 String literals [lex.string] </li></ul>
<li> C++20 standard (ISO/IEC 14882:2020): </li>
<ul><li> 5.13.5 String literals [lex.string] </li></ul>
<li> C++17 standard (ISO/IEC 14882:2017): </li>
<ul><li> 5.13.5 String literals [lex.string] </li></ul>
<li> C++14 standard (ISO/IEC 14882:2014): </li>
<ul><li> 2.14.5 String literals [lex.string] </li></ul>
<li> C++11 standard (ISO/IEC 14882:2011): </li>
<ul><li> 2.14.5 String literals [lex.string] </li></ul>
<li> C++03 standard (ISO/IEC 14882:2003): </li>
<ul><li> 2.13.4 String literals [lex.string] </li></ul>
<li> C++98 standard (ISO/IEC 14882:1998): </li>
<ul><li> 2.13.4 String literals [lex.string] </li></ul>
</ul>                           <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="user_literal.html" title="cpp/language/user literal"> user-defined literals</a><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> literals with user-defined suffix </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">C documentation</a></span> for <span class=""><span>String literals</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/string_literal" class="_attribution-link">https://en.cppreference.com/w/cpp/language/string_literal</a>
  </p>
</div>
