    <h1 id="firstHeading" class="firstHeading">Name lookup</h1>            <p>Name lookup is the procedure by which a <a href="name.html" title="cpp/language/name" class="mw-redirect">name</a>, when encountered in a program, is associated with the <a href="declarations.html" title="cpp/language/declarations">declaration</a> that introduced it.</p>
<p>For example, to compile <code><a href="http://en.cppreference.com/w/cpp/io/cout"><span class="kw1762">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <a href="http://en.cppreference.com/w/cpp/io/manip/endl"><span class="kw1795">std::<span class="me2">endl</span></span></a><span class="sy4">;</span></code>, the compiler performs:</p>
<ul>
<li> unqualified name lookup for the name <code>std</code>, which finds the declaration of namespace std in the header <a href="../header/iostream.html" title="cpp/header/iostream"><code>&lt;iostream&gt;</code></a> </li>
<li> qualified name lookup for the name <code>cout</code>, which finds a variable declaration in the namespace <code>std</code> </li>
<li> qualified name lookup for the name <code>endl</code>, which finds a function template declaration in the namespace <code>std</code> </li>
<li> both <a href="adl.html" title="cpp/language/adl">argument-dependent lookup</a> for the name <code>operator&lt;&lt;</code>, which finds multiple function template declarations in the namespace <code>std</code>, and qualified name lookup for the name <code>std::ostream::operator&lt;&lt;</code>, which finds multiple member function declarations in class <code><a href="../io/basic_ostream.html" title="cpp/io/basic ostream">std::ostream</a></code>. </li>
</ul> <p>For function and function template names, name lookup can associate multiple declarations with the same name, and may obtain additional declarations from <a href="adl.html" title="cpp/language/adl">argument-dependent lookup</a>. <a href="function_template.html" title="cpp/language/function template">Template argument deduction</a> may also apply, and the set of declarations is passed to <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a>, which selects the declaration that will be used. <a href="access.html" title="cpp/language/access">Member access</a> rules, if applicable, are considered only after name lookup and overload resolution.</p>
<p>For all other names (variables, namespaces, classes, etc), name lookup can associate multiple declarations only if they declare the same <a href="basic_concepts.html" title="cpp/language/basic concepts">entity</a>, otherwise it must produce a single declaration in order for the program to compile. Lookup for a name in a scope finds all declarations of that name, with one exception, known as the "struct hack" or "type/non-type hiding": Within the same scope, some occurrences of a name may refer to a declaration of a class/struct/union/enum that is not a <code>typedef</code>, while all other occurrences of the same name either all refer to the same variable, non-static data member, or enumerator, or they all refer to possibly overloaded function or function template names. In this case, there is no error, but the type name is hidden from lookup (the code must use <a href="elaborated_type_specifier.html" title="cpp/language/elaborated type specifier">elaborated type specifier</a> to access it).</p>
<h3 id="Types_of_lookup"> Types of lookup</h3> <p>If the name appears immediately to the right of the scope resolution operator <code>::</code> or possibly after <code>::</code> followed by the disambiguating keyword <code>template</code>, see</p>
<ul><li> <a href="qualified_lookup.html" title="cpp/language/qualified lookup">Qualified name lookup</a> </li></ul> <p>Otherwise, see</p>
<ul>
<li> <a href="unqualified_lookup.html" title="cpp/language/unqualified lookup">Unqualified name lookup</a> </li>
<ul><li> (which, for function names, includes <a href="adl.html" title="cpp/language/adl">Argument-dependent lookup</a>) </li></ul>
</ul>  <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2063.html">CWG 2063</a> </td> <td>C++98 </td> <td>"struct hack" did not apply in class scope (breaks C compatibility) </td> <td>applied </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2218.html">CWG 2218</a> </td> <td>C++98 </td> <td>lookup for non-function (template) names could not associate<br>multiple declarations, even if they declare the same entity </td> <td>allowed </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <ul>
<li> <a href="scope.html" title="cpp/language/scope">Scope</a> </li>
<li> <a href="adl.html" title="cpp/language/adl">Argument-dependent lookup</a> </li>
<li> <a href="function_template.html#Template_argument_deduction" title="cpp/language/function template">Template argument deduction</a> </li>
<li> <a href="overload_resolution.html" title="cpp/language/overload resolution">Overload resolution</a> </li>
</ul> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/name_space" title="c/language/name space">C documentation</a></span> for <span class=""><span>Lookup and name spaces</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/lookup" class="_attribution-link">https://en.cppreference.com/w/cpp/language/lookup</a>
  </p>
</div>
