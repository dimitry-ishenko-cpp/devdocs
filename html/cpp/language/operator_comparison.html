    <h1 id="firstHeading" class="firstHeading">Comparison operators</h1>            <p>Compares the arguments.</p>
<table class="wikitable"> <tr> <th rowspan="2">Operator name </th> <th rowspan="2"> Syntax </th> <th rowspan="2">
<a href="operators.html" title="cpp/language/operators">Over​load​able</a> </th> <th colspan="2">Prototype examples (for <span class="kw1">class</span> T) </th>
</tr> <tr> <th>Inside class definition </th> <th>Outside class definition </th>
</tr> <tr> <td>equal to </td> <td>
<code>a == b</code> </td> <td class="table-yes">Yes </td> <td>
<code>bool T::operator==(const U&amp; b) const;</code> </td> <td>
<code>bool operator==(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>not equal to </td> <td>
<code>a != b</code> </td> <td class="table-yes">Yes </td> <td>
<code>bool T::operator!=(const U&amp; b) const;</code> </td> <td>
<code>bool operator!=(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>less than </td> <td>
<code>a &lt; b</code> </td> <td class="table-yes">Yes </td> <td>
<code>bool T::operator&lt;(const U&amp; b) const;</code> </td> <td>
<code>bool operator&lt;(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>greater than </td> <td>
<code>a &gt; b</code> </td> <td class="table-yes">Yes </td> <td>
<code>bool T::operator&gt;(const U&amp; b) const;</code> </td> <td>
<code>bool operator&gt;(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>less than or equal to </td> <td>
<code>a &lt;= b</code> </td> <td class="table-yes">Yes </td> <td>
<code>bool T::operator&lt;=(const U&amp; b) const;</code> </td> <td>
<code>bool operator&lt;=(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>greater than or equal to </td> <td>
<code>a &gt;= b</code> </td> <td class="table-yes">Yes </td> <td>
<code>bool T::operator&gt;=(const U&amp; b) const;</code> </td> <td>
<code>bool operator&gt;=(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>three-way comparison <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td>
<code>a &lt;=&gt; b</code> </td> <td class="table-yes">Yes </td> <td>
<code>R T::operator&lt;=&gt;(const U&amp; b) const;</code><sup id="cite_ref-R_1-0" class="reference"><a href="#cite_note-R-1">[1]</a></sup> </td> <td>
<code>R operator&lt;=&gt;(const T&amp; a, const U&amp; b);</code><sup id="cite_ref-R_1-1" class="reference"><a href="#cite_note-R-1">[1]</a></sup> </td>
</tr> <tr> <td colspan="5"> <b>Notes</b><br>  <ul>
<li> Where built-in operators return <span class="kw4">bool</span>, most <a href="operators.html" title="cpp/language/operators">user-defined overloads</a> also return <span class="kw4">bool</span> so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including <span class="kw4">void</span>). </li>
<li> <code>U</code> can be any type including <code>T</code>. </li>
</ul> <ol class="references"> <li id="cite_note-R-1"> <span class="reference-text"><code><i>R</i></code> is the return type of <code>operator&lt;=&gt;</code> (<a href="#Three-way_comparison">see below</a>)</span> </li> </ol> </td>
</tr>
</table>  <h3 id="Two-way_comparison"> Two-way comparison</h3> <p>The two-way comparison operator expressions have the form</p>
<h5 id="Relational_operators"> Relational operators</h5> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&lt;</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&gt;</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&lt;=</code> <span class="t-spar">rhs</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&gt;=</code> <span class="t-spar">rhs</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <h5 id="Equality_operators"> Equality operators</h5> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>==</code> <span class="t-spar">rhs</span> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>!=</code> <span class="t-spar">rhs</span> </td> <td> (6) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is less than <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <div class="t-li1">
<span class="t-li">2)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is greater than <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <div class="t-li1">
<span class="t-li">3)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is less than or equal to <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <div class="t-li1">
<span class="t-li">4)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is greater than or equal to <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <div class="t-li1">
<span class="t-li">5)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is equal to <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <div class="t-li1">
<span class="t-li">6)</span> Returns <code>true</code> if <span class="t-spar">lhs</span> is not equal to <span class="t-spar">rhs</span>, <code>false</code> otherwise.</div> <h4 id="Built-in_two-way_comparison_operators"> Built-in two-way comparison operators</h4> <p>For the built-in operators, <a href="implicit_conversion.html#Lvalue-to-rvalue_conversion" title="cpp/language/implicit conversion">lvalue-to-rvalue conversions</a>, <a href="implicit_conversion.html#Array-to-pointer_conversion" title="cpp/language/implicit conversion">array-to-pointer conversions</a> and <a href="implicit_conversion.html#Function-to-pointer_conversion" title="cpp/language/implicit conversion">function-to-pointer conversions</a> are applied to <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span>. <span class="t-rev-inl t-since-cxx20"><span>The comparison is deprecated if both <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> have array type prior to the application of these conversions.</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span></p>
<p>For the built-in operators, the result is a <span class="kw4">bool</span> prvalue.</p>
<h4 id="Built-in_arithmetic_comparison"> Built-in arithmetic comparison</h4> <p>If the converted operands both have arithmetic or enumeration type (scoped or unscoped), <a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> are performed on both operands. The values are compared after conversions:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
int main()
{
    static_assert(sizeof(unsigned char) &lt; sizeof(int),
                  "Can't compare signed and smaller unsigned properly");
    int a = -1;
    int b = 1;
    unsigned int c = 1;
    unsigned char d = 1;
 
    std::cout
        &lt;&lt; std::boolalpha
        &lt;&lt; "Comparing two signed values:\n"
        &lt;&lt; " -1 == 1 ? " &lt;&lt; (a == b) &lt;&lt; '\n'
        &lt;&lt; " -1 &lt;  1 ? " &lt;&lt; (a &lt;  b) &lt;&lt; '\n'
        &lt;&lt; " -1 &gt;  1 ? " &lt;&lt; (a &gt;  b) &lt;&lt; '\n'
        &lt;&lt; "Comparing signed and unsigned:\n"
        &lt;&lt; " -1 == 1 ? " &lt;&lt; (a == c) &lt;&lt; '\n' // may issue different-signedness warning
        &lt;&lt; " -1 &lt;  1 ? " &lt;&lt; (a &lt;  c) &lt;&lt; '\n' // may issue different-signedness warning
        &lt;&lt; " -1 &gt;  1 ? " &lt;&lt; (a &gt;  c) &lt;&lt; '\n' // may issue different-signedness warning
        &lt;&lt; "Comparing signed and smaller unsigned:\n"
        &lt;&lt; " -1 == 1 ? " &lt;&lt; (a == d) &lt;&lt; '\n'
        &lt;&lt; " -1 &lt;  1 ? " &lt;&lt; (a &lt;  d) &lt;&lt; '\n'
        &lt;&lt; " -1 &gt;  1 ? " &lt;&lt; (a &gt;  d) &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Comparing two signed values:
 -1 == 1 ? false
 -1 &lt;  1 ? true
 -1 &gt;  1 ? false
Comparing signed and unsigned:
 -1 == 1 ? false
 -1 &lt;  1 ? false
 -1 &gt;  1 ? true
Comparing signed and smaller unsigned:
 -1 == 1 ? false
 -1 &lt;  1 ? true
 -1 &gt;  1 ? false</pre></div> </div> <h4 id="Built-in_pointer_equality_comparison"> Built-in pointer equality comparison</h4> <p>The converted operands of equality operators <code>==</code> and <code>!=</code> can also have<span class="t-rev-inl t-since-cxx11"><span> the type <code><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></code>,</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> pointer type or pointer-to-member type.</p>
<p>Built-in pointer equality comparison has three possible results: equal, unequal and unspecified. The values yielded by equality operators for built-in pointer equality comparison is listed below:</p>
<table class="wikitable"> <tr> <th rowspan="2"> Comparison result <br>of <code>p</code> and <code>q</code> </th> <th colspan="2">Value yielded by </th>
</tr> <tr> <th>
<code>p == q</code> </th> <th>
<code>p != q</code> </th>
</tr> <tr> <td>equal </td> <td>
<code>true</code> </td> <td>
<code>false</code> </td>
</tr> <tr> <td>unequal </td> <td>
<code>false</code> </td> <td>
<code>true</code> </td>
</tr> <tr> <td>unspecified </td> <td colspan="2"> unspecified <span class="kw4">bool</span> value </td>
</tr>
</table> <p>If at least one of converted <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> is a pointer, <a href="implicit_conversion.html#Pointer_conversions" title="cpp/language/implicit conversion">pointer conversions</a><span class="t-rev-inl t-since-cxx17"><span>, <a href="implicit_conversion.html#Function_pointer_conversions" title="cpp/language/implicit conversion">function pointer conversions</a></span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> and <a href="implicit_conversion.html#Qualification_conversions" title="cpp/language/implicit conversion">qualification conversions</a> are performed on both converted operands to bring them to their <a href="pointer.html#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>. The two pointers of the composite pointer type are compared as follows:</p>
<ul><li> If one pointer <a href="pointer.html#Pointers" title="cpp/language/pointer">represents the address</a> of a complete object, and another pointer </li></ul> <dl>
<dd>
<ul>
<li> represents the address past the end of a different complete non-array object, or </li>
<li> represents the address one past the last element of a different complete array object, </li>
</ul> </dd>
<dd> the result of the comparison is unspecified. </dd>
</dl> <ul>
<li> Otherwise, if the pointers are both null, both point to the same function, or both represent the same address (i.e., they point to or are past the end of the same object), they compare equal. </li>
<li> Otherwise, the pointers compare unequal. </li>
</ul> <p>If at least one of converted <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> is a pointer to member, <a href="implicit_conversion.html#Pointer-to-member_conversions" title="cpp/language/implicit conversion">pointer-to-member conversions</a><span class="t-rev-inl t-since-cxx17"><span>, <a href="implicit_conversion.html#Function_pointer_conversions" title="cpp/language/implicit conversion">function pointer conversions</a></span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> and <a href="implicit_conversion.html#Qualification_conversions" title="cpp/language/implicit conversion">qualification conversions</a> are performed on both converted operands to bring them to their <a href="pointer.html#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>. The two pointers to members of the composite pointer type are compared as follows:</p>
<ul>
<li> If two pointers to members are both the null member pointer value, they compare equal. </li>
<li> If only one of two pointers to members is the null member pointer value, they compare unequal. </li>
<li> If either is a pointer to a <a href="virtual.html" title="cpp/language/virtual">virtual member function</a>, the result is unspecified. </li>
<li> If one refers to a member of class <code>C1</code> and the other refers to a member of a different class <code>C2</code>, where neither is a base class of the other, the result is unspecified. </li>
<li> If both refer to (possibly different) members of the same <a href="union.html" title="cpp/language/union">union</a>, they compare equal. </li>
<li> Otherwise, two pointers to members compare equal if they would refer to the same member of the same <a href="object.html#Subobjects" title="cpp/language/object">most derived object</a> or the same subobject if indirection with a hypothetical object of the associated class type were performed, otherwise they compare unequal. </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">struct P {};
struct Q : P { int x; };
struct R : P { int x; };
 
int P::*bx = (int(P::*)) &amp;Q::x;
int P::*cx = (int(P::*)) &amp;R::x;
 
bool b1 = (bx == cx); // unspecified
 
struct B
{
    int f();
};
struct L : B {};
struct R : B {};
struct D : L, R {};
 
int (B::*pb)() = &amp;B::f;
int (L::*pl)() = pb;
int (R::*pr)() = pb;
int (D::*pdl)() = pl;
int (D::*pdr)() = pr;
 
bool x = (pdl == pdr); // false
bool y = (pb == pl);   // true</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Two operands of type <code><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></code> or one operand of type <code><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></code> and the other a null pointer constant compare equal.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h4 id="Built-in_pointer_relational_comparison"> Built-in pointer relational comparison</h4> <p>The converted operands of relational operators <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> and <code>&lt;=</code> can also have pointer type.</p>
<p>Built-in pointer relational comparison on unequal pointers <code>p</code> and <code>q</code> has three possible results: <code>p</code> is greater, <code>q</code> is greater and unspecified. The values yielded by relational operators for built-in pointer relational comparison is listed below:</p>
<table class="wikitable"> <tr> <th rowspan="2"> Comparison result <br>of <code>p</code> and <code>q</code> </th> <th colspan="4">Value yielded by </th>
</tr> <tr> <th> <code>p &gt; q</code> </th> <th> <code>p &lt; q</code> </th> <th> <code>p &gt;= q</code> </th> <th> <code>p &lt;= q</code> </th>
</tr> <tr> <td>equal </td> <td>
<code>false</code> </td> <td>
<code>false</code> </td> <td>
<code>true</code> </td> <td>
<code>true</code> </td>
</tr> <tr> <td>
<code>p</code> is greater </td> <td>
<code>true</code> </td> <td>
<code>false</code> </td> <td>
<code>true</code> </td> <td>
<code>false</code> </td>
</tr> <tr> <td>
<code>q</code> is greater </td> <td>
<code>false</code> </td> <td>
<code>true</code> </td> <td>
<code>false</code> </td> <td>
<code>true</code> </td>
</tr> <tr> <td>unspecified </td> <td colspan="4">unspecified <span class="kw4">bool</span> value </td>
</tr>
</table> <p>If converted <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> are both pointers, <a href="implicit_conversion.html#Pointer_conversions" title="cpp/language/implicit conversion">pointer conversions</a><span class="t-rev-inl t-since-cxx17"><span>, <a href="implicit_conversion.html#Function_pointer_conversions" title="cpp/language/implicit conversion">function pointer conversions</a></span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> and <a href="implicit_conversion.html#Qualification_conversions" title="cpp/language/implicit conversion">qualification conversions</a> are performed on both converted operands to bring them to their <a href="pointer.html#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>. The two pointers of the composite pointer type are compared as follows:</p>
<ul>
<li> If the pointers compare equal or the equality comparison result is unspecified, the relational comparison result falls into the same category. </li>
<li> Otherwise (the pointers compare unequal), if any of the pointers is not a pointer to object, the result is unspecified. </li>
<li> Otherwise (both pointers point to objects), the result is defined in terms of a partial order consistent with the following rules: </li>
<ul>
<li> Given two different elements <code>high</code> and <code>low</code> of an array such than <code>high</code> has higher subscript than <code>low</code>, if one pointer points to <code>high</code> (or a subobject of <code>high</code>) and the other pointer points to <code>low</code> (or a subobject of <code>low</code>), the former compares greater than the latter. </li>
<li> If one pointer points to an element <code>elem</code> (or to a subobject of <code>elem</code>) of an array, and the other pointer is past the end of the same array, the past-the-end pointer compares greater than the other pointer. </li>
<li> If one pointer points to a complete object, a base class subobject or a member subobject <code>obj</code> (or to a subobject of <code>obj</code>), and the other pointer is past the end of <code>obj</code>, the past-the-end pointer compares greater than the other pointer. </li>
</ul>
</ul>  <ul>
<li> If the pointers point to different<span class="t-rev-inl t-since-cxx20"><span> <a href="attributes/no_unique_address.html" title="cpp/language/attributes/no unique address">non-zero-sized</a></span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> non-static data members<span class="t-rev-inl t-until-cxx23"><span> with the same <a href="access.html" title="cpp/language/access">member access</a></span><span><span class="t-mark-rev t-until-cxx23">(until C++23)</span></span></span> of the same object of a non-union class type, or to subobjects of such members, recursively, the pointer to the later declared member compares greater than the other pointer. </li>
<li> Otherwise, the result is unspecified. </li>
</ul> <h4 id="Pointer_total_order"> Pointer total order</h4> <p>There exists an <i>implementation-defined strict total order over pointers</i> in each program. The strict total order is consistent with the partial order described above: unspecified results become implementation-defined, while other results stay the same.</p>
<p>Pointer comparison with the strict total order is applied in the following cases:</p>
<ul><li> Calling the operator<span class="br0">(</span><span class="br0">)</span> of the pointer type specializations of <code><a href="../utility/functional/less.html" title="cpp/utility/functional/less">std::less</a></code>, <code><a href="../utility/functional/greater.html" title="cpp/utility/functional/greater">std::greater</a></code>, <code><a href="../utility/functional/less_equal.html" title="cpp/utility/functional/less equal">std::less_equal</a></code>, and <code><a href="../utility/functional/greater_equal.html" title="cpp/utility/functional/greater equal">std::greater_equal</a></code>. </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <ul><li> Calling built-in operators comparing pointers from the operator<span class="br0">(</span><span class="br0">)</span> of specializations <a href="../utility/functional/less_void.html" title="cpp/utility/functional/less void"><code>std::less&lt;void&gt;</code></a>, <a href="../utility/functional/greater_void.html" title="cpp/utility/functional/greater void"><code>std::greater&lt;void&gt;</code></a>, <a href="../utility/functional/less_equal_void.html" title="cpp/utility/functional/less equal void"><code>std::less_equal&lt;void&gt;</code></a>, and <a href="../utility/functional/greater_equal_void.html" title="cpp/utility/functional/greater equal void"><code>std::greater_equal&lt;void&gt;</code></a>. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <ul>
<li> Calling built-in operator<span class="sy1">&lt;=&gt;</span> comparing pointers from the operator<span class="br0">(</span><span class="br0">)</span> of <code><a href="../utility/compare/compare_three_way.html" title="cpp/utility/compare/compare three way">std::compare_three_way</a></code>. </li>
<li> Calling built-in operator<span class="sy1">==</span> comparing pointers from the operator<span class="br0">(</span><span class="br0">)</span> of <a href="../utility/functional/ranges/equal_to.html" title="cpp/utility/functional/ranges/equal to"><code>std::ranges::equal_to</code></a> and <a href="../utility/functional/ranges/not_equal_to.html" title="cpp/utility/functional/ranges/not equal to"><code>std::ranges::not_equal_to</code></a>. </li>
<li> Calling built-in operator<span class="sy1">&lt;</span> comparing pointers from the operator<span class="br0">(</span><span class="br0">)</span> of <a href="../utility/functional/ranges/less.html" title="cpp/utility/functional/ranges/less"><code>std::ranges::less</code></a>, <a href="../utility/functional/ranges/greater.html" title="cpp/utility/functional/ranges/greater"><code>std::ranges::greater</code></a>, <a href="../utility/functional/ranges/less_equal.html" title="cpp/utility/functional/ranges/less equal"><code>std::ranges::less_equal</code></a>, and <a href="../utility/functional/ranges/greater_equal.html" title="cpp/utility/functional/ranges/greater equal"><code>std::ranges::greater_equal</code></a>. </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h4 id="Overloads"> Overloads</h4> <p>In <a href="overload_resolution.html#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every pair of promoted arithmetic types <code>L</code> and <code>R</code>, including enumeration types, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&lt;(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&gt;(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&lt;=(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&gt;=(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator==(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator!=(L, R);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>For every type <code>P</code> which is either pointer to object or pointer to function, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&lt;(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&gt;(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&lt;=(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator&gt;=(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator==(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator!=(P, P);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>For every type <code>MP</code> that is a pointer to member object or pointer to member function<span class="t-rev-inl t-since-cxx11"><span> or <code><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></code></span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator==(MP, MP);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool operator!=(MP, MP);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
struct Foo
{
    int n1;
    int n2;
};
 
union Union
{
    int n;
    double d;
};
 
int main()
{
    std::cout &lt;&lt; std::boolalpha;
 
    char a[4] = "abc";
    char* p1 = &amp;a[1];
    char* p2 = &amp;a[2];
    std::cout &lt;&lt; "Pointers to array elements:\n"
              &lt;&lt; "p1 == p2? " &lt;&lt; (p1 == p2) &lt;&lt; '\n'
              &lt;&lt; "p1 &lt;  p2? " &lt;&lt; (p1 &lt;  p2) &lt;&lt; '\n';
 
    Foo f;
    int* p3 = &amp;f.n1;
    int* p4 = &amp;f.n2;
    std::cout &lt;&lt; "Pointers to members of a class:\n"
              &lt;&lt; "p3 == p4? " &lt;&lt; (p3 == p4) &lt;&lt; '\n'
              &lt;&lt; "p3 &lt;  p4? " &lt;&lt; (p3 &lt;  p4) &lt;&lt; '\n';
 
    Union u;
    int* p5 = &amp;u.n;
    double* p6 = &amp;u.d;
    std::cout &lt;&lt; "Pointers to members of a union:\n"
              &lt;&lt; "p5 == (void*)p6? " &lt;&lt; (p5 == (void*)p6) &lt;&lt; '\n'
              &lt;&lt; "p5 &lt;  (void*)p6? " &lt;&lt; (p5 &lt;  (void*)p6) &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Pointers to array elements:
p1 == p2? false
p1 &lt;  p2? true
Pointers to members of a class:
p3 == p4? false
p3 &lt;  p4? true
Pointers to members of a union:
p5 == (void*)p6? true
p5 &lt;  (void*)p6? false</pre></div> </div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h3 id="Three-way_comparison"> Three-way comparison</h3> <p>The three-way comparison operator expressions have the form</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">a</span> <code>&lt;=&gt;</code> <span class="t-spar">b</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>The expression returns an object such that</p>
<ul>
<li> <code>(a &lt;=&gt; b) &lt; 0</code> if <code>a &lt; b</code>, </li>
<li> <code>(a &lt;=&gt; b) &gt; 0</code> if <code>a &gt; b</code>, </li>
<li> <code>(a &lt;=&gt; b) == 0</code> if <code>a</code> and <code>b</code> are equal/equivalent. </li>
</ul> <p>If one of the operands is of type <span class="kw4">bool</span> and the other is not, the program is ill-formed.</p>
<p>If both operands have arithmetic types, or if one operand has unscoped enumeration type and the other has integral type, the usual arithmetic conversions are applied to the operands, and then</p>
<ul>
<li> If a narrowing conversion is required, other than from an integral type to a floating point type, the program is ill-formed. </li>
<li> Otherwise, if the operands have integral type, the operator yields a prvalue of type <a href="../utility/compare/strong_ordering.html" title="cpp/utility/compare/strong ordering"><code>std::strong_ordering</code></a>: </li>
<ul>
<li> <code>std::strong_ordering::equal</code> if both operands are arithmetically equal, </li>
<li> <code>std::strong_ordering::less</code> if the first operand is arithmetically less than the second, </li>
<li> <code>std::strong_ordering::greater</code> otherwise. </li>
</ul>
<li> Otherwise, the operands have floating-point type, and the operator yields a prvalue of type <a href="../utility/compare/partial_ordering.html" title="cpp/utility/compare/partial ordering"><code>std::partial_ordering</code></a>. The expression <code>a &lt;=&gt; b</code> yields </li>
<ul>
<li> <code>std::partial_ordering::less</code> if <code>a</code> is less than <code>b</code>, </li>
<li> <code>std::partial_ordering::greater</code> if <code>a</code> is greater than <code>b</code>, </li>
<li> <code>std::partial_ordering::equivalent</code> if <code>a</code> is equivalent to <code>b</code> (<code>-0 &lt;=&gt; +0</code> is equivalent), </li>
<li> <code>std::partial_ordering::unordered</code> (<code>NaN &lt;=&gt; anything</code> is unordered). </li>
</ul>
</ul>    <p>If both operands have the same enumeration type <code>E</code>, the operator yields the result of converting the operands to the underlying type of E and applying <code>&lt;=&gt;</code> to the converted operands.</p>
<p>If at least one of the operands is a pointer to object or pointer to member, <a href="implicit_conversion.html#Array-to-pointer_conversion" title="cpp/language/implicit conversion">array-to-pointer conversions</a>, <a href="implicit_conversion.html#Pointer_conversions" title="cpp/language/implicit conversion">pointer conversions</a> and <a href="implicit_conversion.html#Qualification_conversions" title="cpp/language/implicit conversion">qualification conversions</a> are applied to both operands to bring them to their <a href="pointer.html#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>.</p>
<p>For converted pointer operands <code>p</code> and <code>q</code>, <code>p &lt;=&gt; q</code> returns a prvalue of type <a href="../utility/compare/strong_ordering.html" title="cpp/utility/compare/strong ordering"><code>std::strong_ordering</code></a>:</p>
<ul>
<li> <code>std::strong_ordering::equal</code> if they <a href="#Built-in_pointer_equality_comparison">compare equal</a>, </li>
<li> <code>std::strong_ordering::less</code> if <code>q</code> <a href="#Built-in_pointer_relational_comparison">compares greater than</a> <code>p</code>, </li>
<li> <code>std::strong_ordering::greater</code> if <code>p</code> compares greater than <code>q</code>, </li>
<li> unspecified result if the two-way comparison result is unspecified. </li>
</ul> <p>Otherwise, the program is ill-formed.</p>
<h4 id="Overloads_2"> Overloads</h4> <p>In <a href="overload_resolution.html#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for pointer or enumeration type <code>T</code>, the following function signature participates in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">R operator&lt;=&gt;(T, T);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Where <code>R</code> is the ordering category type defined above.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;compare&gt;
#include &lt;iostream&gt;
 
int main()
{
    double foo = -0.0;
    double bar = 0.0;
 
    auto res = foo &lt;=&gt; bar;
 
    if (res &lt; 0)
        std::cout &lt;&lt; "-0 is less than 0";
    else if (res &gt; 0)
        std::cout &lt;&lt; "-0 is greater than 0";
    else if (res == 0)
        std::cout &lt;&lt; "-0 and 0 are equal";
    else
        std::cout &lt;&lt; "-0 and 0 are unordered";
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">-0 and 0 are equal</pre></div>  </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h3 id="Notes"> Notes</h3> <p>Because comparison operators group left-to-right, the expression <code>a &lt; b &lt; c</code> is parsed <code>(a &lt; b) &lt; c</code>, and not <code>a &lt; (b &lt; c)</code> or <code>(a &lt; b) &amp;&amp; (b &lt; c)</code>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
int main()
{
    int a = 3, b = 2, c = 1;
 
    std::cout &lt;&lt; std::boolalpha
        &lt;&lt; (a &lt; b &lt; c) &lt;&lt; '\n' // true; maybe warning
        &lt;&lt; ((a &lt; b) &lt; c) &lt;&lt; '\n' // true
        &lt;&lt; (a &lt; (b &lt; c)) &lt;&lt; '\n' // false
        &lt;&lt; ((a &lt; b) &amp;&amp; (b &lt; c)) &lt;&lt; '\n'; // false
}</pre></div> </div> <p>A common requirement for <a href="operators.html#Comparison_operators" title="cpp/language/operators">user-defined operator&lt;</a> is <a href="https://en.wikipedia.org/wiki/Strict_weak_ordering" class="extiw" title="enwiki:Strict weak ordering">strict weak ordering</a>. In particular, this is required by the standard algorithms and containers that work with <a href="../named_req/compare.html" title="cpp/named req/Compare">Compare</a> types: <code><a href="../algorithm/sort.html" title="cpp/algorithm/sort">std::sort</a></code>, <code><a href="../algorithm/max_element.html" title="cpp/algorithm/max element">std::max_element</a></code>, <code><a href="../container/map.html" title="cpp/container/map">std::map</a></code>, etc.</p>
<p>The <a href="#Member_layout">comparison result</a> of pointers to different non-static data members of the same class implies that non-static data members<span class="t-rev-inl t-until-cxx23"><span> in each of the three <a href="access.html" title="cpp/language/access">member access modes</a></span><span><span class="t-mark-rev t-until-cxx23">(until C++23)</span></span></span> are positioned in memory in order of declaration.</p>
<p>Although the results of comparing pointers of random origin (e.g. not all pointing to members of the same array) is unspecified, many implementations provide <a href="https://en.wikipedia.org/wiki/Total_order#Strict_total_order" class="extiw" title="enwiki:Total order">strict total ordering</a> of pointers, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of <code><a href="../utility/functional/less.html" title="cpp/utility/functional/less">std::less</a></code> for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as <code><a href="../container/set.html" title="cpp/container/set">std::set</a></code> or <code><a href="../container/map.html" title="cpp/container/map">std::map</a></code>.</p>
<p>For the types that are both <a href="../named_req/equalitycomparable.html" title="cpp/named req/EqualityComparable">EqualityComparable</a> and <a href="../named_req/lessthancomparable.html" title="cpp/named req/LessThanComparable">LessThanComparable</a>, the C++ standard library makes a distinction between <i>equality</i>, which is the value of the expression <code>a == b</code> and <i>equivalence</i>, which is the value of the expression <code>!(a &lt; b) &amp;&amp; !(b &lt; a)</code>.</p>
<p>Comparison between pointers and null pointer constants was removed by the resolution of <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/583.html">CWG issue 583</a> included in <a rel="nofollow" class="external text" href="https://wg21.link/N3624">N3624</a>:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">void f(char* p)
{
    if (p &gt; 0) { /*...*/ } // Error with N3624, compiled before N3624
    if (p &gt; nullptr) { /*...*/ } // Error with N3624, compiled before N3624
}
 
int main() {}</pre></div> </div> <p>Three-way comparison can be automatically generated for class types, see <a href="default_comparisons.html" title="cpp/language/default comparisons">default comparisons</a>.</p>
<p>If both of the operands are arrays, three-way comparison is ill-formed.</p>
<div class="cpp source-cpp"><pre data-language="cpp">unsigned int i = 1;
auto r = -1 &lt; i;    // existing pitfall: returns ‘false’
auto r2 = -1 &lt;=&gt; i; // Error: narrowing conversion required</pre></div> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test.html" title="cpp/utility/feature test">Feature-test</a> macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Feature </th>
</tr> <tr> <td><a href="../feature_test.html#cpp_impl_three_way_comparison" title="cpp/feature test"><code>__cpp_impl_three_way_comparison</code></a></td> <td><span class="nu0">201907L</span></td> <td><span class="t-mark">(C++20)</span></td> <td>Three-way comparison (compiler support) </td>
</tr> <tr> <td><a href="../feature_test.html#cpp_lib_three_way_comparison" title="cpp/feature test"><code>__cpp_lib_three_way_comparison</code></a></td> <td><span class="nu0">201907L</span></td> <td><span class="t-mark">(C++20)</span></td> <td>Three-way comparison (library support); adding three-way comparison to the library </td>
</tr>
</table> <h3 id="Standard_library"> Standard library</h3> <p>Comparison operators are overloaded for many classes in the standard library.</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../types/type_info/operator_cmp.html" title="cpp/types/type info/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> checks whether the objects refer to the same type <br> <span class="t-mark">(public member function of <code>std::type_info</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../error/error_code/operator_cmp.html" title="cpp/error/error code/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares two <code>error_code</code>s <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../error/error_condition/operator_cmp.html" title="cpp/error/error condition/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares <code>error_condition</code>s and <code>error_code</code>s <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/pair/operator_cmp.html" title="cpp/utility/pair/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values in the pair <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/tuple/operator_cmp.html" title="cpp/utility/tuple/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values in the tuple <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_cmp.html" title="cpp/utility/bitset/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares the contents <br> <span class="t-mark">(public member function of <code>std::bitset&lt;N&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator/operator_cmp.html" title="cpp/memory/allocator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares two allocator instances <br> <span class="t-mark">(public member function of <code>std::allocator&lt;T&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/operator_cmp.html" title="cpp/memory/unique ptr/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares to another <code>unique_ptr</code> or with <code>nullptr</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/operator_cmp.html" title="cpp/memory/shared ptr/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares with another <code>shared_ptr</code> or with <code>nullptr</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/function/operator_cmp.html" title="cpp/utility/functional/function/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares a <code><a href="../utility/functional/function.html" title="cpp/utility/functional/function">std::function</a></code> with <code>nullptr</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/duration/operator_cmp.html" title="cpp/chrono/duration/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares two durations <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/time_point/operator_cmp.html" title="cpp/chrono/time point/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares two time points <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/scoped_allocator_adaptor/operator_cmp.html" title="cpp/memory/scoped allocator adaptor/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares two scoped_allocator_adaptor instances <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../types/type_index/operator_cmp.html" title="cpp/types/type index/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares the underlying <code><a href="../types/type_info.html" title="cpp/types/type info">std::type_info</a></code> objects <br> <span class="t-mark">(public member function of <code>std::type_index</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_cmp.html" title="cpp/string/basic string/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&gt;</span><span>operator&lt;=</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares two strings <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../locale/locale/operator_cmp.html" title="cpp/locale/locale/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> equality comparison between locale objects <br> <span class="t-mark">(public member function of <code>std::locale</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/array/operator_cmp.html" title="cpp/container/array/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>arrays</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/deque/operator_cmp.html" title="cpp/container/deque/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>deques</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/forward_list/operator_cmp.html" title="cpp/container/forward list/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>forward_lists</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/list/operator_cmp.html" title="cpp/container/list/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>lists</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/vector/operator_cmp.html" title="cpp/container/vector/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>vectors</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/map/operator_cmp.html" title="cpp/container/map/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>maps</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/multimap/operator_cmp.html" title="cpp/container/multimap/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>multimaps</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/set/operator_cmp.html" title="cpp/container/set/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>sets</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/multiset/operator_cmp.html" title="cpp/container/multiset/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>multisets</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_map/operator_cmp.html" title="cpp/container/unordered map/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares the values in the unordered_map <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multimap/operator_cmp.html" title="cpp/container/unordered multimap/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares the values in the unordered_multimap <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_set/operator_cmp.html" title="cpp/container/unordered set/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares the values in the unordered_set <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multiset/operator_cmp.html" title="cpp/container/unordered multiset/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares the values in the unordered_multiset <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/queue/operator_cmp.html" title="cpp/container/queue/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>queues</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/stack/operator_cmp.html" title="cpp/container/stack/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares the values of two <code>stacks</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator_cmp.html" title="cpp/iterator/reverse iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares the underlying iterators <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator_cmp.html" title="cpp/iterator/move iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares the underlying iterators <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istream_iterator/operator_cmp.html" title="cpp/iterator/istream iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares two <code>istream_iterator</code>s <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istreambuf_iterator/operator_cmp.html" title="cpp/iterator/istreambuf iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares two <code>istreambuf_iterator</code>s <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_cmp.html" title="cpp/numeric/complex/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares two complex numbers or a complex and a scalar <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_cmp.html" title="cpp/numeric/valarray/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares two valarrays or a valarray with a value <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/linear_congruential_engine/operator_cmp.html" title="cpp/numeric/random/linear congruential engine/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares the internal states of two pseudo-random number engines <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/poisson_distribution/operator_cmp.html" title="cpp/numeric/random/poisson distribution/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares two distribution objects <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/sub_match/operator_cmp.html" title="cpp/regex/sub match/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares a <code>sub_match</code> with another <code>sub_match</code>, a string, or a character <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/match_results/operator_cmp.html" title="cpp/regex/match results/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> lexicographically compares the values in the two match result <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/regex_iterator/operator_cmp.html" title="cpp/regex/regex iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares two <code>regex_iterator</code>s <br> <span class="t-mark">(public member function of <code>std::regex_iterator&lt;BidirIt,CharT,Traits&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/regex_token_iterator/operator_cmp.html" title="cpp/regex/regex token iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> compares two <code>regex_token_iterator</code>s <br> <span class="t-mark">(public member function of <code>std::regex_token_iterator&lt;BidirIt,CharT,Traits&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../thread/thread/id/operator_cmp.html" title="cpp/thread/thread/id/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares two <code>thread::id</code> objects <br> <span class="t-mark">(function)</span>  </td>
</tr> </table> <p>The namespace <a href="../utility/rel_ops/operator_cmp.html" title="cpp/utility/rel ops/operator cmp"><code>std::rel_ops</code></a> provides generic operators <code>!=</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>:</p>
<table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2"> Defined in header <code><a href="../header/utility.html" title="cpp/header/utility">&lt;utility&gt;</a></code>  </th>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::rel_ops</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/rel_ops/operator_cmp.html" title="cpp/utility/rel ops/operator cmp"> <span class="t-lines"><span>operator!=</span><span>operator&gt;</span><span>operator&lt;=</span><span>operator&gt;=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++20)</span></span></span></div> </td> <td> automatically generates comparison operators based on user-defined <code>operator==</code> and <code>operator&lt;</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/583.html">CWG 583</a><br>(<a rel="nofollow" class="external text" href="https://wg21.link/N3624">N3624</a>) </td> <td>C++98 </td> <td>all six comparison operators could be used to<br>compare a pointer with a null pointer constant </td> <td>only equality operators allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/661.html">CWG 661</a> </td> <td>C++98 </td> <td>the actual semantics of arithmetic comparisons (e.g.<br>whether <code>1 &lt; 2</code> yields <code>true</code> or <code>false</code>) were unspecified </td> <td>specification added </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/879.html">CWG 879</a> </td> <td>C++98 </td> <td>pointers to function types and pointers<br>to <span class="kw4">void</span> did not have built-in comparisons </td> <td>added comparison specification<br>for these pointers </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1596.html">CWG 1596</a> </td> <td>C++98 </td> <td>non-array objects were considered to belong to arrays with<br>one element only for the purpose of pointer arithmetic </td> <td>the rule is also<br>applied to comparison </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1598.html">CWG 1598</a> </td> <td>C++98 </td> <td>two pointers to members of classes that are different and<br>neither is the base class of the other did not compare equal<br>even if the offsets of the pointed members can be the same </td> <td>the result is<br>unspecified<br>in this case </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1858.html">CWG 1858</a> </td> <td>C++98 </td> <td>it was not clear whether two pointers to members<br>that refer to different members of the same union<br>compare equal as if they refer to the same member </td> <td>they compare<br>equal in this case </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2419.html">CWG 2419</a> </td> <td>C++98 </td> <td>a pointer to non-array object was only treated as a<br>pointer to the first element of an array with size 1<br>in pointer comparison if the pointer is obtained by <code>&amp;</code> </td> <td>applies to all pointers<br>to non-array objects </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2526.html">CWG 2526</a> </td> <td>C++98 </td> <td>the definition of relational comparison (<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> and <code>&lt;=</code>) of<br>pointers to <span class="kw4">void</span> and function pointers were removed by <a rel="nofollow" class="external text" href="https://wg21.link/N3624">N3624</a> </td> <td>restored </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <ul>
<li> <a href="operator_precedence.html" title="cpp/language/operator precedence">Operator precedence</a> </li>
<li> <a href="operators.html" title="cpp/language/operators">Operator overloading</a> </li>
<li> <a href="../named_req/compare.html" title="cpp/named req/Compare">Compare</a> (named requirements) </li>
</ul> <table class="wikitable"> <tr style="text-align:center"> <th colspan="7">Common operators </th>
</tr> <tr style="text-align:center"> <td>
<a href="operator_assignment.html" title="cpp/language/operator assignment">assignment</a> </td> <td>
<a href="operator_incdec.html" title="cpp/language/operator incdec">increment<br>decrement</a> </td> <td>
<a href="operator_arithmetic.html" title="cpp/language/operator arithmetic">arithmetic</a> </td> <td>
<a href="operator_logical.html" title="cpp/language/operator logical">logical</a> </td> <td>
<strong class="selflink">comparison</strong> </td> <td>
<a href="operator_member_access.html" title="cpp/language/operator member access">member<br>access</a> </td> <td>
<a href="operator_other.html" title="cpp/language/operator other">other</a> </td>
</tr> <tr style="text-align:center"> <td rowspan="6"> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code></p>
</td> <td rowspan="6"> <p><code>++a --a a++ a--</code></p>
</td> <td rowspan="6"> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code></p>
</td> <td rowspan="6"> <p><code>!a a &amp;&amp; b a || b</code></p>
</td> <td rowspan="6"> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b a &lt;=&gt; b</code></p>
</td> <td rowspan="6"> <p><code>a[...] *a &amp;a a-&gt;b a.b a-&gt;*b a.*b</code></p>
</td> <td>function call </td>
</tr> <tr style="text-align:center"> <td>
<code>a(...)</code> </td>
</tr> <tr style="text-align:center"> <td>comma </td>
</tr> <tr style="text-align:center"> <td>
<code>a, b</code> </td>
</tr> <tr style="text-align:center"> <td>conditional </td>
</tr> <tr style="text-align:center"> <td>
<code>a ? b : c</code> </td>
</tr> <tr> <th colspan="7">Special operators </th>
</tr> <tr> <td colspan="7"> <p><a href="static_cast.html" title="cpp/language/static cast"><code>static_cast</code></a> converts one type to another related type <br> <a href="dynamic_cast.html" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a> converts within inheritance hierarchies <br> <a href="const_cast.html" title="cpp/language/const cast"><code>const_cast</code></a> adds or removes <a href="cv.html" title="cpp/language/cv">cv</a>-qualifiers<br> <a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> converts type to unrelated type<br> <a href="explicit_cast.html" title="cpp/language/explicit cast">C-style cast</a> converts one type to another by a mix of <code>static_cast</code>, <code>const_cast</code>, and <code>reinterpret_cast</code> <br> <a href="new.html" title="cpp/language/new"><code>new</code></a> creates objects with dynamic storage duration<br> <a href="delete.html" title="cpp/language/delete"><code>delete</code></a> destructs objects previously created by the new expression and releases obtained memory area<br> <a href="sizeof.html" title="cpp/language/sizeof"><code>sizeof</code></a> queries the size of a type<br> <a href="sizeof....html" title="cpp/language/sizeof..."><code>sizeof...</code></a> queries the size of a <a href="parameter_pack.html" title="cpp/language/parameter pack">parameter pack</a> <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br> <a href="typeid.html" title="cpp/language/typeid"><code>typeid</code></a> queries the type information of a type<br> <a href="noexcept.html" title="cpp/language/noexcept"><code>noexcept</code></a> checks if an expression can throw an exception <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br> <a href="alignof.html" title="cpp/language/alignof"><code>alignof</code></a> queries alignment requirements of a type <span class="t-mark-rev t-since-cxx11">(since C++11)</span></p>
</td>
</tr>
</table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/operator_comparison" title="c/language/operator comparison">C documentation</a></span> for <span class=""><span>Comparison operators</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/operator_comparison" class="_attribution-link">https://en.cppreference.com/w/cpp/language/operator_comparison</a>
  </p>
</div>
