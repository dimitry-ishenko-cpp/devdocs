    <h1 id="firstHeading" class="firstHeading">std::search_n</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/algorithm.html" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">template&lt; class ForwardIt, class Size, class T &gt;
ForwardIt search_n( ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value );</pre></td>  <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class ForwardIt, class Size, class T &gt;
constexpr ForwardIt search_n( ForwardIt first, ForwardIt last,
                              Size count, const T&amp; value );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt; class ExecutionPolicy, class ForwardIt, class Size, class T &gt;
ForwardIt search_n( ExecutionPolicy&amp;&amp; policy, ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value );</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">template&lt; class ForwardIt, class Size, class T, class BinaryPredicate &gt;
ForwardIt search_n( ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value, BinaryPredicate p );</pre></td>  <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class ForwardIt, class Size, class T, class BinaryPredicate &gt;
constexpr ForwardIt search_n( ForwardIt first, ForwardIt last,
                              Size count, const T&amp; value, BinaryPredicate p );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt; class ExecutionPolicy, class ForwardIt,
          class Size, class T, class BinaryPredicate &gt;
ForwardIt search_n( ExecutionPolicy&amp;&amp; policy, ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value, BinaryPredicate p );</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Searches the range <code>[</code><code>first</code><code>, </code><code>last</code><code>)</code> for the first sequence of <code>count</code> identical elements, each equal to the given <code>value</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span> Elements are compared using <code>operator==</code>.</div> <div class="t-li1">
<span class="t-li">3)</span> Elements are compared using the given binary predicate <code>p</code>.</div> <div class="t-li1">
<span class="t-li">2,4)</span> Same as <span class="t-v">(1,3)</span>, but executed according to <code>policy</code>. These overloads do not participate in overload resolution unless <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">std::<span class="me2">is_execution_policy_v</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>ExecutionPolicy<span class="sy1">&gt;&gt;</span></code> is <code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">std::<span class="me2">is_execution_policy_v</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">std::<span class="me2">remove_cvref_t</span></span></a><span class="sy1">&lt;</span>ExecutionPolicy<span class="sy1">&gt;&gt;</span></code> is <code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table>
</div>  <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> first, last </td> <td> - </td> <td> the range of elements to examine </td>
</tr> <tr class="t-par"> <td> count </td> <td> - </td> <td> the length of the sequence to search for </td>
</tr> <tr class="t-par"> <td> value </td> <td> - </td> <td> the value of the elements to search for </td>
</tr> <tr class="t-par"> <td> policy </td> <td> - </td> <td> the execution policy to use. See <a href="execution_policy_tag_t.html" title="cpp/algorithm/execution policy tag t">execution policy</a> for details. </td>
</tr> <tr class="t-par"> <td> p </td> <td> - </td> <td> binary predicate which returns ​<code>true</code> if the elements should be treated as equal. <br> <p>The signature of the predicate function should be equivalent to the following:</p>
<p><span class="t-cc"><code> bool pred(const Type1 &amp;a, const Type2 &amp;b);</code></span></p>
<p>While the signature does not need to have <code>const &amp;</code>, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) <code>Type1</code> and <code>Type2</code> regardless of <a href="../language/value_category.html" title="cpp/language/value category">value category</a> (thus, <code>Type1 &amp;</code> is not allowed<span class="t-rev-inl t-since-cxx11"><span>, nor is <code>Type1</code> unless for <code>Type1</code> a move is equivalent to a copy</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>).<br> The type Type1 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to Type1. The type Type2 must be such that an object of type T can be implicitly converted to Type2. ​</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3"> Type requirements </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>ForwardIt</code> must meet the requirements of <a href="../named_req/forwarditerator.html" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>. </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>Size</code> must be <a href="../language/implicit_cast.html" title="cpp/language/implicit cast" class="mw-redirect">convertible</a> to <a href="../language/type.html" title="cpp/language/type">integral type</a>. </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <p>If <code>count</code> is positive, returns an iterator to the beginning of the first sequence found in the range <code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>. Each iterator <code>it</code> in the sequence should satisfy the following condition:</p>
<div class="t-li1">
<span class="t-li">1,2)</span> <code>*it == value</code> is <code>true</code>.</div> <div class="t-li1">
<span class="t-li">3,4)</span> <code>p(*it, value) != false</code> is <code>true</code>.</div> <p>If no such sequence is found, <code>last</code> is returned.</p>
<p>If <code>count</code> is zero or negative, <code>first</code> is returned.</p>
<h3 id="Complexity"> Complexity</h3> <p>Given <code>N</code> as <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>first, last<span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">1,2)</span> at most <code>N</code> comparisons with value using <code>operator==</code>.</div> <div class="t-li1">
<span class="t-li">3,4)</span> at most <code>N</code> applications of the predicate <code>p</code>.</div> <h3 id="Exceptions"> Exceptions</h3> <p>The overloads with a template parameter named <code>ExecutionPolicy</code> report errors as follows:</p>
<ul>
<li> If execution of a function invoked as part of the algorithm throws an exception and <code>ExecutionPolicy</code> is one of the <a href="execution_policy_tag_t.html" title="cpp/algorithm/execution policy tag t">standard policies</a>, <code><a href="../error/terminate.html" title="cpp/error/terminate">std::terminate</a></code> is called. For any other <code>ExecutionPolicy</code>, the behavior is implementation-defined. </li>
<li> If the algorithm fails to allocate memory, <code><a href="../memory/new/bad_alloc.html" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> is thrown. </li>
</ul> <h3 id="Possible_implementation"> Possible implementation</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">search_n (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class ForwardIt, class Size, class T&gt;
ForwardIt search_n(ForwardIt first, ForwardIt last, Size count, const T&amp; value)
{
    if (count &lt;= 0)
        return first;
 
    for (; first != last; ++first)
    {
        if (!(*first == value))
            continue;
 
        ForwardIt candidate = first;
 
        for (Size cur_count = 1; true; ++cur_count)
        {
            if (cur_count &gt;= count)
                return candidate; // success
 
            ++first;
            if (first == last)
                return last; // exhausted the list
 
            if (!(*first == value))
                break; // too few in a row
        }
    }
    return last;
}</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">search_n (3)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class ForwardIt, class Size, class T, class BinaryPredicate&gt;
ForwardIt search_n(ForwardIt first, ForwardIt last, Size count, const T&amp; value,
                   BinaryPredicate p)
{
    if (count &lt;= 0)
        return first;
 
    for (; first != last; ++first)
    {
        if (!p(*first, value))
            continue;
 
        ForwardIt candidate = first;
 
        for (Size cur_count = 1; true; ++cur_count)
        {
            if (cur_count &gt;= count)
                return candidate; // success
 
            ++first;
            if (first == last)
                return last; // exhausted the list
 
            if (!p(*first, value))
                break; // too few in a row
        }
    }
    return last;
}</pre></div> </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
 
template&lt;class Container, class Size, class T&gt;
[[nodiscard]]
constexpr bool consecutive_values(const Container&amp; c, Size count, const T&amp; v)
{
    return std::search_n(std::begin(c), std::end(c), count, v) != std::end(c);
}
 
int main()
{
    constexpr char sequence[] = "1001010100010101001010101";
 
    static_assert(consecutive_values(sequence, 3, '0'));
 
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "Has 4 consecutive zeros: "
              &lt;&lt; consecutive_values(sequence, 4, '0') &lt;&lt; '\n'
              &lt;&lt; "Has 3 consecutive zeros: "
              &lt;&lt; consecutive_values(sequence, 3, '0') &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Has 4 consecutive zeros: false
Has 3 consecutive zeros: true</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue283">LWG 283</a> </td> <td>C++98 </td> <td>
<code>T</code> was required to be <a href="../named_req/equalitycomparable.html" title="cpp/named req/EqualityComparable">EqualityComparable</a>, but<br>the value type of <code>InputIt</code> is not always <code>T</code> </td> <td>removed the requirement </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue426">LWG 426</a> </td> <td>C++98 </td> <td>the complexity upper limit was <code>N·count</code>,<br>it is negative if <code>count</code> is negative </td> <td>the upper limit is <code>​0​</code><br>if <code>count</code> is non-positive </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue714">LWG 714</a> </td> <td>C++98 </td> <td>if <code>count &gt; 0</code>, the complexity upper limit was <code>N·count</code>, but in<br>the worst case the number of comparisons/operations is always <code>N</code> </td> <td>changed the upper<br>limit to <code>N</code> in this case </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="find_end.html" title="cpp/algorithm/find end"> <span class="t-lines"><span>find_end</span></span></a></div> </td> <td> finds the last sequence of elements in a certain range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="find.html" title="cpp/algorithm/find"> <span class="t-lines"><span>find</span><span>find_if</span><span>find_if_not</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> finds the first element satisfying specific criteria <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="search.html" title="cpp/algorithm/search"> <span class="t-lines"><span>search</span></span></a></div> </td> <td> searches for a range of elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/search_n.html" title="cpp/algorithm/ranges/search n"> <span class="t-lines"><span>ranges::search_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> searches for a number consecutive copies of an element in a range<br><span class="t-mark">(niebloid)</span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/algorithm/search_n" class="_attribution-link">https://en.cppreference.com/w/cpp/algorithm/search_n</a>
  </p>
</div>
