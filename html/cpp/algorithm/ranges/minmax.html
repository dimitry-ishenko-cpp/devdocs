    <h1 id="firstHeading" class="firstHeading">std::ranges::minmax, std::ranges::minmax_result</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/algorithm.html" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td> Call signature</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class T, class Proj = std::identity,
          std::indirect_strict_weak_order&lt;
              std::projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less &gt;
constexpr ranges::minmax_result&lt;const T&amp;&gt;
    minmax( const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {} );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; std::copyable T, class Proj = std::identity,
          std::indirect_strict_weak_order&lt;
              std::projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less &gt;
constexpr ranges::minmax_result&lt;T&gt;
    minmax( std::initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {} );</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_strict_weak_order&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less &gt;
requires std::indirectly_copyable_storable&lt;ranges::iterator_t&lt;R&gt;, ranges::range_value_t&lt;R&gt;*&gt;
constexpr ranges::minmax_result&lt;ranges::range_value_t&lt;R&gt;&gt;
    minmax( R&amp;&amp; r, Comp comp = {}, Proj proj = {} );</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl-h"> <td> Helper types</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class T &gt;
using minmax_result = ranges::min_max_result&lt;T&gt;;</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  </table> <p>Returns the smallest and the greatest of the given projected values.</p>
<div class="t-li1">
<span class="t-li">1)</span> Returns references to the smaller and the greater of <code>a</code> and <code>b</code>.</div> <div class="t-li1">
<span class="t-li">2)</span> Returns the smallest and the greatest of the values in the initializer list <code>r</code>.</div> <div class="t-li1">
<span class="t-li">3)</span> Returns the smallest and the greatest of the values in the range <code>r</code>.</div> <p>The function-like entities described on this page are <i>niebloids</i>, that is:</p>
<ul>
<li> Explicit template argument lists cannot be specified when calling any of them. </li>
<li> None of them are visible to <a href="../../language/adl.html" title="cpp/language/adl">argument-dependent lookup</a>. </li>
<li> When any of them are found by <a href="../../language/unqualified_lookup.html" title="cpp/language/unqualified lookup">normal unqualified lookup</a> as the name to the left of the function-call operator, <a href="../../language/adl.html" title="cpp/language/adl">argument-dependent lookup</a> is inhibited. </li>
</ul> <p>In practice, they may be implemented as function objects, or with special compiler extensions.</p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> a, b </td> <td> - </td> <td> the values to compare </td>
</tr> <tr class="t-par"> <td> r </td> <td> - </td> <td> a non-empty range of values to compare </td>
</tr> <tr class="t-par"> <td> comp </td> <td> - </td> <td> comparison to apply to the projected elements </td>
</tr> <tr class="t-par"> <td> proj </td> <td> - </td> <td> projection to apply to the elements </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1)</span> <code>{b, a}</code> if, according to their respective projected value, <code>b</code> is smaller than <code>a</code>; otherwise it returns <code>{a, b}</code>.</div> <div class="t-li1">
<span class="t-li">2,3)</span> <code>{s, l}</code>, where <code>s</code> and <code>l</code> are respectively the smallest and largest values in <code>r</code>, according to their projected value. If several values are equivalent to the smallest and largest, returns the leftmost smallest value, and the rightmost largest value. If the range is empty (as determined by <code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3140">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>r<span class="br0">)</span></code>), the behavior is undefined.</div> <h3 id="Complexity"> Complexity</h3> <div class="t-li1">
<span class="t-li">1)</span> Exactly one comparison and two applications of the projection.</div> <div class="t-li1">
<span class="t-li">2,3)</span> At most <code><span class="nu0">3</span> <span class="sy2">/</span> <span class="nu0">2</span> <span class="sy2">*</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3140">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>r<span class="br0">)</span></code> comparisons and twice as many applications of the projection.</div> <h3 id="Possible_implementation"> Possible implementation</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">struct minmax_fn
{
    template&lt;class T, class Proj = std::identity,
             std::indirect_strict_weak_order&lt;
                 std::projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
    constexpr ranges::minmax_result&lt;const T&amp;&gt;
         operator()(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {}) const
    {
        if (std::invoke(comp, std::invoke(proj, b), std::invoke(proj, a)))
            return {b, a};
 
        return {a, b};
    }
 
    template&lt;std::copyable T, class Proj = std::identity,
             std::indirect_strict_weak_order&lt;
                 std::projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
    constexpr ranges::minmax_result&lt;T&gt;
        operator()(std::initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {}) const
    {
        auto result = ranges::minmax_element(r, std::ref(comp), std::ref(proj));
        return {*result.min, *result.max};
    }
 
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_strict_weak_order&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
    requires std::indirectly_copyable_storable&lt;ranges::iterator_t&lt;R&gt;,
                                               ranges::range_value_t&lt;R&gt;*&gt;
    constexpr ranges::minmax_result&lt;ranges::range_value_t&lt;R&gt;&gt;
        operator()(R&amp;&amp; r, Comp comp = {}, Proj proj = {}) const
    {
        auto result = ranges::minmax_element(r, std::ref(comp), std::ref(proj));
        return {std::move(*result.min), std::move(*result.max)};
    }
};
 
inline constexpr minmax_fn minmax;</pre></div> </td>
</tr>
</table> <h3 id="Notes"> Notes</h3> <p>For overload <span class="t-v">(1)</span>, if one of the parameters is a temporary, the reference returned becomes a dangling reference at the end of the full expression that contains the call to <code>minmax</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int n = 1;
auto p = std::ranges::minmax(n, n + 1);
int m = p.min; // ok
int x = p.max; // undefined behavior
 
// Note that structured bindings have the same issue
auto [mm, xx] = std::ranges::minmax(n, n + 1);
xx; // undefined behavior</pre></div> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
 
int main()
{
    namespace ranges = std::ranges;
 
    constexpr std::array v{3, 1, 4, 1, 5, 9, 2, 6, 5};
 
    std::random_device rd;
    std::mt19937_64 generator(rd());
    std::uniform_int_distribution&lt;&gt; distribution(0, ranges::distance(v)); // [0..9]
 
    // auto bounds = ranges::minmax(distribution(generator), distribution(generator));
    // UB: dangling references: bounds.min and bounds.max have the type `const int&amp;`.
 
    const int x1 = distribution(generator);
    const int x2 = distribution(generator);
    auto bounds = ranges::minmax(x1, x2); // OK: got references to lvalues x1 and x2
 
    std::cout &lt;&lt; "v[" &lt;&lt; bounds.min &lt;&lt; ":" &lt;&lt; bounds.max &lt;&lt; "]: ";
    for (int i = bounds.min; i &lt; bounds.max; ++i)
        std::cout &lt;&lt; v[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    auto [min, max] = ranges::minmax(v);
    std::cout &lt;&lt; "smallest: " &lt;&lt; min &lt;&lt; ", " &lt;&lt; "largest: " &lt;&lt; max &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">v[3:9]: 1 5 9 2 6 5 
smallest: 1, largest: 9</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="min.html" title="cpp/algorithm/ranges/min"> <span class="t-lines"><span>ranges::min</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the smaller of the given values<br><span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="max.html" title="cpp/algorithm/ranges/max"> <span class="t-lines"><span>ranges::max</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the greater of the given values<br><span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="minmax_element.html" title="cpp/algorithm/ranges/minmax element"> <span class="t-lines"><span>ranges::minmax_element</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the smallest and the largest elements in a range<br><span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="clamp.html" title="cpp/algorithm/ranges/clamp"> <span class="t-lines"><span>ranges::clamp</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> clamps a value between a pair of boundary values<br><span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../minmax.html" title="cpp/algorithm/minmax"> <span class="t-lines"><span>minmax</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> returns the smaller and larger of two elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/minmax" class="_attribution-link">https://en.cppreference.com/w/cpp/algorithm/ranges/minmax</a>
  </p>
</div>
