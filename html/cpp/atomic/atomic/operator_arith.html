    <h1 id="firstHeading" class="firstHeading">std::atomic&lt;T&gt;::operator++,++(int),--,--(int)</h1>            <table class="t-dcl-begin"> <tr class="t-dcl-h"> <td> member only of <code>atomic&lt;<i>Integral</i></code> ﻿<code>&gt;</code> specializations</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T operator++() noexcept;</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T operator++() volatile noexcept;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T operator++( int ) noexcept;</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T operator++( int ) volatile noexcept;</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T operator--() noexcept;</pre>
</td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T operator--() volatile noexcept;</pre>
</td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T operator--( int ) noexcept;</pre>
</td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T operator--( int ) volatile noexcept;</pre>
</td> <td> (8) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl-h"> <td> member only of <code>atomic&lt;T*&gt;</code> partial specialization</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T* operator++() noexcept;</pre>
</td> <td> (9) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T* operator++() volatile noexcept;</pre>
</td> <td> (10) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T* operator++( int ) noexcept;</pre>
</td> <td> (11) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T* operator++( int ) volatile noexcept;</pre>
</td> <td> (12) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T* operator--() noexcept;</pre>
</td> <td> (13) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T* operator--() volatile noexcept;</pre>
</td> <td> (14) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T* operator--( int ) noexcept;</pre>
</td> <td> (15) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T* operator--( int ) volatile noexcept;</pre>
</td> <td> (16) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <p>Atomically increments or decrements the current value. The operation is read-modify-write operation.</p>
<ul>
<li> operator<span class="sy2">++</span><span class="br0">(</span><span class="br0">)</span> performs atomic pre-increment. Equivalent to <code>return fetch_add(1) + 1;</code>. </li>
<li> operator<span class="sy2">++</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> performs atomic post-increment. Equivalent to <code>return fetch_add(1);</code>. </li>
<li> operator<span class="sy2">--</span><span class="br0">(</span><span class="br0">)</span> performs atomic pre-decrement. Equivalent to <code>return fetch_sub(1) - 1;</code>. </li>
<li> operator<span class="sy2">--</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> performs atomic post-decrement. Equivalent to <code>return fetch_sub(1);</code>. </li>
</ul> <div class="t-li1">
<span class="t-li">1-8)</span> For signed integral types, arithmetic is defined to use two’s complement representation. There are no undefined results.</div> <div class="t-li1">
<span class="t-li">9-16)</span> The result may be an undefined address, but the operations otherwise have no undefined behavior.</div> <div class="t-li1">
 If <code>T</code> is not a complete object type, the program is ill-formed.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>It is deprecated if <code><a href="http://en.cppreference.com/w/cpp/atomic/atomic"><span class="kw2070">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">is_always_lock_free</span></code> is false and any <span class="kw4">volatile</span> overload participates in overload resolution.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table>  <h3 id="Parameters"> Parameters</h3> <p>(none)</p>
<h3 id="Return_value"> Return value</h3> <p>operator<span class="sy2">++</span><span class="br0">(</span><span class="br0">)</span> and operator<span class="sy2">--</span><span class="br0">(</span><span class="br0">)</span> return the value of the atomic variable after the modification. Formally, the result of incrementing/decrementing the value immediately preceding the effects of this function in the <a href="../memory_order.html#Modification_order" title="cpp/atomic/memory order">modification order</a> of <code>*this</code>.</p>
<p>operator<span class="sy2">++</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> and operator<span class="sy2">--</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> return the value of the atomic variable before the modification. Formally, the value immediately preceding the effects of this function in the <a href="../memory_order.html#Modification_order" title="cpp/atomic/memory order">modification order</a> of <code>*this</code>.</p>
<h3 id="Notes"> Notes</h3> <p>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for atomic types do not return a reference to the modified object. They return a copy of the stored value instead.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;random&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
 
std::atomic&lt;int&gt; atomic_count{0};
 
std::mutex cout_mutex;
int completed_writes{0};
 
constexpr int global_max_count{72};
constexpr int writes_per_line{8};
constexpr int max_delay{100};
 
template&lt;int Max&gt;
int random_value()
{
    static std::uniform_int_distribution&lt;int&gt; distr{1, Max};
    static std::random_device engine;
    static std::mt19937 noise{engine()};
    static std::mutex rand_mutex;
    std::lock_guard lock{rand_mutex};
    return distr(noise);
}
 
int main()
{
    auto work = [](const std::string id)
    {
        for (int count{}; (count = ++atomic_count) &lt;= global_max_count;)
        {
            std::this_thread::sleep_for(
                std::chrono::milliseconds(random_value&lt;max_delay&gt;()));
 
            // print thread `id` and `count` value
            {
                std::lock_guard lock{cout_mutex};
 
                const bool new_line = ++completed_writes % writes_per_line == 0;
 
                std::cout &lt;&lt; id &lt;&lt; std::setw(3) &lt;&lt; count &lt;&lt; "  "
                          &lt;&lt; (new_line ? "\n" : "") &lt;&lt; std::flush;
            }
        }
    };
 
    std::jthread j1(work, "░"), j2(work, "▒"), j3(work, "▓"), j4(work, "█");
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">▒  2  ░  1  ▒  5  ▒  7  █  4  ░  6  ▓  3  ▒  8  
▓ 11  █  9  ▓ 13  ░ 10  █ 14  ▒ 12  ░ 16  ░ 19  
▓ 15  ▒ 18  ▓ 21  ▒ 22  █ 17  █ 25  ▒ 24  █ 26  
░ 20  ░ 29  ▒ 27  ▓ 23  ▒ 31  ▒ 33  ▓ 32  █ 28  
░ 30  ░ 37  ▒ 34  ▓ 35  █ 36  █ 41  ▓ 40  ▒ 39  
░ 38  ▓ 43  █ 42  ▓ 46  ▓ 48  █ 47  █ 50  ░ 45  
▒ 44  ▒ 53  ▒ 54  ▓ 49  ▒ 55  █ 51  ▒ 57  █ 58  
░ 52  ▓ 56  ░ 61  ▒ 59  █ 60  ▓ 62  ▒ 64  ░ 63  
░ 68  ▓ 66  █ 65  █ 71  ▒ 67  ▓ 70  ░ 69  █ 72</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://wg21.link/P0558R1">P0558R1</a> </td> <td>C++11 </td> <td>arithmetic permitted on pointers to (possibly cv-qualified) <span class="kw4">void</span> or function </td> <td>made ill-formed </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="fetch_add.html" title="cpp/atomic/atomic/fetch add"> <span class="t-lines"><span>fetch_add</span></span></a></div> </td> <td> atomically adds the argument to the value stored in the atomic object and obtains the value held previously <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="fetch_sub.html" title="cpp/atomic/atomic/fetch sub"> <span class="t-lines"><span>fetch_sub</span></span></a></div> </td> <td> atomically subtracts the argument from the value stored in the atomic object and obtains the value held previously <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="operator_arith2.html" title="cpp/atomic/atomic/operator arith2"> <span class="t-lines"><span>operator+=</span><span>operator-=</span><span>operator&amp;=</span><span>operator|=</span><span>operator^=</span></span></a></div> </td> <td> adds, subtracts, or performs bitwise AND, OR, XOR with the atomic value <br> <span class="t-mark">(public member function)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/atomic/atomic/operator_arith" class="_attribution-link">https://en.cppreference.com/w/cpp/atomic/atomic/operator_arith</a>
  </p>
</div>
