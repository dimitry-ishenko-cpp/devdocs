    <h1 id="firstHeading" class="firstHeading">std::proj(std::complex)</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/complex.html" title="cpp/header/complex">&lt;complex&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class T &gt; 
std::complex&lt;T&gt; proj( const std::complex&lt;T&gt;&amp; z );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl-h"> <td> <a href="#Notes">Additional overloads</a> <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</td> <td></td> <td></td> </tr> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/complex.html" title="cpp/header/complex">&lt;complex&gt;</a></code> </th> <th> </th> <th> </th> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(A)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx23"> <td><pre data-language="cpp">std::complex&lt;float&gt;       proj( float f );
std::complex&lt;double&gt;      proj( double f );
std::complex&lt;long double&gt; proj( long double f );</pre></td>  <td><span class="t-mark-rev t-until-cxx23">(until C++23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; class FloatingPoint &gt;
std::complex&lt;FloatingPoint&gt; proj( FloatingPoint f );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr>  <tr class="t-dcl"> <td> <pre data-language="cpp">template&lt; class Integer &gt;
std::complex&lt;double&gt; proj( Integer i );</pre>
</td> <td> (B) </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> Returns the projection of the complex number <code>z</code> onto the <a href="https://en.wikipedia.org/wiki/Riemann_sphere" class="extiw" title="enwiki:Riemann sphere">Riemann sphere</a>.</div> <div class="t-li1">
 For most <code>z</code>, <code>std::proj(z) == z</code>, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, <code><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/numeric/math/INFINITY"><span class="kw1380">INFINITY</span></a>, <span class="nu16">0.0</span><span class="br0">)</span></code> or <code><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/numeric/math/INFINITY"><span class="kw1380">INFINITY</span></a>, <span class="sy2">-</span><span class="nu16">0.0</span><span class="br0">)</span></code>. The sign of the imaginary (zero) component is the sign of <code><a href="http://en.cppreference.com/w/cpp/numeric/complex/imag2"><span class="kw2691">std::<span class="me2">imag</span></span></a><span class="br0">(</span>z<span class="br0">)</span></code>. </div> <div class="t-li1">
<span class="t-li">A,B)</span> Additional overloads are provided for all integer and floating-point types, which are treated as complex numbers with positive zero imaginary component.</div>  <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> z </td> <td> - </td> <td> complex value </td>
</tr> <tr class="t-par"> <td> f </td> <td> - </td> <td> floating-point value </td>
</tr> <tr class="t-par"> <td> i </td> <td> - </td> <td> integer value </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1)</span> The projection of <code>z</code> onto the Riemann sphere.</div> <div class="t-li1">
<span class="t-li">A)</span> The projection of <code><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">std::<span class="me2">complex</span></span></a><span class="br0">(</span>f<span class="br0">)</span></code> onto the Riemann sphere.</div> <div class="t-li1">
<span class="t-li">B)</span> The projection of <code><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">std::<span class="me2">complex</span></span></a><span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span><span class="br0">(</span>i<span class="br0">)</span></code> onto the Riemann sphere.</div> <h3 id="Notes"> Notes</h3> <p>The <code>proj</code> function helps model the Riemann sphere by mapping all infinities to one (give or take the sign of the imaginary zero), and should be used just before any operation, especially comparisons, that might give spurious results for any of the other infinities.</p>
<p>The additional overloads are not required to be provided exactly as <span class="t-v">(A,B)</span>. They only need to be sufficient to ensure that for their argument <code>num</code>:</p>
<ul>
<li> If <code>num</code> has a <span class="t-rev-inl t-until-cxx23"><span>standard</span><span><span class="t-mark-rev t-until-cxx23">(until C++23)</span></span></span> floating-point type <code>T</code>, then <code>std::proj(num)</code> has the same effect as <code>std<span class="sy4">::</span><span class="me2">proj</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">std::<span class="me2">complex</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span>num<span class="br0">)</span><span class="br0">)</span></code>. </li>
<li> Otherwise, if <code>num</code> has an integer type, then <code>std::proj(num)</code> has the same effect as <code>std<span class="sy4">::</span><span class="me2">proj</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">std::<span class="me2">complex</span></span></a><span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span><span class="br0">(</span>num<span class="br0">)</span><span class="br0">)</span></code>. </li>
</ul> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;complex&gt;
#include &lt;iostream&gt;
 
int main()
{
    std::complex&lt;double&gt; c1(1, 2);
    std::cout &lt;&lt; "proj" &lt;&lt; c1 &lt;&lt; " = " &lt;&lt; std::proj(c1) &lt;&lt; '\n';
 
    std::complex&lt;double&gt; c2(INFINITY, -1);
    std::cout &lt;&lt; "proj" &lt;&lt; c2 &lt;&lt; " = " &lt;&lt; std::proj(c2) &lt;&lt; '\n';
 
    std::complex&lt;double&gt; c3(0, -INFINITY);
    std::cout &lt;&lt; "proj" &lt;&lt; c3 &lt;&lt; " = " &lt;&lt; std::proj(c3) &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">proj(1,2) = (1,2)
proj(inf,-1) = (inf,-0)
proj(0,-inf) = (inf,-0)</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="abs.html" title="cpp/numeric/complex/abs"> <span class="t-lines"><span>abs<span class="t-dsc-small">(std::complex)</span></span></span></a></div> </td> <td> returns the magnitude of a complex number <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="norm.html" title="cpp/numeric/complex/norm"> <span class="t-lines"><span>norm</span></span></a></div> </td> <td> returns the squared magnitude <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="polar.html" title="cpp/numeric/complex/polar"> <span class="t-lines"><span>polar</span></span></a></div> </td> <td> constructs a complex number from magnitude and phase angle <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/numeric/complex/cproj" title="c/numeric/complex/cproj">C documentation</a></span> for <code>cproj</code> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/numeric/complex/proj" class="_attribution-link">https://en.cppreference.com/w/cpp/numeric/complex/proj</a>
  </p>
</div>
