    <h1 id="firstHeading" class="firstHeading">std::inout_ptr_t&lt;Smart,Pointer,Args...&gt;::inout_ptr_t</h1>            <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">explicit inout_ptr_t( Smart &amp;sp, Args... args );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">inout_ptr_t( const inout_ptr_t&amp; ) = delete;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> Creates an <code>inout_ptr_t</code>. Adapts <code>sp</code> as if binds it to the <code>Smart&amp;</code> member, captures every argument <code>t</code> in <code>args...</code> as if initializes the corresponding member of type <code>T</code> in <code>Args...</code> with <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span>t<span class="br0">)</span></code>, then initializes the stored <code>Pointer</code> with <code>sp</code> if <code>Smart</code> is a pointer type, otherwise, initializes it with <code>sp.get()</code>. <code>sp.release()</code> may be called if <code>Smart</code> is not a pointer type, in which case it will not be called again within the destructor.</div> <div class="t-li1">
<span class="t-li">2)</span> Copy constructor is explicitly deleted. <code>inout_ptr_t</code> is neither copyable nor movable.</div>  <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> sp </td> <td> - </td> <td> the object (typically a smart pointer) to adapt </td>
</tr> <tr class="t-par"> <td> args... </td> <td> - </td> <td> the arguments used for resetting to capture </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <p>(none)</p>
<h3 id="Exceptions"> Exceptions</h3> <p>May throw implementation-defined exceptions.</p>
<h3 id="Notes"> Notes</h3> <p>If <code>Smart</code> is not a pointer type and <code>sp.release()</code> is not called by the constructor, it may be called by the destructor before resetting <code>sp</code>.</p>
<p>Every argument in <code>args...</code> is moved into the created <code>inout_ptr_t</code> if it is of an object type, or transferred into the created <code>inout_ptr_t</code> as-is if it is of a reference type.</p>
<p>The constructor of <code>inout_ptr_t</code> is allowed to throw exceptions. For example, when <code>sp</code> is an intrusive pointer with a control block, the allocation for the new control block may be performed within the constructor rather than the destructor.</p>
<h3 id="Example"> Example</h3>            <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/memory/inout_ptr_t/inout_ptr_t" class="_attribution-link">https://en.cppreference.com/w/cpp/memory/inout_ptr_t/inout_ptr_t</a>
  </p>
</div>
