    <h1 id="firstHeading" class="firstHeading">std::owner_equal</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/memory.html" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">struct owner_equal;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(since C++26)</span> </td> </tr>  </table> <p>This function object provides owner-based (as opposed to value-based) mixed-type equal comparison of both <code><a href="weak_ptr.html" title="cpp/memory/weak ptr">std::weak_ptr</a></code> and <code><a href="shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></code>. The comparison is such that two smart pointers compare equivalent only if they are both empty or if they share ownership, even if the values of the raw pointers obtained by <code>get()</code> are different (e.g. because they point at different subobjects within the same object).</p>
<div class="t-li1">
<span class="t-li">1)</span> Owner-based mixed-type equal comparison is not provided for types other than <code><a href="shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></code> and <code><a href="weak_ptr.html" title="cpp/memory/weak ptr">std::weak_ptr</a></code>.</div> <div class="t-li1">
<span class="t-li">2)</span> The owner-based mixed-type equal comparison of <code><a href="shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></code> and <code><a href="weak_ptr.html" title="cpp/memory/weak ptr">std::weak_ptr</a></code>.</div> <div class="t-li1">
 It is the preferred comparison predicate when building unordered associative containers with <code><a href="shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></code> and <code><a href="weak_ptr.html" title="cpp/memory/weak ptr">std::weak_ptr</a></code> as keys together with <code>std::owner_hash</code>, that is, <code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">std::<span class="me2">unordered_map</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span>, U, std<span class="sy4">::</span><span class="me2">owner_hash</span>, std<span class="sy4">::</span><span class="me2">owner_equal</span><span class="sy1">&gt;</span></code> or <code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">std::<span class="me2">unordered_map</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">std::<span class="me2">weak_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span>, U, std<span class="sy4">::</span><span class="me2">owner_hash</span>, std<span class="sy4">::</span><span class="me2">owner_equal</span><span class="sy1">&gt;</span></code>.</div> <div class="t-li1">
<span class="t-li">3)</span> <code>std::owner_equal</code> deduces the parameter types from the arguments.</div>  <h3 id="Nested_types"> Nested types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Nested type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>is_transparent</code> </td> <td> <a href="../utility/functional.html#Transparent_function_objects" title="cpp/utility/functional">unspecified</a> </td>
</tr> </table> <h3 id="Member_functions"> Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><strong class="selflink"> <span class="t-lines"><span>operator()</span></span></strong></div> </td> <td> compares its arguments using owner-based semantics <br> <span class="t-mark">(function)</span> </td>
</tr> </table> <div class="t-member"> <h2 id="std::owner_equal::operator.28.29"> std::owner_equal::operator()</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">template&lt; class T, class U &gt;
bool operator()( const std::shared_ptr&lt;T&gt;&amp; lhs, 
                 const std::shared_ptr&lt;U&gt;&amp; rhs ) const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(since C++26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">template&lt; class T, class U &gt;
bool operator()( const std::shared_ptr&lt;T&gt;&amp; lhs, 
                 const std::weak_ptr&lt;U&gt;&amp; rhs ) const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(since C++26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">template&lt; class T, class U &gt;
bool operator()( const std::weak_ptr&lt;T&gt;&amp; lhs, 
                 const std::shared_ptr&lt;U&gt;&amp; rhs ) const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(since C++26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">template&lt; class T, class U &gt;
bool operator()( const std::weak_ptr&lt;T&gt;&amp; lhs, 
                 const std::weak_ptr&lt;U&gt;&amp; rhs ) const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(since C++26)</span> </td> </tr>  </table> <p>Compares <code>lhs</code> and <code>rhs</code> using owner-based semantics. Effectively calls <code>lhs.owner_equal(rhs)</code>.</p>
<p>The equal comparison is an equivalence relation.</p>
<p><code>lhs</code> and <code>rhs</code> are equivalent only if they are both empty or share ownership.</p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> lhs, rhs </td> <td> - </td> <td> shared-ownership pointers to compare </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <p><code>true</code> if <code>lhs</code> and <code>rhs</code> are both empty or share ownership as determined by the owner-based equal comparison, <code>false</code> otherwise.</p>
</div> <h3 id="Notes"> Notes</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test.html" title="cpp/utility/feature test">Feature-test</a> macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Feature </th>
</tr> <tr> <td><a href="../feature_test.html#cpp_lib_smart_ptr_owner_equality" title="cpp/feature test"><code>__cpp_lib_smart_ptr_owner_equality</code></a></td> <td><span class="nu0">202306L</span></td> <td><span class="t-mark">(C++26)</span></td> <td>Enabling the use of <code>std::shared_ptr</code> and <code>std::weak_ptr</code> as keys in <a href="../container.html#Unordered_associative_containers" title="cpp/container">unordered associative containers</a> </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr/owner_equal.html" title="cpp/memory/shared ptr/owner equal"> <span class="t-lines"><span>owner_equal</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> provides owner-based equal comparison of shared pointers <br> <span class="t-mark">(public member function of <code>std::shared_ptr&lt;T&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="weak_ptr/owner_equal.html" title="cpp/memory/weak ptr/owner equal"> <span class="t-lines"><span>owner_equal</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> provides owner-based equal comparison of weak pointers <br> <span class="t-mark">(public member function of <code>std::weak_ptr&lt;T&gt;</code>)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/memory/owner_equal" class="_attribution-link">https://en.cppreference.com/w/cpp/memory/owner_equal</a>
  </p>
</div>
