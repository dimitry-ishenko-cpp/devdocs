    <h1 id="firstHeading" class="firstHeading">std::out_ptr_t&lt;Smart,Pointer,Args...&gt;::~out_ptr_t</h1>            <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">~out_ptr_t();</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr>  </table> <p>Resets the adapted <code>Smart</code> object by the value of modified <code>Pointer</code> object (or the <code>void*</code> object if <code>operator void**()</code> has been called) and the captured arguments.</p>
<p>Let</p>
<ul>
<li> <code>s</code> denotes the adapted <code>Smart</code> object, </li>
<li> <code>args...</code> denotes the captured arguments, </li>
<li> <code>p</code> denotes the value of stored <code>Pointer</code>, or <code>static_cast&lt;Pointer&gt;(*operator void**())</code> if <code>operator void**</code> has been called, </li>
<li> <code>SP</code> be <ul>
<li> <code>Smart::pointer</code>, if it is valid and denotes a type, otherwise, </li>
<li> <code>Smart::element_type*</code>, if <code>Smart::element_type</code> is valid and denotes a type, otherwise, </li>
<li> <code><a href="http://en.cppreference.com/w/cpp/memory/pointer_traits"><span class="kw758">std::<span class="me2">pointer_traits</span></span></a><span class="sy1">&lt;</span>Smart<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">element_type</span><span class="sy2">*</span></code>, if <code><a href="http://en.cppreference.com/w/cpp/memory/pointer_traits"><span class="kw758">std::<span class="me2">pointer_traits</span></span></a><span class="sy1">&lt;</span>Smart<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">element_type</span></code> is valid and denotes a type, otherwise, </li>
<li> <code>Pointer</code>. </li>
</ul> </li>
</ul> <p>If <code>s.<span class="me1">reset</span><span class="br0">(</span><span class="kw1">static_cast</span><span class="sy1">&lt;</span>SP<span class="sy1">&gt;</span><span class="br0">(</span>p<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span></code> is well-formed, the destructor performs  <code><span class="kw1">if</span> <span class="br0">(</span>p<span class="br0">)</span> s.<span class="me1">reset</span><span class="br0">(</span><span class="kw1">static_cast</span><span class="sy1">&lt;</span>SP<span class="sy1">&gt;</span><span class="br0">(</span>p<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">;</span></code>,</p>
<p>otherwise, if <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">std::<span class="me2">is_constructible_v</span></span></a><span class="sy1">&lt;</span>Smart, SP, Args...<span class="sy1">&gt;</span></code> is <code>true</code>, the destructor performs  <code><span class="kw1">if</span> <span class="br0">(</span>p<span class="br0">)</span> s <span class="sy1">=</span> Smart<span class="br0">(</span><span class="kw1">static_cast</span><span class="sy1">&lt;</span>SP<span class="sy1">&gt;</span><span class="br0">(</span>p<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">;</span></code>,</p>
<p>otherwise, the program is ill-formed.</p>
<h3 id="Notes"> Notes</h3> <p>If <code>Smart</code> is a <code><a href="../shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></code> specialization, the implementation may allocate the storage for the new control block on construction, in order to leave non-throwing works to the destructor.</p>
<p>Arguments captured by value are destroyed after resetting.</p>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/memory/out_ptr_t/%7Eout_ptr_t" class="_attribution-link">https://en.cppreference.com/w/cpp/memory/out_ptr_t/%7Eout_ptr_t</a>
  </p>
</div>
