    <h1 id="firstHeading" class="firstHeading">std::out_ptr_t&lt;Smart,Pointer,Args...&gt;::out_ptr_t</h1>            <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">explicit out_ptr_t( Smart &amp;sp, Args... args );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">out_ptr_t( const out_ptr_t&amp; ) = delete;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> Creates an <code>out_ptr_t</code>. Adapts <code>sp</code> as if binds it to the <code>Smart&amp;</code> member, captures every argument <code>t</code> in <code>args...</code> as if initializes the corresponding member of type <code>T</code> in <code>Args...</code> with <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span>t<span class="br0">)</span></code>, then value-initializes the stored <code>Pointer</code>.<br> Then calls <code>sp.reset()</code> if the expression is well-formed; otherwise, calls <code>sp = Smart()</code> if <code><a href="http://en.cppreference.com/w/cpp/types/is_default_constructible"><span class="kw534">std::<span class="me2">is_default_constructible_v</span></span></a><span class="sy1">&lt;</span>Smart<span class="sy1">&gt;</span></code> is <code>true</code>. The program is ill-formed if both resetting operations are ill-formed.</div> <div class="t-li1">
<span class="t-li">2)</span> Copy constructor is explicitly deleted. <code>out_ptr_t</code> is neither copyable nor movable.</div>  <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> sp </td> <td> - </td> <td> the object (typically a smart pointer) to adapt </td>
</tr> <tr class="t-par"> <td> args... </td> <td> - </td> <td> the arguments used for resetting to capture </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <p>(none)</p>
<h3 id="Exceptions"> Exceptions</h3> <p>May throw implementation-defined exceptions.</p>
<h3 id="Notes"> Notes</h3> <p>After construction, the <code>Pointer</code> or <code>void*</code> object pointed by the return value of either conversion function is equal to <code>nullptr</code>.</p>
<p>Every argument in <code>args...</code> is moved into the created <code>out_ptr_t</code> if it is of an object type, or transferred into the created <code>out_ptr_t</code> as-is if it is of a reference type.</p>
<p>The constructor of <code>out_ptr_t</code> is allowed to throw exceptions. For example, when <code>sp</code> is a <code><a href="../shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></code>, the allocation for the new control block may be performed within the constructor rather than the destructor.</p>
<h3 id="Example"> Example</h3>            <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/memory/out_ptr_t/out_ptr_t" class="_attribution-link">https://en.cppreference.com/w/cpp/memory/out_ptr_t/out_ptr_t</a>
  </p>
</div>
