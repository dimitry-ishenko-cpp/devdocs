    <h1 id="firstHeading" class="firstHeading">std::shared_future&lt;T&gt;::get</h1>             <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">const T&amp; get() const;</pre>
</td> <td> (1) </td> <td> <span class="t-mark">(member only of generic <code>shared_future</code> template)</span><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">T&amp; get() const;</pre>
</td> <td> (2) </td> <td> <span class="t-mark">(member only of <code>shared_future&lt;T&amp;&gt;</code> template specialization)</span><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void get() const;</pre>
</td> <td> (3) </td> <td> <span class="t-mark">(member only of <code>shared_future&lt;void&gt;</code> template specialization)</span><br><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <p>The <code>get</code> member function waits until the <code>shared_future</code> has a valid result and (depending on which template is used) retrieves it. It effectively calls <code><a href="wait.html" title="cpp/thread/shared future/wait">wait()</a></code> in order to wait for the result.</p>
<p>The generic template and two template specializations each contain a single version of <code>get</code>. The three versions of <code>get</code> differ only in the return type.</p>
<p>The behavior is undefined if <code><a href="valid.html" title="cpp/thread/shared future/valid">valid()</a></code> is <code>false</code> before the call to this function.</p>
<h3 id="Parameters"> Parameters</h3> <p>(none)</p>
<h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1)</span> Const reference to the value stored in the shared state. Accessing the value through this reference is undefined after the shared state has been destroyed.</div> <div class="t-li1">
<span class="t-li">2)</span> The reference stored as value in the shared state.</div> <div class="t-li1">
<span class="t-li">3)</span> Nothing.</div> <h3 id="Exceptions"> Exceptions</h3> <p>If an exception was stored in the shared state referenced by the future (e.g. via a call to <a href="../promise/set_exception.html" title="cpp/thread/promise/set exception"><code>std::promise::set_exception()</code></a>) then that exception will be thrown.</p>
<h3 id="Notes"> Notes</h3> <p>The implementations are encouraged to detect the case when <code><a href="valid.html" title="cpp/thread/shared future/valid">valid()</a></code> is <code>false</code> before the call and throw a <code><a href="../future_error.html" title="cpp/thread/future error">std::future_error</a></code> with an error condition of <code><a href="../future_errc.html" title="cpp/thread/future errc">std::future_errc::no_state</a></code>.</p>
<h3 id="Example"> Example</h3>  <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="valid.html" title="cpp/thread/shared future/valid"> <span class="t-lines"><span>valid</span></span></a></div> </td> <td> checks if the future has a shared state <br> <span class="t-mark">(public member function)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/thread/shared_future/get" class="_attribution-link">https://en.cppreference.com/w/cpp/thread/shared_future/get</a>
  </p>
</div>
