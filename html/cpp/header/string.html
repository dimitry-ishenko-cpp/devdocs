    <h1 id="firstHeading" class="firstHeading">Standard library header &lt;string&gt;</h1>            <p>This header is part of the <a href="../string.html" title="cpp/string">strings</a> library.</p>
<table class="t-dsc-begin"> <tr> <td colspan="2">  <h3 id="Includes"> Includes</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="compare.html" title="cpp/header/compare"> <span class="t-lines"><span>&lt;compare&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> <a href="../language/operator_comparison.html#Three-way_comparison" title="cpp/language/operator comparison">Three-way comparison operator</a> support </td>
</tr> <tr class="t-dsc"> <td> <div><a href="initializer_list.html" title="cpp/header/initializer list"> <span class="t-lines"><span>&lt;initializer_list&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> <code><a href="../utility/initializer_list.html" title="cpp/utility/initializer list">std::initializer_list</a></code> class template </td>
</tr> <tr> <td colspan="2"> <h3 id="Classes"> Classes</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/char_traits.html" title="cpp/string/char traits"> <span class="t-lines"><span>char_traits</span></span></a></div> </td> <td> Class Template which describes properties of a character type <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <a href="http://en.cppreference.com/w/cpp/string/char_traits"><span class="kw1270">std::<span class="me2">char_traits</span></span></a><span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <a href="http://en.cppreference.com/w/cpp/string/char_traits"><span class="kw1270">std::<span class="me2">char_traits</span></span></a><span class="sy1">&lt;</span><span class="kw4">wchar_t</span><span class="sy1">&gt;</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <a href="http://en.cppreference.com/w/cpp/string/char_traits"><span class="kw1270">std::<span class="me2">char_traits</span></span></a><span class="sy1">&lt;</span>char8_t<span class="sy1">&gt;</span> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <a href="http://en.cppreference.com/w/cpp/string/char_traits"><span class="kw1270">std::<span class="me2">char_traits</span></span></a><span class="sy1">&lt;</span><span class="kw4">char16_t</span><span class="sy1">&gt;</span> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <a href="http://en.cppreference.com/w/cpp/string/char_traits"><span class="kw1270">std::<span class="me2">char_traits</span></span></a><span class="sy1">&lt;</span><span class="kw4">char32_t</span><span class="sy1">&gt;</span> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string.html" title="cpp/string/basic string"> <span class="t-lines"><span>basic_string</span></span></a></div> </td> <td> stores and manipulates sequences of characters <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::string</a></code> </td> <td> <a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1231">std::<span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::u8string</a></code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1231">std::<span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span>char8_t<span class="sy1">&gt;</span> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::u16string</a></code> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1231">std::<span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">char16_t</span><span class="sy1">&gt;</span> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::u32string</a></code> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1231">std::<span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">char32_t</span><span class="sy1">&gt;</span> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::wstring</a></code> </td> <td> <a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1231">std::<span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">wchar_t</span><span class="sy1">&gt;</span> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::pmr::basic_string</a></code> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> <span class="t-mark">(alias template)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::pmr::string</a></code> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> <a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw3293">std::<span class="me2">pmr</span><span class="sy4">::</span><span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::pmr::u8string</a></code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw3293">std::<span class="me2">pmr</span><span class="sy4">::</span><span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span>char8_t<span class="sy1">&gt;</span> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::pmr::u16string</a></code> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> <a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw3293">std::<span class="me2">pmr</span><span class="sy4">::</span><span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">char16_t</span><span class="sy1">&gt;</span> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::pmr::u32string</a></code> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> <a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw3293">std::<span class="me2">pmr</span><span class="sy4">::</span><span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">char32_t</span><span class="sy1">&gt;</span> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::pmr::wstring</a></code> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> <a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw3293">std::<span class="me2">pmr</span><span class="sy4">::</span><span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">wchar_t</span><span class="sy1">&gt;</span> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/hash.html" title="cpp/string/basic string/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::basic_string&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for strings <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr> <td colspan="2"> <h3 id="Functions"> Functions</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_plus_.html" title="cpp/string/basic string/operator+"> <span class="t-lines"><span>operator+</span></span></a></div> </td> <td> concatenates two strings or a string and a <span class="kw4">char</span> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_cmp.html" title="cpp/string/basic string/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&gt;</span><span>operator&lt;=</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> lexicographically compares two strings <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/swap2.html" title="cpp/string/basic string/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::basic_string)</span></span></span></a></div> </td> <td> specializes the <code><a href="../algorithm/swap.html" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/erase2.html" title="cpp/string/basic string/erase2"> <span class="t-lines"><span>erase<span class="t-dsc-small">(std::basic_string)</span></span><span>erase_if<span class="t-dsc-small">(std::basic_string)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> erases all elements satisfying specific criteria <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Input.2Foutput">  Input/output </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_ltltgtgt.html" title="cpp/string/basic string/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> performs stream input and output on strings <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/getline.html" title="cpp/string/basic string/getline"> <span class="t-lines"><span>getline</span></span></a></div> </td> <td> read data from an I/O stream into a string <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Numeric_conversions">  Numeric conversions </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/stol.html" title="cpp/string/basic string/stol"> <span class="t-lines"><span>stoi</span><span>stol</span><span>stoll</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> converts a string to a signed integer <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/stoul.html" title="cpp/string/basic string/stoul"> <span class="t-lines"><span>stoul</span><span>stoull</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> converts a string to an unsigned integer <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/stof.html" title="cpp/string/basic string/stof"> <span class="t-lines"><span>stof</span><span>stod</span><span>stold</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> converts a string to a floating point value <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/to_string.html" title="cpp/string/basic string/to string"> <span class="t-lines"><span>to_string</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> converts an integral or floating-point value to <code>string</code> <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/to_wstring.html" title="cpp/string/basic string/to wstring"> <span class="t-lines"><span>to_wstring</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> converts an integral or floating-point value to <code>wstring</code> <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_access">  Range access </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/begin.html" title="cpp/iterator/begin"> <span class="t-lines"><span>begin</span><span>cbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns an iterator to the beginning of a container or array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/end.html" title="cpp/iterator/end"> <span class="t-lines"><span>end</span><span>cend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns an iterator to the end of a container or array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/rbegin.html" title="cpp/iterator/rbegin"> <span class="t-lines"><span>rbegin</span><span>crbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns a reverse iterator to the beginning of a container or array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/rend.html" title="cpp/iterator/rend"> <span class="t-lines"><span>rend</span><span>crend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> returns a reverse end iterator for a container or array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/size.html" title="cpp/iterator/size"> <span class="t-lines"><span>size</span><span>ssize</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the size of a container or array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/empty.html" title="cpp/iterator/empty"> <span class="t-lines"><span>empty</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> checks whether the container is empty <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/data.html" title="cpp/iterator/data"> <span class="t-lines"><span>data</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> obtains the pointer to the underlying array <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Literals">  Literals </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in inline namespace <code>std::literals::string_literals</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href='../string/basic_string/operator""s' title='cpp/string/basic string/operator""s'> <span class="t-lines"><span>operator""s</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> converts a character array literal to <code>basic_string</code> <br> <span class="t-mark">(function)</span>  </td>
</tr> </table> <h3 id="Synopsis"> Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;compare&gt;
#include &lt;initializer_list&gt;
 
namespace std {
  // character traits
  template&lt;class CharT&gt; struct char_traits; // freestanding
  template&lt;&gt; struct char_traits&lt;char&gt;;      // freestanding
  template&lt;&gt; struct char_traits&lt;char8_t&gt;;   // freestanding
  template&lt;&gt; struct char_traits&lt;char16_t&gt;;  // freestanding
  template&lt;&gt; struct char_traits&lt;char32_t&gt;;  // freestanding
  template&lt;&gt; struct char_traits&lt;wchar_t&gt;;   // freestanding
 
  // basic_string
  template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;,
           class Allocator = allocator&lt;CharT&gt;&gt;
    class basic_string;
 
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(const basic_string&lt;CharT, Traits, Allocator&gt;&amp; lhs,
                const basic_string&lt;CharT, Traits, Allocator&gt;&amp; rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(basic_string&lt;CharT, Traits, Allocator&gt;&amp;&amp; lhs,
                const basic_string&lt;CharT, Traits, Allocator&gt;&amp; rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(const basic_string&lt;CharT, Traits, Allocator&gt;&amp; lhs,
                basic_string&lt;CharT, Traits, Allocator&gt;&amp;&amp; rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(basic_string&lt;CharT, Traits, Allocator&gt;&amp;&amp; lhs,
                basic_string&lt;CharT, Traits, Allocator&gt;&amp;&amp; rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(const CharT* lhs,
                const basic_string&lt;CharT, Traits, Allocator&gt;&amp; rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(const CharT* lhs,
                basic_string&lt;CharT, Traits, Allocator&gt;&amp;&amp; rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(CharT lhs,
                const basic_string&lt;CharT, Traits, Allocator&gt;&amp; rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(CharT lhs,
                basic_string&lt;CharT, Traits, Allocator&gt;&amp;&amp; rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(const basic_string&lt;CharT, Traits, Allocator&gt;&amp; lhs,
                const CharT* rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(basic_string&lt;CharT, Traits, Allocator&gt;&amp;&amp; lhs,
                const CharT* rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(const basic_string&lt;CharT, Traits, Allocator&gt;&amp; lhs,
                CharT rhs);
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr basic_string&lt;CharT, Traits, Allocator&gt;
      operator+(basic_string&lt;CharT, Traits, Allocator&gt;&amp;&amp; lhs,
                CharT rhs);
 
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr bool
      operator==(const basic_string&lt;CharT, Traits, Allocator&gt;&amp; lhs,
                 const basic_string&lt;CharT, Traits, Allocator&gt;&amp; rhs) noexcept;
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr bool operator==(const basic_string&lt;CharT, Traits, Allocator&gt;&amp; lhs,
                              const CharT* rhs);
 
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr /* see description */ operator&lt;=&gt;(const basic_string&lt;CharT,
                                                Traits, Allocator&gt;&amp; lhs,
                                                const basic_string&lt;CharT,
                                                Traits, Allocator&gt;&amp; rhs) noexcept;
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr /* see description */ operator&lt;=&gt;(const basic_string&lt;CharT,
                                                Traits, Allocator&gt;&amp; lhs,
                                                const CharT* rhs);
 
  // swap
  template&lt;class CharT, class Traits, class Allocator&gt;
    constexpr void
      swap(basic_string&lt;CharT, Traits, Allocator&gt;&amp; lhs,
           basic_string&lt;CharT, Traits, Allocator&gt;&amp; rhs)
        noexcept(noexcept(lhs.swap(rhs)));
 
  // inserters and extractors
  template&lt;class CharT, class Traits, class Allocator&gt;
    basic_istream&lt;CharT, Traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;CharT, Traits&gt;&amp; is,
                 basic_string&lt;CharT, Traits, Allocator&gt;&amp; str);
  template&lt;class CharT, class Traits, class Allocator&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;CharT, Traits&gt;&amp; os,
                 const basic_string&lt;CharT, Traits, Allocator&gt;&amp; str);
  template&lt;class CharT, class Traits, class Allocator&gt;
    basic_istream&lt;CharT, Traits&gt;&amp;
      getline(basic_istream&lt;CharT, Traits&gt;&amp; is,
              basic_string&lt;CharT, Traits, Allocator&gt;&amp; str,
              CharT delim);
  template&lt;class CharT, class Traits, class Allocator&gt;
    basic_istream&lt;CharT, Traits&gt;&amp;
      getline(basic_istream&lt;CharT, Traits&gt;&amp;&amp; is,
              basic_string&lt;CharT, Traits, Allocator&gt;&amp; str,
              CharT delim);
  template&lt;class CharT, class Traits, class Allocator&gt;
    basic_istream&lt;CharT, Traits&gt;&amp;
      getline(basic_istream&lt;CharT, Traits&gt;&amp; is,
              basic_string&lt;CharT, Traits, Allocator&gt;&amp; str);
  template&lt;class CharT, class Traits, class Allocator&gt;
    basic_istream&lt;CharT, Traits&gt;&amp;
      getline(basic_istream&lt;CharT, Traits&gt;&amp;&amp; is,
              basic_string&lt;CharT, Traits, Allocator&gt;&amp; str);
 
  // erasure
  template&lt;class CharT, class Traits, class Allocator, class U&gt;
    constexpr typename basic_string&lt;CharT, Traits, Allocator&gt;::size_type
      erase(basic_string&lt;CharT, Traits, Allocator&gt;&amp; c, const U&amp; value);
  template&lt;class CharT, class Traits, class Allocator, class Pred&gt;
    constexpr typename basic_string&lt;CharT, Traits, Allocator&gt;::size_type
      erase_if(basic_string&lt;CharT, Traits, Allocator&gt;&amp; c, Pred pred);
 
  // basic_string typedef-names
  using string    = basic_string&lt;char&gt;;
  using u8string  = basic_string&lt;char8_t&gt;;
  using u16string = basic_string&lt;char16_t&gt;;
  using u32string = basic_string&lt;char32_t&gt;;
  using wstring   = basic_string&lt;wchar_t&gt;;
 
  // numeric conversions
  int stoi(const string&amp; str, size_t* idx = nullptr, int base = 10);
  long stol(const string&amp; str, size_t* idx = nullptr, int base = 10);
  unsigned long stoul(const string&amp; str, size_t* idx = nullptr, int base = 10);
  long long stoll(const string&amp; str, size_t* idx = nullptr, int base = 10);
  unsigned long long stoull(const string&amp; str, size_t* idx = nullptr, int base = 10);
  float stof(const string&amp; str, size_t* idx = nullptr);
  double stod(const string&amp; str, size_t* idx = nullptr);
  long double stold(const string&amp; str, size_t* idx = nullptr);
  string to_string(int val);
  string to_string(unsigned val);
  string to_string(long val);
  string to_string(unsigned long val);
  string to_string(long long val);
  string to_string(unsigned long long val);
  string to_string(float val);
  string to_string(double val);
  string to_string(long double val);
 
  int stoi(const wstring&amp; str, size_t* idx = nullptr, int base = 10);
  long stol(const wstring&amp; str, size_t* idx = nullptr, int base = 10);
  unsigned long stoul(const wstring&amp; str, size_t* idx = nullptr, int base = 10);
  long long stoll(const wstring&amp; str, size_t* idx = nullptr, int base = 10);
  unsigned long long stoull(const wstring&amp; str, size_t* idx = nullptr, int base = 10);
  float stof(const wstring&amp; str, size_t* idx = nullptr);
  double stod(const wstring&amp; str, size_t* idx = nullptr);
  long double stold(const wstring&amp; str, size_t* idx = nullptr);
  wstring to_wstring(int val);
  wstring to_wstring(unsigned val);
  wstring to_wstring(long val);
  wstring to_wstring(unsigned long val);
  wstring to_wstring(long long val);
  wstring to_wstring(unsigned long long val);
  wstring to_wstring(float val);
  wstring to_wstring(double val);
  wstring to_wstring(long double val);
 
  namespace pmr {
    template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
      using basic_string = std::basic_string&lt;CharT, Traits, polymorphic_allocator&lt;CharT&gt;&gt;;
 
    using string    = basic_string&lt;char&gt;;
    using u8string  = basic_string&lt;char8_t&gt;;
    using u16string = basic_string&lt;char16_t&gt;;
    using u32string = basic_string&lt;char32_t&gt;;
    using wstring   = basic_string&lt;wchar_t&gt;;
  }
 
  // hash support
  template&lt;class T&gt; struct hash;
  template&lt;class A&gt; struct hash&lt;basic_string&lt;char, char_traits&lt;char&gt;, A&gt;&gt;;
  template&lt;class A&gt; struct hash&lt;basic_string&lt;char8_t, char_traits&lt;char8_t&gt;, A&gt;&gt;;
  template&lt;class A&gt; struct hash&lt;basic_string&lt;char16_t, char_traits&lt;char16_t&gt;, A&gt;&gt;;
  template&lt;class A&gt; struct hash&lt;basic_string&lt;char32_t, char_traits&lt;char32_t&gt;, A&gt;&gt;;
  template&lt;class A&gt; struct hash&lt;basic_string&lt;wchar_t, char_traits&lt;wchar_t&gt;, A&gt;&gt;;
 
  inline namespace literals {
  inline namespace string_literals {
    // suffix for basic_string literals
    constexpr string    operator""s(const char* str, size_t len);
    constexpr u8string  operator""s(const char8_t* str, size_t len);
    constexpr u16string operator""s(const char16_t* str, size_t len);
    constexpr u32string operator""s(const char32_t* str, size_t len);
    constexpr wstring   operator""s(const wchar_t* str, size_t len);
  }
  }
}</pre></div> <h4 id="Class_template_std::char_traits"> Class template <code><a href="../string/char_traits.html" title="cpp/string/char traits">std::char_traits</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;&gt; struct char_traits&lt;char&gt; {
    using char_type  = char;
    using int_type   = int;
    using off_type   = streamoff;
    using pos_type   = streampos;
    using state_type = mbstate_t;
    using comparison_category = strong_ordering;
 
    static constexpr void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;
 
    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           const char_type&amp; a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
 
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
 
  template&lt;&gt; struct char_traits&lt;char8_t&gt; {
    using char_type  = char8_t;
    using int_type   = unsigned int;
    using off_type   = streamoff;
    using pos_type   = u8streampos;
    using state_type = mbstate_t;
    using comparison_category = strong_ordering;
 
    static constexpr void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;
 
    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           const char_type&amp; a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
 
  template&lt;&gt; struct char_traits&lt;char16_t&gt; {
    using char_type  = char16_t;
    using int_type   = uint_least16_t;
    using off_type   = streamoff;
    using pos_type   = u16streampos;
    using state_type = mbstate_t;
    using comparison_category = strong_ordering;
 
    static constexpr void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;
 
    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           const char_type&amp; a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
 
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
 
  template&lt;&gt; struct char_traits&lt;char32_t&gt; {
    using char_type  = char32_t;
    using int_type   = uint_least32_t;
    using off_type   = streamoff;
    using pos_type   = u32streampos;
    using state_type = mbstate_t;
    using comparison_category = strong_ordering;
 
    static constexpr void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;
 
    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           const char_type&amp; a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
 
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
 
  template&lt;&gt; struct char_traits&lt;wchar_t&gt; {
    using char_type  = wchar_t;
    using int_type   = wint_t;
    using off_type   = streamoff;
    using pos_type   = wstreampos;
    using state_type = mbstate_t;
    using comparison_category = strong_ordering;
 
    static constexpr void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;
 
    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           const char_type&amp; a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
 
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}</pre></div> <h4 id="Class_template_std::basic_string"> Class template <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::basic_string</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class CharT, class Traits = char_traits&lt;CharT&gt;,
           class Allocator = allocator&lt;CharT&gt;&gt;
  class basic_string {
  public:
    // types
    using traits_type            = Traits;
    using value_type             = CharT;
    using allocator_type         = Allocator;
    using size_type              = typename allocator_traits&lt;Allocator&gt;::size_type;
    using difference_type        = typename allocator_traits&lt;Allocator&gt;::difference_type;
    using pointer                = typename allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer          = typename allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference              = value_type&amp;;
    using const_reference        = const value_type&amp;;
 
    using iterator               = /* implementation-defined */;
    using const_iterator         = /* implementation-defined */;
    using reverse_iterator       = std::reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;
    static constexpr size_type npos = size_type(-1);
 
    // construct/copy/destroy
    constexpr basic_string() noexcept(noexcept(Allocator()))
      : basic_string(Allocator()) { }
    constexpr explicit basic_string(const Allocator&amp; a) noexcept;
    constexpr basic_string(const basic_string&amp; str);
    constexpr basic_string(basic_string&amp;&amp; str) noexcept;
    constexpr basic_string(const basic_string&amp; str, size_type pos,
                           const Allocator&amp; a = Allocator());
    constexpr basic_string(const basic_string&amp; str, size_type pos, size_type n,
                           const Allocator&amp; a = Allocator());
    constexpr basic_string(basic_string&amp;&amp; str, size_type pos,
                           const Allocator&amp; a = Allocator());
    constexpr basic_string(basic_string&amp;&amp; str, size_type pos, size_type n,
                           const Allocator&amp; a = Allocator());
    template&lt;class T&gt;
      constexpr basic_string(const T&amp; t, size_type pos, size_type n,
                             const Allocator&amp; a = Allocator());
    template&lt;class T&gt;
      constexpr explicit basic_string(const T&amp; t, const Allocator&amp; a = Allocator());
    constexpr basic_string(const CharT* s, size_type n, const Allocator&amp; a = Allocator());
    constexpr basic_string(const CharT* s, const Allocator&amp; a = Allocator());
    basic_string(nullptr_t) = delete;
    constexpr basic_string(size_type n, CharT c, const Allocator&amp; a = Allocator());
    template&lt;class InputIt&gt;
      constexpr basic_string(InputIt begin, InputIt end,
                             const Allocator&amp; a = Allocator());
    template&lt;__container_compatible_range&lt;CharT&gt; R&gt;
      constexpr basic_string(from_range_t, R&amp;&amp; rg, const Allocator&amp; a = Allocator());
    constexpr basic_string(initializer_list&lt;CharT&gt;, const Allocator&amp; = Allocator());
    constexpr basic_string(const basic_string&amp;, const Allocator&amp;);
    constexpr basic_string(basic_string&amp;&amp;, const Allocator&amp;);
    constexpr ~basic_string();
 
    constexpr basic_string&amp; operator=(const basic_string&amp; str);
    constexpr basic_string&amp; operator=(basic_string&amp;&amp; str)
      noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value ||
               allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    template&lt;class T&gt;
      constexpr basic_string&amp; operator=(const T&amp; t);
    constexpr basic_string&amp; operator=(const CharT* s);
    basic_string&amp; operator=(nullptr_t) = delete;
    constexpr basic_string&amp; operator=(CharT c);
    constexpr basic_string&amp; operator=(initializer_list&lt;CharT&gt;);
 
    // iterators
    constexpr iterator       begin() noexcept;
    constexpr const_iterator begin() const noexcept;
    constexpr iterator       end() noexcept;
    constexpr const_iterator end() const noexcept;
 
    constexpr reverse_iterator       rbegin() noexcept;
    constexpr const_reverse_iterator rbegin() const noexcept;
    constexpr reverse_iterator       rend() noexcept;
    constexpr const_reverse_iterator rend() const noexcept;
 
    constexpr const_iterator         cbegin() const noexcept;
    constexpr const_iterator         cend() const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend() const noexcept;
 
    // capacity
    constexpr size_type size() const noexcept;
    constexpr size_type length() const noexcept;
    constexpr size_type max_size() const noexcept;
    constexpr void resize(size_type n, CharT c);
    constexpr void resize(size_type n);
    template&lt;class Operation&gt;
      constexpr void resize_and_overwrite(size_type n, Operation op);
    constexpr size_type capacity() const noexcept;
    constexpr void reserve(size_type res_arg);
    constexpr void shrink_to_fit();
    constexpr void clear() noexcept;
    [[nodiscard]] constexpr bool empty() const noexcept;
 
    // element access
    constexpr const_reference operator[](size_type pos) const;
    constexpr reference       operator[](size_type pos);
    constexpr const_reference at(size_type n) const;
    constexpr reference       at(size_type n);
 
    constexpr const CharT&amp; front() const;
    constexpr CharT&amp;       front();
    constexpr const CharT&amp; back() const;
    constexpr CharT&amp;       back();
 
    // modifiers
    constexpr basic_string&amp; operator+=(const basic_string&amp; str);
    template&lt;class T&gt;
      constexpr basic_string&amp; operator+=(const T&amp; t);
    constexpr basic_string&amp; operator+=(const CharT* s);
    constexpr basic_string&amp; operator+=(CharT c);
    constexpr basic_string&amp; operator+=(initializer_list&lt;CharT&gt;);
    constexpr basic_string&amp; append(const basic_string&amp; str);
    constexpr basic_string&amp; append(const basic_string&amp; str, size_type pos,
                                   size_type n = npos);
    template&lt;class T&gt;
      constexpr basic_string&amp; append(const T&amp; t);
    template&lt;class T&gt;
      constexpr basic_string&amp; append(const T&amp; t, size_type pos, size_type n = npos);
    constexpr basic_string&amp; append(const CharT* s, size_type n);
    constexpr basic_string&amp; append(const CharT* s);
    constexpr basic_string&amp; append(size_type n, CharT c);
    template&lt;class InputIt&gt;
      constexpr basic_string&amp; append(InputIt first, InputIt last);
    template&lt;__container_compatible_range&lt;CharT&gt; R&gt;
      constexpr basic_string&amp; append_range(R&amp;&amp; rg);
    constexpr basic_string&amp; append(initializer_list&lt;CharT&gt;);
 
    constexpr void push_back(CharT c);
 
    constexpr basic_string&amp; assign(const basic_string&amp; str);
    constexpr basic_string&amp; assign(basic_string&amp;&amp; str)
      noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value ||
               allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    constexpr basic_string&amp; assign(const basic_string&amp; str, size_type pos,
                                   size_type n = npos);
    template&lt;class T&gt;
      constexpr basic_string&amp; assign(const T&amp; t);
    template&lt;class T&gt;
      constexpr basic_string&amp; assign(const T&amp; t, size_type pos, size_type n = npos);
    constexpr basic_string&amp; assign(const CharT* s, size_type n);
    constexpr basic_string&amp; assign(const CharT* s);
    constexpr basic_string&amp; assign(size_type n, CharT c);
    template&lt;class InputIt&gt;
      constexpr basic_string&amp; assign(InputIt first, InputIt last);
    template&lt;__container_compatible_range&lt;CharT&gt; R&gt;
      constexpr basic_string&amp; assign_range(R&amp;&amp; rg);
    constexpr basic_string&amp; assign(initializer_list&lt;CharT&gt;);
 
    constexpr basic_string&amp; insert(size_type pos, const basic_string&amp; str);
    constexpr basic_string&amp; insert(size_type pos1, const basic_string&amp; str,
                                   size_type pos2, size_type n = npos);
    template&lt;class T&gt;
      constexpr basic_string&amp; insert(size_type pos, const T&amp; t);
    template&lt;class T&gt;
      constexpr basic_string&amp; insert(size_type pos1, const T&amp; t,
                                     size_type pos2, size_type n = npos);
    constexpr basic_string&amp; insert(size_type pos, const CharT* s, size_type n);
    constexpr basic_string&amp; insert(size_type pos, const CharT* s);
    constexpr basic_string&amp; insert(size_type pos, size_type n, CharT c);
    constexpr iterator insert(const_iterator p, CharT c);
    constexpr iterator insert(const_iterator p, size_type n, CharT c);
    template&lt;class InputIt&gt;
      constexpr iterator insert(const_iterator p, InputIt first, InputIt last);
    template&lt;__container_compatible_range&lt;CharT&gt; R&gt;
      constexpr iterator insert_range(const_iterator p, R&amp;&amp; rg);
    constexpr iterator insert(const_iterator p, initializer_list&lt;CharT&gt;);
 
    constexpr basic_string&amp; erase(size_type pos = 0, size_type n = npos);
    constexpr iterator erase(const_iterator p);
    constexpr iterator erase(const_iterator first, const_iterator last);
 
    constexpr void pop_back();
 
    constexpr basic_string&amp; replace(size_type pos1, size_type n1, const basic_string&amp; str);
    constexpr basic_string&amp; replace(size_type pos1, size_type n1, const basic_string&amp; str,
                                    size_type pos2, size_type n2 = npos);
    template&lt;class T&gt;
      constexpr basic_string&amp; replace(size_type pos1, size_type n1, const T&amp; t);
    template&lt;class T&gt;
      constexpr basic_string&amp; replace(size_type pos1, size_type n1, const T&amp; t,
                                      size_type pos2, size_type n2 = npos);
    constexpr basic_string&amp; replace(size_type pos, size_type n1, const CharT* s,
                                    size_type n2);
    constexpr basic_string&amp; replace(size_type pos, size_type n1, const CharT* s);
    constexpr basic_string&amp; replace(size_type pos, size_type n1, size_type n2, CharT c);
    constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2,
                                    const basic_string&amp; str);
    template&lt;class T&gt;
      constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2, const T&amp; t);
    constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2, const CharT* s,
                                    size_type n);
    constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2, const CharT* s);
    constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2, size_type n,
                                    CharT c);
    template&lt;class InputIt&gt;
      constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2,
                                      InputIt j1, InputIt j2);
    template&lt;__container_compatible_range&lt;CharT&gt; R&gt;
      constexpr basic_string&amp; replace_with_range(const_iterator i1, const_iterator i2,
                                                 R&amp;&amp; rg);
    constexpr basic_string&amp; replace(const_iterator, const_iterator,
                                    initializer_list&lt;CharT&gt;);
 
    constexpr size_type copy(CharT* s, size_type n, size_type pos = 0) const;
 
    constexpr void swap(basic_string&amp; str)
      noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value ||
               allocator_traits&lt;Allocator&gt;::is_always_equal::value);
 
    // string operations
    constexpr const CharT* c_str() const noexcept;
    constexpr const CharT* data() const noexcept;
    constexpr CharT* data() noexcept;
    constexpr operator basic_string_view&lt;CharT, Traits&gt;() const noexcept;
    constexpr allocator_type get_allocator() const noexcept;
 
    template&lt;class T&gt;
      constexpr size_type find(const T&amp; t,
                               size_type pos = 0) const noexcept(/* see description */);
    constexpr size_type find(const basic_string&amp; str, size_type pos = 0) const noexcept;
    constexpr size_type find(const CharT* s, size_type pos, size_type n) const;
    constexpr size_type find(const CharT* s, size_type pos = 0) const;
    constexpr size_type find(CharT c, size_type pos = 0) const noexcept;
    template&lt;class T&gt;
      constexpr size_type rfind(const T&amp; t, size_type pos = npos)
        const noexcept(/* see description */);
    constexpr size_type rfind(const basic_string&amp; str,
                              size_type pos = npos) const noexcept;
    constexpr size_type rfind(const CharT* s, size_type pos, size_type n) const;
    constexpr size_type rfind(const CharT* s, size_type pos = npos) const;
    constexpr size_type rfind(CharT c, size_type pos = npos) const noexcept;
 
    template&lt;class T&gt;
      constexpr size_type find_first_of(const T&amp; t, size_type pos = 0)
        const noexcept(/* see description */);
    constexpr size_type find_first_of(const basic_string&amp; str,
                                      size_type pos = 0) const noexcept;
    constexpr size_type find_first_of(const CharT* s, size_type pos, size_type n) const;
    constexpr size_type find_first_of(const CharT* s, size_type pos = 0) const;
    constexpr size_type find_first_of(CharT c, size_type pos = 0) const noexcept;
    template&lt;class T&gt;
      constexpr size_type find_last_of(const T&amp; t, size_type pos = npos)
        const noexcept(/* see description */);
    constexpr size_type find_last_of(const basic_string&amp; str,
                                     size_type pos = npos) const noexcept;
    constexpr size_type find_last_of(const CharT* s, size_type pos, size_type n) const;
    constexpr size_type find_last_of(const CharT* s, size_type pos = npos) const;
    constexpr size_type find_last_of(CharT c, size_type pos = npos) const noexcept;
 
    template&lt;class T&gt;
      constexpr size_type find_first_not_of(const T&amp; t, size_type pos = 0)
        const noexcept(/* see description */);
    constexpr size_type find_first_not_of(const basic_string&amp; str,
                                          size_type pos = 0) const noexcept;
    constexpr size_type find_first_not_of(const CharT* s, size_type pos, size_type n) const;
    constexpr size_type find_first_not_of(const CharT* s, size_type pos = 0) const;
    constexpr size_type find_first_not_of(CharT c, size_type pos = 0) const noexcept;
    template&lt;class T&gt;
      constexpr size_type find_last_not_of(const T&amp; t, size_type pos = npos)
        const noexcept(/* see description */);
    constexpr size_type find_last_not_of(const basic_string&amp; str,
                                         size_type pos = npos) const noexcept;
    constexpr size_type find_last_not_of(const CharT* s, size_type pos, size_type n) const;
    constexpr size_type find_last_not_of(const CharT* s, size_type pos = npos) const;
    constexpr size_type find_last_not_of(CharT c, size_type pos = npos) const noexcept;
 
    constexpr basic_string substr(size_type pos = 0, size_type n = npos) const &amp;;
    constexpr basic_string substr(size_type pos = 0, size_type n = npos) &amp;&amp;;
 
    template&lt;class T&gt;
      constexpr int compare(const T&amp; t) const noexcept(/* see description */);
    template&lt;class T&gt;
      constexpr int compare(size_type pos1, size_type n1, const T&amp; t) const;
    template&lt;class T&gt;
      constexpr int compare(size_type pos1, size_type n1, const T&amp; t,
                            size_type pos2, size_type n2 = npos) const;
    constexpr int compare(const basic_string&amp; str) const noexcept;
    constexpr int compare(size_type pos1, size_type n1, const basic_string&amp; str) const;
    constexpr int compare(size_type pos1, size_type n1, const basic_string&amp; str,
                          size_type pos2, size_type n2 = npos) const;
    constexpr int compare(const CharT* s) const;
    constexpr int compare(size_type pos1, size_type n1, const CharT* s) const;
    constexpr int compare(size_type pos1, size_type n1, const CharT* s, size_type n2) const;
 
    constexpr bool starts_with(basic_string_view&lt;CharT, Traits&gt; x) const noexcept;
    constexpr bool starts_with(CharT x) const noexcept;
    constexpr bool starts_with(const CharT* x) const;
    constexpr bool ends_with(basic_string_view&lt;CharT, Traits&gt; x) const noexcept;
    constexpr bool ends_with(CharT x) const noexcept;
    constexpr bool ends_with(const CharT* x) const;
 
    constexpr bool contains(basic_string_view&lt;CharT, Traits&gt; x) const noexcept;
    constexpr bool contains(CharT x) const noexcept;
    constexpr bool contains(const CharT* x) const;
  };
 
  template&lt;class InputIt,
           class Allocator = allocator&lt;typename iterator_traits&lt;InputIt&gt;::value_type&gt;&gt;
    basic_string(InputIt, InputIt, Allocator = Allocator())
      -&gt; basic_string&lt;typename iterator_traits&lt;InputIt&gt;::value_type,
                      char_traits&lt;typename iterator_traits&lt;InputIt&gt;::value_type&gt;,
                      Allocator&gt;;
 
  template&lt;ranges::input_range R,
           class Allocator = allocator&lt;ranges::range_value_t&lt;R&gt;&gt;&gt;
    basic_string(from_range_t, R&amp;&amp;, Allocator = Allocator())
      -&gt; basic_string&lt;ranges::range_value_t&lt;R&gt;, char_traits&lt;ranges::range_value_t&lt;R&gt;&gt;,
                      Allocator&gt;;
 
  template&lt;class CharT,
           class Traits,
           class Allocator = allocator&lt;CharT&gt;&gt;
    explicit basic_string(basic_string_view&lt;CharT, Traits&gt;, const Allocator&amp; = Allocator())
      -&gt; basic_string&lt;CharT, Traits, Allocator&gt;;
 
  template&lt;class CharT,
           class Traits,
           class Allocator = allocator&lt;CharT&gt;&gt;
    basic_string(basic_string_view&lt;CharT, Traits&gt;,
                 typename /* see description */::size_type,
                 typename /* see description */::size_type,
                 const Allocator&amp; = Allocator())
      -&gt; basic_string&lt;CharT, Traits, Allocator&gt;;
}</pre></div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue209">LWG 209</a> </td> <td>C++98 </td> <td>the declarations of the following <code><a href="../string/basic_string.html" title="cpp/string/basic string">std::basic_string</a></code><br>members used inconsistent styles in the synopsis: <ul>
<li> <code>void push_back(CharT c);</code> </li>
<li> <code>basic_string&amp; assign(const basic_string&amp; str);</code> </li>
<li> <code>void swap(basic_string&amp; str);</code> </li>
</ul> </td> <td>uniformed the styles </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/header/string" class="_attribution-link">https://en.cppreference.com/w/cpp/header/string</a>
  </p>
</div>
