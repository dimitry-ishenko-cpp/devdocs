    <h1 id="firstHeading" class="firstHeading">Standard library header &lt;format&gt; <span class="t-mark-rev t-since-cxx20">(C++20)</span>
</h1>            <p>This header is part of the <a href="../utility/format.html" title="cpp/utility/format">format</a> library.</p>
<table class="t-dsc-begin"> <tr> <td colspan="2">  <h3 id="Concepts"> Concepts</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/formattable.html" title="cpp/utility/format/formattable"> <span class="t-lines"><span>formattable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> specifies that a type is formattable, that is, it specializes <code><a href="../utility/format/formatter.html" title="cpp/utility/format/formatter">std::formatter</a></code> and provides member functions <code>parse</code> and <code>format</code> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Enumerations"> Enumerations</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/range_format.html" title="cpp/utility/format/range format"> <span class="t-lines"><span>range_format</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> specifies how a range should be formatted <br> <span class="t-mark">(enum)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Classes"> Classes</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/formatter.html" title="cpp/utility/format/formatter"> <span class="t-lines"><span>formatter</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> defines formatting rules for a given type <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/range_formatter.html" title="cpp/utility/format/range formatter"> <span class="t-lines"><span>range_formatter</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> class template that helps implementing <code><a href="../utility/format/formatter.html" title="cpp/utility/format/formatter">std::formatter</a></code> specializations for range types <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/basic_format_parse_context.html" title="cpp/utility/format/basic format parse context"> <span class="t-lines"><span>basic_format_parse_context</span><span>format_parse_context</span><span>wformat_parse_context</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> formatting string parser state <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/basic_format_context.html" title="cpp/utility/format/basic format context"> <span class="t-lines"><span>basic_format_context</span><span>format_context</span><span>wformat_context</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> formatting state, including all formatting arguments and the output iterator <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/basic_format_arg.html" title="cpp/utility/format/basic format arg"> <span class="t-lines"><span>basic_format_arg</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> class template that provides access to a formatting argument for user-defined formatters <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/basic_format_args.html" title="cpp/utility/format/basic format args"> <span class="t-lines"><span>basic_format_args</span><span>format_args</span><span>wformat_args</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> class that provides access to all formatting arguments <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/basic_format_string.html" title="cpp/utility/format/basic format string"> <span class="t-lines"><span>basic_format_string</span><span>format_string</span><span>wformat_string</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> class template that performs compile-time format string checks at construction time <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/format_error.html" title="cpp/utility/format/format error"> <span class="t-lines"><span>format_error</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> exception type thrown on formatting errors <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Formatter_specializations">  Formatter specializations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/tuple_formatter.html" title="cpp/utility/format/tuple formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;<i>pair-or-tuple</i>&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> formatting support for <code>pair</code> and <code>tuple</code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/ranges_formatter.html" title="cpp/utility/format/ranges formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;<i>range</i>&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> formatting support for ranges <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Functions"> Functions</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/format.html" title="cpp/utility/format/format"> <span class="t-lines"><span>format</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> stores formatted representation of the arguments in a new string <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/format_to.html" title="cpp/utility/format/format to"> <span class="t-lines"><span>format_to</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> writes out formatted representation of its arguments through an output iterator <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/format_to_n.html" title="cpp/utility/format/format to n"> <span class="t-lines"><span>format_to_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> writes out formatted representation of its arguments through an output iterator, not exceeding specified size <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/formatted_size.html" title="cpp/utility/format/formatted size"> <span class="t-lines"><span>formatted_size</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> determines the number of characters necessary to store the formatted representation of its arguments <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/runtime_format.html" title="cpp/utility/format/runtime format"> <span class="t-lines"><span>runtime_format</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> creates runtime format strings directly usable in user-oriented formatting functions <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/vformat.html" title="cpp/utility/format/vformat"> <span class="t-lines"><span>vformat</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> non-template variant of <code><a href="../utility/format/format.html" title="cpp/utility/format/format">std::format</a></code> using type-erased argument representation <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/vformat_to.html" title="cpp/utility/format/vformat to"> <span class="t-lines"><span>vformat_to</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> non-template variant of <code><a href="../utility/format/format_to.html" title="cpp/utility/format/format to">std::format_to</a></code> using type-erased argument representation <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/visit_format_arg.html" title="cpp/utility/format/visit format arg"> <span class="t-lines"><span>visit_format_arg</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span> <span class="t-mark-rev t-deprecated-cxx26">(deprecated in C++26)</span></span></span></div> </td> <td> argument visitation interface for user-defined formatters <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/make_format_args.html" title="cpp/utility/format/make format args"> <span class="t-lines"><span>make_format_args</span><span>make_wformat_args</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a type-erased object referencing all formatting arguments, convertible to <code>format_args</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Helpers"> Helpers</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/format/format_kind.html" title="cpp/utility/format/format kind"> <span class="t-lines"><span>format_kind</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> selects a suited <code>std::range_format</code> for a range<br><span class="t-mark">(variable template)</span> </td>
</tr> </table> <h3 id="Synopsis"> Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  // class template basic_format_context
  template&lt;class Out, class CharT&gt; class basic_format_context;
  using format_context = basic_format_context&lt;/* unspecified */, char&gt;;
  using wformat_context = basic_format_context&lt;/* unspecified */, wchar_t&gt;;
 
  // class template basic_format_args
  template&lt;class Context&gt; class basic_format_args;
  using format_args = basic_format_args&lt;format_context&gt;;
  using wformat_args = basic_format_args&lt;wformat_context&gt;;
 
  // class template basic_format_string
  template&lt;class CharT, class... Args&gt;
    struct basic_format_string;
 
  template&lt;class... Args&gt;
    using format_string = basic_format_string&lt;char, type_identity_t&lt;Args&gt;...&gt;;
  template&lt;class... Args&gt;
    using wformat_string = basic_format_string&lt;wchar_t, type_identity_t&lt;Args&gt;...&gt;;
 
  // formatting functions
  template&lt;class... Args&gt;
    string format(format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class... Args&gt;
    wstring format(wformat_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class... Args&gt;
    string format(const locale&amp; loc, format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class... Args&gt;
    wstring format(const locale&amp; loc, wformat_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
 
  string vformat(string_view fmt, format_args args);
  wstring vformat(wstring_view fmt, wformat_args args);
  string vformat(const locale&amp; loc, string_view fmt, format_args args);
  wstring vformat(const locale&amp; loc, wstring_view fmt, wformat_args args);
 
  template&lt;class Out, class... Args&gt;
    Out format_to(Out out, format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class Out, class... Args&gt;
    Out format_to(Out out, wformat_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class Out, class... Args&gt;
    Out format_to(Out out, const locale&amp; loc, format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class Out, class... Args&gt;
    Out format_to(Out out, const locale&amp; loc, wformat_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
 
  template&lt;class Out&gt;
    Out vformat_to(Out out, string_view fmt, format_args args);
  template&lt;class Out&gt;
    Out vformat_to(Out out, wstring_view fmt, wformat_args args);
  template&lt;class Out&gt;
    Out vformat_to(Out out, const locale&amp; loc, string_view fmt, format_args args);
  template&lt;class Out&gt;
    Out vformat_to(Out out, const locale&amp; loc, wstring_view fmt, wformat_args args);
 
  template&lt;class Out&gt; struct format_to_n_result {
    Out out;
    iter_difference_t&lt;Out&gt; size;
  };
  template&lt;class Out, class... Args&gt;
    format_to_n_result&lt;Out&gt; format_to_n(Out out, iter_difference_t&lt;Out&gt; n,
                                        format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class Out, class... Args&gt;
    format_to_n_result&lt;Out&gt; format_to_n(Out out, iter_difference_t&lt;Out&gt; n,
                                        wformat_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class Out, class... Args&gt;
    format_to_n_result&lt;Out&gt; format_to_n(Out out, iter_difference_t&lt;Out&gt; n,
                                        const locale&amp; loc, format_string&lt;Args...&gt; fmt,
                                        Args&amp;&amp;... args);
  template&lt;class Out, class... Args&gt;
    format_to_n_result&lt;Out&gt; format_to_n(Out out, iter_difference_t&lt;Out&gt; n,
                                        const locale&amp; loc, wformat_string&lt;Args...&gt; fmt,
                                        Args&amp;&amp;... args);
 
  template&lt;class... Args&gt;
    size_t formatted_size(format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class... Args&gt;
    size_t formatted_size(wformat_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class... Args&gt;
    size_t formatted_size(const locale&amp; loc, format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
  template&lt;class... Args&gt;
    size_t formatted_size(const locale&amp; loc, wformat_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);
 
  // formatter
  template&lt;class T, class CharT = char&gt; struct formatter;
 
  // concept formattable
  template&lt;class T, class CharT&gt;
    concept formattable = /* see description */;
 
  template&lt;class R, class CharT&gt;
    concept __const_formattable_range =                               // exposition only
      ranges::input_range&lt;const R&gt; &amp;&amp;
      formattable&lt;ranges::range_reference_t&lt;const R&gt;, CharT&gt;;
 
  template&lt;class R, class CharT&gt;
    using __fmt_maybe_const =                                         // exposition only
      conditional_t&lt;__const_formattable_range&lt;R, CharT&gt;, const R, R&gt;;
 
  // class template basic_format_parse_context
  template&lt;class CharT&gt; class basic_format_parse_context;
  using format_parse_context = basic_format_parse_context&lt;char&gt;;
  using wformat_parse_context = basic_format_parse_context&lt;wchar_t&gt;;
 
  // formatting of ranges
  // variable template format_kind
  enum class range_format {
    disabled,
    map,
    set,
    sequence,
    string,
    debug_string
  };
 
  template&lt;class R&gt;
    constexpr /* unspecified */ format_kind = /* unspecified */;
 
  template&lt;ranges::input_range R&gt;
      requires same_as&lt;R, remove_cvref_t&lt;R&gt;&gt;
    constexpr range_format format_kind&lt;R&gt; = /* see description */;
 
  // class template range_formatter
  template&lt;class T, class CharT = char&gt;
    requires same_as&lt;remove_cvref_t&lt;T&gt;, T&gt; &amp;&amp; formattable&lt;T, CharT&gt;
  class range_formatter;
 
  // class template range-default-formatter
  template&lt;range_format K, ranges::input_range R, class CharT&gt;
    struct __range_default_formatter;                                 // exposition only
 
  // specializations for maps, sets, and strings
  template&lt;ranges::input_range R, class CharT&gt;
    requires (format_kind&lt;R&gt; != range_format::disabled) &amp;&amp;
             formattable&lt;ranges::range_reference_t&lt;R&gt;, CharT&gt;
  struct formatter&lt;R, CharT&gt; : __range_default_formatter&lt;format_kind&lt;R&gt;, R, CharT&gt; { };
 
  // arguments
  // class template basic_format_arg
  template&lt;class Context&gt; class basic_format_arg;
 
  template&lt;class Visitor, class Context&gt;
    decltype(auto) visit_format_arg(Visitor&amp;&amp; vis, basic_format_arg&lt;Context&gt; arg);
 
  // class template format-arg-store
  template&lt;class Context, class... Args&gt; class __format_arg_store;    // exposition only
 
  template&lt;class Context = format_context, class... Args&gt;
    __format_arg_store&lt;Context, Args...&gt;
      make_format_args(Args&amp;&amp;... fmt_args);
  template&lt;class... Args&gt;
    __format_arg_store&lt;wformat_context, Args...&gt;
      make_wformat_args(Args&amp;&amp;... args);
 
  // class format_error
  class format_error;
}</pre></div> <h4 id="Class_template_std::basic_format_string"> Class template <code>std::basic_format_string</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class CharT, class... Args&gt;
  struct basic_format_string {
  private:
    basic_string_view&lt;CharT&gt; str;         // exposition only
 
  public:
    template&lt;class T&gt; consteval basic_format_string(const T&amp; s);
 
    constexpr basic_string_view&lt;CharT&gt; get() const noexcept { return str; }
  };
}</pre></div> <h4 id="Concept_std::formattable"> Concept <code>std::formattable</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, class CharT&gt;
  concept formattable =
    semiregular&lt;formatter&lt;remove_cvref_t&lt;T&gt;, CharT&gt;&gt; &amp;&amp;
    requires(formatter&lt;remove_cvref_t&lt;T&gt;, CharT&gt; f,
             const formatter&lt;remove_cvref_t&lt;T&gt;, CharT&gt; cf,
             T t,
             basic_format_context&lt;__fmt_iter_for&lt;CharT&gt;, CharT&gt; fc,
             basic_format_parse_context&lt;CharT&gt; pc) {
        { f.parse(pc) } -&gt; same_as&lt;basic_format_parse_context&lt;CharT&gt;::iterator&gt;;
        { cf.format(t, fc) } -&gt; same_as&lt;__fmt_iter_for&lt;CharT&gt;&gt;;
    };</pre></div> <h4 id="Class_template_std::basic_format_parse_context"> Class template <code><a href="../utility/format/basic_format_parse_context.html" title="cpp/utility/format/basic format parse context">std::basic_format_parse_context</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class CharT&gt;
  class basic_format_parse_context {
  public:
    using char_type = CharT;
    using const_iterator = typename basic_string_view&lt;CharT&gt;::const_iterator;
    using iterator = const_iterator;
 
  private:
    iterator begin_;                                    // exposition only
    iterator end_;                                      // exposition only
    enum indexing { unknown, manual, automatic };       // exposition only
    indexing indexing_;                                 // exposition only
    size_t next_arg_id_;                                // exposition only
    size_t num_args_;                                   // exposition only
 
  public:
    constexpr explicit basic_format_parse_context(basic_string_view&lt;CharT&gt; fmt,
                                                  size_t num_args = 0) noexcept;
    basic_format_parse_context(const basic_format_parse_context&amp;) = delete;
    basic_format_parse_context&amp; operator=(const basic_format_parse_context&amp;) = delete;
 
    constexpr const_iterator begin() const noexcept;
    constexpr const_iterator end() const noexcept;
    constexpr void advance_to(const_iterator it);
 
    constexpr size_t next_arg_id();
    constexpr void check_arg_id(size_t id);
 
    template&lt;class... Ts&gt;
    constexpr void check_dynamic_spec(size_t id) noexcept;
    constexpr void check_dynamic_spec_integral(size_t id) noexcept;
    constexpr void check_dynamic_spec_string(size_t id) noexcept;
  };
}</pre></div> <h4 id="Class_template_std::basic_format_context"> Class template <code><a href="../utility/format/basic_format_context.html" title="cpp/utility/format/basic format context">std::basic_format_context</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Out, class CharT&gt;
  class basic_format_context {
    basic_format_args&lt;basic_format_context&gt; args_;      // exposition only
    Out out_;                                           // exposition only
 
  public:
    using iterator = Out;
    using char_type = CharT;
    template&lt;class T&gt; using formatter_type = formatter&lt;T, CharT&gt;;
 
    basic_format_arg&lt;basic_format_context&gt; arg(size_t id) const noexcept;
    std::locale locale();
 
    iterator out();
    void advance_to(iterator it);
  };
}</pre></div> <h4 id="Variable_template_std::format_kind"> Variable template <code>std::format_kind</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;ranges::input_range R&gt;
    requires same_as&lt;R, remove_cvref_t&lt;R&gt;&gt;
  constexpr range_format format_kind&lt;R&gt; = /* see description */;</pre></div> <h4 id="Class_template_std::range_formatter"> Class template <code>std::range_formatter</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T, class CharT = char&gt;
    requires same_as&lt;remove_cvref_t&lt;T&gt;, T&gt; &amp;&amp; formattable&lt;T, CharT&gt;
  class range_formatter {
    formatter&lt;T, CharT&gt; underlying_;                        // exposition only
    basic_string_view&lt;CharT&gt; separator_ =                   // exposition only
      __STATICALLY_WIDEN&lt;CharT&gt;(", ");
    basic_string_view&lt;CharT&gt; __opening_bracket_ =           // exposition only
      __STATICALLY_WIDEN&lt;CharT&gt;("[");
    basic_string_view&lt;CharT&gt; __closing_bracket_ =           // exposition only
      __STATICALLY_WIDEN&lt;CharT&gt;("]");
 
  public:
    constexpr void set_separator(basic_string_view&lt;CharT&gt; sep);
    constexpr void set_brackets(basic_string_view&lt;CharT&gt; opening,
                                basic_string_view&lt;CharT&gt; closing);
    constexpr formatter&lt;T, CharT&gt;&amp; underlying() { return underlying_; }
    constexpr const formatter&lt;T, CharT&gt;&amp; underlying() const { return underlying_; }
 
    template&lt;class ParseContext&gt;
      constexpr typename ParseContext::iterator
        parse(ParseContext&amp; ctx);
 
    template&lt;ranges::input_range R, class FormatContext&gt;
        requires formattable&lt;ranges::range_reference_t&lt;R&gt;, CharT&gt; &amp;&amp;
                 same_as&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;R&gt;&gt;, T&gt;
      typename FormatContext::iterator
        format(R&amp;&amp; r, FormatContext&amp; ctx) const;
  };
}</pre></div> <h4 id="Class_template_range_default_formatter"> Class template <i><code>__range_default_formatter</code></i>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;ranges::input_range R, class CharT&gt;
  struct __range_default_formatter&lt;range_format::sequence, R, CharT&gt; {
  private:
    using __maybe_const_r = __fmt_maybe_const&lt;R, CharT&gt;;
    range_formatter&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;__maybe_const_r&gt;&gt;,
                    CharT&gt; underlying_;       // exposition only
 
  public:
    constexpr void set_separator(basic_string_view&lt;CharT&gt; sep);
    constexpr void set_brackets(basic_string_view&lt;CharT&gt; opening,
                                basic_string_view&lt;CharT&gt; closing);
 
    template&lt;class ParseContext&gt;
      constexpr typename ParseContext::iterator
        parse(ParseContext&amp; ctx);
 
    template&lt;class FormatContext&gt;
      typename FormatContext::iterator
        format(__maybe_const_r&amp; elems, FormatContext&amp; ctx) const;
  };
}</pre></div> <h4 id="Specialization_of_range_default_formatter_for_maps"> Specialization of <i><code>__range_default_formatter</code></i> for maps</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;ranges::input_range R, class CharT&gt;
  struct __range_default_formatter&lt;range_format::map, R, CharT&gt; {
  private:
    using __maybe_const_map = __fmt_maybe_const&lt;R, CharT&gt;;          // exposition only
    using __element_type =                                          // exposition only
      remove_cvref_t&lt;ranges::range_reference_t&lt;__maybe_const_map&gt;&gt;;
    range_formatter&lt;__element_type, CharT&gt; underlying_;             // exposition only
  public:
    constexpr __range_default_formatter();
 
    template&lt;class ParseContext&gt;
      constexpr typename ParseContext::iterator
        parse(ParseContext&amp; ctx);
 
    template&lt;class FormatContext&gt;
      typename FormatContext::iterator
        format(__maybe_const_map&amp; r, FormatContext&amp; ctx) const;
  };
}</pre></div> <h4 id="Specialization_of_range_default_formatter_for_sets"> Specialization of <i><code>__range_default_formatter</code></i> for sets</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;ranges::input_range R, class CharT&gt;
  struct __range_default_formatter&lt;range_format::set, R, CharT&gt; {
  private:
    using __maybe_const_set = __fmt_maybe_const&lt;R, CharT&gt;;          // exposition only
    range_formatter&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;__maybe_const_set&gt;&gt;,
                    CharT&gt; underlying_;                             // exposition only
  public:
    constexpr __range_default_formatter();
 
    template&lt;class ParseContext&gt;
      constexpr typename ParseContext::iterator
        parse(ParseContext&amp; ctx);
 
    template&lt;class FormatContext&gt;
      typename FormatContext::iterator
        format(__maybe_const_set&amp; r, FormatContext&amp; ctx) const;
  };
}</pre></div> <h4 id="Specialization_of_range_default_formatter_for_strings"> Specialization of <i><code>__range_default_formatter</code></i> for strings</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;range_format K, ranges::input_range R, class CharT&gt;
    requires (K == range_format::string || K == range_format::debug_string)
  struct __range_default_formatter&lt;K, R, CharT&gt; {
  private:
    formatter&lt;basic_string&lt;CharT&gt;, CharT&gt; underlying_;              // exposition only
 
  public:
    template&lt;class ParseContext&gt;
      constexpr typename ParseContext::iterator
        parse(ParseContext&amp; ctx);
 
    template&lt;class FormatContext&gt;
      typename FormatContext::iterator
        format(/* see description */&amp; str, FormatContext&amp; ctx) const;
  };
}</pre></div> <h4 id="Class_template_std::basic_format_arg"> Class template <code><a href="../utility/format/basic_format_arg.html" title="cpp/utility/format/basic format arg">std::basic_format_arg</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Context&gt;
  class basic_format_arg {
  public:
    class handle;
 
  private:
    using char_type = typename Context::char_type;                     // exposition only
 
    variant&lt;monostate, bool, char_type,
            int, unsigned int, long long int, unsigned long long int,
            float, double, long double,
            const char_type*, basic_string_view&lt;char_type&gt;,
            const void*, handle&gt; value;                                // exposition only
 
    template&lt;class T&gt; explicit basic_format_arg(T&amp;&amp; v) noexcept;       // exposition only
    explicit basic_format_arg(float n) noexcept;                       // exposition only
    explicit basic_format_arg(double n) noexcept;                      // exposition only
    explicit basic_format_arg(long double n) noexcept;                 // exposition only
    explicit basic_format_arg(const char_type* s);                     // exposition only
 
    template&lt;class traits&gt;
      explicit basic_format_arg(
        basic_string_view&lt;char_type, traits&gt; s) noexcept;              // exposition only
 
    template&lt;class traits, class Allocator&gt;
      explicit basic_format_arg(
        const basic_string&lt;char_type, traits, Allocator&gt;&amp; s) noexcept; // exposition only
 
    explicit basic_format_arg(nullptr_t) noexcept;                     // exposition only
 
    template&lt;class T&gt;
      explicit basic_format_arg(T* p) noexcept;                        // exposition only
 
  public:
    basic_format_arg() noexcept;
 
    explicit operator bool() const noexcept;
 
    template&lt;class Visitor&gt;
      decltype(auto) visit(this basic_format_arg arg, Visitor&amp;&amp; vis);
    template&lt;class R, class Visitor&gt;
      R visit(this basic_format_arg arg, Visitor&amp;&amp; vis);
  };
}</pre></div> <h4 id="Class_std::basic_format_arg::handle"> Class <code>std::basic_format_arg::handle</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Context&gt;
  class basic_format_arg&lt;Context&gt;::handle {
    const void* ptr_;                                           // exposition only
    void (*format_)(basic_format_parse_context&lt;char_type&gt;&amp;,
                    Context&amp;, const void*);                     // exposition only
 
    template&lt;class T&gt; explicit handle(T&amp;&amp; val) noexcept;        // exposition only
 
    friend class basic_format_arg&lt;Context&gt;;                     // exposition only
 
  public:
    void format(basic_format_parse_context&lt;char_type&gt;&amp;, Context&amp; ctx) const;
  };
}</pre></div> <h4 id="Class_template_format_arg_store"> Class template <i><code>__format_arg_store</code></i>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Context, class... Args&gt;
  class __format_arg_store {                                    // exposition only
    array&lt;basic_format_arg&lt;Context&gt;, sizeof...(Args)&gt; args;     // exposition only
  };
}</pre></div> <h4 id="Class_template_std::basic_format_args"> Class template <code><a href="../utility/format/basic_format_args.html" title="cpp/utility/format/basic format args">std::basic_format_args</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Context&gt;
  class basic_format_args {
    size_t size_;                               // exposition only
    const basic_format_arg&lt;Context&gt;* data_;     // exposition only
 
  public:
    basic_format_args() noexcept;
 
    template&lt;class... Args&gt;
      basic_format_args(const __format_arg_store&lt;Context, Args...&gt;&amp; store) noexcept;
 
    basic_format_arg&lt;Context&gt; get(size_t i) const noexcept;
  };
}</pre></div> <h4 id="Tuple_formatter"> Tuple formatter</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class CharT, formattable&lt;CharT&gt;... Ts&gt;
  struct formatter&lt;__pair_or_tuple&lt;Ts...&gt;, CharT&gt; {
  private:
    tuple&lt;formatter&lt;remove_cvref_t&lt;Ts&gt;, CharT&gt;...&gt; underlying_;     // exposition only
    basic_string_view&lt;CharT&gt; separator_ =                           // exposition only
      __STATICALLY_WIDEN&lt;CharT&gt;(", ");
    basic_string_view&lt;CharT&gt; opening_bracket_ =                     // exposition only
      __STATICALLY_WIDEN&lt;CharT&gt;("(");
    basic_string_view&lt;CharT&gt; closing_bracket_ =                     // exposition only
      __STATICALLY_WIDEN&lt;CharT&gt;(")");
 
  public:
    constexpr void set_separator(basic_string_view&lt;CharT&gt; sep);
    constexpr void set_brackets(basic_string_view&lt;CharT&gt; opening,
                                basic_string_view&lt;CharT&gt; closing);
 
    template&lt;class ParseContext&gt;
      constexpr typename ParseContext::iterator
        parse(ParseContext&amp; ctx);
 
    template&lt;class FormatContext&gt;
      typename FormatContext::iterator
        format(/* see description */&amp; elems, FormatContext&amp; ctx) const;
  };
}</pre></div> <h4 id="Class_std::format_error"> Class <code><a href="../utility/format/format_error.html" title="cpp/utility/format/format error">std::format_error</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  class format_error : public runtime_error {
  public:
    explicit format_error(const string&amp; what_arg);
    explicit format_error(const char* what_arg);
  };
}</pre></div>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/header/format" class="_attribution-link">https://en.cppreference.com/w/cpp/header/format</a>
  </p>
</div>
