    <h1 id="firstHeading" class="firstHeading">std::coroutine_handle, std::noop_coroutine_handle</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/coroutine.html" title="cpp/header/coroutine">&lt;coroutine&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class Promise = void &gt;
struct coroutine_handle;</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt;&gt;
struct coroutine_handle&lt;void&gt;;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt;&gt;
struct coroutine_handle&lt;std::noop_coroutine_promise&gt;;</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">using noop_coroutine_handle =
    std::coroutine_handle&lt;std::noop_coroutine_promise&gt;;</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  </table> <p>The class template <code>coroutine_handle</code> can be used to refer to a suspended or executing coroutine. Every specialization of <code>coroutine_handle</code> is a <a href="../named_req/literaltype.html" title="cpp/named req/LiteralType">LiteralType</a>.</p>
<div class="t-li1">
<span class="t-li">1)</span> Primary template, can be created from the promise object of type <code>Promise</code>.</div> <div class="t-li1">
<span class="t-li">2)</span> Specialization <code>std::coroutine_handle&lt;void&gt;</code> erases the promise type. It is convertible from other specializations.</div> <div class="t-li1">
<span class="t-li">3)</span> Specialization <code>std<span class="sy4">::</span><span class="me2">coroutine_handle</span><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/coroutine/noop_coroutine_promise"><span class="kw3246">std::<span class="me2">noop_coroutine_promise</span></span></a><span class="sy1">&gt;</span></code> refers to no-op coroutines. It cannot be created from a promise object.</div> <p>On typical implementations, every specialization of <code>std::coroutine_handle</code> is <a href="../named_req/triviallycopyable.html" title="cpp/named req/TriviallyCopyable">TriviallyCopyable</a>.</p>
<p>The behavior of a program that adds specializations for <code>std::coroutine_handle</code> is undefined.</p>
<h3 id="Data_members"> Data members</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member name </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code><i>ptr</i></code> <span class="t-mark">(private)</span> </td> <td> A pointer <code>void*</code> to the coroutine state.<br><span class="t-mark t-mark-expos">(<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">exposition-only member object*</span>)</span> </td>
</tr> </table> <h3 id="Member_functions"> Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/coroutine_handle.html" title="cpp/coroutine/coroutine handle/coroutine handle"> <span class="t-lines"><span>(constructor)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> constructs a <code>coroutine_handle</code> object <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/operator=.html" title="cpp/coroutine/coroutine handle/operator="> <span class="t-lines"><span>operator=</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> assigns the <code>coroutine_handle</code> object <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Conversion">  Conversion </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/operator_coroutine_handle_void.html" title="cpp/coroutine/coroutine handle/operator coroutine handle void"> <span class="t-lines"><span>operator coroutine_handle&lt;&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains a type-erased <code>coroutine_handle</code> <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Observers">  Observers </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/done.html" title="cpp/coroutine/coroutine handle/done"> <span class="t-lines"><span>done</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> checks if the coroutine has completed <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/operator_bool.html" title="cpp/coroutine/coroutine handle/operator bool"> <span class="t-lines"><span>operator bool</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> checks if the handle represents a coroutine <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Control">  Control </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/resume.html" title="cpp/coroutine/coroutine handle/resume"> <span class="t-lines"><span>operator()</span><span>resume</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> resumes execution of the coroutine <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/destroy.html" title="cpp/coroutine/coroutine handle/destroy"> <span class="t-lines"><span>destroy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> destroys a coroutine <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Promise_Access">  Promise Access </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/promise.html" title="cpp/coroutine/coroutine handle/promise"> <span class="t-lines"><span>promise</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> access the promise of a coroutine <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/from_promise.html" title="cpp/coroutine/coroutine handle/from promise"> <span class="t-lines"><span>from_promise</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">[static]</span> <span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a <code>coroutine_handle</code> from the promise object of a coroutine <br> <span class="t-mark">(public static member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Export.2FImport">  Export/Import </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/address.html" title="cpp/coroutine/coroutine handle/address"> <span class="t-lines"><span>address</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> exports the underlying address, i.e. the pointer backing the coroutine <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/from_address.html" title="cpp/coroutine/coroutine handle/from address"> <span class="t-lines"><span>from_address</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">[static]</span> <span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> imports a coroutine from a pointer <br> <span class="t-mark">(public static member function)</span>  </td>
</tr> </table> <h3 id="Non-member_functions"> Non-member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/operator_cmp.html" title="cpp/coroutine/coroutine handle/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares two <code>coroutine_handle</code> objects <br> <span class="t-mark">(function)</span>  </td>
</tr> </table> <h3 id="Helper_classes"> Helper classes</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="coroutine_handle/hash.html" title="cpp/coroutine/coroutine handle/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::coroutine_handle&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> hash support for <strong class="selflink"><code>std::coroutine_handle</code></strong> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> </table> <h3 id="Notes"> Notes</h3> <p>A <code>coroutine_handle</code> may be dangling, in which case the <code>coroutine_handle</code> must be used carefully in order to avoid undefined behavior.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;coroutine&gt;
#include &lt;iostream&gt;
#include &lt;optional&gt;
 
template&lt;std::movable T&gt;
class Generator
{
public:
    struct promise_type
    {
        Generator&lt;T&gt; get_return_object()
        {
            return Generator{Handle::from_promise(*this)};
        }
        static std::suspend_always initial_suspend() noexcept
        {
            return {};
        }
        static std::suspend_always final_suspend() noexcept
        {
            return {};
        }
        std::suspend_always yield_value(T value) noexcept
        {
            current_value = std::move(value);
            return {};
        }
        // Disallow co_await in generator coroutines.
        void await_transform() = delete;
        [[noreturn]]
        static void unhandled_exception() { throw; }
 
        std::optional&lt;T&gt; current_value;
    };
 
    using Handle = std::coroutine_handle&lt;promise_type&gt;;
 
    explicit Generator(const Handle coroutine) :
        m_coroutine{coroutine}
    {}
 
    Generator() = default;
    ~Generator()
    {
        if (m_coroutine)
            m_coroutine.destroy();
    }
 
    Generator(const Generator&amp;) = delete;
    Generator&amp; operator=(const Generator&amp;) = delete;
 
    Generator(Generator&amp;&amp; other) noexcept :
        m_coroutine{other.m_coroutine}
    {
        other.m_coroutine = {};
    }
    Generator&amp; operator=(Generator&amp;&amp; other) noexcept
    {
        if (this != &amp;other)
        {
            if (m_coroutine)
                m_coroutine.destroy();
            m_coroutine = other.m_coroutine;
            other.m_coroutine = {};
        }
        return *this;
    }
 
    // Range-based for loop support.
    class Iter
    {
    public:
        void operator++()
        {
            m_coroutine.resume();
        }
        const T&amp; operator*() const
        {
            return *m_coroutine.promise().current_value;
        }
        bool operator==(std::default_sentinel_t) const
        {
            return !m_coroutine || m_coroutine.done();
        }
 
        explicit Iter(const Handle coroutine) :
            m_coroutine{coroutine}
        {}
 
    private:
        Handle m_coroutine;
    };
 
    Iter begin()
    {
        if (m_coroutine)
            m_coroutine.resume();
        return Iter{m_coroutine};
    }
 
    std::default_sentinel_t end() { return {}; }
 
private:
    Handle m_coroutine;
};
 
template&lt;std::integral T&gt;
Generator&lt;T&gt; range(T first, const T last)
{
    while (first &lt; last)
        co_yield first++;
}
 
int main()
{
    for (const char i : range(65, 91))
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue3460">LWG 3460</a> </td> <td>C++20 </td> <td>the public base class of <code>coroutine_handle</code> could leave it in an undesired state </td> <td>inheritance removed </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="generator.html" title="cpp/coroutine/generator"> <span class="t-lines"><span>generator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> A <a href="../ranges/view.html" title="cpp/ranges/view"><code>view</code></a> that represents synchronous <a href="../language/coroutines.html" title="cpp/language/coroutines">coroutine</a> generator <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle" class="_attribution-link">https://en.cppreference.com/w/cpp/coroutine/coroutine_handle</a>
  </p>
</div>
