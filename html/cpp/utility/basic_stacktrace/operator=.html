    <h1 id="firstHeading" class="firstHeading">std::basic_stacktrace&lt;Allocator&gt;::operator=</h1>            <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">basic_stacktrace&amp; operator=( const basic_stacktrace&amp; other );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">basic_stacktrace&amp; operator=( basic_stacktrace&amp;&amp; other )
    noexcept(/* see below */);</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr>  </table> <p>Replaces the contents of the <code>basic_stacktrace</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span> Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.</div> <div class="t-li1">
 If <code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_copy_assignment</span><span class="sy4">::</span><span class="me2">value</span></code> is <code>true</code>, the allocator of <code>*this</code> is replaced by a copy of that of <code>other</code>. If the allocator of <code>*this</code> after assignment would compare unequal to its old value, the old allocator is used to deallocate the memory, then the new allocator is used to allocate it before copying the entries. Otherwise, the memory owned by <code>*this</code> may be reused when possible. </div> <div class="t-li1">
<span class="t-li">2)</span> Move assignment operator. Replaces the contents with those of <code>other</code> using move semantics (i.e. the data in <code>other</code> is moved from <code>other</code> into <code>*this</code>). <code>other</code> is in a valid but unspecified state afterwards.</div> <div class="t-li1">
 If <code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_move_assignment</span><span class="sy4">::</span><span class="me2">value</span></code> is <code>true</code>, the allocator of <code>*this</code> is replaced by a copy of that of <code>other</code>. If it is <code>false</code> and the allocators of <code>*this</code> and <code>other</code> do not compare equal, <code>*this</code> cannot take ownership of the memory owned by <code>other</code> and must assign each entries individually, allocating additional memory using its own allocator as needed.</div> <p>In any case, the stacktrace entries originally belong to <code>*this</code> may be either destroyed or replaced by element-wise assignment.</p>
<p><code>*this</code> may be set to empty on allocation failure if the implementation strengthens the exception specification.</p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> other </td> <td> - </td> <td> another <code>basic_stacktrace</code> to use as source </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <p><code>*this</code></p>
<h3 id="Complexity"> Complexity</h3> <div class="t-li1">
<span class="t-li">1)</span> Linear in the size of <code>*this</code> and <code>other</code>.</div> <div class="t-li1">
<span class="t-li">2)</span> Linear in the size of <code>*this</code> unless the allocators do not compare equal and do not propagate, in which case linear in the size of <code>*this</code> and <code>other</code>.</div> <h3 id="Exceptions"> Exceptions</h3> <div class="t-li1">
<span class="t-li">1)</span> May throw implementation-defined exceptions.</div> <div class="t-li1">
<span class="t-li">2)</span> <div class="t-noexcept-full">
<a href="../../language/noexcept_spec.html" title="cpp/language/noexcept spec"><code>noexcept</code></a> specification: <div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">noexcept</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>Allocator<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_move_assignment</span><span class="sy4">::</span><span class="me2">value</span><br> <span class="sy3">||</span> <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>Allocator<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">is_always_equal</span><span class="sy4">::</span><span class="me2">value</span><span class="br0">)</span></code></span></div>
</div>
</div> <h3 id="Notes"> Notes</h3> <p>After container move assignment (overload <span class="t-v">(2)</span>), unless element-wise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the end iterator) to <code>other</code> remain valid, but refer to elements that are now in <code>*this</code>. The current standard makes this guarantee via the blanket statement in <a rel="nofollow" class="external text" href="https://eel.is/c++draft/container.reqmts#67">[container.reqmts]/67</a>, and a more direct guarantee is under consideration via <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2321">LWG issue 2321</a>.</p>
<h3 id="Example"> Example</h3>  <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="basic_stacktrace.html" title="cpp/utility/basic stacktrace/basic stacktrace"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> creates a new <code>basic_stacktrace</code> <br> <span class="t-mark">(public member function)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/utility/basic_stacktrace/operator%3D" class="_attribution-link">https://en.cppreference.com/w/cpp/utility/basic_stacktrace/operator%3D</a>
  </p>
</div>
