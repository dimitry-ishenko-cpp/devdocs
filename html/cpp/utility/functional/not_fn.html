    <h1 id="firstHeading" class="firstHeading">std::not_fn</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/functional.html" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">template&lt; class F &gt;
/* unspecified */ not_fn( F&amp;&amp; f );</pre></td> <td> (1)</td> <td>
<span class="t-mark-rev t-since-cxx17">(since C++17)</span> <br><span class="t-mark-rev t-since-cxx20">(constexpr since C++20)</span>
</td> </tr> <tr class="t-dcl t-since-cxx26"> <td><pre data-language="cpp">template&lt; auto ConstFn &gt;
constexpr /* unspecified */ not_fn() noexcept;</pre></td> <td> (2)</td> <td><span class="t-mark-rev t-since-cxx26">(since C++26)</span></td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> Creates a forwarding call wrapper that returns the negation of the callable object it holds.</div> <div class="t-li1">
<span class="t-li">2)</span> Creates a forwarding call wrapper that returns the negation of the statically determined callable target. The program is ill-formed if <code>ConstFn</code> is a null pointer or null pointer-to-member.</div>  <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> f </td> <td> - </td> <td> the object from which the <a href="../../named_req/callable.html" title="cpp/named req/Callable">Callable</a> object held by the wrapper is constructed </td>
</tr> <tr class="t-par-hitem"> <td colspan="3"> Type requirements </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span></code> must meet the requirements of <a href="../../named_req/callable.html" title="cpp/named req/Callable">Callable</a> and <a href="../../named_req/moveconstructible.html" title="cpp/named req/MoveConstructible">MoveConstructible</a>. </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">std::<span class="me2">is_constructible_v</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span>, F<span class="sy1">&gt;</span></code> is required to be <code>true</code>. </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1)</span> A function object of unspecified type <code>T</code>. It has the following members. <div class="t-member"> <h2 id="std::not_fn_return_type"> std::not_fn <i>return type</i>
</h2> <h4 id="Member_objects"> Member objects</h4> <p>The return type of <code>std::not_fn</code> holds a member object of type <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span>.</p>
<h4 id="Constructors"> Constructors</h4> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">explicit T( F&amp;&amp; f );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> <br><span class="t-mark-rev t-since-cxx20">(constexpr since C++20)</span><br><span class="t-mark t-mark-expos">(<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">exposition only*</span>)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">T( T&amp;&amp; f ) = default;
T( const T&amp; f ) = default;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> The constructor direct-non-list-initializes the member object (of type <code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span></code>) from <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span><span class="br0">(</span>f<span class="br0">)</span></code>. Throws any exception thrown by the constructor selected.</div> <div class="t-li1">
<span class="t-li">2)</span> Because <code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span></code> is required to be <a href="../../named_req/moveconstructible.html" title="cpp/named req/MoveConstructible">MoveConstructible</a>, the returned call wrapper is always <a href="../../named_req/moveconstructible.html" title="cpp/named req/MoveConstructible">MoveConstructible</a>, and is <a href="../../named_req/copyconstructible.html" title="cpp/named req/CopyConstructible">CopyConstructible</a> if <code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span></code> is <a href="../../named_req/copyconstructible.html" title="cpp/named req/CopyConstructible">CopyConstructible</a>. <table class="t-rev-begin"> <tr class="t-rev">
<td> <p>The explicitly defaulted definitions make the return type not assignable.</p>
</td> <td></td>
</tr> <tr class="t-rev">
<td> <p>It is unspecified whether these constructors are explicitly defaulted and whether the return type is assignable.</p>
</td> <td></td>
</tr> </table>
</div> <h4 id="Member_function_operator.28.29"> Member function operator<span class="br0">(</span><span class="br0">)</span>
</h4> <table class="t-dcl-begin">  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td><pre data-language="cpp">template&lt; class... Args &gt;
auto operator()( Args&amp;&amp;... args ) &amp;
-&gt; decltype(!std::declval&lt;
    std::invoke_result_t&lt;std::decay_t&lt;F&gt;&amp;, Args...&gt;&gt;());
template&lt; class... Args &gt;
auto operator()( Args&amp;&amp;... args ) const&amp;
-&gt; decltype(!std::declval&lt;
    std::invoke_result_t&lt;std::decay_t&lt;F&gt; const&amp;, Args...&gt;&gt;());</pre></td>  <td>
<span class="t-mark-rev t-since-cxx17">(since C++17)</span> <br><span class="t-mark-rev t-until-cxx20">(until C++20)</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class... Args &gt;
constexpr auto operator()( Args&amp;&amp;... args ) &amp;
    noexcept(/* see below */)
-&gt; decltype(!std::declval&lt;
    std::invoke_result_t&lt;std::decay_t&lt;F&gt;&amp;, Args...&gt;&gt;());
template&lt; class... Args &gt;
constexpr auto operator()( Args&amp;&amp;... args ) const&amp;
    noexcept(/* see below */)
-&gt; decltype(!std::declval&lt;
    std::invoke_result_t&lt;std::decay_t&lt;F&gt; const&amp;, Args...&gt;&gt;());</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>   <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td><pre data-language="cpp">template&lt; class... Args &gt;
auto operator()( Args&amp;&amp;... args ) &amp;&amp;
-&gt; decltype(!std::declval&lt;
    std::invoke_result_t&lt;std::decay_t&lt;F&gt;, Args...&gt;&gt;());
template&lt; class... Args &gt;
auto operator()( Args&amp;&amp;... args ) const&amp;&amp;
-&gt; decltype(!std::declval&lt;
    std::invoke_result_t&lt;std::decay_t&lt;F&gt; const, Args...&gt;&gt;());</pre></td>  <td>
<span class="t-mark-rev t-since-cxx17">(since C++17)</span> <br><span class="t-mark-rev t-until-cxx20">(until C++20)</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class... Args &gt;
constexpr auto operator()( Args&amp;&amp;... args ) &amp;&amp;
    noexcept(/* see below */)
-&gt; decltype(!std::declval&lt;
    std::invoke_result_t&lt;std::decay_t&lt;F&gt;, Args...&gt;&gt;());
template&lt; class... Args &gt;
constexpr auto operator()( Args&amp;&amp;... args ) const&amp;&amp;
    noexcept(/* see below */)
-&gt; decltype(!std::declval&lt;
    std::invoke_result_t&lt;std::decay_t&lt;F&gt; const, Args...&gt;&gt;());</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>   </table> <p>Let <code>fd</code> be the member object of type <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17 t-until-cxx20">
<td> <span class="t-li">1)</span> Equivalent to <code><span class="kw1">return</span> <span class="sy3">!</span><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1062">std::<span class="me2">invoke</span></span></a><span class="br0">(</span>fd, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">;</span></code> <span class="t-li">2)</span> Equivalent to <code><span class="kw1">return</span> <span class="sy3">!</span><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1062">std::<span class="me2">invoke</span></span></a><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>fd<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">;</span></code> <p>While invoking the result, if the substitution into the return type of the originally selected operator<span class="br0">(</span><span class="br0">)</span> overload fails, <a href="../../language/sfinae.html" title="cpp/language/sfinae">another overload may be selected</a>.</p>
</td> <td>
<span class="t-mark-rev t-since-cxx17">(since C++17)</span><br><span class="t-mark-rev t-until-cxx20">(until C++20)</span>
</td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <span class="t-li">1)</span> <a href="../../language/expressions.html#Expression-equivalence" title="cpp/language/expressions">Expression-equivalent</a> to <code><span class="sy3">!</span><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1062">std::<span class="me2">invoke</span></span></a><span class="br0">(</span>fd, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span></code> <span class="t-li">2)</span> <a href="../../language/expressions.html#Expression-equivalence" title="cpp/language/expressions">Expression-equivalent</a> to <code><span class="sy3">!</span><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1062">std::<span class="me2">invoke</span></span></a><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>fd<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span></code> <p>While invoking the result, if the substitution into the return type of the originally selected operator<span class="br0">(</span><span class="br0">)</span> overload fails, the invocation is ill-formed, which can also be a <a href="../../language/sfinae.html" title="cpp/language/sfinae">substitution failure</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </div>
</div> <div class="t-li1">
<span class="t-li">2)</span> A value of the following type. <div class="t-member"> <h2 id="std::not_fn_stateless_return_type"> std::not_fn <i>stateless return type</i>
</h2> <p>The return type is a <a href="../../named_req/copyconstructible.html" title="cpp/named req/CopyConstructible">CopyConstructible</a> stateless class. It is unspecified whether the return type is assignable.</p>
<h4 id="Member_function_operator.28.29_2"> Member function operator<span class="br0">(</span><span class="br0">)</span>
</h4> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">template&lt; class... Args &gt;
constexpr auto operator()( Args&amp;&amp;... args ) const
    noexcept(/* see below */)
-&gt; decltype(
    !std::declval&lt;std::invoke_result_t&lt;decltype((ConstFn)), Args...&gt;&gt;());</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(since C++26)</span> </td> </tr>  </table> <p><a href="../../language/expressions.html#Expression-equivalence" title="cpp/language/expressions">Expression-equivalent</a> to <code><span class="sy3">!</span><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1062">std::<span class="me2">invoke</span></span></a><span class="br0">(</span>ConstFn, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span></code>.</p>
</div>
</div> <h3 id="Exceptions"> Exceptions</h3> <div class="t-li1">
<span class="t-li">1)</span> Throws no exceptions, unless the construction of <code>fd</code> throws.</div> <h3 id="Possible_implementation"> Possible implementation</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">(1) not_fn</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">namespace detail
{
    template&lt;class V, class F, class... Args&gt;
    constexpr bool negate_invocable_impl = false;
    template&lt;class F, class... Args&gt;
    constexpr bool negate_invocable_impl&lt;std::void_t&lt;decltype(
        !std::invoke(std::declval&lt;F&gt;(), std::declval&lt;Args&gt;()...))&gt;, F, Args...&gt; = true;
 
    template&lt;class F, class... Args&gt;
    constexpr bool negate_invocable_v = negate_invocable_impl&lt;void, F, Args...&gt;;
 
    template&lt;class F&gt;
    struct not_fn_t
    {
        F f;
 
        template&lt;class... Args,
            std::enable_if_t&lt;negate_invocable_v&lt;F&amp;, Args...&gt;, int&gt; = 0&gt;
        constexpr decltype(auto) operator()(Args&amp;&amp;... args) &amp;
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
        {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }
 
        template&lt;class... Args,
            std::enable_if_t&lt;negate_invocable_v&lt;const F&amp;, Args...&gt;, int&gt; = 0&gt;
        constexpr decltype(auto) operator()(Args&amp;&amp;... args) const&amp;
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
        {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }
 
        template&lt;class... Args,
            std::enable_if_t&lt;negate_invocable_v&lt;F, Args...&gt;, int&gt; = 0&gt;
        constexpr decltype(auto) operator()(Args&amp;&amp;... args) &amp;&amp;
            noexcept(noexcept(!std::invoke(std::move(f), std::forward&lt;Args&gt;(args)...)))
        {
            return !std::invoke(std::move(f), std::forward&lt;Args&gt;(args)...);
        }
 
        template&lt;class... Args,
            std::enable_if_t&lt;negate_invocable_v&lt;const F, Args...&gt;, int&gt; = 0&gt;
        constexpr decltype(auto) operator()(Args&amp;&amp;... args) const&amp;&amp;
            noexcept(noexcept(!std::invoke(std::move(f), std::forward&lt;Args&gt;(args)...)))
        {
            return !std::invoke(std::move(f), std::forward&lt;Args&gt;(args)...);
        }
 
        // Deleted overloads are needed since C++20
        // for preventing a non-equivalent but well-formed overload to be selected.
 
        template&lt;class... Args,
            std::enable_if_t&lt;!negate_invocable_v&lt;F&amp;, Args...&gt;, int&gt; = 0&gt;
        void operator()(Args&amp;&amp;...) &amp; = delete;
 
        template&lt;class... Args,
            std::enable_if_t&lt;!negate_invocable_v&lt;const F&amp;, Args...&gt;, int&gt; = 0&gt;
        void operator()(Args&amp;&amp;...) const&amp; = delete;
 
        template&lt;class... Args,
            std::enable_if_t&lt;!negate_invocable_v&lt;F, Args...&gt;, int&gt; = 0&gt;
        void operator()(Args&amp;&amp;...) &amp;&amp; = delete;
 
        template&lt;class... Args,
            std::enable_if_t&lt;!negate_invocable_v&lt;const F, Args...&gt;, int&gt; = 0&gt;
        void operator()(Args&amp;&amp;...) const&amp;&amp; = delete;
    };
}
 
template&lt;class F&gt;
constexpr detail::not_fn_t&lt;std::decay_t&lt;F&gt;&gt; not_fn(F&amp;&amp; f)
{
    return {std::forward&lt;F&gt;(f)};
}</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_2">(2) not_fn</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">namespace detail
{
    template&lt;auto ConstFn&gt;
    struct stateless_not_fn
    {
        template&lt;class... Args&gt;
        constexpr auto operator()(Args&amp;&amp;... args) const
            noexcept(noexcept(!std::invoke(ConstFn, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(ConstFn, std::forward&lt;Args&gt;(args)...))
        {
            return !std::invoke(ConstFn, std::forward&lt;Args&gt;(args)...);
        }
    };
}
 
template&lt;auto ConstFn&gt;
constexpr detail::stateless_not_fn&lt;ConstFn&gt; not_fn() noexcept
{
    if constexpr (std::is_pointer_v&lt;decltype(ConstFn)&gt; ||
                  std::is_member_pointer_v&lt;decltype(ConstFn)&gt;)
        static_assert(ConstFn != nullptr);
 
    return {};
}</pre></div> </td>
</tr>
</table> <h3 id="Notes"> Notes</h3> <p><code>std::not_fn</code> is intended to replace the C++03-era negators <code><a href="not1.html" title="cpp/utility/functional/not1">std::not1</a></code> and <code><a href="not2.html" title="cpp/utility/functional/not2">std::not2</a></code>.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../feature_test.html" title="cpp/utility/feature test">Feature-test</a> macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Feature </th>
</tr> <tr> <td rowspan="2"><a href="../../feature_test.html#cpp_lib_not_fn" title="cpp/feature test"><code>__cpp_lib_not_fn</code></a></td> <td><span class="nu0">201603L</span></td> <td><span class="t-mark">(C++17)</span></td> <td>
<code>std::not_fn()</code>, <span class="t-v">(<a href="#Version_1">1</a>)</span> </td>
</tr> <tr> <td><span class="nu0">202306L</span></td> <td><span class="t-mark">(C++26)</span></td> <td>Allow passing callable objects as non-type template arguments to <code>std::not_fn</code>, <span class="t-v">(<a href="#Version_2">2</a>)</span> </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cassert&gt;
#include &lt;functional&gt;
 
bool is_same(int a, int b) noexcept
{
    return a == b;
}
 
struct S
{
    int val;
    bool is_same(int arg) const noexcept { return val == arg; }
};
 
int main()
{
    // Using with a free function:
    auto is_differ = std::not_fn(is_same);
    assert(is_differ(8, 8) == false); // equivalent to: !is_same(8, 8) == false
    assert(is_differ(6, 9) == true); // equivalent to: !is_same(8, 0) == true
 
    // Using with a member function:
    auto member_differ = std::not_fn(&amp;S::is_same);
    assert(member_differ(S{3}, 3) == false); //: S tmp{6}; !tmp.is_same(6) == false
 
    // Noexcept-specification is preserved:
    static_assert(noexcept(is_differ) == noexcept(is_same));
    static_assert(noexcept(member_differ) == noexcept(&amp;S::is_same));
 
    // Using with a function object:
    auto same = [](int a, int b) { return a == b; };
    auto differ = std::not_fn(same);
    assert(differ(1, 2) == true); //: !same(1, 2) == true
    assert(differ(2, 2) == false); //: !same(2, 2) == false
 
#if __cpp_lib_not_fn &gt;= 202306L
    auto is_differ_cpp26 = std::not_fn&lt;is_same&gt;();
    assert(is_differ_cpp26(8, 8) == false);
    assert(is_differ_cpp26(6, 9) == true);
 
    auto member_differ_cpp26 = std::not_fn&lt;&amp;S::is_same&gt;();
    assert(member_differ_cpp26(S{3}, 3) == false);
 
    auto differ_cpp26 = std::not_fn&lt;same&gt;();
    static_assert(differ_cpp26(1, 2) == true);
    static_assert(differ_cpp26(2, 2) == false);
#endif
}</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="not1.html" title="cpp/utility/functional/not1"> <span class="t-lines"><span>not1</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> constructs custom <code><a href="unary_negate.html" title="cpp/utility/functional/unary negate">std::unary_negate</a></code> object <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="not2.html" title="cpp/utility/functional/not2"> <span class="t-lines"><span>not2</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> constructs custom <code><a href="binary_negate.html" title="cpp/utility/functional/binary negate">std::binary_negate</a></code> object <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/utility/functional/not_fn" class="_attribution-link">https://en.cppreference.com/w/cpp/utility/functional/not_fn</a>
  </p>
</div>
