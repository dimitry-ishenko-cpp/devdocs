<h1>Synchronizing with Effects
</h1>
<div><p>Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. <em>Effects</em> let you run some code after rendering so that you can synchronize your component with some system outside of React.</p></div> <div class="note">
<h4>You will learn</h4>
<ul> <li>What Effects are</li> <li>How Effects are different from events</li> <li>How to declare an Effect in your component</li> <li>How to skip re-running an Effect unnecessarily</li> <li>Why Effects run twice in development and how to fix them</li> </ul>
</div> <h2 id="what-are-effects-and-how-are-they-different-from-events">What are Effects and how are they different from events? 
</h2> <p>Before getting to Effects, you need to be familiar with two types of logic inside React components:</p> <ul> <li> <p><strong>Rendering code</strong> (introduced in <a href="describing-the-ui.html">Describing the UI</a>) lives at the top level of your component. This is where you take the props and state, transform them, and return the JSX you want to see on the screen. <a href="keeping-components-pure.html">Rendering code must be pure.</a> Like a math formula, it should only <em>calculate</em> the result, but not do anything else.</p> </li> <li> <p><strong>Event handlers</strong> (introduced in <a href="adding-interactivity.html">Adding Interactivity</a>) are nested functions inside your components that <em>do</em> things rather than just calculate them. An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. Event handlers contain <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" target="_blank" rel="nofollow noopener noreferrer">“side effects”</a> (they change the program’s state) caused by a specific user action (for example, a button click or typing).</p> </li> </ul> <p>Sometimes this isn’t enough. Consider a <code dir="ltr">ChatRoom</code> component that must connect to the chat server whenever it’s visible on the screen. Connecting to a server is not a pure calculation (it’s a side effect) so it can’t happen during rendering. However, there is no single particular event like a click that causes <code dir="ltr">ChatRoom</code> to be displayed.</p> <p><strong><em>Effects</em> let you specify side effects that are caused by rendering itself, rather than by a particular event.</strong> Sending a message in the chat is an <em>event</em> because it is directly caused by the user clicking a specific button. However, setting up a server connection is an <em>Effect</em> because it should happen no matter which interaction caused the component to appear. Effects run at the end of a <a href="render-and-commit.html">commit</a> after the screen updates. This is a good time to synchronize the React components with some external system (like network or a third-party library).</p> <div class="note note-green">
<h4>Note</h4>
<div><p>Here and later in this text, capitalized “Effect” refers to the React-specific definition above, i.e. a side effect caused by rendering. To refer to the broader programming concept, we’ll say “side effect”.</p></div>
</div> <h2 id="you-might-not-need-an-effect">You might not need an Effect 
</h2> <p><strong>Don’t rush to add Effects to your components.</strong> Keep in mind that Effects are typically used to “step out” of your React code and synchronize with some <em>external</em> system. This includes browser APIs, third-party widgets, network, and so on. If your Effect only adjusts some state based on other state, <a href="you-might-not-need-an-effect.html">you might not need an Effect.</a></p> <h2 id="how-to-write-an-effect">How to write an Effect 
</h2> <p>To write an Effect, follow these three steps:</p> <ol> <li>
<strong>Declare an Effect.</strong> By default, your Effect will run after every <a href="render-and-commit.html">commit</a>.</li> <li>
<strong>Specify the Effect dependencies.</strong> Most Effects should only re-run <em>when needed</em> rather than after every render. For example, a fade-in animation should only trigger when a component appears. Connecting and disconnecting to a chat room should only happen when the component appears and disappears, or when the chat room changes. You will learn how to control this by specifying <em>dependencies.</em>
</li> <li>
<strong>Add cleanup if needed.</strong> Some Effects need to specify how to stop, undo, or clean up whatever they were doing. For example, “connect” needs “disconnect”, “subscribe” needs “unsubscribe”, and “fetch” needs either “cancel” or “ignore”. You will learn how to do this by returning a <em>cleanup function</em>.</li> </ol> <p>Let’s look at each of these steps in detail.</p> <h3 id="step-1-declare-an-effect">Step 1: Declare an Effect 
</h3> <p>To declare an Effect in your component, import the <a href="../reference/react/useeffect.html"><code dir="ltr">useEffect</code> Hook</a> from React:</p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span></code></pre> <p>Then, call it at the top level of your component and put some code inside your Effect:</p> <pre data-language="jsx"><code><span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Code here will run after *every* render</span>
  <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>&lt;</span><span>div</span> <span>/&gt;</span><span>;</span>
<span>}</span></code></pre> <p>Every time your component renders, React will update the screen <em>and then</em> run the code inside <code dir="ltr">useEffect</code>. In other words, <strong><code dir="ltr">useEffect</code> “delays” a piece of code from running until that render is reflected on the screen.</strong></p> <p>Let’s see how you can use an Effect to synchronize with an external system. Consider a <code dir="ltr">&lt;VideoPlayer&gt;</code> React component. It would be nice to control whether it’s playing or paused by passing an <code dir="ltr">isPlaying</code> prop to it:</p> <pre data-language="jsx"><code><span>&lt;</span><span>VideoPlayer</span> <span>isPlaying</span>=<span>{</span><span>isPlaying</span><span>}</span> <span>/&gt;</span><span>;</span></code></pre> <p>Your custom <code dir="ltr">VideoPlayer</code> component renders the built-in browser <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">&lt;video&gt;</code></a> tag:</p> <pre data-language="jsx"><code><span>function</span> <span>VideoPlayer</span><span>(</span><span>{</span> <span>src</span><span>,</span> <span>isPlaying</span> <span>}</span><span>)</span> <span>{</span>
  <span>// TODO: do something with isPlaying</span>
  <span>return</span> <span>&lt;</span><span>video</span> <span>src</span>=<span>{</span><span>src</span><span>}</span> <span>/&gt;</span><span>;</span>
<span>}</span></code></pre> <p>However, the browser <code dir="ltr">&lt;video&gt;</code> tag does not have an <code dir="ltr">isPlaying</code> prop. The only way to control it is to manually call the <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">play()</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">pause()</code></a> methods on the DOM element. <strong>You need to synchronize the value of <code dir="ltr">isPlaying</code> prop, which tells whether the video <em>should</em> currently be playing, with calls like <code dir="ltr">play()</code> and <code dir="ltr">pause()</code>.</strong></p> <p>We’ll need to first <a href="manipulating-the-dom-with-refs.html">get a ref</a> to the <code dir="ltr">&lt;video&gt;</code> DOM node.</p> <p>You might be tempted to try to call <code dir="ltr">play()</code> or <code dir="ltr">pause()</code> during rendering, but that isn’t correct:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useRef</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>function</span> <span>VideoPlayer</span><span>(</span><span>{</span> <span>src</span><span>,</span> <span>isPlaying</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>ref</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>if</span> <span>(</span><span>isPlaying</span><span>)</span> <span>{</span>
    <span>ref</span>.<span>current</span>.<span>play</span><span>(</span><span>)</span><span>;</span>  <span>// Calling these while rendering isn't allowed.</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>ref</span>.<span>current</span>.<span>pause</span><span>(</span><span>)</span><span>;</span> <span>// Also, this crashes.</span>
  <span>}</span>

  <span>return</span> <span>&lt;</span><span>video</span> <span>ref</span>=<span>{</span><span>ref</span><span>}</span> <span>src</span>=<span>{</span><span>src</span><span>}</span> <span>loop</span> <span>playsInline</span> <span>/&gt;</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>isPlaying</span><span>,</span> <span>setIsPlaying</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setIsPlaying</span><span>(</span>!<span>isPlaying</span><span>)</span><span>}</span><span>&gt;</span>
        <span>{</span><span>isPlaying</span> ? <span>'Pause'</span> : <span>'Play'</span><span>}</span>
      <span>&lt;/</span><span>button</span><span>&gt;</span>
      <span>&lt;</span><span>VideoPlayer</span>
        <span>isPlaying</span>=<span>{</span><span>isPlaying</span><span>}</span>
        <span>src</span>=<span>"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"</span>
      <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>The reason this code isn’t correct is that it tries to do something with the DOM node during rendering. In React, <a href="keeping-components-pure.html">rendering should be a pure calculation</a> of JSX and should not contain side effects like modifying the DOM.</p> <p>Moreover, when <code dir="ltr">VideoPlayer</code> is called for the first time, its DOM does not exist yet! There isn’t a DOM node yet to call <code dir="ltr">play()</code> or <code dir="ltr">pause()</code> on, because React doesn’t know what DOM to create until you return the JSX.</p> <p>The solution here is to <strong>wrap the side effect with <code dir="ltr">useEffect</code> to move it out of the rendering calculation:</strong></p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>useEffect</span><span>,</span> <span>useRef</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>function</span> <span>VideoPlayer</span><span>(</span><span>{</span> <span>src</span><span>,</span> <span>isPlaying</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>ref</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPlaying</span><span>)</span> <span>{</span>
      <span>ref</span>.<span>current</span>.<span>play</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>ref</span>.<span>current</span>.<span>pause</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>

  <span>return</span> <span>&lt;</span><span>video</span> <span>ref</span>=<span>{</span><span>ref</span><span>}</span> <span>src</span>=<span>{</span><span>src</span><span>}</span> <span>loop</span> <span>playsInline</span> <span>/&gt;</span><span>;</span>
<span>}</span></code></pre> <p>By wrapping the DOM update in an Effect, you let React update the screen first. Then your Effect runs.</p> <p>When your <code dir="ltr">VideoPlayer</code> component renders (either the first time or if it re-renders), a few things will happen. First, React will update the screen, ensuring the <code dir="ltr">&lt;video&gt;</code> tag is in the DOM with the right props. Then React will run your Effect. Finally, your Effect will call <code dir="ltr">play()</code> or <code dir="ltr">pause()</code> depending on the value of <code dir="ltr">isPlaying</code>.</p> <p>Press Play/Pause multiple times and see how the video player stays synchronized to the <code dir="ltr">isPlaying</code> value:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useRef</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>function</span> <span>VideoPlayer</span><span>(</span><span>{</span> <span>src</span><span>,</span> <span>isPlaying</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>ref</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPlaying</span><span>)</span> <span>{</span>
      <span>ref</span>.<span>current</span>.<span>play</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>ref</span>.<span>current</span>.<span>pause</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>

  <span>return</span> <span>&lt;</span><span>video</span> <span>ref</span>=<span>{</span><span>ref</span><span>}</span> <span>src</span>=<span>{</span><span>src</span><span>}</span> <span>loop</span> <span>playsInline</span> <span>/&gt;</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>isPlaying</span><span>,</span> <span>setIsPlaying</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setIsPlaying</span><span>(</span>!<span>isPlaying</span><span>)</span><span>}</span><span>&gt;</span>
        <span>{</span><span>isPlaying</span> ? <span>'Pause'</span> : <span>'Play'</span><span>}</span>
      <span>&lt;/</span><span>button</span><span>&gt;</span>
      <span>&lt;</span><span>VideoPlayer</span>
        <span>isPlaying</span>=<span>{</span><span>isPlaying</span><span>}</span>
        <span>src</span>=<span>"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"</span>
      <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>In this example, the “external system” you synchronized to React state was the browser media API. You can use a similar approach to wrap legacy non-React code (like jQuery plugins) into declarative React components.</p> <p>Note that controlling a video player is much more complex in practice. Calling <code dir="ltr">play()</code> may fail, the user might play or pause using the built-in browser controls, and so on. This example is very simplified and incomplete.</p> <div class="note note-orange">
<h4>Pitfall</h4>
<div>
<p>By default, Effects run after <em>every</em> render. This is why code like this will <strong>produce an infinite loop:</strong></p>
<pre data-language="jsx"><code><span>const</span> <span>[</span><span>count</span><span>,</span> <span>setCount</span><span>]</span> = <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>setCount</span><span>(</span><span>count</span> + <span>1</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></code></pre>
<p>Effects run as a <em>result</em> of rendering. Setting state <em>triggers</em> rendering. Setting state immediately in an Effect is like plugging a power outlet into itself. The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on.</p>
<p>Effects should usually synchronize your components with an <em>external</em> system. If there’s no external system and you only want to adjust some state based on other state, <a href="you-might-not-need-an-effect.html">you might not need an Effect.</a></p>
</div>
</div> <h3 id="step-2-specify-the-effect-dependencies">Step 2: Specify the Effect dependencies 
</h3> <p>By default, Effects run after <em>every</em> render. Often, this is <strong>not what you want:</strong></p> <ul> <li>Sometimes, it’s slow. Synchronizing with an external system is not always instant, so you might want to skip doing it unless it’s necessary. For example, you don’t want to reconnect to the chat server on every keystroke.</li> <li>Sometimes, it’s wrong. For example, you don’t want to trigger a component fade-in animation on every keystroke. The animation should only play once when the component appears for the first time.</li> </ul> <p>To demonstrate the issue, here is the previous example with a few <code dir="ltr">console.log</code> calls and a text input that updates the parent component’s state. Notice how typing causes the Effect to re-run:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useRef</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>function</span> <span>VideoPlayer</span><span>(</span><span>{</span> <span>src</span><span>,</span> <span>isPlaying</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>ref</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPlaying</span><span>)</span> <span>{</span>
      <span>console</span>.<span>log</span><span>(</span><span>'Calling video.play()'</span><span>)</span><span>;</span>
      <span>ref</span>.<span>current</span>.<span>play</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>console</span>.<span>log</span><span>(</span><span>'Calling video.pause()'</span><span>)</span><span>;</span>
      <span>ref</span>.<span>current</span>.<span>pause</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>

  <span>return</span> <span>&lt;</span><span>video</span> <span>ref</span>=<span>{</span><span>ref</span><span>}</span> <span>src</span>=<span>{</span><span>src</span><span>}</span> <span>loop</span> <span>playsInline</span> <span>/&gt;</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>isPlaying</span><span>,</span> <span>setIsPlaying</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>text</span><span>,</span> <span>setText</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>input</span> <span>value</span>=<span>{</span><span>text</span><span>}</span> <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setText</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setIsPlaying</span><span>(</span>!<span>isPlaying</span><span>)</span><span>}</span><span>&gt;</span>
        <span>{</span><span>isPlaying</span> ? <span>'Pause'</span> : <span>'Play'</span><span>}</span>
      <span>&lt;/</span><span>button</span><span>&gt;</span>
      <span>&lt;</span><span>VideoPlayer</span>
        <span>isPlaying</span>=<span>{</span><span>isPlaying</span><span>}</span>
        <span>src</span>=<span>"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"</span>
      <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>You can tell React to <strong>skip unnecessarily re-running the Effect</strong> by specifying an array of <em>dependencies</em> as the second argument to the <code dir="ltr">useEffect</code> call. Start by adding an empty <code dir="ltr">[]</code> array to the above example on line 14:</p> <pre data-language="jsx"><code>  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// ...</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre> <p>You should see an error saying <code dir="ltr">React Hook useEffect has a missing dependency: 'isPlaying'</code>:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useRef</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>function</span> <span>VideoPlayer</span><span>(</span><span>{</span> <span>src</span><span>,</span> <span>isPlaying</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>ref</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPlaying</span><span>)</span> <span>{</span>
      <span>console</span>.<span>log</span><span>(</span><span>'Calling video.play()'</span><span>)</span><span>;</span>
      <span>ref</span>.<span>current</span>.<span>play</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>console</span>.<span>log</span><span>(</span><span>'Calling video.pause()'</span><span>)</span><span>;</span>
      <span>ref</span>.<span>current</span>.<span>pause</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// This causes an error</span>

  <span>return</span> <span>&lt;</span><span>video</span> <span>ref</span>=<span>{</span><span>ref</span><span>}</span> <span>src</span>=<span>{</span><span>src</span><span>}</span> <span>loop</span> <span>playsInline</span> <span>/&gt;</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>isPlaying</span><span>,</span> <span>setIsPlaying</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>text</span><span>,</span> <span>setText</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>input</span> <span>value</span>=<span>{</span><span>text</span><span>}</span> <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setText</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setIsPlaying</span><span>(</span>!<span>isPlaying</span><span>)</span><span>}</span><span>&gt;</span>
        <span>{</span><span>isPlaying</span> ? <span>'Pause'</span> : <span>'Play'</span><span>}</span>
      <span>&lt;/</span><span>button</span><span>&gt;</span>
      <span>&lt;</span><span>VideoPlayer</span>
        <span>isPlaying</span>=<span>{</span><span>isPlaying</span><span>}</span>
        <span>src</span>=<span>"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"</span>
      <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>The problem is that the code inside of your Effect <em>depends on</em> the <code dir="ltr">isPlaying</code> prop to decide what to do, but this dependency was not explicitly declared. To fix this issue, add <code dir="ltr">isPlaying</code> to the dependency array:</p> <pre data-language="jsx"><code>  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPlaying</span><span>)</span> <span>{</span> <span>// It's used here...</span>
      <span>// ...</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// ...</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>isPlaying</span><span>]</span><span>)</span><span>;</span> <span>// ...so it must be declared here!</span></code></pre> <p>Now all dependencies are declared, so there is no error. Specifying <code dir="ltr">[isPlaying]</code> as the dependency array tells React that it should skip re-running your Effect if <code dir="ltr">isPlaying</code> is the same as it was during the previous render. With this change, typing into the input doesn’t cause the Effect to re-run, but pressing Play/Pause does:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useRef</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>function</span> <span>VideoPlayer</span><span>(</span><span>{</span> <span>src</span><span>,</span> <span>isPlaying</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>ref</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPlaying</span><span>)</span> <span>{</span>
      <span>console</span>.<span>log</span><span>(</span><span>'Calling video.play()'</span><span>)</span><span>;</span>
      <span>ref</span>.<span>current</span>.<span>play</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>console</span>.<span>log</span><span>(</span><span>'Calling video.pause()'</span><span>)</span><span>;</span>
      <span>ref</span>.<span>current</span>.<span>pause</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>isPlaying</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>&lt;</span><span>video</span> <span>ref</span>=<span>{</span><span>ref</span><span>}</span> <span>src</span>=<span>{</span><span>src</span><span>}</span> <span>loop</span> <span>playsInline</span> <span>/&gt;</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>isPlaying</span><span>,</span> <span>setIsPlaying</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>text</span><span>,</span> <span>setText</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>input</span> <span>value</span>=<span>{</span><span>text</span><span>}</span> <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setText</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setIsPlaying</span><span>(</span>!<span>isPlaying</span><span>)</span><span>}</span><span>&gt;</span>
        <span>{</span><span>isPlaying</span> ? <span>'Pause'</span> : <span>'Play'</span><span>}</span>
      <span>&lt;/</span><span>button</span><span>&gt;</span>
      <span>&lt;</span><span>VideoPlayer</span>
        <span>isPlaying</span>=<span>{</span><span>isPlaying</span><span>}</span>
        <span>src</span>=<span>"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"</span>
      <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>The dependency array can contain multiple dependencies. React will only skip re-running the Effect if <em>all</em> of the dependencies you specify have exactly the same values as they had during the previous render. React compares the dependency values using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">Object.is</code></a> comparison. See the <a href="../reference/react/useeffect.html#reference"><code dir="ltr">useEffect</code> reference</a> for details.</p> <p><strong>Notice that you can’t “choose” your dependencies.</strong> You will get a lint error if the dependencies you specified don’t match what React expects based on the code inside your Effect. This helps catch many bugs in your code. If you don’t want some code to re-run, <a href="lifecycle-of-reactive-effects.html#what-to-do-when-you-dont-want-to-re-synchronize"><em>edit the Effect code itself</em> to not “need” that dependency.</a></p> <div class="note note-orange">
<h4>Pitfall</h4>
<div>
<p>The behaviors without the dependency array and with an <em>empty</em> <code dir="ltr">[]</code> dependency array are different:</p>
<pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// This runs after every render</span>
<span>}</span><span>)</span><span>;</span>

<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// This runs only on mount (when the component appears)</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>

<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// This runs on mount *and also* if either a or b have changed since the last render</span>
<span>}</span><span>,</span> <span>[</span><span>a</span><span>,</span> <span>b</span><span>]</span><span>)</span><span>;</span></code></pre>
<p>We’ll take a close look at what “mount” means in the next step.</p>
</div>
</div> <details class="note note-blue"><summary tabindex="-1"><h5>
Deep Dive</h5>
<h4 id="why-was-the-ref-omitted-from-the-dependency-array">Why was the ref omitted from the dependency array? 
</h4></summary><div>
<p>This Effect uses <em>both</em> <code dir="ltr">ref</code> and <code dir="ltr">isPlaying</code>, but only <code dir="ltr">isPlaying</code> is declared as a dependency:</p>
<pre data-language="jsx"><code><span>function</span> <span>VideoPlayer</span><span>(</span><span>{</span> <span>src</span><span>,</span> <span>isPlaying</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>ref</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPlaying</span><span>)</span> <span>{</span>
      <span>ref</span>.<span>current</span>.<span>play</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>ref</span>.<span>current</span>.<span>pause</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>isPlaying</span><span>]</span><span>)</span><span>;</span></code></pre>
<p>This is because the <code dir="ltr">ref</code> object has a <em>stable identity:</em> React guarantees <a href="../reference/react/useref.html#returns">you’ll always get the same object</a> from the same <code dir="ltr">useRef</code> call on every render. It never changes, so it will never by itself cause the Effect to re-run. Therefore, it does not matter whether you include it or not. Including it is fine too:</p>
<pre data-language="jsx"><code><span>function</span> <span>VideoPlayer</span><span>(</span><span>{</span> <span>src</span><span>,</span> <span>isPlaying</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>ref</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPlaying</span><span>)</span> <span>{</span>
      <span>ref</span>.<span>current</span>.<span>play</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>ref</span>.<span>current</span>.<span>pause</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>isPlaying</span><span>,</span> <span>ref</span><span>]</span><span>)</span><span>;</span></code></pre>
<p>The <a href="../reference/react/usestate.html#setstate"><code dir="ltr">set</code> functions</a> returned by <code dir="ltr">useState</code> also have stable identity, so you will often see them omitted from the dependencies too. If the linter lets you omit a dependency without errors, it is safe to do.</p>
<p>Omitting always-stable dependencies only works when the linter can “see” that the object is stable. For example, if <code dir="ltr">ref</code> was passed from a parent component, you would have to specify it in the dependency array. However, this is good because you can’t know whether the parent component always passes the same ref, or passes one of several refs conditionally. So your Effect <em>would</em> depend on which ref is passed.</p>
</div></details> <h3 id="step-3-add-cleanup-if-needed">Step 3: Add cleanup if needed 
</h3> <p>Consider a different example. You’re writing a <code dir="ltr">ChatRoom</code> component that needs to connect to the chat server when it appears. You are given a <code dir="ltr">createConnection()</code> API that returns an object with <code dir="ltr">connect()</code> and <code dir="ltr">disconnect()</code> methods. How do you keep the component connected while it is displayed to the user?</p> <p>Start by writing the Effect logic:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
  <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></code></pre> <p>It would be slow to connect to the chat after every re-render, so you add the dependency array:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
  <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre> <p><strong>The code inside the Effect does not use any props or state, so your dependency array is <code dir="ltr">[]</code> (empty). This tells React to only run this code when the component “mounts”, i.e. appears on the screen for the first time.</strong></p> <p>Let’s try running this code:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>ChatRoom</span><span>(</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the chat!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
<span>}</span>

</pre> <p>This Effect only runs on mount, so you might expect <code dir="ltr">"✅ Connecting..."</code> to be printed once in the console. <strong>However, if you check the console, <code dir="ltr">"✅ Connecting..."</code> gets printed twice. Why does it happen?</strong></p> <p>Imagine the <code dir="ltr">ChatRoom</code> component is a part of a larger app with many different screens. The user starts their journey on the <code dir="ltr">ChatRoom</code> page. The component mounts and calls <code dir="ltr">connection.connect()</code>. Then imagine the user navigates to another screen—for example, to the Settings page. The <code dir="ltr">ChatRoom</code> component unmounts. Finally, the user clicks Back and <code dir="ltr">ChatRoom</code> mounts again. This would set up a second connection—but the first connection was never destroyed! As the user navigates across the app, the connections would keep piling up.</p> <p>Bugs like this are easy to miss without extensive manual testing. To help you spot them quickly, in development React remounts every component once immediately after its initial mount.</p> <p>Seeing the <code dir="ltr">"✅ Connecting..."</code> log twice helps you notice the real issue: your code doesn’t close the connection when the component unmounts.</p> <p>To fix the issue, return a <em>cleanup function</em> from your Effect:</p> <pre data-language="jsx"><code>  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre> <p>React will call your cleanup function each time before the Effect runs again, and one final time when the component unmounts (gets removed). Let’s see what happens when the cleanup function is implemented:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>ChatRoom</span><span>(</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the chat!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
<span>}</span>

</pre> <p>Now you get three console logs in development:</p> <ol> <li><code dir="ltr">"✅ Connecting..."</code></li> <li><code dir="ltr">"❌ Disconnected."</code></li> <li><code dir="ltr">"✅ Connecting..."</code></li> </ol> <p><strong>This is the correct behavior in development.</strong> By remounting your component, React verifies that navigating away and back would not break your code. Disconnecting and then connecting again is exactly what should happen! When you implement the cleanup well, there should be no user-visible difference between running the Effect once vs running it, cleaning it up, and running it again. There’s an extra connect/disconnect call pair because React is probing your code for bugs in development. This is normal—don’t try to make it go away!</p> <p><strong>In production, you would only see <code dir="ltr">"✅ Connecting..."</code> printed once.</strong> Remounting components only happens in development to help you find Effects that need cleanup. You can turn off <a href="../reference/react/strictmode.html">Strict Mode</a> to opt out of the development behavior, but we recommend keeping it on. This lets you find many bugs like the one above.</p> <h2 id="how-to-handle-the-effect-firing-twice-in-development">How to handle the Effect firing twice in development? 
</h2> <p>React intentionally remounts your components in development to find bugs like in the last example. <strong>The right question isn’t “how to run an Effect once”, but “how to fix my Effect so that it works after remounting”.</strong></p> <p>Usually, the answer is to implement the cleanup function. The cleanup function should stop or undo whatever the Effect was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the Effect running once (as in production) and a <em>setup → cleanup → setup</em> sequence (as you’d see in development).</p> <p>Most of the Effects you’ll write will fit into one of the common patterns below.</p> <div class="note note-orange">
<h4>Pitfall</h4>
<div>
<h4 id="dont-use-refs-to-prevent-effects-from-firing">Don’t use refs to prevent Effects from firing 
</h4>
<p>A common pitfall for preventing Effects firing twice in development is to use a <code dir="ltr">ref</code> to prevent the Effect from running more than once. For example, you could “fix” the above bug with a <code dir="ltr">useRef</code>:</p>
<pre data-language="jsx"><code>  <span>const</span> <span>connectionRef</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// 🚩 This wont fix the bug!!!</span>
    <span>if</span> <span>(</span>!<span>connectionRef</span>.<span>current</span><span>)</span> <span>{</span>
      <span>connectionRef</span>.<span>current</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
      <span>connectionRef</span>.<span>current</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre>
<p>This makes it so you only see <code dir="ltr">"✅ Connecting..."</code> once in development, but it doesn’t fix the bug.</p>
<p>When the user navigates away, the connection still isn’t closed and when they navigate back, a new connection is created. As the user navigates across the app, the connections would keep piling up, the same as it would before the “fix”.</p>
<p>To fix the bug, it is not enough to just make the Effect run once. The effect needs to work after re-mounting, which means the connection needs to be cleaned up like in the solution above.</p>
<p>See the examples below for how to handle common patterns.</p>
</div>
</div> <h3 id="controlling-non-react-widgets">Controlling non-React widgets 
</h3> <p>Sometimes you need to add UI widgets that aren’t written in React. For example, let’s say you’re adding a map component to your page. It has a <code dir="ltr">setZoomLevel()</code> method, and you’d like to keep the zoom level in sync with a <code dir="ltr">zoomLevel</code> state variable in your React code. Your Effect would look similar to this:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>map</span> = <span>mapRef</span>.<span>current</span><span>;</span>
  <span>map</span>.<span>setZoomLevel</span><span>(</span><span>zoomLevel</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>[</span><span>zoomLevel</span><span>]</span><span>)</span><span>;</span></code></pre> <p>Note that there is no cleanup needed in this case. In development, React will call the Effect twice, but this is not a problem because calling <code dir="ltr">setZoomLevel</code> twice with the same value does not do anything. It may be slightly slower, but this doesn’t matter because it won’t remount needlessly in production.</p> <p>Some APIs may not allow you to call them twice in a row. For example, the <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">showModal</code></a> method of the built-in <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">&lt;dialog&gt;</code></a> element throws if you call it twice. Implement the cleanup function and make it close the dialog:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>dialog</span> = <span>dialogRef</span>.<span>current</span><span>;</span>
  <span>dialog</span>.<span>showModal</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>dialog</span>.<span>close</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre> <p>In development, your Effect will call <code dir="ltr">showModal()</code>, then immediately <code dir="ltr">close()</code>, and then <code dir="ltr">showModal()</code> again. This has the same user-visible behavior as calling <code dir="ltr">showModal()</code> once, as you would see in production.</p> <h3 id="subscribing-to-events">Subscribing to events 
</h3> <p>If your Effect subscribes to something, the cleanup function should unsubscribe:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>function</span> <span>handleScroll</span><span>(</span><span>e</span><span>)</span> <span>{</span>
    <span>console</span>.<span>log</span><span>(</span><span>window</span>.<span>scrollX</span><span>,</span> <span>window</span>.<span>scrollY</span><span>)</span><span>;</span>
  <span>}</span>
  <span>window</span>.<span>addEventListener</span><span>(</span><span>'scroll'</span><span>,</span> <span>handleScroll</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>window</span>.<span>removeEventListener</span><span>(</span><span>'scroll'</span><span>,</span> <span>handleScroll</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre> <p>In development, your Effect will call <code dir="ltr">addEventListener()</code>, then immediately <code dir="ltr">removeEventListener()</code>, and then <code dir="ltr">addEventListener()</code> again with the same handler. So there would be only one active subscription at a time. This has the same user-visible behavior as calling <code dir="ltr">addEventListener()</code> once, as in production.</p> <h3 id="triggering-animations">Triggering animations 
</h3> <p>If your Effect animates something in, the cleanup function should reset the animation to the initial values:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>node</span> = <span>ref</span>.<span>current</span><span>;</span>
  <span>node</span>.<span>style</span>.<span>opacity</span> = <span>1</span><span>;</span> <span>// Trigger the animation</span>
  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>node</span>.<span>style</span>.<span>opacity</span> = <span>0</span><span>;</span> <span>// Reset to the initial value</span>
  <span>}</span><span>;</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre> <p>In development, opacity will be set to <code dir="ltr">1</code>, then to <code dir="ltr">0</code>, and then to <code dir="ltr">1</code> again. This should have the same user-visible behavior as setting it to <code dir="ltr">1</code> directly, which is what would happen in production. If you use a third-party animation library with support for tweening, your cleanup function should reset the timeline to its initial state.</p> <h3 id="fetching-data">Fetching data 
</h3> <p>If your Effect fetches something, the cleanup function should either <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" target="_blank" rel="nofollow noopener noreferrer">abort the fetch</a> or ignore its result:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> <span>ignore</span> = <span>false</span><span>;</span>

  <span>async</span> <span>function</span> <span>startFetching</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>json</span> = <span>await</span> <span>fetchTodos</span><span>(</span><span>userId</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span>
      <span>setTodos</span><span>(</span><span>json</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>startFetching</span><span>(</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>ignore</span> = <span>true</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span><span>,</span> <span>[</span><span>userId</span><span>]</span><span>)</span><span>;</span></code></pre> <p>You can’t “undo” a network request that already happened, but your cleanup function should ensure that the fetch that’s <em>not relevant anymore</em> does not keep affecting your application. If the <code dir="ltr">userId</code> changes from <code dir="ltr">'Alice'</code> to <code dir="ltr">'Bob'</code>, cleanup ensures that the <code dir="ltr">'Alice'</code> response is ignored even if it arrives after <code dir="ltr">'Bob'</code>.</p> <p><strong>In development, you will see two fetches in the Network tab.</strong> There is nothing wrong with that. With the approach above, the first Effect will immediately get cleaned up so its copy of the <code dir="ltr">ignore</code> variable will be set to <code dir="ltr">true</code>. So even though there is an extra request, it won’t affect the state thanks to the <code dir="ltr">if (!ignore)</code> check.</p> <p><strong>In production, there will only be one request.</strong> If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:</p> <pre data-language="jsx"><code><span>function</span> <span>TodoList</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>todos</span> = <span>useSomeDataLibrary</span><span>(</span><span>`/api/user/</span><span>${</span><span>userId</span><span>}</span><span>/todos`</span><span>)</span><span>;</span>
  <span>// ...</span></code></pre> <p>This will not only improve the development experience, but also make your application feel faster. For example, the user pressing the Back button won’t have to wait for some data to load again because it will be cached. You can either build such a cache yourself or use one of the many alternatives to manual fetching in Effects.</p> <details class="note note-blue"><summary tabindex="-1"><h5>
Deep Dive</h5>
<h4 id="what-are-good-alternatives-to-data-fetching-in-effects">What are good alternatives to data fetching in Effects? 
</h4></summary><div>
<p>Writing <code dir="ltr">fetch</code> calls inside Effects is a <a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="nofollow noopener noreferrer">popular way to fetch data</a>, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:</p>
<ul> <li>
<strong>Effects don’t run on the server.</strong> This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.</li> <li>
<strong>Fetching directly in Effects makes it easy to create “network waterfalls”.</strong> You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.</li> <li>
<strong>Fetching directly in Effects usually means you don’t preload or cache data.</strong> For example, if the component unmounts and then mounts again, it would have to fetch the data again.</li> <li>
<strong>It’s not very ergonomic.</strong> There’s quite a bit of boilerplate code involved when writing <code dir="ltr">fetch</code> calls in a way that doesn’t suffer from bugs like <a href="https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect" target="_blank" rel="nofollow noopener noreferrer">race conditions.</a>
</li> </ul>
<p>This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:</p>
<ul> <li>
<strong>If you use a <a href="start-a-new-react-project.html#production-grade-react-frameworks">framework</a>, use its built-in data fetching mechanism.</strong> Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.</li> <li>
<strong>Otherwise, consider using or building a client-side cache.</strong> Popular open source solutions include <a href="https://tanstack.com/query/latest" target="_blank" rel="nofollow noopener noreferrer">React Query</a>, <a href="https://swr.vercel.app/" target="_blank" rel="nofollow noopener noreferrer">useSWR</a>, and <a href="https://beta.reactrouter.com/en/main/start/overview" target="_blank" rel="nofollow noopener noreferrer">React Router 6.4+.</a> You can build your own solution too, in which case you would use Effects under the hood, but add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).</li> </ul>
<p>You can continue fetching data directly in Effects if neither of these approaches suit you.</p>
</div></details> <h3 id="sending-analytics">Sending analytics 
</h3> <p>Consider this code that sends an analytics event on the page visit:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>logVisit</span><span>(</span><span>url</span><span>)</span><span>;</span> <span>// Sends a POST request</span>
<span>}</span><span>,</span> <span>[</span><span>url</span><span>]</span><span>)</span><span>;</span></code></pre> <p>In development, <code dir="ltr">logVisit</code> will be called twice for every URL, so you might be tempted to try to fix that. <strong>We recommend keeping this code as is.</strong> Like with earlier examples, there is no <em>user-visible</em> behavior difference between running it once and running it twice. From a practical point of view, <code dir="ltr">logVisit</code> should not do anything in development because you don’t want the logs from the development machines to skew the production metrics. Your component remounts every time you save its file, so it logs extra visits in development anyway.</p> <p><strong>In production, there will be no duplicate visit logs.</strong></p> <p>To debug the analytics events you’re sending, you can deploy your app to a staging environment (which runs in production mode) or temporarily opt out of <a href="../reference/react/strictmode.html">Strict Mode</a> and its development-only remounting checks. You may also send analytics from the route change event handlers instead of Effects. For more precise analytics, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" target="_blank" rel="nofollow noopener noreferrer">intersection observers</a> can help track which components are in the viewport and how long they remain visible.</p> <h3 id="not-an-effect-initializing-the-application">Not an Effect: Initializing the application 
</h3> <p>Some logic should only run once when the application starts. You can put it outside your components:</p> <pre data-language="jsx"><code><span>if</span> <span>(</span><span>typeof</span> <span>window</span> !== <span>'undefined'</span><span>)</span> <span>{</span> <span>// Check if we're running in the browser.</span>
  <span>checkAuthToken</span><span>(</span><span>)</span><span>;</span>
  <span>loadDataFromLocalStorage</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>// ...</span>
<span>}</span></code></pre> <p>This guarantees that such logic only runs once after the browser loads the page.</p> <h3 id="not-an-effect-buying-a-product">Not an Effect: Buying a product 
</h3> <p>Sometimes, even if you write a cleanup function, there’s no way to prevent user-visible consequences of running the Effect twice. For example, maybe your Effect sends a POST request like buying a product:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// 🔴 Wrong: This Effect fires twice in development, exposing a problem in the code.</span>
  <span>fetch</span><span>(</span><span>'/api/buy'</span><span>,</span> <span>{</span> <span>method</span><span>:</span> <span>'POST'</span> <span>}</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre> <p>You wouldn’t want to buy the product twice. However, this is also why you shouldn’t put this logic in an Effect. What if the user goes to another page and then presses Back? Your Effect would run again. You don’t want to buy the product when the user <em>visits</em> a page; you want to buy it when the user <em>clicks</em> the Buy button.</p> <p>Buying is not caused by rendering; it’s caused by a specific interaction. It should run only when the user presses the button. <strong>Delete the Effect and move your <code dir="ltr">/api/buy</code> request into the Buy button event handler:</strong></p> <pre data-language="jsx"><code>  <span>function</span> <span>handleClick</span><span>(</span><span>)</span> <span>{</span>
    <span>// ✅ Buying is an event because it is caused by a particular interaction.</span>
    <span>fetch</span><span>(</span><span>'/api/buy'</span><span>,</span> <span>{</span> <span>method</span><span>:</span> <span>'POST'</span> <span>}</span><span>)</span><span>;</span>
  <span>}</span></code></pre> <p><strong>This illustrates that if remounting breaks the logic of your application, this usually uncovers existing bugs.</strong> From a user’s perspective, visiting a page shouldn’t be different from visiting it, clicking a link, then pressing Back to view the page again. React verifies that your components abide by this principle by remounting them once in development.</p> <h2 id="putting-it-all-together">Putting it all together 
</h2> <p>This playground can help you “get a feel” for how Effects work in practice.</p> <p>This example uses <a href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">setTimeout</code></a> to schedule a console log with the input text to appear three seconds after the Effect runs. The cleanup function cancels the pending timeout. Start by pressing “Mount the component”:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>function</span> <span>Playground</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>text</span><span>,</span> <span>setText</span><span>]</span> = <span>useState</span><span>(</span><span>'a'</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>function</span> <span>onTimeout</span><span>(</span><span>)</span> <span>{</span>
      <span>console</span>.<span>log</span><span>(</span><span>'⏰ '</span> + <span>text</span><span>)</span><span>;</span>
    <span>}</span>

    <span>console</span>.<span>log</span><span>(</span><span>'🔵 Schedule "'</span> + <span>text</span> + <span>'" log'</span><span>)</span><span>;</span>
    <span>const</span> <span>timeoutId</span> = <span>setTimeout</span><span>(</span><span>onTimeout</span><span>,</span> <span>3000</span><span>)</span><span>;</span>

    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>console</span>.<span>log</span><span>(</span><span>'🟡 Cancel "'</span> + <span>text</span> + <span>'" log'</span><span>)</span><span>;</span>
      <span>clearTimeout</span><span>(</span><span>timeoutId</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>text</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>label</span><span>&gt;</span>
        What to log:<span>{</span><span>' '</span><span>}</span>
        <span>&lt;</span><span>input</span>
          <span>value</span>=<span>{</span><span>text</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setText</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span>
        <span>/&gt;</span>
      <span>&lt;/</span><span>label</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span><span>{</span><span>text</span><span>}</span><span>&lt;/</span><span>h1</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>show</span><span>,</span> <span>setShow</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setShow</span><span>(</span>!<span>show</span><span>)</span><span>}</span><span>&gt;</span>
        <span>{</span><span>show</span> ? <span>'Unmount'</span> : <span>'Mount'</span><span>}</span> the component
      <span>&lt;/</span><span>button</span><span>&gt;</span>
      <span>{</span><span>show</span> &amp;&amp; <span>&lt;</span><span>hr</span> <span>/&gt;</span><span>}</span>
      <span>{</span><span>show</span> &amp;&amp; <span>&lt;</span><span>Playground</span> <span>/&gt;</span><span>}</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>You will see three logs at first: <code dir="ltr">Schedule "a" log</code>, <code dir="ltr">Cancel "a" log</code>, and <code dir="ltr">Schedule "a" log</code> again. Three second later there will also be a log saying <code dir="ltr">a</code>. As you learned earlier, the extra schedule/cancel pair is because React remounts the component once in development to verify that you’ve implemented cleanup well.</p> <p>Now edit the input to say <code dir="ltr">abc</code>. If you do it fast enough, you’ll see <code dir="ltr">Schedule "ab" log</code> immediately followed by <code dir="ltr">Cancel "ab" log</code> and <code dir="ltr">Schedule "abc" log</code>. <strong>React always cleans up the previous render’s Effect before the next render’s Effect.</strong> This is why even if you type into the input fast, there is at most one timeout scheduled at a time. Edit the input a few times and watch the console to get a feel for how Effects get cleaned up.</p> <p>Type something into the input and then immediately press “Unmount the component”. Notice how unmounting cleans up the last render’s Effect. Here, it clears the last timeout before it has a chance to fire.</p> <p>Finally, edit the component above and comment out the cleanup function so that the timeouts don’t get cancelled. Try typing <code dir="ltr">abcde</code> fast. What do you expect to happen in three seconds? Will <code dir="ltr">console.log(text)</code> inside the timeout print the <em>latest</em> <code dir="ltr">text</code> and produce five <code dir="ltr">abcde</code> logs? Give it a try to check your intuition!</p> <p>Three seconds later, you should see a sequence of logs (<code dir="ltr">a</code>, <code dir="ltr">ab</code>, <code dir="ltr">abc</code>, <code dir="ltr">abcd</code>, and <code dir="ltr">abcde</code>) rather than five <code dir="ltr">abcde</code> logs. <strong>Each Effect “captures” the <code dir="ltr">text</code> value from its corresponding render.</strong> It doesn’t matter that the <code dir="ltr">text</code> state changed: an Effect from the render with <code dir="ltr">text = 'ab'</code> will always see <code dir="ltr">'ab'</code>. In other words, Effects from each render are isolated from each other. If you’re curious how this works, you can read about <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="nofollow noopener noreferrer">closures</a>.</p> <details class="note note-blue"><summary tabindex="-1"><h5>
Deep Dive</h5>
<h4 id="each-render-has-its-own-effects">Each render has its own Effects 
</h4></summary><div>
<p>You can think of <code dir="ltr">useEffect</code> as “attaching” a piece of behavior to the render output. Consider this Effect:</p>
<pre data-language="jsx"><code><span>export</span> <span>default</span> <span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to <span>{</span><span>roomId</span><span>}</span>!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
<span>}</span></code></pre>
<p>Let’s see what exactly happens as the user navigates around the app.</p>
<h4 id="initial-render">Initial render 
</h4>
<p>The user visits <code dir="ltr">&lt;ChatRoom roomId="general" /&gt;</code>. Let’s <a href="state-as-a-snapshot.html#rendering-takes-a-snapshot-in-time">mentally substitute</a> <code dir="ltr">roomId</code> with <code dir="ltr">'general'</code>:</p>
<pre data-language="jsx"><code>  <span>// JSX for the first render (roomId = "general")</span>
  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to general!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span></code></pre>
<p><strong>The Effect is <em>also</em> a part of the rendering output.</strong> The first render’s Effect becomes:</p>
<pre data-language="jsx"><code>  <span>// Effect for the first render (roomId = "general")</span>
  <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>'general'</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span>
  <span>// Dependencies for the first render (roomId = "general")</span>
  <span>[</span><span>'general'</span><span>]</span></code></pre>
<p>React runs this Effect, which connects to the <code dir="ltr">'general'</code> chat room.</p>
<h4 id="re-render-with-same-dependencies">Re-render with same dependencies 
</h4>
<p>Let’s say <code dir="ltr">&lt;ChatRoom roomId="general" /&gt;</code> re-renders. The JSX output is the same:</p>
<pre data-language="jsx"><code>  <span>// JSX for the second render (roomId = "general")</span>
  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to general!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span></code></pre>
<p>React sees that the rendering output has not changed, so it doesn’t update the DOM.</p>
<p>The Effect from the second render looks like this:</p>
<pre data-language="jsx"><code>  <span>// Effect for the second render (roomId = "general")</span>
  <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>'general'</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span>
  <span>// Dependencies for the second render (roomId = "general")</span>
  <span>[</span><span>'general'</span><span>]</span></code></pre>
<p>React compares <code dir="ltr">['general']</code> from the second render with <code dir="ltr">['general']</code> from the first render. <strong>Because all dependencies are the same, React <em>ignores</em> the Effect from the second render.</strong> It never gets called.</p>
<h4 id="re-render-with-different-dependencies">Re-render with different dependencies 
</h4>
<p>Then, the user visits <code dir="ltr">&lt;ChatRoom roomId="travel" /&gt;</code>. This time, the component returns different JSX:</p>
<pre data-language="jsx"><code>  <span>// JSX for the third render (roomId = "travel")</span>
  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to travel!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span></code></pre>
<p>React updates the DOM to change <code dir="ltr">"Welcome to general"</code> into <code dir="ltr">"Welcome to travel"</code>.</p>
<p>The Effect from the third render looks like this:</p>
<pre data-language="jsx"><code>  <span>// Effect for the third render (roomId = "travel")</span>
  <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>'travel'</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span>
  <span>// Dependencies for the third render (roomId = "travel")</span>
  <span>[</span><span>'travel'</span><span>]</span></code></pre>
<p>React compares <code dir="ltr">['travel']</code> from the third render with <code dir="ltr">['general']</code> from the second render. One dependency is different: <code dir="ltr">Object.is('travel', 'general')</code> is <code dir="ltr">false</code>. The Effect can’t be skipped.</p>
<p><strong>Before React can apply the Effect from the third render, it needs to clean up the last Effect that <em>did</em> run.</strong> The second render’s Effect was skipped, so React needs to clean up the first render’s Effect. If you scroll up to the first render, you’ll see that its cleanup calls <code dir="ltr">disconnect()</code> on the connection that was created with <code dir="ltr">createConnection('general')</code>. This disconnects the app from the <code dir="ltr">'general'</code> chat room.</p>
<p>After that, React runs the third render’s Effect. It connects to the <code dir="ltr">'travel'</code> chat room.</p>
<h4 id="unmount">Unmount 
</h4>
<p>Finally, let’s say the user navigates away, and the <code dir="ltr">ChatRoom</code> component unmounts. React runs the last Effect’s cleanup function. The last Effect was from the third render. The third render’s cleanup destroys the <code dir="ltr">createConnection('travel')</code> connection. So the app disconnects from the <code dir="ltr">'travel'</code> room.</p>
<h4 id="development-only-behaviors">Development-only behaviors 
</h4>
<p>When <a href="../reference/react/strictmode.html">Strict Mode</a> is on, React remounts every component once after mount (state and DOM are preserved). This <a href="#step-3-add-cleanup-if-needed">helps you find Effects that need cleanup</a> and exposes bugs like race conditions early. Additionally, React will remount the Effects whenever you save a file in development. Both of these behaviors are development-only.</p>
</div></details> <section><h2 id="recap">Recap
</h2>
<ul> <li>Unlike events, Effects are caused by rendering itself rather than a particular interaction.</li> <li>Effects let you synchronize a component with some external system (third-party API, network, etc).</li> <li>By default, Effects run after every render (including the initial one).</li> <li>React will skip the Effect if all of its dependencies have the same values as during the last render.</li> <li>You can’t “choose” your dependencies. They are determined by the code inside the Effect.</li> <li>Empty dependency array (<code dir="ltr">[]</code>) corresponds to the component “mounting”, i.e. being added to the screen.</li> <li>In Strict Mode, React mounts components twice (in development only!) to stress-test your Effects.</li> <li>If your Effect breaks because of remounting, you need to implement a cleanup function.</li> <li>React will call your cleanup function before the Effect runs next time, and during the unmount.</li> </ul></section> <div class="note">
<h4>Try out some challenges</h4>

<div>
<h4 id="focus-a-field-on-mount">
<div>Challenge 1 of 4<span>: </span>
</div>Focus a field on mount 
</h4>
<p>In this example, the form renders a <code dir="ltr">&lt;MyInput /&gt;</code> component.</p>
<p>Use the input’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">focus()</code></a> method to make <code dir="ltr">MyInput</code> automatically focus when it appears on the screen. There is already a commented out implementation, but it doesn’t quite work. Figure out why it doesn’t work, and fix it. (If you’re familiar with the <code dir="ltr">autoFocus</code> attribute, pretend that it does not exist: we are reimplementing the same functionality from scratch.)</p>

<pre data-language="jsx"><span>import</span> <span>{</span> <span>useEffect</span><span>,</span> <span>useRef</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>MyInput</span><span>(</span><span>{</span> <span>value</span><span>,</span> <span>onChange</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>ref</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>// TODO: This doesn't quite work. Fix it.</span>
  <span>// ref.current.focus()    </span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>input</span>
      <span>ref</span>=<span>{</span><span>ref</span><span>}</span>
      <span>value</span>=<span>{</span><span>value</span><span>}</span>
      <span>onChange</span>=<span>{</span><span>onChange</span><span>}</span>
    <span>/&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre>
<p>To verify that your solution works, press “Show form” and verify that the input receives focus (becomes highlighted and the cursor is placed inside). Press “Hide form” and “Show form” again. Verify the input is highlighted again.</p>
<p><code dir="ltr">MyInput</code> should only focus <em>on mount</em> rather than after every render. To verify that the behavior is right, press “Show form” and then repeatedly press the “Make it uppercase” checkbox. Clicking the checkbox should <em>not</em> focus the input above it.</p>
</div>

</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013&ndash;present Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://react.dev/learn/synchronizing-with-effects" class="_attribution-link">https://react.dev/learn/synchronizing-with-effects</a>
  </p>
</div>
