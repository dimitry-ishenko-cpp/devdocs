<h1>Removing Effect Dependencies
</h1>
<div><p>When you write an Effect, the linter will verify that you’ve included every reactive value (like props and state) that the Effect reads in the list of your Effect’s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. Follow this guide to review and remove unnecessary dependencies from your Effects.</p></div> <div class="note">
<h4>You will learn</h4>
<ul> <li>How to fix infinite Effect dependency loops</li> <li>What to do when you want to remove a dependency</li> <li>How to read a value from your Effect without “reacting” to it</li> <li>How and why to avoid object and function dependencies</li> <li>Why suppressing the dependency linter is dangerous, and what to do instead</li> </ul>
</div> <h2 id="dependencies-should-match-the-code">Dependencies should match the code 
</h2> <p>When you write an Effect, you first specify how to <a href="lifecycle-of-reactive-effects.html#the-lifecycle-of-an-effect">start and stop</a> whatever you want your Effect to be doing:</p> <pre data-language="jsx"><code><span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  	<span>// ...</span>
<span>}</span></code></pre> <p>Then, if you leave the Effect dependencies empty (<code dir="ltr">[]</code>), the linter will suggest the correct dependencies:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// &lt;-- Fix the mistake here!</span>
  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the <span>{</span><span>roomId</span><span>}</span> room!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>roomId</span><span>,</span> <span>setRoomId</span><span>]</span> = <span>useState</span><span>(</span><span>'general'</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>label</span><span>&gt;</span>
        Choose the chat room:<span>{</span><span>' '</span><span>}</span>
        <span>&lt;</span><span>select</span>
          <span>value</span>=<span>{</span><span>roomId</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setRoomId</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span>
        <span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"general"</span><span>&gt;</span>general<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"travel"</span><span>&gt;</span>travel<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"music"</span><span>&gt;</span>music<span>&lt;/</span><span>option</span><span>&gt;</span>
        <span>&lt;/</span><span>select</span><span>&gt;</span>
      <span>&lt;/</span><span>label</span><span>&gt;</span>
      <span>&lt;</span><span>hr</span> <span>/&gt;</span>
      <span>&lt;</span><span>ChatRoom</span> <span>roomId</span>=<span>{</span><span>roomId</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>Fill them in according to what the linter says:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span>
<span>}</span></code></pre> <p><a href="lifecycle-of-reactive-effects.html#effects-react-to-reactive-values">Effects “react” to reactive values.</a> Since <code dir="ltr">roomId</code> is a reactive value (it can change due to a re-render), the linter verifies that you’ve specified it as a dependency. If <code dir="ltr">roomId</code> receives a different value, React will re-synchronize your Effect. This ensures that the chat stays connected to the selected room and “reacts” to the dropdown:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span>
  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the <span>{</span><span>roomId</span><span>}</span> room!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>roomId</span><span>,</span> <span>setRoomId</span><span>]</span> = <span>useState</span><span>(</span><span>'general'</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>label</span><span>&gt;</span>
        Choose the chat room:<span>{</span><span>' '</span><span>}</span>
        <span>&lt;</span><span>select</span>
          <span>value</span>=<span>{</span><span>roomId</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setRoomId</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span>
        <span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"general"</span><span>&gt;</span>general<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"travel"</span><span>&gt;</span>travel<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"music"</span><span>&gt;</span>music<span>&lt;/</span><span>option</span><span>&gt;</span>
        <span>&lt;/</span><span>select</span><span>&gt;</span>
      <span>&lt;/</span><span>label</span><span>&gt;</span>
      <span>&lt;</span><span>hr</span> <span>/&gt;</span>
      <span>&lt;</span><span>ChatRoom</span> <span>roomId</span>=<span>{</span><span>roomId</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <h3 id="to-remove-a-dependency-prove-that-its-not-a-dependency">To remove a dependency, prove that it’s not a dependency 
</h3> <p>Notice that you can’t “choose” the dependencies of your Effect. Every <span data-step="2">reactive value</span> used by your Effect’s code must be declared in your dependency list. The dependency list is determined by the surrounding code:</p> <pre data-language="jsx"><code><span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span> <span>// This is a reactive value</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span> <span>// This Effect reads that reactive value</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span> <span>// ✅ So you must specify that reactive value as a dependency of your Effect</span>
  <span>// ...</span>
<span>}</span></code></pre> <p><a href="lifecycle-of-reactive-effects.html#all-variables-declared-in-the-component-body-are-reactive">Reactive values</a> include props and all variables and functions declared directly inside of your component. Since <code dir="ltr">roomId</code> is a reactive value, you can’t remove it from the dependency list. The linter wouldn’t allow it:</p> <pre data-language="jsx"><code><span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// 🔴 React Hook useEffect has a missing dependency: 'roomId'</span>
  <span>// ...</span>
<span>}</span></code></pre> <p>And the linter would be right! Since <code dir="ltr">roomId</code> may change over time, this would introduce a bug in your code.</p> <p><strong>To remove a dependency, “prove” to the linter that it <em>doesn’t need</em> to be a dependency.</strong> For example, you can move <code dir="ltr">roomId</code> out of your component to prove that it’s not reactive and won’t change on re-renders:</p> <pre data-language="jsx"><code><span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>
<span>const</span> <span>roomId</span> = <span>'music'</span><span>;</span> <span>// Not a reactive value anymore</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span>
<span>}</span></code></pre> <p>Now that <code dir="ltr">roomId</code> is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>
<span>const</span> <span>roomId</span> = <span>'music'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>ChatRoom</span><span>(</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the <span>{</span><span>roomId</span><span>}</span> room!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
<span>}</span>

</pre> <p>This is why you could now specify an <a href="lifecycle-of-reactive-effects.html#what-an-effect-with-empty-dependencies-means">empty (<code dir="ltr">[]</code>) dependency list.</a> Your Effect <em>really doesn’t</em> depend on any reactive value anymore, so it <em>really doesn’t</em> need to re-run when any of the component’s props or state change.</p> <h3 id="to-change-the-dependencies-change-the-code">To change the dependencies, change the code 
</h3> <p>You might have noticed a pattern in your workflow:</p> <ol> <li>First, you <strong>change the code</strong> of your Effect or how your reactive values are declared.</li> <li>Then, you follow the linter and adjust the dependencies to <strong>match the code you have changed.</strong>
</li> <li>If you’re not happy with the list of dependencies, you <strong>go back to the first step</strong> (and change the code again).</li> </ol> <p>The last part is important. <strong>If you want to change the dependencies, change the surrounding code first.</strong> You can think of the dependency list as <a href="lifecycle-of-reactive-effects.html#react-verifies-that-you-specified-every-reactive-value-as-a-dependency">a list of all the reactive values used by your Effect’s code.</a> You don’t <em>choose</em> what to put on that list. The list <em>describes</em> your code. To change the dependency list, change the code.</p> <p>This might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to “find” the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below.</p> <div class="note note-orange">
<h4>Pitfall</h4>
<div>
<p>If you have an existing codebase, you might have some Effects that suppress the linter like this:</p>
<pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// ...</span>
  <span>// 🔴 Avoid suppressing the linter like this:</span>
  <span>// eslint-ignore-next-line react-hooks/exhaustive-deps</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre>
<p><strong>When dependencies don’t match the code, there is a very high risk of introducing bugs.</strong> By suppressing the linter, you “lie” to React about the values your Effect depends on.</p>
<p>Instead, use the techniques below.</p>
</div>
</div> <details class="note note-blue"><summary tabindex="-1"><h5>
Deep Dive</h5>
<h4 id="why-is-suppressing-the-dependency-linter-so-dangerous">Why is suppressing the dependency linter so dangerous? 
</h4></summary><div>
<p>Suppressing the linter leads to very unintuitive bugs that are hard to find and fix. Here’s one example:</p>

<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Timer</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>count</span><span>,</span> <span>setCount</span><span>]</span> = <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>increment</span><span>,</span> <span>setIncrement</span><span>]</span> = <span>useState</span><span>(</span><span>1</span><span>)</span><span>;</span>

  <span>function</span> <span>onTick</span><span>(</span><span>)</span> <span>{</span>
	<span>setCount</span><span>(</span><span>count</span> + <span>increment</span><span>)</span><span>;</span>
  <span>}</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>id</span> = <span>setInterval</span><span>(</span><span>onTick</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>clearInterval</span><span>(</span><span>id</span><span>)</span><span>;</span>
    <span>// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span>
        Counter: <span>{</span><span>count</span><span>}</span>
        <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setCount</span><span>(</span><span>0</span><span>)</span><span>}</span><span>&gt;</span>Reset<span>&lt;/</span><span>button</span><span>&gt;</span>
      <span>&lt;/</span><span>h1</span><span>&gt;</span>
      <span>&lt;</span><span>hr</span> <span>/&gt;</span>
      <span>&lt;</span><span>p</span><span>&gt;</span>
        Every second, increment by:
        <span>&lt;</span><span>button</span> <span>disabled</span>=<span>{</span><span>increment</span> === <span>0</span><span>}</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
          <span>setIncrement</span><span>(</span><span>i</span> <span>=&gt;</span> <span>i</span> - <span>1</span><span>)</span><span>;</span>
        <span>}</span><span>}</span><span>&gt;</span>–<span>&lt;/</span><span>button</span><span>&gt;</span>
        <span>&lt;</span><span>b</span><span>&gt;</span><span>{</span><span>increment</span><span>}</span><span>&lt;/</span><span>b</span><span>&gt;</span>
        <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
          <span>setIncrement</span><span>(</span><span>i</span> <span>=&gt;</span> <span>i</span> + <span>1</span><span>)</span><span>;</span>
        <span>}</span><span>}</span><span>&gt;</span>+<span>&lt;/</span><span>button</span><span>&gt;</span>
      <span>&lt;/</span><span>p</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre>
<p>Let’s say that you wanted to run the Effect “only on mount”. You’ve read that <a href="lifecycle-of-reactive-effects.html#what-an-effect-with-empty-dependencies-means">empty (<code dir="ltr">[]</code>) dependencies</a> do that, so you’ve decided to ignore the linter, and forcefully specified <code dir="ltr">[]</code> as the dependencies.</p>
<p>This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you “lied” to React that this Effect doesn’t depend on anything, React forever keeps using the <code dir="ltr">onTick</code> function from the initial render. <a href="state-as-a-snapshot.html#rendering-takes-a-snapshot-in-time">During that render,</a> <code dir="ltr">count</code> was <code dir="ltr">0</code> and <code dir="ltr">increment</code> was <code dir="ltr">1</code>. This is why <code dir="ltr">onTick</code> from that render always calls <code dir="ltr">setCount(0 + 1)</code> every second, and you always see <code dir="ltr">1</code>. Bugs like this are harder to fix when they’re spread across multiple components.</p>
<p>There’s always a better solution than ignoring the linter! To fix this code, you need to add <code dir="ltr">onTick</code> to the dependency list. (To ensure the interval is only setup once, <a href="separating-events-from-effects.html#reading-latest-props-and-state-with-effect-events">make <code dir="ltr">onTick</code> an Effect Event.</a>)</p>
<p><strong>We recommend treating the dependency lint error as a compilation error. If you don’t suppress it, you will never see bugs like this.</strong> The rest of this page documents the alternatives for this and other cases.</p>
</div></details> <h2 id="removing-unnecessary-dependencies">Removing unnecessary dependencies 
</h2> <p>Every time you adjust the Effect’s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is “no”:</p> <ul> <li>You might want to re-execute <em>different parts</em> of your Effect under different conditions.</li> <li>You might want to only read the <em>latest value</em> of some dependency instead of “reacting” to its changes.</li> <li>A dependency may change too often <em>unintentionally</em> because it’s an object or a function.</li> </ul> <p>To find the right solution, you’ll need to answer a few questions about your Effect. Let’s walk through them.</p> <h3 id="should-this-code-move-to-an-event-handler">Should this code move to an event handler? 
</h3> <p>The first thing you should think about is whether this code should be an Effect at all.</p> <p>Imagine a form. On submit, you set the <code dir="ltr">submitted</code> state variable to <code dir="ltr">true</code>. You need to send a POST request and show a notification. You’ve put this logic inside an Effect that “reacts” to <code dir="ltr">submitted</code> being <code dir="ltr">true</code>:</p> <pre data-language="jsx"><code><span>function</span> <span>Form</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>submitted</span><span>,</span> <span>setSubmitted</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>submitted</span><span>)</span> <span>{</span>
      <span>// 🔴 Avoid: Event-specific logic inside an Effect</span>
      <span>post</span><span>(</span><span>'/api/register'</span><span>)</span><span>;</span>
      <span>showNotification</span><span>(</span><span>'Successfully registered!'</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>submitted</span><span>]</span><span>)</span><span>;</span>

  <span>function</span> <span>handleSubmit</span><span>(</span><span>)</span> <span>{</span>
    <span>setSubmitted</span><span>(</span><span>true</span><span>)</span><span>;</span>
  <span>}</span>

  <span>// ...</span>
<span>}</span></code></pre> <p>Later, you want to style the notification message according to the current theme, so you read the current theme. Since <code dir="ltr">theme</code> is declared in the component body, it is a reactive value, so you add it as a dependency:</p> <pre data-language="jsx"><code><span>function</span> <span>Form</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>submitted</span><span>,</span> <span>setSubmitted</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  <span>const</span> <span>theme</span> = <span>useContext</span><span>(</span><span>ThemeContext</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>submitted</span><span>)</span> <span>{</span>
      <span>// 🔴 Avoid: Event-specific logic inside an Effect</span>
      <span>post</span><span>(</span><span>'/api/register'</span><span>)</span><span>;</span>
      <span>showNotification</span><span>(</span><span>'Successfully registered!'</span><span>,</span> <span>theme</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>submitted</span><span>,</span> <span>theme</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>

  <span>function</span> <span>handleSubmit</span><span>(</span><span>)</span> <span>{</span>
    <span>setSubmitted</span><span>(</span><span>true</span><span>)</span><span>;</span>
  <span>}</span>  

  <span>// ...</span>
<span>}</span></code></pre> <p>By doing this, you’ve introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. The <code dir="ltr">theme</code> will change, the Effect will re-run, and so it will display the same notification again!</p> <p><strong>The problem here is that this shouldn’t be an Effect in the first place.</strong> You want to send this POST request and show the notification in response to <em>submitting the form,</em> which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler:</p> <pre data-language="jsx"><code><span>function</span> <span>Form</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>theme</span> = <span>useContext</span><span>(</span><span>ThemeContext</span><span>)</span><span>;</span>

  <span>function</span> <span>handleSubmit</span><span>(</span><span>)</span> <span>{</span>
    <span>// ✅ Good: Event-specific logic is called from event handlers</span>
    <span>post</span><span>(</span><span>'/api/register'</span><span>)</span><span>;</span>
    <span>showNotification</span><span>(</span><span>'Successfully registered!'</span><span>,</span> <span>theme</span><span>)</span><span>;</span>
  <span>}</span>  

  <span>// ...</span>
<span>}</span></code></pre> <p>Now that the code is in an event handler, it’s not reactive—so it will only run when the user submits the form. Read more about <a href="separating-events-from-effects.html#reactive-values-and-reactive-logic">choosing between event handlers and Effects</a> and <a href="you-might-not-need-an-effect.html">how to delete unnecessary Effects.</a></p> <h3 id="is-your-effect-doing-several-unrelated-things">Is your Effect doing several unrelated things? 
</h3> <p>The next question you should ask yourself is whether your Effect is doing several unrelated things.</p> <p>Imagine you’re creating a shipping form where the user needs to choose their city and area. You fetch the list of <code dir="ltr">cities</code> from the server according to the selected <code dir="ltr">country</code> to show them in a dropdown:</p> <pre data-language="jsx"><code><span>function</span> <span>ShippingForm</span><span>(</span><span>{</span> <span>country</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>cities</span><span>,</span> <span>setCities</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>city</span><span>,</span> <span>setCity</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>let</span> <span>ignore</span> = <span>false</span><span>;</span>
    <span>fetch</span><span>(</span><span>`/api/cities?country=</span><span>${</span><span>country</span><span>}</span><span>`</span><span>)</span>
      .<span>then</span><span>(</span><span>response</span> <span>=&gt;</span> <span>response</span>.<span>json</span><span>(</span><span>)</span><span>)</span>
      .<span>then</span><span>(</span><span>json</span> <span>=&gt;</span> <span>{</span>
        <span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span>
          <span>setCities</span><span>(</span><span>json</span><span>)</span><span>;</span>
        <span>}</span>
      <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>ignore</span> = <span>true</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>country</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>

  <span>// ...</span></code></pre> <p>This is a good example of <a href="you-might-not-need-an-effect.html#fetching-data">fetching data in an Effect.</a> You are synchronizing the <code dir="ltr">cities</code> state with the network according to the <code dir="ltr">country</code> prop. You can’t do this in an event handler because you need to fetch as soon as <code dir="ltr">ShippingForm</code> is displayed and whenever the <code dir="ltr">country</code> changes (no matter which interaction causes it).</p> <p>Now let’s say you’re adding a second select box for city areas, which should fetch the <code dir="ltr">areas</code> for the currently selected <code dir="ltr">city</code>. You might start by adding a second <code dir="ltr">fetch</code> call for the list of areas inside the same Effect:</p> <pre data-language="jsx"><code><span>function</span> <span>ShippingForm</span><span>(</span><span>{</span> <span>country</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>cities</span><span>,</span> <span>setCities</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>city</span><span>,</span> <span>setCity</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>areas</span><span>,</span> <span>setAreas</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>let</span> <span>ignore</span> = <span>false</span><span>;</span>
    <span>fetch</span><span>(</span><span>`/api/cities?country=</span><span>${</span><span>country</span><span>}</span><span>`</span><span>)</span>
      .<span>then</span><span>(</span><span>response</span> <span>=&gt;</span> <span>response</span>.<span>json</span><span>(</span><span>)</span><span>)</span>
      .<span>then</span><span>(</span><span>json</span> <span>=&gt;</span> <span>{</span>
        <span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span>
          <span>setCities</span><span>(</span><span>json</span><span>)</span><span>;</span>
        <span>}</span>
      <span>}</span><span>)</span><span>;</span>
    <span>// 🔴 Avoid: A single Effect synchronizes two independent processes</span>
    <span>if</span> <span>(</span><span>city</span><span>)</span> <span>{</span>
      <span>fetch</span><span>(</span><span>`/api/areas?city=</span><span>${</span><span>city</span><span>}</span><span>`</span><span>)</span>
        .<span>then</span><span>(</span><span>response</span> <span>=&gt;</span> <span>response</span>.<span>json</span><span>(</span><span>)</span><span>)</span>
        .<span>then</span><span>(</span><span>json</span> <span>=&gt;</span> <span>{</span>
          <span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span>
            <span>setAreas</span><span>(</span><span>json</span><span>)</span><span>;</span>
          <span>}</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>ignore</span> = <span>true</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>country</span><span>,</span> <span>city</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>

  <span>// ...</span></code></pre> <p>However, since the Effect now uses the <code dir="ltr">city</code> state variable, you’ve had to add <code dir="ltr">city</code> to the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and call <code dir="ltr">fetchCities(country)</code>. As a result, you will be unnecessarily refetching the list of cities many times.</p> <p><strong>The problem with this code is that you’re synchronizing two different unrelated things:</strong></p> <ol> <li>You want to synchronize the <code dir="ltr">cities</code> state to the network based on the <code dir="ltr">country</code> prop.</li> <li>You want to synchronize the <code dir="ltr">areas</code> state to the network based on the <code dir="ltr">city</code> state.</li> </ol> <p>Split the logic into two Effects, each of which reacts to the prop that it needs to synchronize with:</p> <pre data-language="jsx"><code><span>function</span> <span>ShippingForm</span><span>(</span><span>{</span> <span>country</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>cities</span><span>,</span> <span>setCities</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>let</span> <span>ignore</span> = <span>false</span><span>;</span>
    <span>fetch</span><span>(</span><span>`/api/cities?country=</span><span>${</span><span>country</span><span>}</span><span>`</span><span>)</span>
      .<span>then</span><span>(</span><span>response</span> <span>=&gt;</span> <span>response</span>.<span>json</span><span>(</span><span>)</span><span>)</span>
      .<span>then</span><span>(</span><span>json</span> <span>=&gt;</span> <span>{</span>
        <span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span>
          <span>setCities</span><span>(</span><span>json</span><span>)</span><span>;</span>
        <span>}</span>
      <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>ignore</span> = <span>true</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>country</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>

  <span>const</span> <span>[</span><span>city</span><span>,</span> <span>setCity</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>areas</span><span>,</span> <span>setAreas</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>city</span><span>)</span> <span>{</span>
      <span>let</span> <span>ignore</span> = <span>false</span><span>;</span>
      <span>fetch</span><span>(</span><span>`/api/areas?city=</span><span>${</span><span>city</span><span>}</span><span>`</span><span>)</span>
        .<span>then</span><span>(</span><span>response</span> <span>=&gt;</span> <span>response</span>.<span>json</span><span>(</span><span>)</span><span>)</span>
        .<span>then</span><span>(</span><span>json</span> <span>=&gt;</span> <span>{</span>
          <span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span>
            <span>setAreas</span><span>(</span><span>json</span><span>)</span><span>;</span>
          <span>}</span>
        <span>}</span><span>)</span><span>;</span>
      <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
        <span>ignore</span> = <span>true</span><span>;</span>
      <span>}</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>city</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>

  <span>// ...</span></code></pre> <p>Now the first Effect only re-runs if the <code dir="ltr">country</code> changes, while the second Effect re-runs when the <code dir="ltr">city</code> changes. You’ve separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they won’t trigger each other unintentionally.</p> <p>The final code is longer than the original, but splitting these Effects is still correct. <a href="lifecycle-of-reactive-effects.html#each-effect-represents-a-separate-synchronization-process">Each Effect should represent an independent synchronization process.</a> In this example, deleting one Effect doesn’t break the other Effect’s logic. This means they <em>synchronize different things,</em> and it’s good to split them up. If you’re concerned about duplication, you can improve this code by <a href="reusing-logic-with-custom-hooks.html#when-to-use-custom-hooks">extracting repetitive logic into a custom Hook.</a></p> <h3 id="are-you-reading-some-state-to-calculate-the-next-state">Are you reading some state to calculate the next state? 
</h3> <p>This Effect updates the <code dir="ltr">messages</code> state variable with a newly created array every time a new message arrives:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>messages</span><span>,</span> <span>setMessages</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>on</span><span>(</span><span>'message'</span><span>,</span> <span>(</span><span>receivedMessage</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setMessages</span><span>(</span><span>[</span><span>...</span><span>messages</span><span>,</span> <span>receivedMessage</span><span>]</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
    <span>// ...</span></code></pre> <p>It uses the <code dir="ltr">messages</code> variable to <a href="updating-arrays-in-state.html">create a new array</a> starting with all the existing messages and adds the new message at the end. However, since <code dir="ltr">messages</code> is a reactive value read by an Effect, it must be a dependency:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>messages</span><span>,</span> <span>setMessages</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>on</span><span>(</span><span>'message'</span><span>,</span> <span>(</span><span>receivedMessage</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setMessages</span><span>(</span><span>[</span><span>...</span><span>messages</span><span>,</span> <span>receivedMessage</span><span>]</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>,</span> <span>messages</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>And making <code dir="ltr">messages</code> a dependency introduces a problem.</p> <p>Every time you receive a message, <code dir="ltr">setMessages()</code> causes the component to re-render with a new <code dir="ltr">messages</code> array that includes the received message. However, since this Effect now depends on <code dir="ltr">messages</code>, this will <em>also</em> re-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that!</p> <p>To fix the issue, don’t read <code dir="ltr">messages</code> inside the Effect. Instead, pass an <a href="../reference/react/usestate.html#updating-state-based-on-the-previous-state">updater function</a> to <code dir="ltr">setMessages</code>:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>messages</span><span>,</span> <span>setMessages</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>on</span><span>(</span><span>'message'</span><span>,</span> <span>(</span><span>receivedMessage</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setMessages</span><span>(</span><span>msgs</span> <span>=&gt;</span> <span>[</span><span>...</span><span>msgs</span><span>,</span> <span>receivedMessage</span><span>]</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p><strong>Notice how your Effect does not read the <code dir="ltr">messages</code> variable at all now.</strong> You only need to pass an updater function like <code dir="ltr">msgs =&gt; [...msgs, receivedMessage]</code>. React <a href="queueing-a-series-of-state-updates.html">puts your updater function in a queue</a> and will provide the <code dir="ltr">msgs</code> argument to it during the next render. This is why the Effect itself doesn’t need to depend on <code dir="ltr">messages</code> anymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect.</p> <h3 id="do-you-want-to-read-a-value-without-reacting-to-its-changes">Do you want to read a value without “reacting” to its changes? 
</h3> <div class="note note-orange">
<h4>Under Construction</h4>
<div><p>This section describes an <strong>experimental API that has not yet been released</strong> in a stable version of React.</p></div>
</div> <p>Suppose that you want to play a sound when the user receives a new message unless <code dir="ltr">isMuted</code> is <code dir="ltr">true</code>:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>messages</span><span>,</span> <span>setMessages</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>isMuted</span><span>,</span> <span>setIsMuted</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>on</span><span>(</span><span>'message'</span><span>,</span> <span>(</span><span>receivedMessage</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setMessages</span><span>(</span><span>msgs</span> <span>=&gt;</span> <span>[</span><span>...</span><span>msgs</span><span>,</span> <span>receivedMessage</span><span>]</span><span>)</span><span>;</span>
      <span>if</span> <span>(</span>!<span>isMuted</span><span>)</span> <span>{</span>
        <span>playSound</span><span>(</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>// ...</span></code></pre> <p>Since your Effect now uses <code dir="ltr">isMuted</code> in its code, you have to add it to the dependencies:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>messages</span><span>,</span> <span>setMessages</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>isMuted</span><span>,</span> <span>setIsMuted</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>on</span><span>(</span><span>'message'</span><span>,</span> <span>(</span><span>receivedMessage</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setMessages</span><span>(</span><span>msgs</span> <span>=&gt;</span> <span>[</span><span>...</span><span>msgs</span><span>,</span> <span>receivedMessage</span><span>]</span><span>)</span><span>;</span>
      <span>if</span> <span>(</span>!<span>isMuted</span><span>)</span> <span>{</span>
        <span>playSound</span><span>(</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>,</span> <span>isMuted</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>The problem is that every time <code dir="ltr">isMuted</code> changes (for example, when the user presses the “Muted” toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not work—if you do that, <code dir="ltr">isMuted</code> would get “stuck” with its old value.)</p> <p>To solve this problem, you need to extract the logic that shouldn’t be reactive out of the Effect. You don’t want this Effect to “react” to the changes in <code dir="ltr">isMuted</code>. <a href="separating-events-from-effects.html#declaring-an-effect-event">Move this non-reactive piece of logic into an Effect Event:</a></p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span><span>,</span> <span>useEffectEvent</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>messages</span><span>,</span> <span>setMessages</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>isMuted</span><span>,</span> <span>setIsMuted</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>

  <span>const</span> <span>onMessage</span> = <span>useEffectEvent</span><span>(</span><span>receivedMessage</span> <span>=&gt;</span> <span>{</span>
    <span>setMessages</span><span>(</span><span>msgs</span> <span>=&gt;</span> <span>[</span><span>...</span><span>msgs</span><span>,</span> <span>receivedMessage</span><span>]</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>!<span>isMuted</span><span>)</span> <span>{</span>
      <span>playSound</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>on</span><span>(</span><span>'message'</span><span>,</span> <span>(</span><span>receivedMessage</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>onMessage</span><span>(</span><span>receivedMessage</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>Effect Events let you split an Effect into reactive parts (which should “react” to reactive values like <code dir="ltr">roomId</code> and their changes) and non-reactive parts (which only read their latest values, like <code dir="ltr">onMessage</code> reads <code dir="ltr">isMuted</code>). <strong>Now that you read <code dir="ltr">isMuted</code> inside an Effect Event, it doesn’t need to be a dependency of your Effect.</strong> As a result, the chat won’t re-connect when you toggle the “Muted” setting on and off, solving the original issue!</p> <h4 id="wrapping-an-event-handler-from-the-props">Wrapping an event handler from the props 
</h4> <p>You might run into a similar problem when your component receives an event handler as a prop:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span><span>,</span> <span>onReceiveMessage</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>messages</span><span>,</span> <span>setMessages</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>on</span><span>(</span><span>'message'</span><span>,</span> <span>(</span><span>receivedMessage</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>onReceiveMessage</span><span>(</span><span>receivedMessage</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>,</span> <span>onReceiveMessage</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>Suppose that the parent component passes a <em>different</em> <code dir="ltr">onReceiveMessage</code> function on every render:</p> <pre data-language="jsx"><code><span>&lt;</span><span>ChatRoom</span>
  <span>roomId</span>=<span>{</span><span>roomId</span><span>}</span>
  <span>onReceiveMessage</span>=<span>{</span><span>receivedMessage</span> <span>=&gt;</span> <span>{</span>
    <span>// ...</span>
  <span>}</span><span>}</span>
<span>/&gt;</span></code></pre> <p>Since <code dir="ltr">onReceiveMessage</code> is a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span><span>,</span> <span>onReceiveMessage</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>messages</span><span>,</span> <span>setMessages</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>

  <span>const</span> <span>onMessage</span> = <span>useEffectEvent</span><span>(</span><span>receivedMessage</span> <span>=&gt;</span> <span>{</span>
    <span>onReceiveMessage</span><span>(</span><span>receivedMessage</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>on</span><span>(</span><span>'message'</span><span>,</span> <span>(</span><span>receivedMessage</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>onMessage</span><span>(</span><span>receivedMessage</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>Effect Events aren’t reactive, so you don’t need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function that’s different on every re-render.</p> <h4 id="separating-reactive-and-non-reactive-code">Separating reactive and non-reactive code 
</h4> <p>In this example, you want to log a visit every time <code dir="ltr">roomId</code> changes. You want to include the current <code dir="ltr">notificationCount</code> with every log, but you <em>don’t</em> want a change to <code dir="ltr">notificationCount</code> to trigger a log event.</p> <p>The solution is again to split out the non-reactive code into an Effect Event:</p> <pre data-language="jsx"><code><span>function</span> <span>Chat</span><span>(</span><span>{</span> <span>roomId</span><span>,</span> <span>notificationCount</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>onVisit</span> = <span>useEffectEvent</span><span>(</span><span>visitedRoomId</span> <span>=&gt;</span> <span>{</span>
    <span>logVisit</span><span>(</span><span>visitedRoomId</span><span>,</span> <span>notificationCount</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>onVisit</span><span>(</span><span>roomId</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span>
<span>}</span></code></pre> <p>You want your logic to be reactive with regards to <code dir="ltr">roomId</code>, so you read <code dir="ltr">roomId</code> inside of your Effect. However, you don’t want a change to <code dir="ltr">notificationCount</code> to log an extra visit, so you read <code dir="ltr">notificationCount</code> inside of the Effect Event. <a href="separating-events-from-effects.html#reading-latest-props-and-state-with-effect-events">Learn more about reading the latest props and state from Effects using Effect Events.</a></p> <h3 id="does-some-reactive-value-change-unintentionally">Does some reactive value change unintentionally? 
</h3> <p>Sometimes, you <em>do</em> want your Effect to “react” to a certain value, but that value changes more often than you’d like—and might not reflect any actual change from the user’s perspective. For example, let’s say that you create an <code dir="ltr">options</code> object in the body of your component, and then read that object from inside of your Effect:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>// ...</span>
  <span>const</span> <span>options</span> = <span>{</span>
    <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
    <span>roomId</span><span>:</span> <span>roomId</span>
  <span>}</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>// ...</span></code></pre> <p>This object is declared in the component body, so it’s a <a href="lifecycle-of-reactive-effects.html#effects-react-to-reactive-values">reactive value.</a> When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect “reacts” to its changes:</p> <pre data-language="jsx"><code>  <span>// ...</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>options</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>It is important to declare it as a dependency! This ensures, for example, that if the <code dir="ltr">roomId</code> changes, your Effect will re-connect to the chat with the new <code dir="ltr">options</code>. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>// Temporarily disable the linter to demonstrate the problem</span>
  <span>// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  <span>const</span> <span>options</span> = <span>{</span>
    <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
    <span>roomId</span><span>:</span> <span>roomId</span>
  <span>}</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>options</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the <span>{</span><span>roomId</span><span>}</span> room!<span>&lt;/</span><span>h1</span><span>&gt;</span>
      <span>&lt;</span><span>input</span> <span>value</span>=<span>{</span><span>message</span><span>}</span> <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setMessage</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>roomId</span><span>,</span> <span>setRoomId</span><span>]</span> = <span>useState</span><span>(</span><span>'general'</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>label</span><span>&gt;</span>
        Choose the chat room:<span>{</span><span>' '</span><span>}</span>
        <span>&lt;</span><span>select</span>
          <span>value</span>=<span>{</span><span>roomId</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setRoomId</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span>
        <span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"general"</span><span>&gt;</span>general<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"travel"</span><span>&gt;</span>travel<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"music"</span><span>&gt;</span>music<span>&lt;/</span><span>option</span><span>&gt;</span>
        <span>&lt;/</span><span>select</span><span>&gt;</span>
      <span>&lt;/</span><span>label</span><span>&gt;</span>
      <span>&lt;</span><span>hr</span> <span>/&gt;</span>
      <span>&lt;</span><span>ChatRoom</span> <span>roomId</span>=<span>{</span><span>roomId</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>In the sandbox above, the input only updates the <code dir="ltr">message</code> state variable. From the user’s perspective, this should not affect the chat connection. However, every time you update the <code dir="ltr">message</code>, your component re-renders. When your component re-renders, the code inside of it runs again from scratch.</p> <p>A new <code dir="ltr">options</code> object is created from scratch on every re-render of the <code dir="ltr">ChatRoom</code> component. React sees that the <code dir="ltr">options</code> object is a <em>different object</em> from the <code dir="ltr">options</code> object created during the last render. This is why it re-synchronizes your Effect (which depends on <code dir="ltr">options</code>), and the chat re-connects as you type.</p> <p><strong>This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesn’t matter that the contents inside of them may be the same!</strong></p> <pre data-language="jsx"><code><span>// During the first render</span>
<span>const</span> <span>options1</span> = <span>{</span> <span>serverUrl</span><span>:</span> <span>'https://localhost:1234'</span><span>,</span> <span>roomId</span><span>:</span> <span>'music'</span> <span>}</span><span>;</span>

<span>// During the next render</span>
<span>const</span> <span>options2</span> = <span>{</span> <span>serverUrl</span><span>:</span> <span>'https://localhost:1234'</span><span>,</span> <span>roomId</span><span>:</span> <span>'music'</span> <span>}</span><span>;</span>

<span>// These are two different objects!</span>
<span>console</span>.<span>log</span><span>(</span><span>Object</span>.<span>is</span><span>(</span><span>options1</span><span>,</span> <span>options2</span><span>)</span><span>)</span><span>;</span> <span>// false</span></code></pre> <p><strong>Object and function dependencies can make your Effect re-synchronize more often than you need.</strong></p> <p>This is why, whenever possible, you should try to avoid objects and functions as your Effect’s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them.</p> <h4 id="move-static-objects-and-functions-outside-your-component">Move static objects and functions outside your component 
</h4> <p>If the object does not depend on any props and state, you can move that object outside your component:</p> <pre data-language="jsx"><code><span>const</span> <span>options</span> = <span>{</span>
  <span>serverUrl</span><span>:</span> <span>'https://localhost:1234'</span><span>,</span>
  <span>roomId</span><span>:</span> <span>'music'</span>
<span>}</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>This way, you <em>prove</em> to the linter that it’s not reactive. It can’t change as a result of a re-render, so it doesn’t need to be a dependency. Now re-rendering <code dir="ltr">ChatRoom</code> won’t cause your Effect to re-synchronize.</p> <p>This works for functions too:</p> <pre data-language="jsx"><code><span>function</span> <span>createOptions</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>{</span>
    <span>serverUrl</span><span>:</span> <span>'https://localhost:1234'</span><span>,</span>
    <span>roomId</span><span>:</span> <span>'music'</span>
  <span>}</span><span>;</span>
<span>}</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>options</span> = <span>createOptions</span><span>(</span><span>)</span><span>;</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>Since <code dir="ltr">createOptions</code> is declared outside your component, it’s not a reactive value. This is why it doesn’t need to be specified in your Effect’s dependencies, and why it won’t ever cause your Effect to re-synchronize.</p> <h4 id="move-dynamic-objects-and-functions-inside-your-effect">Move dynamic objects and functions inside your Effect 
</h4> <p>If your object depends on some reactive value that may change as a result of a re-render, like a <code dir="ltr">roomId</code> prop, you can’t pull it <em>outside</em> your component. You can, however, move its creation <em>inside</em> of your Effect’s code:</p> <pre data-language="jsx"><code><span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>options</span> = <span>{</span>
      <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
      <span>roomId</span><span>:</span> <span>roomId</span>
    <span>}</span><span>;</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>Now that <code dir="ltr">options</code> is declared inside of your Effect, it is no longer a dependency of your Effect. Instead, the only reactive value used by your Effect is <code dir="ltr">roomId</code>. Since <code dir="ltr">roomId</code> is not an object or function, you can be sure that it won’t be <em>unintentionally</em> different. In JavaScript, numbers and strings are compared by their content:</p> <pre data-language="jsx"><code><span>// During the first render</span>
<span>const</span> <span>roomId1</span> = <span>'music'</span><span>;</span>

<span>// During the next render</span>
<span>const</span> <span>roomId2</span> = <span>'music'</span><span>;</span>

<span>// These two strings are the same!</span>
<span>console</span>.<span>log</span><span>(</span><span>Object</span>.<span>is</span><span>(</span><span>roomId1</span><span>,</span> <span>roomId2</span><span>)</span><span>)</span><span>;</span> <span>// true</span></code></pre> <p>Thanks to this fix, the chat no longer re-connects if you edit the input:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>options</span> = <span>{</span>
      <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
      <span>roomId</span><span>:</span> <span>roomId</span>
    <span>}</span><span>;</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the <span>{</span><span>roomId</span><span>}</span> room!<span>&lt;/</span><span>h1</span><span>&gt;</span>
      <span>&lt;</span><span>input</span> <span>value</span>=<span>{</span><span>message</span><span>}</span> <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setMessage</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>roomId</span><span>,</span> <span>setRoomId</span><span>]</span> = <span>useState</span><span>(</span><span>'general'</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>label</span><span>&gt;</span>
        Choose the chat room:<span>{</span><span>' '</span><span>}</span>
        <span>&lt;</span><span>select</span>
          <span>value</span>=<span>{</span><span>roomId</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setRoomId</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span>
        <span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"general"</span><span>&gt;</span>general<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"travel"</span><span>&gt;</span>travel<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"music"</span><span>&gt;</span>music<span>&lt;/</span><span>option</span><span>&gt;</span>
        <span>&lt;/</span><span>select</span><span>&gt;</span>
      <span>&lt;/</span><span>label</span><span>&gt;</span>
      <span>&lt;</span><span>hr</span> <span>/&gt;</span>
      <span>&lt;</span><span>ChatRoom</span> <span>roomId</span>=<span>{</span><span>roomId</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>However, it <em>does</em> re-connect when you change the <code dir="ltr">roomId</code> dropdown, as you would expect.</p> <p>This works for functions, too:</p> <pre data-language="jsx"><code><span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>function</span> <span>createOptions</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>{</span>
        <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
        <span>roomId</span><span>:</span> <span>roomId</span>
      <span>}</span><span>;</span>
    <span>}</span>

    <span>const</span> <span>options</span> = <span>createOptions</span><span>(</span><span>)</span><span>;</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>You can write your own functions to group pieces of logic inside your Effect. As long as you also declare them <em>inside</em> your Effect, they’re not reactive values, and so they don’t need to be dependencies of your Effect.</p> <h4 id="read-primitive-values-from-objects">Read primitive values from objects 
</h4> <p>Sometimes, you may receive an object from props:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>options</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>options</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>The risk here is that the parent component will create the object during rendering:</p> <pre data-language="jsx"><code><span>&lt;</span><span>ChatRoom</span>
  <span>roomId</span>=<span>{</span><span>roomId</span><span>}</span>
  <span>options</span>=<span>{</span><span>{</span>
    <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
    <span>roomId</span><span>:</span> <span>roomId</span>
  <span>}</span><span>}</span>
<span>/&gt;</span></code></pre> <p>This would cause your Effect to re-connect every time the parent component re-renders. To fix this, read information from the object <em>outside</em> the Effect, and avoid having object and function dependencies:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>options</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>const</span> <span>{</span> <span>roomId</span><span>,</span> <span>serverUrl</span> <span>}</span> = <span>options</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>{</span>
      <span>roomId</span><span>:</span> <span>roomId</span><span>,</span>
      <span>serverUrl</span><span>:</span> <span>serverUrl</span>
    <span>}</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>,</span> <span>serverUrl</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>The logic gets a little repetitive (you read some values from an object outside an Effect, and then create an object with the same values inside the Effect). But it makes it very explicit what information your Effect <em>actually</em> depends on. If an object is re-created unintentionally by the parent component, the chat would not re-connect. However, if <code dir="ltr">options.roomId</code> or <code dir="ltr">options.serverUrl</code> really are different, the chat would re-connect.</p> <h4 id="calculate-primitive-values-from-functions">Calculate primitive values from functions 
</h4> <p>The same approach can work for functions. For example, suppose the parent component passes a function:</p> <pre data-language="jsx"><code><span>&lt;</span><span>ChatRoom</span>
  <span>roomId</span>=<span>{</span><span>roomId</span><span>}</span>
  <span>getOptions</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
      <span>roomId</span><span>:</span> <span>roomId</span>
    <span>}</span><span>;</span>
  <span>}</span><span>}</span>
<span>/&gt;</span></code></pre> <p>To avoid making it a dependency (and causing it to re-connect on re-renders), call it outside the Effect. This gives you the <code dir="ltr">roomId</code> and <code dir="ltr">serverUrl</code> values that aren’t objects, and that you can read from inside your Effect:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>getOptions</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>const</span> <span>{</span> <span>roomId</span><span>,</span> <span>serverUrl</span> <span>}</span> = <span>getOptions</span><span>(</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>{</span>
      <span>roomId</span><span>:</span> <span>roomId</span><span>,</span>
      <span>serverUrl</span><span>:</span> <span>serverUrl</span>
    <span>}</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>,</span> <span>serverUrl</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span></code></pre> <p>This only works for <a href="keeping-components-pure.html">pure</a> functions because they are safe to call during rendering. If your function is an event handler, but you don’t want its changes to re-synchronize your Effect, <a href="#do-you-want-to-read-a-value-without-reacting-to-its-changes">wrap it into an Effect Event instead.</a></p> <section><h2 id="recap">Recap
</h2>
<ul> <li>Dependencies should always match the code.</li> <li>When you’re not happy with your dependencies, what you need to edit is the code.</li> <li>Suppressing the linter leads to very confusing bugs, and you should always avoid it.</li> <li>To remove a dependency, you need to “prove” to the linter that it’s not necessary.</li> <li>If some code should run in response to a specific interaction, move that code to an event handler.</li> <li>If different parts of your Effect should re-run for different reasons, split it into several Effects.</li> <li>If you want to update some state based on the previous state, pass an updater function.</li> <li>If you want to read the latest value without “reacting” it, extract an Effect Event from your Effect.</li> <li>In JavaScript, objects and functions are considered different if they were created at different times.</li> <li>Try to avoid object and function dependencies. Move them outside the component or inside the Effect.</li> </ul></section> <div class="note">
<h4>Try out some challenges</h4>

<div>
<h4 id="fix-a-resetting-interval">
<div>Challenge 1 of 4<span>: </span>
</div>Fix a resetting interval 
</h4>
<p>This Effect sets up an interval that ticks every second. You’ve noticed something strange happening: it seems like the interval gets destroyed and re-created every time it ticks. Fix the code so that the interval doesn’t get constantly re-created.</p>

<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Timer</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>count</span><span>,</span> <span>setCount</span><span>]</span> = <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>console</span>.<span>log</span><span>(</span><span>'✅ Creating an interval'</span><span>)</span><span>;</span>
    <span>const</span> <span>id</span> = <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>console</span>.<span>log</span><span>(</span><span>'⏰ Interval tick'</span><span>)</span><span>;</span>
      <span>setCount</span><span>(</span><span>count</span> + <span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>console</span>.<span>log</span><span>(</span><span>'❌ Clearing an interval'</span><span>)</span><span>;</span>
      <span>clearInterval</span><span>(</span><span>id</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>count</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Counter: <span>{</span><span>count</span><span>}</span><span>&lt;/</span><span>h1</span><span>&gt;</span>
<span>}</span>

</pre>
</div>

</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013&ndash;present Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://react.dev/learn/removing-effect-dependencies" class="_attribution-link">https://react.dev/learn/removing-effect-dependencies</a>
  </p>
</div>
