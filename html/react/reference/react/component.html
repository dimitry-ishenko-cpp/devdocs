<h1>Component
</h1>
<div class="note note-orange">
<h4>Pitfall</h4>
<div><p>We recommend defining components as functions instead of classes. <a href="#alternatives">See how to migrate.</a></p></div>
</div> <div>
<p><code dir="ltr">Component</code> is the base class for the React components defined as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="nofollow noopener noreferrer">JavaScript classes.</a> Class components are still supported by React, but we don’t recommend using them in new code.</p>
<pre data-language="jsx"><code><span>class</span> Greeting <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Hello, <span>{</span><span>this</span>.<span>props</span>.<span>name</span><span>}</span>!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>
</div> <ul>
<li>
<a href="#reference">Reference </a><ul>
<li><a href="#component"><code dir="ltr">Component</code> </a></li>
<li><a href="#context"><code dir="ltr">context</code> </a></li>
<li><a href="#props"><code dir="ltr">props</code> </a></li>
<li><a href="#state"><code dir="ltr">state</code> </a></li>
<li><a href="#constructor"><code dir="ltr">constructor(props)</code> </a></li>
<li><a href="#componentdidcatch"><code dir="ltr">componentDidCatch(error, info)</code> </a></li>
<li><a href="#componentdidmount"><code dir="ltr">componentDidMount()</code> </a></li>
<li><a href="#componentdidupdate"><code dir="ltr">componentDidUpdate(prevProps, prevState, snapshot?)</code> </a></li>
<li><a href="#componentwillmount"><code dir="ltr">componentWillMount()</code> </a></li>
<li><a href="#componentwillreceiveprops"><code dir="ltr">componentWillReceiveProps(nextProps)</code> </a></li>
<li><a href="#componentwillupdate"><code dir="ltr">componentWillUpdate(nextProps, nextState)</code> </a></li>
<li><a href="#componentwillunmount"><code dir="ltr">componentWillUnmount()</code> </a></li>
<li><a href="#forceupdate"><code dir="ltr">forceUpdate(callback?)</code> </a></li>
<li><a href="#getsnapshotbeforeupdate"><code dir="ltr">getSnapshotBeforeUpdate(prevProps, prevState)</code> </a></li>
<li><a href="#render"><code dir="ltr">render()</code> </a></li>
<li><a href="#setstate"><code dir="ltr">setState(nextState, callback?)</code> </a></li>
<li><a href="#shouldcomponentupdate"><code dir="ltr">shouldComponentUpdate(nextProps, nextState, nextContext)</code> </a></li>
<li><a href="#unsafe_componentwillmount"><code dir="ltr">UNSAFE_componentWillMount()</code> </a></li>
<li><a href="#unsafe_componentwillreceiveprops"><code dir="ltr">UNSAFE_componentWillReceiveProps(nextProps, nextContext)</code> </a></li>
<li><a href="#unsafe_componentwillupdate"><code dir="ltr">UNSAFE_componentWillUpdate(nextProps, nextState)</code> </a></li>
<li><a href="#static-contexttype"><code dir="ltr">static contextType</code> </a></li>
<li><a href="#static-defaultprops"><code dir="ltr">static defaultProps</code> </a></li>
<li><a href="#static-getderivedstatefromerror"><code dir="ltr">static getDerivedStateFromError(error)</code> </a></li>
<li><a href="#static-getderivedstatefromprops"><code dir="ltr">static getDerivedStateFromProps(props, state)</code> </a></li>
</ul>
</li>
<li>
<a href="#usage">Usage </a><ul>
<li><a href="#defining-a-class-component">Defining a class component </a></li>
<li><a href="#adding-state-to-a-class-component">Adding state to a class component </a></li>
<li><a href="#adding-lifecycle-methods-to-a-class-component">Adding lifecycle methods to a class component </a></li>
<li><a href="#catching-rendering-errors-with-an-error-boundary">Catching rendering errors with an error boundary </a></li>
</ul>
</li>
<li>
<a href="#alternatives">Alternatives </a><ul>
<li><a href="#migrating-a-simple-component-from-a-class-to-a-function">Migrating a simple component from a class to a function </a></li>
<li><a href="#migrating-a-component-with-state-from-a-class-to-a-function">Migrating a component with state from a class to a function </a></li>
<li><a href="#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function">Migrating a component with lifecycle methods from a class to a function </a></li>
<li><a href="#migrating-a-component-with-context-from-a-class-to-a-function">Migrating a component with context from a class to a function </a></li>
</ul>
</li>
</ul> <hr> <h2 id="reference">Reference 
</h2> <h3 id="component">
<code dir="ltr">Component</code> 
</h3> <p>To define a React component as a class, extend the built-in <code dir="ltr">Component</code> class and define a <a href="#render"><code dir="ltr">render</code> method:</a></p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>Component</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>class</span> Greeting <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Hello, <span>{</span><span>this</span>.<span>props</span>.<span>name</span><span>}</span>!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>Only the <code dir="ltr">render</code> method is required, other methods are optional.</p> <p><a href="#usage">See more examples below.</a></p> <hr> <h3 id="context">
<code dir="ltr">context</code> 
</h3> <p>The <a href="../../learn/passing-data-deeply-with-context.html">context</a> of a class component is available as <code dir="ltr">this.context</code>. It is only available if you specify <em>which</em> context you want to receive using <a href="#static-contexttype"><code dir="ltr">static contextType</code></a>.</p> <p>A class component can only read one context at a time.</p> <pre data-language="jsx"><code><span>class</span> Button <span>extends</span> <span>Component</span> <span>{</span>
  <span>static</span> <span>contextType</span> = <span>ThemeContext</span><span>;</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>theme</span> = <span>this</span>.<span>context</span><span>;</span>
    <span>const</span> <span>className</span> = <span>'button-'</span> + <span>theme</span><span>;</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>button</span> <span>className</span>=<span>{</span><span>className</span><span>}</span><span>&gt;</span>
        <span>{</span><span>this</span>.<span>props</span>.<span>children</span><span>}</span>
      <span>&lt;/</span><span>button</span><span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <div class="note note-green">
<h4>Note</h4>
<div>
<p>Reading <code dir="ltr">this.context</code> in class components is equivalent to <a href="usecontext.html"><code dir="ltr">useContext</code></a> in function components.</p>
<p><a href="#migrating-a-component-with-context-from-a-class-to-a-function">See how to migrate.</a></p>
</div>
</div> <hr> <h3 id="props">
<code dir="ltr">props</code> 
</h3> <p>The props passed to a class component are available as <code dir="ltr">this.props</code>.</p> <pre data-language="jsx"><code><span>class</span> Greeting <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Hello, <span>{</span><span>this</span>.<span>props</span>.<span>name</span><span>}</span>!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>&lt;</span><span>Greeting</span> <span>name</span>=<span>"Taylor"</span> <span>/&gt;</span></code></pre> <div class="note note-green">
<h4>Note</h4>
<div>
<p>Reading <code dir="ltr">this.props</code> in class components is equivalent to <a href="../../learn/passing-props-to-a-component.html#step-2-read-props-inside-the-child-component">declaring props</a> in function components.</p>
<p><a href="#migrating-a-simple-component-from-a-class-to-a-function">See how to migrate.</a></p>
</div>
</div> <hr> <h3 id="state">
<code dir="ltr">state</code> 
</h3> <p>The state of a class component is available as <code dir="ltr">this.state</code>. The <code dir="ltr">state</code> field must be an object. Do not mutate the state directly. If you wish to change the state, call <code dir="ltr">setState</code> with the new state.</p> <pre data-language="jsx"><code><span>class</span> Counter <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>age</span><span>:</span> <span>42</span><span>,</span>
  <span>}</span><span>;</span>

  <span>handleAgeChange</span> = <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>this</span>.<span>setState</span><span>(</span><span>{</span>
      <span>age</span><span>:</span> <span>this</span>.<span>state</span>.<span>age</span> + <span>1</span> 
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>&gt;</span>
        <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>this</span>.<span>handleAgeChange</span><span>}</span><span>&gt;</span>
        Increment age
        <span>&lt;/</span><span>button</span><span>&gt;</span>
        <span>&lt;</span><span>p</span><span>&gt;</span>You are <span>{</span><span>this</span>.<span>state</span>.<span>age</span><span>}</span>.<span>&lt;/</span><span>p</span><span>&gt;</span>
      <span>&lt;/</span><span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <div class="note note-green">
<h4>Note</h4>
<div>
<p>Defining <code dir="ltr">state</code> in class components is equivalent to calling <a href="usestate.html"><code dir="ltr">useState</code></a> in function components.</p>
<p><a href="#migrating-a-component-with-state-from-a-class-to-a-function">See how to migrate.</a></p>
</div>
</div> <hr> <h3 id="constructor">
<code dir="ltr">constructor(props)</code> 
</h3> <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor" target="_blank" rel="nofollow noopener noreferrer">constructor</a> runs before your class component <em>mounts</em> (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="nofollow noopener noreferrer">bind</a> your class methods to the class instance:</p> <pre data-language="jsx"><code><span>class</span> Counter <span>extends</span> <span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span><span>props</span><span>)</span><span>;</span>
    <span>this</span>.<span>state</span> = <span>{</span> <span>counter</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
    <span>this</span>.<span>handleClick</span> = <span>this</span>.<span>handleClick</span>.<span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
  <span>}</span>

  <span>handleClick</span><span>(</span><span>)</span> <span>{</span>
    <span>// ...</span>
  <span>}</span></code></pre> <p>If you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields" target="_blank" rel="nofollow noopener noreferrer">public class field syntax</a> which is supported both by modern browsers and tools like <a href="https://babeljs.io/" target="_blank" rel="nofollow noopener noreferrer">Babel:</a></p> <pre data-language="jsx"><code><span>class</span> Counter <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span> <span>counter</span><span>:</span> <span>0</span> <span>}</span><span>;</span>

  <span>handleClick</span> = <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// ...</span>
  <span>}</span></code></pre> <p>A constructor should not contain any side effects or subscriptions.</p> <h4 id="constructor-parameters">Parameters 
</h4> <ul> <li>
<code dir="ltr">props</code>: The component’s initial props.</li> </ul> <h4 id="constructor-returns">Returns 
</h4> <p><code dir="ltr">constructor</code> should not return anything.</p> <h4 id="constructor-caveats">Caveats 
</h4> <ul> <li> <p>Do not run any side effects or subscriptions in the constructor. Instead, use <a href="#componentdidmount"><code dir="ltr">componentDidMount</code></a> for that.</p> </li> <li> <p>Inside a constructor, you need to call <code dir="ltr">super(props)</code> before any other statement. If you don’t do that, <code dir="ltr">this.props</code> will be <code dir="ltr">undefined</code> while the constructor runs, which can be confusing and cause bugs.</p> </li> <li> <p>Constructor is the only place where you can assign <a href="#state"><code dir="ltr">this.state</code></a> directly. In all other methods, you need to use <a href="#setstate"><code dir="ltr">this.setState()</code></a> instead. Do not call <code dir="ltr">setState</code> in the constructor.</p> </li> <li> <p>When you use <a href="../react-dom/server.html">server rendering,</a> the constructor will run on the server too, followed by the <a href="#render"><code dir="ltr">render</code></a> method. However, lifecycle methods like <code dir="ltr">componentDidMount</code> or <code dir="ltr">componentWillUnmount</code> will not run on the server.</p> </li> <li> <p>When <a href="strictmode.html">Strict Mode</a> is on, React will call <code dir="ltr">constructor</code> twice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of the <code dir="ltr">constructor</code>.</p> </li> </ul> <div class="note note-green">
<h4>Note</h4>
<div><p>There is no exact equivalent for <code dir="ltr">constructor</code> in function components. To declare state in a function component, call <a href="usestate.html"><code dir="ltr">useState</code>.</a> To avoid recalculating the initial state, <a href="usestate.html#avoiding-recreating-the-initial-state">pass a function to <code dir="ltr">useState</code>.</a></p></div>
</div> <hr> <h3 id="componentdidcatch">
<code dir="ltr">componentDidCatch(error, info)</code> 
</h3> <p>If you define <code dir="ltr">componentDidCatch</code>, React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.</p> <p>Typically, it is used together with <a href="#static-getderivedstatefromerror"><code dir="ltr">static getDerivedStateFromError</code></a> which lets you update state in response to an error and display an error message to the user. A component with these methods is called an <em>error boundary.</em></p> <p><a href="#catching-rendering-errors-with-an-error-boundary">See an example.</a></p> <h4 id="componentdidcatch-parameters">Parameters 
</h4> <ul> <li> <p><code dir="ltr">error</code>: The error that was thrown. In practice, it will usually be an instance of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">Error</code></a> but this is not guaranteed because JavaScript allows to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">throw</code></a> any value, including strings or even <code dir="ltr">null</code>.</p> </li> <li> <p><code dir="ltr">info</code>: An object containing additional information about the error. Its <code dir="ltr">componentStack</code> field contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.</p> </li> </ul> <h4 id="componentdidcatch-returns">Returns 
</h4> <p><code dir="ltr">componentDidCatch</code> should not return anything.</p> <h4 id="componentdidcatch-caveats">Caveats 
</h4> <ul> <li> <p>In the past, it was common to call <code dir="ltr">setState</code> inside <code dir="ltr">componentDidCatch</code> in order to update the UI and display the fallback error message. This is deprecated in favor of defining <a href="#static-getderivedstatefromerror"><code dir="ltr">static getDerivedStateFromError</code>.</a></p> </li> <li> <p>Production and development builds of React slightly differ in the way <code dir="ltr">componentDidCatch</code> handles errors. In development, the errors will bubble up to <code dir="ltr">window</code>, which means that any <code dir="ltr">window.onerror</code> or <code dir="ltr">window.addEventListener('error', callback)</code> will intercept the errors that have been caught by <code dir="ltr">componentDidCatch</code>. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by <code dir="ltr">componentDidCatch</code>.</p> </li> </ul> <div class="note note-green">
<h4>Note</h4>
<div><p>There is no direct equivalent for <code dir="ltr">componentDidCatch</code> in function components yet. If you’d like to avoid creating class components, write a single <code dir="ltr">ErrorBoundary</code> component like above and use it throughout your app. Alternatively, you can use the <a href="https://github.com/bvaughn/react-error-boundary" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">react-error-boundary</code></a> package which does that for you.</p></div>
</div> <hr> <h3 id="componentdidmount">
<code dir="ltr">componentDidMount()</code> 
</h3> <p>If you define the <code dir="ltr">componentDidMount</code> method, React will call it when your component is added <em>(mounted)</em> to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.</p> <p>If you implement <code dir="ltr">componentDidMount</code>, you usually need to implement other lifecycle methods to avoid bugs. For example, if <code dir="ltr">componentDidMount</code> reads some state or props, you also have to implement <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code></a> to handle their changes, and <a href="#componentwillunmount"><code dir="ltr">componentWillUnmount</code></a> to clean up whatever <code dir="ltr">componentDidMount</code> was doing.</p> <pre data-language="jsx"><code><span>class</span> ChatRoom <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>serverUrl</span><span>:</span> <span>'https://localhost:1234'</span>
  <span>}</span><span>;</span>

  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>setupConnection</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>componentDidUpdate</span><span>(</span><span>prevProps</span><span>,</span> <span>prevState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>
      <span>this</span>.<span>props</span>.<span>roomId</span> !== <span>prevProps</span>.<span>roomId</span> ||
      <span>this</span>.<span>state</span>.<span>serverUrl</span> !== <span>prevState</span>.<span>serverUrl</span>
    <span>)</span> <span>{</span>
      <span>this</span>.<span>destroyConnection</span><span>(</span><span>)</span><span>;</span>
      <span>this</span>.<span>setupConnection</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>destroyConnection</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>// ...</span>
<span>}</span></code></pre> <p><a href="#adding-lifecycle-methods-to-a-class-component">See more examples.</a></p> <h4 id="componentdidmount-parameters">Parameters 
</h4> <p><code dir="ltr">componentDidMount</code> does not take any parameters.</p> <h4 id="componentdidmount-returns">Returns 
</h4> <p><code dir="ltr">componentDidMount</code> should not return anything.</p> <h4 id="componentdidmount-caveats">Caveats 
</h4> <ul> <li> <p>When <a href="strictmode.html">Strict Mode</a> is on, in development React will call <code dir="ltr">componentDidMount</code>, then immediately call <a href="#componentwillunmount"><code dir="ltr">componentWillUnmount</code>,</a> and then call <code dir="ltr">componentDidMount</code> again. This helps you notice if you forgot to implement <code dir="ltr">componentWillUnmount</code> or if its logic doesn’t fully “mirror” what <code dir="ltr">componentDidMount</code> does.</p> </li> <li> <p>Although you may call <a href="#setstate"><code dir="ltr">setState</code></a> immediately in <code dir="ltr">componentDidMount</code>, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the <a href="#render"><code dir="ltr">render</code></a> will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the <a href="#constructor"><code dir="ltr">constructor</code></a> instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.</p> </li> </ul> <div class="note note-green">
<h4>Note</h4>
<div>
<p>For many use cases, defining <code dir="ltr">componentDidMount</code>, <code dir="ltr">componentDidUpdate</code>, and <code dir="ltr">componentWillUnmount</code> together in class components is equivalent to calling <a href="useeffect.html"><code dir="ltr">useEffect</code></a> in function components. In the rare cases where it’s important for the code to run before browser paint, <a href="uselayouteffect.html"><code dir="ltr">useLayoutEffect</code></a> is a closer match.</p>
<p><a href="#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function">See how to migrate.</a></p>
</div>
</div> <hr> <h3 id="componentdidupdate">
<code dir="ltr">componentDidUpdate(prevProps, prevState, snapshot?)</code> 
</h3> <p>If you define the <code dir="ltr">componentDidUpdate</code> method, React will call it immediately after your component has been re-rendered with updated props or state. This method is not called for the initial render.</p> <p>You can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you’d use it together with <a href="#componentdidmount"><code dir="ltr">componentDidMount</code></a> and <a href="#componentwillunmount"><code dir="ltr">componentWillUnmount</code>:</a></p> <pre data-language="jsx"><code><span>class</span> ChatRoom <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>serverUrl</span><span>:</span> <span>'https://localhost:1234'</span>
  <span>}</span><span>;</span>

  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>setupConnection</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>componentDidUpdate</span><span>(</span><span>prevProps</span><span>,</span> <span>prevState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>
      <span>this</span>.<span>props</span>.<span>roomId</span> !== <span>prevProps</span>.<span>roomId</span> ||
      <span>this</span>.<span>state</span>.<span>serverUrl</span> !== <span>prevState</span>.<span>serverUrl</span>
    <span>)</span> <span>{</span>
      <span>this</span>.<span>destroyConnection</span><span>(</span><span>)</span><span>;</span>
      <span>this</span>.<span>setupConnection</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>destroyConnection</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>// ...</span>
<span>}</span></code></pre> <p><a href="#adding-lifecycle-methods-to-a-class-component">See more examples.</a></p> <h4 id="componentdidupdate-parameters">Parameters 
</h4> <ul> <li> <p><code dir="ltr">prevProps</code>: Props before the update. Compare <code dir="ltr">prevProps</code> to <a href="#props"><code dir="ltr">this.props</code></a> to determine what changed.</p> </li> <li> <p><code dir="ltr">prevState</code>: State before the update. Compare <code dir="ltr">prevState</code> to <a href="#state"><code dir="ltr">this.state</code></a> to determine what changed.</p> </li> <li> <p><code dir="ltr">snapshot</code>: If you implemented <a href="#getsnapshotbeforeupdate"><code dir="ltr">getSnapshotBeforeUpdate</code></a>, <code dir="ltr">snapshot</code> will contain the value you returned from that method. Otherwise, it will be <code dir="ltr">undefined</code>.</p> </li> </ul> <h4 id="componentdidupdate-returns">Returns 
</h4> <p><code dir="ltr">componentDidUpdate</code> should not return anything.</p> <h4 id="componentdidupdate-caveats">Caveats 
</h4> <ul> <li> <p><code dir="ltr">componentDidUpdate</code> will not get called if <a href="#shouldcomponentupdate"><code dir="ltr">shouldComponentUpdate</code></a> is defined and returns <code dir="ltr">false</code>.</p> </li> <li> <p>The logic inside <code dir="ltr">componentDidUpdate</code> should usually be wrapped in conditions comparing <code dir="ltr">this.props</code> with <code dir="ltr">prevProps</code>, and <code dir="ltr">this.state</code> with <code dir="ltr">prevState</code>. Otherwise, there’s a risk of creating infinite loops.</p> </li> <li> <p>Although you may call <a href="#setstate"><code dir="ltr">setState</code></a> immediately in <code dir="ltr">componentDidUpdate</code>, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the <a href="#render"><code dir="ltr">render</code></a> will be called twice in this case, the user won’t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.</p> </li> </ul> <div class="note note-green">
<h4>Note</h4>
<div>
<p>For many use cases, defining <code dir="ltr">componentDidMount</code>, <code dir="ltr">componentDidUpdate</code>, and <code dir="ltr">componentWillUnmount</code> together in class components is equivalent to calling <a href="useeffect.html"><code dir="ltr">useEffect</code></a> in function components. In the rare cases where it’s important for the code to run before browser paint, <a href="uselayouteffect.html"><code dir="ltr">useLayoutEffect</code></a> is a closer match.</p>
<p><a href="#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function">See how to migrate.</a></p>
</div>
</div> <hr> <h3 id="componentwillmount">
<code dir="ltr">componentWillMount()</code> 
</h3> <h3>
Deprecated</h3>
<div>
<p>This API has been renamed from <code dir="ltr">componentWillMount</code> to <a href="#unsafe_componentwillmount"><code dir="ltr">UNSAFE_componentWillMount</code>.</a> The old name has been deprecated. In a future major version of React, only the new name will work.</p>
<p>Run the <a href="https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">rename-unsafe-lifecycles</code> codemod</a> to automatically update your components.</p>
</div> <hr> <h3 id="componentwillreceiveprops">
<code dir="ltr">componentWillReceiveProps(nextProps)</code> 
</h3> <h3>
Deprecated</h3>
<div>
<p>This API has been renamed from <code dir="ltr">componentWillReceiveProps</code> to <a href="#unsafe_componentwillreceiveprops"><code dir="ltr">UNSAFE_componentWillReceiveProps</code>.</a> The old name has been deprecated. In a future major version of React, only the new name will work.</p>
<p>Run the <a href="https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">rename-unsafe-lifecycles</code> codemod</a> to automatically update your components.</p>
</div> <hr> <h3 id="componentwillupdate">
<code dir="ltr">componentWillUpdate(nextProps, nextState)</code> 
</h3> <h3>
Deprecated</h3>
<div>
<p>This API has been renamed from <code dir="ltr">componentWillUpdate</code> to <a href="#unsafe_componentwillupdate"><code dir="ltr">UNSAFE_componentWillUpdate</code>.</a> The old name has been deprecated. In a future major version of React, only the new name will work.</p>
<p>Run the <a href="https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">rename-unsafe-lifecycles</code> codemod</a> to automatically update your components.</p>
</div> <hr> <h3 id="componentwillunmount">
<code dir="ltr">componentWillUnmount()</code> 
</h3> <p>If you define the <code dir="ltr">componentWillUnmount</code> method, React will call it before your component is removed <em>(unmounted)</em> from the screen. This is a common place to cancel data fetching or remove subscriptions.</p> <p>The logic inside <code dir="ltr">componentWillUnmount</code> should “mirror” the logic inside <a href="#componentdidmount"><code dir="ltr">componentDidMount</code>.</a> For example, if <code dir="ltr">componentDidMount</code> sets up a subscription, <code dir="ltr">componentWillUnmount</code> should clean up that subscription. If the cleanup logic in your <code dir="ltr">componentWillUnmount</code> reads some props or state, you will usually also need to implement <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code></a> to clean up resources (such as subscriptions) corresponding to the old props and state.</p> <pre data-language="jsx"><code><span>class</span> ChatRoom <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>serverUrl</span><span>:</span> <span>'https://localhost:1234'</span>
  <span>}</span><span>;</span>

  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>setupConnection</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>componentDidUpdate</span><span>(</span><span>prevProps</span><span>,</span> <span>prevState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>
      <span>this</span>.<span>props</span>.<span>roomId</span> !== <span>prevProps</span>.<span>roomId</span> ||
      <span>this</span>.<span>state</span>.<span>serverUrl</span> !== <span>prevState</span>.<span>serverUrl</span>
    <span>)</span> <span>{</span>
      <span>this</span>.<span>destroyConnection</span><span>(</span><span>)</span><span>;</span>
      <span>this</span>.<span>setupConnection</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>destroyConnection</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>// ...</span>
<span>}</span></code></pre> <p><a href="#adding-lifecycle-methods-to-a-class-component">See more examples.</a></p> <h4 id="componentwillunmount-parameters">Parameters 
</h4> <p><code dir="ltr">componentWillUnmount</code> does not take any parameters.</p> <h4 id="componentwillunmount-returns">Returns 
</h4> <p><code dir="ltr">componentWillUnmount</code> should not return anything.</p> <h4 id="componentwillunmount-caveats">Caveats 
</h4> <ul> <li>When <a href="strictmode.html">Strict Mode</a> is on, in development React will call <a href="#componentdidmount"><code dir="ltr">componentDidMount</code>,</a> then immediately call <code dir="ltr">componentWillUnmount</code>, and then call <code dir="ltr">componentDidMount</code> again. This helps you notice if you forgot to implement <code dir="ltr">componentWillUnmount</code> or if its logic doesn’t fully “mirror” what <code dir="ltr">componentDidMount</code> does.</li> </ul> <div class="note note-green">
<h4>Note</h4>
<div>
<p>For many use cases, defining <code dir="ltr">componentDidMount</code>, <code dir="ltr">componentDidUpdate</code>, and <code dir="ltr">componentWillUnmount</code> together in class components is equivalent to calling <a href="useeffect.html"><code dir="ltr">useEffect</code></a> in function components. In the rare cases where it’s important for the code to run before browser paint, <a href="uselayouteffect.html"><code dir="ltr">useLayoutEffect</code></a> is a closer match.</p>
<p><a href="#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function">See how to migrate.</a></p>
</div>
</div> <hr> <h3 id="forceupdate">
<code dir="ltr">forceUpdate(callback?)</code> 
</h3> <p>Forces a component to re-render.</p> <p>Usually, this is not necessary. If your component’s <a href="#render"><code dir="ltr">render</code></a> method only reads from <a href="#props"><code dir="ltr">this.props</code></a>, <a href="#state"><code dir="ltr">this.state</code></a>, or <a href="#context"><code dir="ltr">this.context</code>,</a> it will re-render automatically when you call <a href="#setstate"><code dir="ltr">setState</code></a> inside your component or one of its parents. However, if your component’s <code dir="ltr">render</code> method reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That’s what <code dir="ltr">forceUpdate</code> lets you do.</p> <p>Try to avoid all uses of <code dir="ltr">forceUpdate</code> and only read from <code dir="ltr">this.props</code> and <code dir="ltr">this.state</code> in <code dir="ltr">render</code>.</p> <h4 id="forceupdate-parameters">Parameters 
</h4> <ul> <li>
<strong>optional</strong> <code dir="ltr">callback</code> If specified, React will call the <code dir="ltr">callback</code> you’ve provided after the update is committed.</li> </ul> <h4 id="forceupdate-returns">Returns 
</h4> <p><code dir="ltr">forceUpdate</code> does not return anything.</p> <h4 id="forceupdate-caveats">Caveats 
</h4> <ul> <li>If you call <code dir="ltr">forceUpdate</code>, React will re-render without calling <a href="#shouldcomponentupdate"><code dir="ltr">shouldComponentUpdate</code>.</a>
</li> </ul> <div class="note note-green">
<h4>Note</h4>
<div><p>Reading an external data source and forcing class components to re-render in response to its changes with <code dir="ltr">forceUpdate</code> has been superseded by <a href="usesyncexternalstore.html"><code dir="ltr">useSyncExternalStore</code></a> in function components.</p></div>
</div> <hr> <h3 id="getsnapshotbeforeupdate">
<code dir="ltr">getSnapshotBeforeUpdate(prevProps, prevState)</code> 
</h3> <p>If you implement <code dir="ltr">getSnapshotBeforeUpdate</code>, React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code>.</a></p> <p>For example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:</p> <pre data-language="jsx"><code><span>class</span> ScrollingList <span>extends</span> <span>React</span>.<span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span><span>props</span><span>)</span><span>;</span>
    <span>this</span>.<span>listRef</span> = <span>React</span>.<span>createRef</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>getSnapshotBeforeUpdate</span><span>(</span><span>prevProps</span><span>,</span> <span>prevState</span><span>)</span> <span>{</span>
    <span>// Are we adding new items to the list?</span>
    <span>// Capture the scroll position so we can adjust scroll later.</span>
    <span>if</span> <span>(</span><span>prevProps</span>.<span>list</span>.<span>length</span> &lt; <span>this</span>.<span>props</span>.<span>list</span>.<span>length</span><span>)</span> <span>{</span>
      <span>const</span> <span>list</span> = <span>this</span>.<span>listRef</span>.<span>current</span><span>;</span>
      <span>return</span> <span>list</span>.<span>scrollHeight</span> - <span>list</span>.<span>scrollTop</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
  <span>}</span>

  <span>componentDidUpdate</span><span>(</span><span>prevProps</span><span>,</span> <span>prevState</span><span>,</span> <span>snapshot</span><span>)</span> <span>{</span>
    <span>// If we have a snapshot value, we've just added new items.</span>
    <span>// Adjust scroll so these new items don't push the old ones out of view.</span>
    <span>// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span>
    <span>if</span> <span>(</span><span>snapshot</span> !== <span>null</span><span>)</span> <span>{</span>
      <span>const</span> <span>list</span> = <span>this</span>.<span>listRef</span>.<span>current</span><span>;</span>
      <span>list</span>.<span>scrollTop</span> = <span>list</span>.<span>scrollHeight</span> - <span>snapshot</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>div</span> <span>ref</span>=<span>{</span><span>this</span>.<span>listRef</span><span>}</span><span>&gt;</span><span>{</span><span>/* ...contents... */</span>}<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>In the above example, it is important to read the <code dir="ltr">scrollHeight</code> property directly in <code dir="ltr">getSnapshotBeforeUpdate</code>. It is not safe to read it in <a href="#render"><code dir="ltr">render</code></a>, <a href="#unsafe_componentwillreceiveprops"><code dir="ltr">UNSAFE_componentWillReceiveProps</code></a>, or <a href="#unsafe_componentwillupdate"><code dir="ltr">UNSAFE_componentWillUpdate</code></a> because there is a potential time gap between these methods getting called and React updating the DOM.</p> <h4 id="getsnapshotbeforeupdate-parameters">Parameters 
</h4> <ul> <li> <p><code dir="ltr">prevProps</code>: Props before the update. Compare <code dir="ltr">prevProps</code> to <a href="#props"><code dir="ltr">this.props</code></a> to determine what changed.</p> </li> <li> <p><code dir="ltr">prevState</code>: State before the update. Compare <code dir="ltr">prevState</code> to <a href="#state"><code dir="ltr">this.state</code></a> to determine what changed.</p> </li> </ul> <h4 id="getsnapshotbeforeupdate-returns">Returns 
</h4> <p>You should return a snapshot value of any type that you’d like, or <code dir="ltr">null</code>. The value you returned will be passed as the third argument to <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code>.</a></p> <h4 id="getsnapshotbeforeupdate-caveats">Caveats 
</h4> <ul> <li>
<code dir="ltr">getSnapshotBeforeUpdate</code> will not get called if <a href="#shouldcomponentupdate"><code dir="ltr">shouldComponentUpdate</code></a> is defined and returns <code dir="ltr">false</code>.</li> </ul> <div class="note note-green">
<h4>Note</h4>
<div><p>At the moment, there is no equivalent to <code dir="ltr">getSnapshotBeforeUpdate</code> for function components. This use case is very uncommon, but if you have the need for it, for now you’ll have to write a class component.</p></div>
</div> <hr> <h3 id="render">
<code dir="ltr">render()</code> 
</h3> <p>The <code dir="ltr">render</code> method is the only required method in a class component.</p> <p>The <code dir="ltr">render</code> method should specify what you want to appear on the screen, for example:</p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>Component</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>class</span> Greeting <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Hello, <span>{</span><span>this</span>.<span>props</span>.<span>name</span><span>}</span>!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>React may call <code dir="ltr">render</code> at any moment, so you shouldn’t assume that it runs at a particular time. Usually, the <code dir="ltr">render</code> method should return a piece of <a href="../../learn/writing-markup-with-jsx.html">JSX</a>, but a few <a href="#render-returns">other return types</a> (like strings) are supported. To calculate the returned JSX, the <code dir="ltr">render</code> method can read <a href="#props"><code dir="ltr">this.props</code></a>, <a href="#state"><code dir="ltr">this.state</code></a>, and <a href="#context"><code dir="ltr">this.context</code></a>.</p> <p>You should write the <code dir="ltr">render</code> method as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn’t contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods like <a href="#componentdidmount"><code dir="ltr">componentDidMount</code>.</a></p> <h4 id="render-parameters">Parameters 
</h4> <p><code dir="ltr">render</code> does not take any parameters.</p> <h4 id="render-returns">Returns 
</h4> <p><code dir="ltr">render</code> can return any valid React node. This includes React elements such as <code dir="ltr">&lt;div /&gt;</code>, strings, numbers, <a href="../react-dom/createportal.html">portals</a>, empty nodes (<code dir="ltr">null</code>, <code dir="ltr">undefined</code>, <code dir="ltr">true</code>, and <code dir="ltr">false</code>), and arrays of React nodes.</p> <h4 id="render-caveats">Caveats 
</h4> <ul> <li> <p><code dir="ltr">render</code> should be written as a pure function of props, state, and context. It should not have side effects.</p> </li> <li> <p><code dir="ltr">render</code> will not get called if <a href="#shouldcomponentupdate"><code dir="ltr">shouldComponentUpdate</code></a> is defined and returns <code dir="ltr">false</code>.</p> </li> <li> <p>When <a href="strictmode.html">Strict Mode</a> is on, React will call <code dir="ltr">render</code> twice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of the <code dir="ltr">render</code> method.</p> </li> <li> <p>There is no one-to-one correspondence between the <code dir="ltr">render</code> call and the subsequent <code dir="ltr">componentDidMount</code> or <code dir="ltr">componentDidUpdate</code> call. Some of the <code dir="ltr">render</code> call results may be discarded by React when it’s beneficial.</p> </li> </ul> <hr> <h3 id="setstate">
<code dir="ltr">setState(nextState, callback?)</code> 
</h3> <p>Call <code dir="ltr">setState</code> to update the state of your React component.</p> <pre data-language="jsx"><code><span>class</span> Form <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>name</span><span>:</span> <span>'Taylor'</span><span>,</span>
  <span>}</span><span>;</span>

  <span>handleNameChange</span> = <span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>newName</span> = <span>e</span>.<span>target</span>.<span>value</span><span>;</span>
    <span>this</span>.<span>setState</span><span>(</span><span>{</span>
      <span>name</span><span>:</span> <span>newName</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>&gt;</span>
        <span>&lt;</span><span>input</span> <span>value</span>=<span>{</span><span>this</span>.<span>state</span>.<span>name</span><span>}</span> <span>onChange</span>=<span>{</span><span>this</span>.<span>handleNameChange</span><span>}</span> <span>/&gt;</span>
        <span>&lt;</span><span>p</span><span>&gt;</span>Hello, <span>{</span><span>this</span>.<span>state</span>.<span>name</span><span>}</span>.<span>&lt;/</span><span>p</span><span>&gt;</span>
      <span>&lt;/</span><span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p><code dir="ltr">setState</code> enqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you’ll update the user interface in response to interactions.</p> <div class="note note-orange">
<h4>Pitfall</h4>
<div>
<p>Calling <code dir="ltr">setState</code> <strong>does not</strong> change the current state in the already executing code:</p>
<pre data-language="jsx"><code><span>function</span> <span>handleClick</span><span>(</span><span>)</span> <span>{</span>
  <span>console</span>.<span>log</span><span>(</span><span>this</span>.<span>state</span>.<span>name</span><span>)</span><span>;</span> <span>// "Taylor"</span>
  <span>this</span>.<span>setState</span><span>(</span><span>{</span>
    <span>name</span><span>:</span> <span>'Robin'</span>
  <span>}</span><span>)</span><span>;</span>
  <span>console</span>.<span>log</span><span>(</span><span>this</span>.<span>state</span>.<span>name</span><span>)</span><span>;</span> <span>// Still "Taylor"!</span>
<span>}</span></code></pre>
<p>It only affects what <code dir="ltr">this.state</code> will return starting from the <em>next</em> render.</p>
</div>
</div> <p>You can also pass a function to <code dir="ltr">setState</code>. It lets you update state based on the previous state:</p> <pre data-language="jsx"><code>  <span>handleIncreaseAge</span> = <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>this</span>.<span>setState</span><span>(</span><span>prevState</span> <span>=&gt;</span> <span>{</span>
      <span>return</span> <span>{</span>
        <span>age</span><span>:</span> <span>prevState</span>.<span>age</span> + <span>1</span>
      <span>}</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span></code></pre> <p>You don’t have to do this, but it’s handy if you want to update state multiple times during the same event.</p> <h4 id="setstate-parameters">Parameters 
</h4> <ul> <li> <p><code dir="ltr">nextState</code>: Either an object or a function.</p> <ul> <li>If you pass an object as <code dir="ltr">nextState</code>, it will be shallowly merged into <code dir="ltr">this.state</code>.</li> <li>If you pass a function as <code dir="ltr">nextState</code>, it will be treated as an <em>updater function</em>. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged into <code dir="ltr">this.state</code>. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.</li> </ul> </li> <li> <p><strong>optional</strong> <code dir="ltr">callback</code>: If specified, React will call the <code dir="ltr">callback</code> you’ve provided after the update is committed.</p> </li> </ul> <h4 id="setstate-returns">Returns 
</h4> <p><code dir="ltr">setState</code> does not return anything.</p> <h4 id="setstate-caveats">Caveats 
</h4> <ul> <li> <p>Think of <code dir="ltr">setState</code> as a <em>request</em> rather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it in <a href="../react-dom/flushsync.html"><code dir="ltr">flushSync</code>,</a> but this may hurt performance.</p> </li> <li> <p><code dir="ltr">setState</code> does not update <code dir="ltr">this.state</code> immediately. This makes reading <code dir="ltr">this.state</code> right after calling <code dir="ltr">setState</code> a potential pitfall. Instead, use <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code></a> or the setState <code dir="ltr">callback</code> argument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function to <code dir="ltr">nextState</code> as described above.</p> </li> </ul> <div class="note note-green">
<h4>Note</h4>
<div>
<p>Calling <code dir="ltr">setState</code> in class components is similar to calling a <a href="usestate.html#setstate"><code dir="ltr">set</code> function</a> in function components.</p>
<p><a href="#migrating-a-component-with-state-from-a-class-to-a-function">See how to migrate.</a></p>
</div>
</div> <hr> <h3 id="shouldcomponentupdate">
<code dir="ltr">shouldComponentUpdate(nextProps, nextState, nextContext)</code> 
</h3> <p>If you define <code dir="ltr">shouldComponentUpdate</code>, React will call it to determine whether a re-render can be skipped.</p> <p>If you are confident you want to write it by hand, you may compare <code dir="ltr">this.props</code> with <code dir="ltr">nextProps</code> and <code dir="ltr">this.state</code> with <code dir="ltr">nextState</code> and return <code dir="ltr">false</code> to tell React the update can be skipped.</p> <pre data-language="jsx"><code><span>class</span> Rectangle <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>isHovered</span><span>:</span> <span>false</span>
  <span>}</span><span>;</span>

  <span>shouldComponentUpdate</span><span>(</span><span>nextProps</span><span>,</span> <span>nextState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>
      <span>nextProps</span>.<span>position</span>.<span>x</span> === <span>this</span>.<span>props</span>.<span>position</span>.<span>x</span> &amp;&amp;
      <span>nextProps</span>.<span>position</span>.<span>y</span> === <span>this</span>.<span>props</span>.<span>position</span>.<span>y</span> &amp;&amp;
      <span>nextProps</span>.<span>size</span>.<span>width</span> === <span>this</span>.<span>props</span>.<span>size</span>.<span>width</span> &amp;&amp;
      <span>nextProps</span>.<span>size</span>.<span>height</span> === <span>this</span>.<span>props</span>.<span>size</span>.<span>height</span> &amp;&amp;
      <span>nextState</span>.<span>isHovered</span> === <span>this</span>.<span>state</span>.<span>isHovered</span>
    <span>)</span> <span>{</span>
      <span>// Nothing has changed, so a re-render is unnecessary</span>
      <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span>

  <span>// ...</span>
<span>}</span></code></pre> <p>React calls <code dir="ltr">shouldComponentUpdate</code> before rendering when new props or state are being received. Defaults to <code dir="ltr">true</code>. This method is not called for the initial render or when <a href="#forceupdate"><code dir="ltr">forceUpdate</code></a> is used.</p> <h4 id="shouldcomponentupdate-parameters">Parameters 
</h4> <ul> <li>
<code dir="ltr">nextProps</code>: The next props that the component is about to render with. Compare <code dir="ltr">nextProps</code> to <a href="#props"><code dir="ltr">this.props</code></a> to determine what changed.</li> <li>
<code dir="ltr">nextState</code>: The next state that the component is about to render with. Compare <code dir="ltr">nextState</code> to <a href="#props"><code dir="ltr">this.state</code></a> to determine what changed.</li> <li>
<code dir="ltr">nextContext</code>: The next context that the component is about to render with. Compare <code dir="ltr">nextContext</code> to <a href="#context"><code dir="ltr">this.context</code></a> to determine what changed. Only available if you specify <a href="#static-contexttype"><code dir="ltr">static contextType</code></a>.</li> </ul> <h4 id="shouldcomponentupdate-returns">Returns 
</h4> <p>Return <code dir="ltr">true</code> if you want the component to re-render. That’s the default behavior.</p> <p>Return <code dir="ltr">false</code> to tell React that re-rendering can be skipped.</p> <h4 id="shouldcomponentupdate-caveats">Caveats 
</h4> <ul> <li> <p>This method <em>only</em> exists as a performance optimization. If your component breaks without it, fix that first.</p> </li> <li> <p>Consider using <a href="purecomponent.html"><code dir="ltr">PureComponent</code></a> instead of writing <code dir="ltr">shouldComponentUpdate</code> by hand. <code dir="ltr">PureComponent</code> shallowly compares props and state, and reduces the chance that you’ll skip a necessary update.</p> </li> <li> <p>We do not recommend doing deep equality checks or using <code dir="ltr">JSON.stringify</code> in <code dir="ltr">shouldComponentUpdate</code>. It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.</p> </li> <li> <p>Returning <code dir="ltr">false</code> does not prevent child components from re-rendering when <em>their</em> state changes.</p> </li> <li> <p>Returning <code dir="ltr">false</code> does not <em>guarantee</em> that the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.</p> </li> </ul> <div class="note note-green">
<h4>Note</h4>
<div><p>Optimizing class components with <code dir="ltr">shouldComponentUpdate</code> is similar to optimizing function components with <a href="memo.html"><code dir="ltr">memo</code>.</a> Function components also offer more granular optimization with <a href="usememo.html"><code dir="ltr">useMemo</code>.</a></p></div>
</div> <hr> <h3 id="unsafe_componentwillmount">
<code dir="ltr">UNSAFE_componentWillMount()</code> 
</h3> <p>If you define <code dir="ltr">UNSAFE_componentWillMount</code>, React will call it immediately after the <a href="#constructor"><code dir="ltr">constructor</code>.</a> It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:</p> <ul> <li>To initialize state, declare <a href="#state"><code dir="ltr">state</code></a> as a class field or set <code dir="ltr">this.state</code> inside the <a href="#constructor"><code dir="ltr">constructor</code>.</a>
</li> <li>If you need to run a side effect or set up a subscription, move that logic to <a href="#componentdidmount"><code dir="ltr">componentDidMount</code></a> instead.</li> </ul> <p><a href="https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples" target="_blank" rel="nofollow noopener noreferrer">See examples of migrating away from unsafe lifecycles.</a></p> <h4 id="unsafe_componentwillmount-parameters">Parameters 
</h4> <p><code dir="ltr">UNSAFE_componentWillMount</code> does not take any parameters.</p> <h4 id="unsafe_componentwillmount-returns">Returns 
</h4> <p><code dir="ltr">UNSAFE_componentWillMount</code> should not return anything.</p> <h4 id="unsafe_componentwillmount-caveats">Caveats 
</h4> <ul> <li> <p><code dir="ltr">UNSAFE_componentWillMount</code> will not get called if the component implements <a href="#static-getderivedstatefromprops"><code dir="ltr">static getDerivedStateFromProps</code></a> or <a href="#getsnapshotbeforeupdate"><code dir="ltr">getSnapshotBeforeUpdate</code>.</a></p> </li> <li> <p>Despite its naming, <code dir="ltr">UNSAFE_componentWillMount</code> does not guarantee that the component <em>will</em> get mounted if your app uses modern React features like <a href="suspense.html"><code dir="ltr">Suspense</code>.</a> If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is “unsafe”. Code that relies on mounting (like adding a subscription) should go into <a href="#componentdidmount"><code dir="ltr">componentDidMount</code>.</a></p> </li> <li> <p><code dir="ltr">UNSAFE_componentWillMount</code> is the only lifecycle method that runs during <a href="../react-dom/server.html">server rendering.</a> For all practical purposes, it is identical to <a href="#constructor"><code dir="ltr">constructor</code>,</a> so you should use the <code dir="ltr">constructor</code> for this type of logic instead.</p> </li> </ul> <div class="note note-green">
<h4>Note</h4>
<div><p>Calling <a href="#setstate"><code dir="ltr">setState</code></a> inside <code dir="ltr">UNSAFE_componentWillMount</code> in a class component to initialize state is equivalent to passing that state as the initial state to <a href="usestate.html"><code dir="ltr">useState</code></a> in a function component.</p></div>
</div> <hr> <h3 id="unsafe_componentwillreceiveprops">
<code dir="ltr">UNSAFE_componentWillReceiveProps(nextProps, nextContext)</code> 
</h3> <p>If you define <code dir="ltr">UNSAFE_componentWillReceiveProps</code>, React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:</p> <ul> <li>If you need to <strong>run a side effect</strong> (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic to <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code></a> instead.</li> <li>If you need to <strong>avoid re-computing some data only when a prop changes,</strong> use a <a href="https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization" target="_blank" rel="nofollow noopener noreferrer">memoization helper</a> instead.</li> <li>If you need to <strong>“reset” some state when a prop changes,</strong> consider either making a component <a href="https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component" target="_blank" rel="nofollow noopener noreferrer">fully controlled</a> or <a href="https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key" target="_blank" rel="nofollow noopener noreferrer">fully uncontrolled with a key</a> instead.</li> <li>If you need to <strong>“adjust” some state when a prop changes,</strong> check whether you can compute all the necessary information from props alone during rendering. If you can’t, use <a href="component.html#static-getderivedstatefromprops"><code dir="ltr">static getDerivedStateFromProps</code></a> instead.</li> </ul> <p><a href="https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props" target="_blank" rel="nofollow noopener noreferrer">See examples of migrating away from unsafe lifecycles.</a></p> <h4 id="unsafe_componentwillreceiveprops-parameters">Parameters 
</h4> <ul> <li>
<code dir="ltr">nextProps</code>: The next props that the component is about to receive from its parent component. Compare <code dir="ltr">nextProps</code> to <a href="#props"><code dir="ltr">this.props</code></a> to determine what changed.</li> <li>
<code dir="ltr">nextContext</code>: The next context that the component is about to receive from the closest provider. Compare <code dir="ltr">nextContext</code> to <a href="#context"><code dir="ltr">this.context</code></a> to determine what changed. Only available if you specify <a href="#static-contexttype"><code dir="ltr">static contextType</code></a>.</li> </ul> <h4 id="unsafe_componentwillreceiveprops-returns">Returns 
</h4> <p><code dir="ltr">UNSAFE_componentWillReceiveProps</code> should not return anything.</p> <h4 id="unsafe_componentwillreceiveprops-caveats">Caveats 
</h4> <ul> <li> <p><code dir="ltr">UNSAFE_componentWillReceiveProps</code> will not get called if the component implements <a href="#static-getderivedstatefromprops"><code dir="ltr">static getDerivedStateFromProps</code></a> or <a href="#getsnapshotbeforeupdate"><code dir="ltr">getSnapshotBeforeUpdate</code>.</a></p> </li> <li> <p>Despite its naming, <code dir="ltr">UNSAFE_componentWillReceiveProps</code> does not guarantee that the component <em>will</em> receive those props if your app uses modern React features like <a href="suspense.html"><code dir="ltr">Suspense</code>.</a> If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go into <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code>.</a></p> </li> <li> <p><code dir="ltr">UNSAFE_componentWillReceiveProps</code> does not mean that the component has received <em>different</em> props than the last time. You need to compare <code dir="ltr">nextProps</code> and <code dir="ltr">this.props</code> yourself to check if something changed.</p> </li> <li> <p>React doesn’t call <code dir="ltr">UNSAFE_componentWillReceiveProps</code> with initial props during mounting. It only calls this method if some of component’s props are going to be updated. For example, calling <a href="#setstate"><code dir="ltr">setState</code></a> doesn’t generally trigger <code dir="ltr">UNSAFE_componentWillReceiveProps</code> inside the same component.</p> </li> </ul> <div class="note note-green">
<h4>Note</h4>
<div><p>Calling <a href="#setstate"><code dir="ltr">setState</code></a> inside <code dir="ltr">UNSAFE_componentWillReceiveProps</code> in a class component to “adjust” state is equivalent to <a href="usestate.html#storing-information-from-previous-renders">calling the <code dir="ltr">set</code> function from <code dir="ltr">useState</code> during rendering</a> in a function component.</p></div>
</div> <hr> <h3 id="unsafe_componentwillupdate">
<code dir="ltr">UNSAFE_componentWillUpdate(nextProps, nextState)</code> 
</h3> <p>If you define <code dir="ltr">UNSAFE_componentWillUpdate</code>, React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:</p> <ul> <li>If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic to <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code></a> instead.</li> <li>If you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it in <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code></a> later, read it inside <a href="#getsnapshotbeforeupdate"><code dir="ltr">getSnapshotBeforeUpdate</code></a> instead.</li> </ul> <p><a href="https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples" target="_blank" rel="nofollow noopener noreferrer">See examples of migrating away from unsafe lifecycles.</a></p> <h4 id="unsafe_componentwillupdate-parameters">Parameters 
</h4> <ul> <li>
<code dir="ltr">nextProps</code>: The next props that the component is about to render with. Compare <code dir="ltr">nextProps</code> to <a href="#props"><code dir="ltr">this.props</code></a> to determine what changed.</li> <li>
<code dir="ltr">nextState</code>: The next state that the component is about to render with. Compare <code dir="ltr">nextState</code> to <a href="#state"><code dir="ltr">this.state</code></a> to determine what changed.</li> </ul> <h4 id="unsafe_componentwillupdate-returns">Returns 
</h4> <p><code dir="ltr">UNSAFE_componentWillUpdate</code> should not return anything.</p> <h4 id="unsafe_componentwillupdate-caveats">Caveats 
</h4> <ul> <li> <p><code dir="ltr">UNSAFE_componentWillUpdate</code> will not get called if <a href="#shouldcomponentupdate"><code dir="ltr">shouldComponentUpdate</code></a> is defined and returns <code dir="ltr">false</code>.</p> </li> <li> <p><code dir="ltr">UNSAFE_componentWillUpdate</code> will not get called if the component implements <a href="#static-getderivedstatefromprops"><code dir="ltr">static getDerivedStateFromProps</code></a> or <a href="#getsnapshotbeforeupdate"><code dir="ltr">getSnapshotBeforeUpdate</code>.</a></p> </li> <li> <p>It’s not supported to call <a href="#setstate"><code dir="ltr">setState</code></a> (or any method that leads to <code dir="ltr">setState</code> being called, like dispatching a Redux action) during <code dir="ltr">componentWillUpdate</code>.</p> </li> <li> <p>Despite its naming, <code dir="ltr">UNSAFE_componentWillUpdate</code> does not guarantee that the component <em>will</em> update if your app uses modern React features like <a href="suspense.html"><code dir="ltr">Suspense</code>.</a> If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go into <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code>.</a></p> </li> <li> <p><code dir="ltr">UNSAFE_componentWillUpdate</code> does not mean that the component has received <em>different</em> props or state than the last time. You need to compare <code dir="ltr">nextProps</code> with <code dir="ltr">this.props</code> and <code dir="ltr">nextState</code> with <code dir="ltr">this.state</code> yourself to check if something changed.</p> </li> <li> <p>React doesn’t call <code dir="ltr">UNSAFE_componentWillUpdate</code> with initial props and state during mounting.</p> </li> </ul> <div class="note note-green">
<h4>Note</h4>
<div><p>There is no direct equivalent to <code dir="ltr">UNSAFE_componentWillUpdate</code> in function components.</p></div>
</div> <hr> <h3 id="static-contexttype">
<code dir="ltr">static contextType</code> 
</h3> <p>If you want to read <a href="#context-instance-field"><code dir="ltr">this.context</code></a> from your class component, you must specify which context it needs to read. The context you specify as the <code dir="ltr">static contextType</code> must be a value previously created by <a href="createcontext.html"><code dir="ltr">createContext</code>.</a></p> <pre data-language="jsx"><code><span>class</span> Button <span>extends</span> <span>Component</span> <span>{</span>
  <span>static</span> <span>contextType</span> = <span>ThemeContext</span><span>;</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>theme</span> = <span>this</span>.<span>context</span><span>;</span>
    <span>const</span> <span>className</span> = <span>'button-'</span> + <span>theme</span><span>;</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>button</span> <span>className</span>=<span>{</span><span>className</span><span>}</span><span>&gt;</span>
        <span>{</span><span>this</span>.<span>props</span>.<span>children</span><span>}</span>
      <span>&lt;/</span><span>button</span><span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <div class="note note-green">
<h4>Note</h4>
<div>
<p>Reading <code dir="ltr">this.context</code> in class components is equivalent to <a href="usecontext.html"><code dir="ltr">useContext</code></a> in function components.</p>
<p><a href="#migrating-a-component-with-context-from-a-class-to-a-function">See how to migrate.</a></p>
</div>
</div> <hr> <h3 id="static-defaultprops">
<code dir="ltr">static defaultProps</code> 
</h3> <p>You can define <code dir="ltr">static defaultProps</code> to set the default props for the class. They will be used for <code dir="ltr">undefined</code> and missing props, but not for <code dir="ltr">null</code> props.</p> <p>For example, here is how you define that the <code dir="ltr">color</code> prop should default to <code dir="ltr">'blue'</code>:</p> <pre data-language="jsx"><code><span>class</span> Button <span>extends</span> <span>Component</span> <span>{</span>
  <span>static</span> <span>defaultProps</span> = <span>{</span>
    <span>color</span><span>:</span> <span>'blue'</span>
  <span>}</span><span>;</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span><span>button</span> <span>className</span>=<span>{</span><span>this</span>.<span>props</span>.<span>color</span><span>}</span><span>&gt;</span>click me<span>&lt;/</span><span>button</span><span>&gt;</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>If the <code dir="ltr">color</code> prop is not provided or is <code dir="ltr">undefined</code>, it will be set by default to <code dir="ltr">'blue'</code>:</p> <pre data-language="jsx"><code><span>&lt;</span><span>&gt;</span>
  <span>{</span><span>/* this.props.color is "blue" */</span>}
  <span>&lt;</span><span>Button</span> <span>/&gt;</span>

  <span>{</span><span>/* this.props.color is "blue" */</span>}
  <span>&lt;</span><span>Button</span> <span>color</span>=<span>{</span><span>undefined</span><span>}</span> <span>/&gt;</span>

  <span>{</span><span>/* this.props.color is null */</span>}
  <span>&lt;</span><span>Button</span> <span>color</span>=<span>{</span><span>null</span><span>}</span> <span>/&gt;</span>

  <span>{</span><span>/* this.props.color is "red" */</span>}
  <span>&lt;</span><span>Button</span> <span>color</span>=<span>"red"</span> <span>/&gt;</span>
<span>&lt;/</span><span>&gt;</span></code></pre> <div class="note note-green">
<h4>Note</h4>
<div><p>Defining <code dir="ltr">defaultProps</code> in class components is similar to using <a href="../../learn/passing-props-to-a-component.html#specifying-a-default-value-for-a-prop">default values</a> in function components.</p></div>
</div> <hr> <h3 id="static-getderivedstatefromerror">
<code dir="ltr">static getDerivedStateFromError(error)</code> 
</h3> <p>If you define <code dir="ltr">static getDerivedStateFromError</code>, React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI.</p> <p>Typically, it is used together with <a href="#componentdidcatch"><code dir="ltr">componentDidCatch</code></a> which lets you send the error report to some analytics service. A component with these methods is called an <em>error boundary.</em></p> <p><a href="#catching-rendering-errors-with-an-error-boundary">See an example.</a></p> <h4 id="static-getderivedstatefromerror-parameters">Parameters 
</h4> <ul> <li>
<code dir="ltr">error</code>: The error that was thrown. In practice, it will usually be an instance of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">Error</code></a> but this is not guaranteed because JavaScript allows to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">throw</code></a> any value, including strings or even <code dir="ltr">null</code>.</li> </ul> <h4 id="static-getderivedstatefromerror-returns">Returns 
</h4> <p><code dir="ltr">static getDerivedStateFromError</code> should return the state telling the component to display the error message.</p> <h4 id="static-getderivedstatefromerror-caveats">Caveats 
</h4> <ul> <li>
<code dir="ltr">static getDerivedStateFromError</code> should be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implement <a href="#componentdidcatch"><code dir="ltr">componentDidCatch</code>.</a>
</li> </ul> <div class="note note-green">
<h4>Note</h4>
<div><p>There is no direct equivalent for <code dir="ltr">static getDerivedStateFromError</code> in function components yet. If you’d like to avoid creating class components, write a single <code dir="ltr">ErrorBoundary</code> component like above and use it throughout your app. Alternatively, use the <a href="https://github.com/bvaughn/react-error-boundary" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">react-error-boundary</code></a> package which does that.</p></div>
</div> <hr> <h3 id="static-getderivedstatefromprops">
<code dir="ltr">static getDerivedStateFromProps(props, state)</code> 
</h3> <p>If you define <code dir="ltr">static getDerivedStateFromProps</code>, React will call it right before calling <a href="#render"><code dir="ltr">render</code>,</a> both on the initial mount and on subsequent updates. It should return an object to update the state, or <code dir="ltr">null</code> to update nothing.</p> <p>This method exists for <a href="https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state" target="_blank" rel="nofollow noopener noreferrer">rare use cases</a> where the state depends on changes in props over time. For example, this <code dir="ltr">Form</code> component resets the <code dir="ltr">email</code> state when the <code dir="ltr">userID</code> prop changes:</p> <pre data-language="jsx"><code><span>class</span> Form <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>email</span><span>:</span> <span>this</span>.<span>props</span>.<span>defaultEmail</span><span>,</span>
    <span>prevUserID</span><span>:</span> <span>this</span>.<span>props</span>.<span>userID</span>
  <span>}</span><span>;</span>

  <span>static</span> <span>getDerivedStateFromProps</span><span>(</span><span>props</span><span>,</span> <span>state</span><span>)</span> <span>{</span>
    <span>// Any time the current user changes,</span>
    <span>// Reset any parts of state that are tied to that user.</span>
    <span>// In this simple example, that's just the email.</span>
    <span>if</span> <span>(</span><span>props</span>.<span>userID</span> !== <span>state</span>.<span>prevUserID</span><span>)</span> <span>{</span>
      <span>return</span> <span>{</span>
        <span>prevUserID</span><span>:</span> <span>props</span>.<span>userID</span><span>,</span>
        <span>email</span><span>:</span> <span>props</span>.<span>defaultEmail</span>
      <span>}</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
  <span>}</span>

  <span>// ...</span>
<span>}</span></code></pre> <p>Note that this pattern requires you to keep a previous value of the prop (like <code dir="ltr">userID</code>) in state (like <code dir="ltr">prevUserID</code>).</p> <div class="note note-orange">
<h4>Pitfall</h4>
<div>
<p>Deriving state leads to verbose code and makes your components difficult to think about. <a href="https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="nofollow noopener noreferrer">Make sure you’re familiar with simpler alternatives:</a></p>
<ul> <li>If you need to <strong>perform a side effect</strong> (for example, data fetching or an animation) in response to a change in props, use <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code></a> method instead.</li> <li>If you want to <strong>re-compute some data only when a prop changes,</strong> <a href="https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization" target="_blank" rel="nofollow noopener noreferrer">use a memoization helper instead.</a>
</li> <li>If you want to <strong>“reset” some state when a prop changes,</strong> consider either making a component <a href="https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component" target="_blank" rel="nofollow noopener noreferrer">fully controlled</a> or <a href="https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key" target="_blank" rel="nofollow noopener noreferrer">fully uncontrolled with a key</a> instead.</li> </ul>
</div>
</div> <h4 id="static-getderivedstatefromprops-parameters">Parameters 
</h4> <ul> <li>
<code dir="ltr">props</code>: The next props that the component is about to render with.</li> <li>
<code dir="ltr">state</code>: The next state that the component is about to render with.</li> </ul> <h4 id="static-getderivedstatefromprops-returns">Returns 
</h4> <p><code dir="ltr">static getDerivedStateFromProps</code> return an object to update the state, or <code dir="ltr">null</code> to update nothing.</p> <h4 id="static-getderivedstatefromprops-caveats">Caveats 
</h4> <ul> <li> <p>This method is fired on <em>every</em> render, regardless of the cause. This is different from <a href="#unsafe_cmoponentwillreceiveprops"><code dir="ltr">UNSAFE_componentWillReceiveProps</code></a>, which only fires when the parent causes a re-render and not as a result of a local <code dir="ltr">setState</code>.</p> </li> <li> <p>This method doesn’t have access to the component instance. If you’d like, you can reuse some code between <code dir="ltr">static getDerivedStateFromProps</code> and the other class methods by extracting pure functions of the component props and state outside the class definition.</p> </li> </ul> <div class="note note-green">
<h4>Note</h4>
<div><p>Implementing <code dir="ltr">static getDerivedStateFromProps</code> in a class component is equivalent to <a href="usestate.html#storing-information-from-previous-renders">calling the <code dir="ltr">set</code> function from <code dir="ltr">useState</code> during rendering</a> in a function component.</p></div>
</div> <hr> <h2 id="usage">Usage 
</h2> <h3 id="defining-a-class-component">Defining a class component 
</h3> <p>To define a React component as a class, extend the built-in <code dir="ltr">Component</code> class and define a <a href="#render"><code dir="ltr">render</code> method:</a></p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>Component</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>class</span> Greeting <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Hello, <span>{</span><span>this</span>.<span>props</span>.<span>name</span><span>}</span>!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>React will call your <a href="#render"><code dir="ltr">render</code></a> method whenever it needs to figure out what to display on the screen. Usually, you will return some <a href="../../learn/writing-markup-with-jsx.html">JSX</a> from it. Your <code dir="ltr">render</code> method should be a <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="nofollow noopener noreferrer">pure function:</a> it should only calculate the JSX.</p> <p>Similarly to <a href="../../learn/your-first-component.html#defining-a-component">function components,</a> a class component can <a href="../../learn/your-first-component.html#defining-a-component">receive information by props</a> from its parent component. However, the syntax for reading props is different. For example, if the parent component renders <code dir="ltr">&lt;Greeting name="Taylor" /&gt;</code>, then you can read the <code dir="ltr">name</code> prop from <a href="#props"><code dir="ltr">this.props</code></a>, like <code dir="ltr">this.props.name</code>:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>Component</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>class</span> Greeting <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Hello, <span>{</span><span>this</span>.<span>props</span>.<span>name</span><span>}</span>!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>Greeting</span> <span>name</span>=<span>"Sara"</span> <span>/&gt;</span>
      <span>&lt;</span><span>Greeting</span> <span>name</span>=<span>"Cahal"</span> <span>/&gt;</span>
      <span>&lt;</span><span>Greeting</span> <span>name</span>=<span>"Edite"</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>Note that Hooks (functions starting with <code dir="ltr">use</code>, like <a href="usestate.html"><code dir="ltr">useState</code></a>) are not supported inside class components.</p> <div class="note note-orange">
<h4>Pitfall</h4>
<div><p>We recommend defining components as functions instead of classes. <a href="#migrating-a-simple-component-from-a-class-to-a-function">See how to migrate.</a></p></div>
</div> <hr> <h3 id="adding-state-to-a-class-component">Adding state to a class component 
</h3> <p>To add <a href="../../learn/state-a-components-memory.html">state</a> to a class, assign an object to a property called <a href="#state"><code dir="ltr">state</code></a>. To update state, call <a href="#setstate"><code dir="ltr">this.setState</code></a>.</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>Component</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>export</span> <span>default</span> <span>class</span> Counter <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>name</span><span>:</span> <span>'Taylor'</span><span>,</span>
    <span>age</span><span>:</span> <span>42</span><span>,</span>
  <span>}</span><span>;</span>

  <span>handleNameChange</span> = <span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>this</span>.<span>setState</span><span>(</span><span>{</span>
      <span>name</span><span>:</span> <span>e</span>.<span>target</span>.<span>value</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span>

  <span>handleAgeChange</span> = <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>this</span>.<span>setState</span><span>(</span><span>{</span>
      <span>age</span><span>:</span> <span>this</span>.<span>state</span>.<span>age</span> + <span>1</span> 
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>&gt;</span>
        <span>&lt;</span><span>input</span>
          <span>value</span>=<span>{</span><span>this</span>.<span>state</span>.<span>name</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>this</span>.<span>handleNameChange</span><span>}</span>
        <span>/&gt;</span>
        <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>this</span>.<span>handleAgeChange</span><span>}</span><span>&gt;</span>
          Increment age
        <span>&lt;/</span><span>button</span><span>&gt;</span>
        <span>&lt;</span><span>p</span><span>&gt;</span>Hello, <span>{</span><span>this</span>.<span>state</span>.<span>name</span><span>}</span>. You are <span>{</span><span>this</span>.<span>state</span>.<span>age</span><span>}</span>.<span>&lt;/</span><span>p</span><span>&gt;</span>
      <span>&lt;/</span><span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

</pre> <div class="note note-orange">
<h4>Pitfall</h4>
<div><p>We recommend defining components as functions instead of classes. <a href="#migrating-a-component-with-state-from-a-class-to-a-function">See how to migrate.</a></p></div>
</div> <hr> <h3 id="adding-lifecycle-methods-to-a-class-component">Adding lifecycle methods to a class component 
</h3> <p>There are a few special methods you can define on your class.</p> <p>If you define the <a href="#componentdidmount"><code dir="ltr">componentDidMount</code></a> method, React will call it when your component is added <em>(mounted)</em> to the screen. React will call <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code></a> after your component re-renders due to changed props or state. React will call <a href="#componentwillunmount"><code dir="ltr">componentWillUnmount</code></a> after your component has been removed <em>(unmounted)</em> from the screen.</p> <p>If you implement <code dir="ltr">componentDidMount</code>, you usually need to implement all three lifecycles to avoid bugs. For example, if <code dir="ltr">componentDidMount</code> reads some state or props, you also have to implement <code dir="ltr">componentDidUpdate</code> to handle their changes, and <code dir="ltr">componentWillUnmount</code> to clean up whatever <code dir="ltr">componentDidMount</code> was doing.</p> <p>For example, this <code dir="ltr">ChatRoom</code> component keeps a chat connection synchronized with props and state:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>Component</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>export</span> <span>default</span> <span>class</span> ChatRoom <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>serverUrl</span><span>:</span> <span>'https://localhost:1234'</span>
  <span>}</span><span>;</span>

  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>setupConnection</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>componentDidUpdate</span><span>(</span><span>prevProps</span><span>,</span> <span>prevState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>
      <span>this</span>.<span>props</span>.<span>roomId</span> !== <span>prevProps</span>.<span>roomId</span> ||
      <span>this</span>.<span>state</span>.<span>serverUrl</span> !== <span>prevState</span>.<span>serverUrl</span>
    <span>)</span> <span>{</span>
      <span>this</span>.<span>destroyConnection</span><span>(</span><span>)</span><span>;</span>
      <span>this</span>.<span>setupConnection</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>destroyConnection</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>setupConnection</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>connection</span> = <span>createConnection</span><span>(</span>
      <span>this</span>.<span>state</span>.<span>serverUrl</span><span>,</span>
      <span>this</span>.<span>props</span>.<span>roomId</span>
    <span>)</span><span>;</span>
    <span>this</span>.<span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>    
  <span>}</span>

  <span>destroyConnection</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
    <span>this</span>.<span>connection</span> = <span>null</span><span>;</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>&gt;</span>
        <span>&lt;</span><span>label</span><span>&gt;</span>
          Server URL:<span>{</span><span>' '</span><span>}</span>
          <span>&lt;</span><span>input</span>
            <span>value</span>=<span>{</span><span>this</span>.<span>state</span>.<span>serverUrl</span><span>}</span>
            <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>{</span>
              <span>this</span>.<span>setState</span><span>(</span><span>{</span>
                <span>serverUrl</span><span>:</span> <span>e</span>.<span>target</span>.<span>value</span>
              <span>}</span><span>)</span><span>;</span>
            <span>}</span><span>}</span>
          <span>/&gt;</span>
        <span>&lt;/</span><span>label</span><span>&gt;</span>
        <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the <span>{</span><span>this</span>.<span>props</span>.<span>roomId</span><span>}</span> room!<span>&lt;/</span><span>h1</span><span>&gt;</span>
      <span>&lt;/</span><span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

</pre> <p>Note that in development when <a href="strictmode.html">Strict Mode</a> is on, React will call <code dir="ltr">componentDidMount</code>, immediately call <code dir="ltr">componentWillUnmount</code>, and then call <code dir="ltr">componentDidMount</code> again. This helps you notice if you forgot to implement <code dir="ltr">componentWillUnmount</code> or if its logic doesn’t fully “mirror” what <code dir="ltr">componentDidMount</code> does.</p> <div class="note note-orange">
<h4>Pitfall</h4>
<div><p>We recommend defining components as functions instead of classes. <a href="#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function">See how to migrate.</a></p></div>
</div> <hr> <h3 id="catching-rendering-errors-with-an-error-boundary">Catching rendering errors with an error boundary 
</h3> <p>By default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an <em>error boundary</em>. An error boundary is a special component that lets you display some fallback UI instead of the part that crashed—for example, an error message.</p> <p>To implement an error boundary component, you need to provide <a href="#static-getderivedstatefromerror"><code dir="ltr">static getDerivedStateFromError</code></a> which lets you update state in response to an error and display an error message to the user. You can also optionally implement <a href="#componentdidcatch"><code dir="ltr">componentDidCatch</code></a> to add some extra logic, for example, to log the error to an analytics service.</p> <pre data-language="jsx"><code><span>class</span> ErrorBoundary <span>extends</span> <span>React</span>.<span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span><span>props</span><span>)</span><span>;</span>
    <span>this</span>.<span>state</span> = <span>{</span> <span>hasError</span><span>:</span> <span>false</span> <span>}</span><span>;</span>
  <span>}</span>

  <span>static</span> <span>getDerivedStateFromError</span><span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>// Update state so the next render will show the fallback UI.</span>
    <span>return</span> <span>{</span> <span>hasError</span><span>:</span> <span>true</span> <span>}</span><span>;</span>
  <span>}</span>

  <span>componentDidCatch</span><span>(</span><span>error</span><span>,</span> <span>info</span><span>)</span> <span>{</span>
    <span>// Example "componentStack":</span>
    <span>//   in ComponentThatThrows (created by App)</span>
    <span>//   in ErrorBoundary (created by App)</span>
    <span>//   in div (created by App)</span>
    <span>//   in App</span>
    <span>logErrorToMyService</span><span>(</span><span>error</span><span>,</span> <span>info</span>.<span>componentStack</span><span>)</span><span>;</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span>.<span>state</span>.<span>hasError</span><span>)</span> <span>{</span>
      <span>// You can render any custom fallback UI</span>
      <span>return</span> <span>this</span>.<span>props</span>.<span>fallback</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>this</span>.<span>props</span>.<span>children</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>Then you can wrap a part of your component tree with it:</p> <pre data-language="jsx"><code><span>&lt;</span><span>ErrorBoundary</span> <span>fallback</span>=<span>{</span><span>&lt;</span><span>p</span><span>&gt;</span>Something went wrong<span>&lt;/</span><span>p</span><span>&gt;</span><span>}</span><span>&gt;</span>
  <span>&lt;</span><span>Profile</span> <span>/&gt;</span>
<span>&lt;/</span><span>ErrorBoundary</span><span>&gt;</span></code></pre> <p>If <code dir="ltr">Profile</code> or its child component throws an error, <code dir="ltr">ErrorBoundary</code> will “catch” that error, display a fallback UI with the error message you’ve provided, and send a production error report to your error reporting service.</p> <p>You don’t need to wrap every component into a separate error boundary. When you think about the <a href="https://www.brandondail.com/posts/fault-tolerance-react" target="_blank" rel="nofollow noopener noreferrer">granularity of error boundaries,</a> consider where it makes sense to display an error message. For example, in a messaging app, it makes sense to place an error boundary around the list of conversations. It also makes sense to place one around every individual message. However, it wouldn’t make sense to place a boundary around every avatar.</p> <div class="note note-green">
<h4>Note</h4>
<div><p>There is currently no way to write an error boundary as a function component. However, you don’t have to write the error boundary class yourself. For example, you can use <a href="https://github.com/bvaughn/react-error-boundary" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">react-error-boundary</code></a> instead.</p></div>
</div> <hr> <h2 id="alternatives">Alternatives 
</h2> <h3 id="migrating-a-simple-component-from-a-class-to-a-function">Migrating a simple component from a class to a function 
</h3> <p>Typically, you will <a href="../../learn/your-first-component.html#defining-a-component">define components as functions</a> instead.</p> <p>For example, suppose you’re converting this <code dir="ltr">Greeting</code> class component to a function:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>Component</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>class</span> Greeting <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Hello, <span>{</span><span>this</span>.<span>props</span>.<span>name</span><span>}</span>!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>Greeting</span> <span>name</span>=<span>"Sara"</span> <span>/&gt;</span>
      <span>&lt;</span><span>Greeting</span> <span>name</span>=<span>"Cahal"</span> <span>/&gt;</span>
      <span>&lt;</span><span>Greeting</span> <span>name</span>=<span>"Edite"</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>Define a function called <code dir="ltr">Greeting</code>. This is where you will move the body of your <code dir="ltr">render</code> function.</p> <pre data-language="jsx"><code><span>function</span> <span>Greeting</span><span>(</span><span>)</span> <span>{</span>
  <span>// ... move the code from the render method here ...</span>
<span>}</span></code></pre> <p>Instead of <code dir="ltr">this.props.name</code>, define the <code dir="ltr">name</code> prop <a href="../../learn/passing-props-to-a-component.html">using the destructuring syntax</a> and read it directly:</p> <pre data-language="jsx"><code><span>function</span> <span>Greeting</span><span>(</span><span>{</span> <span>name</span> <span>}</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Hello, <span>{</span><span>name</span><span>}</span>!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
<span>}</span></code></pre> <p>Here is a complete example:</p> 
<pre data-language="jsx"><span>function</span> <span>Greeting</span><span>(</span><span>{</span> <span>name</span> <span>}</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span>Hello, <span>{</span><span>name</span><span>}</span>!<span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>Greeting</span> <span>name</span>=<span>"Sara"</span> <span>/&gt;</span>
      <span>&lt;</span><span>Greeting</span> <span>name</span>=<span>"Cahal"</span> <span>/&gt;</span>
      <span>&lt;</span><span>Greeting</span> <span>name</span>=<span>"Edite"</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <hr> <h3 id="migrating-a-component-with-state-from-a-class-to-a-function">Migrating a component with state from a class to a function 
</h3> <p>Suppose you’re converting this <code dir="ltr">Counter</code> class component to a function:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>Component</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>export</span> <span>default</span> <span>class</span> Counter <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>name</span><span>:</span> <span>'Taylor'</span><span>,</span>
    <span>age</span><span>:</span> <span>42</span><span>,</span>
  <span>}</span><span>;</span>

  <span>handleNameChange</span> = <span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>this</span>.<span>setState</span><span>(</span><span>{</span>
      <span>name</span><span>:</span> <span>e</span>.<span>target</span>.<span>value</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span>

  <span>handleAgeChange</span> = <span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>this</span>.<span>setState</span><span>(</span><span>{</span>
      <span>age</span><span>:</span> <span>this</span>.<span>state</span>.<span>age</span> + <span>1</span> 
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>&gt;</span>
        <span>&lt;</span><span>input</span>
          <span>value</span>=<span>{</span><span>this</span>.<span>state</span>.<span>name</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>this</span>.<span>handleNameChange</span><span>}</span>
        <span>/&gt;</span>
        <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>this</span>.<span>handleAgeChange</span><span>}</span><span>&gt;</span>
          Increment age
        <span>&lt;/</span><span>button</span><span>&gt;</span>
        <span>&lt;</span><span>p</span><span>&gt;</span>Hello, <span>{</span><span>this</span>.<span>state</span>.<span>name</span><span>}</span>. You are <span>{</span><span>this</span>.<span>state</span>.<span>age</span><span>}</span>.<span>&lt;/</span><span>p</span><span>&gt;</span>
      <span>&lt;/</span><span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

</pre> <p>Start by declaring a function with the necessary <a href="usestate.html#adding-state-to-a-component">state variables:</a></p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>useState</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>name</span><span>,</span> <span>setName</span><span>]</span> = <span>useState</span><span>(</span><span>'Taylor'</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>age</span><span>,</span> <span>setAge</span><span>]</span> = <span>useState</span><span>(</span><span>42</span><span>)</span><span>;</span>
  <span>// ...</span></code></pre> <p>Next, convert the event handlers:</p> <pre data-language="jsx"><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>name</span><span>,</span> <span>setName</span><span>]</span> = <span>useState</span><span>(</span><span>'Taylor'</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>age</span><span>,</span> <span>setAge</span><span>]</span> = <span>useState</span><span>(</span><span>42</span><span>)</span><span>;</span>

  <span>function</span> <span>handleNameChange</span><span>(</span><span>e</span><span>)</span> <span>{</span>
    <span>setName</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>;</span>
  <span>}</span>

  <span>function</span> <span>handleAgeChange</span><span>(</span><span>)</span> <span>{</span>
    <span>setAge</span><span>(</span><span>age</span> + <span>1</span><span>)</span><span>;</span>
  <span>}</span>
  <span>// ...</span></code></pre> <p>Finally, replace all references starting with <code dir="ltr">this</code> with the variables and functions you defined in your component. For example, replace <code dir="ltr">this.state.age</code> with <code dir="ltr">age</code>, and replace <code dir="ltr">this.handleNameChange</code> with <code dir="ltr">handleNameChange</code>.</p> <p>Here is a fully converted component:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>name</span><span>,</span> <span>setName</span><span>]</span> = <span>useState</span><span>(</span><span>'Taylor'</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>age</span><span>,</span> <span>setAge</span><span>]</span> = <span>useState</span><span>(</span><span>42</span><span>)</span><span>;</span>

  <span>function</span> <span>handleNameChange</span><span>(</span><span>e</span><span>)</span> <span>{</span>
    <span>setName</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>;</span>
  <span>}</span>

  <span>function</span> <span>handleAgeChange</span><span>(</span><span>)</span> <span>{</span>
    <span>setAge</span><span>(</span><span>age</span> + <span>1</span><span>)</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>input</span>
        <span>value</span>=<span>{</span><span>name</span><span>}</span>
        <span>onChange</span>=<span>{</span><span>handleNameChange</span><span>}</span>
      <span>/&gt;</span>
      <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>handleAgeChange</span><span>}</span><span>&gt;</span>
        Increment age
      <span>&lt;/</span><span>button</span><span>&gt;</span>
      <span>&lt;</span><span>p</span><span>&gt;</span>Hello, <span>{</span><span>name</span><span>}</span>. You are <span>{</span><span>age</span><span>}</span>.<span>&lt;/</span><span>p</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span>
<span>}</span>

</pre> <hr> <h3 id="migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function">Migrating a component with lifecycle methods from a class to a function 
</h3> <p>Suppose you’re converting this <code dir="ltr">ChatRoom</code> class component with lifecycle methods to a function:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>Component</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>export</span> <span>default</span> <span>class</span> ChatRoom <span>extends</span> <span>Component</span> <span>{</span>
  <span>state</span> = <span>{</span>
    <span>serverUrl</span><span>:</span> <span>'https://localhost:1234'</span>
  <span>}</span><span>;</span>

  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>setupConnection</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>componentDidUpdate</span><span>(</span><span>prevProps</span><span>,</span> <span>prevState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>
      <span>this</span>.<span>props</span>.<span>roomId</span> !== <span>prevProps</span>.<span>roomId</span> ||
      <span>this</span>.<span>state</span>.<span>serverUrl</span> !== <span>prevState</span>.<span>serverUrl</span>
    <span>)</span> <span>{</span>
      <span>this</span>.<span>destroyConnection</span><span>(</span><span>)</span><span>;</span>
      <span>this</span>.<span>setupConnection</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>destroyConnection</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>setupConnection</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>connection</span> = <span>createConnection</span><span>(</span>
      <span>this</span>.<span>state</span>.<span>serverUrl</span><span>,</span>
      <span>this</span>.<span>props</span>.<span>roomId</span>
    <span>)</span><span>;</span>
    <span>this</span>.<span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>    
  <span>}</span>

  <span>destroyConnection</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span>.<span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
    <span>this</span>.<span>connection</span> = <span>null</span><span>;</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>&gt;</span>
        <span>&lt;</span><span>label</span><span>&gt;</span>
          Server URL:<span>{</span><span>' '</span><span>}</span>
          <span>&lt;</span><span>input</span>
            <span>value</span>=<span>{</span><span>this</span>.<span>state</span>.<span>serverUrl</span><span>}</span>
            <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>{</span>
              <span>this</span>.<span>setState</span><span>(</span><span>{</span>
                <span>serverUrl</span><span>:</span> <span>e</span>.<span>target</span>.<span>value</span>
              <span>}</span><span>)</span><span>;</span>
            <span>}</span><span>}</span>
          <span>/&gt;</span>
        <span>&lt;/</span><span>label</span><span>&gt;</span>
        <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the <span>{</span><span>this</span>.<span>props</span>.<span>roomId</span><span>}</span> room!<span>&lt;/</span><span>h1</span><span>&gt;</span>
      <span>&lt;/</span><span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

</pre> <p>First, verify that your <a href="#componentwillunmount"><code dir="ltr">componentWillUnmount</code></a> does the opposite of <a href="#componentdidmount"><code dir="ltr">componentDidMount</code>.</a> In the above example, that’s true: it disconnects the connection that <code dir="ltr">componentDidMount</code> sets up. If such logic is missing, add it first.</p> <p>Next, verify that your <a href="#componentdidupdate"><code dir="ltr">componentDidUpdate</code></a> method handles changes to any props and state you’re using in <code dir="ltr">componentDidMount</code>. In the above example, <code dir="ltr">componentDidMount</code> calls <code dir="ltr">setupConnection</code> which reads <code dir="ltr">this.state.serverUrl</code> and <code dir="ltr">this.props.roomId</code>. This is why <code dir="ltr">componentDidUpdate</code> checks whether <code dir="ltr">this.state.serverUrl</code> and <code dir="ltr">this.props.roomId</code> have changed, and resets the connection if they did. If your <code dir="ltr">componentDidUpdate</code> logic is missing or doesn’t handle changes to all relevant props and state, fix that first.</p> <p>In the above example, the logic inside the lifecycle methods connects the component to a system outside of React (a chat server). To connect a component to an external system, <a href="useeffect.html#connecting-to-an-external-system">describe this logic as a single Effect:</a></p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>serverUrl</span><span>,</span> <span>setServerUrl</span><span>]</span> = <span>useState</span><span>(</span><span>'https://localhost:1234'</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>]</span><span>)</span><span>;</span>

  <span>// ...</span>
<span>}</span></code></pre> <p>This <a href="useeffect.html"><code dir="ltr">useEffect</code></a> call is equivalent to the logic in the lifecycle methods above. If your lifecycle methods do multiple unrelated things, <a href="../../learn/removing-effect-dependencies.html#is-your-effect-doing-several-unrelated-things">split them into multiple independent Effects.</a> Here is a complete example you can play with:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>serverUrl</span><span>,</span> <span>setServerUrl</span><span>]</span> = <span>useState</span><span>(</span><span>'https://localhost:1234'</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>,</span> <span>serverUrl</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>label</span><span>&gt;</span>
        Server URL:<span>{</span><span>' '</span><span>}</span>
        <span>&lt;</span><span>input</span>
          <span>value</span>=<span>{</span><span>serverUrl</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setServerUrl</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span>
        <span>/&gt;</span>
      <span>&lt;/</span><span>label</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the <span>{</span><span>roomId</span><span>}</span> room!<span>&lt;/</span><span>h1</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <div class="note note-green">
<h4>Note</h4>
<div><p>If your component does not synchronize with any external systems, <a href="../../learn/you-might-not-need-an-effect.html">you might not need an Effect.</a></p></div>
</div> <hr> <h3 id="migrating-a-component-with-context-from-a-class-to-a-function">Migrating a component with context from a class to a function 
</h3> <p>In this example, the <code dir="ltr">Panel</code> and <code dir="ltr">Button</code> class components read <a href="../../learn/passing-data-deeply-with-context.html">context</a> from <a href="#context"><code dir="ltr">this.context</code>:</a></p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>createContext</span><span>,</span> <span>Component</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>const</span> <span>ThemeContext</span> = <span>createContext</span><span>(</span><span>null</span><span>)</span><span>;</span>

<span>class</span> Panel <span>extends</span> <span>Component</span> <span>{</span>
  <span>static</span> <span>contextType</span> = <span>ThemeContext</span><span>;</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>theme</span> = <span>this</span>.<span>context</span><span>;</span>
    <span>const</span> <span>className</span> = <span>'panel-'</span> + <span>theme</span><span>;</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>section</span> <span>className</span>=<span>{</span><span>className</span><span>}</span><span>&gt;</span>
        <span>&lt;</span><span>h1</span><span>&gt;</span><span>{</span><span>this</span>.<span>props</span>.<span>title</span><span>}</span><span>&lt;/</span><span>h1</span><span>&gt;</span>
        <span>{</span><span>this</span>.<span>props</span>.<span>children</span><span>}</span>
      <span>&lt;/</span><span>section</span><span>&gt;</span>
    <span>)</span><span>;</span>    
  <span>}</span>
<span>}</span>

<span>class</span> Button <span>extends</span> <span>Component</span> <span>{</span>
  <span>static</span> <span>contextType</span> = <span>ThemeContext</span><span>;</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>theme</span> = <span>this</span>.<span>context</span><span>;</span>
    <span>const</span> <span>className</span> = <span>'button-'</span> + <span>theme</span><span>;</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span><span>button</span> <span>className</span>=<span>{</span><span>className</span><span>}</span><span>&gt;</span>
        <span>{</span><span>this</span>.<span>props</span>.<span>children</span><span>}</span>
      <span>&lt;/</span><span>button</span><span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>Form</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>Panel</span> <span>title</span>=<span>"Welcome"</span><span>&gt;</span>
      <span>&lt;</span><span>Button</span><span>&gt;</span>Sign up<span>&lt;/</span><span>Button</span><span>&gt;</span>
      <span>&lt;</span><span>Button</span><span>&gt;</span>Log in<span>&lt;/</span><span>Button</span><span>&gt;</span>
    <span>&lt;/</span><span>Panel</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>MyApp</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>ThemeContext</span>.<span>Provider</span> <span>value</span>=<span>"dark"</span><span>&gt;</span>
      <span>&lt;</span><span>Form</span> <span>/&gt;</span>
    <span>&lt;/</span><span>ThemeContext</span>.<span>Provider</span><span>&gt;</span>
  <span>)</span>
<span>}</span>

</pre> <p>When you convert them to function components, replace <code dir="ltr">this.context</code> with <a href="usecontext.html"><code dir="ltr">useContext</code></a> calls:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>createContext</span><span>,</span> <span>useContext</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>const</span> <span>ThemeContext</span> = <span>createContext</span><span>(</span><span>null</span><span>)</span><span>;</span>

<span>function</span> <span>Panel</span><span>(</span><span>{</span> <span>title</span><span>,</span> <span>children</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>theme</span> = <span>useContext</span><span>(</span><span>ThemeContext</span><span>)</span><span>;</span>
  <span>const</span> <span>className</span> = <span>'panel-'</span> + <span>theme</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>section</span> <span>className</span>=<span>{</span><span>className</span><span>}</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span><span>{</span><span>title</span><span>}</span><span>&lt;/</span><span>h1</span><span>&gt;</span>
      <span>{</span><span>children</span><span>}</span>
    <span>&lt;/</span><span>section</span><span>&gt;</span>
  <span>)</span>
<span>}</span>

<span>function</span> <span>Button</span><span>(</span><span>{</span> <span>children</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>theme</span> = <span>useContext</span><span>(</span><span>ThemeContext</span><span>)</span><span>;</span>
  <span>const</span> <span>className</span> = <span>'button-'</span> + <span>theme</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>button</span> <span>className</span>=<span>{</span><span>className</span><span>}</span><span>&gt;</span>
      <span>{</span><span>children</span><span>}</span>
    <span>&lt;/</span><span>button</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>Form</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>Panel</span> <span>title</span>=<span>"Welcome"</span><span>&gt;</span>
      <span>&lt;</span><span>Button</span><span>&gt;</span>Sign up<span>&lt;/</span><span>Button</span><span>&gt;</span>
      <span>&lt;</span><span>Button</span><span>&gt;</span>Log in<span>&lt;/</span><span>Button</span><span>&gt;</span>
    <span>&lt;/</span><span>Panel</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>MyApp</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>ThemeContext</span>.<span>Provider</span> <span>value</span>=<span>"dark"</span><span>&gt;</span>
      <span>&lt;</span><span>Form</span> <span>/&gt;</span>
    <span>&lt;/</span><span>ThemeContext</span>.<span>Provider</span><span>&gt;</span>
  <span>)</span>
<span>}</span>

</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013&ndash;present Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://react.dev/reference/react/Component" class="_attribution-link">https://react.dev/reference/react/Component</a>
  </p>
</div>
