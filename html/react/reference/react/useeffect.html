<h1>useEffect
</h1>
<div>
<p><code dir="ltr">useEffect</code> is a React Hook that lets you <a href="../../learn/synchronizing-with-effects.html">synchronize a component with an external system.</a></p>
<pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>setup</span><span>,</span> <span>dependencies</span>?<span>)</span></code></pre>
</div> <ul>
<li>
<a href="#reference">Reference </a><ul><li><a href="#useeffect"><code dir="ltr">useEffect(setup, dependencies?)</code> </a></li></ul>
</li>
<li>
<a href="#usage">Usage </a><ul>
<li><a href="#connecting-to-an-external-system">Connecting to an external system </a></li>
<li><a href="#wrapping-effects-in-custom-hooks">Wrapping Effects in custom Hooks </a></li>
<li><a href="#controlling-a-non-react-widget">Controlling a non-React widget </a></li>
<li><a href="#fetching-data-with-effects">Fetching data with Effects </a></li>
<li><a href="#specifying-reactive-dependencies">Specifying reactive dependencies </a></li>
<li><a href="#updating-state-based-on-previous-state-from-an-effect">Updating state based on previous state from an Effect </a></li>
<li><a href="#removing-unnecessary-object-dependencies">Removing unnecessary object dependencies </a></li>
<li><a href="#removing-unnecessary-function-dependencies">Removing unnecessary function dependencies </a></li>
<li><a href="#reading-the-latest-props-and-state-from-an-effect">Reading the latest props and state from an Effect </a></li>
<li><a href="#displaying-different-content-on-the-server-and-the-client">Displaying different content on the server and the client </a></li>
</ul>
</li>
<li>
<a href="#troubleshooting">Troubleshooting </a><ul>
<li><a href="#my-effect-runs-twice-when-the-component-mounts">My Effect runs twice when the component mounts </a></li>
<li><a href="#my-effect-runs-after-every-re-render">My Effect runs after every re-render </a></li>
<li><a href="#my-effect-keeps-re-running-in-an-infinite-cycle">My Effect keeps re-running in an infinite cycle </a></li>
<li><a href="#my-cleanup-logic-runs-even-though-my-component-didnt-unmount">My cleanup logic runs even though my component didn’t unmount </a></li>
<li><a href="#my-effect-does-something-visual-and-i-see-a-flicker-before-it-runs">My Effect does something visual, and I see a flicker before it runs </a></li>
</ul>
</li>
</ul> <hr> <h2 id="reference">Reference 
</h2> <h3 id="useeffect">
<code dir="ltr">useEffect(setup, dependencies?)</code> 
</h3> <p>Call <code dir="ltr">useEffect</code> at the top level of your component to declare an Effect:</p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>serverUrl</span><span>,</span> <span>setServerUrl</span><span>]</span> = <span>useState</span><span>(</span><span>'https://localhost:1234'</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>]</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span></code></pre> <p><a href="#usage">See more examples below.</a></p> <h4 id="parameters">Parameters 
</h4> <ul> <li> <p><code dir="ltr">setup</code>: The function with your Effect’s logic. Your setup function may also optionally return a <em>cleanup</em> function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.</p> </li> <li> <p><strong>optional</strong> <code dir="ltr">dependencies</code>: The list of all reactive values referenced inside of the <code dir="ltr">setup</code> code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is <a href="../../learn/editor-setup.html#linting">configured for React</a>, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like <code dir="ltr">[dep1, dep2, dep3]</code>. React will compare each dependency with its previous value using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">Object.is</code></a> comparison. If you omit this argument, your Effect will re-run after every re-render of the component. <a href="#examples-dependencies">See the difference between passing an array of dependencies, an empty array, and no dependencies at all.</a></p> </li> </ul> <h4 id="returns">Returns 
</h4> <p><code dir="ltr">useEffect</code> returns <code dir="ltr">undefined</code>.</p> <h4 id="caveats">Caveats 
</h4> <ul> <li> <p><code dir="ltr">useEffect</code> is a Hook, so you can only call it <strong>at the top level of your component</strong> or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.</p> </li> <li> <p>If you’re <strong>not trying to synchronize with some external system,</strong> <a href="../../learn/you-might-not-need-an-effect.html">you probably don’t need an Effect.</a></p> </li> <li> <p>When Strict Mode is on, React will <strong>run one extra development-only setup+cleanup cycle</strong> before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, <a href="../../learn/synchronizing-with-effects.html#how-to-handle-the-effect-firing-twice-in-development">implement the cleanup function.</a></p> </li> <li> <p>If some of your dependencies are objects or functions defined inside the component, there is a risk that they will <strong>cause the Effect to re-run more often than needed.</strong> To fix this, remove unnecessary <a href="#removing-unnecessary-object-dependencies">object</a> and <a href="#removing-unnecessary-function-dependencies">function</a> dependencies. You can also <a href="#updating-state-based-on-previous-state-from-an-effect">extract state updates</a> and <a href="#reading-the-latest-props-and-state-from-an-effect">non-reactive logic</a> outside of your Effect.</p> </li> <li> <p>If your Effect wasn’t caused by an interaction (like a click), React will generally let the browser <strong>paint the updated screen first before running your Effect.</strong> If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace <code dir="ltr">useEffect</code> with <a href="uselayouteffect.html"><code dir="ltr">useLayoutEffect</code>.</a></p> </li> <li> <p>If your Effect is caused by an interaction (like a click), <strong>React may run your Effect before the browser paints the updated screen</strong>. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an <code dir="ltr">alert()</code>, you can use <code dir="ltr">setTimeout</code>. See <a href="https://github.com/reactwg/react-18/discussions/128" target="_blank" rel="nofollow noopener noreferrer">reactwg/react-18/128</a> for more information.</p> </li> <li> <p>Even if your Effect was caused by an interaction (like a click), <strong>React may allow the browser to repaint the screen before processing the state updates inside your Effect.</strong> Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace <code dir="ltr">useEffect</code> with <a href="uselayouteffect.html"><code dir="ltr">useLayoutEffect</code>.</a></p> </li> <li> <p>Effects <strong>only run on the client.</strong> They don’t run during server rendering.</p> </li> </ul> <hr> <h2 id="usage">Usage 
</h2> <h3 id="connecting-to-an-external-system">Connecting to an external system 
</h3> <p>Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren’t controlled by React, so they are called <em>external.</em></p> <p>To <a href="../../learn/synchronizing-with-effects.html">connect your component to some external system,</a> call <code dir="ltr">useEffect</code> at the top level of your component:</p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>serverUrl</span><span>,</span> <span>setServerUrl</span><span>]</span> = <span>useState</span><span>(</span><span>'https://localhost:1234'</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  	<span>const connection = createConnection(serverUrl, roomId);</span>
    <span>connection.connect();</span>
  	<span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>connection.disconnect();</span>
  	<span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[serverUrl, roomId]</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span></code></pre> <p>You need to pass two arguments to <code dir="ltr">useEffect</code>:</p> <ol> <li>A <em>setup function</em> with <span data-step="1">setup code</span> that connects to that system. <ul> <li>It should return a <em>cleanup function</em> with <span data-step="2">cleanup code</span> that disconnects from that system.</li> </ul> </li> <li>A <span data-step="3">list of dependencies</span> including every value from your component used inside of those functions.</li> </ol> <p><strong>React calls your setup and cleanup functions whenever it’s necessary, which may happen multiple times:</strong></p> <ol> <li>Your <span data-step="1">setup code</span> runs when your component is added to the page <em>(mounts)</em>.</li> <li>After every re-render of your component where the <span data-step="3">dependencies</span> have changed: <ul> <li>First, your <span data-step="2">cleanup code</span> runs with the old props and state.</li> <li>Then, your <span data-step="1">setup code</span> runs with the new props and state.</li> </ul> </li> <li>Your <span data-step="2">cleanup code</span> runs one final time after your component is removed from the page <em>(unmounts).</em>
</li> </ol> <p><strong>Let’s illustrate this sequence for the example above.</strong></p> <p>When the <code dir="ltr">ChatRoom</code> component above gets added to the page, it will connect to the chat room with the initial <code dir="ltr">serverUrl</code> and <code dir="ltr">roomId</code>. If either <code dir="ltr">serverUrl</code> or <code dir="ltr">roomId</code> change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will <em>disconnect from the previous room, and connect to the next one.</em> When the <code dir="ltr">ChatRoom</code> component is removed from the page, your Effect will disconnect one last time.</p> <p><strong>To <a href="../../learn/synchronizing-with-effects.html#step-3-add-cleanup-if-needed">help you find bugs,</a> in development React runs <span data-step="1">setup</span> and <span data-step="2">cleanup</span> one extra time before the <span data-step="1">setup</span>.</strong> This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a <em>setup</em> → <em>cleanup</em> → <em>setup</em> sequence (as in development). <a href="../../learn/synchronizing-with-effects.html#how-to-handle-the-effect-firing-twice-in-development">See common solutions.</a></p> <p><strong>Try to <a href="../../learn/lifecycle-of-reactive-effects.html#each-effect-represents-a-separate-synchronization-process">write every Effect as an independent process</a> and <a href="../../learn/lifecycle-of-reactive-effects.html#thinking-from-the-effects-perspective">think about a single setup/cleanup cycle at a time.</a></strong> It shouldn’t matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly “mirrors” the setup logic, your Effect is resilient to running setup and cleanup as often as needed.</p> <div class="note note-green">
<h4>Note</h4>
<div>
<p>An Effect lets you <a href="../../learn/synchronizing-with-effects.html">keep your component synchronized</a> with some external system (like a chat service). Here, <em>external system</em> means any piece of code that’s not controlled by React, such as:</p>
<ul> <li>A timer managed with <span data-step="1"><a href="https://developer.mozilla.org/en-US/docs/Web/API/setInterval" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">setInterval()</code></a></span> and <span data-step="2"><a href="https://developer.mozilla.org/en-US/docs/Web/API/clearInterval" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">clearInterval()</code></a></span>.</li> <li>An event subscription using <span data-step="1"><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">window.addEventListener()</code></a></span> and <span data-step="2"><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">window.removeEventListener()</code></a></span>.</li> <li>A third-party animation library with an API like <span data-step="1"><code dir="ltr">animation.start()</code></span> and <span data-step="2"><code dir="ltr">animation.reset()</code></span>.</li> </ul>
<p><strong>If you’re not connecting to any external system, <a href="../../learn/you-might-not-need-an-effect.html">you probably don’t need an Effect.</a></strong></p>
</div>
</div>  <hr> <h3 id="wrapping-effects-in-custom-hooks">Wrapping Effects in custom Hooks 
</h3> <p>Effects are an <a href="../../learn/escape-hatches.html">“escape hatch”:</a> you use them when you need to “step outside React” and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it’s usually a sign that you need to extract some <a href="../../learn/reusing-logic-with-custom-hooks.html">custom Hooks</a> for common behaviors your components rely on.</p> <p>For example, this <code dir="ltr">useChatRoom</code> custom Hook “hides” the logic of your Effect behind a more declarative API:</p> <pre data-language="jsx"><code><span>function</span> <span>useChatRoom</span><span>(</span><span>{</span> <span>serverUrl</span><span>,</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>options</span> = <span>{</span>
      <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
      <span>roomId</span><span>:</span> <span>roomId</span>
    <span>}</span><span>;</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>,</span> <span>serverUrl</span><span>]</span><span>)</span><span>;</span>
<span>}</span></code></pre> <p>Then you can use it from any component like this:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>serverUrl</span><span>,</span> <span>setServerUrl</span><span>]</span> = <span>useState</span><span>(</span><span>'https://localhost:1234'</span><span>)</span><span>;</span>

  <span>useChatRoom</span><span>(</span><span>{</span>
    <span>roomId</span><span>:</span> <span>roomId</span><span>,</span>
    <span>serverUrl</span><span>:</span> <span>serverUrl</span>
  <span>}</span><span>)</span><span>;</span>
  <span>// ...</span></code></pre> <p>There are also many excellent custom Hooks for every purpose available in the React ecosystem.</p> <p><a href="../../learn/reusing-logic-with-custom-hooks.html">Learn more about wrapping Effects in custom Hooks.</a></p>  <hr> <h3 id="controlling-a-non-react-widget">Controlling a non-React widget 
</h3> <p>Sometimes, you want to keep an external system synchronized to some prop or state of your component.</p> <p>For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a <code dir="ltr">MapWidget</code> class defined in <code dir="ltr">map-widget.js</code>. When you change the <code dir="ltr">zoomLevel</code> prop of the <code dir="ltr">Map</code> component, the Effect calls the <code dir="ltr">setZoom()</code> on the class instance to keep it synchronized:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useRef</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>MapWidget</span> <span>}</span> <span>from</span> <span>'./map-widget.js'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Map</span><span>(</span><span>{</span> <span>zoomLevel</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>containerRef</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>const</span> <span>mapRef</span> = <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>mapRef</span>.<span>current</span> === <span>null</span><span>)</span> <span>{</span>
      <span>mapRef</span>.<span>current</span> = <span>new</span> <span>MapWidget</span><span>(</span><span>containerRef</span>.<span>current</span><span>)</span><span>;</span>
    <span>}</span>

    <span>const</span> <span>map</span> = <span>mapRef</span>.<span>current</span><span>;</span>
    <span>map</span>.<span>setZoom</span><span>(</span><span>zoomLevel</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>zoomLevel</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>div</span>
      <span>style</span>=<span>{</span><span>{</span> <span>width</span><span>:</span> <span>200</span><span>,</span> <span>height</span><span>:</span> <span>200</span> <span>}</span><span>}</span>
      <span>ref</span>=<span>{</span><span>containerRef</span><span>}</span>
    <span>/&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>In this example, a cleanup function is not needed because the <code dir="ltr">MapWidget</code> class manages only the DOM node that was passed to it. After the <code dir="ltr">Map</code> React component is removed from the tree, both the DOM node and the <code dir="ltr">MapWidget</code> class instance will be automatically garbage-collected by the browser JavaScript engine.</p> <hr> <h3 id="fetching-data-with-effects">Fetching data with Effects 
</h3> <p>You can use an Effect to fetch data for your component. Note that <a href="../../learn/start-a-new-react-project.html#production-grade-react-frameworks">if you use a framework,</a> using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually.</p> <p>If you want to fetch data from an Effect manually, your code might look like this:</p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>fetchBio</span> <span>}</span> <span>from</span> <span>'./api.js'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Page</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>person</span><span>,</span> <span>setPerson</span><span>]</span> = <span>useState</span><span>(</span><span>'Alice'</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>bio</span><span>,</span> <span>setBio</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>let</span> <span>ignore</span> = <span>false</span><span>;</span>
    <span>setBio</span><span>(</span><span>null</span><span>)</span><span>;</span>
    <span>fetchBio</span><span>(</span><span>person</span><span>)</span>.<span>then</span><span>(</span><span>result</span> <span>=&gt;</span> <span>{</span>
      <span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span>
        <span>setBio</span><span>(</span><span>result</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>ignore</span> = <span>true</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>person</span><span>]</span><span>)</span><span>;</span>

  <span>// ...</span></code></pre> <p>Note the <code dir="ltr">ignore</code> variable which is initialized to <code dir="ltr">false</code>, and is set to <code dir="ltr">true</code> during cleanup. This ensures <a href="https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect" target="_blank" rel="nofollow noopener noreferrer">your code doesn’t suffer from “race conditions”:</a> network responses may arrive in a different order than you sent them.</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>fetchBio</span> <span>}</span> <span>from</span> <span>'./api.js'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Page</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>person</span><span>,</span> <span>setPerson</span><span>]</span> = <span>useState</span><span>(</span><span>'Alice'</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>bio</span><span>,</span> <span>setBio</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>let</span> <span>ignore</span> = <span>false</span><span>;</span>
    <span>setBio</span><span>(</span><span>null</span><span>)</span><span>;</span>
    <span>fetchBio</span><span>(</span><span>person</span><span>)</span>.<span>then</span><span>(</span><span>result</span> <span>=&gt;</span> <span>{</span>
      <span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span>
        <span>setBio</span><span>(</span><span>result</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>ignore</span> = <span>true</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>person</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>select</span> <span>value</span>=<span>{</span><span>person</span><span>}</span> <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>{</span>
        <span>setPerson</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>;</span>
      <span>}</span><span>}</span><span>&gt;</span>
        <span>&lt;</span><span>option</span> <span>value</span>=<span>"Alice"</span><span>&gt;</span>Alice<span>&lt;/</span><span>option</span><span>&gt;</span>
        <span>&lt;</span><span>option</span> <span>value</span>=<span>"Bob"</span><span>&gt;</span>Bob<span>&lt;/</span><span>option</span><span>&gt;</span>
        <span>&lt;</span><span>option</span> <span>value</span>=<span>"Taylor"</span><span>&gt;</span>Taylor<span>&lt;/</span><span>option</span><span>&gt;</span>
      <span>&lt;/</span><span>select</span><span>&gt;</span>
      <span>&lt;</span><span>hr</span> <span>/&gt;</span>
      <span>&lt;</span><span>p</span><span>&gt;</span><span>&lt;</span><span>i</span><span>&gt;</span><span>{</span><span>bio</span> ?? <span>'Loading...'</span><span>}</span><span>&lt;/</span><span>i</span><span>&gt;</span><span>&lt;/</span><span>p</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>You can also rewrite using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">async</code> / <code dir="ltr">await</code></a> syntax, but you still need to provide a cleanup function:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>fetchBio</span> <span>}</span> <span>from</span> <span>'./api.js'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Page</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>person</span><span>,</span> <span>setPerson</span><span>]</span> = <span>useState</span><span>(</span><span>'Alice'</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>bio</span><span>,</span> <span>setBio</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>async</span> <span>function</span> <span>startFetching</span><span>(</span><span>)</span> <span>{</span>
      <span>setBio</span><span>(</span><span>null</span><span>)</span><span>;</span>
      <span>const</span> <span>result</span> = <span>await</span> <span>fetchBio</span><span>(</span><span>person</span><span>)</span><span>;</span>
      <span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span>
        <span>setBio</span><span>(</span><span>result</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>

    <span>let</span> <span>ignore</span> = <span>false</span><span>;</span>
    <span>startFetching</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>ignore</span> = <span>true</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>person</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>select</span> <span>value</span>=<span>{</span><span>person</span><span>}</span> <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>{</span>
        <span>setPerson</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>;</span>
      <span>}</span><span>}</span><span>&gt;</span>
        <span>&lt;</span><span>option</span> <span>value</span>=<span>"Alice"</span><span>&gt;</span>Alice<span>&lt;/</span><span>option</span><span>&gt;</span>
        <span>&lt;</span><span>option</span> <span>value</span>=<span>"Bob"</span><span>&gt;</span>Bob<span>&lt;/</span><span>option</span><span>&gt;</span>
        <span>&lt;</span><span>option</span> <span>value</span>=<span>"Taylor"</span><span>&gt;</span>Taylor<span>&lt;/</span><span>option</span><span>&gt;</span>
      <span>&lt;/</span><span>select</span><span>&gt;</span>
      <span>&lt;</span><span>hr</span> <span>/&gt;</span>
      <span>&lt;</span><span>p</span><span>&gt;</span><span>&lt;</span><span>i</span><span>&gt;</span><span>{</span><span>bio</span> ?? <span>'Loading...'</span><span>}</span><span>&lt;/</span><span>i</span><span>&gt;</span><span>&lt;/</span><span>p</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. <a href="../../learn/reusing-logic-with-custom-hooks.html#when-to-use-custom-hooks">It’s easier to use a custom Hook—either your own or maintained by the community.</a></p> <details class="note note-blue"><summary tabindex="-1"><h5>
Deep Dive</h5>
<h4 id="what-are-good-alternatives-to-data-fetching-in-effects">What are good alternatives to data fetching in Effects? 
</h4></summary><div>
<p>Writing <code dir="ltr">fetch</code> calls inside Effects is a <a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="nofollow noopener noreferrer">popular way to fetch data</a>, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:</p>
<ul> <li>
<strong>Effects don’t run on the server.</strong> This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.</li> <li>
<strong>Fetching directly in Effects makes it easy to create “network waterfalls”.</strong> You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.</li> <li>
<strong>Fetching directly in Effects usually means you don’t preload or cache data.</strong> For example, if the component unmounts and then mounts again, it would have to fetch the data again.</li> <li>
<strong>It’s not very ergonomic.</strong> There’s quite a bit of boilerplate code involved when writing <code dir="ltr">fetch</code> calls in a way that doesn’t suffer from bugs like <a href="https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect" target="_blank" rel="nofollow noopener noreferrer">race conditions.</a>
</li> </ul>
<p>This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:</p>
<ul> <li>
<strong>If you use a <a href="../../learn/start-a-new-react-project.html#production-grade-react-frameworks">framework</a>, use its built-in data fetching mechanism.</strong> Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.</li> <li>
<strong>Otherwise, consider using or building a client-side cache.</strong> Popular open source solutions include <a href="https://tanstack.com/query/latest/" target="_blank" rel="nofollow noopener noreferrer">React Query</a>, <a href="https://swr.vercel.app/" target="_blank" rel="nofollow noopener noreferrer">useSWR</a>, and <a href="https://beta.reactrouter.com/en/main/start/overview" target="_blank" rel="nofollow noopener noreferrer">React Router 6.4+.</a> You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).</li> </ul>
<p>You can continue fetching data directly in Effects if neither of these approaches suit you.</p>
</div></details> <hr> <h3 id="specifying-reactive-dependencies">Specifying reactive dependencies 
</h3> <p><strong>Notice that you can’t “choose” the dependencies of your Effect.</strong> Every <span data-step="2">reactive value</span> used by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span> <span>// This is a reactive value</span>
  <span>const</span> <span>[</span><span>serverUrl</span><span>,</span> <span>setServerUrl</span><span>]</span> = <span>useState</span><span>(</span><span>'https://localhost:1234'</span><span>)</span><span>;</span> <span>// This is a reactive value too</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span> <span>// This Effect reads these reactive values</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>]</span><span>)</span><span>;</span> <span>// ✅ So you must specify them as dependencies of your Effect</span>
  <span>// ...</span>
<span>}</span></code></pre> <p>If either <code dir="ltr">serverUrl</code> or <code dir="ltr">roomId</code> change, your Effect will reconnect to the chat using the new values.</p> <p><strong><a href="../../learn/lifecycle-of-reactive-effects.html#effects-react-to-reactive-values">Reactive values</a> include props and all variables and functions declared directly inside of your component.</strong> Since <code dir="ltr">roomId</code> and <code dir="ltr">serverUrl</code> are reactive values, you can’t remove them from the dependencies. If you try to omit them and <a href="../../learn/editor-setup.html#linting">your linter is correctly configured for React,</a> the linter will flag this as a mistake you need to fix:</p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>serverUrl</span><span>,</span> <span>setServerUrl</span><span>]</span> = <span>useState</span><span>(</span><span>'https://localhost:1234'</span><span>)</span><span>;</span>
  
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// 🔴 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'</span>
  <span>// ...</span>
<span>}</span></code></pre> <p><strong>To remove a dependency, you need to <a href="../../learn/removing-effect-dependencies.html#removing-unnecessary-dependencies">“prove” to the linter that it <em>doesn’t need</em> to be a dependency.</a></strong> For example, you can move <code dir="ltr">serverUrl</code> out of your component to prove that it’s not reactive and won’t change on re-renders:</p> <pre data-language="jsx"><code><span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span> <span>// Not a reactive value anymore</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span>
<span>}</span></code></pre> <p>Now that <code dir="ltr">serverUrl</code> is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency. <strong>If your Effect’s code doesn’t use any reactive values, its dependency list should be empty (<code dir="ltr">[]</code>):</strong></p> <pre data-language="jsx"><code><span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span> <span>// Not a reactive value anymore</span>
<span>const</span> <span>roomId</span> = <span>'music'</span><span>;</span> <span>// Not a reactive value anymore</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span>
<span>}</span></code></pre> <p><a href="../../learn/lifecycle-of-reactive-effects.html#what-an-effect-with-empty-dependencies-means">An Effect with empty dependencies</a> doesn’t re-run when any of your component’s props or state change.</p> <div class="note note-orange">
<h4>Pitfall</h4>
<div>
<p>If you have an existing codebase, you might have some Effects that suppress the linter like this:</p>
<pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// ...</span>
  <span>// 🔴 Avoid suppressing the linter like this:</span>
  <span>// eslint-ignore-next-line react-hooks/exhaustive-deps</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre>
<p><strong>When dependencies don’t match the code, there is a high risk of introducing bugs.</strong> By suppressing the linter, you “lie” to React about the values your Effect depends on. <a href="../../learn/removing-effect-dependencies.html#removing-unnecessary-dependencies">Instead, prove they’re unnecessary.</a></p>
</div>
</div>  <hr> <h3 id="updating-state-based-on-previous-state-from-an-effect">Updating state based on previous state from an Effect 
</h3> <p>When you want to update state based on previous state from an Effect, you might run into a problem:</p> <pre data-language="jsx"><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>count</span><span>,</span> <span>setCount</span><span>]</span> = <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>intervalId</span> = <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setCount</span><span>(</span><span>count</span> + <span>1</span><span>)</span><span>;</span> <span>// You want to increment the counter every second...</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>clearInterval</span><span>(</span><span>intervalId</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>count</span><span>]</span><span>)</span><span>;</span> <span>// 🚩 ... but specifying `count` as a dependency always resets the interval.</span>
  <span>// ...</span>
<span>}</span></code></pre> <p>Since <code dir="ltr">count</code> is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the <code dir="ltr">count</code> changes. This is not ideal.</p> <p>To fix this, <a href="usestate.html#updating-state-based-on-the-previous-state">pass the <code dir="ltr">c =&gt; c + 1</code> state updater</a> to <code dir="ltr">setCount</code>:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>count</span><span>,</span> <span>setCount</span><span>]</span> = <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>intervalId</span> = <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setCount</span><span>(</span><span>c</span> <span>=&gt;</span> <span>c</span> + <span>1</span><span>)</span><span>;</span> <span>// ✅ Pass a state updater</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>clearInterval</span><span>(</span><span>intervalId</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// ✅ Now count is not a dependency</span>

  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span><span>{</span><span>count</span><span>}</span><span>&lt;/</span><span>h1</span><span>&gt;</span><span>;</span>
<span>}</span>

</pre> <p>Now that you’re passing <code dir="ltr">c =&gt; c + 1</code> instead of <code dir="ltr">count + 1</code>, <a href="../../learn/removing-effect-dependencies.html#are-you-reading-some-state-to-calculate-the-next-state">your Effect no longer needs to depend on <code dir="ltr">count</code>.</a> As a result of this fix, it won’t need to cleanup and setup the interval again every time the <code dir="ltr">count</code> changes.</p> <hr> <h3 id="removing-unnecessary-object-dependencies">Removing unnecessary object dependencies 
</h3> <p>If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the <code dir="ltr">options</code> object is <a href="../../learn/removing-effect-dependencies.html#does-some-reactive-value-change-unintentionally">different for every render:</a></p> <pre data-language="jsx"><code><span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>const</span> <span>options</span> = <span>{</span> <span>// 🚩 This object is created from scratch on every re-render</span>
    <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
    <span>roomId</span><span>:</span> <span>roomId</span>
  <span>}</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span> <span>// It's used inside the Effect</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>options</span><span>]</span><span>)</span><span>;</span> <span>// 🚩 As a result, these dependencies are always different on a re-render</span>
  <span>// ...</span></code></pre> <p>Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>options</span> = <span>{</span>
      <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
      <span>roomId</span><span>:</span> <span>roomId</span>
    <span>}</span><span>;</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the <span>{</span><span>roomId</span><span>}</span> room!<span>&lt;/</span><span>h1</span><span>&gt;</span>
      <span>&lt;</span><span>input</span> <span>value</span>=<span>{</span><span>message</span><span>}</span> <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setMessage</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>roomId</span><span>,</span> <span>setRoomId</span><span>]</span> = <span>useState</span><span>(</span><span>'general'</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>label</span><span>&gt;</span>
        Choose the chat room:<span>{</span><span>' '</span><span>}</span>
        <span>&lt;</span><span>select</span>
          <span>value</span>=<span>{</span><span>roomId</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setRoomId</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span>
        <span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"general"</span><span>&gt;</span>general<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"travel"</span><span>&gt;</span>travel<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"music"</span><span>&gt;</span>music<span>&lt;/</span><span>option</span><span>&gt;</span>
        <span>&lt;/</span><span>select</span><span>&gt;</span>
      <span>&lt;/</span><span>label</span><span>&gt;</span>
      <span>&lt;</span><span>hr</span> <span>/&gt;</span>
      <span>&lt;</span><span>ChatRoom</span> <span>roomId</span>=<span>{</span><span>roomId</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>Now that you create the <code dir="ltr">options</code> object inside the Effect, the Effect itself only depends on the <code dir="ltr">roomId</code> string.</p> <p>With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string like <code dir="ltr">roomId</code> doesn’t change unless you set it to another value. <a href="../../learn/removing-effect-dependencies.html">Read more about removing dependencies.</a></p> <hr> <h3 id="removing-unnecessary-function-dependencies">Removing unnecessary function dependencies 
</h3> <p>If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the <code dir="ltr">createOptions</code> function is <a href="../../learn/removing-effect-dependencies.html#does-some-reactive-value-change-unintentionally">different for every render:</a></p> <pre data-language="jsx"><code><span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>function</span> <span>createOptions</span><span>(</span><span>)</span> <span>{</span> <span>// 🚩 This function is created from scratch on every re-render</span>
    <span>return</span> <span>{</span>
      <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
      <span>roomId</span><span>:</span> <span>roomId</span>
    <span>}</span><span>;</span>
  <span>}</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>options</span> = <span>createOptions</span><span>(</span><span>)</span><span>;</span> <span>// It's used inside the Effect</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>createOptions</span><span>]</span><span>)</span><span>;</span> <span>// 🚩 As a result, these dependencies are always different on a re-render</span>
  <span>// ...</span></code></pre> <p>By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.</p> <p>Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:</p> 
<pre data-language="jsx"><span>import</span> <span>{</span> <span>useState</span><span>,</span> <span>useEffect</span> <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span> <span>createConnection</span> <span>}</span> <span>from</span> <span>'./chat.js'</span><span>;</span>

<span>const</span> <span>serverUrl</span> = <span>'https://localhost:1234'</span><span>;</span>

<span>function</span> <span>ChatRoom</span><span>(</span><span>{</span> <span>roomId</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>message</span><span>,</span> <span>setMessage</span><span>]</span> = <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>function</span> <span>createOptions</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>{</span>
        <span>serverUrl</span><span>:</span> <span>serverUrl</span><span>,</span>
        <span>roomId</span><span>:</span> <span>roomId</span>
      <span>}</span><span>;</span>
    <span>}</span>

    <span>const</span> <span>options</span> = <span>createOptions</span><span>(</span><span>)</span><span>;</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>options</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>roomId</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span>Welcome to the <span>{</span><span>roomId</span><span>}</span> room!<span>&lt;/</span><span>h1</span><span>&gt;</span>
      <span>&lt;</span><span>input</span> <span>value</span>=<span>{</span><span>message</span><span>}</span> <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setMessage</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>roomId</span><span>,</span> <span>setRoomId</span><span>]</span> = <span>useState</span><span>(</span><span>'general'</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>label</span><span>&gt;</span>
        Choose the chat room:<span>{</span><span>' '</span><span>}</span>
        <span>&lt;</span><span>select</span>
          <span>value</span>=<span>{</span><span>roomId</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>e</span> <span>=&gt;</span> <span>setRoomId</span><span>(</span><span>e</span>.<span>target</span>.<span>value</span><span>)</span><span>}</span>
        <span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"general"</span><span>&gt;</span>general<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"travel"</span><span>&gt;</span>travel<span>&lt;/</span><span>option</span><span>&gt;</span>
          <span>&lt;</span><span>option</span> <span>value</span>=<span>"music"</span><span>&gt;</span>music<span>&lt;/</span><span>option</span><span>&gt;</span>
        <span>&lt;/</span><span>select</span><span>&gt;</span>
      <span>&lt;/</span><span>label</span><span>&gt;</span>
      <span>&lt;</span><span>hr</span> <span>/&gt;</span>
      <span>&lt;</span><span>ChatRoom</span> <span>roomId</span>=<span>{</span><span>roomId</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

</pre> <p>Now that you define the <code dir="ltr">createOptions</code> function inside the Effect, the Effect itself only depends on the <code dir="ltr">roomId</code> string. With this fix, typing into the input doesn’t reconnect the chat. Unlike a function which gets re-created, a string like <code dir="ltr">roomId</code> doesn’t change unless you set it to another value. <a href="../../learn/removing-effect-dependencies.html">Read more about removing dependencies.</a></p> <hr> <h3 id="reading-the-latest-props-and-state-from-an-effect">Reading the latest props and state from an Effect 
</h3> <div class="note note-orange">
<h4>Under Construction</h4>
<div><p>This section describes an <strong>experimental API that has not yet been released</strong> in a stable version of React.</p></div>
</div> <p>By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect “reacts” to every change of that value. For most dependencies, that’s the behavior you want.</p> <p><strong>However, sometimes you’ll want to read the <em>latest</em> props and state from an Effect without “reacting” to them.</strong> For example, imagine you want to log the number of the items in the shopping cart for every page visit:</p> <pre data-language="jsx"><code><span>function</span> <span>Page</span><span>(</span><span>{</span> <span>url</span><span>,</span> <span>shoppingCart</span> <span>}</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>logVisit</span><span>(</span><span>url</span><span>,</span> <span>shoppingCart</span>.<span>length</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>url</span><span>,</span> <span>shoppingCart</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span>
<span>}</span></code></pre> <p><strong>What if you want to log a new page visit after every <code dir="ltr">url</code> change, but <em>not</em> if only the <code dir="ltr">shoppingCart</code> changes?</strong> You can’t exclude <code dir="ltr">shoppingCart</code> from dependencies without breaking the <a href="#specifying-reactive-dependencies">reactivity rules.</a> However, you can express that you <em>don’t want</em> a piece of code to “react” to changes even though it is called from inside an Effect. <a href="../../learn/separating-events-from-effects.html#declaring-an-effect-event">Declare an <em>Effect Event</em></a> with the <a href="experimental_useeffectevent.html"><code dir="ltr">useEffectEvent</code></a> Hook, and move the code reading <code dir="ltr">shoppingCart</code> inside of it:</p> <pre data-language="jsx"><code><span>function</span> <span>Page</span><span>(</span><span>{</span> <span>url</span><span>,</span> <span>shoppingCart</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>onVisit</span> = <span>useEffectEvent</span><span>(</span><span>visitedUrl</span> <span>=&gt;</span> <span>{</span>
    <span>logVisit</span><span>(</span><span>visitedUrl</span><span>,</span> <span>shoppingCart</span>.<span>length</span><span>)</span>
  <span>}</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>onVisit</span><span>(</span><span>url</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>url</span><span>]</span><span>)</span><span>;</span> <span>// ✅ All dependencies declared</span>
  <span>// ...</span>
<span>}</span></code></pre> <p><strong>Effect Events are not reactive and must always be omitted from dependencies of your Effect.</strong> This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading <code dir="ltr">shoppingCart</code> inside of <code dir="ltr">onVisit</code>, you ensure that <code dir="ltr">shoppingCart</code> won’t re-run your Effect.</p> <p><a href="../../learn/separating-events-from-effects.html#reading-latest-props-and-state-with-effect-events">Read more about how Effect Events let you separate reactive and non-reactive code.</a></p> <hr> <h3 id="displaying-different-content-on-the-server-and-the-client">Displaying different content on the server and the client 
</h3> <p>If your app uses server rendering (either <a href="../react-dom/server.html">directly</a> or via a <a href="../../learn/start-a-new-react-project.html#production-grade-react-frameworks">framework</a>), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for <a href="../react-dom/client/hydrateroot.html#hydrating-server-rendered-html">hydration</a> to work, your initial render output must be identical on the client and the server.</p> <p>In rare cases, you might need to display different content on the client. For example, if your app reads some data from <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">localStorage</code></a>, it can’t possibly do that on the server. Here is how you could implement this:</p> <pre data-language="jsx"><code><span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>didMount</span><span>,</span> <span>setDidMount</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setDidMount</span><span>(</span><span>true</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>

  <span>if</span> <span>(</span><span>didMount</span><span>)</span> <span>{</span>
    <span>// ... return client-only JSX ...</span>
  <span>}</span>  <span>else</span> <span>{</span>
    <span>// ... return initial JSX ...</span>
  <span>}</span>
<span>}</span></code></pre> <p>While the app is loading, the user will see the initial render output. Then, when it’s loaded and hydrated, your Effect will run and set <code dir="ltr">didMount</code> to <code dir="ltr">true</code>, triggering a re-render. This will switch to the client-only render output. Effects don’t run on the server, so this is why <code dir="ltr">didMount</code> was <code dir="ltr">false</code> during the initial server render.</p> <p>Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time—potentially, many seconds—so you don’t want to make jarring changes to your component’s appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.</p> <hr> <h2 id="troubleshooting">Troubleshooting 
</h2> <h3 id="my-effect-runs-twice-when-the-component-mounts">My Effect runs twice when the component mounts 
</h3> <p>When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.</p> <p>This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a setup → cleanup → setup sequence (as in development).</p> <p>Read more about <a href="../../learn/synchronizing-with-effects.html#step-3-add-cleanup-if-needed">how this helps find bugs</a> and <a href="../../learn/synchronizing-with-effects.html#how-to-handle-the-effect-firing-twice-in-development">how to fix your logic.</a></p> <hr> <h3 id="my-effect-runs-after-every-re-render">My Effect runs after every re-render 
</h3> <p>First, check that you haven’t forgotten to specify the dependency array:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// ...</span>
<span>}</span><span>)</span><span>;</span> <span>// 🚩 No dependency array: re-runs after every render!</span></code></pre> <p>If you’ve specified the dependency array but your Effect still re-runs in a loop, it’s because one of your dependencies is different on every re-render.</p> <p>You can debug this problem by manually logging your dependencies to the console:</p> <pre data-language="jsx"><code>  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// ..</span>
  <span>}</span><span>,</span> <span>[</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>]</span><span>)</span><span>;</span>

  <span>console</span>.<span>log</span><span>(</span><span>[</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>]</span><span>)</span><span>;</span></code></pre> <p>You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as <code dir="ltr">temp1</code> and the second one got saved as <code dir="ltr">temp2</code>, you can then use the browser console to check whether each dependency in both arrays is the same:</p> <pre data-language="jsx"><code><span>Object</span>.<span>is</span><span>(</span><span>temp1</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>temp2</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span> <span>// Is the first dependency the same between the arrays?</span>
<span>Object</span>.<span>is</span><span>(</span><span>temp1</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>temp2</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span> <span>// Is the second dependency the same between the arrays?</span>
<span>Object</span>.<span>is</span><span>(</span><span>temp1</span><span>[</span><span>2</span><span>]</span><span>,</span> <span>temp2</span><span>[</span><span>2</span><span>]</span><span>)</span><span>;</span> <span>// ... and so on for every dependency ...</span></code></pre> <p>When you find the dependency that is different on every re-render, you can usually fix it in one of these ways:</p> <ul> <li><a href="#updating-state-based-on-previous-state-from-an-effect">Updating state based on previous state from an Effect</a></li> <li><a href="#removing-unnecessary-object-dependencies">Removing unnecessary object dependencies</a></li> <li><a href="#removing-unnecessary-function-dependencies">Removing unnecessary function dependencies</a></li> <li><a href="#reading-the-latest-props-and-state-from-an-effect">Reading the latest props and state from an Effect</a></li> </ul> <p>As a last resort (if these methods didn’t help), wrap its creation with <a href="usememo.html#memoizing-a-dependency-of-another-hook"><code dir="ltr">useMemo</code></a> or <a href="usecallback.html#preventing-an-effect-from-firing-too-often"><code dir="ltr">useCallback</code></a> (for functions).</p> <hr> <h3 id="my-effect-keeps-re-running-in-an-infinite-cycle">My Effect keeps re-running in an infinite cycle 
</h3> <p>If your Effect runs in an infinite cycle, these two things must be true:</p> <ul> <li>Your Effect is updating some state.</li> <li>That state leads to a re-render, which causes the Effect’s dependencies to change.</li> </ul> <p>Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application’s data flow with it?</p> <p>If there is no external system, consider whether <a href="../../learn/you-might-not-need-an-effect.html">removing the Effect altogether</a> would simplify your logic.</p> <p>If you’re genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component’s visual output? If you need to keep track of some data that isn’t used by rendering, a <a href="useref.html#referencing-a-value-with-a-ref">ref</a> (which doesn’t trigger re-renders) might be more appropriate. Verify your Effect doesn’t update the state (and trigger re-renders) more than needed.</p> <p>Finally, if your Effect is updating the state at the right time, but there is still a loop, it’s because that state update leads to one of the Effect’s dependencies changing. <a href="useeffect.html#my-effect-runs-after-every-re-render">Read how to debug dependency changes.</a></p> <hr> <h3 id="my-cleanup-logic-runs-even-though-my-component-didnt-unmount">My cleanup logic runs even though my component didn’t unmount 
</h3> <p>The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React <a href="#my-effect-runs-twice-when-the-component-mounts">runs setup+cleanup one extra time immediately after component mounts.</a></p> <p>If you have cleanup code without corresponding setup code, it’s usually a code smell:</p> <pre data-language="jsx"><code><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// 🔴 Avoid: Cleanup logic without corresponding setup logic</span>
  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>doSomething</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span></code></pre> <p>Your cleanup logic should be “symmetrical” to the setup logic, and should stop or undo whatever setup did:</p> <pre data-language="jsx"><code>  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>connection</span> = <span>createConnection</span><span>(</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>)</span><span>;</span>
    <span>connection</span>.<span>connect</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>connection</span>.<span>disconnect</span><span>(</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>serverUrl</span><span>,</span> <span>roomId</span><span>]</span><span>)</span><span>;</span></code></pre> <p><a href="../../learn/lifecycle-of-reactive-effects.html#the-lifecycle-of-an-effect">Learn how the Effect lifecycle is different from the component’s lifecycle.</a></p> <hr> <h3 id="my-effect-does-something-visual-and-i-see-a-flicker-before-it-runs">My Effect does something visual, and I see a flicker before it runs 
</h3> <p>If your Effect must block the browser from <a href="../../learn/render-and-commit.html#epilogue-browser-paint">painting the screen,</a> replace <code dir="ltr">useEffect</code> with <a href="uselayouteffect.html"><code dir="ltr">useLayoutEffect</code></a>. Note that <strong>this shouldn’t be needed for the vast majority of Effects.</strong> You’ll only need this if it’s crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013&ndash;present Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://react.dev/reference/react/useEffect" class="_attribution-link">https://react.dev/reference/react/useEffect</a>
  </p>
</div>
