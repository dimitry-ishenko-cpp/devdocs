<h1>renderToReadableStream
</h1>
<div>
<p><code dir="ltr">renderToReadableStream</code> renders a React tree to a <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" target="_blank" rel="nofollow noopener noreferrer">Readable Web Stream.</a></p>
<pre data-language="jsx"><code><span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>reactNode</span><span>,</span> <span>options</span>?<span>)</span></code></pre>
</div> <ul>
<li>
<a href="#reference">Reference </a><ul><li><a href="#rendertoreadablestream"><code dir="ltr">renderToReadableStream(reactNode, options?)</code> </a></li></ul>
</li>
<li>
<a href="#usage">Usage </a><ul>
<li><a href="#rendering-a-react-tree-as-html-to-a-readable-web-stream">Rendering a React tree as HTML to a Readable Web Stream </a></li>
<li><a href="#streaming-more-content-as-it-loads">Streaming more content as it loads </a></li>
<li><a href="#specifying-what-goes-into-the-shell">Specifying what goes into the shell </a></li>
<li><a href="#logging-crashes-on-the-server">Logging crashes on the server </a></li>
<li><a href="#recovering-from-errors-inside-the-shell">Recovering from errors inside the shell </a></li>
<li><a href="#recovering-from-errors-outside-the-shell">Recovering from errors outside the shell </a></li>
<li><a href="#setting-the-status-code">Setting the status code </a></li>
<li><a href="#handling-different-errors-in-different-ways">Handling different errors in different ways </a></li>
<li><a href="#waiting-for-all-content-to-load-for-crawlers-and-static-generation">Waiting for all content to load for crawlers and static generation </a></li>
<li><a href="#aborting-server-rendering">Aborting server rendering </a></li>
</ul>
</li>
</ul> <div class="note note-green">
<h4>Note</h4>
<div><p>This API depends on <a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API" target="_blank" rel="nofollow noopener noreferrer">Web Streams.</a> For Node.js, use <a href="rendertopipeablestream.html"><code dir="ltr">renderToPipeableStream</code></a> instead.</p></div>
</div> <hr> <h2 id="reference">Reference 
</h2> <h3 id="rendertoreadablestream">
<code dir="ltr">renderToReadableStream(reactNode, options?)</code> 
</h3> <p>Call <code dir="ltr">renderToReadableStream</code> to render your React tree as HTML into a <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" target="_blank" rel="nofollow noopener noreferrer">Readable Web Stream.</a></p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>renderToReadableStream</span> <span>}</span> <span>from</span> <span>'react-dom/server'</span><span>;</span>

<span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>/&gt;</span><span>,</span> <span>{</span>
    <span>bootstrapScripts</span><span>:</span> <span>[</span><span>'/main.js'</span><span>]</span>
  <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
    <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span></code></pre> <p>On the client, call <a href="../client/hydrateroot.html"><code dir="ltr">hydrateRoot</code></a> to make the server-generated HTML interactive.</p> <p><a href="#usage">See more examples below.</a></p> <h4 id="parameters">Parameters 
</h4> <ul> <li> <p><code dir="ltr">reactNode</code>: A React node you want to render to HTML. For example, a JSX element like <code dir="ltr">&lt;App /&gt;</code>. It is expected to represent the entire document, so the <code dir="ltr">App</code> component should render the <code dir="ltr">&lt;html&gt;</code> tag.</p> </li> <li> <p><strong>optional</strong> <code dir="ltr">options</code>: An object with streaming options.</p> <ul> <li>
<strong>optional</strong> <code dir="ltr">bootstrapScriptContent</code>: If specified, this string will be placed in an inline <code dir="ltr">&lt;script&gt;</code> tag.</li> <li>
<strong>optional</strong> <code dir="ltr">bootstrapScripts</code>: An array of string URLs for the <code dir="ltr">&lt;script&gt;</code> tags to emit on the page. Use this to include the <code dir="ltr">&lt;script&gt;</code> that calls <a href="../client/hydrateroot.html"><code dir="ltr">hydrateRoot</code>.</a> Omit it if you don’t want to run React on the client at all.</li> <li>
<strong>optional</strong> <code dir="ltr">bootstrapModules</code>: Like <code dir="ltr">bootstrapScripts</code>, but emits <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">&lt;script type="module"&gt;</code></a> instead.</li> <li>
<strong>optional</strong> <code dir="ltr">identifierPrefix</code>: A string prefix React uses for IDs generated by <a href="../../react/useid.html"><code dir="ltr">useId</code>.</a> Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to <a href="../client/hydrateroot.html#parameters"><code dir="ltr">hydrateRoot</code>.</a>
</li> <li>
<strong>optional</strong> <code dir="ltr">namespaceURI</code>: A string with the root <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS#important_namespace_uris" target="_blank" rel="nofollow noopener noreferrer">namespace URI</a> for the stream. Defaults to regular HTML. Pass <code dir="ltr">'http://www.w3.org/2000/svg'</code> for SVG or <code dir="ltr">'http://www.w3.org/1998/Math/MathML'</code> for MathML.</li> <li>
<strong>optional</strong> <code dir="ltr">nonce</code>: A <a target="_blank" rel="nofollow noopener noreferrer" href="http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#nonce"><code dir="ltr">nonce</code></a> string to allow scripts for <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">script-src</code> Content-Security-Policy</a>.</li> <li>
<strong>optional</strong> <code dir="ltr">onError</code>: A callback that fires whenever there is a server error, whether <a href="#recovering-from-errors-outside-the-shell">recoverable</a> or <a href="#recovering-from-errors-inside-the-shell">not.</a> By default, this only calls <code dir="ltr">console.error</code>. If you override it to <a href="#logging-crashes-on-the-server">log crash reports,</a> make sure that you still call <code dir="ltr">console.error</code>. You can also use it to <a href="#setting-the-status-code">adjust the status code</a> before the shell is emitted.</li> <li>
<strong>optional</strong> <code dir="ltr">progressiveChunkSize</code>: The number of bytes in a chunk. <a href="https://github.com/facebook/react/blob/14c2be8dac2d5482fda8a0906a31d239df8551fc/packages/react-server/src/ReactFizzServer.js#L210-L225" target="_blank" rel="nofollow noopener noreferrer">Read more about the default heuristic.</a>
</li> <li>
<strong>optional</strong> <code dir="ltr">signal</code>: An <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal" target="_blank" rel="nofollow noopener noreferrer">abort signal</a> that lets you <a href="#aborting-server-rendering">abort server rendering</a> and render the rest on the client.</li> </ul> </li> </ul> <h4 id="returns">Returns 
</h4> <p><code dir="ltr">renderToReadableStream</code> returns a Promise:</p> <ul> <li>If rendering the <a href="#specifying-what-goes-into-the-shell">shell</a> is successful, that Promise will resolve to a <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" target="_blank" rel="nofollow noopener noreferrer">Readable Web Stream.</a>
</li> <li>If rendering the shell fails, the Promise will be rejected. <a href="#recovering-from-errors-inside-the-shell">Use this to output a fallback shell.</a>
</li> </ul> <p>The returned stream has an additional property:</p> <ul> <li>
<code dir="ltr">allReady</code>: A Promise that resolves when all rendering is complete, including both the <a href="#specifying-what-goes-into-the-shell">shell</a> and all additional <a href="#streaming-more-content-as-it-loads">content.</a> You can <code dir="ltr">await stream.allReady</code> before returning a response <a href="#waiting-for-all-content-to-load-for-crawlers-and-static-generation">for crawlers and static generation.</a> If you do that, you won’t get any progressive loading. The stream will contain the final HTML.</li> </ul> <hr> <h2 id="usage">Usage 
</h2> <h3 id="rendering-a-react-tree-as-html-to-a-readable-web-stream">Rendering a React tree as HTML to a Readable Web Stream 
</h3> <p>Call <code dir="ltr">renderToReadableStream</code> to render your React tree as HTML into a <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" target="_blank" rel="nofollow noopener noreferrer">Readable Web Stream:</a></p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>renderToReadableStream</span> <span>}</span> <span>from</span> <span>'react-dom/server'</span><span>;</span>

<span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;App /&gt;</span><span>,</span> <span>{</span>
    <span>bootstrapScripts</span><span>:</span> <span>['/main.js']</span>
  <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
    <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span></code></pre> <p>Along with the <span data-step="1">root component</span>, you need to provide a list of <span data-step="2">bootstrap <code dir="ltr">&lt;script&gt;</code> paths</span>. Your root component should return <strong>the entire document including the root <code dir="ltr">&lt;html&gt;</code> tag.</strong></p> <p>For example, it might look like this:</p> <pre data-language="jsx"><code><span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>html</span><span>&gt;</span>
      <span>&lt;</span><span>head</span><span>&gt;</span>
        <span>&lt;</span><span>meta</span> <span>charSet</span>=<span>"utf-8"</span> <span>/&gt;</span>
        <span>&lt;</span><span>meta</span> <span>name</span>=<span>"viewport"</span> <span>content</span>=<span>"width=device-width, initial-scale=1"</span> <span>/&gt;</span>
        <span>&lt;</span><span>link</span> <span>rel</span>=<span>"stylesheet"</span> <span>href</span>=<span>"/styles.css"</span><span>&gt;</span><span>&lt;/</span><span>link</span><span>&gt;</span>
        <span>&lt;</span><span>title</span><span>&gt;</span>My app<span>&lt;/</span><span>title</span><span>&gt;</span>
      <span>&lt;/</span><span>head</span><span>&gt;</span>
      <span>&lt;</span><span>body</span><span>&gt;</span>
        <span>&lt;</span><span>Router</span> <span>/&gt;</span>
      <span>&lt;/</span><span>body</span><span>&gt;</span>
    <span>&lt;/</span><span>html</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre> <p>React will inject the <a href="https://developer.mozilla.org/en-US/docs/Glossary/Doctype" target="_blank" rel="nofollow noopener noreferrer">doctype</a> and your <span data-step="2">bootstrap <code dir="ltr">&lt;script&gt;</code> tags</span> into the resulting HTML stream:</p> <pre data-language="jsx"><code>&lt;!DOCTYPE html&gt;
<span>&lt;</span><span>html</span><span>&gt;</span>
  <span>&lt;!-- ... HTML from your components ... --&gt;</span>
<span>&lt;/</span><span>html</span><span>&gt;</span>
<span>&lt;</span><span>script</span> <span>src</span>=<span>"</span><span>/main.js</span><span>"</span> <span>async</span>=<span>""</span><span>&gt;</span><span>&lt;/</span><span>script</span><span>&gt;</span></code></pre> <p>On the client, your bootstrap script should <a href="../client/hydrateroot.html#hydrating-an-entire-document">hydrate the entire <code dir="ltr">document</code> with a call to <code dir="ltr">hydrateRoot</code>:</a></p> <pre data-language="jsx"><code><span>import</span> <span>{</span> <span>hydrateRoot</span> <span>}</span> <span>from</span> <span>'react-dom/client'</span><span>;</span>
<span>import</span> <span>App</span> <span>from</span> <span>'./App.js'</span><span>;</span>

<span>hydrateRoot</span><span>(</span><span>document</span><span>,</span> <span>&lt;App /&gt;</span><span>)</span><span>;</span></code></pre> <p>This will attach event listeners to the server-generated HTML and make it interactive.</p> <details class="note note-blue"><summary tabindex="-1"><h5>
Deep Dive</h5>
<h4 id="reading-css-and-js-asset-paths-from-the-build-output">Reading CSS and JS asset paths from the build output 
</h4></summary><div>
<p>The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of <code dir="ltr">styles.css</code> you might end up with <code dir="ltr">styles.123456.css</code>. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.</p>
<p>However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding <code dir="ltr">"/styles.css"</code> into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:</p>
<pre data-language="jsx"><code><span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>{</span> <span>assetMap</span> <span>}</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>html</span><span>&gt;</span>
      <span>&lt;</span><span>head</span><span>&gt;</span>
        <span>&lt;</span><span>title</span><span>&gt;</span>My app<span>&lt;/</span><span>title</span><span>&gt;</span>
        <span>&lt;</span><span>link</span> <span>rel</span>=<span>"stylesheet"</span> <span>href</span>=<span>{</span><span>assetMap</span><span>[</span><span>'styles.css'</span><span>]</span><span>}</span><span>&gt;</span><span>&lt;/</span><span>link</span><span>&gt;</span>
      <span>&lt;/</span><span>head</span><span>&gt;</span>
      ...
    <span>&lt;/</span><span>html</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre>
<p>On the server, render <code dir="ltr">&lt;App assetMap={assetMap} /&gt;</code> and pass your <code dir="ltr">assetMap</code> with the asset URLs:</p>
<pre data-language="jsx"><code><span>// You'd need to get this JSON from your build tooling, e.g. read it from the build output.</span>
<span>const</span> <span>assetMap</span> = <span>{</span>
  <span>'styles.css'</span><span>:</span> <span>'/styles.123456.css'</span><span>,</span>
  <span>'main.js'</span><span>:</span> <span>'/main.123456.js'</span>
<span>}</span><span>;</span>

<span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>assetMap</span>=<span>{</span><span>assetMap</span><span>}</span> <span>/&gt;</span><span>,</span> <span>{</span>
    <span>bootstrapScripts</span><span>:</span> <span>[</span><span>assetMap</span><span>[</span><span>'/main.js'</span><span>]</span><span>]</span>
  <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
    <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span></code></pre>
<p>Since your server is now rendering <code dir="ltr">&lt;App assetMap={assetMap} /&gt;</code>, you need to render it with <code dir="ltr">assetMap</code> on the client too to avoid hydration errors. You can serialize and pass <code dir="ltr">assetMap</code> to the client like this:</p>
<pre data-language="jsx"><code><span>// You'd need to get this JSON from your build tooling.</span>
<span>const</span> <span>assetMap</span> = <span>{</span>
  <span>'styles.css'</span><span>:</span> <span>'/styles.123456.css'</span><span>,</span>
  <span>'main.js'</span><span>:</span> <span>'/main.123456.js'</span>
<span>}</span><span>;</span>

<span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>assetMap</span>=<span>{</span><span>assetMap</span><span>}</span> <span>/&gt;</span><span>,</span> <span>{</span>
    <span>// Careful: It's safe to stringify() this because this data isn't user-generated.</span>
    <span>bootstrapScriptContent</span><span>:</span> <span>`window.assetMap = </span><span>${</span><span>JSON</span>.<span>stringify</span><span>(</span><span>assetMap</span><span>)</span><span>}</span><span>;`</span><span>,</span>
    <span>bootstrapScripts</span><span>:</span> <span>[</span><span>assetMap</span><span>[</span><span>'/main.js'</span><span>]</span><span>]</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
    <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span></code></pre>
<p>In the example above, the <code dir="ltr">bootstrapScriptContent</code> option adds an extra inline <code dir="ltr">&lt;script&gt;</code> tag that sets the global <code dir="ltr">window.assetMap</code> variable on the client. This lets the client code read the same <code dir="ltr">assetMap</code>:</p>
<pre data-language="jsx"><code><span>import</span> <span>{</span> <span>hydrateRoot</span> <span>}</span> <span>from</span> <span>'react-dom/client'</span><span>;</span>
<span>import</span> <span>App</span> <span>from</span> <span>'./App.js'</span><span>;</span>

<span>hydrateRoot</span><span>(</span><span>document</span><span>,</span> <span>&lt;</span><span>App</span> <span>assetMap</span>=<span>{</span><span>window</span>.<span>assetMap</span><span>}</span> <span>/&gt;</span><span>)</span><span>;</span></code></pre>
<p>Both client and server render <code dir="ltr">App</code> with the same <code dir="ltr">assetMap</code> prop, so there are no hydration errors.</p>
</div></details> <hr> <h3 id="streaming-more-content-as-it-loads">Streaming more content as it loads 
</h3> <p>Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:</p> <pre data-language="jsx"><code><span>function</span> <span>ProfilePage</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>ProfileLayout</span><span>&gt;</span>
      <span>&lt;</span><span>ProfileCover</span> <span>/&gt;</span>
      <span>&lt;</span><span>Sidebar</span><span>&gt;</span>
        <span>&lt;</span><span>Friends</span> <span>/&gt;</span>
        <span>&lt;</span><span>Photos</span> <span>/&gt;</span>
      <span>&lt;/</span><span>Sidebar</span><span>&gt;</span>
      <span>&lt;</span><span>Posts</span> <span>/&gt;</span>
    <span>&lt;/</span><span>ProfileLayout</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre> <p>Imagine that loading data for <code dir="ltr">&lt;Posts /&gt;</code> takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this, <a href="../../react/suspense.html#displaying-a-fallback-while-content-is-loading">wrap <code dir="ltr">Posts</code> in a <code dir="ltr">&lt;Suspense&gt;</code> boundary:</a></p> <pre data-language="jsx"><code><span>function</span> <span>ProfilePage</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>ProfileLayout</span><span>&gt;</span>
      <span>&lt;</span><span>ProfileCover</span> <span>/&gt;</span>
      <span>&lt;</span><span>Sidebar</span><span>&gt;</span>
        <span>&lt;</span><span>Friends</span> <span>/&gt;</span>
        <span>&lt;</span><span>Photos</span> <span>/&gt;</span>
      <span>&lt;/</span><span>Sidebar</span><span>&gt;</span>
      <span>&lt;</span><span>Suspense</span> <span>fallback</span>=<span>{</span><span>&lt;</span><span>PostsGlimmer</span> <span>/&gt;</span><span>}</span><span>&gt;</span>
        <span>&lt;</span><span>Posts</span> <span>/&gt;</span>
      <span>&lt;/</span><span>Suspense</span><span>&gt;</span>
    <span>&lt;/</span><span>ProfileLayout</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre> <p>This tells React to start streaming the HTML before <code dir="ltr">Posts</code> loads its data. React will send the HTML for the loading fallback (<code dir="ltr">PostsGlimmer</code>) first, and then, when <code dir="ltr">Posts</code> finishes loading its data, React will send the remaining HTML along with an inline <code dir="ltr">&lt;script&gt;</code> tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with the <code dir="ltr">PostsGlimmer</code>, later replaced by the <code dir="ltr">Posts</code>.</p> <p>You can further <a href="../../react/suspense.html#revealing-nested-content-as-it-loads">nest <code dir="ltr">&lt;Suspense&gt;</code> boundaries</a> to create a more granular loading sequence:</p> <pre data-language="jsx"><code><span>function</span> <span>ProfilePage</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>ProfileLayout</span><span>&gt;</span>
      <span>&lt;</span><span>ProfileCover</span> <span>/&gt;</span>
      <span>&lt;</span><span>Suspense</span> <span>fallback</span>=<span>{</span><span>&lt;</span><span>BigSpinner</span> <span>/&gt;</span><span>}</span><span>&gt;</span>
        <span>&lt;</span><span>Sidebar</span><span>&gt;</span>
          <span>&lt;</span><span>Friends</span> <span>/&gt;</span>
          <span>&lt;</span><span>Photos</span> <span>/&gt;</span>
        <span>&lt;/</span><span>Sidebar</span><span>&gt;</span>
        <span>&lt;</span><span>Suspense</span> <span>fallback</span>=<span>{</span><span>&lt;</span><span>PostsGlimmer</span> <span>/&gt;</span><span>}</span><span>&gt;</span>
          <span>&lt;</span><span>Posts</span> <span>/&gt;</span>
        <span>&lt;/</span><span>Suspense</span><span>&gt;</span>
      <span>&lt;/</span><span>Suspense</span><span>&gt;</span>
    <span>&lt;/</span><span>ProfileLayout</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre> <p>In this example, React can start streaming the page even earlier. Only <code dir="ltr">ProfileLayout</code> and <code dir="ltr">ProfileCover</code> must finish rendering first because they are not wrapped in any <code dir="ltr">&lt;Suspense&gt;</code> boundary. However, if <code dir="ltr">Sidebar</code>, <code dir="ltr">Friends</code>, or <code dir="ltr">Photos</code> need to load some data, React will send the HTML for the <code dir="ltr">BigSpinner</code> fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.</p> <p>Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <code dir="ltr">&lt;script&gt;</code> tags load.</p> <p><a href="https://github.com/reactwg/react-18/discussions/37" target="_blank" rel="nofollow noopener noreferrer">Read more about how streaming HTML works.</a></p> <div class="note note-green">
<h4>Note</h4>
<div>
<p><strong>Only Suspense-enabled data sources will activate the Suspense component.</strong> They include:</p>
<ul> <li>Data fetching with Suspense-enabled frameworks like <a href="https://relay.dev/docs/guided-tour/rendering/loading-states/" target="_blank" rel="nofollow noopener noreferrer">Relay</a> and <a href="https://nextjs.org/docs/getting-started/react-essentials" target="_blank" rel="nofollow noopener noreferrer">Next.js</a>
</li> <li>Lazy-loading component code with <a href="../../react/lazy.html"><code dir="ltr">lazy</code></a>
</li> <li>Reading the value of a Promise with <a href="../../react/use.html"><code dir="ltr">use</code></a>
</li> </ul>
<p>Suspense <strong>does not</strong> detect when data is fetched inside an Effect or event handler.</p>
<p>The exact way you would load data in the <code dir="ltr">Posts</code> component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.</p>
<p>Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.</p>
</div>
</div> <hr> <h3 id="specifying-what-goes-into-the-shell">Specifying what goes into the shell 
</h3> <p>The part of your app outside of any <code dir="ltr">&lt;Suspense&gt;</code> boundaries is called <em>the shell:</em></p> <pre data-language="jsx"><code><span>function</span> <span>ProfilePage</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>ProfileLayout</span><span>&gt;</span>
      <span>&lt;</span><span>ProfileCover</span> <span>/&gt;</span>
      <span>&lt;</span><span>Suspense</span> <span>fallback</span>=<span>{</span><span>&lt;</span><span>BigSpinner</span> <span>/&gt;</span><span>}</span><span>&gt;</span>
        <span>&lt;</span><span>Sidebar</span><span>&gt;</span>
          <span>&lt;</span><span>Friends</span> <span>/&gt;</span>
          <span>&lt;</span><span>Photos</span> <span>/&gt;</span>
        <span>&lt;/</span><span>Sidebar</span><span>&gt;</span>
        <span>&lt;</span><span>Suspense</span> <span>fallback</span>=<span>{</span><span>&lt;</span><span>PostsGlimmer</span> <span>/&gt;</span><span>}</span><span>&gt;</span>
          <span>&lt;</span><span>Posts</span> <span>/&gt;</span>
        <span>&lt;/</span><span>Suspense</span><span>&gt;</span>
      <span>&lt;/</span><span>Suspense</span><span>&gt;</span>
    <span>&lt;/</span><span>ProfileLayout</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre> <p>It determines the earliest loading state that the user may see:</p> <pre data-language="jsx"><code><span>&lt;</span><span>ProfileLayout</span><span>&gt;</span>
  <span>&lt;</span><span>ProfileCover</span> <span>/&gt;</span>
  <span>&lt;</span><span>BigSpinner</span> <span>/&gt;</span>
<span>&lt;/</span><span>ProfileLayout</span><span>&gt;</span></code></pre> <p>If you wrap the whole app into a <code dir="ltr">&lt;Suspense&gt;</code> boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the <code dir="ltr">&lt;Suspense&gt;</code> boundaries so that the shell feels <em>minimal but complete</em>—like a skeleton of the entire page layout.</p> <p>The async call to <code dir="ltr">renderToReadableStream</code> will resolve to a <code dir="ltr">stream</code> as soon as the entire shell has been rendered. Usually, you’ll start streaming then by creating and returning a response with that <code dir="ltr">stream</code>:</p> <pre data-language="jsx"><code><span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>/&gt;</span><span>,</span> <span>{</span>
    <span>bootstrapScripts</span><span>:</span> <span>[</span><span>'/main.js'</span><span>]</span>
  <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
    <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span></code></pre> <p>By the time the <code dir="ltr">stream</code> is returned, components in nested <code dir="ltr">&lt;Suspense&gt;</code> boundaries might still be loading data.</p> <hr> <h3 id="logging-crashes-on-the-server">Logging crashes on the server 
</h3> <p>By default, all errors on the server are logged to console. You can override this behavior to log crash reports:</p> <pre data-language="jsx"><code><span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>/&gt;</span><span>,</span> <span>{</span>
    <span>bootstrapScripts</span><span>:</span> <span>[</span><span>'/main.js'</span><span>]</span><span>,</span>
    <span>onError</span><span>(</span><span>error</span><span>)</span> <span>{</span>
      <span>console</span>.<span>error</span><span>(</span><span>error</span><span>)</span><span>;</span>
      <span>logServerCrashReport</span><span>(</span><span>error</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
    <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span></code></pre> <p>If you provide a custom <code dir="ltr">onError</code> implementation, don’t forget to also log errors to the console like above.</p> <hr> <h3 id="recovering-from-errors-inside-the-shell">Recovering from errors inside the shell 
</h3> <p>In this example, the shell contains <code dir="ltr">ProfileLayout</code>, <code dir="ltr">ProfileCover</code>, and <code dir="ltr">PostsGlimmer</code>:</p> <pre data-language="jsx"><code><span>function</span> <span>ProfilePage</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>ProfileLayout</span><span>&gt;</span>
      <span>&lt;</span><span>ProfileCover</span> <span>/&gt;</span>
      <span>&lt;</span><span>Suspense</span> <span>fallback</span>=<span>{</span><span>&lt;</span><span>PostsGlimmer</span> <span>/&gt;</span><span>}</span><span>&gt;</span>
        <span>&lt;</span><span>Posts</span> <span>/&gt;</span>
      <span>&lt;/</span><span>Suspense</span><span>&gt;</span>
    <span>&lt;/</span><span>ProfileLayout</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre> <p>If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Wrap your <code dir="ltr">renderToReadableStream</code> call in a <code dir="ltr">try...catch</code> to send a fallback HTML that doesn’t rely on server rendering as the last resort:</p> <pre data-language="jsx"><code><span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>/&gt;</span><span>,</span> <span>{</span>
      <span>bootstrapScripts</span><span>:</span> <span>[</span><span>'/main.js'</span><span>]</span><span>,</span>
      <span>onError</span><span>(</span><span>error</span><span>)</span> <span>{</span>
        <span>console</span>.<span>error</span><span>(</span><span>error</span><span>)</span><span>;</span>
        <span>logServerCrashReport</span><span>(</span><span>error</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
      <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>'&lt;h1&gt;Something went wrong&lt;/h1&gt;'</span><span>,</span> <span>{</span>
      <span>status</span><span>:</span> <span>500</span><span>,</span>
      <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>If there is an error while generating the shell, both <code dir="ltr">onError</code> and your <code dir="ltr">catch</code> block will fire. Use <code dir="ltr">onError</code> for error reporting and use the <code dir="ltr">catch</code> block to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.</p> <hr> <h3 id="recovering-from-errors-outside-the-shell">Recovering from errors outside the shell 
</h3> <p>In this example, the <code dir="ltr">&lt;Posts /&gt;</code> component is wrapped in <code dir="ltr">&lt;Suspense&gt;</code> so it is <em>not</em> a part of the shell:</p> <pre data-language="jsx"><code><span>function</span> <span>ProfilePage</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>ProfileLayout</span><span>&gt;</span>
      <span>&lt;</span><span>ProfileCover</span> <span>/&gt;</span>
      <span>&lt;</span><span>Suspense</span> <span>fallback</span>=<span>{</span><span>&lt;</span><span>PostsGlimmer</span> <span>/&gt;</span><span>}</span><span>&gt;</span>
        <span>&lt;</span><span>Posts</span> <span>/&gt;</span>
      <span>&lt;/</span><span>Suspense</span><span>&gt;</span>
    <span>&lt;/</span><span>ProfileLayout</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre> <p>If an error happens in the <code dir="ltr">Posts</code> component or somewhere inside it, React will <a href="../../react/suspense.html#providing-a-fallback-for-server-errors-and-client-only-content">try to recover from it:</a></p> <ol> <li>It will emit the loading fallback for the closest <code dir="ltr">&lt;Suspense&gt;</code> boundary (<code dir="ltr">PostsGlimmer</code>) into the HTML.</li> <li>It will “give up” on trying to render the <code dir="ltr">Posts</code> content on the server anymore.</li> <li>When the JavaScript code loads on the client, React will <em>retry</em> rendering <code dir="ltr">Posts</code> on the client.</li> </ol> <p>If retrying rendering <code dir="ltr">Posts</code> on the client <em>also</em> fails, React will throw the error on the client. As with all the errors thrown during rendering, the <a href="../../react/component.html#static-getderivedstatefromerror">closest parent error boundary</a> determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.</p> <p>If retrying rendering <code dir="ltr">Posts</code> on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server <code dir="ltr">onError</code> callback and the client <a href="../client/hydrateroot.html#hydrateroot"><code dir="ltr">onRecoverableError</code></a> callbacks will fire so that you can get notified about the error.</p> <hr> <h3 id="setting-the-status-code">Setting the status code 
</h3> <p>Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.</p> <p>By <a href="#specifying-what-goes-into-the-shell">dividing your app</a> into the shell (above all <code dir="ltr">&lt;Suspense&gt;</code> boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, your <code dir="ltr">catch</code> block will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.</p> <pre data-language="jsx"><code><span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>/&gt;</span><span>,</span> <span>{</span>
      <span>bootstrapScripts</span><span>:</span> <span>[</span><span>'/main.js'</span><span>]</span><span>,</span>
      <span>onError</span><span>(</span><span>error</span><span>)</span> <span>{</span>
        <span>console</span>.<span>error</span><span>(</span><span>error</span><span>)</span><span>;</span>
        <span>logServerCrashReport</span><span>(</span><span>error</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
      <span>status</span><span>:</span> <span>200</span><span>,</span>
      <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>'&lt;h1&gt;Something went wrong&lt;/h1&gt;'</span><span>,</span> <span>{</span>
      <span>status</span><span>:</span> <span>500</span><span>,</span>
      <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>If a component <em>outside</em> the shell (i.e. inside a <code dir="ltr">&lt;Suspense&gt;</code> boundary) throws an error, React will not stop rendering. This means that the <code dir="ltr">onError</code> callback will fire, but your code will continue running without getting into the <code dir="ltr">catch</code> block. This is because React will try to recover from that error on the client, <a href="#recovering-from-errors-outside-the-shell">as described above.</a></p> <p>However, if you’d like, you can use the fact that something has errored to set the status code:</p> <pre data-language="jsx"><code><span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>let</span> <span>didError</span> = <span>false</span><span>;</span>
    <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>/&gt;</span><span>,</span> <span>{</span>
      <span>bootstrapScripts</span><span>:</span> <span>[</span><span>'/main.js'</span><span>]</span><span>,</span>
      <span>onError</span><span>(</span><span>error</span><span>)</span> <span>{</span>
        <span>didError</span> = <span>true</span><span>;</span>
        <span>console</span>.<span>error</span><span>(</span><span>error</span><span>)</span><span>;</span>
        <span>logServerCrashReport</span><span>(</span><span>error</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
      <span>status</span><span>:</span> <span>didError</span> ? <span>500</span> : <span>200</span><span>,</span>
      <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>'&lt;h1&gt;Something went wrong&lt;/h1&gt;'</span><span>,</span> <span>{</span>
      <span>status</span><span>:</span> <span>500</span><span>,</span>
      <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.</p> <hr> <h3 id="handling-different-errors-in-different-ways">Handling different errors in different ways 
</h3> <p>You can <a href="https://javascript.info/custom-errors" target="_blank" rel="nofollow noopener noreferrer">create your own <code dir="ltr">Error</code> subclasses</a> and use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">instanceof</code></a> operator to check which error is thrown. For example, you can define a custom <code dir="ltr">NotFoundError</code> and throw it from your component. Then you can save the error in <code dir="ltr">onError</code> and do something different before returning the response depending on the error type:</p> <pre data-language="jsx"><code><span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>let</span> <span>didError</span> = <span>false</span><span>;</span>
  <span>let</span> <span>caughtError</span> = <span>null</span><span>;</span>

  <span>function</span> <span>getStatusCode</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>didError</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>caughtError</span> <span>instanceof</span> <span>NotFoundError</span><span>)</span> <span>{</span>
        <span>return</span> <span>404</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>500</span><span>;</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>return</span> <span>200</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>try</span> <span>{</span>
    <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>/&gt;</span><span>,</span> <span>{</span>
      <span>bootstrapScripts</span><span>:</span> <span>[</span><span>'/main.js'</span><span>]</span><span>,</span>
      <span>onError</span><span>(</span><span>error</span><span>)</span> <span>{</span>
        <span>didError</span> = <span>true</span><span>;</span>
        <span>caughtError</span> = <span>error</span><span>;</span>
        <span>console</span>.<span>error</span><span>(</span><span>error</span><span>)</span><span>;</span>
        <span>logServerCrashReport</span><span>(</span><span>error</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
      <span>status</span><span>:</span> <span>getStatusCode</span><span>(</span><span>)</span><span>,</span>
      <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>'&lt;h1&gt;Something went wrong&lt;/h1&gt;'</span><span>,</span> <span>{</span>
      <span>status</span><span>:</span> <span>getStatusCode</span><span>(</span><span>)</span><span>,</span>
      <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>Keep in mind that once you emit the shell and start streaming, you can’t change the status code.</p> <hr> <h3 id="waiting-for-all-content-to-load-for-crawlers-and-static-generation">Waiting for all content to load for crawlers and static generation 
</h3> <p>Streaming offers a better user experience because the user can see the content as it becomes available.</p> <p>However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.</p> <p>You can wait for all the content to load by awaiting the <code dir="ltr">stream.allReady</code> Promise:</p> <pre data-language="jsx"><code><span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>let</span> <span>didError</span> = <span>false</span><span>;</span>
    <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>/&gt;</span><span>,</span> <span>{</span>
      <span>bootstrapScripts</span><span>:</span> <span>[</span><span>'/main.js'</span><span>]</span><span>,</span>
      <span>onError</span><span>(</span><span>error</span><span>)</span> <span>{</span>
        <span>didError</span> = <span>true</span><span>;</span>
        <span>console</span>.<span>error</span><span>(</span><span>error</span><span>)</span><span>;</span>
        <span>logServerCrashReport</span><span>(</span><span>error</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>let</span> <span>isCrawler</span> = <span>// ... depends on your bot detection strategy ...</span>
    <span>if</span> <span>(</span><span>isCrawler</span><span>)</span> <span>{</span>
      <span>await</span> <span>stream</span>.<span>allReady</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>stream</span><span>,</span> <span>{</span>
      <span>status</span><span>:</span> <span>didError</span> ? <span>500</span> : <span>200</span><span>,</span>
      <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>'&lt;h1&gt;Something went wrong&lt;/h1&gt;'</span><span>,</span> <span>{</span>
      <span>status</span><span>:</span> <span>500</span><span>,</span>
      <span>headers</span><span>:</span> <span>{</span> <span>'content-type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre> <p>A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for <em>all</em> data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.</p> <hr> <h3 id="aborting-server-rendering">Aborting server rendering 
</h3> <p>You can force the server rendering to “give up” after a timeout:</p> <pre data-language="jsx"><code><span>async</span> <span>function</span> <span>handler</span><span>(</span><span>request</span><span>)</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>const</span> <span>controller</span> = <span>new</span> <span>AbortController</span><span>(</span><span>)</span><span>;</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>controller</span>.<span>abort</span><span>(</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>10000</span><span>)</span><span>;</span>

    <span>const</span> <span>stream</span> = <span>await</span> <span>renderToReadableStream</span><span>(</span><span>&lt;</span><span>App</span> <span>/&gt;</span><span>,</span> <span>{</span>
      <span>signal</span><span>:</span> <span>controller</span>.<span>signal</span><span>,</span>
      <span>bootstrapScripts</span><span>:</span> <span>[</span><span>'/main.js'</span><span>]</span><span>,</span>
      <span>onError</span><span>(</span><span>error</span><span>)</span> <span>{</span>
        <span>didError</span> = <span>true</span><span>;</span>
        <span>console</span>.<span>error</span><span>(</span><span>error</span><span>)</span><span>;</span>
        <span>logServerCrashReport</span><span>(</span><span>error</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>// ...</span></code></pre> <p>React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013&ndash;present Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://react.dev/reference/react-dom/server/renderToReadableStream" class="_attribution-link">https://react.dev/reference/react-dom/server/renderToReadableStream</a>
  </p>
</div>
