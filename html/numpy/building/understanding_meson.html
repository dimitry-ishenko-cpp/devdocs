<section id="understanding-meson"> <h1>Understanding Meson</h1> <p>Building NumPy relies on the following tools, which can be considered part of the build system:</p> <ul class="simple"> <li>
<code>meson</code>: the Meson build system, installable as a pure Python package from PyPI or conda-forge</li> <li>
<code>ninja</code>: the build tool invoked by Meson to do the actual building (e.g. invoking compilers). Installable also from PyPI (on all common platforms) or conda-forge.</li> <li>
<code>pkg-config</code>: the tool used for discovering dependencies (in particular BLAS/LAPACK). Available on conda-forge (and Homebrew, Chocolatey, and Linux package managers), but not packaged on PyPI.</li> <li>
<code>meson-python</code>: the Python build backend (i.e., the thing that gets invoked via a hook in <code>pyproject.toml</code> by a build frontend like <code>pip</code> or <code>pypa/build</code>). This is a thin layer on top of Meson, with as main roles (a) interface with build frontends, and (b) produce sdists and wheels with valid file names and metadata.</li> </ul> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>As of Dec’23, NumPy vendors a custom version of Meson, which is needed for SIMD and BLAS/LAPACK features that are not yet available in upstream Meson. Hence, using the <code>meson</code> executable directly is not possible. Instead, wherever instructions say <code>meson xxx</code>, use <code>python
vendored-meson/meson/meson.py xxx</code> instead.</p> </div> <p>Building with Meson happens in stages:</p> <ul class="simple"> <li>A configure stage (<code>meson setup</code>) to detect compilers, dependencies and build options, and create the build directory and <code>build.ninja</code> file,</li> <li>A compile stage (<code>meson compile</code> or <code>ninja</code>), where the extension modules that are part of a built NumPy package get compiled,</li> <li>An install stage (<code>meson install</code>) to install the installable files from the source and build directories to the target install directory,</li> </ul> <p>Meson has a good build dependency tracking system, so invoking a build for a second time will rebuild only targets for which any sources or dependencies have changed.</p> <section id="to-learn-more-about-meson"> <h2>To learn more about Meson</h2> <p>Meson has <a class="reference external" href="https://mesonbuild.com/">very good documentation</a>; it pays off to read it, and is often the best source of answers for “how to do X”. Furthermore, an extensive pdf book on Meson can be obtained for free at <a class="reference external" href="https://nibblestew.blogspot.com/2021/12/this-year-receive-gift-of-free-meson.html">https://nibblestew.blogspot.com/2021/12/this-year-receive-gift-of-free-meson.html</a></p> <p>To learn more about the design principles Meson uses, the recent talks linked from <a class="reference external" href="https://mesonbuild.com/Videos.html">mesonbuild.com/Videos</a> are also a good resource.</p> </section> <section id="explanation-of-build-stages"> <h2>Explanation of build stages</h2> <p><em>This is for teaching purposes only; there should be no need to execute these stages separately!</em></p> <p>Assume we’re starting from a clean repo and a fully set up conda environment:</p> <pre data-language="python">git clone git@github.com:numpy/numpy.git
git submodule update --init
mamba env create -f environment.yml
mamba activate numpy-dev
</pre> <p>To now run the configure stage of the build and instruct Meson to put the build artifacts in <code>build/</code> and a local install under <code>build-install/</code> relative to the root of the repo, do:</p> <pre data-language="python">meson setup build --prefix=$PWD/build-install
</pre> <p>To then run the compile stage of the build, do:</p> <pre data-language="python">ninja -C build
</pre> <p>In the command above, <code>-C</code> is followed by the name of the build directory. You can have multiple build directories at the same time. Meson is fully out-of-place, so those builds will not interfere with each other. You can for example have a GCC build, a Clang build and a debug build in different directories.</p> <p>To then install NumPy into the prefix (<code>build-install/</code> here, but note that that’s just an arbitrary name we picked here):</p> <pre data-language="python">meson install -C build
</pre> <p>It will then install to <code>build-install/lib/python3.11/site-packages/numpy</code>, which is not on your Python path, so to add it do (<em>again, this is for learning purposes, using ``PYTHONPATH`` explicitly is typically not the best idea</em>):</p> <pre data-language="python">export PYTHONPATH=$PWD/build-install/lib/python3.11/site-packages/
</pre> <p>Now we should be able to import <code>numpy</code> and run the tests. Remembering that we need to move out of the root of the repo to ensure we pick up the package and not the local <code>numpy/</code> source directory:</p> <pre data-language="python">cd doc
python -c "import numpy as np; np.test()"
</pre> <p>The above runs the “fast” numpy test suite. Other ways of running the tests should also work, for example:</p> <pre data-language="python">pytest --pyargs numpy
</pre> <p>The full test suite should pass, without any build warnings on Linux (with the GCC version for which <code>-Werror</code> is enforced in CI at least) and with at most a moderate amount of warnings on other platforms.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/building/understanding_meson.html" class="_attribution-link">https://numpy.org/doc/2.0/building/understanding_meson.html</a>
  </p>
</div>
