<section id="numpy-security"> <h1>NumPy security</h1> <p>Security issues can be reported privately as described in the project README and when opening a <a class="reference external" href="https://github.com/numpy/numpy/issues/new/choose">new issue on the issue tracker</a>. The <a class="reference external" href="https://www.python.org/dev/security/">Python security reporting guidelines</a> are a good resource and its notes apply also to NumPy.</p> <p>NumPy’s maintainers are not security experts. However, we are conscientious about security and experts of both the NumPy codebase and how it’s used. Please do notify us before creating security advisories against NumPy as we are happy to prioritize issues or help with assessing the severity of a bug. A security advisory we are not aware of beforehand can lead to a lot of work for all involved parties.</p> <section id="advice-for-using-numpy-on-untrusted-data"> <h2>Advice for using NumPy on untrusted data</h2> <p>A user who can freely execute NumPy (or Python) functions must be considered to have the same privilege as the process/Python interpreter.</p> <p>That said, NumPy should be generally safe to use on <em>data</em> provided by unprivileged users and read through safe API functions (e.g. loaded from a text file or <code>.npy</code> file without pickle support). Malicious <em>values</em> or <em>data sizes</em> should never lead to privilege escalation. Note that the above refers to array data. We do not currently consider for example <code>f2py</code> to be safe: it is typically used to compile a program that is then run. Any <code>f2py</code> invocation must thus use the same privilege as the later execution.</p> <p>The following points may be useful or should be noted when working with untrusted data:</p> <ul class="simple"> <li>
<p>Exhausting memory can result in an out-of-memory kill, which is a possible denial of service attack. Possible causes could be:</p> <ul> <li>Functions reading text files, which may require much more memory than the original input file size.</li> <li>If users can create arbitrarily shaped arrays, NumPy’s broadcasting means that intermediate or result arrays can be much larger than the inputs.</li> </ul> </li> <li>NumPy structured dtypes allow for a large amount of complexity. Fortunately, most code fails gracefully when a structured dtype is provided unexpectedly. However, code should either disallow untrusted users to provide these (e.g. via <code>.npy</code> files) or carefully check the fields included for nested structured/subarray dtypes.</li> <li>Passing on user input should generally be considered unsafe (except for the data being read). An example would be <code>np.dtype(user_string)</code> or <code>dtype=user_string</code>.</li> <li>The speed of operations can depend on values and memory order can lead to larger temporary memory use and slower execution. This means that operations may be significantly slower or use more memory compared to simple test cases.</li> <li>When reading data, consider enforcing a specific shape (e.g. one dimensional) or dtype such as <code>float64</code>, <code>float32</code>, or <code>int64</code> to reduce complexity.</li> </ul> <p>When working with non-trivial untrusted data, it is advisable to sandbox the analysis to guard against potential privilege escalation. This is especially advisable if further libraries based on NumPy are used since these add additional complexity and potential security issues.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2024 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/2.0/reference/security.html" class="_attribution-link">https://numpy.org/doc/2.0/reference/security.html</a>
  </p>
</div>
